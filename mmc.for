c     program mmca(input,output)
c#    MMC routine   1 lstmod: 02/26/24
c*****Force-bias Metropolis Monte Carlo program for molecular solvation
c     in the canonical, grand-canonical and isothermal-isobaric ensembles,
c     including analysis based on the Proximity Criterion and the calculation
c     of generic sites.
c
c     Written by Mihaly Mezei (at Hunter College, CUNY, 1977-1991)
c                                 (with David L. Beveridge from 1977-1986)
c                             (at Mount Sinai School of Medicine, 1991- )
c     Code contributed by
c          Prem K. Mehrotra, B. Jayaram and Peter V. Maye (at Hunter College);
c     and by
c          Haluk Resat, Pal Jedlovszky, Jian Sun, Monika Fuxreiter,
c          Tom Joseph and Meng Cui (at Mount Sinai);
c     IBM minimizer (retyped and slightly modified)
c     Numerical Recipes routines for solving a system of linear equations and
c                                for finding matrix eigenvectors/values
c     Mersenne twister code Copyright 1997 Makoto Matsumoto & Takuji Nishimura
c              Fortran version by  Hiroshi Takano
c
c     Address:   Department of Structural and Chemical Biology
c                Mount Sinai School of Medicine
c                New York, N.Y. 10029.
c     E-mail:    Mihaly.Mezei@mssm.edu/
c
c-------------------------- Dimensioning -------------------------------
c     The symbols in the dimension statements have to be changed
c     The changes can be conveniently done by the preprocessor program pre.f
c  1 #MO - maxmol     : maximum no of solvent molecules +1 (keep it even)
c  2 #MA - maxatmol   : maximum no of atoms per  ingle solute molecule
c  3 #SX - mxpxslt    : maximum no of solute atoms for proximity analysis
c  4 #MM - maxsltmol  : maximum no of solute molecules
c  5 #UW - maxwnnu    : maximum no of words for solute neighbour bit list
c  6 #TN - maxnst     : maximum no of nuclei on solute (EPEN/QPEN)
c  7 #VN - maxnsv     : maximum no of nuclei on solvent (EPEN/QPEN)
c  8 #TE - maxest     : maximum no of electrons on solute (EPEN/QPEN)
c  9 #VE - maxesv     : maximum no of electrons on solvent (EPEN/QPEN)
c 10 #LS - maxloopslt : when loop moves are active, maxslt, otherwise 1
c 11 #VW - maxwnnv    : maximum no of words for solvent neighbour bit list
c 12 #ST - maxslt     : maximum no of solute centers (all copies)
c 13 #GR - maxgslt    : maximum no of solute groups (all copies)
c 14 #TA - maxtslt    : maximum no of solute centers for torsion option
c                       (must be EVEN!)
c 15 #SV - maxslv     : maximum no of solvent centers/solvent
c 16 #VT - maxss      : greater of #SV and #ST
c 17 #NA - maxat      : maximum no of centers (atoms and pseudoatoms)
c 18 #TL - mxtrgrgr   : maximum no of solute groups within torsion groups
c 19 #GT - maxstg     : maximum no of solute centers interacting with a
c                       general solvent
c 20 #GV - maxsvg     : maximum no of solvent centers in a general solvent
c 21 #DT - maxsst     : maximum no of solute centers for parameter sensitivity
c                       calculation or energy decomposition over a trajectory
c 22 #DM - maxmst     : maximum no of molecules for parameter sensitivity
c                       calculation
c 23 #RG - maxgrid    : maximum no of proximity slt-slv g(r) grid-points
c 24 #PG - maxpfgr    : maximum no of preferential sampling grid points
c 25 #WG - maxcggr    : number of grids for the coupling parameter distribution
c 26 #OR - maxorgr    : number of grids for the energy difference distributions
c 27 #GX - maxxgr     : maximum no of grids in the x dir for grid search
c 28 #GY - maxygr     : maximum no of grids in the y dir for grid search
c 29 #GZ - maxzgr     : maximum no of grids in the z dir for grid search
c 30 #CV - maxcav     : maximum no of cavities
c 31 #W2 - maxlin     : #WI*(#WI+1) (AUS fit workspace)
c 32 #WS - maxausp    : #WI*#WG/2+1 : size of storage array for individual
c                       probability distributions
c 33 #WI - maxauit    : maximum no of iterations allowed for adaptive us + 1
c 34 #MI - maxavit    : maximum no of block average entries
c 35 #TR - maxtors    : maximum no of torsions
c 36 #AT - maxatyp    : maximum no of atom types the program can store
c 37 #UU - maxatypu   : maximum no of atom types in a given solute
c 38 #UV - maxstmol   : greatest of #MO, #ST, #MH,  and 32
c 39 #TG - maxtgrid   : maximum no of total g(r) grid points
c 40 #VG - maxwrgrid  : maximum no of grid points for
c                       solvent-solvent g(r)
c 41 #ND - maxgvv     : maximum no of solvent-solvent rdf's
c 42 #DG - maxdrgrid  : maximum no of radial grid points for dipole
c                       correlation QCDF
c 43 #LG - maxdagrid  : maximum no of angular grid points for dipole
c                       correlation QCDF
c 44 #GE - maxpegrid  : maximum no of energy grid points for solute-solvent
c                       PE QCDF
c 45 #GQ - mxpxgslt   : maximum no of different QCDF's
c 46 #PP - maxcavps   : maximum no of cavities with pref. sampl. weights
c 47 #PS - maxpfsum   : maximum no of preferential sampling weight sub sums
c 48 #WM - maxmatch   : maximum no of AUS runs to match
c 49 #TD - maxtagrid  : maximum no of torsion angle distribution grids
c 50 #FE - mxfeslt    : maximum no of free energy solute atoms
c 51 #MH - maxhunsite : maximum no sites for Hungarian method matching
c 52 #LT - mxlooptor  : maximum no of torsion loops
c 53 #MD - mxdiffmol  : maximum no of molecules for diffusion constant and
c                       residence time calculations
c 54 #DC - mxdiffcr   : maximum no of structures in diffusion calc
c 55 #RC - mxrescr    : maximum no of structures/nbits in residence time calc
c 56 #MW - maxwidslt  : maximum no of Widom solutes
c 57 #MS - maxphsmol  : maximum no of molecules for primary hydration shell
c 58 #NH - maxhmneig  : maximum no of potential neighbors for a generic site
c 59 #MG - maxmolfg   : maximum no of molecules for solvent-site fg calc
c 60 #HA - maxath     : greater of maxat & maxslt+maxhunsite*maxslv
c 61 #GM - maxmapgrid : maximum no of grids in an energy map
c 62 #GH - maxhbgrid  : maximum no of grids in the hydrogen-bond map
c 63 #NE - maxatsave  : maximum no of atoms for minimum energy save
c 64 #AU - maxaucsave : maximum no of torsions to save for AUC calculation
c 65 #GC - maxgrdclst : maximum no of grid clusters for cavity/pocket calc
c 66 #RN - maxrangdinp: maximum no of random numbers to read and store
c 67 #NL - maxnnlist  : maximum no of 1st + 2nd + 3rd neighbors
c 68 #NS - maxsitehb  : maximum no of sites h bonded to a solute residue
c*****Perform all initial tasks before the main MC loop
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /slfttolerance/ tol(10),tolr(10),told(10)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /oldedge/ exyzo(3),ionemessage
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
C@FG      real*8 fguuacc,fguvacc,fgvuacc,fgvvacc,fgusacc,fgvsacc
      common /fieldgrad/
C@FG     -  fguuacc(6,#MM,#GQ),fguvacc(6,#MM,#GQ),
C@FG     -  fgusacc(6,#MM),fgvsacc(6,#MG),fgvuacc(6,#MG,#GQ),
C@FG     -  fgvvacc(6,#MG,#GQ),nusedfgr(#MO),
     -  fgruucut,fgruvcut,fgrvvcut,rproxfgmax,
     -  fgruucut2,fgruvcut2,fgrvvcut2,rproxfgmax2
      real*8 eiess,ei12s,ei6s,eiRs,eies14s,ei614s,ei1214s,eiR14s,
     -  eiesws,ei6ws,ei12ws,eiRws,eiess2,ei12s2,ei6s2,eiRs2,eies14s2,
     -  ei614s2,ei1214s2,eiR14s2,eiesws2,ei6ws2,ei12ws2,eiRws2,
     -  eiessg2,ei12sg2,ei6sg2,eies14sg2,ei614sg2,ei1214sg2,
     -  gvesg2,gv6g2,gv12g2,nnbs2,ntvs2
      common /engdec/ eiess(#DT,2),ei12s(#DT,2),ei6s(#DT,2),
     -  eies14s(#DT,2),ei614s(#DT,2),ei1214s(#DT,2),
     -  eiesws(#DT),ei6ws(#DT),ei12ws(#DT),
     -  eiess2(#DT),ei12s2(#DT),ei6s2(#DT),
     -  eies14s2(#DT),ei614s2(#DT),ei1214s2(#DT),
     -  eiessg2(#DT,2),ei12sg2(#DT,2),ei6sg2(#DT,2),
     -  eies14sg2(#DT,2),ei614sg2(#DT,2),ei1214sg2(#DT,2),
     -  gvesg2(#DT),gv6g2(#DT),gv12g2(#DT),
     -  eiRws(#DT),eiR14s(#DT),eiRs(#DT),eiRs2(#DT),
     -  eiR14s2(#DT),eiesws2(#DT),ei6ws2(#DT),ei12ws2(#DT),
     -  eiRws2(#DT),nnbs2(#DT),ntvs2(#DT),
     -  n14s2(#DT),nnbs(#DT),n14s(#DT),ntvs(#DT),
     -  iexcludetyp,iafrst,ialast,igf,igl,
     -  iafrst2,ialast2,igf2,igl2,ctonnb,ctonnb2,ctdiff3,shfr,swr
      character*80 ident
      common /title/ nlident,ident(2)
      common /wadaptf/ ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,rldvmx,
     -  diffmx,tolera,iopnrm,iopeql,iopenc,nitssk,nwtst,nsubmn,ngovmn,
     -  ngrcor,negitdel
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*80 scratchpath
      common /localdisk/ lscratchpath,scratchpath
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /oldio/ ifold(10),ifsaved
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /fblam/ wfblam(#PG),rfblam(9),afblam(9),nfblam
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      real*8 ucsm_prev,u_prev,uslt_prev,uttnb_prev,uinnb_prev
      common /anneal/ ucsm_prev,u_prev,uslt_prev,uttnb_prev,
     -  uinnb_prev,nmctempstep,ntemplist,ntempstep,ntempsteptot,
     -  ntempstepcum,isannread,templist(100),temp0,tempstep,tempexp,
     -  tempfin
      common /anneal_cp/ nmcsacpstep,nmcsacpsteppnmol,maxbsave,
     -  nstep_ann,nmcav0,nligsave(500),avgligsave(500),bsave(500),
     -  bincr,cav_fract_lim
      real*8 ew0nb,teslt1,teslt1n,uwnb,uwnbn,uwnbmin,uwnbmax,
     -  etsincr
      common /nonboltz/ ew0nb,teslt1,teslt1n,
     -  uwnb,uwnbn,uwnbmin,uwnbmax,etsincr,tornbfac,repnbfac,slttmp,
     -  sltsltfac,signincfac,tsexp,tsfac
      common /tdstate/ press,pressv,ba,temp,beta
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /fieldpot/ niparf,nrparf,niparm,nrparm,intf(10),intm(10),
     -  rf(10),rm(10)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*4 labslt,labslv,namslv,pfl4
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /overlay/ covref(3,#ST),rangerad,ixovref(#ST),
     -  icrefok,ixrefok,irangetyp,novuse
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      common /dijdiff/ n12diff(20),n13diff(20)
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      real*8 rstack,rix,rira,rirb
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
      common /lcg_const/ lcg_fac,lcg_add,lcg_seed,lcg_modexp,lcg_mod,i31
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ediffsm,ediffsm2,expediffsm
      common /virtvolcha/ ediffsm,ediffsm2,expediffsm,ediffmn,ediffmx,
     -  volchaperc,volchafac(3),volchadiff(3),delvvol,delvarea
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /energymap/ engmap(#GM,#GM,#GM,10),gridmapcent(3),
     -  nemap,ngridmap,gridmap,edgemap,edgemap2,scalemap,evdwlim,
     -  elstatmin,hbgrid,gridedgeinc(3),egridmin(3),egridmax(3),
     -  mapedone,nhbgrid,maxhbng,maxhbgrid,maptyph,
     -  nhbaccng(#GH,#GH,#GH),nhbdonng(#GH,#GH,#GH),
     -  ihbng(25,#GH,#GH,#GH)
      common /griderror/ ngriderr,nhbgriderr,igridprint,griderrmax
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
CJJ   variables
      real*8 setpoint,gain_n,gain_den,integraltime,oldpv,controlerror,
     -  dbetadt,dpvdt
      common /control/ setpoint,gain_n,gain_den,integraltime,oldpv,
     -  controlerror,dbetadt,dpvdt
      real*8 rnsumprev,uavcorprev,delndelbsum
      common /tuneb/ rnsumprev(2),uavcorprev,delndelbsum,nitconv,
     -  nunphys,nmctunskip,nmctunave,nmclastch,ntune,nmccorprev,
     -  ndelndelbsum,inorout,targetden,targetn,tolden,toln,delndelb0,
     -  rnaviprev,baprev,chabmax,pv
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /cplp358/ cpl358(8,3),cq358(8,3),ixcpl(8)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /tpn/ edgexyz0(3),edge2xyz0(3),rinscr0(3),vol0,cic0(3,27),
     -  dex0(5),dey0(5),dez0(5),chexdx0(2),chexy0(2),dexhex0(5),vrange,
     -  volfac(3),vlam,vlamt,vvlmt,vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyy,
     -  vvlmtzz,vvlmtyz,complfac,sqcomplfac,ixyzfreeze(3),iscaletyplast
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /pretrans/ preshift(3),prerot(3,3),ipretrans
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      real*8 eminsave,eminhsave
      common /mine/ eminsave,eminhsave,cminsave(3,#NE),
     -  cminhsave(3,#NE),nmcminsave,nmcminhsave,natomssave,
     -  natomshsave,nminsave,nminhsave
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /ecell/ cic(3,27),ncell
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /howfar/ dtot(#MI,2),decay(#MI,2),nhowfar,nhowfarsamp
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),c1(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /bondmod/ nmake,imake(2,250),nbreak,ibreak(2,250),nhhb,nhrb
      common /stow/ clstfin_dmax,cvfilt_stow,froccmin_stow,rmsdlim_stow,
     -  subreground,nclust_clstfin,maxclstmem_stow
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
C@NL      logical irtd
      common /residt/ timestep,aucmin,nzerosignore,irtd(#RC,#GQ,#MD)
      common /torauc/ nmctorauc,ntorsaved,ntaucprint,nauc(#AU),
     -  tauc_timestep,tauc_min,torsave(#AU,#TR),auctor(#AU,#TR)
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      common /rfsavg/ iwrfs(#GQ),rkpdbmin,rkgrmin,r2kgrmin,rtkgrmin
      common /frslvr/ fsrad(#AT,11)
      Real*8 xtlabc
      common /charmm/ xtlabc(6),icntrlr(20),icntrlw(20),nfreatr,nfreatw,
     -  ichopen,ifree(#NA)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      character*4 namfcg
      character*20 nmlfcg
      common /fcgnam/ igrdup(100),namfcg(100,2),nmlfcg(100,2)
      common /fcgdatpx/ fcgavg(101,12),sdev2(101,11),ndupfg(100),nfge
      common /mcydat/ qq,dqq,a1,a2,a3,a4,b1,b2,b3,b4,ab1,ab2,ab3,ab4,qqq
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /ljprint/ ipflibprint,iprtlibcomb
      common /selfindex/ indexself(#UV)
      character*3 terend(2)
      character*36 datainfo(30)
      common /pdbinfo/ ntabcol,npxcol,nothercol,terend,datainfo
      character*17 formatnames
      common /trajform/ formatnames(11)
      common /trajhead/ etoth,eslth,bparh,modelnumh,ietoth,ibparh
      character*3 namunit
      common /extnames/ namunit(50)
      character*1 charlist
      common /characters/ charlist(52)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /cellshift/ ncross(27)
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /cutinr/ rwwina,rwwin2
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      character*80 rngfile
      common /rnglist/ rnolist(#RN),nrand,irand,lrngfile,rngfile
      common /option/ iop(200),idebug(200)
      character*80 line
      common /inpline/ line,lineno,icol
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      character*80 titline
      common /trajtit/ ntitline,titline(32)
      character*1 lxyz
      common /names/ lxyz(3)
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      common /timing/ ireset_tim,ncount_st,iday_st,month_st,iexit,nmcrun
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /liga/ ligand_start_molecule,last_slt_mol_g
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
C@DM      real*8 tesi_inp,tesi_out
C@DM      common /MPI_PERS/ tesi_inp(2),tesi_out(2)
C@DM      real*8 mpi_time,mpi_time_st
C@DM      common /MPI_TIM/ mpi_time,mpi_time_st(64),mpi_start
C@dc      character*4 labcall
C@dc      common /testprint/ labcall
      character*4 key,key0,key1,key2,key3,key4,key5,prevkey,atnam,
     -  resnam,keyw,mainkey(200),keys01(1000),prereq(500),forbid(500),
     -  newlist(100),forbidk0(200),any4,nodupwrn(100),noerrr(200),
     -  iopkeylist(4,200),mcy(2),tip3(5),tip4(4),tip5(2),pmli(3),
     -  pmf2(6),pmf3(3),cmpc(3),cmpc1(2),pmf4(3),rckp1(2),gcen1(3),
     -  gcen2(2),gcen3(2),gcen4(4),tord1(3),pfs1(3),pxcr1(3),pxcr2(4),
     -  filt(10),filt1(5),pdbg(21),iben(3),dstc(2),cnfg2(4),cnfg3(5),
     -  traj(3),traj1(4),traj2(3),prac(2),slft(5),pxww(2),pxgr1(3),
     -  pxgr2(3),pxpr1(2),pxpr2(4),pxpr3(2),readwrite(2),slta1(4),
     -  slta2(2),wcnf(14),chimd(4), addw(2),gens2(2),gens3(7),gens4(9),
     -  gens5(6),gens6(5),phs(3),prtg(2),prtg2(4),engl(3),engl2(2),
     -  fldg(2),loop(4),tiqu(3),wmat(4),wmat2(2),wmat3(3),idag(2),
     -  stun(5),framefilt(2),supi1(2),gsao(3),gsao1(3),gsan(4),cnst(2)
C@PG      character*4 cpoc(2),cpoc1(2)
      character*6 any6
      dimension ndummyu(200),keyforbid(200),noerror(200),
     -  iopkey(3,200),ifkey1(200),nkey1(200),iurefc(100),ifpass(2),
     -  nodupwarn(200),d0(3),ixfit(3),isltdellim(2,250),ilpass(2),
     -  islvdellim(2,250),crmslt(3),crm00(3),edgn(3),tiinteg(50),
     -  iunitnos(10),icompoptr(40),iasizer(70),ianatdtyp(100),dipmom(3),
     -  iafltrange(2,50),iaflxrange(2,50),iaflxneig(2,50),matchrun(#WM),
     -  iformiop9(11),iformiop47(5),itypeiop47(5),keycol(2),
     -  nruncnfi(100),islvkeep(#MO),idontypdef(10),iacctypdef(10),
     -  ntbond(2,20),ifirsts(#MH),ilasts(#MH),iclsts(#MH),
     -  igsanaltyp(7),ixrep3slt(3),ir12(2)
      dimension grll(3),grlu(3),gre(3),elgr(3),ergr(3),lgrl(3),lgru(3),
     -  gcent(3),gll(3),glu(3),xyzmin(3),xyzmax(3),center(3),cc(3),
     -  ort(3,3),cm(3),cx(3),tunstpmndef(4),tunstpmxdef(4)
      character*10 moddater,cmoddater
      real*8 d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,uusfac,atwsuminp,
     -  rno(1),avgvolg,avgvolg2
      character*1 gcnt,mcnt,sltchainid
      character*2 mapfiles(10)
      character*4 segid,atname,ntbond,pftyp,sltinptyp,r8vsr16,pfl1,
     -  pfl2,addlab
      character*6 pfl,pfll
      character*5 aorg(2)
      character*80 filename1,filename2,filenameslt,datalab,stuff
      data mapfiles /'pc','pa','pn','po','pp','ps','ph','pd',2*'  '/
      data ianatdtyp /7,4*0,1,3,4,6*0,5,6,84*0/
c     iatdatnos is initialized in the block data
      data ndummyu /200*0/,keyforbid /200*0/,iopkey /600*0/,
     -  nodupwarn /200*0/,noerror /200*0/,iformiop47 /0,1,0,0,0/,
     -  iformiop9 /1,1,1,0,0,1,0,0,0,0,1/,itypeiop47 /13,13,13,15,18/,
     -  nurefc /0/,nrcnfi /0/,ifc14read /0/,idontypdef /1,2,8*0/,
     -  iacctypdef /1,2,8*0/
      data rpxdivi /0.0/,rpxwwdivi /0.0/,rgpxsltmax /0.0/,
     -  rgpxwwmax /0.0/,tunstpmndef /4*0.0/,
     -  tunstpmxdef /10.0,3*180.0/
      data prevkey /'    '/,key0 /'    '/,atnam /'    '/,
     -  resnam /'    '/,sltchainid /'M'/,aorg /'atom ','group'/
      data nodupwrn /'PRNT','TRAJ','WTRA','CNFG','RCKP','WCNF',
     -  'WCKP','FILE','FCGA','CMPC','ENGL','DENF','DBUG','FILT','WPLT',
     -  'GENS','PLCV','TORT','LPST','GENT','SETC','OUTP','STUN','TAC0',
     -  'AROM','HBMO','STSC','CPOC','GSAN','PFRD',70*'    '/
      data noerrr /'PRTG','FILT','GENS','STVG','GENV',195*'    '/
c    '****' closes the auxiliary key list for each key
c    '    ' as the first auxiliary key will allow setting the first
c    nonblank as the default
      data keys01    /'TITL','****',
     -  'PRNT','NECH','ECHO','DETL','DBUG','MPIP','****',
     -  'HRDW','SCLR','VC32','VC64','****',
     -  'STOP','    ','SLFT','NOSF','****','TEMP','****','FETK','****',
     -  'PBCN','RECT','FCC ','HCP ','TOCT','HEXG','SPHR','PHS ','READ',
     -  '****','SANN','NONE','LINE','EXPO','LOG ','LIST','****',
     -  'SUPT','CLMG','EPEN','AM02','AM94','CHRM','GR87','GR96','OPLS',
     -  'HSPH','ATNO','DUMM','****','SACP','FIXS','SCLS','****',
     -  'SVPT','MCY ','TIP3','TIP4','TIP5','GENL','****','STOL','****',
     -  'SLTA','SMPL','POLY','XTAL','****',
     -  'SLFT','    ','BASC','FULL','ALL ','DEFL','****',
     -  'CHRG','ZERO','INPT','****','RMOD','****',
     -  'PFRD','CHRM','OPLS','****','PMOD','CLMG','EPEN',
     -  'AM02','AM94','CHRM','GR87','GR96','OPLS','HSPH','****',
     -  'SAMP','METC','METS','METX','METR','    ','FBPR','FBSC','****',
     -  'STUN','TRAN','ROTA','TORS','LOOP','****',
     -  'TAC0','TRAN','ROTA','TORS','LOOP','****',
     -  'STEP','****','TDIS','UNIF','2DIM','3DIM','****',
     -  'INCT','NONE','EXPL','****','MIXR','GEGE','ARGE','****',
     -  'SUVC','SPCC','MICC','ISOE','SPGC','MIGC','****',
     -  'SVVC','SPCC','MINI','****','SIZE','****',
     -  'SUUC','NONE','MIMC','SPMC','MIGC','SPGC','****','NSLV','****',
     -  'MOVE','RAND','CYCL','SHCY','CYCI','PRSL','PRSP','PRSE','****',
     -  'MVRT','BOTH','STAL','SVAL','TVAL','****',
     -  'FREE','WIDO','CHIM','ADDW','XXXX','TICA','PMLI','PMF1','PMNL',
     -  '****','SLVA','****',
     -  'PARD','UNIF','EXBI','EXBQ','EXBA','EBMA','EBQA','****',
     -  'PART','UNIF','EXBI','EXBQ','EXBA','EBMA','EBQA','****',
     -  'TORD','INPT','ALL ','RDBB','ALBB','****','SWAP','****',
     -  'SPSM','****',
     -  'TRAJ','NONE','ALLE','ALLV','XXXX','ALLC','ALLA','ALLB','ALLP',
     -  'ALLM','ALLH','AMBR','CHRM','****','WTRA','UNCH','STCT','SHCT',
     -  '****','SENS','****','FCGD','STND','INTO','INTG','****',
     -  'GCEN','OFF ','CAVB','CVBF','UNBI','****','PDBT','INPT','REGU',
     -  'LEFT','****','MINE','NONE','TRAJ','ALLC','WANN','WANF','****',
     -  'CNFG','READ','RPSU','RPUV','RANC','RANI','PMFN','RPUU','TRAJ',
     -  'RDEX','****','DSTP','ALL ','GRKC','NONE','ALLC','GKCC','****',
     -  'SCAL','****','DSTC','NONE','SOME','ALL ','****',
     -  'SCRM','****','RCKP','    ','STPD','IGND','FIXD','FXDI','****',
     -  'STPD','IGND','FIXD','****','RUNS','****',
     -  'WCNF','ASCI','BNRY','ASAN','AMBT','PDB ','PDBO',
     -  'PDBD','PDBG','PDBQ','PDTD','PDTG','CHRM','CHRD','****',
     -  'TIQU','DATA','REGL','LIST','****','WMAT','REGL','LIST','****',
     -  'OVRA','****','OPTN','****','DBUG','****','WCKP','****',
     -  'SCKP','****','NFBU','****','NMVP','****','STPS','****',
     -  'EPLT','UICV','UIUT','****','CPOC','CVTY','PCKT','****',
     -  'TEST','CPLW','FSLT','FSTT','FSLV','PBCT','EIJT','****',
     -  'PLBP','USED','ALL ','CMBU','CMBA','SNGL','****',
     -  'PRPL','NONE','CPLD','UICV','CONV','ALL ','****',
     -  'RAUS','NOIN','CTIN','ALIN','****','PROT','****','CHKP','****',
     -  'PRTG','NOLP','PDB ','CHRM','ASAN','****',
     -  'PRFI','NONE','PRSL','PRSP','PRSE','****','STVG','****',
     -  'FILT','SOLV','GEOM','NMBR','ENRG','FRAM','****',
     -  'PRCO','    ','NOSA','SAVE','SVMN','****',
     -  'DENF','PDB ','CHRM','INSG','****','FCGA','ALL ','OERR','****',
     -  'OVST','****','PRMF','****','IGTT','CALC','NOCA','****',
     -  'SPST','NONE','EMAP','CMAP','CMPW','BLCK','****','SPPS','****',
     -  'MV2S','UNIF','EXBI','EXBQ','EXBA','EBMA','EBQA','****',
     -  'CLON','****','MAKB','****','BRKB','****','BDHH','****',
     -  'BDRH','****','FIXD','STPD','IGND','FIXD','FXDI',
     -  '****','BLKW','****',
     -  'REGE','****','RMCK','****','PRAC','SUMR','INDI','NTRY','****',
     -  'SPRD','****','IBEN','OFF ','UNIF','VB3D','VB1D','****',
     -  'MOND','****','BTUN','NONE','ADPT','FLUC','PICL','AVRG','****',
     -  'SEED','****','CMPC','ASCI','BNRY','ASAN','PDB ','CHRM','****',
     -  'LIMG','NOWA','WARC','WALL','****','VORO','PBC ','NPBC','****',
     -  'BNDL','    ','DIST','ANGL','TORS','ANRS','CNCT','****',
     -  'PBGR','****',
     -  'MODA','****','MOLD','****','LCMP','****','BUFF','****',
     -  'IDAC','****','IDLG','OFF ','ASCI','ASPX','****','STPX','****',
     -  'OUTP','PRPB','PRAT','REPT','PRFC','PROP','****','CSEG','****',
     -  'FILE','****','RFCR','****','WPLT','LIN ','SQRT','LOG ','****',
     -  'PLCV','ENRG','VOLU','NUMB','BPAR','FETI','****',
     -  'LOOP','PROX','SCAN','JACW','****','STIR','****','IGJA','****',
     -  'NONB','SCTR','SCRP','TMOD','TSAL','SCNB','SCTN','****',
     -  'TORT','RELE','ABSE','****','LPST','RELE','ABSE','****',
     -  'IDAG','BOTH','INSR','DELE','DELD','****','LPAT','****',
     -  'VCHA','OFF ','PRES','SFTX','SFTY','SFTZ','****','AROM','****',
     -  'SETC','FCIN','FC14','DIEL','DDIE','BLKS','****','GENT','****',
     -  'HBMO','EXCL','HBMO','ADDT','ADDC','****','LIGA','****',
     -  'SKWT','DRIV','LOOP','DRLP','PROX','DRPR','DLPR','****',
     -  'STSC','SVTR','SVRO','STTR','STRO','SMTR','SMRO','NTOR','LTOR',
     -  '****','SVDP','****','ENHB','NONE','SMPL','2ANG','****',
     -  'SVIN','ALLA','CARB','NOHP','NOPP','CARA','****','IGSV','****',
     -  'CNST','INIT','UPDT','NONE','****','IWSL','WSTO','NOST','****',
     -  'GSAN','DPCV','DPCR','ENRG','HBND','OCCC','HBTT','JMPA','****',
     -  'SUPI','CONF','TRAJ','****','GABF','NODP','DTPR','DLPR','****',
     -  'GSAO','NOSR','SXYZ','RXYZ','LEXI','****','VVNE','****',
     -  'FLXR','INDX','PDB ','****','RDBD','MAKB','CPSF','ATOP','****',
     -  'RNDG','MMC ','LCG ','MRTW','INPT','INNS','OUTP','****',
c      (Proximity) analysis options start here
     -  'PXCR','TDEN','PDEN','WDEN','MDEN','****',
     -  'PXWW','NOPE','PEWW','****',
     -  'PXGR','NOTO','PXTO','****','GENV','NOWR','WRIT','****',
     -  'PXBE','****','PXDP','****','ATFR','****','PXAN','****',
     -  'PXPR','DSTR','NDST','NDSF','****',
     -  'PXWR','OFF ','ASCI','BNRY','BNRR','****',
     -  'SCAN','TRAJ','TRNC','CONF','****','PXPL','****',
     -  'VOLE','DROP','KEEP','****','PXPA','ALL ','NOEM','****',
     -  'FLDG','NONE','BNRY','ASCI','BNTO','ASTO','****',
     -  'RFSL','STOR','SIGM','RDFM','****','DIPC','****',
     -  'PXLM','****','RTIM','FRST','SCND','READ','****',
     -  'TAUC','****','GRAV','NONE','ELEM','PTYP','****',
     -  'KMNP','****','PXTD','****','ENGL','AVRG','INDI','****',
     -  'PXYZ','****','DBLG','****','TAND','****',
     -  'GENS','COMP','CLST','CALC','CCAL','****',
     -  'DIFC','****','HBBR','ALST','BBON','TLST','CHRG','****',
     -  '#-#-',198*'    '/
      data iopkeylist /
     -  'TITL','   0','   0','   0','HRDW','  21','   1','  -1',
     -  'STOP','   0','   0','   0','PBCN','   5','   1','  -1',
     -  'TEMP','   0','   0','   0','SUPT','   3','   1','   0',
     -  'SVPT','  26','   1','  -1','LIMG','  79','   1','   0',
     -  'SLTA','   2','   1','  -1','SLFT','  13','   1','  -1',
     -  'CHRG','   0','   0','   0','PMOD','   0','   0','   0',
     -  'RMOD','   0','   0','   0','SAMP','   6','   1','  -1',
     -  'STEP','   0','   0','   0','INCT','  33','   1','  -1',
     -  'MIXR','  52','   1','  -1','SUVC','   7','   1','  -1',
     -  'SVVC','  54','   1','  -1','SUUC','  65','   1','  -1',
     -  'NSLV','   0','   0','   0','MOVE','  12','   1','  -1',
     -  'FREE','  30','   1','   0','SLVA','   0','   0','   1',
     -  'PARD','  57','   1','   0','PART','  58','   1','   0',
     -  'TORD','  84','   1','   0','SWAP','  64','   0','   0',
     -  'SPSM','  68','   0','   0','TRAJ','   9','   1','  -1',
     -  'WTRA','  77','   1','  -1','SENS','   0','   0','   0',
     -  'FCGD','  25','   1','  -1','GCEN','  41','   1','  -1',
     -  'CNFG','  11','   1','  -1','DSTP','   1','   1','  -1',
     -  'SCAL','   0','   0','   0','DSTC','   4','   1','  -1',
     -  'RCKP','  48','   1','  -2','PFRD','   0','   0','   0',
     -  'WCNF','   0','   0','   0','RUNS','   0','   0','   0',
     -  'TIQU','   0','   0','   0','WMAT','   0','   0','   0',
     -  'OVRA','   0','   0','   0','OPTN','   0','   0','   0',
     -  'DBUG','   0','   0','   0','WCKP','   0','   0','   0',
     -  'NFBU','  19','   0','   0','NMVP','   0','   0','   0',
     -  'STPS','   0','   0','   0','EPLT','  23','   1','  -1',
     -  'PLBP','   0','   0','   0','PRPL','  16','   1','  -1',
     -  'PROT','  60','   0','   0','IGSV',' 119','   1','  -1',
     -  'PRTG','   0','   0','   0','PRFI','  63','   1','  -1',
     -  'FILE','   0','   0','   0','FILT','   0','   0','   0',
     -  'OUTP','   0','   0','   0','RFCR','   0','   0','   0',
     -  'DENF','   0','   0','   0','FCGA','   0','   0','   0',
     -  'OVST','  45','   0','   0','RAUS',' 120','   1','   0',
     -  'PRMF',' 126','   1','   0','SETC','   0','   0','   0',
     -  'MV2S','  66','   1','  -1','SPST','  67','   1','  -1',
     -  'CLON','  69','   0','   0','MAKB','   0','   0','   0',
     -  'BRKB','   0','   0','   0','FIXD','  95','   1','  -1',
     -  'REGE','   0','   0','   0','RMCK','   0','   0','   0',
     -  'PRAC','  70','   1','  -1','SPRD','   0','   0','   0',
     -  'IBEN','  71','   1','  -1','MOND','  80','   0','   1',
     -  'BTUN','  76','   1','  -1','BLKW','  80','   0','   2',
     -  'LCMP','  78','   0','   0','SCRM',' 102','   0','   0',
     -  'BDHH',' 100','   0','   0','BDRH',' 101','   0','   0',
     -  'CMPC','   0','   0','   0','PRNT','  24','   1','  -1',
     -  'VORO','  81','   1','  -1','BNDL','   0','   0','   0',
     -  'PBGR','  83','   0','   0','MODA','   0','   0','   0',
     -  'MOLD','  85','   0','   0','BUFF','  87','   0','   0',
     -  'IDLG','  42','   1','  -1','STPX','  15','   0','   0',
     -  'PRCO','   0','   0','   0','STVG','   0','   0','   0',
     -  'CSEG','  90','   0','   0','TAND',' 176','   0','   0',
     -  'SCKP','  40','   0','   0','GENS','   0','   0','   0',
     -  'LOOP','  91','   1','   0','STIR','   0','   0','   0',
     -  'TEST','   0','   0','   0','WPLT','   0','   0','   0',
     -  'PDBT','  98','   1','  -1','MVRT','  44','   1','  -1',
     -  'TDIS','  99','   1','   0','PLCV','   0','   0','   0',
     -  'LIGA',' 104','   1','   0','TORT','  36','   1','   0',
     -  'LPST','   0','   0','   0','GENT','   0','   0','   0',
     -  'IDAG','   0','   0','   0','VCHA',' 106','   1','  -1',
     -  'CHKP','   0','   0','   0','STUN',' 107','   1','   0',
     -  'SPPS',' 108','   1','   0','MINE',' 109','   1','  -1',
     -  'AROM','   0','   0','   0','STSC',' 110','   1','   0',
     -  'ENHB','   0','   0','   0','SVIN',' 113','   1','   0',
     -  'SANN',' 114','   1','  -1','LPAT','   0','   0','   0',
     -  'HBMO','   0','   0','   0','TAC0','   0','   0','   0',
     -  'IGJA',' 115','   1','   0','SKWT',' 116','   1','   0',
     -  'CNST',' 117','   1','   0','IWSL',' 118','   1','   0',
     -  'CPOC','   0','   0','   0','IDAC','  22','   0','   0',
     -  'FETK','   0','   0','   0','STOL','   0','   0','   0',
     -  'SUPI',' 121','   1','   0','GSAN',' 122','   1','   0',
     -  'GSAO','   0','   0','   0','GABF',' 123','   1','   0',
     -  'FLXR','  61','   1','   0','RNDG',' 124','   1','  -1',
     -  'VVNE',' 125','   1','   0','IGTT',' 127','   1','   0',
     -  'SEED','   0','   0','   0','RDBD',' 128','   1','   0',
     -  'SACP',' 129','   1','   0',
c      Analysis options start here
     -  'PXCR',' 162','   1','  0',
     -  'PXWW',' 148','   1','  -1','PXGR',' 143','   1','  -1',
     -  'GENV','   0','   0','   0','PXBE',' 146','   0','   0',
     -  'PXDP',' 145','   0','   0','ATFR',' 144','   0','   0',
     -  'PXAN','   0','   0','   0','PXPR',' 156','   1','  -1',
     -  'PXWR',' 163','   1','  -1','SCAN',' 160','   1','   0',
     -  'PXPL',' 153','   0','   0','VOLE',' 164','   1','  -1',
     -  'PXPA',' 165','   1','  -1','FLDG',' 166','   1','  -1',
     -  'RFSL',' 167','   1','  -1','DIPC',' 169','   0','   0',
     -  'PXLM','   0','   0','   0','RTIM',' 171','   1','   0',
     -  'GRAV',' 172','   1','  -1','KMNP','   0','   0','   0',
     -  'PXTD','   0','   0','   0','ENGL',' 174','   1','   0',
     -  'PXYZ',' 175','   0','   0','DBLG','   0','   0','   0',
     -  'DIFC',' 177','   0','   0','NONB','  96','   1','   0',
     -  'HBBR',' 178','   1','   0','SVDP',' 111','   1','   0',
     -  'TAUC',' 180','   1','   0',
     -   92*'    '/
      data prereq /'****','PBCN','SUVC','SVVC','****',
     -  'CNFG','SLTA','FILE','****','GCEN','PBCN','****',
     -  'RUNS','SLTA','CNFG','TEMP','FILE','****',
     -  'TORD','SLTA','****','SCAL','CNFG','****','FETK','TEMP','****',
     -  'PRTG','CNFG','GCEN','****','CPOC','CNFG','GCEN','PRTG','****',
     -  'WCNF','SLTA','CNFG','****','STOL','CNFG','****',
     -  'SLTA','FILE','PBCN','SVPT','SUPT','****','PROT','SUPT','****',
     -  'PRFI','GCEN','MOVE','****','RCKP','FILE','****',
     -  'FCGA','SLTA','****','PARD','SLTA','SUUC','****',
     -  'SLVA','SVPT','****',
     -  'PART','SUUC','SLTA','****',
     -  'FCGD','SLTA','****','DENF','TRAJ','****','SPST','FLXR','****',
     -  'REGE','CNFG','TORD','****','SPRD','CNFG','****',
     -  'BTUN','GCEN','MOND','****','WTRA','TRAJ','****',
     -  'LCMP','IBEN','****','MV2S','PARD','****','AROM','SLTA','****',
     -  'ENGL','SLTA','SUUC','****','STVG','GCEN','SLTA','CNFG','****',
     -  'CMPC','SLTA','****','MOND','PBCN','****','LIMG','PBCN','****',
     -  'VORO','CNFG','PBCN','****','FREE','PBCN','****',
     -  'STPX','GCEN','****','BNDL','SLTA','****','SUPI','TRAJ','****',
     -  'STIR','CNFG','****','SCRM','CNFG','****',
     -  'GENS','PBCN','****','TORT','CNFG','TORD','****',
     -  'LPST','CNFG','TORD','LOOP','****','HBMO','ENHB','SLTA','****',
     -  'GENT','CNFG','TORD','****','IDAG','IDLG','CNFG','****',
     -  'SVDP','SLVA','SLTA','****','SVIN','AROM','****',
     -  'IDLG','GCEN','****','SANN','TEMP','****','TAC0','STUN','****',
     -  'ENHB','SLTA','****','SWAP','PARD','****','IDAC','GCEN','****',
     -  'SACP','GCEN','****',
c      Proximity options start here
     -  'GENV','SLTA','PXCR','PXGR','****','PXWW','PXCR','****',
     -  'PXGR','PXCR','****','PXBE','PXCR','****',
     -  'PXLM','PXCR','****','PXCR','SLTA','****',
     -  'SCAN','SLTA','****',
     -  'FLDG','PXCR','****','TAND','TORD','****','RTIM','PXCR','****',
     -  'DIFC','PXCR','****','PXDP','PXCR','PXGR','****',
     -  'HBBR','SLTA','****','GRAV','PXGR','****','PXTD','PXCR','****',
     -  'PXWR','PXCR','****','STUN','MVRT','****',
     -  'TAUC','PART','****','RFSL','SUPT','****',
     -  '#-#-',242*'    '/
      data forbid /'****','SLTA','SLVA','PFRD','PMOD','FREE',
     -  'PROT','CHRG','CLON','MAKB','BRKB','RFSL','MIXR','SETC','MODA',
     -  'MOLD','STEP','FLXR','CNST','VVNE','RDBD','****',
     -  'MOND','PRTG','****','BLKW','PRTG','****',
     -  'GENS','GSAN','GSAO','****','PARD','FREE','****',
     -  'PART','SVVC','****','RCKP','TITL','PBCN','SUPT','SVPT','TRAJ',
     -  'INCT','MIXR','SUVC','SVVC','SUUC','NSLV','MOVE','FREE','SLTA',
     -  'SLVA','CNFG','****',
     -  'CNFG','FREE','TORD','CMPC','NSLV','IBEN','VCHA','PXYZ','****',
     -  'VOLE','RCKP','****','NSLV','HRDW','****',
     -  'TORD','PRMF','SETC','LOOP','FREE','PARD','****',
     -  'FCGD','FCGA','****','GCEN','LIMG','****',
     -  'SPST','AROM','SVIN','ENHB','PARD','TORD','CNFG','HBMO','****',
     -  'PXAN','PXGR','PXBE','PXDP','PXWW','VORO','RTIM','TAND','ATFR',
     -  'FLDG','CHKP','****','PRMF','SLTA','****','IBEN','VCHA','****',
     -  'VCHA','IBEN','****','STUN','MVRT','****','TRAJ','MINE','****',
     -  'TORD','SKWT','****','TORD','ENHB','****','PXCR','IDAC','****',
     -  'IDAC','PXCR','****',
     -  '#-#-',367*'    '/
      data nmcy /2/,mcy /'MCY ','YMD '/,
     -  ntip3 /5/,tip3 /'TIPS','SPC ','TIP3','SPCE','READ'/,
     -  ntip4 /4/,tip4 /'BRFW','TIP2','TIP4','READ'/,
     -  ntip5 /2/,tip5 /'TIP5','READ'/,
     -  npmli /3/,pmli /'NOMX','CIMX','CCMX'/,
     -  npmf2 /6/,pmf2 /'GENL','WRMM','WRFM','WRFR','TORS','WRTR'/,
     -  npmf3 /3/,pmf3 /'GEOC','GEQC','GDQC'/,
     -  npmf4 /3/,pmf4 /'HUSS','AUSL','AUSE'/,
     -  npfs1 /3/,pfs1/'COM ','NRST','CXYZ'/
     -  nrckp1 /2/,rckp1 /'NOFX','FXTR'/,
     -  ngcen1 /3/,gcen1 /'RVDW','RSIG','RSGH'/,
     -  ngcen2 /2/,gcen2 /'ALTI','RANI'/,
     -  ngcen3 /2/,gcen3 /'ALLG','SLVG'/,
     -  ngcen4 /4/,gcen4 /'LJQI','LJNC','LJCN','LJCU'/,
     -  niben /3/,iben /'ISOT','IXYZ','ISYZ'/,
     -  ntord1 /3/,tord1 /'MOLG','SING','BRAG'/,
     -  ndstc /2/,dstc /'NOFI','FILE'/,
     -  nwcnf /14/,wcnf/'UNCH','CENT','SW23','MLCT','REPL','REP0',
     -    'PXSR','SPSR','NOSV','TRRT','RTTR','PRET','FIXC','FULL'/,
     -  ncnfg2 /4/,cnfg2 /'SIZE','NTOS','STOS','STON'/,
     -  ncnfg3 /5/,cnfg3 /'NOFX','FXCR','FXCC','FXIN','IGND'/,
     -  ncmpc/3/,cmpc /'SHRT','SHON','ALLD'/,
     -  ncmpc1 /2/, cmpc1 /'GENL','LIPI'/
     -  nprac /2/, prac /'USED','ALLA'/
     -  ntraj/3/,traj /'RGFX','RGNO','FLEX'/,
     -  ntraj1/4/,traj1 /'ALST','MVST','NOST','NOSV'/,
     -  ntraj2/3/,traj2 /'NOBX','BOX ','BOXX'/,
     -  nslft /5/,slft /'STPD','IGND','FIXD','FXDI','STWD'/
     -  nfilt /10/,filt /'INSD','INSV','INVG','CRCV','CRCH','CVLS',
     -    'SHL1','SHL2','SHL3','NCLS'/
     -  nframefilt /2/,framefilt /'ETRA','ECAL'/,
     -  nfilt1 /5/,filt1 /'CONF','TRAJ','TRAC','TRAO','TRCO'/
     -  npxcr1 /3/,pxcr1 /'BISE','RPVW','RPCH'/
     -  npxcr2 /4/,pxcr2 /'ALL ','NOHD','URNG','URNH'/
     -  npxww /2/,pxww /'NOGR','GRWW'/,
     -  npxgr1 /3/,pxgr1 /'NOPR','PRKC','PRIM'/,
     -  npxgr2 /3/,pxgr2 /'NOWT','TDWT','PDWT'/,
     -  npxpr1 /2/,pxpr1 /'NVLE','VOLE'/,
     -  npdbg /21/,pdbg /'VFSH','V2SH','NFSH','N2SH','DFSH','DSSH',
     -    'EBFS','EPFS','TOBE','TOTN','NFVV','EPVV','EBVV',
     -    'MRDF','KRDF','VRDF','DRDF','CRCV','CRCH','INAC','DLAC'/
     -  npxpr2 /4/,pxpr2 /'FULT','NFLT','NFGT','FFGT'/,
     -  npxpr3 /2/,pxpr3 /'NECH','FECH'/,
     -  nreadwrite /2/,readwrite /'WRIT','READ'/,
     -  nslta1 /4/,slta1 /'MMC ','MMC4','PDB ','CRD '/,
     -  nslta2 /2/,slta2 /'READ','FILE'/,
     -  nchimd /4/,chimd /'XGRD','YGRD','ZGRD','PXRG'/,
     -  naddw /2/,addw /'FIXL','FLEX'/
      data nengl /3/,engl/'ALLI','NOGI','NOMI'/,
     -  nengl2 /2/,engl2/'ARNG','GRNG'/,
     -  nprtg /2/,prtg /'ALLG','SRFG'/,
     -  nprtg2 /4/,prtg2 /'NOLS','GRLS','ATLS','AGLS'/,
C@PG     -  ncpoc /2/, cpoc/'CONF','TRAJ'/,
C@PG     -  ncpoc1 /2/, cpoc1/'NOSA','SAVE'/,
     -  nphs /3/, phs/'UTTO','UTPM','UPML'/,
     -  ngens2 /2/,gens2 /'FIXI','CONT'/,
     -  ngens3 /7/,gens3 /'GETC','GETH','RDAS','RDBI','RDAN','RDPD',
     -    'RDCH'/,
     -  ngens4 /8/,gens4 /'WPDB','WASC','WANN','SPDB','SASC','SANN',
     -    'RPDB','RASC','RANN'/
     -  ngens5 /6/,gens5 /'FSRT','DSRT','CSRT','PSRT','CVSR','PXSR'/,
     -  ngens6 /5/,gens6 /'DIST','ENVN','ENVI','ENVM','TANI'/,
     -  ntiqu /3/, tiqu /'ALL ','STSV','STST'/,
     -  nwmat /4/,wmat /'NONE','PLPS','NOPS','NOPL'/,
     -  nwmat2 /2/,wmat2 /'NOCR','CROP'/,
     -  nwmat3 /3/,wmat3 /'MATW','MATD','MATC'/,
     -  nloop /4/,loop /'FORW','BCKW','TRNG','BOTH'/,
     -  nfldg /2/, fldg /'ALLG','NOSV'/,
     -  nidag /2/, idag /'NOFT','FILT'/,
     -  nstun /5/, stun /'PICL','PCLG','OFF ','OFFW','OFFC'/,
     -  nsupi1 /2/,supi1 /'RNGE','PROX'/,
     -  ngsan /4/,gsan/'NOEV','CAEV','ONRM','RDOR'/,
     -  ngsao /3/,gsao/'ASCI','ASCL','BNRY'/,
     -  ngsao1 /3/,gsao1/'DIPL','HHVC','DPHH'/,
     -  ncnst /3/,cnst/'NOCT','WCNT'/
      data crm00 /3*0.0/,linenoo /0/,lineno0 /0/,movatf /0/,movatl /0/,
     -  iop25prev /0/,iotyp /0/,nsleftsum /0/,nsltbef /0/,natsbef /0/,
     -  nmolbef /0/,iskipframe /0/, leavemol /0/,matform /2/,
     -  matsort /1/
      iexit=0
      ireset_tim=1
      call zeroiti(icompopt,0,40)
C@NN      icompopt(1)=1
          ivvon=icompopt(1)
C@TN      icompopt(2)=1
          iuuon=icompopt(2)
C@NA      icompopt(3)=1
C@NL      icompopt(4)=1
C@TS      icompopt(5)=1
C@FR      icompopt(6)=1
C@DB      icompopt(7)=1
C@UX      icompopt(8)=1
C@UG      icompopt(10)=1
C@AX      icompopt(11)=1
C@PS      icompopt(12)=1
C@EF      icompopt(13)=1
          r8vsr16='dlog'
          if (r8vsr16 .eq. 'qlog') icompopt(14)=1
C@DM      icompopt(15)=1
C@HP      icompopt(16)=1
C@I2      icompopt(17)=1
C@VC      icompopt(18)=1
C@IB      icompopt(19)=1
C@G7      icompopt(20)=1
C@PG      icompopt(21)=1
C@FG      icompopt(22)=1
C@FG      iasize(59)=#MG
C@RF      icompopt(23)=1
C@AB      icompopt(24)=1
C@DD      icompopt(25)=1
C@1R      icompopt(26)=1
C@G9      icompopt(27)=1
C@ND      icompopt(31)=1
C@NV      icompopt(32)=1
C@NR      icompopt(33)=1
C@dc      labcall='????'
      call indexit(indexself,1,#UV,0)
      call wordlength
      call findnewunit(iunew,1,iout)
c     Estimate the sizes of the MC checkpoint file
      rnint=2*#ND+3*#SV+(49+#NL)*#ST+8*#GR+20*#MM+
     -    44*#TR+21*#MO+2*#RG+#PG+2*#PS+#PP+20*#AT+
     -    2*#WG+8*#WI+#WS+2*#UV+3*#TL+2*#OR+2*#DM+
     -    #CV+#PP+#GX*#GY*#GZ+2*#GX+#TA+#TD*#TR+
     -    13*#LT+2*#MS+9*#MH+2*#MH*#MO+2*#MH**2+
     -    #RN+2*#NS*#MH
C@NN      rnint=rnint+#VW*#MO+3*#MO
C@TN      rnint=rnint+#UW*#ST
C@DM      rnint=rnint+#MO
      rnreal=3*#NA+55*#MO+6*#MA+3*#GR+12*#SV+41*#ST+
     -      22*#TR+11*#MM+3*#PG+#PP+3*#AT+5*#MI+7*#WG+
     -      2*#WS+3*#GV*#GV+3*#GT*#GV+#GV+#UU*#UU+#WI+
     -      3*#TA+3*#MS+6*#MH+#LT+3*#NE+7500+
     -      2*#AU*#TR+4*#MH+4*#MH**2
      rndbl=13*#MM+7*#MO+16*#TR+3*#ST+3*#PS+7*#MI+
     -      9*#WG+9*#DT*#SV+2*#GX+35*#LT
C@FG      rndbl=rndbl+12*#MG*#GQ+12*#MM*#GQ+2*#MM+6*#MG
      if (icompopt(14) .eq. 1) rndbl=rndbl*2.0
      rnc=4*(4*#ST+2*#SV)+6*10*#AT
      rnbytyckp=4*rnint+4*rnreal+8*rndbl+rnc/8
c     Estimate the sizes of the analysis checkpoint file
      rnint=#RG*#GQ+#TG*#GQ+22*#SX+3*#ST+
     -  #LG*#GQ+15*#GQ+#GE*#GQ+#VG*#GQ*#ND+
     -  4*#DT+#RC*#GQ*#MD+#NA+#RG*#GQ
      rnreal=4*#ST+3*#SV+21*#SX
      rndbl=#DG*#GQ+7*#SX+11*#MI+3*#ST+47*#DT
C@TS      rndbl=rndbl+6*#ST+2*#TR
      if (icompopt(14) .eq. 1) rndbl=rndbl*2.0
      rnc4=3*#ST
      rnbytypxc=4*rnint+4*rnreal+8*rndbl+4*rnc4
      rnint=#NA+3*#UV+4*#MO+3*32*#RC+
C@PG     -  12*#CV+5*#GC+
     -  27*#GH**3
      rnreal=3*#MH+2*#UV+3*#MH*#MO+4*#MO+#GQ*#RC*16+
C@PG     -  4*#CV+
     -  10*#GM**3
      rnbytyadd=4*rnint+4*rnreal
      tab=tab4(1:1)
      ctrlM=ctrlM4(1:1)
      pi=atan(1.0)*4.0
      pi2=2.0*pi
      pi43=4.0*pi/3.0
      dpi=datan(1.d0)*4.d0
      dpi2=2.d0*dpi
c     Convert from radian to degrees
      rdtodg=180.0/pi
c     Convert from mole/ml to molecule/A**3
      wmmltona3=1.0e+24/avogad
      sq2=sqrt(2.0)
      sq3=sqrt(3.0)
      sq5=sqrt(5.0)
      sq3p2=sq3/2.0
      threp2=1.5
      sq2p3=sqrt(2.0/3.0)
      ifsaved=0
      call blankout(ident(1),1,80)
      call blankout(ident(2),1,80)
      nlident=0
      call blankout(file,1,80)
      call zeroiti(ncross,0,27)
      call zeroiti(nmc_zeroacc,0,4)
      call zeroit(edgexyz,3)
      lscratchpath=0
      wloop=0.0
      MYRANK=0
      iopenok=0
      iop94old=0
      iopen90=0
      NUMNOD=1
C@DM      MAXNOD=64
C@DM      call MPI_init(ISTAT)
C@DM      call MPI_COMM_SIZE(MPI_COMM_WORLD,NUMNOD,ISTAT)
C@DM      call MPI_COMM_RANK(MPI_COMM_WORLD,MYRANK,ISTAT)
C@DM      NUMNOD_p=NUMNOD
C@DM      iop(21)=3
C@DM      ioutdb=min0(iout+MYRANK,9)
C@DMc     Does not empty the buffer upon crash - can't use
C@DM      ioutdb=iout
C@DM      if (MYRANK .eq. 0) then
      file(1:1)='-'
      call getarg(1,file)
      if (file(1:1) .ne. '-' .and. file(1:1) .ne. ' ') then
        len=1
        do while (file(len:len) .ne. ' ')
          len=len+1
        end do
        len=len+3
        file(len-3:len)='.out'
        filenames(30)=file
        namlens(30)=len
        call findnewunit(iout,0,iout)
        open(unit=iout,status='new',file=file(1:len),form='FORMATTED',
     -    iostat=iopenok)
        if (iopenok .ne. 0) open(unit=iout,status='old',
     -    file=file(1:len),form='FORMATTED',iostat=iopenok)
        if (iopenok .ne. 0) then
          iout=6
          write (iout,2262) file(1:len)
        end if
        file(len-3:len)='.inp'
        filenames(23)=file
        namlens(23)=len
        call findnewunit(inpt,0,iout)
        open(unit=inpt,status='old',file=file(1:len),form='FORMATTED',
     -    iostat=iopenok)
        if (iopenok .ne. 0) then
          write (iout,2262) file(1:len)
        end if
      end if
      write (iout,2000) isize,realmx,dpmx,nbits
      call printcomp(iout,icompopt,ncompopt,sizesym,sizename,sizelname,
     -  optname,optlname,iasize,nasize,cmoddate,cpxmoddate,moddate,
     -  file,nbits,0,1,0,nwarn)
      if (inpt .ne. 5) then
        write (iout,2261) 'input ',filenames(23)(1:namlens(23)),inpt
        write (iout,2261) 'output',filenames(30)(1:namlens(30)),iout
      end if
C@DM        write (iout,2249) NUMNOD
C@DM      end if
       if (iopenok .ne. 0) call datprt(2)
C@DM      if (NUMNOD .gt. MAXNOD) then
C@DM        if (MYRANK .eq. 0) write (iout,2247) MAXNOD
C@DM        call MPI_finalize(ierr)
C@DM        stop
C@DM      end if
C@DM      mpi_start=1
      myrank1=MYRANK+1
      call datprt(0)
      icp=1
      call ranini(iout,0,0,0)
      nseedread=0
      call zeroiti(iatnos(1,11),0,#AT)
      iatnos(99,11)=99
      call zeroiti(iatnos(1,10),0,#AT)
      call indexit(iatnos(1,10),1,99,0)
      call zeroiti(idebug,0,200)
      call zeroiti(istune,0,4)
      call zeroiti(istunestep,0,4)
      call zeroiti(istunetyp,0,4)
      call zeroiti(igsanaltyp,0,7)
      nfge=11
c     Set defaults
      ichopen=0
      rwwin2=0.0
      ipxdiff=0
      ickpread=0
      ickpok=0
      mapedone=0
      ngridmap=1
      edgemap2=0.0
      iopdesolv=0
      ihbtypsltslt=0
      ihbtypsltmap=0
      ihbsignslt=-1
      ihbsignmap=-1
      nospecterm=1
      naromc=0
      nhbexclude=0
      incrhmap=3
      nosltname=1
      iop9old=0
      wsltpdis=0.0
      wswap=0.0
      wmv2s=0.0
      wspec=0.0
      wsltptor=0.0
      fblamd=0.5
      temp=298.5
      kexp=0
      rmaxhb=0.0
      kxmn=1
      igrll=0
      sltinptyp='    '
c     inperr,nwarn,nwwarn,nchng: error,warning,serious warning, change counter.
      inperr=0
      nwarn=0
      nwwarn=0
      nconnfail=0
      nchng=0
      lineno=0
      iaread=0
      isltread=0
      itiquad=0
      nmc=0
      nmcmax=0
      nmcrep=0
      nmchinc=0
      nmcslftst=5000000
      iskewdr=0
      iskewpr=0
      iskewlp=0
      ichkp0=0
      ipdbvers=1
      irat=-1
      ifrocc=0
      ngfree=0
      nstta=0
      numsolv=0
      nsltfreq=0
      nslvxp=0
      nafltrange=0
      naflxrange=0
      nhstvers=1
      nfilt_solv=0
      max_atdtyp=7
      isannread=0
      ntempstepcum=0
      ntypused=0
      nrep3slt=0
c     Some initializations are moved here from the block data to avoid g77 msgs
c     nsltcp(iop(30)+1) is the number of FE solute copies kept for iop(30)
c     data nsltcp/1,1,1,1,0,2,2,3,3/
      do i=1,4
        nsltcp(i)=1
      end do
      nsltcp(5)=0
      nsltcp(6)=2
      nsltcp(7)=2
      nsltcp(8)=3
      nsltcp(9)=3
c     variables in common block proxan
c     data nfadel /0/, nladel /0/,
c    -  epmink /0.0/,epdivk /1.0/,ncnfpx/0/,rfsfac /1.0/, rfsadd /0.0/,
c    -  nranpx /0/,nsavepx /0/,nmcpxdsc /0/,npxres /0/,npxcntin /0/,
      nfadel=0
      nladel=0
      epmink=0.0
      epdivk=0.0
      rfsfac=1.0
      rfsadd=0.0
      modelnum=0
      ncnfpx=0
      nranpx=0
      nsavepx=0
      nmcpxdsc=0
      npxres=0
      npxcntin=0
      rpxdiv=0.1
      nogridrun=0
      griderrmax=0.0
      igridprint=0
c    -  rkpdbmin/0.0/,rkgrmin/0.7/,r2kgrmin/2.5/,rtkgrmin/10.0/,
      rkpdbmin=0.0
      rkgrmin=0.7
      r2kgrmin=2.5
      rtkgrmin=10.0
      volcavmin=-1.0
      vrange=0.0
      randsh=-1.0
      rsltfac=0.9
      rxhmax2=3.0
      hbanglemina=90.0
      occmin_at=0.0
      occmin_res=0.0
      occmin_tt=0.0
      clstfin_dmax=0.0
      nclust_clstfin=0
      hbmatmin=0.0
      iwriteorg=0
      npfl6=0
      iop47read=0
      isplitdone=0
      namlenh=0
      modelnumh=0
      ietoth=0
      ibparh=0
c     By default, fix attempt is made after failed compulsory self test
      iop(95)=2
c     By default, number of molec is read from .cr or .hst file
      iop(97)=1
      keycol(1)=npxcol+3
      keycol(2)=npxcol+4
c     Extract main key list
      ifrst=0
      ik=0
      id=0
      do while (keys01(ifrst+1) .ne. '#-#-')
        ik=ik+1
        if (ik .gt. 200) then
          ik=ik-1
          id=id+1
        end if
        ifrst=ifrst+1
        mainkey(ik)=keys01(ifrst)
        mainkeyu(ik)=0
        mainkeyun(ik)=0
        ifkey1(ik)=ifrst+1
        do while (keys01(ifrst) .ne. '****')
          ifrst=ifrst+1
        end do
      end do
      nmainkey=ik+id
      if (nmainkey .gt. 200) then
        write (iout,2106) nmainkey,200
        call datprt(2)
      end if
      do ik=1,nmainkey-1
        nkey1(ik)=ifkey1(ik+1)-ifkey1(ik)-2
      end do
      nkey1(nmainkey)=ifrst-ifkey1(nmainkey)
      call find('CNFG',1,nmainkey,mainkey,keynocnf,4)
      call find('SLTA',1,nmainkey,mainkey,keynoslta,4)
c     Extract nodupwarn info
      ik=1
      do while (nodupwrn(ik) .ne. '    ')
        call find(nodupwrn(ik),1,nmainkey,mainkey,keyno,4)
        if (keyno .eq. 0) then
          write (iout,2269) 'nodupwarn',nodupwrn(ik)
        else
          nodupwarn(keyno)=1
        end if
        ik=ik+1
      end do
c     Extract noerror info
      ik=1
      do while (noerrr(ik) .ne. '    ')
        call find(noerrr(ik),1,nmainkey,mainkey,keyno,4)
        if (keyno .eq. 0) then
          write (iout,2269) 'noerrr',noerrr(ik)
        else
          noerror(keyno)=1
        end if
        ik=ik+1
      end do
c     Extract iopkey info
      ik=1
      do while (iopkeylist(1,ik) .ne. '    ')
        call find(iopkeylist(1,ik),1,nmainkey,mainkey,keyno,4)
        if (keyno .eq. 0) then
          write (iout,2207) iopkeylist(1,ik)
        else
          do k=1,3
            read (iopkeylist(k+1,ik),1002) iopkey(k,keyno)
          end do
        end if
        ik=ik+1
      end do
      iop(24)=0
      nsttar=0
      ipflibprint=0
      iprtlibcomb=0
      iconfread=0
      iconffilt=0
      ntang=0
      if (#SV .lt. 5) then
        write (iout,2323)
        inperr=inperr+1
      end if
      ifirstt(1)=-1
      ilastt(1)=-1
      do while (key0 .ne. 'STOP')
C@DM        call MPI_BARRIER(MPI_COMM_WORLD,ierr)
        if (prevkey .eq. 'RUNS' .or. prevkey .eq. 'SCAN'
     -    .or. prevkey .eq. 'PXAN') call datprt(0)
        irectx=0
        keyno0=0
        do while (keyno0 .le. 0)
          if (icol .lt. 0) then
            icol=-icol+1
C@DB            print *,'Continuation at icol=',icol
          else
            if (MYRANK .eq. 0) write (iout,2011)
            lineno=lineno+1
C@DM            if (MYRANK .eq. 0) then
            ireadok=0
            ncolp=80
            call blankout(line,1,80)
            read (inpt,1000,end=801) line
            ireadok=1
            do ic=1,80
              if (line(ic:ic) .eq. ctrlM) ncolp=ic-1
            end do
801         write (iout,2005) lineno,line(1:ncolp)
C@DM            end if
C@DM            call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            if (ireadok .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2999)
              call datprt(1)
            end if
C@DM            call MPI_Bcast(line,80,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
            icol=1
          end if
C@DB          print *,'nmainkey=',nmainkey
          call decode(mainkey,nmainkey,mainkeyun,keyno0,key0,0)
          prevkey=key0
        end do
C@DB        print *,'key0,keyno0=',key0,keyno0
c       Warn about duplicate
        if (mainkeyun(keyno0)-mainkeyu(keyno0) .gt. 1 .and.
     -      keyno0 .gt. 1  .and. nodupwarn(keyno0)  .eq. 0) then
          if (MYRANK .eq. 0) write (iout,2008) key0,lineno
          nwarn=nwarn+1
        end if
c       Check for prerequisites
        call compile_ready(key0,icompopt,optname,iout,inperr)
        call getlist(prereq,500,newlist,n,key0)
C@DB        print *,'Prereqs:',n
        do i=1,n
          call find(newlist(i),1,nmainkey,mainkey,keyno,4)
          if (mainkeyun(keyno) .eq. 0) then
            if (MYRANK .eq. 0)
     -        write (iout,2009) key0,mainkey(keyno),lineno
            inperr=inperr+1
          end if
        end do
C@DB        print *,'keyno0=',keyno0
c       Check if this keyword has been forbidden by previous keys
        if (keyforbid(keyno0) .lt. 0) then
          if (MYRANK .eq. 0) then
            write (iout,2010) key0,lineno,forbidk0(keyno0)
            if (iop(10) .gt. 0) write (iout,2119) numrun
          end if
          inperr=inperr+1
        end if
C@DB        print *,'nkey1(keyno0)=',nkey1(keyno0)
        if (nkey1(keyno0) .gt. 0) then
c         Find the position of the argument key and set iop accordingly
          call decode(keys01(ifkey1(keyno0)),nkey1(keyno0),ndummyu,
     -      keyno,key,1)
C@DB          print *,'keyno0,iopkey=',keyno0,(iopkey(k,keyno0),k=1,3)
          if (iopkey(1,keyno0) .gt. 0) iop(iopkey(1,keyno0))=
     -      keyno*iopkey(2,keyno0)+iopkey(3,keyno0)
        else
c         Set corresponding iop, if any
          if (iopkey(1,keyno0) .gt. 0)
     -      iop(iopkey(1,keyno0))=max0(1,iopkey(3,keyno0))
c         This allows to differentate when two keywords activate the same opt
        end if
c       Check if error-tolerant
        if (inperr .gt. 0 . and. noerror(keyno0) .gt. 0) then
          write (iout,2254) key0,key0
          mainkeyun(keyno0)=0
          go to 1111
        end if
c=======Additional input by keywords
C@DM        call mpi_ready(key0,mpi_ok)
C@DM        if (mpi_ok .eq. 0) then
C@DM          if (MYRANK .eq. 0) write (iout,2248) key0
C@DM          inperr=inperr+1
C@DM          key0='    '
C@DM        end if
        if (iconfread .eq. 0) then
          if (key0 .eq. 'REGE' .or. key0 .eq. 'WCNF' .or.
     -        key0 .eq. 'STIR') then
            write (iout,2153) key0
            inperr=inperr+1
            go to 1111
          end if
        end if
        if (key0 .eq. 'FILE') then
c---------File name root
          call getname(file,namlenf,1,80)
          call getint(numrunr,0,1,0)
          lmax=4
          if (numrunr .gt. 1) lmax=lmax+2
          if (numrunr .gt. 10) lmax=lmax+1
          if (namlenf+lmax .gt. 80) then
            write (iout,2297)
            inperr=inperr+1
          else if (namlenf+lmax+3 .gt. 80) then
            write (iout,2298)
            nwwarn=nwwarn+1
          end if
          if (numrun .gt. 1) then
C@DM            if (MYRANK .eq. 0) then
c           Close all open files
            call switchfiles(numrunr,inpt,iout,1)
            write (iout,2073) file(1:namlenf)
            nwarn=nwarn+1
c           Make sure that config is also read if it will be needed
            mainkeyun(keynocnf)=0
C@DM            end if
            call zeroiti(keyforbid,0,nmainkey)
          end if
          if (numrunr .gt. 0) numrun=numrunr
          numrunst=numrun
        else if (key0 .eq. 'LPAT') then
c---------Path for local files (ckp file, temp files)
          call getname(scratchpath,lscratchpath,1,80)
          if (scratchpath(lscratchpath:lscratchpath) .ne. '/') then
            lscratchpath=lscratchpath+1
            scratchpath(lscratchpath:lscratchpath)='/'
          end if
        else if (key0 .eq. 'TITL') then
c---------Up to 2 title lines
          nlident=nlident+1
C@DB          print *,'nlident,icol=',nlident,icol
          if (nlident .le. 2) then
            call lastchar(line,icl,80)
            ident(nlident)(1:(icl-icol))=line(icol+1:icl)
          else
            write (iout,2006)
            nwarn=nwarn+1
          end if
        else if (key0 .eq. 'HRDW') then
c---------Computer architecture
C@DM          if (MYRANK .eq. 0) write (iout,2060)
C@DM          nwwarn=nwwarn+1
C@DM          iop(21)=3
        else if (key0 .eq. 'RNDG') then
c---------Random number generator
          irng=iop(124)
          if (irng .eq. 1) then
c           Read LCG constants
            call getint(lcg_fac,0,1,lcg_fac)
            call getint(lcg_add,0,1,lcg_add)
            call getint(lcg_seed,0,1,lcg_seed)
            call getint(lcg_modexp,0,1,lcg_modexp)
            if (lcg_modexp .lt. 31) lcg_mod=2**lcg_modexp
          else if (irng .eq. 2) then
c           Mersenne twister
            call getint(ixmt,0,1,1357)
            call ranini(iout,0,0,0)
          else if (irng .eq. 3 .or. irng .eq. 4) then
c           Read random numbers
            irand=1
            call getname(rngfile,lrngfile,1,80)
            open(unit=90,file=rngfile(1:lrngfile),form='FORMATTED',
     -        status='old',iostat=ifail)
            if (ifail .eq. 0) then
              nrand=0
              do while (.true.)
                read (90,*,end=111,err=111) rnol
                nrand=nrand+1
                if (nrand .le. #RN) then
                  rnolist(nrand)=rnol
                else
                  write (iout,2342) #RN
                  inperr=inperr+1
                  nrand=#RN
                  go to 111
                end if
              end do
111           ncycle=0
              irnd1=1
              irnd2=2
              do i=2,nrand
                if (rnolist(i) .eq. rnolist(irnd1)) then
                  ncycle=i-1
                  if (i .lt. nrand) then
                    if (rnolist(i+1) .ne. rnolist(irnd2)) ncycle=0
                  end if
                end if
              end do
              if (ncycle .eq. 0) write (iout,2337)
              if (ncycle .gt. 0) write (iout,2338) ncycle
            else
              write (iout,2064) rngfile(1:lrngfile)
              inperr=inperr+1
            end if
            close (90)
          else if (irng .eq. 5) then
c           Write random numbers
            irng=0
            call getname(rngfile,lrngfile,1,80)
            call getint(nrand,0,1,#RN)
            if (nrand .gt. #RN) then
              write (iout,2334) nrand,#RN
              nrand=#RN
            end if
            call getint(lrand,0,1,12)
            if (lrand .gt. 12) then
              write (iout,2336) lrand
              lrand=12
            end if
            open(unit=90,file=rngfile(1:lrngfile),form='FORMATTED',
     -        status='new',iostat=ifail)
            if (ifail .eq. 0) then
              do i=1,nrand
                call mmc_random(1,rno)
                write (stuff,1001) rno(1)
                write (90,1008) stuff(1:lrand+2)
              end do
            else
              write (iout,2064) rngfile(1:lrngfile)
              inperr=inperr+1
            end if
            close (90)
            write (iout,2335) nrand,lrand,rngfile(1:lrngfile)
C@DM            call MPI_finalize(ierr)
            stop
          end if
        else if (key0 .eq. 'PBCN') then
c---------Boundary conditions
          if (key .ne. 'PHS ') then
            if (key .ne. 'READ') then
              call getreal(edg1,1,0.0)
              call getreal(edg2,0,edg1)
              call getreal(edg3,0,edg1)
            end if
            call initbc(iop(5),edg1,edg2,edg3,iop(24),inpt,iout)
            call crorgn(edgexyz(1),edgexyz(2),edgexyz(3),
     -        mod(iop(5),10),3)
            call trnsfr(exyzo,edgexyz,3)
          else
c           Primary shell method
            call decode(gcen1,2,ndummyu,keyno,key,0)
            if (keyno .gt. 0) iop(92)=keyno-1
            call decode(phs,nphs,ndummyu,keyno,key,0)
            if (keyno .gt. 0) iop(93)=keyno-1
            call phs_setup(iop,MYRANK)
          end if
        else if (key0 .eq. 'TEMP') then
c---------Set the simulation temperature
          call getreal(temp,1,0.0)
c         beta: 1/kT in kcal/mol
        else if (key0 .eq. 'FETK') then
c---------Modify simulation temperature to represent a coupling parameter run
          call getint(kexp,1,1,4)
          call getint(nquad,1,1,0)
          if (nquad .ne. 3 .and. nquad .ne. 5 .and. nquad .ne. 8) then
            write (iout,2311)
            inperr=inperr+1
          end if
          call getint(iquad,1,1,0)
          if (iquad .gt. nquad) then
            write (iout,2312) iquad,nquad
            inperr=inperr+1
          end if
          cplpar=cpl358(iquad,ixcpl(nquad))
          temp=temp/cplpar**kexp
c         beta: 1/kT in kcal/mol
          beta=1.0/(boltz*temp)
        else if (key0 .eq. 'SANN') then
c---------Simulated annealing - specify schedule
          call anneal_inp(key,temp)
          isannread=1
        else if (key0 .eq. 'SACP') then
c---------Simulated annealing of the cgemical potential - specify schedule
          call anneal_cp_inp(bincr,nmcsacpstep,cav_fract_lim)
          if (iop(129) .eq. 2) nmcsacpsteppnmol=nmcsacpstep
          if (iop(9) .eq. 0 .and. ifilstat(3) .eq. 0) then
            if (MYRANK .eq. 0) call fileopen(file,namlenf,filenames(3),
     -        namlens(3),3,0,numrun,1,0,0,iop(24),iversout,iout,ihist,0)
            numrec(3)=0
            iform(3)=0
            iop(59)=1
          else if (iop(9) .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2368)
          end if
          maxbsave=500
          nstep_ann=0
          nmcav0=0
        else if (key0 .eq. 'OUTP') then
c---------Print various data
          if (key .eq. 'PRPB') then
c...........Print image cell centers
C@DM            if (MYRANK .eq. 0) then
              if (edgexyz(1) .eq. 0) then
                write (iout,2246)
                inperr=inperr+1
              else
                write (iout,1006) (ic,(-cic(k,ic),k=1,3),ic=1,ncell)
              end if
C@DM            end if
          else if (key .eq. 'PRAT') then
c...........Atom parameter print
            if (MYRANK .eq. 0) call printljconst(0,nmolec,nstta,
     -        nslv,0,0,1,nwarn,iout)
          else if (key .eq. 'PRFC') then
c           Print functional group list
            do i=1,100
              if (MYRANK .eq. 0 .and. namfcg(i,1) .ne. '    ')
     -          write (iout,2276) i, namfcg(i,1),nmlfcg(i,1)
            end do
          else if (key .eq. 'REPT') then
c...........Print the full run information
C@DM            call getint(maxrank,0,1,0)
C@DM            if (MYRANK .le. maxrank) then
            call echopr(1)
            if (iop(159) .gt. 0 .or. iop(160) .gt. 0) call echoprpx
C@DM            end if
C@DM            call MPI_Bcast(inperr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM            call MPI_Bcast(iop,200,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
          else if (key .eq. 'PROP') then
            call printopt(iopkeylist,iout)
          end if
        else if (key0 .eq. 'SUPT') then
c---------Solute potential types
          pftyp=key
          if (pftyp .eq. 'AMBR') then
            write (iout,2324)
            inperr=inperr+1
          else
            call find('SUPT',1,nmainkey,mainkey,keyno,4)
            call decode(keys01(ifkey1(keyno)),nkey1(keyno),ndummyu,
     -        keyno,key,0)
            if (keyno .gt. 0) then
              iop(29)=keyno
            else
              iop(29)=iop(3)
            end if
          end if
        else if (key0 .eq. 'RFCR') then
c---------Dielectric constant for reaction field calculation
          call getreal(epsrf,0,80.0)
        else if (key0 .eq. 'SVPT') then
c---------Solvent potential types
          if (key .eq. 'MCY ') then
            call decode(mcy,nmcy,ndummyu,keyno,key,1)
            iop(37)=keyno
          else if (key .eq. 'TIP3') then
            call decode(tip3,ntip3,ndummyu,keyno,key,1)
            iop(37)=2*keyno-1
          else if (key .eq. 'TIP4') then
            call decode(tip4,ntip4,ndummyu,keyno,key,1)
            iop(37)=2*keyno
          else if (key .eq. 'TIP5') then
            call decode(tip5,ntip5,ndummyu,keyno,key,1)
            iop(37)=8
          else if (key .eq. 'GENL') then
            call find('SUPT',1,nmainkey,mainkey,keyno,4)
            call decode(keys01(ifkey1(keyno)),nkey1(keyno),ndummyu,
     -        keyno,key,1)
            iop(37)=keyno
            if (#GT .eq. ione) then
              write (iout,2256) ' solute-','GT','ST'
              inperr=inperr+1
            end if
            if (#GV .eq. ione) then
              write (iout,2256) ' ','GV','SV'
              inperr=inperr+1
            end if
          end if
          if (key .eq. 'READ') then
            call getreal(alj6,1,0.0)
            call getreal(blj12,1,0.0)
            call getreal(qh,0,0.0)
            iop(37)=0
          end if
        else if (key0 .eq. 'PMOD' .or. key0 .eq. 'PFRD' .or.
     -           key0 .eq. 'MODA' .or. key0 .eq. 'RMOD') then
          if (key0 .eq. 'PMOD') then
c-----------Potential modification
            call getint(nmod,0,1,1)
            iop(20)=1
            call pfpinp(keyno,nmod)
            ipflibprint=1
          else if (key0 .eq. 'PFRD') then
c-----------Read a parameter file for potential modification
            call pfparaminp(key)
            iop(31)=1
            write (iout,2333)
          else if (key0 .eq. 'MODA') then
c-----------Atom (element) modification
            call getint(natmod,0,1,1)
            call atommod(natmod)
          else if (key0 .eq. 'RMOD') then
c-----------First shell radius modification
            call getint(nmod,1,1,0)
            call find('SUPT',1,nmainkey,mainkey,npfkey,4)
            do im=1,nmod
              call getname(pfll,lpfll,1,6)
              call find(pfll,1,nkey1(npfkey),keys01(ifkey1(npfkey)),
     -          iopst,6)
              if (iopst .eq. 0) then
                write (iout,2115) pfll
                inperr=inperr+1
                iopst=3
              end if
              pfl4='    '
              call getname(pfl4,lpfl,1,4)
              call namornum(pfl4,icl,pfl4,4)
              if (icl .eq. -1) then
                pfl='      '
                pfl(1:4)=pfl4
                call find(pfl,1,#AT,pflab(1,iopst),icl,6)
                if (icl .eq. 0) then
                  write (iout,2116) pfl,pfll,'first shell radius'
                  inperr=inperr+1
                  icl=1
                end if
              end if
              call getreal(rfs,1,0.0)
              fsrad(icl,iopst)=rfs
            end do
            ipflibprint=1
            iop(173)=1
          end if
        else if (key0 .eq. 'AROM' .or. key0 .eq. 'ENHB' .or.
     -           key0 .eq. 'FLXR') then
          if (key0 .eq. 'AROM') then
c-----------Read the list of aromatic atom types
c           key is the PF type
            call find('SUPT',1,nmainkey,mainkey,keyno,4)
            call decode(keys01(ifkey1(keyno)),nkey1(keyno),ndummyu,
     -        ioppf,key,0)
            call readtypelist(naromc,iaromc,ioppf,pflab,key0,key,
     -        pftyp,inperr,iout,11)
          else if (key0 .eq. 'ENHB') then
c-----------Read the explicit default H-bond parameters
            ihbtypsltslt=keyno-1
            call find('ENHB',1,nmainkey,mainkey,keyno,4)
            call decode(keys01(ifkey1(keyno)),nkey1(keyno),ndummyu,
     -        ihbtypsltmap,key,0)
            call hbondsetup(nogridrun,iout)
            if (iop(112) .eq. 0) go to 1111
          else if (key0 .eq. 'FLXR') then
c-----------Establish the list of flexible residues - rest will form grid
            if (key .eq. 'INDX') then
              call readpairlist(naflxrange,iaflxrange,50,0,
     -          'iaflxrange','flexible residues','residue numbers',
     -          iout,inperr,nwarn,1,nchng,0,0,0,0)
            else
              call getint(nca,0,1,000)
              irectx=51
              do ir=1,nca
                call getnextrec(inpt,iout,irectx,nwwarn)
                if (line(1:4) .ne. 'ATOM' .and.
     -              line(1:6) .ne. 'HETATM') then
                  write (iout,2344) line(1:80)
                  inperr=inperr+1
                end if
                read (line(23:26),*,err=980) l1(ir)
                if (ir .gt. 1) then
                  if (l1(ir) .lt. l1(ir-1)) then
                    write (iout,2331) ir-1,l1(ir-1),ir,l1(ir)
                    inperr=inperr+1
                  end if
                end if
              end do
              naflxrange=1
              iaflxrange(1,1)=l1(1)
              ir=2
              do while (ir .lt. nca)
                do while (l1(ir) .eq. l1(ir-1)+1)
                  ir=ir+1
                end do
                iaflxrange(2,naflxrange)=l1(ir-1)
                naflxrange=naflxrange+1
                if (naflxrange .gt. 50) then
                  write (iout,2327) 50
                  inperr=inperr+1
                  go to 1111
                end if
                iaflxrange(1,naflxrange)=l1(ir)
                ir=ir+1
              end do
              naflxrange=naflxrange-1
            end if
            write (iout,2326) naflxrange,
     -        ((iaflxrange(k,i),k=1,2),i=1,naflxrange)
          end if
        else if (key0 .eq. 'HBMO') then
c---------Read information about non-default hydrogen bonds
          if (key .eq. 'EXCL') then
c           Read the list of atom types to exclude from hydrogen bonding
c           key1 is the PF type
            call find('SUPT',1,nmainkey,mainkey,keyno1,4)
            call decode(keys01(ifkey1(keyno1)),nkey1(keyno1),ndummyu,
     -        ioppf,key1,0)
            call readtypelist(nhbexclude,ityphbexclude,ioppf,pflab,key0,
     -        key,pftyp,inperr,iout,11)
            do ia=1,nstta
c             See if in the excluded list
              do i=1,nhbexclude
                if (ityphbexclude(i) .eq. indextyp(iclsltt(ia)))
     -            ihbdonacc(ia)=0
              end do
            end do
          else if (key .eq. 'ADDT') then
c           Read list of atom types with non-default hydrogen bond(s)
c           key1 is the PF type
            call find('SUPT',1,nmainkey,mainkey,keyno1,4)
            call decode(keys01(ifkey1(keyno1)),nkey1(keyno1),ndummyu,
     -        ioppf,key1,0)
            call readtypelist(nhbnewtype,l1,ioppf,pflab,key0,
     -        key,pftyp,inperr,iout,2*maxhbtyp)
            do it=1,nhbnewtype
              iaddtype=mod(l1(it),#AT)
              if (iaddtype .gt. 0) then
                ida=-1
                if (iatnos(iaddtype,ioppf) .eq. 1) ida=1
                nfound=0
                do ia=1,nstta
                  if (l1(it) .eq. indextyp(iclsltt(ia))) then
                    nfound=nfound+1
                    if (ida .eq. 1) then
                      ihbdonacc(ia)=nhbdontyp+1
                    else
                      ihbdonacc(ia)=-(nhbacctyp+1)
                    end if
                  end if
                end do
                if (nhbdonaccp .gt. 0) then
c                 Check protein donor/acceptor atoms too
                  do ja=1,nhbdonaccp
                    ia=indexhb(ja)
                    if (pflabslt(ia) .eq. pflab(iaddtype,ioppf)) then
                      nfound=nfound+1
                      if (ida .eq. -1) ihbdonacc(ia)=-(nhbacctyp+1)
                      if (ida .eq. +1) ihbdonacc(ia)=nhbdontyp+1
                    end if
                  end do
                end if
                if (nfound .eq. 0) then
                  write (iout,2267) pflab(iaddtype,ioppf)
                  iaddtype=0
                  nwwarn=nwwarn+1
                end if
              end if
              if (iaddtype .gt. 0) then
                addlab=pflab(iaddtype,ioppf)(1:4)
                if (iatnos(iaddtype,ioppf) .eq. 1) then
c                 H, i.e., donor
                  idup=0
                  do i=1,nhbdontyp
                    if (addlab .eq. hbdonlab(i)) idup=1
                  end do
                  if (idup .eq. 0) then
                    if (nhbdontyp .lt. maxhbtyp) then
                      nhbdontyp=nhbdontyp+1
                      hbdonlab(nhbdontyp)=addlab
                      itypdef=0
                      ja=1
                      do while (itypdef .eq. 0 .and.
     -                          ja .le. nhbdonaccp)
                        ia=indexhb(ja)
                        if (pflabslt(ia)(1:4) .eq. addlab) then
                          if (nneig(ia) .gt. 0) then
                            if (ianslt(ineig(1,ia)) .eq. 7) itypdef=1
                            if (ianslt(ineig(1,ia)) .eq. 8) itypdef=2
                          end if
                        end if
                        ia=ia+1
                      end do
                      idontypdef(nhbdontyp)=itypdef
                      if (itypdef .gt. 0) then
c                       Establish default HB type
                        do i=1,nhbacctyp
                          if (iacctypdef(i) .gt. 0)
     -                     ixdonacc(nhbdontyp,i)=
     -                       ixdonacc(itypdef,iacctypdef(i))
                        end do
                      end if
                    end if
                  end if
                else
c                 Acceptor
                  idup=0
                  do i=1,nhbacctyp
                    if (addlab .eq. hbacclab(i)) idup=1
                  end do
                  if (idup .eq. 0) then
                    if (nhbacctyp .lt. maxhbtyp) then
                      nhbacctyp=nhbacctyp+1
                      hbacclab(nhbacctyp)=addlab
                      itypdef=0
                      if (iatnos(iaddtype,ioppf) .eq. 8) then
                        ja=1
                        do while (itypdef .eq. 0 .and.
     -                            ja .le. nhbdonaccp)
                          ia=indexhb(ja)
                          if (pflabslt(ia)(1:4) .eq. addlab) then
                            if (nneig(ia) .eq. 1) itypdef=2
                            if (nneig(ia) .eq. 2) itypdef=1
                          end if
                          ia=ia+1
                        end do
                        iacctypdef(nhbacctyp)=itypdef
                        if (itypdef .gt. 0) then
c                         Establish default HB type
                          do i=1,nhbdontyp
                            if (idontypdef(i) .gt. 0)
     -                       ixdonacc(i,nhbacctyp)=
     -                         ixdonacc(idontypdef(i),itypdef)
                          end do
                        end if
                      end if
                    end if
                  end if
                end if
              end if
            end do
          else if (key .eq. 'ADDC') then
c           Read coefficients for non-default hydrogen bond(s)
            pfl1='    '
            call getname(pfl1,namlenpfl,1,4)
            call find(pfl1,1,nhbdontyp,hbdonlab,idonfound,4)
            if (idonfound .eq. 0) then
              write (iout,2266) 'donor',pfl1
              inperr=inperr+1
            end if
            pfl2='    '
            call getname(pfl2,namlenpfl,1,4)
            call find(pfl2,1,nhbacctyp,hbacclab,iaccfound,4)
            if (iaccfound .eq. 0) then
              write (iout,2266) 'acceptor',pfl2
              inperr=inperr+1
            end if
            if (idonfound*iaccfound .gt. 0) then
              call getreal(c12,1,0.0)
              call getreal(c10,1,0.0)
              if (c10 .eq. 0.0 .and. c12 .eq. 0.0) then
                ixdonacc(idonfound,iaccfound)=0
              else
                if (idonfound .gt. nhbdontyp .or.
     -              iaccfound .gt. nhbacctyp) then
                  nhbdonacctyp=nhbdonacctyp+1
                  ixdonacc(idonfound,iaccfound)=nhbdonacctyp
                end if
                ihbdonacctyp=ixdonacc(idonfound,iaccfound)
                cohhb12(ihbdonacctyp)=c12
                cohhb10(ihbdonacctyp)=c10
                call getreal(rhhmin,0,0.0)
                rminhbheavy2(ihbdonacctyp)=rhhmin**2
              end if
            end if
          end if
        else if (key0 .eq. 'SVIN') then
c---------Read the the desolvation parameters
          iopdesolv=iop(113)
          nospecterm=0
          call getreal(gaussdist2,0,24.50)
          call getreal(gausslimfac,0,4.0)
          gaussdistlim=gaussdist2*gausslimfac
          call getreal(qk_par,0,0.01097)
          call getreal(a_solv_par(1),0,-0.00143)
          call getreal(v_solv_par(1),0,33.5103 )
          call getreal(a_solv_par(2),0,-0.00052)
          call getreal(v_solv_par(2),0,33.5103 )
          call getreal(a_solv_par(3),0,-0.00162)
          call getreal(v_solv_par(3),0,22.4493 )
          call getreal(a_solv_par(4),0,-0.00251)
          call getreal(v_solv_par(4),0,17.1573 )
          call getreal(a_solv_par(5),0,-0.00214)
          call getreal(v_solv_par(5),0,33.5103)
          call getreal(a_solv_par(6),0,-0.00214)
          call getreal(v_solv_par(6),0,33.5103)
          call getreal(a_solv_par(7),0,+0.00051)
          call getreal(v_solv_par(7),0, 0.0   )
          call getreal(qpolarcarbmin,0,0.2)
          call setatdtype(nstta_full,maxmaptyp,naromc,iatdtypslt,
     -      ianatdtyp,ianslt,iaromc,indextyp,iclsltt,nneig,ineig,#NL,
     -      max_atdtyp,inperr,iout)
          call zeroit(s_solv_slt,nstta)
          call zeroiti(ipolarslt,0,nstta)
c         Use desolvation contributions
          call zeroit(v_solv_slt,nstta)
c         Change to united atom charges on carbons
          do ia=1,nstta
            if (ianslt(ia) .eq. 1) then
              iaheavy=ineig(1,ia)
              if (ianslt(iaheavy) .eq. 6) then
                qslt(iaheavy)=qslt(iaheavy)+qslt(ia)
                qslt(ia)=0.0
                qslteps(iaheavy)=qslteps(iaheavy)+qslteps(ia)
                    qslteps(ia)=0.0
              end if
            end if
          end do
          if (iop(113) .eq. 4) then
c           Determine polar labels
            do ia=1,nstta
              ipolarslt(ia)=1
            end do
          end if
          do ia=1,nstta
            call setdesolvparams(iop(113),keep,ia,ianslt,qslt,ipolarslt,
     -        iatdtypslt,qpolarcarbmin,v_solv_slt,s_solv_slt,
     -        v_solv_par,a_solv_par,qk_par,nstta,iout,inperr,max_atdtyp)
          end do
        else if (key0 .eq. 'SPST') then
c---------Special potential (field or molec-dependent)
          if (key .eq. 'EMAP' .or. key .eq. 'CMAP' .or.
     -        key .eq. 'CMPW') then
c           Energy map potential (code originaly from Dr. Meng Cui)
            call getint(ngridmap,0,1,131)
            call checkdim(ifail,iout,inperr,'GM',ngridmap,1,0,0)
            call getreal(evdwlim,0,1000.0)
            call getreal(elstatmin,0,-1000.0)
            call getreal(scalemap,0,1.0)
            incrhmap=3
            if (ihbtypsltmap .gt. 0) incrhmap=2
c           There are maxmaptyp-incrhmap atom types + lp and es map
            maxhbgrid=#GH
            maxhbng=25
c           maptyph is the map number of hydrogens (>NH type)
c           maptyphh is the map number of hydrogens (-OH type)
            maptyph=maxmaptyp-3
            maptyphh=maptyph+1
            if (iop(113) .eq. 0)
     -        call setatdtype(nstta,maxmaptyp,naromc,iatdtypslt,
     -          ianatdtyp,ianslt,iaromc,indextyp,iclsltt,nneig,ineig,
     -          #NL,max_atdtyp,inperr,iout)
            if (nogridrun .eq. 1) then
              write (iout,2301)
              call datprt(2)
            end if
            if (key .eq. 'EMAP') then
c             Read maps
              call readmap('prot.pi',7,engmap(1,1,1,maxmaptyp),ngridmap,
     -          evdwlim,scalemap,elstatmin,maxmaptyp,1,gridmap,
     -          gridmapcent,iop(24),inperr,1,nofile,nwarn,iout)
              edgemap=ngridmap*gridmap
              edgemap2=(edgemap+gridmap)/2.0
              do k=1,3
                gridedgeinc(k)=edgemap2-gridmapcent(k)
                egridmin(k)=gridmapcent(k)-edgemap/2.0
                egridmax(k)=gridmapcent(k)+edgemap/2.0
              end do
              if (iop(113) .gt. 0) then
                inperr0=inperr
                call readmap('lp.map',6,engmap(1,1,1,maxmaptyp-1),
     -            ngridmap,evdwlim,scalemap,elstatmin,maxmaptyp-1,
     -            0,gridmap,gridmapcent,iop(24),inperr,1,nofile,nwarn,
     -            iout)
                if (inperr .gt. inperr0)
     -            write (iout,2202)'desolvation','lp'
              end if
              nemaperr=0
              nofilesum=0
              inperr0=inperr
              nemap=0
              filename1(3:6)='.map'
              do while (nemap .lt. maxmaptyp-incrhmap .and.
     -                  inperr .eq. inperr0)
                nemap=nemap+1
                filename1(1:2)=mapfiles(nemap)
                if (iop(24) .gt. 0) write (iout,2210)
     -            nemap,iatdatnos(nemap),filename1(1:6)
                call readmap(filename1,6,engmap(1,1,1,nemap),ngridmap,
     -            evdwlim,scalemap,evdwlim,nemap,0,gridmap,gridmapcent,
     -            iop(24),inperr,0,nofile,nwarn,iout)
                if (inperr .gt. inperr0) nemaperr=nemaperr+1
                if (nofile .gt. 0) then
                  ianatdtyp(iatdatnos(nemap))=-1
                  nofilesum=nofilesum+1
                end if
                call zeroit(gridcent,3)
              end do
              if (nemaperr .gt. 0) then
                write (iout,2211) nemap-nemaperr,maxmaptyp-incrhmap
                inperr=inperr+1
              end if
              if (nofilesum .gt. 0) write (iout,2280) nofilesum
              mapedone=1
            else
c             Calculate maps
              call getreal(edgemap,1,0.0)
              gridmap=edgemap/ngridmap
c             This is just to keep consistent with reading the maps
              edgemap=ngridmap*gridmap
              edgemap2=(edgemap+gridmap)/2.0
              do k=1,3
                call getreal(gridmapcent(k),1,0.0)
                gridedgeinc(k)=edgemap2-gridmapcent(k)
              end do
              call getreal(gridbuffer,1,0.0)
c             Run map calculations after the hydrogen-bond grid has been done
            end if
c           Determine the rectangle enclosing the moving atoms and the
c           extent of grid box violations
            call trnsfr(xyzmin,c(1,1),3)
            call trnsfr(xyzmax,c(1,1),3)
            call zeroit(devmax_xyz,12)
            nocharge=1
            do ia=1,nstta
              do k=1,3
                if (c(k,ia) .lt. xyzmin(k)) xyzmin(k)=c(k,ia)
                if (c(k,ia) .gt. xyzmax(k)) xyzmax(k)=c(k,ia)
              end do
              if (qslt(ia) .ne. 0.0) nocharge=0
            end do
            if (nocharge .eq. 0 .and. icompopt(25) .eq. 0) then
              write (iout,2364)
              inperr=inperr+1
            end if
            devmaxmax=0.0
            do k=1,3
              lb=gridmapcent(k)-edgemap/2.0
              ub=gridmapcent(k)+edgemap/2.0
              devl=lb-xyzmin(k)
              if (devl .gt. 0.0) devmax_xyz(1,k)=devl
              devu=xyzmax(k)-ub
              if (devu .gt. 0.0) devmax_xyz(2,k)=devu
              devmaxmax=amax1(devmaxmax,devl,devu)
              dev=xyzmin(k)-lb
              if (dev .gt. 0.0) devmax_xyz(3,k)=dev
              dev=ub-xyzmax(k)
              if (dev .gt. 0.0) devmax_xyz(4,k)=dev
            end do
            write (iout,2328) (lxyz(k),xyzmin(k),xyzmax(k),
     -        xyzmax(k)-xyzmin(k),(xyzmax(k)+xyzmin(k))/2.0,k=1,3),
     -        gridmapcent,edgemap
            if (devmaxmax .gt. 0.0) then
              if (devmaxmax .gt. 2.0) then
                write (iout,2347)
                inperr=inperr+1
              else
                write (iout,2348)
                nwwarn=nwwarn+1
              end if
              write (iout,2329) 'Largest outside',
     -          ((lxyz(k),devmax_xyz(i,k),i=1,2),k=1,3)
            end if
            write (iout,2329) 'Smallest inside',
     -        ((lxyz(k),devmax_xyz(i,k),i=3,4),k=1,3)
            if (ihbtypsltmap .gt. 0) then
c             Explicit hydrogen-bonding term - prepare the coarse grid
              nhbgrid=edgemap/rmaxhb-1
              if (nhbgrid .gt. maxhbgrid) then
                write (iout,2203)
                inperr=inperr+1
              end if
              hbgrid=edgemap/nhbgrid
              call zeroiti(nhbaccng,0,maxhbgrid**3)
              call zeroiti(nhbdonng,0,maxhbgrid**3)
              noxcheck=0
              nhydcheck=0
              inperr0=inperr
              do ja=1,nhbdonaccp
                ia=indexhb(ja)
                if (ihbdonacc(ia) .eq. 0) then
                  write (iout,3006) ja,ia
                  inperr=inperr+1
                else
                  if (ihbdonacc(ia) .gt. 0) then
                    ihydox=1
                    nhydcheck=nhydcheck+1
                  else
                    ihydox=-1
                    noxcheck=noxcheck+1
                  end if
                  ix=(cslt(1,ia)+gridedgeinc(1))/hbgrid+1
                  iy=(cslt(2,ia)+gridedgeinc(2))/hbgrid+1
                  iz=(cslt(3,ia)+gridedgeinc(3))/hbgrid+1
                  if (max0(ix,iy,iz) .ge. 0) then
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix+1,iy,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy+1,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy,iz+1,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix+1,iy+1,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix+1,iy,iz+1,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy+1,iz+1,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix+1,iy+1,
     -                iz+1,ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix-1,iy,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy-1,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy,iz-1,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix-1,iy-1,iz,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix-1,iy,iz-1,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy-1,iz-1,
     -                ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                    call addox(ia,nhbdonng,nhbaccng,ihbng,ix-1,iy-1,
     -                iz-1,ihydox,inperr,iout,nhbgrid,maxhbgrid,maxhbng)
                  end if
                end if
              end do
              minlist=0
              if (inperr0 .lt. inperr) then
c               Find the largest deficit
                do ix=1,nhbgrid
                  do iy=1,nhbgrid
                    do iz=1,nhbgrid
                      ideficit=0
                      if (nhbaccng(ix,iy,iz) .lt. 0)
     -                  ideficit=nhbaccng(ix,iy,iz)
                      if (nhbdonng(ix,iy,iz) .lt. 0)
     -                  ideficit=ideficit-nhbdonng(ix,iy,iz)
                      if (ideficit .lt. minlist)
     -                  minlist=ideficit
                    end do
                  end do
                end do
              end if
              if (minlist .lt. 0)
     -          write (iout,2265) maxhbng,maxhbng-minlist
              maxacc=0
              maxdon=0
              maxdonacc=0
              do ix=1,nhbgrid
                do iy=1,nhbgrid
                  do iz=1,nhbgrid
                    if (nhbaccng(ix,iy,iz) .gt. maxacc)
     -                maxacc=nhbaccng(ix,iy,iz)
                    if (nhbdonng(ix,iy,iz) .gt. maxdon)
     -                maxdon=nhbdonng(ix,iy,iz)
                    if (nhbaccng(ix,iy,iz)+nhbdonng(ix,iy,iz) .gt.
     -                  maxdonacc) maxdonacc=
     -               nhbdonng(ix,iy,iz)+nhbaccng(ix,iy,iz)
                  end do
                end do
              end do
              write (iout,2216) noxcheck,nhydcheck,maxacc,maxdon,
     -          maxdonacc
            end if
            if (iop(113) .eq. 0) call zeroiti(ipolarslt,0,nstta)
            if (key .eq. 'CMPW' .or. key .eq. 'CMAP') then
              if (iop(61) .eq. 0) then
                write (iout,2318)
                call datprt(-1)
              end if
              write (iout,3007) nstta_full-nstta
            end if
            call initpfslt(1,nstta_full,iopslt,iclslt,iclsltt,
     -        indextyp)
            call grouplist(nstta+1,nstta_full,nsttg,nsttg,igrslt,
     -        nsttg_full,ifgrslt,ilgrslt,0,#GR,'GR')
            call zeroiti(l1,0,nstta_full)
            do ig=nsttg+1,nsttg_full
              call findtcent(ineig,nneig,l1,l2,l3,ifgrslt(ig),
     -        ilgrslt(ig),igrcnt(ig),ncentfound,1,iout,inperr,#ST,#NL)
            end do
            call setatdtype(nstta_full,maxmaptyp,naromc,iatdtypslt,
     -        ianatdtyp,ianslt,iaromc,indextyp,iclsltt,nneig,ineig,#NL,
     -        max_atdtyp,inperr,iout)
c           Skip map calculation if input was in error
            if (inperr .gt. 0) go to 1111
            if (key .eq. 'CMPW') then
c             First make sure the files can be opened
              open(unit=90,status='new',file='prot.pi',
     -          form='UNFORMATTED',iostat=iopen90)
              if (iopen90 .gt. 0) write (iout,3005) 'prot.pi'
              nemap=0
              filename1(3:6)='.map'
              do while (nemap .lt. maxmaptyp-incrhmap)
                nemap=nemap+1
                filename1(1:2)=mapfiles(nemap)
                open(unit=90+nemap,status='new',file=filename1(1:6),
     -            form='UNFORMATTED',iostat=iopen)
                if (iopen .gt. 0) write (iout,3005) filename1(1:6)
                iopen90=iopen90+iopen
              end do
              if (iop(113) .gt. 0) then
                open(unit=90+nemap+1,status='new',file='lp.map',
     -            form='UNFORMATTED',iostat=iopen)
                if (iopen .gt. 0) write (iout,3005) 'lp.map'
                iopen90=iopen90+iopen
              end if
              if (iopen90 .gt. 0) then
                write (iout,2282)
                inperr=inperr+1
              end if
            end if
            if ((key .eq. 'CMPW' .and. iopen90 .eq. 0) .or.
     -           key .eq. 'CMAP') then
              call calcmap(engmap,ngridmap,edgemap,gridmapcent,cslt,
     -          qslt,ianslt,ineig,ifgrslt,ilgrslt,igrcnt,iatdtypslt,
     -          nsttg,nsttg_full,evdwlim,elstatmin,scalemap,gridmap,
     -          gridbuffer,iop(24),iout,#ST,#NL,maxmaptyp)
              mapedone=2
            end if
            if (key .eq. 'CMPW' .and. iopen90 .eq. 0) then
              call writemap(90,engmap(1,1,1,maxmaptyp),ngridmap,
     -          gridmap,1,gridmapcent)
              do imap=1,nemap
                call writemap(90+imap,engmap(1,1,1,imap),ngridmap,
     -            gridmap,0,gridmapcent)
              end do
              if (iop(113) .gt. 0)
     -          call writemap(90+nemap+1,engmap(1,1,1,maxmaptyp-1),
     -            ngridmap,gridmap,0,gridmapcent)
            end if
          else if (key .eq. 'BLCK') then
c           Block out from the solvent a slab
c           Axis normal to the slab
            call getint(intf(1),1,1,1)
c           Solute central atom #
            call getint(intf(2),1,1,1)
c           Upper and lower limits
            call getreal(rf(1),1,0.0)
            call getreal(rf(2),2,0.0)
c           Delete molecules in the forbidden slab
            call zeroiti(l1,0,nmolec)
            ndel=0
            do is=2,nmolec
              call eslvfield(c(1,nstta+(is-2)*nslv+1),nslv,efieldismn)
              if (efieldismn .gt. 0.0) then
                 ndel=ndel+1
              else if (ndel .gt. 0) then
                 call trnsfr(c(1,nstta+(is-ndel-2)*nslv+1),
     -             c(1,nstta+(is-2)*nslv+1),3*nslv)
              end if
            end do
            if (ndel .gt. 0) then
              nmolec=nmolec-ndel
              numsolv=nmolec-1
              natoms=nstta+numsolv*nslv
              write (iout,2077) ndel,numsolv
              call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,
     -          edgexyz,iop(47),iop(41),iop(90),iop(30),iop(24),
     -          filenames(2),namlens(2),iop(98),0,c)
            end if
          else if (key .eq. 'NONE') then
            iop(67)=0
          end if
        else if (key0 .eq. 'SPPS') then
c---------Molecule-dependent potential
          call getint(niparm,1,1,0)
          do i=1,niparm
            call getint(intm(i),1,1,0)
          end do
          call getint(nrparm,1,1,0)
          do i=1,nrparm
            call getreal(rm(i),1,0.0)
          end do
          if (niparf .gt. 10 .or. nrparf .gt. 10) then
            write (iout,2041)
            inperr=inperr+1
          end if
        else if (key0 .eq. 'CNST') then
c---------Constraint input
          if (key .eq. 'NONE') then
            if (iop(117) .eq. 0 .and. MYRANK .eq. 0) write (iout,2330)
            iop(117)=0
          else
            call decode(cnst,ncnst,ndummyu,keyno,key1,0)
            call getint(nconstr_pair,1,1,0)
            call checklim(ifail,iout,inperr,1,100,nconstr_pair,1,
     -          'number of restraints',20)
            do i=1,nconstr_pair
              if (iop(117) .eq. 1) then
c               Initialize constraints
                call getint(iconstr_pair(1,i),1,1,0)
                call getint(iconstr_pair(2,i),1,1,0)
              end if
              call getreal(d_target(i),1,0.0)
              call getreal(force_target(i),1,0.0)
              call getreal(tol_target(i),0,0.0)
              eng_tol(i)=force_target(i)*tol_target(i)**2
            end do
            if (key1 .eq. 'WCNT') iop(117)=iop(117)+2
          end if
        else if (key0 .eq. 'CHRG') then
c---------Charge manipulations
          if (key .eq. 'ZERO') iop(46)=1
          if (key .eq. 'INPT') iop(31)=1
        else if (key0 .eq. 'NONB') then
c---------Non-Boltzmann samplings
          if (key .eq. 'SCTR' .or. key .eq. 'SCTN') then
            call getreal(tornbfac,1,1.0)
            call check01int(tornbfac,'Torsion scale factor',iout,inperr)
            tornbfac=1.0-tornbfac
            call getreal(repnbfac,1,1.0)
            call check01int(repnbfac,'Solute-solute scale factor',
     -        iout,inperr)
            repnbfac=1.0-repnbfac
          else if (key .eq. 'SCRP') then
            call getreal(repnbfac,1,1.0)
            call check01int(repnbfac,'Solute-solvent scale factor',
     -        iout,inperr)
            repnbfac=1.0-repnbfac
          else if (key .eq. 'SCNB') then
            call getreal(sltssltfac,1,1.0)
            call check01int(repnbfac,'Solute-solute scale factor',
     -        iout,inperr)
            sltsltfac=1.0-sltsltfac
          else if (key .eq. 'TMOD') then
            call getreal(slttmp,1,temp)
          else if (key .eq. 'TSAL') then
            call getreal(tsexp,1,2.0)
            if (tsexp .le. 1.0001) then
              if (MYRANK .eq. 0) write (iout,2184)
              inperr=inperr+1
              tsexp=2.0
            end if
            tsfac=tsexp/(1.0-tsexp)
            call getreal(signincfac,0,1.1)
          end if
          call getreal(ew0inp,0,0.0)
          ew0nb=ew0inp
        else if (key0 .eq. 'SLFT') then
c---------Selftest options
          if (iop(13) .eq. 4) iop(13)=0
          call decode(slft,nslft,ndummyu,keyno,key1,0)
          if (keyno .gt. 0) iop(94)=keyno-1
          if (iop(94) .eq. 1) iop(95)=1
          if (iop(94) .eq. 4 .and. iop94old .ne. 4) then
c           Open 'last good' checkpoint file
            if (MYRANK .eq. 0) call fileopen(file,namlenf,filenames(14),
     -        namlens(14),14,0,99,1,0,1,iop(24),iversout,iout,ickpok,0)
          end if
          call getint(nmcslftst,0,1,5000000)
        else if (key0 .eq. 'STOL') then
c---------Set self-test tolerances
          do i=1,10
            call getreal(tolr(i),0,0.0)
          end do
          call settol(nstta,nstfa,nmolec,iout)
          call echo_tol(iout)
        else if (key0 .eq. 'SAMP') then
c---------Sampling technique
          if (key .eq. 'METR') then
            call getreal(rngminfac,0,0.8)
            rsphm2=(0.5*rngminfac)**2
          else if (key .eq. 'FBPR' .or. key .eq. 'FBSC') then
            call getreal(fblamd,0,0.5)
          end if
          if (key .eq. 'FBSC') then
            irectx=27
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1007,err=980) nfblam
            if (nfblam .gt. 9) then
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,9359) nfblam
            end if
            if (iop(24) .gt. 0) write (iout,1336) nfblam
C@DM            if (iop(24) .gt. 2) write (ioutdb,3000) key0,MYRANK,nfblam
            irectx=28
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1012,err=980) (rfblam(i),afblam(i),i=1,nfblam)
            if (iop(24) .gt. 0)
     -        write (iout,1337) (rfblam(i),afblam(i),i=1,nfblam)
C@DM            if (iop(24) .gt. 2) write (iout,3001) key0,MYRANK,
C@DM     -        (i,rfblam(i),afblam(i),i=1,nfblam)
          end if
        else if (key0 .eq. 'PRFI') then
c---------Insertion with preferential sampling
          call decode(pfs1,npfs1,ndummyu,keyno,key1,1)
          if (keyno .gt. 0) iop(8)=keyno-1
          call pfswinp(iop(63),iop(24),npfid,
     -      rpfid,apfid,iop(8),wpfidcen,stiffid,55,inperr,inpt,iout)
c         See if the two kinds of PS distances differ
          if (iop(8) .eq. iop(17)) then
            iop(56)=0
            if (iop(8) .eq. 2) then
              if (amax1(abs(wpfmvcen(1)-wpfidcen(1)),abs(wpfmvcen(3)-
     -          wpfidcen(2)),abs(wpfmvcen(3)-wpfidcen(3))) .gt. 0.01)
     -          iop(56)=1
            end if
          else
            iop(56)=1
          end if
        else if (key0 .eq. 'STEP') then
c---------Stepsize selection parameters
          call getreal(cedslt,1,0.0)
          call getreal(rtxslt,1,0.0)
          if (cedslt+rtxslt .gt. 0.0) then
            isltmove=1
            isltsmpl=1
          end if
          rtxslt=rtxslt/rdtodg
          call getreal(cedslv,1,0.0)
          call getreal(rtxslv,1,0.0)
          rtxslv=rtxslv/rdtodg
          if (nslv .eq. 1) then
            if (rtxslv .ne. 0.0) then
              if (MYRANK .eq. 0) write (iout,2027) rtxslv
              nchng=nchng+1
              rtxslv=0.0
            end if
          end if
          call getint(nsltfreq,0,1,0)
        else if (key0 .eq. 'MVRT') then
c---------Translation/rotation separation
          call getreal(wsltdisp,0,1.0)
          call getreal(wsltrot,0,1.0)
          call getreal(wslvdisp,0,1.0)
          call getreal(wslvrot,0,1.0)
          wsltdisp=wsltdisp/(wsltdisp+wsltrot)
          wslvdisp=wslvdisp/(wslvdisp+wslvrot)
          wsltrot=1.0-wsltdisp
          wslvrot=1.0-wsltdisp
        else if (key0 .eq. 'STSC') then
c---------Stepsize scale input
          call getreal(scalefac,0,1.0)
          call scalestep(iop(110),scalefac,1,0,0,0,iop(24),inperr,iout)
        else if (key0 .eq. 'MOVE') then
c---------Move selection strategy
          if (key(1:3) .eq. 'PRS') then
c           Preferential sampling, get more input
            call decode(pfs1,npfs1,ndummyu,keyno,key1,1)
            if (keyno .gt. 0) iop(17)=keyno-1
            call pfswinp(iop(12)-3,iop(24),npfmv,
     -        rpfmv,apfmv,iop(17),wpfmvcen,stiffmv,0,inperr,inpt,iout)
          end if
        else if (key0 .eq. 'INCT') then
c---------Solvent-sovent inner cutoff
          if (key .eq. 'EXPL') then
            call getreal(rwwina,0,1.0)
            rwwin2=rwwina**2
          else
            rwwin2=0.0
          end if
        else if (key0 .eq. 'SUVC') then
c---------Solute-solvent cutoff
          if (key .eq. 'SPCC' .or. key .eq. 'SPGC' .or. key .eq. 'ISOE')
     -      call getreal(cutslt,0,0.0)
          if (key(3:4) .eq. 'GC') then
            iop(43)=1
            if (iop(7) .ge. 3) iop(7)=iop(7)-3
          else if (key .eq. 'ISOE') then
            iop(43)=0
          end if
        else if (key0 .eq. 'SUUC') then
c---------Solute-solute cutoff
          call getreal(cutuu,0,0.0)
        else if (key0 .eq. 'SVVC') then
c---------Solvent-sovent cutoff
          call getreal(cutslv,0,0.0)
          call getreal(rccomp,0,0.0)
          call getreal(cutexp,0,0.0)
        else if (key0 .eq. 'SIZE') then
c---------Obsolete key - explain change
          write (iout,2189)
          inperr=inperr+1
        else if (key0 .eq. 'NSLV') then
c---------Number of solvents and solvents to keep fixed
          call  getint(numsolv,1,1,0)
          nmolec=numsolv+1
          call checkdim(ifail,iout,inperr,'MO',nmolec,1,0,0)
          nmol3=3*nmolec
          if (iop(41) .eq. 0) iop(97)=0
          call getint(nsolvfix,0,1,0)
C@DM          call setlim(2,nmolec,NUMNOD,iflslv,icpuslv,MYRANK,iout,MAXNOD,
C@DM     -      iop(24),'solvent')
C@DM          call setdispl(NUMNOD,iflslv,1,ndisplslv,ncountslv,1,MAXNOD)
C@DM          call setdispl(NUMNOD,iflslv,3,ndisplslv3,ncountslv3,1,MAXNOD)
        else if (key0 .eq. 'FREE') then
c---------Free energy options
C@DMc         For now cancel all non-Widom FE options
C@DM          if (key .ne. 'WIDO' .and. key .ne. 'PMF1') key='XXXX'
          if (key .eq. 'WIDO') then
c           Calculate excess chemical potential with the Widom method
            call getreal(diamslv,1,0.0)
            iop(62)=0
            call getint(ngrid(1),0,1,#GX)
            call getint(ngrid(2),0,1,#GY)
            call getint(ngrid(3),0,1,#GZ)
            call checkdim(ifail,iout,inperr,'GX',ngrid(1),1,0,0)
            call checkdim(ifail,iout,inperr,'GY',ngrid(2),1,0,0)
            call checkdim(ifail,iout,inperr,'GZ',ngrid(3),1,0,0)
            call getint(nwgtry,0,1,1)
            call getint(nwitry,0,1,1)
            call getint(ishifttp(1),0,1,0)
            call getint(ishifttp(2),0,1,0)
            call getint(ishifttp(3),0,1,0)
            call getint(nmolwid,0,1,1)
            call checkdim(ifail,iout,inperr,'MW',nmolwid,1,0,0)
            do im=1,nmolwid
              call getint(ifdummy(im),0,1,0)
              call getreal(ew0(im),0,0.0)
            end do
            call edgetogredge(gredge,edgelgr,edgergr,edgexyz,
     -            iop(79),limgrl,limgru,gridcent,grll,grlu,iout,nchng,
     -        idebug(58))
C@DBC@DM            if (iop(24) .gt. 1) then
C@DBC@DM              call mpi_rangather_scatter(1,iout,iop(24),'TST1')
C@DBC@DM              call mpi_rangather_scatter(2,iout,iop(24),'TST2')
C@DBC@DM            end if
          else if (key .eq. 'CHIM') then
c           Calculate excess free energy with the chimera method
            call decode(chimd,nchimd,ndummyu,keyno,key,1)
            iop(28)=keyno
            if (iop(28) .eq. 1) call getint(ngrid(1),0,1,#GX)
            if (iop(28) .eq. 2) call getint(ngrid(2),0,1,#GY)
            if (iop(28) .eq. 3) call getint(ngrid(3),0,1,#GZ)
            if (iop(28) .eq. 4) then
              call getreal(rnearchim,0,4.0)
              call getreal(pfarchim,0,0.0)
            end if
            call getint(nwitry,0,1,1)
            call getint(nmolwid,0,1,1)
            call checkdim(ifail,iout,inperr,'MW',nmolwid,1,0,0)
            do im=1,nmolwid
              call getint(ifdummy(im),0,1,0)
              call getreal(ew0(im),0,0.0)
            end do
            call edgetogredge(gredge,edgelgr,edgergr,edgexyz,
     -        iop(79),limgrl,limgru,gridcent,grll,grlu,iout,nchng,
     -        idebug(58))
          else if (key .eq. 'ADDW') then
c           Calculate excess chemical potential with the Widom method for an
c           additional group
            call decode(addw,naddw,ndummyu,keyno,key,1)
            iop(105)=keyno-1
c           nwgtry: Number of torsion gridpoints to move the new group
            call getint(nwgtry,1,1,1)
c           nwitry: Number of torsion gridpoints to move the main anchor atom
            call getint(nwitry,1,1,1)
            call checkdim(ifail,iout,inperr,'GX',nwitry*nwgtry,0,0,0)
            call getint(nmolwid,1,1,1)
            call checkdim(ifail,iout,inperr,'MW',nmolwid,1,0,0)
            call getint(nmcransh,1,1,1)
c           There are nghanchor atoms common between the ligand & the ghost grp
c           ighanchor(k): indices (negative index means to drop that atom);
c           ighanchor(nghanchor+1) is the atom to be replaced
c           For the ghost groups, the nghanchor-th atom has to be the center
            call getint(nghanchor,1,1,1)
            call checklim(ifail,iout,inperr,1,199,nghanchor,1,
     -        'number of anchor atoms',22)
            do k=1,nghanchor+1
              call getint(ighanchor(k),1,1,0)
            end do
            call getint(nghdrop,1,1,1)
            call checklim(ifail,iout,inperr,1,100,nghanchor,1,
     -        'number of atoms to drop',23)
            do k=1,nghdrop
              call getint(ighdrop(k),1,1,0)
            end do
            do im=1,nmolwid
              call getreal(ew0(im),0,0.0)
            end do
          else if (key .eq. 'TICA' .or. key .eq. 'PMLI' .or.
     -        key .eq. 'PMNL') then
            call decode(pmli,npmli,ndummyu,keyno,key1,1)
            if (keyno .gt. 0) iop(35)=keyno-1
            ngquadp=0
            if (key .eq. 'TICA') then
c             Input ppti -- > kTI tolerance parameters
              call getint(ngquadp,0,1,0)
              call getint(igquadp,0,1,0)
              call getreal(epstol,0,0.0)
              call getreal(sigtol,0,0.0)
              call getreal(qtol,0,0.0)
              call getreal(xyztol2,0,0.0)
            else if (key .eq. 'PMNL') then
c             Overlap ratio method distributions
c             gmor0k, gmor1k: minimum of the e& - e&- and e&+ - e& distributions
c             gdvork: gridsize of the distributions for OR method
              call getreal(gmor0k,1,0.0)
              call getreal(gmor1k,1,0.0)
              call getreal(gdvork,1,0.0)
            end if
c           cplpar: coupling parameter for TI;
c           uspar0,uspar1: cplpar defining initial and final state for US
c           for iop(35)=2, the solute pair on unit icord is assumed to have been
c           prepared previously as the uscpo0,uscpo1 combination of the
c           solute as read into cslt.
c           ptiexp : coupling parameter exponent
c           For ptiexp>1, iop(30)=6 will not work
            irectx=5
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1013,err=980) ptiexp,ii,cplparr,uspar0,uspar1,
     -        uscpo0,uscpo1
            if (iop(24) .gt. 0) write (iout,1305) ptiexp,ii,cplparr,
     -        uspar0,uspar1,uscpo0,uscpo1
            call check01int(cplparr,'coupling parameter',iout,inperr)
            if (ngquadp .eq. 0) then
              cplpar=cplparr
            else if (ngquadp .gt. 8) then
              write (iout,2045) ngquadp
              inperr=inperr+1
            else if (ixcpl(ngquadp) .eq. 0) then
              write (iout,2045) ngquadp
              inperr=inperr+1
            else if (igquadp .eq. 0 .or. igquadp .gt. ngquadp) then
              write (iout,2046) igquadp,ngquadp
              inperr=inperr+1
            else
              cplpar=cpl358(igquadp,ixcpl(ngquadp))
            end if
          else if (key .eq. 'PMF1') then
            isltsmpl=1
            call decode(pmf2,npmf2,ndummyu,keyno,key2,1)
            iop(18)=keyno-1
            call decode(pmf3,npmf3,ndummyu,keyno,key3,1)
            iop(38)=keyno-1
            call decode(pmf4,npmf4,ndummyu,keyno,key4,1)
            iop(51)=keyno-1
            if (key2(1:3) .eq. 'WRF') call getint(imolcent2,0,1,0)
            if (key2 .eq. 'WRTR') then
c             Read translate/rotate stepsize
              numrot=0
              numtran=0
              do k=1,3
                call getreal(cdpmf(k),0,0.0)
                if (cdpmf(k) .gt. 0.0) numtran=numtran+1
                call getreal(rtpmf(k),0,0.0)
                if (rtpmf(k) .gt. 0.0) numrot=numrot+1
                rtpmf(k)=rtpmf(k)/rdtodg
              end do
              notranpmf=0
              if (numtran .eq. 0) notranpmf=1
              norotpmf=0
              if (numrot .eq. 0) norotpmf=1
              if (norotpmf .eq. 1 .and. notranpmf .eq. 1) then
                write (iout,2137)
                iop(18)=0
                nchng=nchng+1
              end if
              if (numtran .eq. 3) then
                write (iout,2145)
                iop(18)=0
                nchng=nchng+1
              end if
            end if
            if (iop(51) .ge. 1) then
              call readpmf(inpt,iout,iopnrm,iopeql,iopenc,nitssk,faclim,
     -          fcenc1,smplmx,ratmax,rldvmx,diffmx,ngovmn,nsubmn,ngrcor,
     -          negitdel,nwtst,fcenc2,encexp,tolera,cplmin,cplmax,
     -          delcpl,c0cplh,p0cplh,wcplcha,iop(24),iop(51),iop(55),
     -          MYRANK)
              if (numrun .ne. numrunst) then
                write (iout,2052)
                inperr=inperr+1
              end if
            end if
C@DM          else if (key .eq. 'XXXX') then
C@DM            if (MYRANK .eq. 0) write (iout,2252)
C@DM            inperr=inperr+1
          end if
        else if (key0 .eq. 'CLON' .or. key0 .eq. 'MAKB' .or.
     -      key0 .eq. 'BRKB' .or. key0 .eq. 'MOLD' .or.
     -      key0 .eq. 'RDBD') then
c         Lump together a few keywords to reduce the number of if/then/else's
          if (key0 .eq. 'CLON') then
c-----------Solute cloning information
            call getint(nclone,1,1,0)
            if (nclone .gt. 10) then
              nclone=10
              if (MYRANK .eq. 0) write (iout,2093)
              inperr=inperr+1
            end if
            do ic=1,nclone
              call getint(iaclnf(ic),1,1,0)
              call getint(iaclnl(ic),1,1,0)
              call getint(ncopcln(ic),1,1,0)
              if (ncopcln(ic) .le.1 .or. iaclnf(ic) .gt. iaclnl(ic))then
                if (MYRANK .eq. 0)
     -            write (iout,2092) iaclnf(ic),iaclnl(ic),ncopcln(ic)
                inperr=inperr+1
              end if
              if (ic .gt. 1) then
                if (iaclnf(ic) .le. iaclnl(ic-1)) then
                  if (MYRANK .eq. 0)
     -              write (iout,2090) iaclnf(ic),iaclnl(ic)
                  inperr=inperr+1
                end if
              end if
            end do
          else if (key0 .eq. 'RDBD') then
c-----------Read bond list instead of generating it
            ifiletyp=45+iop(128)
            call getname(filename1,lfilename1,0,80)
            if (MYRANK .eq. 0) then
              if (lfilename1 .lt. 1) then
                call fileopen(file,namlenf,filenames(ifiletyp),
     -            namlens(ifiletyp),ifiletyp,0,1,1,2,0,iop(24),iversout,
     -            iout,ibndok,0)
                if (ibndok .gt. 0) write (iout,2366)
              else
                call fileopen(filename1,lfilename1,filenames(ifiletyp),
     -            namlens(ifiletyp),ifiletyp,0,1,1,2,0,iop(24),iversout,
     -            iout,ibndok,0)
              end if
            end if
          else if (key0 .eq. 'MAKB') then
c-----------Make additional bonds
            call readpairlist(nmake,imake,250,0,'imake     ',
     -        'bond making list',' ',iout,inperr,nwarn,0,nchng,0,0,1,0)
          else if (key0 .eq. 'BRKB') then
c-----------Break bonds
            call readpairlist(nbreak,ibreak,250,0,'ibreak    ',
     -        'bond breaking list',' ',iout,inperr,nwarn,0,nchng,
     -        0,0,1,0)
          else if (key0 .eq. 'MOLD') then
c-----------Define solute molecules
            call getint(nsttm,1,1,1)
            call checkdim(ifail,iout,inperr,'MM',nsttm,0,0,0)
            ifirstm(1)=1
            do im=1,nsttm
              call getint(ilastm(im),1,1,1)
              if (im .gt. 1) then
                if (ilastm(im) .le. ilastm(im-1)) then
                  if (MYRANK .eq. 0)
     -              write (iout,2274) im,ilastm(im),ilastm(im-1)
                  inperr=inperr+1
                end if
                ifirstm(im)=ilastm(im-1)+1
              end if
            end do
          end if
        else if (key0 .eq. 'SLTA') then
c---------Input solute description
          isltread=1
          call decode(slta1,nslta1,ndummyu,keyno,key1,1)
          islt4=0
          if (key1 .eq. 'MMC4') islt4=1
          call decode(slta2,nslta2,ndummyu,keyno,key2,1)
          call getint(nstta,1,1,0)
          call checkdim(ifail,iout,inperr,'ST',nstta,1,0,0)
          call getint(nstfa,0,1,0)
          if (nstta .eq. 0 .and. nsltfreq .gt. 0) then
            nsltfreq=0
            nchng=nchng+1
            if (MYRANK .eq. 0) write (iout,2253)
          end if
          nstta_inp=nstta
          if (iop(30) .gt. 0) then
            if (nstfa .eq. 0) nstfa=nstta
            if (iop(30) .eq. 5 .or. iop(30) .eq. 6)
     -        call checkdim(ifail,iout,inperr,'FE',nstfa,1,0,0)
          end if
          call getint(nstfa0,0,1,nstfa/nsltcp(iop(30)+1))
          call getint(nsltpr,0,1,nstta)
          if (nsltpr .gt. nstta) then
            nsltpr=nstta
            if (MYRANK .eq. 0) write (iout,2022)
            nchng=nchng+1
          end if
          if (inperr .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2199)
            call datprt(-1)
          end if
          ipretrans=0
          if (iop(61) .gt. 0) then
            if (nmolec .gt. 1) then
              write (iout,2359)
              inperr=inperr+1
            end if
            if (iop(69) .gt. 0) then
              write (iout,2313)
              inperr=inperr+1
            end if
            if (key1(1:3) .ne. 'MMC') then
              write (iout,2314)
              inperr=inperr+1
            end if
            if (key2 .ne. 'FILE') then
              write (iout,2315)
              inperr=inperr+1
            end if
            do k=1,3
              xyzflmin(k)=realmx
              xyzflmax(k)=-xyzflmin(k)
            end do
          end if
          if (key2 .eq. 'FILE') then
c               For now, MPI has trouble reading from a file in this context
C@DM            write (iout,2255)
C@DM            if (idebug(123) .eq. 0) call datprt(2)
            linenoo=lineno
            if (key1(1:3) .eq. 'MMC') then
              itypopen=20
              itypealt=0
            else if (key1 .eq. 'PDB ') then
              itypopen=15
              itypealt=20
            else if (key1 .eq. 'CRD ') then
              itypopen=18
              itypealt=20
            end if
            call getint(numrunrslt,0,1,numrun)
            call getname(filenameslt,namlenslt,0,80)
            if (namlenslt .eq. 0) then
              filenameslt=file
              namlenslt=namlenf
            end if
c           Start new count for solute file
            lineno0=lineno
            lineno=0
            if (MYRANK .eq. 0)
     -        call fileopen(filenameslt,namlenslt,filenames(20),
     -         namlens(20),itypopen,itypealt,numrunrslt,1,2,0,iop(24),
     -         iversout,iout,isltinp,0)
            call checkpretrans(isltinp,iout,inperr,nwarn)
          else if (key2 .eq. 'READ') then
            isltinp=inpt
            namlens(20)=0
          end if
          nsttainp=nstta
          nsttar=nstta
          if (ifail .gt. 0) nsttar=#ST
          call zeroiti(mask,0,nsttar)
          call zeroiti(ivtm,0,nsttar)
c         Solute atom types, coordinates, charges, group indices
          sltinptyp=key1
          if (key1(1:3) .ne. 'MMC') then
c           Non-MMC formats (PDB and CRD), set type to atomic numbers only
            if (iop(3) .lt. 10) then
              iop(3)=10
              nchng=nchng+1
              if (MYRANK .eq. 0) write (iout,2213) pftyp
            end if
            qsltmax=0
            do ia=1,nsttar
              if (key1 .eq. 'CRD ') then
c               Charmm CRD format
                irectx=50
                call getnextrec(isltinp,iout,irectx,nwwarn)
                if (ia .eq. 1) then
c                 Skip header (if any)
                  if (line(1:1) .eq. '*') then
                    do while (line(1:1) .eq. '*')
                      call getnextrec(isltinp,iout,irectx,nwwarn)
                    end do
                    call getnextrec(isltinp,iout,irectx,nwwarn)
                  end if
                end if
                read (line,1022,err=980) igrslt(ia),mcnt,resnam,atnam,
     -            (cslt(k,ia),k=1,3),qslt(ia)
                if (mcnt .eq. 'm' .or. mcnt .eq. 'M') then
                  mask(ia)=1
                else if (mcnt .ne. ' ') then
                  write (iout,2325) 'molecule',mcnt,line
                  inperr=inperr+1
                end if
                iclslt(ia)=ianum(atnam,0,iout,inperr)
                if (iop(90) .gt. 0) fcglab(ia)(5:8)=line(52:55)
                if (MYRANK .eq. 0 .and. iop(24) .gt. 1)
     -            write (iout,1315) irectx,resnam,atnam,igrslt(ia),
     -            iclslt(ia),(cslt(k,ia),k=1,3),qslt(ia)
                iaread=ia
              else if (key1 .eq. 'PDB ') then
c               PDB format
                irectx=51
c               Skip until atom record is found
                line(1:5)='     '
                do while (line(1:4) .ne. 'ATOM' .and.
     -             line(1:6) .ne. 'HETATM' .and. irectx .gt. 0)
                  call getnextrec(isltinp,iout,irectx,nwwarn)
                end do
                if (irectx .lt. 0) then
                  if (iaread .eq. 0) then
                    if (MYRANK .eq. 0) write (iout,2263)
                    call datprt(2)
                  else
                    if (MYRANK .eq. 0) write (iout,2185) iaread,' '
                    go to 982
                  end if
                end if
                read (line,1023,err=980) mcnt,atnam,resnam,
     -            igrslt(ia),(cslt(k,ia),k=1,3),x,qslt(ia)
                if (line(22:22) .ne. ' ') sltchainid=line(22:22)
                if (mcnt .eq. 'm' .or. mcnt .eq. 'M') then
                  mask(ia)=1
                else if (mcnt .ne. ' ') then
                  write (iout,2325) 'molecule',mcnt,line
                  inperr=inperr+1
                end if
                iclslt(ia)=ianum(atnam,0,iout,inperr)
                if (iop(24) .gt. 1 .and. MYRANK .eq. 0)
     -            write (iout,1315) irectx,resnam,atnam,igrslt(ia),
     -              iclslt(ia),(cslt(k,ia),k=1,3),x,qslt(ia)
                if (resnam(1:3) .eq. 'HOH') then
                  if (MYRANK .eq. 0)
     -              write (iout,2185) iaread,' non-water '
                  go to 982
                end if
                iaread=ia
              end if
              indxrdf(ia)=0
              iopslt(ia)=0
              labslt(1,ia)=resnam
              labslt(2,ia)=atnam
              fcglab(ia)='        '
              pflabslt(ia)='      '
              if (abs(qslt(ia)) .gt. qsltmax) qsltmax=abs(qslt(ia))
            end do
982         nchng=nchng+1
            nstta=iaread
            nsttar=iaread
            nstta_full=nstta
c           If it looks like data is not charge then clear qslt
            if (qsltmax .gt. 3.0) call zeroit(qslt,nstta)
          else
c           MMC format
            nmmcerr=0
            if (iop(61) .gt. 0 .and. key2 .eq. 'FILE') then
c             Find out the number of atoms in flexible residues
              call zeroiti(l1,0,nsttar)
              do i=1,naflxrange
                do j=iaflxrange(1,i),iaflxrange(2,i)
                  l1(j)=1
                end do
              end do
              nslt_flex=0
              nslt_fix=0
              irectx=55
              do ia=1,nsttar
                call getnextrec(isltinp,iout,irectx,nwwarn)
                if (islt4 .eq. 0) read (line,1121,err=981) any6,
     -            (cslt(k,ia),k=1,3),qslt(ia),igrslt(ia)
                if (islt4 .eq. 1) read (line,1021,err=980) any4,
     -            (cslt(k,ia),k=1,3),qslt(ia),igrslt(ia)
                if (l1(igrslt(ia)) .eq. 1) then
                  nslt_flex=nslt_flex+1
                  l2(nslt_flex)=ia
                  do k=1,3
                    if (cslt(k,ia) .lt. xyzflmin(k)) then
                      xyzflmin(k)=cslt(k,ia)
                    else if (cslt(k,ia) .gt. xyzflmax(k)) then
                      xyzflmax(k)=cslt(k,ia)
                    end if
                  end do
                else
                  nslt_fix=nslt_fix+1
                  l3(nslt_fix)=ia
                end if
              end do
c             Convert flexible residue range to atom range
              ia=1
              do is=1,naflxrange
                call trnsfi(ir12,iaflxrange(1,is),2)
                do while (igrslt(ia) .lt. iaflxrange(1,is) .and.
     -                    ia .lt. nsttar)
                  ia=ia+1
                end do
                iaflxrange(1,is)=ia
                do while (igrslt(ia) .lt. iaflxrange(2,is)+1 .and.
     -                    ia .lt. nsttar)
                  ia=ia+1
                end do
                if (igrslt(ia-1) .eq. iaflxrange(2,is)) then
                  ia=ia-1
                  iaflxrange(2,is)=ia
                  write (iout,2367) is,ir12,(iaflxrange(k,is),k=1,2)
                else if (igrslt(ia) .eq. iaflxrange(2,is)) then
                  iaflxrange(2,is)=ia
                  write (iout,2367) is,ir12,(iaflxrange(k,is),k=1,2)
                else
                  write (iout,2349) is,ir12,(iaflxrange(k,is),k=1,2),
     -              ia,nsttar,igrslt(ia)
                  inperr=inperr+1
                end if
              end do
              rewind isltinp
              do ia=1,nslt_flex
                iorig_of_split(ia)=l2(ia)
              end do
              do ia=1,nslt_fix
                iorig_of_split(nslt_flex+ia)=l3(ia)
              end do
              do ia=1,nsttar
                isplit_of_orig(iorig_of_split(ia))=ia
              end do
              nstta_full=nstta
              nstta=nslt_flex
c              if (idebug(169) .gt. 0) write (77,9217)
c     -          (i,iorig_of_split(i),isplit_of_orig(i),i=1,nstta_inp)
c9217          format(i6,' iofs=',i6,' iofo=',i6)
            else
              nstta=nsttar
              nstta_full=nsttar
            end if
            irectx=14
            call find('SUPT',1,nmainkey,mainkey,npfkey,4)
            any6='      '
            nmmcerr=0
            do iaa=1,nsttar
              if (iop(61) .eq. 0) then
                ia=iaa
              else
                ia=isplit_of_orig(iaa)
              end if
              call getnextrec(isltinp,iout,irectx,nwwarn)
              if (islt4 .eq. 0) then
                read (line,1121,err=981) any6,(cslt(k,ia),k=1,3),
     -            qslt(ia),igrslt(ia),gcnt,mcnt,(labslt(k,ia),k=1,2),
     -            indxrdf(ia),key,fcglab(ia)
                call namornum(any6,iclslt(ia),pflabslt(ia),6)
              else
                read (line,1021,err=980) any4,(cslt(k,ia),k=1,3),
     -            qslt(ia),igrslt(ia),gcnt,mcnt,(labslt(k,ia),k=1,2),
     -            indxrdf(ia),key,fcglab(ia)
                call namornum(any4,iclslt(ia),pfl4,4)
                pflabslt(ia)(1:4)=pfl4
                pflabslt(ia)(5:6)='  '
                any6(1:4)=any4
              end if
              if (iop(24) .gt. 1 .and. MYRANK .eq. 0)
     -          write (iout,1314) ia,any6,(cslt(k,ia),k=1,3),qslt(ia),
     -            igrslt(ia),gcnt,mcnt,(labslt(k,ia),k=1,2),
     -            indxrdf(ia),key,fcglab(ia)
              if (iop(61) .gt. 0) ir_split_orig(iaa)=igrslt(ia)
              if (key .ne. '    ') then
                call find(key,1,nkey1(npfkey),keys01(ifkey1(npfkey)),
     -            keyno,4)
                if (keyno .eq. 0 .and. islt4 .eq. 1) then
c                 Assumed to be additional pf characters
                  call leftadjust(key,key,4)
                  pflabslt(ia)(5:6)=key(1:2)
                  npfl6=npfl6+1
                else
                  iopslt(ia)=keyno
                end if
              else
                iopslt(ia)=0
              end if
              if (mcnt .eq. 'm' .or. mcnt .eq. 'M') then
                mask(ia)=1
              else if (mcnt .ne. ' ') then
                write (iout,2325) 'molecule',mcnt,line
                inperr=inperr+1
                nmmcerr=nmmcerr+1
              end if
              if (gcnt .eq. 'g' .or. gcnt .eq. 'G') then
                ivtm(ia)=1
              else if (gcnt .ne. ' ') then
                write (iout,2325) 'group',gcnt,line
                inperr=inperr+1
                nmmcerr=nmmcerr+1
              end if
              if (nmmcerr .gt. 0 .and. nmmcerr .le. 2 .and.
     -          key .eq. 'MMC ') write (iout,2340)
            end do
            if (nmmcerr .gt. 0 .and. key .eq. 'MMC ') write (iout,2340)
          end if
          if (nstfa0 .gt. nstfa .or. nstfa .gt. nstta) then
            if (MYRANK .eq. 0) write (iout,2094) nstfa0,nstfa,nstta
            inperr=inperr+1
          end if
          if (nstfa+nstfa0 .gt. 0 .and. iop(30) .eq. 0) then
            if (MYRANK .eq. 0) write (iout,2003)
            inperr=inperr+1
          end if
          if (key2 .eq. 'FILE') then
            lineno=linenoo
            if (MYRANK .eq. 0) then
              do while (.true.)
                read (isltinp,1000,end=201) line
                if (line(1:1) .ne. '!' .and. line(1:3) .ne. 'END') then
                  write (iout,2150) filenames(20)(1:namlens(20)),
     -              nstta,line
                  go to 201
                end if
              end do
            end if
          end if
201       natnew=nstta
          nsttanoclone=nstta
          if (iop(69) .gt. 0 .and. inperr .eq. 0) then
c           Copy the input solute atom description according to the cloning
c           abs(icorig(ia)) will tell after the cloning the original atomnumber
c           of atom ia. If icorig(ia) < 0 then atom ia is a cloned atom.
c           icnew(ia) gives the new position of an uncloned atom whose original
c           index was ia. For atoms undergoing the ic-th cloning, icnew(ia)= -ic
c           where ic is the cloning number
            do ic=1,nclone
              if (iaclnf(ic) .le. nstfa) then
                if (MYRANK .eq. 0) write (iout,2091)
                inperr=inperr+1
              end if
              nsplit=0
              if (iaclnf(ic) .gt. 1) then
                if (igrslt(iaclnf(ic)-1) .eq. igrslt(iaclnf(ic)))
     -            nsplit=nsplit+1
              end if
              if (iaclnl(ic) .lt. nstta) then
                if (igrslt(iaclnl(ic)) .eq. igrslt(iaclnl(ic)+1))
     -            nsplit=nsplit+1
              end if
              if (nsplit .gt .0) then
                if (MYRANK .eq. 0) write (iout,2332)
     -            ic,iaclnf(ic),iaclnl(ic)
                inperr=inperr+1
              end if
              igrinc(ic)=igrslt(iaclnl(ic))-igrslt(iaclnf(ic))+1
              natnew=natnew+(ncopcln(ic)-1)*(iaclnl(ic)-iaclnf(ic)+1)
            end do
            call checkdim(ifail,iout,inperr,'ST',natnew,0,0,0)
            if (ifail .gt. 0) nclone=0
            call zeroiti(icnew,0,nstta)
            call indexit(icorig,1,nstta,0)
            do ic=nclone,1,-1
              incr0=iaclnl(ic)-iaclnf(ic)+1
              incr=(ncopcln(ic)-1)*incr0
c             Make room first
              do ia=nstta,iaclnl(ic)+1,-1
                icorig(ia+incr)=icorig(ia)
                call trnsfr(cslt(1,ia+incr),cslt(1,ia),3)
                qslt(ia+incr)=qslt(ia)
                indxrdf(ia+incr)=indxrdf(ia)
                iopslt(ia+incr)=iopslt(ia)
                iclslt(ia+incr)=iclslt(ia)
                pflabslt(ia+incr)=pflabslt(ia)
                l1(ia+incr)=l1(ia)
                mask(ia+incr)=mask(ia)
                ivtm(ia+incr)=ivtm(ia)
                labslt(1,ia+incr)=labslt(1,ia)
                labslt(2,ia+incr)=labslt(2,ia)
                fcglab(ia+incr)=fcglab(ia)
                igrslt(ia+incr)=igrslt(ia)+igrinc(ic)*(ncopcln(ic)-1)
              end do
              nstta=nstta+incr
              nstta_full=nstta
c             Now clone
              do ia=iaclnf(ic),iaclnl(ic)
                do id=1,ncopcln(ic)-1
                  icorig(ia+id*incr0)=-icorig(ia)
                  call trnsfr(cslt(1,ia+id*incr0),cslt(1,ia),3)
                  qslt(ia+id*incr0)=qslt(ia)
                  indxrdf(ia+id*incr0)=indxrdf(ia)
                  iopslt(ia+id*incr0)=iopslt(ia)
                  iclslt(ia+id*incr0)=iclslt(ia)
                  pflabslt(ia+id*incr0)=pflabslt(ia)
                  l1(ia+id*incr0)=l1(ia)
                  mask(ia+id*incr0)=mask(ia)
                  labslt(1,ia+id*incr0)=labslt(1,ia)
                  labslt(2,ia+id*incr0)=labslt(2,ia)
                  fcglab(ia+id*incr0)=fcglab(ia)
                  igrslt(ia+id*incr0)=igrslt(ia)+id*igrinc(ic)
                end do
              end do
              do ia=1,nstta
                if (icorig(ia) .gt. 0) icnew(icorig(ia))=ia
              end do
            end do
            do ic=1,nclone
              do ia=iaclnf(ic),iaclnl(ic)
                icnew(ia)=-ic
              end do
            end do
            if (nsltpr .eq. nsttainp) nsltpr=nstta
            if (idebug(17) .gt. 0 .and. MYRANK .eq. 0) then
              do ia=1,nstta
                write (iout,7866) ia,iclslt(ia),pflabslt(ia),igrslt(ia),
     -            icnew(ia),icorig(ia),labslt(1,ia),labslt(2,ia)
              end do
            end if
            nsttar=nstta
          else
            if (nsttar .ne. nstta_inp) then
              if (MYRANK .eq. 0) write (iout,2316) nsttar,nstta_inp
              inperr=inperr+1
            end if
            call zeroiti(icorig,0,nstta_full)
          end if
          if (iop(85) .gt. 0) then
            if (nstta .lt. ilastm(nsttm)) then
              if (MYRANK .eq. 0) write (iout,2287) ilastm(nsttm),nstta
              inperr=inperr+1
            else if (nstta .gt. ilastm(nsttm)) then
              if (MYRANK .eq. 0) write (iout,2288) ilastm(nsttm),nstta
              nwarn=nwarn+1
            end if
          end if
          if (numrun .eq. numrunst) then
c           Set mixing rule and 1-4 factors if defaults are needed
            call find('MIXR',1,nmainkey,mainkey,keyno,4)
            if (mainkeyun(keyno) .eq. 0) iop(52)=mixrule(iop(3))
            if (ifc14read .eq. 0) then
              vdwf14=vdw14fac(iop(3))
              esf14=es14fac(iop(3))
            end if
          end if
          call initpf(noutwarn,nsplitwarn,noutwmin,noutwmax,
     -      nsplitwmin,nsplitwmax,nsttanoclone,qslvdip,
     -        naflxrange,iaflxrange,50)
          if (iop(61) .gt. 0) then
c           Assign atom type numbers to the fixed part too
            do ia=nstta+1,nsttar
              iopuse=iop(3)
              if (iopslt(ia) .gt. 0) iopuse=iopslt(ia)
              if (iopslt(ia) .eq. 0) iopslt(ia)=iopuse
              call find(pflabslt(ia),1,maxtyp(iopuse),
     -          pflab(1,iopuse),iclslt(ia),6)
              if (iclslt(ia) .gt. 0)ianslt(ia)=iatnos(iclslt(ia),iopuse)
            end do
c           Find fixed neighbors of flexible atoms
            call nneiglist(cslt,1,nsttar,ianslt,iout,inperr,nwarn,
     -        nwwarn,nneig,nneiga,nneigh,ineig,#NL)
            if (idebug(174) .gt. 0) then
              do ia=1,nsttar
                write (iout,2352) iorig_of_split(ia),
     -            (labslt(k,ia),k=1,2),(iorig_of_split(ineig(in,ia)),
     -            (labslt(k,ineig(in,ia)),k=1,2),in=1,nneig(ia))
              end do
            end if
            do is=1,naflxrange
              nbtot=0
              nfxn=0
              do iao=iaflxrange(1,is),iaflxrange(2,is)
                ia=isplit_of_orig(iao)
                ing=0
                do in=1,nneig(ia)
                  if (ineig(in,ia) .gt. nstta .and.
     -                ianslt(ineig(in,ia)) .ne. 1) then
                    ing=ia
                    write (iout,2353) ia,(labslt(k,ia),k=1,2),
     -                ineig(in,ia),(labslt(k,in),k=1,2)
                    nbtot=nbtot+1
                  end if
                end do
                if (ing .gt. 0) then
                  nfxn=nfxn+1
                  l1(nfxn)=ing
                end if
              end do
              iaflxneig(1,is)=0
              if (nfxn .gt. 0) iaflxneig(1,is)=l1(1)
              iaflxneig(2,is)=0
              if (nfxn .gt. 1) iaflxneig(2,is)=l1(nfxn)
              write (iout,2350)(iaflxrange(k,is),k=1,2),(l1(k),k=1,nfxn)
              if (nbtot .gt. 2) then
                write (iout,2354) nbtot
                nwwarn=nwwarn+1
              end if
            end do
            call initpf(noutwarn,nsplitwarn,noutwmin,noutwmax,
     -        nsplitwmin,nsplitwmax,nsttanoclone,qslvdip,
     -        naflxrange,iaflxrange,50)
c           iaflxrange(1,1)=1
c           iaflxrange(2,1)=205
c           iaflxneig(1,1)=1
c           iaflxneig(2,1)=204
          end if
C@DM          call setlim(npfgr(3)+1,npfgr(4),NUMNOD,iflsltg,icpuslt,
C@DM     -      MYRANK,iout,MAXNOD,iop(24),'solute group')
C@DM          call indexit(l1,npfgr(3)+1,npfgr(4),0)
C@DMc         Scramble solute group indices
C@DM          nleft=npfgr(4)
C@DM          call randpx(nleft,cv1)
C@DM          do ig=npfgr(3)+1,npfgr(4)
C@DM            ix=cv1(ig)*nleft+1
C@DM            mixupslt(ig)=l1(ix)
C@DM            l1(ix)=l1(nleft)
C@DM            nleft=nleft-1
C@DM          end do
          if (inperr .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2199)
            if (MYRANK .eq. 0) write (iout,2310)
            if (ntopwwarn .gt. 0) then
              if (MYRANK .eq. 0) write (iout,2317)
              call printbondlist('BOND',1,nstta,nstta,cslt,nneig,ineig,
     -          labslt,cv1,#NL,rdtodg,nwarn,idebug(24)-1,iout)
              call fcganal(nstfa+1,nstta,1)
            end if
            call printopt(iopkeylist,iout)
            call echopr(1)
            call datprt(-1)
          end if
          call initpfslt(1,nstta_full,iopslt,iclslt,iclsltt,indextyp)
          call initsolute
          if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
            if (nsttm-nstfm .gt. 1) then
c             Check for slt-slt cutoff info
              call find('SUUC',1,nmainkey,mainkey,keyno,4)
              if (mainkeyun(keyno) .eq. 0) then
                inperr=inperr+1
                write (iout,2259)
              end if
            end if
          end if
          call zeroiti(nmolinout,0,2)
          natoms=nstta+numsolv*nslv
          uspro0=uspar0
          uspro1=uspar1
          if (iop(35) .gt. 0) then
c           Prepare the uspar0 and uspar1 combinations in cslt
            if (iop(3) .eq. 2) then
              if (MYRANK .eq. 0) write (iout,2035)
              inperr=inperr+1
            end if
            call lincm2(cslt,3,#ST,nstfa0,3,uspar0,uspar1)
c           Pf coefficients have already combined in initpf
            if (cplpar .lt. uspar0 .or. cplpar .gt. uspar1) then
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,2036) cplpar,uspar0,uspar1
            end if
c           Change cpl par limits to 0 and 1, change cplpar proportionally
            cplpar=(cplpar-uspar0)/(uspar1-uspar0)
          end if
c         Initial and final states are represented in any case by lambda=0 and 1
          uspar0=0.0
          uspar1=1.0
c         Get slt and slv atom coordinates in their local systems
c         crm: array of molecular center of masses.
c         rlcslt, rlcslv: solute and solvent local coordinates shifted to COM.
c         (for iop(43)>0 rlcslt will get new meaning)
          call trnsfi(l1,iclslt,nsttar)
          if (iop(30) .ge. 7) call zeroiti(l1,nstfa1,nstfa)
          call grelcd(cslt,rlcslt,l1,nsttar,0)
          if (idebug(9) .gt. 0 .and. MYRANK .eq. 0) write (iout,7511)
     -      nstta,nsttg,nstfa0,nstfg0,nstfa1,nstfg1,nstfa,nstfg,
     -        (ia,(cslt(k,ia),k=1,3),(rlcslt(k,ia),k=1,3),ia=1,nsttar)
          call grelcd(cslv,rlcslv,ianslv,nslv,1)
          nosltname=0
          do ia=1,nstta_full
            if (labslt(1,ia) .eq. '    ') then
              if (MYRANK .eq. 0) write (labslt(1,ia),1002) igrslt(ia)
              nosltname=nosltname+1
            end if
            if (labslt(2,ia) .eq. '    ') then
              labslt(2,ia)=iatnam(ianslt(ia))
              nosltname=nosltname+1
            end if
          end do
          if (nosltname .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2139)
            nchng=nchng+1
          end if
          if (isltinp .ne. inpt) then
            lineno=lineno0
            if (MYRANK .eq. 0) call fileclose(isltinp,0,iop(24),iout)
          end if
          if (nstta_full .gt. nstta) then
            do ia=nstta+1,nstta_full
              if (pflabslt(ia) .ne. '      ') then
                ianslt(ia)=ianum(pflabslt(ia)(1:4),0,iout,inperr)
              else
                ianslt(ia)=ianum(labslt(2,ia),0,iout,inperr)
              end if
            end do
            call nneiglist(cslt,nstta+1,nstta_full,ianslt,iout,inperr,
     -        nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          end if
        else if (key0 .eq. 'SLVA') then
c---------Input solvent description
          call getint(nslv,1,1,0)
          call getint(islvrep,0,1,1)
          call getname(namslv,ii,0,4)
          call getint(islv4,0,1,0)
          islvinpt=inpt
          call getname(stuff,lfile,0,80)
          if (lfile .gt. 1) then
c           File name was read - read form there in .slt format
            call fileopen(stuff,lfile,filenames(49),namlens(49),49,
     -        0,1,1,2,0,iop(24),iversout,iout,islvinp,0)
            islv4=0
          else
            islvinp=inpt
          end if
          if (ii .eq. 0) then
             namslv='SOLV'
          else if (ii .lt. 4) then
           do i=ii+1,4
              namslv(i:i)=' '
            end do
          end if
          if (nslv .gt. 0) then
            call checkdim(ifail,iout,inperr,'SV',nslv,0,0,0)
            if (iop(26) .eq. 4) then
              call checkdim(ifail,iout,inperr,'GV',nslv,0,0,0)
            else
              if (MYRANK .eq. 0) write (iout,2075)
              inperr=inperr+1
            end if
            if (islvrep .gt. nslv) then
              if (MYRANK .eq. 0) write (iout,2374) islvrep,nslv
              inperr=inperr+1
            end if
          else if (lfile .le. 1) then
            if (MYRANK .eq. 0) write (iout,2370)
            inperr=inperr+1
          end if
          irectx=15
          any6='      '
          llim=nslv
          if (nslv .eq. 0) then
            llim=min0(#SV,#GV)
            nslv=llim
          end if
          ia=0
          do while (ia .lt. llim .and. irectx .gt. 0)
            call getnextrec(islvinp,iout,irectx,nwwarn)
            if (irectx .lt. 0) then
              nslv=ia
            else
              ia=ia+1
              labslv(ia)='    '
              if (islv4 .eq. 0) then
                if (lfile .le. 1) then
                  read (line,1126,err=980) any6,(cslv(k,ia),k=1,3),
     -              qslv(ia),labslv(ia)
                else
                  read (line,1127,err=980) any6,(cslv(k,ia),k=1,3),
     -              qslv(ia),labslv(ia)
                  if (line(53:53) .eq. 'G') then
                    write (iout,2369) islvrep,ia
                    islvrep=ia
                  end if
                end if
                call namornum(any6,iclslv(ia),pflabslv(ia),6)
              else
                read (line,1026,err=980) any4,(cslv(k,ia),k=1,3),
     -            qslv(ia),labslv(ia)
                call namornum(any4,iclslv(ia),pfl4,4)
                if (iclslv(ia) .eq. -1) then
                  pflabslv(ia)(1:4)=pfl4
                  pflabslv(ia)(5:6)='  '
                  any6(1:4)=any4
                end if
              end if
              if (iclslv(ia) .eq. -1) then
                call find(pflabslv(ia),1,maxtyp(iop(37)),
     -            pflab(1,iop(37)),iclslv(ia),6)
                if (iclslv(ia) .gt. 0)
     -            ianslv(ia)=iatnos(iclslv(ia),iop(37))
              else if (iclslv(ia) .gt. maxtyp(iop(37))) then
                if (MYRANK .eq. 0)
     -            write (iout,2099) iclslv(ia),maxtyp(iop(37))
                inperr=inperr+1
                iclslv(ia)=maxtyp(iop(37))
              else
                pflabslv(ia)=pflab(iclslv(ia),iop(37))
              end if
              if (iclslv(ia) .eq. -1) then
                if (MYRANK .eq. 0) write (iout,2098) pflabslv(ia)
                inperr=inperr+1
              end if
              if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,1316)
     -          any6,(cslv(k,ia),k=1,3),qslv(ia),labslv(ia)
            end if
          end do
          if (lfile .gt. 1 .and. irectx .ge. 0) then
c           Test if there are more records
            call getnextrec(islvinp,iout,irectx,nwwarn)
            if (irectx .ge. 0) then
              if (MYRANK .eq. 0)
     -          write (iout,2381) llim
              inperr=inperr+1
            end if
          end if
          if (islvinp .ne. inpt) call fileclose(islvinp,0,iop(24),iout)
        else if (key0 .eq. 'SWAP' .or. key0 .eq. 'MV2S' .or.
     -           key0 .eq. 'PARD' .or. key0 .eq. 'SPSN' .or.
     -           key0 .eq. 'TORD' .or. key0 .eq. 'PARD' .or.
     -           key0 .eq. 'PART' .or. key0 .eq. 'LOOP') then
          if (key0 .eq. 'SWAP') then
c-----------Specifying details of solute molec swap
            call getreal(wswap,1,0.0)
          else if (key0 .eq. 'MV2S') then
c-----------Specifying details of solute molec pair for correlated rotations
            call getreal(wmv2s,1,0.0)
            call getreal(r2scut,1,0.0)
            call getreal(rtxcslt,1,0.0)
            call getint(iaxis2s,1,1,1)
            nn2min=#MM
            nn2max=0
          else if (key0 .eq. 'SPSM') then
c-----------Input for special sampling
c           imspf,imspl: first and last solute molec to apply special sampl.
c           Depending on the realization, update movmoll, movmolf, isltmv
            call getint(imspf,1,1,0)
            call getint(imspl,1,1,0)
            call getreal(wspec,1,0.0)
          else if (key0 .eq. 'PARD') then
c-----------Input for partial solute displacement:
            isltsmpl=1
            call find('MOVE',1,nmainkey,mainkey,keyno,4)
            call decode(keys01(ifkey1(keyno)),4,ndummyu,keyno,key,1)
            iop(73)=keyno-1
c           nsltpardis: number of slt atoms to move (starting from the first
c           non FE atom)
c           wsltpdis: relative frequency of partial displacements
c           cedpslt,rtxpslt: displacement and rotation intervals
            call getreal(wsltpdis,1,0.0)
            do k=1,3
              call getreal(cedpslt(k),1,0.0)
              call getreal(rtxpslt(k),1,0.0)
              if (iop(57) .eq. 1) rtxpslt(k)=rtxpslt(k)/rdtodg
              call getreal(waxis(k+1),1,1.0)
              if (rtxpslt(k) .gt. 0.0 .and. waxis(k+1) .eq. 0.0) then
                write (iout,2148) lxyz(k),rtxpslt(k)
                inperr=inperr+1
              end if
              if (rtxpslt(k) .eq. 0.0 .and. waxis(k+1) .gt. 0.0) then
                write (iout,2283) lxyz(k)
                nchng=nchng+1
              end if
            end do
            waxis(1)=0.0
            waxsum=waxis(2)+waxis(3)+waxis(4)
            if (waxsum .gt. 0.0) then
              waxis(2)=waxis(2)/waxsum
              waxis(3)=waxis(2)+waxis(3)/waxsum
              waxis(4)=(waxis(3)+waxis(4)/waxsum)+0.001
            end if
            call getint(nsltpardis,1,0,0)
c           Determine atom and molecule limits for the moving solute molecules
            nsttao=nstta
            if (iop(69) .gt. 0 .and. inperr .eq. 0)
     -        nsttao=iabs(icorig(nstta))
            if (nsltpardis .lt. 0) then
c             Moving molecules are at the end
              nsltpardis=-nsltpardis
              movatf=nsttao-nsltpardis+1
              movatl=nsttao
            else if (nsltpardis .gt. 0) then
c             Moving molecules are right after the FE molecules (if any)
              movatf=nstfa+1
              movatl=nstfa+nsltpardis
            else
              write (iout,2279)
                inperr=inperr+1
            end if
            if (iop(69) .gt. 0) then
c             Adjust for cloned molecules
              ia=1
              do while (icorig(ia) .ne. movatf .and. ia .lt. nstta)
                ia=ia+1
              end do
              movatf=ia
              ia=nstta
              do while (icorig(ia)**2 .ne. movatl**2 .and. ia .gt. 1)
                ia=ia-1
              end do
              movatl=ia
            end if
            movmolf=iamolslt(movatf)
            movmoll=iamolslt(movatl)
            do im=movmolf,movmoll
              call trnsfr(cedpsltim(1,im),cedpslt,3)
              call trnsfr(rtxpsltim(1,im),rtxpslt,3)
            end do
c           Mark atoms of moving molecs as affected by intra changes
            do ia=movatf,movatl
              if (isltmv(ia) .lt. 1) isltmv(ia)=1
            end do
            if (noutwarn .gt. 0) then
              if (movatf .le. noutwmax .and. movatl .eq. nstta .or.
     -            movatl .gt. noutwmin .and. movatf .eq. nstfa+1) then
                if (MYRANK .eq. 0) write (iout,2001) noutwmin,noutwmax
                inperr=inperr+1
              end if
            end if
            if (nsplitwarn .gt. 0 .and. iop(57) .gt. 0) then
              if (movatf .le. nsplitwmax .and. movatl .eq. nstta .or.
     -            movatl .gt. nsplitwmin .and. movatf .eq. nstfa+1) then
                if (MYRANK .eq. 0)
     -            write (iout,2105) nsplitwmin,nsplitwmax
                inperr=inperr+1
              else if (iop(65) .gt. 2) then
                if (MYRANK .eq. 0) write (iout,2143)
                inperr=inperr+1
              end if
            end if
            if (nstfa .eq. nstta) then
              if (MYRANK .eq. 0) write (iout,2026)
              inperr=inperr+1
            end if
            if (nsltpardis .gt. nstta-nstfa) then
              if (MYRANK .eq. 0)
     -          write (iout,2034) nsltpardis,nstta-nstfa
              inperr=inperr+1
              nsltpardis=nstta-nstfa
              if (iop(69) .gt. 0) write (iout,2295)
            else if (nstfm .ge. movmolf) then
              if (MYRANK .eq. 0) write (iout,2097)
              inperr=inperr+1
              iop(57)=0
            end if
            if (movatf .gt. 1) then
              if (iamolslt(movatf-1) .eq. iamolslt(movatf)) then
                if (MYRANK .eq. 0) write (iout,2088)
                inperr=inperr+1
              end if
            end if
            if (movatl .lt. nsttanoclone) then
              if (iamolslt(movatl) .eq. iamolslt(movatl+1)) then
                if (MYRANK .eq. 0) write (iout,2088)
                if (iop(69) .gt. 0) write (iout,2194)
                inperr=inperr+1
              end if
            end if
          else if (key0 .eq. 'PART') then
c-----------Partial torsion setup
            isltsmpl=1
            call find('MOVE',1,nmainkey,mainkey,keyno,4)
            call decode(keys01(ifkey1(keyno)),4,ndummyu,keyno1,key,1)
            iop(74)=keyno1-1
            call decode(keys01(ifkey1(keyno)),4,ndummyu,keyno1,key,1)
            iop(75)=keyno1-1
            call getreal(wsltptor,1,0.0)
c           Frequency of solute moves, relative frequency of partial torsions
          else if (key0 .eq. 'LOOP') then
c-----------Loop move specifications
            call decode(loop,nloop,ndummyu,iop(103),key1,1)
            call getreal(wloop,0,1.0)
            call getreal(divr3,0,0.1)
            d3toldef=0.000001
c           if (icompopt(14) .eq. 1) d3toldef=d3toldef/100.0
            call getreal(d3tol,0,d3toldef)
            call getreal(dijtol,0,0.01)
            d24toldef=0.1
c           if (icompopt(14) .eq. 1) d24toldef=d24toldef/10.0
            call getreal(d24tol,0,d24toldef)
            call getreal(drevtol,0,0.02)
            call getreal(dextol,0,0.2)
            call getreal(dihpmtol,0,5.0)
            if (d3tol .gt. 0.1) then
              nwwarn=nwwarn+1
              write (iout,2013) d3tol
            end if
          else if (key0 .eq. 'TORD') then
c-----------Torsion angle definitions - new torsion angle routines
            if (iop(61) .gt. 0) then
              do is=1,naflxrange
                do k=1,2
                  iaflxrange(k,is)=isplit_of_orig(iaflxrange(k,is))
c                 if (iaflxneig(k,is) .gt. 0)
c    -              iaflxneig(k,is)=isplit_of_orig(iaflxneig(k,is))
                end do
                write (iout,2351) is,(iaflxneig(k,is),k=1,2)
              end do
            end if
            call centdef_fix(0,nsttm,ifirstm,ilastm,ifgrmolslt,
     -        ilgrmolslt,nneig,ineig,labslt,mask,molcnt,
     -        naflxrange,iaflxrange,iaflxneig,iout,nwarn,iop(84),
     -        #NL,#MM,#ST)
            if (iop(10) .gt. 0) then
              write (iout,2110)
              inperr=inperr+1
            end if
            if (key .eq. 'INPT' .or. key .eq. 'RDBB') then
              call getint(ntorsinp,1,1,0)
              if (ntorsinp .eq. 0) then
                write (iout,2205)
                inperr=inperr+1
              end if
              call getint(nsltcop,0,1,1)
              do ic=1,nsltcop
                call getreal(rngfac(ic),0,1.0)
                call getreal(rngfacl(ic),0,1.0)
              end do
              if (nsltcop .gt. 1) then
                if (iop(30) .le. 3) then
                  inperr=inperr+1
                  write (iout,2113)
                end if
                if (iop(18) .eq. 4) then
                  nsltcop=1
                  nchng=nchng+1
                  write (iout,2108)
                end if
              end if
              call getint(incrat,0,0,0)
              defrot=0.0
              deflooprot=0.0
              maxtorchain=nstta
              if (ntorsinp .gt. 0) call torsionsetup(0,incrat,0,ntbond,
     -          nflexring,ntordrop,nptd,naflxrange,iaflxrange,iaflxneig)
            else if (key .eq. 'ALL ' .or. key .eq. 'ALBB') then
              call decode(tord1,ntord1,ndummyu,keyno,key1,1)
              if (iop(58) .eq. 1) call getreal(defrot,0,10.0)
              if (iop(58) .gt. 1) call getreal(defrot,0,0.5)
              call getreal(deflooprot,0,10.0)
              call getint(maxtorchain,0,1,nstta)
              call getint(nfixbondtyp,0,1,0)
              do ibt=1,nfixbondtyp
                do k=1,2
                  ntbond(k,ibt)='    '
                  call getname(pfl,nl,1,4)
                  ntbond(k,ibt)=pfl(1:nl)
                end do
              end do
              ntorsinp=0
              nsltcop=1
              call torsionsetup(keyno-1,0,nfixbondtyp,ntbond,nflexring,
     -          ntordrop,nptd,naflxrange,iaflxrange,iaflxneig)
            end if
          end if
        else if (key0 .eq. 'PRMF') then
c---------Parameter file name input
          call find('SUPT',1,nmainkey,mainkey,npfkey,4)
          call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -      keyno,key,1)
c         Pf name is the keyno-th
          if (keyno .gt. 0)
     -      call getname(prmfil(keyno),lprmfil(keyno),1,80)
        else if (key0 .eq. 'SKWT') then
c---------Skewed torsion sampling (biased)
          if (iop(116) .eq. 1 .or. iop(116) .eq. 3 .or.
     -        iop(116) .eq. 5 .or. iop(116) .eq. 6) iskewdr=1
          if (iop(116) .eq. 2 .or. iop(116) .eq. 3 .or.
     -        iop(116) .eq. 6) iskewlp=1
          if (iop(116) .gt. 3) iskewpr=1
            call getreal(wskew,1,1.0)
            wskewinv=1.0/wskew
            call getreal(wskewstepmin,0,1.0)
            wskewstepmin=wskewstepmin/rdtodg
            call getreal(resumefac,0,1.2)
        else if (key0 .eq. 'SETC') then
c---------Read in various constants
          if (key .eq. 'FCIN') then
c           Read in intramolecular energy scaling factor
            call getreal(fcintra,1,0.0)
          else if (key .eq. 'FC14') then
c           Read in 1-4 interaction coefficients
            call getreal(esf14,1,0.0)
            call getreal(vdwf14,1,0.0)
            ifc14read=1
          else if (key .eq. 'DIEL') then
c           Dielectric constant
            call getreal(dielcau,1,1.0)
            if (dielcau .le. 0.0) then
              dielcau=1.0
            if (MYRANK .eq. 0) write (iout,2087)
              nchng=nchng+1
            end if
          else if (key .eq. 'DDIE') then
c           call getreal(eps0_ddd,0,78.4)
c           call getreal(a_ddd,0,-8.5525)
c           call getreal(rlambda_ddd,0,0.00362)
c           call getreal(rk_ddd,0,7.7839)
c           Newly optimized default screening function parameters
            call getreal(eps0_ddd,0,78.4)
            call getreal(a_ddd,0,6.02944)
            call getreal(rlambda_ddd,0,0.018733345)
            call getreal(rk_ddd,0,213.5782)
            call getreal(epsmin_ddd,0,8.0)
            if (epsmin_ddd .ge. eps0_ddd) then
              write (iout,2019) epsmin_ddd,eps0_ddd
              inperr=inperr+1
            end if
C@DD            b_ddd=eps0_ddd-a_ddd
C@DD            bl_ddd=rlambda_ddd*b_ddd
C@DD            if (epsmin_ddd .gt. 0.0) then
C@DD              argln=b_ddd/(rk_ddd*(epsmin_ddd-a_ddd))-1.0/rk_ddd
C@DD              if (argln .le. 0.0) then
C@DD                write (iout,3003) epsmin_ddd
C@DD                inperr=inperr+1
C@DD              else
C@DD                rmin_ddd=-alog(argln)/(rlambda_ddd*(eps0_ddd-a_ddd))
C@DD              end if
C@DD            else
C@DD              rmin_ddd=0
C@DD            end if
C@DD            do i=1,ngrid_ddd
C@DD              rij=(i-1)*rdiv_ddd
C@DD              if (rmin_ddd .ge. rij) then
C@DD                dd_ms(i)=1.0/epsmin_ddd
C@DD              else
C@DD                ddexp=(1.0+rk_ddd*exp(-bl_ddd*rij))
C@DD                dd_ms(i)=ddexp/(a_ddd*ddexp+b_ddd)
C@DD              end if
C@DD            end do
C@DD            if (idebug(141) .gt. 0) write (iout,3004)
C@DD     -        ((i-1)*rdiv_ddd,dd_ms(i),i=1,ngrid_ddd)
          else if (key .eq. 'BLKS') then
c           Blocks to skip for error estimate
            call getint(ncntrlskip,1,1,0)
            call getint(ncntrllim,1,1,#MI)
          end if
        else if (key0 .eq. 'OVST') then
c---------Find approximate best overlap of the two slt copies
          do i=1,3
            call getint(ixfit(i),0,1,0)
          end do
          if (nstfa .eq. 0) then
            inperr=inperr+1
            write (iout,2020)
          end if
          if (max0(ixfit(1),ixfit(2),ixfit(3)) .gt.
     -                  min0(nstfa0,nstfa-nstfa0)) then
            inperr=inperr+1
            write (iout,2023) ixfit
            iop(45)=0
          end if
          if (ixfit(1)*ixfit(2)*ixfit(3) .eq. 0) then
            do i=1,3
              ixfit(i)=(i*min0(nstfa0,nstfa-nstfa0))/3
            end do
          end if
          na=min0(nstfa0,3)
          write (iout,2021) (iatnam(ianslt(ixfit(k))),ixfit(k),k=1,na)
          call ovrslt(cslt,cslt(1,nstfa0+1),nstfa0,nstfa-nstfa0,
     -      ixfit,ixfit)
        else if (key0 .eq. 'IBEN') then
c---------Isobaric-isothermal ensemble
          if (key .ne. 'OFF ') then
            call decode(iben,niben,ndummyu,keyno,key,1)
            iop(72)=keyno-1
            call getreal(press,0,1.0)
            call getreal(vrange,0,100.0)
            call getint(nvchfreq,0,1,nmolec)
            call getint(nvchrep,0,1,nmolec)
            call getreal(vlam,0,0.5)
            if (iop(72) .eq. 1) then
              do k=1,3
                call getint(ixyzfreeze(k),0,1,0)
              end do
            end if
          end if
        else if (key0 .eq. 'LCMP') then
c---------Input compression modifier factor
          call getreal(complfac,0,0.5)
          sqcomplfac=sqrt(complfac)
        else if (key0 .eq. 'VCHA') then
c---------Pressure calculation with Widom-approach
          call getreal(volchaperc,0,0.5)
          call getint(nvvchfreq,0,1,1000)
          call getint(nvvchrep,0,1,10)
        else if (key0 .eq. 'GCEN') then
c---------Grand-canonical ensemble
          if (key .eq. 'OFF ') iop(88)=0
          call decode(gcen1,ngcen1,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(62)=keyno-1
          if (key .ne. 'RWVD' .and. iop(3) .gt. 9) then
            if (MYRANK .eq. 0) write (iout,2179)
            nchng=nchng+1
            iop(62)=0
          end if
          call decode(gcen2,ngcen2,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(88)=keyno-1
          call decode(gcen3,ngcen3,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(89)=keyno-1
          call decode(gcen4,ngcen4,ndummyu,keyno,key,0)
          if (keyno .gt. 1) then
            iop(53)=keyno-1
c           Read in as kcal/mole
            call getreal(uscpmas,1,0.0)
            uscpma=uscpmas
            call getreal(usmixps,1,0.0)
            usmixp=usmixps
            if (uscpma .lt. -1000. .and. MYRANK .eq. 0) write(iout,2030)
            if (uscpma .ge. -1000. .and. MYRANK .eq. 0) then
              bxxx=ba-beta*uscpma
              write (iout,2031) uscpma,usmixp,bxxx
            end if
          end if
          if (iop(41) .gt. 0) then
            iop(97)=2
c           Grid parameters, ba-Adams B param; nslvxp solvent molecules at
c           target density; ngrid-# of grid pts for cavity search in each
c           dimension; diamslv-cavity radius (in A) in cavity biased T,V,Mu;
c           idfreq-freq of ins/del try; idrepf-freq of report on ins/del try;
            irectx=13
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1024,err=980) ba,diamslv,pmvslt,ngrid,nslvxp,
     -        nmolfx,idfreq,idrepf,nmcransh
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,1345) ba,diamslv,pmvslt,ngrid,
     -        nslvxp,nmolfx,idfreq,idrepf,nmcransh
            if (nmolfx .eq. 0) nmolfx=1
            idsvfst=nmolfx+1
            if (ngrid(1) .eq. 0) ngrid(1)=#GX
            if (ngrid(2) .eq. 0) ngrid(2)=#GY
            if (ngrid(3) .eq. 0) ngrid(3)=#GZ
            if (ngrid(1) .lt. 2 .or. ngrid(2) .lt. 2 .or.
     -          ngrid(3) .lt. 2) then
              if (MYRANK .eq. 0) write (iout,2278) ngrid
              inperr=inperr+1
            end if
            if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
              call checkdim(ifail,iout,inperr,'GX',ngrid(1),1,0,0)
              call checkdim(ifail,iout,inperr,'GY',ngrid(2),1,0,0)
              call checkdim(ifail,iout,inperr,'GZ',ngrid(3),1,0,0)
            end if
            if (iop(9) .gt. 0 .and. nmcrec .ne. 1) then
              if (nmcrec .eq. 0) nmcrec=idfreq*(nslvxp+1)+1
              if (iop(53) .gt. 1) then
c               if iop(53)>1, to get the correct conf sampling, nmcrec should
c               not be a multiple of (idfreq+1) (or vice versa)
                if (nmcrec .ge. (idfreq+1)) then
                  ires1=mod(nmcrec,(idfreq+1))
                else
                  ires1=mod((idfreq+1),nmcrec)
                end if
                if (ires1 .eq. 0) then
                  if (MYRANK .eq. 0)
     -              write (iout,2039) filenames(3)(1:namlens(3))
                  nwarn=nwarn+1
                end if
              end if
            end if
            call edgetogredge(gredge,edgelgr,edgergr,edgexyz,iop(79),
     -        limgrl,limgru,gridcent,grll,grlu,iout,nchng,idebug(58))
            if ((iop(5) .ge. 1 .and. iop(5) .le. 3)
     -           .and. iop(41) .ne. 3) then
c             Non-rect PBC can only be used with grid limited to the inside
c             Update subroutine gridcopy to eliminate this
              nout=0
              do k=1,3
                if (gredge(k)+2.0*diamslv .ge. edgexyz(1)) nout=nout+1
              end do
              if (nout .gt. 0) then
                if (MYRANK .eq. 0)
     -            write (iout,2138) edgexyz(1)-2.0*diamslv
                inperr=inperr+1
              end if
            end if
          end if
        else if (key0 .eq. 'IDLG' .or. key0 .eq. 'LIMG' .or.
     -    key0 .eq. 'IDAC' .or. key0 .eq. 'IDAG' .or. key0 .eq. 'BTUN'
     -    .or. key0 .eq. 'MOND' .or. key0 .eq. 'BLKW' .or.
     -    key0 .eq. 'STPX')  then
c         Lump together a few keywords to reduce the number of if/then/else's
          if (key0 .eq. 'IDLG') then
c-----------Open/close insertion/deletion log file
            if (key(1:3) .eq. 'OFF') then
              call fileclose(iindel,0,iop(24),iout)
            else
              call fileopen(file,namlenf,filenames(5),namlens(5),5,0,
     -          numrun,1,0,0,iop(24),iversout,iout,iindel,0)
            end if
            call getreal(rpxidlim,0,4.0)
          else if (key0 .eq. 'IDAC') then
c-----------Set up proximity insertion/deletion acceptance rate calculation
            call getreal(rpxidlim,0,4.0)
            rpxidlim2=rpxidlim**2
            call zeroiti(idproxacc,0,4*nstta)
            call readpairlist(npxkeep,ipxkeep,100,nstta,'ipxkeep   ',
     -        'list of atoms to use','solute atoms',iout,inperr,
     -        nwarn,1,nchng,1,1,0,0)
            call zeroiti(keeppx,0,nstta)
            if (npxkeep .gt. 0) then
              do ix=1,npxkeep
                do ia=ipxkeep(1,ix),ipxkeep(2,ix)
                  if (ianslt(ia) .gt. 1) keeppx(ia)=1
                end do
              end do
            else
              do ia=1,nstta
                if (ianslt(ia) .gt. 1) keeppx(ia)=1
              end do
            end if
          else if (key0 .eq. 'LIMG') then
c-----------Limit cavity grid to a smaller region than the full box
            call find('FREE',1,nmainkey,mainkey,keyno,4)
            if (mainkeyun(keyno) .gt. 0 .and.
     -          (iop(30) .eq. 1 .or. iop(30) .eq. 2)) then
              write (iout,2136)
              inperr=inperr+1
            end if
            call zeroiti(limgrl,0,3)
            call zeroiti(limgru,0,3)
            do k=1,3
              call getreal(grll(k),1,0.0)
              call getreal(grlu(k),1,0.0)
            end do
            igrll=1
          else if (key0 .eq. 'MOND' .or. key0 .eq. 'BLKW') then
c-----------Monitor inside/outside density
            if (iop(5) .gt. 0 .and. key0 .eq. 'BLKW') then
              write (iout,2346)
              inperr=inperr+1
            else
              call find('MOND',1,nmainkey,mainkey,keynoM,4)
              call find('BLKW',1,nmainkey,mainkey,keynoB,4)
              if (mainkeyun(keynoM)*mainkeyun(keynoB) .gt. 0) then
                write (iout,2345)
                nwarn=nwarn+1
              end if
              if (key0 .eq. 'MOND') then
                do k=1,3
                  call getreal(edgelinxyz(k),0,0.0)
                  call getreal(edgerinxyz(k),0,0.0)
                end do
              else
                call getreal(wlayer,0,5.0)
                do k=1,3
                  edgelinxyz(k)=-edgexyz(k)/2.0+wlayer
                  edgerinxyz(k)=edgexyz(k)/2.0-wlayer
                end do
              end if
              call volincalc(vol,iop(5),edgexyz,edge2xyz,rinscr,rboxmax,
     -          volin,edgelinxyz,edgerinxyz)
            end if
          else if (key0 .eq. 'IDAG') then
c-----------Print a PDB file with the I/D sites as N and O atoms
            call decode(idag,nidag,ndummyu,keyno1,key1,1)
            call idaggregate(c,nstta,nsttg,numrec(5),file,namlenf,
     -        filename1,namlens1,filenames(5),namlens(5),numrun,
     -        ipdbvers,nmc,labslt,ianslt,abx,aby,key,key1)
            ipdbvers=ipdbvers+1
          else if (key0 .eq. 'BTUN') then
c-----------Tune B parameter to a density
          if (iop(76) .eq. 0 .or. iop(76) .eq. 4) then
            if (ickpread .eq. 0 .and. numrun .eq. numrunst) then
              if (MYRANK .eq. 0) write (iout,2237)
              nwwarn=nwwarn+1
            end if
            if (iop(76) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2238)
     -          'B value at the end of the last run',ba
            else
              if (nmc .eq. 0) then
                write (iout,2380)
                inperr=inperr+1
              else
                ba=bsum/(2*nmc)
                if (MYRANK .eq. 0)
     -            write (iout,2238) 'average B over the last run',ba
              end if
              iop(76)=0
            end if
          end if
          if (iop(76) .gt. 0) then
              call getreal(targetden,0,0.997)
              if (iop(76) .eq. 1 .or. iop(76) .eq. 2) then
                call getint(nmctunave,0,1,100000)
                call getint(nmctunskip,0,1,nmctunave)
                call getreal(chabmax,0,1.0)
                call getreal(tolden,0,0.01)
              else if (iop(76) .eq. 3) then
                call getreal(sintegraltime,0,2000.0)
                integraltime=sintegraltime
                call getreal(sgain,0,-50.0)
                gain_den=sgain
              end if
              call getint(inorout,0,1,2)
              call getreal(targetn,0,-50.0)
            end if
          else if (key0 .eq. 'STPX') then
c-----------Stop GCE run at target solvent number
            call getint(nslvxp,0,1,0)
            call checkdim(ifail,iout,inperr,'MO',nslvxp,1,1,0)
          end if
        else if (key0 .eq. 'STUN') then
c---------Tune stepsizes to a target acceptance rate
          call decode(stun,nstun,ndummyu,keyno1,key1,1)
          if (keyno1 .gt. 2 .and. istune(keyno) .eq. 0) then
            if (MYRANK .eq. 0) write (iout,2140) key,key1,key
            inperr=inperr+1
          else if (key1(1:3) .eq. 'OFF') then
c           Turn off this tuning
            istune(keyno)=0
            istunestep(keyno)=keyno1
            if (key1 .eq. 'OFFW') then
c             Get weight-averaged stepsize
              if (keyno .eq. 1) then
                do im=movmolf,movmoll
cwww              call trnsfrrd(cedpsltim(1,im),stepsumtrans(1,im),3)
                  do k=1,3
                    cedpsltim(k,im)=stepsumtrans(k,im)*(wstepsum1(1)/
     -                (1.d0-wstepsum(1)**(ntrantune(im)+1)))
                  end do
                end do
              else if (keyno .eq. 2) then
                do im=movmolf,movmoll
cwww              call trnsfrrd(rtxpslt(1,im),stepsumrot(1,im),3)
                  do k=1,3
                    rtxpsltim(k,im)=stepsumrot(k,im)*(wstepsum1(2)/
     -                (1.d0-wstepsum(2)**(nrottune(k,im)+1)))
                  end do
                end do
              else if (keyno .eq. 3) then
cwww            call trnsfrrd(torstep,stepsumtor,ntangorg)
                do it=1,ntangorg
                  torstep(it)=stepsumtor(it)*(wstepsum1(3)/
     -              (1.d0-wstepsum(3)**(nptsttry(it)+1)))
                end do
              else if (keyno .eq. 4) then
cwww            call trnsfrrd(steploop,stepsumloop,ntangorg)
                do it=1,ntangorg
                  steploop(it)=stepsumloop(it)*(wstepsum1(4)/
     -              (1.d0-wstepsum(4)**(nptlooptry(it)+1)))
                end do
              end if
            else if (key1 .eq. 'OFFC') then
c             Get cumulative stepsize averages
              if (keyno .eq. 1) then
                do im=movmolf,movmoll
                  do k=1,3
                    if (ntrantune(im) .gt. 0) cedpsltim(k,im)=
     -                stepsumtranscumu(k,im)/ntrantune(im)
                  end do
                end do
              else if (keyno .eq. 2) then
                do im=movmolf,movmoll
                  do k=1,3
                    if (nrottune(k,im) .gt. 0) rtxpsltim(k,im)=
     -                stepsumrotcumu(k,im)/nrottune(k,im)
                  end do
                end do
              else if (keyno .eq. 3) then
                do it=1,ntangorg
                  if (nptsttry(it) .gt. 0)
     -              torstep(it)=stepsumtorcumu(it)/nptsttry(it)
                end do
              else if (keyno .eq. 4) then
                do it=1,ntangorg
                  if (nptlooptry(it) .gt. 0)
     -              steploop(it)=stepsumloopcumu(it)/nptlooptry(it)
                end do
              end if
            end if
          else
c           Read tuning parameters
            istune(keyno)=1
            istunetyp(keyno)=keyno1
            call getreal(targetacc(keyno),0,0.3)
            call check01int(targetacc(keyno),'acceptance rate target',
     -        iout,inperr)
            call getreal(wsumread,0,0.999)
            if (wsumread .gt. 0.999) then
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,2125)
              wsumread=0.999
            end if
            wsum(keyno)=wsumread
            wsum1(keyno)=1.d0-wsum(keyno)
            call getreal(sintegraltime,0,2000.0)
            timeint(keyno)=sintegraltime
            call getreal(sgain,0,-50.0)
            gain(keyno)=sgain
            call getreal(wsumread,0,0.999)
            if (wsumread .gt. 0.999) then
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,2125)
              wsumread=0.999
            end if
            wstepsum(keyno)=wsumread
            wstepsum1(keyno)=1.d0-wstepsum(keyno)
            call getreal(tunstpmn(keyno),0,tunstpmndef(keyno))
            call getreal(tunstpmx(keyno),0,tunstpmxdef(keyno))
            if (keyno .gt. 1) then
              tunstpmn(keyno)=tunstpmn(keyno)/rdtodg
              tunstpmx(keyno)=tunstpmx(keyno)/rdtodg
            end if
            if (mod(iop(44),2) .ne. 1) then
c             Solute sampling has to be set to separate trans and rot
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,2061)
            end if
          end if
          call zeroiti(nmc_zeroacc,0,4)
        else if (key0 .eq. 'TAC0') then
c---------Read new start of cumulative stepsize averaging
          call getint(nmc_zeroacc(keyno),1,1,0)
        else if (key0 .eq. 'PRTG') then
c---------Print gridpoints
          call checkcompopt(icompopt(21),key0,'PG',inperr,iout)
          call decode(prtg,nprtg,ndummyu,keyno1,key1,1)
          call decode(prtg2,nprtg2,ndummyu,keyno2,key2,1)
          call getint(nnexmin,0,1,1)
          call getint(nnexmax,0,1,0)
          call getreal(cvlim,0,0.0)
          call check01int(cvlim,'Pocket CV threshold',iout,inperr)
          call getreal(rcutcv,0,10.0)
          call getreal(volcavmin,0,0.0)
          call getreal(volpckmin,0,0.0)
          call getreal(rnearlim,0,sqrt(10.0))
          rnear2lim=rnearlim**2
          call getreal(rsltfac,0,0.9)
          call getreal(cvlimcav,0,0.0)
          call check01int(cvlimcav,'Cavity CV threshold',iout,inperr)
c         call getreal(rcutcvcav,0,10.0)
          call getreal(randsh,0,0.5)
          call getreal(diamslvnew,0,0.0)
          call getint(nlshave,0,1,0)
          call getint(maxnnsurf,0,1,4)
          call getint(noputbacksfg,0,1,0)
          call getint(numrunw,0,1,numrun)
          if (rcutcv .lt. diamslv) then
            write (iout,2375) rcutcv,diamslv
            inperr=inperr+1
          else if (rcutcv .lt. diamslv) then
            write (iout,2376) rcutcv,2.0*diamslv
            nwwarn=nwwarn+1
          end if
          do k=1,3
            ranshift(k)=randsh
          end do
c         If there is a PDB file (input crd) open, close it
          if (ifilstat(15) .ne. 0)
     -      call fileclose(icord,0,iop(24),iout)
          if (nmolec .gt. 1) then
            write (iout,2200)
            nwarn=nwarn+1
          end if
          if (nstta .eq. 0) then
            write (iout,2260)
            call datprt(2)
          end if
          if (iop(76) .eq. 0) then
c           Default grid
c           Center the solute for the grid calculation
            do k=1,3
              xyzmin(k)=1.e+25
              xyzmax(k)=-1.e+25
            end do
            do i=1,nstta
              do k=1,3
                if (c(k,i) .lt. xyzmin(k)) xyzmin(k)=c(k,i)
                if (c(k,i) .gt. xyzmax(k)) xyzmax(k)=c(k,i)
              end do
            end do
            do k=1,3
              cx(k)=(gredge(k)-(xyzmax(k)-xyzmin(k)))/2.0
              if (cx(k) .lt. 0.0) then
                write (iout,2204) lxyz(k),-2.0*cx(k)
                nwwarn=nwwarn+1
              end if
            end do
c           Create a new grid around the center of the solute
            rsph=diamslv
            if (diamslvnew .gt. 0.0) rsph=diamslvnew
            call makefullgrid(xyzmin,xyzmax,rsph,iout)
          end if
          igrdvers=2
          if (inperr .gt. 0) then
            call datprt(-1)
            if (MYRANK .eq. 0) write (iout,2199)
          end if
          inperr0=inperr
          call initgrid(1,1.0,diamslv/2.0,1,vsltgrx,vol,
     -      c,crm,0,1,0,'PRTG',min0(1,iop(24)),0)
          nshort=0
          do ia=1,nstta
            if (rnearlim .lt. rsphi(ia)) nshort=nshort+1
            end do
          if (nshort .gt. 0) then
            write (iout,2206) nshort,rnearlim
            nwarn=nwarn+1
          end if
          if (nshort .eq. nstta) then
            write (iout,2309)
            inperr=inperr+1
          end if
          if (inperr .gt. 0) call datprt(2)
          call prtgrid(numrunw,c,#NA,keyno,
     -      nofcls,keyno1-1,nnexmin,nnexmax,cvlim,rcutcv,volcavmin,
     -      volpckmin,cvlimcav,nlshave,noputbacksfg,
C@PG     -      igrdvers,labslt,keyno2,maxnnsurf,sltchainid,
     -      iout,inperr,nwarn,nwwarn)
          if (diamslvnew .gt. 0.0 .and. inperr .eq. inperr0) then
            if (diamslv .gt. 0.0) then
              call initgrid(1,(diamslvnew/diamslv),diamslv/2.0,nr,
     -          vsltgrx,vol,c,crm,0,1,0,'PRTG',1,0)
            else
              call initgrid(1,1.0,diamslvnew/2.0,nr,
     -          vsltgrx,vol,c,crm,0,1,0,'PRTG',1,0)
            end if
            write (iout,2058) diamslvnew
            call prtgrid(numrunw,c,#NA,keyno,
     -        nofcls,keyno1-1,nnexmin,nnexmax,cvlim,rcutcv,volcavmin,
     -        volpckmin,cvlimcav,nlshave,noputbacksfg,
C@PG     -        igrdvers,labslt,keyno2,maxnnsurf,sltchainid,
     -      iout,inperr,nwarn,nwwarn)
          end if
        else if (key0 .eq. 'STVG') then
c---------Estimate solute volume
          call checkcompopt(icompopt(21),key0,'PG',inperr,iout)
          call getreal(diamslvnew,0,diamslv)
          call getint(ngridrep,0,1,10)
          avgvolg=0.d0
          avgvolg2=0.d0
          call zeroit(cv1,nstta)
          call zeroit(cv2,nstta)
          igrdvers=1
          volfact=1.0
          if (iop(79) .gt. 0) then
            call volincalc(vol,iop(5),edgexyz,edge2xyz,rinscr,rboxmax,
     -        volint,grll,grlu)
            volfact=volint/vol
            if (igrll .eq. 0) then
              write (iout,2017)
              call datprt(2)
            end if
          end if
          do ig=1,ngridrep
            call mmc_random(3,ranshift)
            call initgrid(1,(diamslvnew/diamslv),diamslv/2.0,1,
     -        vsltgrx,vol*volfact,cslt,crm,0,1,1,'STVG',1,0)
            avgvolg=avgvolg+vsltgrx
            avgvolg2=avgvolg2+vsltgrx**2
          end do
          sd=dsqrt(avgvolg2/ngridrep-(avgvolg/ngridrep)**2)
          write (iout,2071) (avgvolg/ngridrep),sd,diamslvnew,ngridrep
        else if (key0 .eq. 'IWSL') then
c---------Solvent-to-site assignment information file (.wsl) write setup
c         used for input to entropy calculation
          call getreal(clstfin_dmax,0,0.0)
          call getint(nclust_clstfin,0,1,0)
          if (clstfin_dmax .gt. 0.0 .and. nclust_clstfin .gt. 0) then
            write (iout,2341)
            inperr=inperr+1
          end if
          call getreal(cvfilt_stow,0,0.0)
          call check01int(clstfin_stow,'clstfin_stow',iout,inperr)
          call getreal(froccmin_stow,0,0.0)
          call check01int(froccmin_stow,'froccmin_stow',iout,inperr)
          call getreal(rmsdlim_stow,0,0.0)
          call getint(maxclstmem_stow,0,1,10)
          call getreal(subreground,0,0.7)
          call check01int(subreground,'subreground',iout,inperr)
        else if (key0 .eq. 'CPOC') then
c---------Calculate solvent occupancy of cavities
          call checkcompopt(icompopt(21),key0,'PG',inperr,iout)
C@PG          call decode(cpoc,ncpoc,ndummyu,keyno1,key1,1)
C@PG          call decode(cpoc1,ncpoc1,ndummyu,keyno2,key2,1)
C@PG          do k=1,3
C@PG            ranshift(k)=randsh
C@PG          end do
C@PG          rslv=diamslv/2.0
C@PG          gvol=grid(1)*grid(2)*grid(3)
C@PG          mincavcl=volcavmin/gvol
C@PG          write (iout,2304) rslv,grid
C@PG          if (mincavcl .gt. 0) write (iout,2308) mincavcl,volcavmin
C@PG          call initgrid(1,1.0,diamslv/2.0,1,vsltgrx,vol,c,crm,0,1,0,
C@PG     -      'CPOC',min0(1,iop(24)),0)
C@PG          ncavs=0
C@PG          call clustergrid(1,1,ncavs,nofcls,mincavcl,cvlimcav,rcutcv,
C@PG     -      0.0,c,istf,nstta,ngleft,ncleft,1,1,idebug(157),iout,inperr)
C@PG          nofcls0=0
C@PG          nofcls1=ncavs
C@PG          if (key .eq. 'PCKT') then
C@PGc           Filter the first cluster by CV and recluster
C@PG            call cvfilter_grids(ngdel,istf,nstta,c,rcutcv,cvlim,nofcls)
C@PGc           Update neighbor list
C@PG            call clustergrid(0,0,ncavs,nofcls,minpckcl,cvlimcav,
C@PG     -        rcutcv,0.0,c,istf,nstta,nleft,ncleft,0,0,idebug(157),
C@PG     -        iout,inperr)
C@PG            nofcls0=ncavs
C@PG            nofcls1=nofcls
C@PG          end if
C@PG          diamol=2.0*rslv
C@PG          if (key1 .eq. 'CONF') then
C@PG            do im=2,nmolec
C@PG              call cofms(c(1,ic01+im*nslv),crm(1,im),ianslv,1,nslv,1,wx)
C@PG            end do
C@PG            call cavity_occ(crm,2,nmolec,nofcls0,nofcls1,diamol,
C@PG     -        mincavcl,cvlimcav,rcutcv,istf,nstta,c,l1,nslvfound,0,
C@PG     -        ncleft,n_unass,key,iout)
C@PG            call report_clst_occ(ncleft,nofcls0,nofcls1,1,gvol,rslv,l1,
C@PG     -        nslvfound,n_unass,key,iout)
C@PG            if (key2 .eq. 'SAVE') then
C@PGc             Create a PDB file with the slt and the cavity-occupying slvnts
C@PG              call trnsfr(cci,c,3*nstta)
C@PG              do is=1,nslvfound
C@PG                call trnsfr(cci(1,nstta+nslv*(is-1)+1),
C@PG     -            c(1,nstta+(ivopt(is)-2)*nslv+1),nslv*3)
C@PG              end do
C@PG              call savepdb('PDB ',keycol,iupdb2,iout,1,nstta,nslv,cci,
C@PG     -          nslvfound,0,0,1,filename1,lenfile1,0,2,file,namlenf,
C@PG     -          numrun,4,3,inperr,nwarn,nwwarn,25,1,nlwr,0,1,#NA)
C@PG              write (iout,2307) nslvfound,filename1(1:lenfile1)
C@PG            end if
C@PG          else
C@PGc           Trajectory
C@PG            call getint(nmcf,1,1,1)
C@PG            call getint(nmcl,1,1,1)
C@PG            call getint(nmcinc,1,1,1)
C@PG            write (iout,2114) filenames(3)(1:namlens(3)),
C@PG     -        nmcf,nmcl,nmcinc
C@PG            if (iop(9) .eq. 0) then
C@PG              write (iout,2056)
C@PG              inperr=inperr+1
C@PG              go to 1131
C@PG            end if
C@PG            if (keyno2 .eq. 2) then
C@PG              write (iout,2306)
C@PG              nchng=nchng+1
C@PG            end if
C@PG            nslvtot=0
C@PG            n_unasstot=0
C@PG            nmchinc=0
C@PG            icntrlr(1)=0
C@PGc           Open input trajectories and gather initial config
C@PG            call opentraj(filenames(3),namlens(3),nstta,nslv,nsvp,c,0,
C@PG     -        nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),0,
C@PG     -        uusfac,edgexyz,ieof,nconnfail)
C@PG            if (inperr .gt. 0) call datprt(-1)
C@PG            call zeroiti(l2,0,#UV)
C@PG            nframe=0
C@PG            lastnmc=0
C@PG            do while (.true.)
C@PG              if (iskip1 .eq. 0) then
C@PG                call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
C@PG     -            nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
C@PG     -            nmchinc,incrun,ia0,c,0,numrec(3),uusfac,0,nsvp,0)
C@PG                if (ieof .gt. 0) then
C@PG                  if (inperr .gt. 0) call datprt(-1)
C@PG                  write (iout,2169) lastnmc,filenames(3)(1:namlens(3))
C@PG                  go to 1130
C@PG                end if
C@PG              else
C@PG                iskip1=0
C@PG              end if
C@PG              lastnmc=nmc
C@PG              if (nmc.gt. nmcl) go to 1130
C@PG              iskip=0
C@PG              if (nmc .lt. nmcf) iskip=1
C@PG              if (mod(nmc-nmcf,nmcinc) .ne. 0) iskip=1
C@PG              if (iskip .eq. 0) then
C@PG                do im=2,nmolec
C@PG                  call cofms(c(1,ic01+im*nslv),crm(1,im),ianslv,1,nslv,
C@PG     -              1,wx)
C@PG                end do
C@PG                call cavity_occ(crm,2,nmolec,nofcls0,nofcls1,diamol,
C@PG     -            mincavcl,cvlimcav,rcutcv,istf,nstta,c,l1,nslvfound,
C@PG     -            nframe,ncleft,n_unass,key,iout)
C@PG                nframe=nframe+1
C@PG                nslvtot=nslvtot+nslvfound
C@PG                n_unasstot=n_unasstot+n_unass
C@PG                do i=1,nofcls
C@PG                  l2(i)=l2(i)+l1(i)
C@PG                end do
C@PG                if (idebug(156) .gt. 0) then
C@PG                  write (iout,8793) nframe,nslvfound,nslvtot,nofcls,
C@PG     -              (l2(i),i=1,nofcls)
C@PG8793              format(' nframe,nslvfound,nslvtot,nofcls=',4i10,/,
C@PG     -             (' l2=',20i6))
C@PG                end if
C@PG              end if
C@PG            end do
C@PG1130        call report_clst_occ(ncleft,nofcls0,nofcls1,nframe,gvol,
C@PG     -        rslv,l2,nslvtot,n_unasstot,key,iout)
C@PG1131        continue
C@PG          end if
        else if (key0 .eq. 'GSAN' .or. key0 .eq. 'GSAO' .or.
     -           key0 .eq. 'GABF') then
          if (key0 .eq. 'GSAN') then
c-----------Generic solvent site analysis selection
            igsanaltyp(iop(122))=1
            call decode(gsan,ngsan,ndummyu,keyno1,key1,0)
            if (key1 .eq. 'CAEV' .or. key1 .eq. 'ONRM' .or.
     -        key1 .eq. 'RDOR') igsanaltyp(iop(122))=2
            if (igsanaltyp(6) .eq. 2) then
              write (iout,2285)
              nchng=nchng+1
            end if
            if (key .eq. 'HBND' .or. key .eq. 'HBTT') then
              call getreal(rxhmax,0,rxhmax)
              rxhmax2=rxhmax**2
              call getreal(hbanglemina,0,hbanglemina)
              hbanglemin=hbanglemina/rdtodg
              call getreal(occmin_at,0,0.0)
              call check01int(occmin_at,'occmin_at',iout,inperr)
              call getreal(occmin_res,0,0.0)
              call check01int(occmin_res,'occmin_res',iout,inperr)
              if (key .eq. 'HBTT') then
                call getreal(occmin_tt,0,0.0)
                call check01int(occmin_tt,'occmin_tt',iout,inperr)
              end if
            end if
            if (key1 .eq. 'RDOR')  then
              call getint(numrunorg,0,1,numrun)
              call getint(iversorg,0,1,1)
              call fileopen(file,namlenf,filenames(42),namlens(42),42,0,
     -          numrunorg,iversorg,2,1,iop(24),iversout,iout,iwriteorg,
     -          0)
            end if
            if (key .ne. 'ENRG' .and. iop(26) .gt. 3) then
              write (iout,2103)
              nwwarn=nwwarn+1
            end if
            if (#GC .eq. 1) then
              write (iout,2284)
              call datprt(2)
            end if
            if (iop(118) .eq. 0) iop(118)=2
          else if (key0 .eq. 'GSAO') then
c-----------Generic solvent site analysis options
            matsort=keyno
            call decode(gsao,ngsao,ndummyu,matform,key1,0)
            call decode(gsao1,ngsao1,ndummyu,icorrcomp,key2,0)
            if (key .eq. 'SXYZ' .or. key .eq. 'RXYZ') then
              call getint(iaxsort1,1,1,0)
            else if (key .eq. 'LEXI') then
              call getint(iaxsort1,1,1,0)
              call getint(iaxsort2,1,1,0)
              call getint(iaxsort3,1,1,0)
              call getreal(sortwgt,0,10.0)
            end if
          else if (key0 .eq. 'GABF') then
c-----------Generic solvent site hydrogen bond analysis by frames
            call getreal(rxhmax,0,rxhmax)
            rxhmax2=rxhmax**2
            call getreal(hbanglemina,0,hbanglemina)
            hbanglemin=hbanglemina/rdtodg
            call getreal(hbmatmin,0,0.0)
            if (iop(118) .eq. 0) iop(118)=2
          end if
        else if (key0 .eq. 'GENS') then
c---------Generic solvent site calculations
          if (key .eq. 'CCAL' .and. ickpread .eq. 0) then
            write (iout,2191)
            call datprt(2)
          end if
          if (key .eq. 'COMP') then
c           Compare two sites
            call find('CMPC',1,nmainkey,mainkey,npfkey,4)
            call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -        keyno1,key1,1)
            call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -        keyno2,key2,1)
            call decode(gens6,ngens6,ndummyu,keyno3,key3,0)
            call getint(ns1,1,1,0)
            call getint(ns2,1,1,0)
            call getsitec(c,ns1,iformiop47,itypeiop47,nslt1,nslv1,
     -        isite1,edgexyz,frocc1,bfac1,keyno1,filename1,nlen1,
     -        iout,nwarn,inperr)
            call getsitec(cgs,ns2,iformiop47,itypeiop47,nslt2,nslv2,
     -        isite2,edgexyz,frocc2,bfac2,keyno2,filename2,nlen2,
     -        iout,nwarn,inperr)
            call getreal(rcutxst,0,3.0)
            call getreal(rmateps,0,0.01)
            call getreal(rcutcrcv,0,8.0)
            call getreal(rmsdgrid,0,0.15)
            if (keyno3 .gt. 1) then
              call getreal(rneigsite,0,5.0)
              rneigsite2=rneigsite**2
              if (nslt1 .ne. nslt2) then
                write (iout,2192) nslt1,nslt2
                inperr=inperr+1
              end if
              if (nslt1 .eq. 0) then
                write (iout,2193)
                inperr=inperr+1
              end if
              call getint(nexp,0,0,1)
              sqrcutxst=sqrt(rcutxst)
              call rij2matcorr(1,ns1,1,ns2,nslt1,nslt2,nslv1,nslv2,
     -          isite1,isite2,c,cgs,iop(5),keyno3,nexp,rneigsite2,iout)
            else
              rneigsite2=0.0
              maxsiteng=0
              sqrcutxst=rcutxst
              nexp=0
            end if
            if (inperr .gt. 0) go to 1111
            call rij2mat(1,ns1,1,ns2,nslt1,nslt2,nslv1,nslv2,isite1,
     -        isite2,c,cgs,iop(5),keyno3,nexp,rneigsite2,#NA,#MH)
            if (keyno3 .gt. 1) maxsiteng=l1(1)
            maxmaxng=0
            call minmat(ns1,ns2,sqrcutxst,0.0,r2sum,r2max,nmat,nmiter,
     -        0,rmateps,0,maxmaxng,0)
            call rep2mat(ns1,ns2,nslt1,nslt2,nslv1,nslv2,isite1,isite2,
     -        c,cgs,nmat,niter,filename1,filename2,nlen1,nlen2,
     -        rcutxst,rmateps,rcutcrcv,rmsdgrid,indexn,indexx,
     -        cv1,cv2,cv3,aby,abz,keyno3,l1,nexp,rneigsite,maxsiteng,
     -        iout)
            call mrgsrt(iout,indexx,cv3,nmat,l2,l3,l4,cv1,#MH)
            call mrgsrt(iout,indexx(nmat+1),cv3(nmat+1),ns2-nmat,
     -        l2,l3,l4,cv1,#MH)
            if (nslt2 .ne. nstta .or. nslv2 .ne. nslv) then
              write (iout,2241)
            else
c             Create a PDB file from the sites in the order of decreasing CV
              call trnsfr(c,cgs,nstta*3)
              call trnsfr(abx,frocc2,ns2)
              do is=1,ns2
                call trnsfr(c(1,nstta+(is-1)*nslv+1),
     -            cgs(1,nstta+(indexx(is)-1)*nslv+1),3*nslv)
                frocc1(is)=abx(indexx(is))
                bfac1(is)=-cv3(is)
              end do
              incvers=10
              call savepdb('PDBw',keycol,icordw,iout,1,nstta,nslv,c,
     -          ns2,0,0,1,filename1,namlen1,0,2,file,namlenf,numrun,
     -          1+incvers,0,inperr,nwarn,nwwarn,15,0,nlwr,0,1,#NA)
            end if
          else if (key .eq. 'CLST') then
            call find('CMPC',1,nmainkey,mainkey,npfkey,4)
            call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -        keyno1,key1,1)
            call getint(ns,1,1,0)
            call getsitec(c,ns,iformiop47,itypeiop47,nslt1,nslv1,
     -        isite1,edgexyz,abx,aby,keyno1,filename1,nlen1,
     -        iout,nwarn,inperr)
            call getreal(clstmerge_dmax,0,2.0)
            call getreal(froccpairmax,0,2.0)
            do is=1,ns
              call trnsfr(zv(1,is),c(1,nslt1+(is-1)*nslv1+isite1),3)
            end do
            call zeroitd(tesi,ns)
            call mergesites(c,nslt,ns,clstmerge_dmax,froccpairmax,zv,
     -        abx,aby,abz,tesi,nofcls,ifirsts,ilasts,iclsts,inperr,iout)
            nmolec=nofcls+1
            natoms=nslt1+nofcls
            incvers=10
            call trnsfr(c(1,nslt1+1),cgs(1,nslt1+1),3*nofcls)
            if (nslt1 .eq. nstta) then
              call savepdb('PDBw',keycol,icordw,iout,1,nstta,1,c,
     -          nofcls,0,0,1,filename1,namlen1,0,2,file,namlenf,numrun,
     -          1+incvers,0,inperr,nwarn,nwwarn,16,0,nlwr,0,1,#NA)
            else
c             Solute read above is different from solute read with SLTA
              write (iout,2242)
              write (iout,2243) (is,is,(c(k,nslt1+is),k=1,3),frocc1(is),
     -          bfac1(is),is=1,ns)
            end if
          else
c           Calculate sites from trajectory
            if (key .eq. 'CALC') irestore=0
            if (key .eq. 'CCAL') irestore=1
            call decode(gens2,ngens2,ndummyu,iopupdate,key2,0)
            call decode(gens3,ngens3,ndummyu,iopinicnf,key3,0)
            call decode(gens4,ngens4,ndummyu,iopresfor,key4,0)
            call decode(gens5,ngens5,ndummyu,isorttyp,key5,0)
            if (iasize(38) .lt. iasize(51)) then
              write (iout,2240) 'UV','MH'
              call datprt(2)
            else
              call gensitecalc(c,cgs,c1,crm,nstta,nslv,islvrep,rlcslv,
     -          ianslv,ixrep3,nrep3,ianslt,iclslt,igrslt,ifgrslt,
     -          ilgrslt,qslt,labslt,ixislt,iopupdate,iopinicnf,
     -          iopresfor,iformiop47,itypeiop47,keynocnf,isorttyp,
     -          irestore,sltinptyp,igsanaltyp,matform,matsort,iaxsort1,
     -          iaxsort2,iaxsort3,sortwgt,icorrcomp,rxhmax2,hbanglemin,
     -          hbmatmin,occmin_at,occmin_res,occmin_tt,iwriteorg,
     -          filenames(42),namlens(42))
              ifrocc=1
            end if
          end if
c         Prevent new run without CNFG since config arrays are changed
          call find('CNFG',1,nmainkey,mainkey,keynocnf,4)
          mainkeyun(keynocnf)=0
        else if (key0 .eq. 'TRAJ') then
c---------Trajectory file options
          if (iop(9) .eq. 0) then
c           Turn  off trajectory file writing
            if (iop9old*ihist .gt. 0 .and. MYRANK .eq. 0)
     -         call fileclose(ihist,0,iop(24),iout)
            iop9old=0
            nhstvers=1
          else
            iform(3)=iformiop9(iop(9))
            if (MYRANK .eq. 0) call fileclose(ihist,0,iop(24),iout)
            numrunr=numrun
            call decode(traj,ntraj,ndummyu,keyno,key1,0)
            if (keyno .gt. 0) iop(152)=keyno-1
            if (key .eq. 'AMBR' .or. key .eq. 'CHRM') then
c             Non-MMC trajectory
              if (key .eq. 'AMBR') then
                call decode(traj2,ntraj2,ndummyu,keyno,key1,0)
                if (keyno .gt. 0) iop(161)=keyno-1
              end if
            else
c             MMC trajectory
              if (key(1:3) .eq. 'ALL') then
                call decode(traj1,ntraj1,ndummyu,keyno,key1,0)
                if (keyno .gt. 0) iop(59)=keyno-1
              end if
            end if
            call getint(natskip,0,1,0)
            call getint(numrunh,0,1,numrun)
            call getint(nhstvers,0,1,1)
            call getname(filenameh,namlenh,0,80)
            call getint(incrun,0,1,0)
            if (incrun .gt. 1) then
              write (iout,2220) incrun
              inperr=inperr+1
            end if
            if (namlenh .eq. 0) then
              namlenh=namlenf
              filenameh=file
            end if
            ialttraj=0
            call getname(stuff,lenext,0,80)
            if (lenext .gt. 0) then
              do i=1,nfiletyp
                if (stuff(1:3) .eq. namunit(i)) ialttraj=i
              end do
              if (ialttraj .eq. 0) then
                if (lenext .ne. 3) then
                  if (MYRANK .eq. 0) write (iout,2234) stuff(1:lenext)
                  inperr=inperr+1
                else
                  if (MYRANK .eq. 0) write (iout,2219) stuff(1:lenext)
                  nfiletyp=nfiletyp+1
                  namunit(nfiletyp)=stuff(1:lenext)
                  ialttraj=nfiletyp
                end if
              end if
            else if (namlenh .gt. 0) then
              write (iout,2382)
              nwwarn=nwwarn+1
            end if
            if (MYRANK .eq. 0) then
              call fileopen(filenameh,namlenh,filenames(3),namlens(3),3,
     -          ialttraj,numrunh,nhstvers,0,iform(3),iop(24),iversout,
     -          iout,ihist,0)
            end if
            iop9old=iop(9)
          end if
          nmchinc=0
          call zeroiti(icntrlr,0,20)
        else if (key0 .eq. 'SUPI') then
c---------Trajectory superimposition
          call decode(supi1,nsupi1,ndummyu,keyno,key1,0)
          if (key1 .eq. 'RNGE') then
c           Read in range here
            irangetyp=0
            call readpairlist(nafltrange,iafltrange,50,0,
     -        'iafltrange','atoms to use for overlay','solute atoms',
     -        iout,inperr,nwarn,1,nchng,0,0,0,0)
            novuse=0
            do iseg=1,nafltrange
              do i=iafltrange(1,iseg),iafltrange(2,iseg)
                novuse=novuse+1
                ixovref(novuse)=i
              end do
            end do
            ixrefok=1
          else
            call getint(irangetyp,1,1,0)
            call getreal(rangerad,1,0.0)
          end if
        else if (key0(1:3) .eq. 'CNF') then
c---------Initial configuration
          idiffread=0
          ifrocc=0
          icplp=0
          irunvers=1
          call find('CMPC',1,nmainkey,mainkey,npfkey,4)
          call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -      keyno,key1,1)
          if (keyno .gt. 0) iop(47)=keyno-1
          iop47read=iop(47)
          iform(2)=0
          if (iop(47) .eq. 1) iform(2)=1
          if (key .eq. 'READ' .or. key .eq. 'RDEX') then
            call decode(cnfg3,ncnfg3,ndummyu,keyno2,key2,0)
            if (keyno2 .gt. 0) iop(50)=keyno2-1
          else if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
            if (MYRANK .eq. 0) write (iout,2232)
            inperr=inperr+1
            icol=0
            go to 1111
          end if
          if (key .eq. 'RDEX') then
            if (iop(61) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2355)
              inperr=inperr+1
              icol=0
              go to 1111
            end if
            if (key1 .ne. 'PDB ' .and. key1 .ne. 'CHRM') then
              if (MYRANK .eq. 0) write (iout,2360)
              inperr=inperr+1
              icol=0
              go to 1111
            end if
          else if (iop(61) .gt. 0 .and. key .ne. 'READ' .and.
     -       key .ne. 'RANI' .and. key .ne. 'RANC') then
            if (MYRANK .eq. 0) write (iout,2319)
            inperr=inperr+1
          end if
          if (key .eq. 'TRAJ') then
c           Gather config from a trajectory file
            if (ihist .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2081)
              inperr=inperr+1
              icol=0
              go to 1111
            else
              natoms=nstta+(nmolec-1)*nslv
              if (MYRANK .eq. 0) call opentraj(filenames(3),namlens(3),
     -          nstta,nslv,nsvp,c,0,nmolec,numsolv,natoms,nmcstart,
     -          cplpar,iskip1,numrec(3),0,uusfac,edgexyz,ieof,nconnfail)
            end if
            iconfread=2
          else if (key(1:3) .eq. 'RAN') then
            call find('NSLV',1,nmainkey,mainkey,keynoNSLV,4)
            if (mainkeyun(keynoNSLV) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,3008)
              inperr=inperr+1
            end if
            if (iop(33) .gt. 0) then
              rwwina=0.0
              rwwin2=0.0
              iop(33)=0
              if (MYRANK .eq. 0) write (iout,2198)
              nchng=nchng+1
            end if
            call decode(cnfg2,ncnfg2,ndummyu,keyno2,key2,0)
            if (keyno2 .gt. 0) iop(27)=keyno2-1
            call getreal(pmvslt,0,0.0)
            call getreal(pmvslv,0,18.12004)
            call getreal(rnshll,0,2.0)
            call getreal(cplnew,0,0.0)
            call check01int(cplnew,'cplpar',iout,inperr)
            if (iop(30) .eq. 7 .and. cplnew .ne. 0.0) cplpar=cplnew
            if (MYRANK .eq. 0) call fileopen(file,namlenf,filenames(2),
     -        namlens(2),2,0,numrun,1,0,iform(2),iop(24),iversout,
     -        iout,icord,0)
            if (ifilstat(2) .lt. 0) then
              if (MYRANK .eq. 0)
     -          write (iout,2152) filenames(2)(1:namlens(2))
              inperr=inperr+1
              nmolec=2
              numsolv=1
              icol=0
              go to 1111
            end if
            if (iop(5) .eq. 6) then
              if (MYRANK .eq. 0) write (iout,2172)
              inperr=inperr+1
              icol=0
              go to 1111
            end if
          end if
          if (iop(69) .gt. 0 .and.
     -        key .ne. 'READ' .and. key(1:3) .ne. 'RAN') then
c           Cloned solute can only be read or generated randomly
            if (MYRANK .eq. 0) write (iout,2089)
            inperr=inperr+1
            icol=0
            go to 1111
          end if
          if (iop(41) .gt. 0 .and. nmolec .lt. 2) then
            if (key(1:3) .eq. 'RAN') then
              nmolec=2
              numsolv=1
              nchng=nchng+1
              if (MYRANK .eq. 0) write (iout,2160)
            end if
          end if
c         natoms: total number of atoms (including pseudoatoms) in the system.
          natoms=nstta+(nmolec-1)*nslv
          call checkdim(ifail,iout,inperr,'MO',nmolec,1,0,0)
          call checkdim(ifail,iout,inperr,'NA',natoms,1,1,0)
          if (iop(26) .eq. 4)
     -      call checkdim(ifail,iout,inperr,'GV',nslv,1,0,0)
          call checkdim(ifail,iout,inperr,'NA',natoms,1,1,0)
          if (key .eq. 'READ' .or. key .eq. 'RDEX') then
            if (icord .gt. 0) then
              call fileclose(icord,0,iop(24),iout)
              write (iout,2296) filenames(2)(1:namlens(2))
            end if
            if (key1 .eq. 'ASAN') then
              itype=11
              itypealt=2
            else if (key1 .eq. 'PDB ') then
              itype=15
              itypealt=2
            else if (key1 .eq. 'CHRM') then
              itype=18
              itypealt=2
            else
              itype=2
              itypealt=0
            end if
            call getint(numrunr,0,1,0)
            if (numrunr .gt. 0) then
              call getint(irunvers,0,1,0)
              idiffread=1
              call getname(filename1,namlen1,0,80)
              if (namlen1 .eq. namlenf) then
                if (filename1(1:namlen1) .eq. file(1:namlenf))
     -            idiffread=0
              else if (namlenf .eq. 0) then
                idiffread=0
              end if
            else
              numrunr=numrun
              namlen1=0
            end if
C@DM              if (MYRANK .eq. 0) then
            if (ifilstat(itype) .ne. 0)
     -        call fileclose(iabs(ifilstat(itype)),
     -          0,iop(24),iout)
            if (namlen1 .gt. 0) then
              call fileopen(filename1,namlen1,filenames(2),namlens(2),
     -          itype,itypealt,numrunr,irunvers,2,iform(itype),iop(24),
     -          iversout,iout,icordr,0)
            else
              call fileopen(file,namlenf,filenames(2),namlens(2),itype,
     -          itypealt,numrunr,1,2,iform(itype),iop(24),iversout,
     -          iout,icordr,0)
            end if
C@DM              end if
            if (iop(61) .gt. 0) then
              nstta0=nstta
              nstta_full0=nstta_full
              natoms0=natoms
            end if
            call readcrd(c,icordr,nmolec,nmol3,numsolv,natoms,nstta,
     -        nstfa,nslv,cplpar,edgexyz,icplp,0,0,0,filenames(2),
     -        namlens(2),0,iout,nwwarn,inperr)
            if (iop(47) .eq. 3) then
c             PDB input - read occupancy and B factor also
              call readcrd(cgs,icordr,nmolec,nmol3,numsolv,nstta+
     -          (nmolec-1)*nslv,nstta,nstfa,nslv,cplp,edgexyz,icp,1,0,
     -          1,filenames(2),namlens(2),0,iout,nwwarn,inperr)
              do is=1,nmolec-1
                frocc1(is)=cgs(1,nstta+(is-1)*nslv+1)
                bfac1(is)=cgs(2,nstta+(is-1)*nslv+1)
              end do
              ifrocc=1
            end if
            irdexsave=0
            if (key .eq. 'RDEX') then
c             Extract the moving part
              natomsr=natoms
              nstta=nstta0
              if (natomsr .ne. nstta_full) then
                if (MYRANK .eq. 0) write (iout,2356) natomsr,nstta_full
                inperr=inperr+1
                icol=0
                go to 1111
              end if
              if (MYRANK .eq. 0) write (iout,2357) nstta0,natoms
              do iaa=1,nstta_full
                ia=isplit_of_orig(iaa)
                if (ia .le. nstta) then
                  if (ia .gt. iaa) then
                    if (MYRANK .eq. 0) write (iout,2358) ia,iaa
                    inperr=inperr+1
                    icol=0
                    go to 1111
                  end if
c                 Moving part
                  call trnsfr(c(1,ia),c(1,iaa),3)
                end if
              end do
              natoms=nstta
c             Save the extracted structure in ASCI format
              if (MYRANK .eq. 0) call fileclose(icordr,0,iop(24),iout)
              itype=2
              call fileopen(file,namlenf,filenames(2),namlens(2),itype,
     -          itypealt,numrun,1,3,iform(itype),iop(24),iversout,
     -          iout,icord,0)
              if (iversout .ne. 1) then
                write (iout,2361)
                inperr=inperr+1
                icol=0
                go to 1111
              end if
              iop(47)=0
              call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,
     -          edgexyz,iop(47),iop(41),iop(90),iop(30),iop(24),
     -          filenames(2),namlens(2),iop(98),0,c)
              irdexsave=1
            end if
            numsolv=nmolec-1
            if (key1 .eq. 'ASCI') then
              if (nrcnfi .lt. 100) then
                nrcnfi=nrcnfi+1
                nruncnfi(nrcnfi)=numrunr
              else
                if (MYRANK .eq. 0) write (iout,2132)
                nwwarn=nwwarn+1
              end if
            end if
            if (numrunr .ne. numrun .or. namlen1 .gt. 0) then
              nfound=0
              do il=1,nrcnfi
                if (nruncnfi(il) .eq. numrun) nfound=1
              end do
              if (nfound .eq. 0 .or. idiffread .eq. 1) then
                if (MYRANK .eq. 0) call fileclose(icordr,0,iop(24),iout)
                if (iop(47) .gt. 1) then
                  if (MYRANK .eq. 0) write (iout,2186)
                  iop(47)=0
                end if
C@DM                if (MYRANK .eq. 0) then
                if (ifilstat(2) .ne. 0)
     -            call fileclose(iabs(ifilstat(2)),0,iop(24),iout)
                call fileopen(file,namlenf,filenames(2),namlens(2),2,0,
     -            numrun,1,0,iform(2),iop(24),iversout,iout,icord,0)
                call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,
     -            edgexyz,iop(47),iop(41),iop(90),iop(30),iop(24),
     -            filenames(2),namlens(2),iop(98),0,c)
C@DM                end if
              else
                if (MYRANK .eq. 0)
     -            write (iout,2133) filenames(2)(1:namlens(2))
                nwwarn=nwwarn+1
                icord=icordr
              end if
            else
              if (irdexsave .eq. 0) icord=icordr
            end if
          else
            if (iop(41) .eq. 0) then
c             Canonical (T,V,N) ensemble
              if (key(1:2) .eq. 'RP' .or .key .eq. 'PMFN') then
C@DM                if (MYRANK .eq. 0) write (iout,2300) '***** ERROR:',
C@DM     -            'the CNFG RP** and CNFGs allowed with MPI for now'
C@DM                inperr=inperr+1
C@DM                icol=0
C@DM                go to 1111
                call fileopen(file,namlenf,filenames(2),namlens(2),2,0,
     -            numrun,1,0,iform(2),iop(24),iversout,iout,icord,0)
                call getint(numrunr,1,1,0)
                if (numrunr .eq. numrun) then
                  write (iout,2084) numrunr,numrun
                  inperr=inperr+1
                  icol=0
                  go to 1111
                end if
                call getname(filename1,namlen1,1,80)
                call fileopen(filename1,namlen1,filename2,namlen2,13,0,
     -            numrunr,1,2,iform(2),iop(24),iversout,iout,icordo,0)
                write (iout,2074) filename1(1:namlen1)
                if (key(1:2) .eq. 'RP') then
                  call getint(noslt,1,1,0)
                  if (key .eq. 'RPSU') call
     -              chaslt(0,icordo,noslt,filename1,namlen1,cgs,c,crm)
                  if (key .eq. 'RPUU') call
     -               chaslt(1,icordo,noslt,filename1,namlen1,cgs,c,crm)
                  if (key .eq. 'RPUV') then
                    call getint(noslv,1,1,0)
                    call getint(i37o,1,1,0)
                    call chstsv(icordo,noslt,noslv,iop37o,cgs,
     -                orient,c,crm,filename1,namlen1)
                  end if
                else
                  call getint(nstfa0new,1,1,0)
                  call getreal(cplparo,1,0.0)
                  call check01int(cplparo,'cplpar',iout,inperr)
                  call crtpij(icordo,cplparo,nstfa0new,cgs,c,crm,
     -              file,namlen)
                end if
                call fileclose(icordo,0,iop(24),iout)
              end if
              if (key .eq. 'RANC') call rancnf(0,0,orient,c,crm,
     -          filenames(2),namlens(2),MYRANK)
              if (key .eq. 'RANI') call rancnf(1,0,orient,c,crm,
     -          filenames(2),namlens(2),MYRANK)
            else
c             Grand-canonical (T,V,N) ensemble
              if (key .eq. 'RANC') call rancnf(0,1,orient,c,crm,
     -          filenames(2),namlens(2),MYRANK)
              if (key .eq. 'RANI') call rancnf(1,1,orient,c,crm,
     -          filenames(2),namlens(2),MYRANK)
            end if
          end if
c         Find out if there are fixed solute atoms
          call trnsfi(l1,iclslt,nstta)
          if (iop(30) .ge. 7) then
            call zeroiti(l1,nstfa1,nstfa)
            nstlook=nstfa1
          else
            nstlook=nstta
          end if
          nfixed=0
          do ia=1,nstlook
            if (isltmv(ia) .eq. 0) nfixed=nfixed+1
            if (isltmv(ia) .gt. 0) l1(ia)=0
          end do
c         If there are no fixed solute atoms, use all (except 3rd FE copy)
          if (nfixed .eq. 0 .and. nstta .gt. 0) then
            call trnsfi(l1,iclslt,nstlook)
            write (iout,2085)
            nwarn=nwarn+1
          end if
c         Repeat rlcslt determination if needed
          if (iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4)
     -      call grelcd(cslt,rlcslt,l1,nstta,0)
          if (idebug(9) .gt. 0) write (iout,7511)
     -      nstta,nsttg,nstfa0,nstfg0,nstfa1,nstfg1,nstfa,nstfg,
     -        (ia,(cslt(k,ia),k=1,3),(rlcslt(k,ia),k=1,3),ia=1,nstta)
c         Get solute COM here
          call cofms(c,crm,l1,1,nstta,0,wx)
          if (ntang .gt. 0) then
            if (ntorlim .gt. 0) then
c             Get the reference torsion angles from cslt
              call trnsfr(ta0,dih0,ntorpmf)
              call findtangles(0,ntang,itangindx,iprecursor,nrot,
     -          irotlist,irotlinc,iquata,cslt,dih0,tangd,sindela,
     -          cosdela,0,1,idebug(21),iout,nwarn,inperr,#TR,#ST)
              call trnsfr(dih0,ta0,ntorpmf)
            end if
c           Find the torsion angles in the starting config
            if (iop(30) .ge. 1 .and. iop(30) .le. 3)
     -        call trnsfr(c,rlcslt,3*nstfa)
            call findtangles(0,ntang,itangindx,iprecursor,nrot,irotlist,
     -        irotlinc,iquata,c,dihang,tangd,sindela,cosdela,0,2,
     -        idebug(21),iout,nwarn,inperr,#TR,#ST)
c           Save the starting value of the variable torsion angles into ta0
            call trnsfr(ta0,dihang,ntang)
          end if
          if (iop(30) .eq. 7) then
c           Transformed solute
            if (iop(18) .eq. 3 .or. iop(18) .eq. 5) then
c             Determine the center of the two limiting states
              call trnsfr(crm2nd0,c(1,icent1-nstfa1),3)
              call trnsfr(crm2nd1,c(1,icent1-nstfa0),3)
            end if
c           Find cplpar if not found on unit icord or check third solute
            call checkcpl(0,c,crm,nstfa0,iclslt,isltmv,cplparn,
     -        nerr,2,MYRANK)
            if (icplp .eq. 1) then
              if (abs(cplpar-cplparn) .gt. 0.001) then
                write (iout,2190) cplpar,cplparn,
     -            filenames(2)(1:namlens(2))
              end if
            end if
            cplpar=cplparn
          end if
          if (iop(30) .ge. 7) then
            if (iop(18) .ne. 4 .or. ntang .gt. 0) then
              call arrdiff(crmslt,cslt,rlcslt,3)
              call lincmb(cslt,crmslt,cplpar,0,qslt,nstfa0)
              call lincmb(rlcslt,crm00,cplpar,0,qslt,nstfa0)
            else
              write (iout,2002)
              inperr=inperr+1
            end if
          end if
          if (iop(35) .eq. 2) then
c           Prepare the appropriate l.c. of the solute on unit icord as well
            if (uscpo0 .eq. 0.0 .and. uscpo1 .eq. 0.0) then
              uscpo0=0.0
              uscpo1=1.0
            end if
            usp0=(uspro0-uscpo0)/(uscpo1-uscpo0)
            usp1=(uspro1-uscpo0)/(uscpo1-uscpo0)
            call lincm2(c,3,#NA,nstfa0,3,usp0,usp1)
            write (iout,2032) filenames(2)(1:namlens(2)),
     -        usp0,usp0,usp1,usp1
            if (uscpo0 .ne. 0.0 .or. uscpo1 .ne. 1.0)
     -        write (iout,2033) filenames(2)(1:namlens(2)),
     -          uscpo0,uscpo0,uscpo1,uscpo1
            call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -        iop(47),0,iop(90),iop(30),iop(24),filenames(2),namlens(2),
     -        iop(98),0,c)
          end if
          if (iop(30) .eq. 8)
     -      call lincmb(c,crm,cplpar,0,qslt,nstfa0)
          if (idebug(158) .eq. 0)
     -      call checkwayout(nmolec,nslv,islvrep,iop(5),
     -        iout,iop(24),nsltout,nslvout,nwwarn)
          ignorehs=0
          if (iconfread .eq. 0) iconfread=1
          iconffilt=0
          if (iop(121) .eq. 1) then
            call trnsfr(covref,c,3*nstta)
            icrefok=1
          end if
          if (iop(128) .gt. 0) call bondcheck(iout,1,nstta,ianslt,nneig,
     -      ineig,c,labslt,nmake,nwarn,nwwarn,inperr,#NL)
c         Get the grid-forming atoms into c if constraints are used
          if (iop(61) .gt. 0 .and. iop(117) .gt. 0)
     -      call trnsfr(c(1,nstta+1),cslt(1,nstta+1),
     -        3*(nstta_full-nstta))
C@DM          nmolmx_gce=nmolec
C@DM          if (iop(15) .eq. 0) then
C@DM            if (nslvxp .gt. nmolec) nmolmx_gce=nslvxp+1
C@DMc           Increase the expected number of solvents slightly
C@DM            nmolmx_add=nmolmx_gce+10.0*sqrt(100./float(nmolmx_gce))
C@DM            if (nmolmx_add .ge. #MO) then
C@DM              nmolmx_add=#MO-1
C@DM              write (iout,2294) 'MO'
C@DM              nwarn=nwarn+1
C@DM            end if
C@DM          else
C@DM            nmolmx_add=nmolmx_gce
C@DM          end if
C@DM          if (MYRANK .eq. 0) write (iout,2293) nmolmx_gce-1
C@DM          call setlim(2,nmolmx_add,NUMNOD,iflslv,icpuslv,MYRANK,iout,
C@DM     -      MAXNOD,iop(24),'solvent')
C@DM          lastcpuuse=icpuslv(nmolec)
C@DM          iflslv(2,lastcpuuse)=nmolec
C@DM          if (lastcpuuse .lt. NUMNOD) then
C@DM            do icpu=lastcpuuse+1,NUMNOD
C@DM              iflslv(2,icpu)=iflslv(1,icpu)-1
C@DM            end do
C@DM          end if
C@DM          call setdispl(lastcpuuse,iflslv,1,ndisplslv,ncountslv,1,
C@DM     -      MAXNOD)
C@DM          call setdispl(lastcpuuse,iflslv,3,ndisplslv3,ncountslv3,3,
C@DM     -      MAXNOD)
        else if (key0 .eq. 'SCRM') then
          call scrambletor(c,nsttm,iout)
        else if (key0 .eq. 'CMPC') then
c---------Compare two solute conformations
          iop(47)=keyno-1
          call decode(cmpc,ncmpc,ndummyu,keyno1,key1,1)
          if (key1 .eq. 'SHRT' .and. iop(58) .eq. 0) then
            key1='SHON'
            write (iout,2134)
            nchng=nchng+1
          end if
          call decode(cmpc1,ncmpc1,ndummyu,keyno2,key2,1)
          call getint(numrun1,1,1,0)
          call getint(numrun2,1,1,0)
          call getint(numrund,1,1,0)
          numrunw1=numrun1+numrund
          numrunw2=numrun2+numrund
          call getint(ix1,1,1,0)
          call getreal(dx1,1,0.0)
          call getint(ix2,1,1,0)
          call getreal(dx2,1,0.0)
          call getint(numshow,0,0,nsttm)
          if (ix1 .eq. ix2 .or. ix1 .gt. 3 .or. ix2 .gt. 3) then
            write (iout,2212) ix1,ix2
            inperr=inperr+1
          else
            ix3=1
            do while (ix3 .eq. ix1 .or. ix3 .eq. ix2)
              ix3=ix3+1
            end do
            write (iout,2128) lxyz(ix1),lxyz(ix2),lxyz(ix3)
          end if
          if (key2 .eq. 'LIPI') then
            call getint(ixflip,0,1,ix1)
            call getint(lipfst,0,1,1)
            call getint(liplst,0,1,nsttm)
          end if
          icrdform=0
          if (key .eq. 'BNRY') icrdform=1
          itypealt=0
          if (key .eq. 'PDB ') itypealt=15
          if (key .eq. 'CRD ') itypealt=18
          call fileopen(file,namlenf,filename1,namlen1,2,itypealt,
     -      numrun1,1,2,icrdform,iop(24),iversout,iout,icord1,0)
          call readcrd(c,icord1,nmolec,nmol3,numsolv,nstta,nstta,nstfa,
     -      nslv,cplpar,edgexyz,icplp,1,0,0,filename1,namlen1,0,iout,
     -      nwwarn,inperr)
          call fileclose(icord1,0,iop(24),iout)
          call fileopen(file,namlenf,filename2,namlen2,2,itypealt,
     -      numrun2,1,2,icrdform,iop(24),iversout,iout,icord2,0)
          call readcrd(cgs,icord2,nmolec,nmol3,numsolv,nstta,nstta,
     -      nstfa,nslv,cplpar,edgexyz,icplp,1,0,0,filename2,namlen2,
     -      0,iout,nwwarn,inperr)
          call fileclose(icord2,0,iop(24),iout)
          write (iout,2144) filename1(1:namlen1),filename2(1:namlen2)
          call zeroit(center,3)
          maxdev=1
          if (numshow .lt. 0) then
c           If numshow is negitive, show the -numshow least moved molecs
            maxdev=-1
            numshow=-numshow
          end if
          rows=numshow
          rows=sqrt(rows)
          nrows=rows
          if (nrows .lt. 1) nrows=1
          rmsd=0.0
          rmsdmin=100000.
          rmsdmax=0.0
          do im=1,nsttm
            if (key1 .eq. 'ALLD' .or. key1 .eq. 'NOSH') then
              call arrdiff(cx,cgs(1,molcnt(im)),c(1,molcnt(im)),3)
              call trnsfr(cm,cx,3)
              call pbcnd(cx(1),cx(2),cx(3),iop(5),iopt,riijj)
              if (idebug(54) .gt. 0) write (iout,7512) im,cm,cx
            end if
            if (key1 .eq. 'SHRT') then
              im0=1
              if (im .gt. 1) im0=natfix(im-1)+1
              nrootused=natfix(im)-im0+1
              call getort(c(1,ifirstm(im)),c(1,molcnt(im)),
     -          iclslt(ifirstm(im)),cgs(1,ifirstm(im)),natfix(im)-im0+1,
     -          ort,0,iroots(im0),ifirstm(im)-1,linear,1,0,ixrep3slt,
     -          nrep3slt,ifail,idebug(29),iout,natoms)
              call ckortfail(ifail,'input configuration',19,im,0,0,
     -          inperr,iout)
              call rot_trans(ort,cgs(1,ifirstm(im)),c(1,molcnt(im)),
     -          cgs(1,ifirstm(im)),(ilastm(im)-ifirstm(im)+1))
            end if
            call arrdiff(cc,center,c(1,molcnt(im)),3)
            call arrdiff(cm,center,cgs(1,molcnt(im)),3)
            if (idebug(54) .gt. 0) write (iout,7513) im,cc,cm
            if (key1 .eq. 'ALLD' .or. key1 .eq. 'NOSH')
     -        call arrsum(cm,cm,cx,3)
              if (idebug(54) .gt. 0) write (iout,7514) im,cm
            dsqm=0.0
            do ia=ifirstm(im),ilastm(im)
              call arrsum(c(1,ia),c(1,ia),cc,3)
              call arrsum(cgs(1,ia),cgs(1,ia),cm,3)
              do k=1,3
                dsqm=dsqm+(c(k,ia)-cgs(k,ia))**2
              end do
            end do
            indexx(im)=im
            dsqm=sqrt(dsqm)
            cv1(im)=dsqm
            rmsd=rmsd+dsqm
            if (rmsdmin .ge. dsqm) rmsdmin=dsqm
            if (rmsdmax .le. dsqm) rmsdmax=dsqm
            if (idebug(54) .gt. 0) write (iout,7515) im,dsqm
          end do
          rmsd=rmsd/nsttm
          write (iout,2135) rmsd,'all',rmsdmin,rmsdmax
c         Sort by RMSD
          call mrgsrt(iout,indexx,cv1,nsttm,ixnear,indexn,ivtm,cv2,
     -      #UV)
          rmsd=0.0
          rmsdmin=100000.
          rmsdmax=0.0
          nacop=0
          imf=1
          iml=nsttm
          if (maxdev .eq. 1) imf=nsttm-numshow+1
          if (maxdev .eq. -1) iml=numshow
          do imm=imf,iml
            im=indexx(imm)
            imc=imm-imf+1
            center(ix1)=dx1*mod(imc-1,nrows)
            center(ix2)=dx2*float((imc-1)/nrows)
            if (key2 .eq. 'LIPI' .and.
     -          im .ge. lipfst+(liplst-lipfst+1)/2) then
c             Flip lipid
              do ia=ifirstm(im),ilastm(im)
                c(ixflip,ia)=-c(ixflip,ia)
                cgs(ixflip,ia)=-cgs(ixflip,ia)
              end do
            end if
            do ia=ifirstm(im),ilastm(im)
              call arrsum(c(1,ia),c(1,ia),center,3)
              call arrsum(cgs(1,ia),cgs(1,ia),center,3)
            end do
            if (numshow .lt. nsttm) then
              dsqm=cv1(imm)
              rmsd=rmsd+dsqm
              if (rmsdmin .ge. dsqm) rmsdmin=dsqm
              if (rmsdmax .le. dsqm) rmsdmax=dsqm
c             Copy contents of C and cgs to form a contiguous stretch
              nncop=(ilastm(im)-ifirstm(im)+1)
              call trnsfr(c1(1,nacop+1),c(1,ifirstm(im)),3*nncop)
              call trnsfr(trqng(1,nacop+1),cgs(1,ifirstm(im)),3*nncop)
              nacop=nacop+nncop
            end if
          end do
          nsttap=nstta
          if (numshow .lt. nsttm) then
            rmsd=rmsd/numshow
            if (maxdev .eq. 1)
     -        write (iout,2135) rmsd,'top',rmsdmin,rmsdmax
            if (maxdev .eq. -1)
     -        write (iout,2135) rmsd,'bottom',rmsdmin,rmsdmax
            nsttap=nacop
            call trnsfr(c,c1,3*nsttap)
            call trnsfr(cgs,trqng,3*nsttap)
          end if
          ifound=0
          do i=1,nurefc
            if (iurefc(i) .eq. numrunw1) ifound=1
          end do
          if (ifound .eq. 0) then
            call savepdb('PDB ',keycol,iupdb1,iout,1,nsttap,nslv,c,
     -        -1,0,0,1,filename1,namlen1,nmc,2,file,namlenf,numrunw1,
     -        1,0,inperr,nwarn,nwwarn,1,0,nlwr,0,1,#NA)
            if (nurefc .lt. 100) then
              nurefc=nurefc+1
              iurefc(nurefc)=numrun1
            else
              write (iout,2131)
              nwwarn=nwwarn+1
            end if
          end if
          call savepdb('PDB ',keycol,iupdb2,iout,1,nsttap,nslv,cgs,
     -      -1,0,0,1,filename2,namlen2,nmc,2,file,namlenf,numrunw2,1,0,
     -      inperr,nwarn,nwwarn,2,0,nlwr,0,1,#HA)
        else if (key0 .eq. 'REGE') then
c---------Regenerate the solute from torsion angles
          if (nmc .eq. 0) then
            call inicac
            call findor(orient,orientsltm,c,crm,crm0,iconfread,
     -        iop47read)
          end if
          call regenerate(c,0,1,iout,nerr,devmax)
          write (iout,2078) devmax
        else if (key0 .eq. 'SCAL') then
c---------Scale the simulation cell
          call getreal(edgn(1),1,0.0)
          call getreal(edgn(2),0,edgn(1))
          call getreal(edgn(3),0,edgn(1))
          call corscl(edgn,c,file,namlen)
        else if (key0 .eq. 'DSTC') then
c---------Distribution calculation level
          if (key .ne. 'NONE') then
            call decode(dstc,ndstc,ndummyu,keyno,key,1)
            iop(32)=keyno-1
            if (iop(32) .gt. 0)
     -        call fileopen(file,namlenf,filenames(4),namlens(4),4,0,
     -          numrun,1,0,1,iop(24),iversout,iout,idstr,0)
            call disini
          end if
        else if (key0 .eq. 'SENS') then
c---------Sensitivity analyis
          call getint(isensfreq,1,1,0)
          iop(82)=isensfreq
        else if (key0 .eq. 'BNDL') then
c---------Bond list print
          call getint(n1,0,1,1)
          call getint(n2,0,1,nstta)
          if (n1 .gt. n2) then
            write (iout,2158) 'atom',n1,n2
            inperr=inperr+1
          end if
          if (n2 .gt. nstta) then
            write (iout,2264) n2,nstta
            nchng=nchng+1
          end if
          call printbondlist(key,n1,n2,nstta,cslt,nneig,ineig,labslt,
     -      cv1,#NL,rdtodg,nwarn,idebug(24)-1,iout)
        else if (key0 .eq. 'FCGA') then
c---------Functional group analysis  for solute, bond list
          write (iout,2079)
          ierronly=keyno-1
          if (ierronly .gt. 0) write (iout,2149)
          if (iop(30) .le. 2) then
            call fcganal(1,nstfa,ierronly)
          else if (iop(30) .eq. 3) then
c???
            call fcganal(1,nstfa0,ierronly)
          else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
            call fcganal(1,nstfa0,ierronly)
            call fcganal(nstfa0+1,nstfa,ierronly)
          else if (iop(30) .ge. 7) then
            call fcganal(nstfa1+1,nstfa,ierronly)
          end if
          call fcganal(nstfa+1,nstta,ierronly)
        else if (key0 .eq. 'FCGD') then
c---------New group definition
          if (iop(10) .gt. 0) then
            if (iop25prev .gt. 1 .and. iop(25) .gt. 1) then
c             Already collapsed RDF's
              write (iout,2111)
              inperr=inperr+1
            end if
          end if
          if (iop(25) .gt. 0) then
            if (iop(30) .eq. 7 .or. iop(30) .eq. 8) then
              call fcgdef(nstfa1+1,nstta,igrslt,iamolslt)
            else
              call fcgdef(1,nstta,igrslt,iamolslt)
            end if
            if (ncnfpx .gt. 0) then
c             Condense RDFs and QCDFs (already calculated - if any) based on
c             the new FCG info
              call rdfgrp(nsltpx1,nsltpx2,nsltpxgr,indxrdf,indxfg,
     -          ixfg,nfg,icorig,keeppx)
              call collapserdf
c             Update group labels
              call getgrouplabels(nsltpxgr,nsltpx1,nsltpx2,iatnam,
     -          ianslt,labslt,indxrdf,iout,idebug(44))
            end if
          end if
        else if (key0 .eq. 'PRCO') then
c---------Find/print compilation options, sizes
C@DM          if (key .eq. 'SAVE' .or. key .eq. 'SVMN') then
C@DM            write (iout,3009)
C@DM            go to 1111
C@DM          end if
          if (key .eq. 'SAVE') then
            call getint(numrunr,0,1,0)
            if (numrunr .gt. 0) then
              if (numrun .eq. numrunr .and. ichkp .ne. 0) then
                ichkpr=ichkp
                rewind ichkpr
              else
                call fileopen(file,namlenf,filenames(1),namlens(1),
     -            1,0,numrunr,1,2,1,iop(24),iversout,iout,ichkpr,0)
              end if
              read (ichkpr)
              iok=0
              read (ichkpr,end=1096) ncompoptr,icompoptr,nasizer,
     -          iasizer,cmoddater,moddater
              iok=1
1096          call fileclose(ichkpr,0,iop(24),iout)
              if (iok .eq. 1) then
                write (iout,2054) filenames(1)(1:namlens(1))
                call printcomp(iout,icompoptr,ncompoptr,sizesym,
     -            sizename,sizelname,optname,optlname,iasizer,nasizer,
     -            cmoddater,cmoddater,moddater,file,namlenf,nbits,2,1,
     -            nwarn)
              else
                write (iout,2050)
              end if
            else
              call printcomp(iout,icompopt,ncompopt,sizesym,sizename,
     -          sizelname,optname,optlname,iasize,nasize,cmoddate,
     -          cpxmoddate,moddate,file,namlenf,nbits,2,1,nwarn)
            end if
          else if (key .eq. 'SVMN') then
            write (iout,2229)
            if (iconfread .eq. 0) then
              write (iout,2230)
              nwarn=nwarn+1
            end if
            call compmin(nmolec,nbits,nstta,nstfa0,nsttg,nsttm,ifirstm,
     -        ilastm,iltorgrp,iltormovgrgr,nslv,ngrid,ntang,ntorsinp,
     -        ntordrop,ntorgrp,nptd,iclsltt,nsltpx1,nsltpx2,nijgvv,
     -        ngridmap,indxrdf,rk_ddd,rpxdivi,rpxwwdivi,rgpxsltmax,
     -        rgpxwwmax)
            call printcomp(iout,icompopt,ncompopt,sizesym,sizename,
     -        sizelname,optname,optlname,iasize,nasize,
     -        cmoddate,cpxmoddate,moddate,file,namlenf,nbits,2,1,nwarn)
          else
            if (MYRANK .eq. 0)
     -        call printcomp(iout,icompopt,ncompopt,sizesym,sizename,
     -          sizelname,optname,optlname,iasize,nasize,cmoddate,
     -          cpxmoddate,moddate,file,namlenf,nbits,2,0,nwarn)
          end if
        else if (key0 .eq. 'RCKP') then
c---------Read checkpoint file
          call decode(rckp1,nrckp1,ndummyu,keyno,key2,0)
c         Close all open files
          call switchfiles(0,inpt,iout,0)
          numruno=numrun
          iop48=iop(48)
          iop49=0
          iop24=iop(24)
          iop94old=iop(94)
          namlen1=0
          numrunr=0
          if (keyno .gt. 0) then
            iop49=keyno-1
            call getint(numrunr,0,1,0)
            if (numrunr .gt. 0) call getname(filename1,namlen1,0,80)
          end if
          if (numrunr .eq. 0) numrunr=numrun
          if (namlen1 .eq. 0) then
            namlen1=namlenf
            filename1=file
          end if
          ickptype=1
          if (lscratchpath .gt. 0) then
c           Close scratch-disk checkpoint file (if exists)
            if (filenames(1)(1:lscratchpath) .eq.
     -          scratchpath(1:lscratchpath)) then
              call fileclose(ichkp,1,iop(24),iout)
              if (ichkpx .gt. 0) call fileclose(ichkpx,1,iop(24),iout)
            end if
            ickptype=26
          end if
          call fileopen(filename1,namlen1,filenames(ickptype),
     -      namlens(ickptype),ickptype,0,numrunr,1,2,1,iop(24),
     -      iversout,iout,ichkp,0)
          filename2=filenames(ickptype)
          namlen2=namlens(ickptype)
          if (ichkp .gt. 0) then
            ichkpo=ichkp
C@DM        call crstr_mpi
C@ND        call crstr(0)
            ichkp=ichkpo
            write (iout,2018) filename2(1:namlen2),nmc
            filenames(1)=filename2
            namlens(1)=namlen2
            if (numrun .ne. numrunr) then
              write (iout,2126) numrun,numrunr
              call datprt(2)
            end if
            iop(10)=1
            iop(24)=iop24
            iop(48)=iop48
            iop(49)=iop49
            iop25prev=iop(25)
c           See if there are other files to be opened
            call getunitnos(iunitnos,1)
            nferr=0
            iconfread=1
            if (iunitnos(2) .eq. 0) then
              if (iunitnos(3) .gt. 0) iconfread=2
              if (iunitnos(3) .eq. 0) then
                write (iout,2208)
                inperr=inperr+1
              end if
            end if
            do itype=2,10
              ivers=1
              if (itype .eq. 3) ivers=nhstvers
              if (iunitnos(itype) .gt. 0) then
c               Open existing files with their known names
                call fileopen(file,namlenf,filenames(itype),
     -            namlens(itype),-itype,0,numrun,ivers,2,
     -            iform(itype),iop(24),iversout,iout,iunitnos(itype),1)
              end if
              if (iunitnos(itype) .lt. 0) then
                write (iout,2048) filenames(itype)(1:namlens(itype))
                nferr=nferr+1
              end if
            end do
            call getunitnos(iunitnos,0)
            if (lscratchpath .gt. 0 .and. NUMNOD .eq. 1) then
c             Open checkpoint file on the local disk
              call fileclose(ichkp,0,iop(24),iout)
              call fileopen(filename1,namlen1,filenames(1),
     -          namlens(1),1,1,numrunr,1,1,1,iop(24),iversout,iout,
     -          ichkp,0)
              call csave(ichkp,0,inperr,1)
            end if
            if  (nferr .gt. 0) call datprt(nferr+1)
            if (MYRANK .eq. 0 .and.
     -         iop(94) .eq. 4 .and. ickpok .eq. 0) then
c             Open 'last good' checkpoint file
              call fileopen(file,namlenf,filenames(14),
     -          namlens(14),14,0,99,1,0,1,iop(24),iversout,iout,
     -          ickpok,0)
            end if
            if (iop(159)+iop(160) .gt. 0) then
c             Read proximity checkpoint file
              if (ichkpx .gt. 0) then
                if (NUMNOD .eq. 1) then
                  call crstrpx(0)
                else
C@DM                  do icpu=0,NUMNOD-1
C@DM                    call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM                    if (icpu .eq. MYRANK) then
C@DM                      call crstrpx(1)
C@DM                      if (MYRANK .gt. 0) call mpi_resetpx
C@DM                    end if
C@DM                  end do
                end if
                if (MYRANK .eq. 0)
     -            write (iout,2024) filenames(6)(1:namlens(6)),nmc
                if (lscratchpath .gt. 0 .and. NUMNOD .eq. 1) then
c                 Open checkpoint file on the local disk
                  call fileclose(ichkpx,0,iop(24),iout)
                  call fileopen(filenames(6)(lscratchpath+1:namlens(6)),
     -              namlens(6)-lscratchpath,filenames(29),namlens(29),
     -              29,0,numrunr,1,2,1,iop(24),iversout,iout,ichkpx,0)
                  call csavepx(ichkpx,0,inperr,6)
                end if
              end if
            end if
          end if
          if (iop(30) . eq. 7 .and. iop(51) .ge. 1)
     -      call checkdim(ifail,iout,inperr,'WI',iterw+1,0,0,0)
          ickpread=1
          ignorehs=0
          if (iop(48) .eq. 1 .or. iop(48) .eq. 3) then
            iop(94)=iop(48)
            write (iout,2371) key0
          end if
        else if (key0 .eq. 'RMCK') then
c---------Remove checkpoint file(s) of the previus RUNS or SCAN
          call getint(numrunp,0,0,numrun-2)
          if (numrunp .lt. 0) numrunp=numrun+numrunp
          call fileopen(file,namlenf,filename1,namlen1,
     -      26,0,numrunp,1,0,1,iop(24),iversout,iout,ichkpd,0)
          if (ifilstat(26) .gt. 0) then
            write (iout,2165) 'C',numrunp
            nwwarn=nwwarn+1
          else
            write (iout,2166) 'C',numrunp
          end if
          call fileclose(ichkpd,1,iop(24),iout)
          if (iop(159) .gt. 0 .or. iop(160) .gt. 0) then
            call fileopen(file,namlenf,filename1,namlen1,
     -        29,0,numrunp,1,0,1,iop(24),iversout,iout,ichkpxd,0)
            if (ifilstat(29) .gt. 0) then
              write (iout,2165) 'Proximity c',numrunp
              nwwarn=nwwarn+1
            else
              write (iout,2166) 'Proximity c',numrunp
            end if
            call fileclose(ichkpxd,1,iop(24),iout)
          end if
        else if (key0 .eq. 'WCNF') then
c---------Write out configuration
          if (MYRANK .gt. 0) go to 1111
          instant=0
          itypew=2
          filename1=filenames(2)
          namlens1=namlens(2)
          if (key(1:3) .eq. 'PDT') then
            key(3:3)='B'
            iusetab=1
            if (ipxdiff .eq. 0) then
              write (iout,2121)
              nwwarn=nwwarn+1
            end if
          else
            iusetab=0
          end if
          if (key .eq. 'PDBG' .or. key .eq. 'PDBD' .or.
     -        key .eq. 'CHRD') then
            ncols=2
            if (key .eq. 'CHRD') ncols=1
            do ic=1,ncols
              call decode(pdbg,npdbg,ndummyu,keycol(ic),key3,1)
              if (keycol(ic) .gt. ntabcol .and.
     -            keycol(ic) .le. npxcol) then
                if (nsltpxgr .ne. nsltpx2-nsltpx1+1) then
                  write (iout,2117) key3
                  nwarn=nwarn+1
                end if
              end if
              if ((keycol(ic) .eq. npxcol+3 .or.
     -           keycol(ic) .eq. npxcol+4) .and. iop(42) .eq. 0) then
                write (iout,2236) keycol(ic)
                call zeroiti(idproxacc,0,4*nstta_full)
                nwarn=nwarn+1
              end if
              if (ic .eq. 1) then
                key2=key3
              else
                if (key2 .eq. key3) then
                  write (iout,2095) key2
                  nwarn=nwarn+1
                end if
              end if
              if (ncnfpx .eq. 0 .and. keycol(ic) .le. npxcol) then
                write (iout,2096)
                nwarn=nwarn+1
              end if
            end do
            keyno1=1
          else
            call decode(wcnf,nwcnf,ndummyu,keyno1,key1,0)
            key2='    '
            key3='    '
          end if
          nstta_full_orig=nstta_full
          nstta_save=nstta
          nstta_prt=nstta
          if (key1 .eq. 'FULL') then
            if (iop(61) .eq. 0) then
              write (iout,2320)
              nchng=nchng+1
              key1='UNCH'
              keyno1=1
            else
              nstta=nstta_full
              natoms=nstta
              write (iout,2321)
              call trnsfr(trqng,c,3*nstta_full)
              call reassemble(nstta_save,nstta_full,crmgs,c,cslt,
     -          isplit_of_orig)
              call trnsfr(c,crmgs,3*nstta_full)
              nstta_prt=nstta_full
              iop(61)=2
            end if
c           write (77,9767) 'FULL',nstta,nstta_full,nstta_prt,
c    -          (i,(c(k,i),k=1,3),i=1,nstta_full)
          end if
c         write (78,9767) 'SPLIT',nstta,nstta_full,nstta_prt,
c    -          (i,(c(k,i),k=1,3),i=1,nstta)
c9767 format(1x,a,' NSTTA,NSTTA_FULL_prt=',3i5,/,(i5,3f10.4))
          call getint(numrunw,0,1,0)
          if (key2(1:3) .eq. 'CRC' .or. key3(1:3) .eq. 'CRC') then
            call getreal(rcrcv,0,6.0)
            call sltrad(rsphi,ianslt,nstta_full,rcrcv,1,1,1.0,1.0,2)
            nohyd=0
            if (key2 .eq. 'CRCH' .or. key3 .eq. 'CRCH') nohyd=1
            call circularvar(c,ianslt,c,1,nstta_full,1,nstta,rsphi,
     -        aby,abz,rcrcv,nohyd,0,iout)
            if (nmc .eq. 0) then
              call inicac
              call findor(orient,orientsltm,c,crm,crm0,iconfread,
     -          iop47read)
            end if
            call circularvar(c,indexx,crm,1,nstta_full,2,nmolec,rsphi,
     -        aby,texng,rcrcv,0,0,iout)
          end if
          if (numrunw .gt. 0 .or. key .eq. 'ASAN' .or.
     -      key(1:3) .eq. 'PDB' .or. key(1:3) .eq. 'CHR' .or.
     -      key .eq. 'AMBT' .or. key .eq. 'ASCI') then
            iformw=0
            if (key .eq. 'BNRY') iformw=1
            itypew=27
            if (key .eq. 'ASCI') itypew=2
            if (key .eq. 'AMBT') itypew=35
            if (key .eq. 'ASAN') itypew=11
            if (key(1:3) .eq. 'PDB') itypew=24
            if (key(1:3) .eq. 'CHR') itypew=25
            if (numrunw .eq. 0) numrunw=numrun
            iversw=1
            if (ifilstat(itypew) .ne. 0) then
              write (iout,2362)
              iversw=2
              nwarn=nwarn+1
              call fileclose(iabs(ifilstat(itypew)),0,iop(24),iout)
            end if
            call fileopen(file,namlenf,filename1,namlens1,itypew,
     -        0,numrunw,iversw,3,iformw,iop(24),iversout,iout,iconfw,0)
          else
            iconfw=icord
            filename1=filenames(2)
            namlens1=namlens(2)
          end if
          igce=iop(41)
          if (keyno1 .gt. 1) then
            if (ifilstat(1) .eq. 0)
     -        call fileopen(file,namlenf,filenames(1),namlens(1),1,0,
     -          numrun,1,0,1,iop(24),iversout,iout,ichkp,0)
            call csave(ichkp,1,inperr,1)
          end if
          if (key1 .eq. 'NOSV') then
            nmolec=1
            numsolv=0
            natoms=nstta_full
            write (iout,2226)
          end if
          nwr=natoms
          if (key1 .eq. 'SW23') then
c...........Toggle between 2-slt and 3-slt
            if (key(1:3) .eq. 'PDB' .or. key(1:3) .eq. 'CHR') then
              write (iout,2129) key(1:3)
              key='ASCI'
              nwarn=nwarn+1
            end if
            if (iop(30) .le. 4) then
              inperr=inperr+1
              write (iout,2014)
            else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
c             Add third solute  - simply shift atoms in c
c             First make room for the third solute copy in c
              call trnsfr(cgs,c(1,nstfa+1),3*(natoms-nstfa))
c             Call to lincmb creates the third solute at cplplt
              call lincmb(c,crm,cplpar,0,qslt,nstfa0)
              nwr=natoms+nstfa0
              call trnsfr(c(1,nstfa+1),cgs,3*(natoms-nstfa))
              write (iout,2015) cplpar
            else if (iop(30) .ge. 7) then
c             Remove third solute
              call trnsfr(cgs,c(1,nstfa+1),3*(natoms-nstfa))
              call trnsfr(c(1,nstfa1+1),cgs,3*(natoms-nstfa))
              nwr=natoms-nstfa0
              write (iout,2016)
            end if
          else if (key1 .eq. 'CENT') then
c...........Center the solute in the simulation box
            call systemcent(crm,c,zv,d0,nstta_full,nmolec,iop(5),nslvi,
     -        ianslt,ianslv,ic00,1)
            write (iout,2028) d0
          else if (key1 .eq. 'TRRT' .or. key1 .eq. 'RTTR') then
c...........Translate/rotate the system
            do k=1,3
              call getreal(cx(k),1,0.0)
            end do
c           Read matrix row by row
            do i=1,3
              do j=1,3
                call getreal(ort(i,j),1,0.0)
              end do
            end do
            call checkort(ort,iout,inperr,nwarn,'input')
            if (key1 .eq. 'RTTR') then
c             Rotate first, translate next
              write (iout,2234) ort
              write (iout,2233) cx
              call rot_trans(ort,c,cx,c,natoms)
            else
c             Translate first, rotate next
              write (iout,2233) cx
              write (iout,2234) ort
              call trans_rot(ort,c,cx,c,natoms,1.0,0)
            end if
          else if (key1 .eq. 'PRET') then
c...........Translate/rotate the system with pretransformation data
            if (ipretrans .eq. 0) then
               write (iout,2235)
               inperr=inperr+1
            else if (ipretrans .eq. 1) then
              write (iout,2233) preshift
              write (iout,2234) ((prerot(i,k),k=1,3),i=1,3)
              call trans_rot(prerot,c,preshift,c,natoms,1.0,0)
            else if (ipretrans .eq. 2) then
              write (iout,2234) ((prerot(i,k),k=1,3),i=1,3)
              write (iout,2233) preshift
              call rot_trans(prerot,c,preshift,c,natoms)
            end if
          else if (key1 .eq. 'MLCT') then
c...........Extract solute molecule centers
            do im=1,nsttm
              call trnsfr(c(1,im),c(1,molcnt(im)),3)
              iamolslt(im)=im
              ianslt(im)=ianslt(molcnt(im))
              igrslt(im)=im
              qslt(im)=qslt(molcnt(im))
              labslt(1,im)=labslt(1,molcnt(im))
              labslt(2,im)=labslt(2,molcnt(im))
              molcnt(im)=im
            end do
            nstta=nsttm
            nmolec=1
            numsolv=0
            natoms=nsttm
          else if (key1(1:3) .eq. 'REP') then
c...........Extend system with periodic replicas
            write (iout,2154)
            call find('PBCN',1,nmainkey,mainkey,keypbc,4)
            if (mainkeyun(keypbc) .eq. 0) then
              write (iout,2155)
              inperr=inperr+1
              go to 1112
            end if
            if (iop(5) .eq. 5 .or. iop(5) .eq. 6) then
              write (iout,2156)
              inperr=inperr+1
              go to 1112
            end if
            if (key .eq. 'PDBO' .and. ifrocc .eq. 0) then
              write (iout,2231)
              key='PDB '
              nchng=nchng+1
            end if
            if (key .eq. 'ASCI' .or. key .eq. 'PDB ' .or.
     -          key .eq. 'PDBO' .or. key .eq. 'PDBQ' .or.
     -          key .eq. 'ASAN' .or. key .eq. 'CHRM') then
              instant=1
            else
              write (iout,2171)
              inperr=inperr+1
              go to 1112
            end if
            ncellslt=ncell
            if (key1 .eq. 'REP0') ncellslt=1
            ifpass(1)=1
            if (nsltpardis .ne. 0 .and. ncellslt .gt. 1) then
c             Group fixed and moving solute atoms separately
              npass=2
              if (movatf .eq. 1) ilpass(1)=movatl
              if (movatf .ne. 1) ilpass(1)=movatf-1
              ifpass(2)=ilpass(1)+1
            else
              npass=1
            end if
            ilpass(npass)=nstta_full
            natomsp=(natoms-nstta_full)*ncell+nstta_full
            keyfm=keyno-1
            if (key .eq. 'ASAN') then
              write (iconfw,1003) natomsp
            else if (key .eq. 'CHRM') then
              write (iconfw,1011) (ident(i)(1:76),i=1,nlident)
              write (iconfw,1014) natomsp
              keyfm=4
            else if (key .eq. 'PDBQ') then
              write (iconfw,1010) 1
              keyfm=3
            end if
            ia0=0
            iamolslt0=0
            igrslt0=0
            atname='    '
            segid='CHRM'
            do ipass=1,npass
              do ic=1,ncellslt
                do ia=ifpass(ipass),ilpass(ipass)
                  i0ia=ia0+ia-ifpass(ipass)+1
                  i0im=iamolslt0+ia-ifpass(ipass)+1
                  call arrdiff(cx,c(1,ia),cic(1,ic),3)
                  igrsltp=igrslt0+igrslt(ia)-igrslt(ifpass(ipass))+1
                  if (iop(90) .gt. 0) segid=fcglab(ia)(5:8)
                  call writeat(keyfm,iconfw,cx,i0ia,igrsltp,
     -              iamolslt(ia),labslt(2,ia),labslt(1,ia),segid,
     -              iatnam(ianslt(ia)),iop(98),vdw(ianslt(ia)),
     -              qslt(ia))
                end do
                ia0=ia0+(ilpass(ipass)-ifpass(ipass)+1)
                iamolslt0=iamolslt0+
     -            iamolslt(ilpass(ipass))-iamolslt(ifpass(ipass))+1
                igrslt0=igrslt0+
     -            igrslt(ilpass(ipass))-igrslt(ifpass(ipass))+1
              end do
            end do
            if (natoms .gt. nstta_full) then
              segid='SOLV'
              do ic=1,ncell
                iw=0
                do ia=1,natoms-nstta_full
                  call arrdiff(cx,c(1,nstta_full+ia),cic(1,ic),3)
                  iaw=mod(ia+1,nslv)+1
                  iw=(ia-1)/nslv+1
                  call writeat(keyfm,iconfw,cx,ia0+ia,igrsltp+iw,
     -              0,labslv(iaw),namslv,iatnam(ianslv(iaw)),segid,
     -              iop(98),vdw(ianslv(iaw)),qslv(iaw))
                end do
                ia0=ia0+(natoms-nstta_full)
                igrsltp=igrsltp+iw
              end do
            end if
          else if (key1 .eq. 'PXSR' .or. key1 .eq. 'SPSR') then
c...........Reorder solvents
            if (nmolec .le. 1) then
              write (iout,2221)
              nwarn=nwarn+1
            else if (key1 .eq. 'PXSR') then
              write (iout,2224) 'non-proximal to selected solute atoms'
            else if (key1 .eq. 'SPSR') then
              write (iout,2224) 'outside a user-specified sphere'
            end if
            call trnsfr(cgs(1,nstta_full+1),c(1,nstta_full+1),
     -        3*nslv*(nmolec-1))
            call zeroiti(l4,1,nmolec)
            if (key1 .eq. 'PXSR') then
c             Sort solvents so that the ones non-proximal to selected solutes
c             will be placed first
              nsltpx1=1
              nsltpx2=nstta_full
              call findprox(c,crm,nmolec,edgexyz(1),l1,l2,l3,0,0)
              if (iop(24) .gt. 1) write (iout,2223) (l1(i),i=2,nmolec)
              call readpairlist(nafltrange,iafltrange,50,nstta_full,
     -          'iafltrange','solute atoms to sample','solute atoms',
     -          iout,inperr,nwarn,1,nchng,1,1,1,1)
              do iw=2,nmolec
                do iseg=1,nafltrange
                  if (l1(iw) .ge. iafltrange(1,iseg) .and.
     -                l1(iw) .le. iafltrange(2,iseg)) l4(iw)=1
                end do
              end do
            else
c             Sort solvents so that the ones outside a sphere  will be first
              do k=1,3
                call getreal(center(k),1,0.0)
              end do
              call getreal(rsppx,1,0.0)
              write (iout,2225) rsppx,center
              do iw=2,nmolec
                r2=0.0
                do k=1,3
                  r2=r2+
     -             (center(k)-c(k,nstta_full+(iw-2)*nslv+islvrep))**2
                end do
                if (r2 .le. rsppx**2) l4(iw)=1
              end do
            end if
            nwcop=0
            do iw=2,nmolec
              if (l4(iw) .eq. 0) then
                call trnsfr(c(1,nstta_full+nwcop*nslv+1),
     -            cgs(1,nstta_full+(iw-2)*nslv+1),3*nslv)
                nwcop=nwcop+1
              end if
            end do
            write (iout,2187) nwcop,nmolec-1,nwcop
            if (nwcop .eq. 0) write (iout,2222) 'non-'
            if (nwcop .eq. nmolec-1) write (iout,2222) ' '
            do iw=2,nmolec
              if (l4(iw) .eq. 1) then
                call trnsfr(c(1,nstta_full+nwcop*nslv+1),
     -            cgs(1,nstta_full+(iw-2)*nslv+1),3*nslv)
                nwcop=nwcop+1
              end if
            end do
            if (nwcop .ne. nmolec-1) then
              write (iout,2151) nwcop,nmolec-1
              inperr=inperr+1
            end if
          else if (key1 .eq. 'FIXC') then
c...........Save all solute molecules to correspond precisely to the .slt file
            if (iconfread .eq. 0) then
              write (iout,2153) 'FIXC'
              inperr=inperr+1
              go to 1111
            end if
            if (nmc .eq. 0) then
              call inicac
              call findor(orient,orientsltm,c,crm,crm0,iconfread,
     -          iop47read)
            end if
            do im=1,nsttm
              call trnsfr(center,c(1,molcnt(im)),3)
              call transrotslt(1,1,0.0,cx,im,center,orientsltm,orj,
     -          ifirstm(im),ilastm(im),rlcslt,c,dihang,iout)
            end do
            write (iout,2244)
          end if
          if (key1 .eq. 'SW23' .or. key1 .eq. 'MLCT') then
            mainkeyun(keynocnf)=0
            mainkeyun(keynoslta)=0
            write (iout,2130) key1
          end if
          if (instant .eq. 0) then
            if (key(1:3) .eq. 'PDB' .or. key(1:3) .eq. 'CHR') then
c.............Save a PDB or Charmm CRD file
              if (key(1:3) .eq. 'CHR' .and. natoms .gt. 99999) then
                write (iout,2177) 'configuration',natoms
                inperr=inperr+1
              else
                nocoldatw=0
                if (key .eq. 'PDBD') nocoldatw=1
                call savepdb(key,keycol,iconfw,iout,1,nstta_prt,nslv,c,
     -            0,0,iusetab,1,filename1,namlens1,nmc,0,file,namlenf,
     -            numrunw,1,3,inperr,nwarn,nwwarn,3,nocoldatw,nlwr,0,1,
     -            #NA)
              end if
            else if (key .eq. 'AMBT') then
c.............Save structure as an Amber trajectory
              write (iconfw,1000) ident(1)
              write (iconfw,1005) ((c(k,i),k=1,3),i=1,natoms)
              write (iconfw,1005) edgexyz
            else
              nfound=0
              do il=1,nrcnfi
                if (nruncnfi(il) .eq. numrunw) nfound=1
              end do
              if (nfound .eq. 0) then
                icplp=iop(30)-6
                if (natoms .gt. 99999 .and. keyno .eq. 0) then
                  keyno=1
                  nchng=nchng+1
                  write (iout,2127) natoms
                end if
                call savec(iconfw,iout,nwarn,c,nwr,nmolec,cplpar,
     -            edgexyz,keyno-1,igce,iop(90),iop(30),iop(24),
     -            filename1,namlens1,iop(98),0,c)
              else
                write (iout,2133) filename1(1:namlens1)
                nwwarn=nwwarn+1
              end if
            end if
          end if
1112      if (iconfw .ne. icord)
     -      call fileclose(iconfw,0,iop(24),iout)
          if (key1 .eq. 'FULL') then
            nstta=nstta_save
            call trnsfr(c,trqng,3*nstta_full)
            iop(61)=1
          else if (keyno1 .gt. 1) then
            write (iout,2245) filename1(1:namlens1)
            call crstr(0)
            write (iout,2157)
          end if
        else if (key0 .eq. 'SPRD') then
c---------Generate input for a spread-out image of the solute molecules
          call spreadslt(xyzmax,numrun,numrunw,ifirstm,ilastm,molcnt,c,
     -      center,cgs,nsttm,nstta_full)
          call savepdb('PDB ',keycol,iconfw,iout,1,nstta_full,nslv,cgs,
     -      -1,1,0,1,filename1,namlens1,nmc,1,file,namlenf,numrunw,1,1,
     -      inperr,nwarn,nwwarn,4,0,nlwr,0,1,#HA)
          write (iout,2102) filename1(1:namlens1)
        else if (key0 .eq. 'SCKP') then
c---------Save periodically the checkpoint file with different versionnumbers
          call getint(nsavckpf,1,1,0)
        else if (key0 .eq. 'WCKP') then
c---------Write a checkpoint file
          call getint(numrunw,0,1,0)
          if (numrunw .eq. 0 .or. numrunw .eq. numrun) then
            numrunw=numrun
            ichkpw=ichkp
            ichkpxw=ichkpx
            filename1=filenames(1)
            namlens1=namlens(1)
            filename2=filenames(6)
            nl2=namlens(6)
          else
            call fileopen(file,namlenf,filename1,
     -        namlens1,26,0,numrunw,1,0,1,iop(24),iversout,iout,
     -        ichkpw,0)
            if (iop(162)+iop(176)+iop(144)+iop(172)+iop(178) .gt. 0)
     -        call fileopen(file,namlenf,filename2,nl2,29,0,numrunw,
     -          1,0,1,iop(24),iversout,iout,ichkpxw,0)
          end if
          call csave(ichkpw,0,inperr,9)
          write (iout,2038) ' C',filename1(1:namlens1),nmc
          call fileclose (ichkpw,0,iop(24),iout)
          if (iop(162)+iop(176)+iop(144)+iop(172)+iop(178) .gt. 0) then
            call csavepx(ichkpxw,0,iskipfail,29)
            write (iout,2038) ' Proximity analysis c',
     -        filename2(1:nl2),nmc
            call fileclose (ichkpxw,0,iop(24),iout)
          end if
        else if (key0 .eq. 'VORO') then
c---------Perform Voronoi analysis
          if (iop(5) .ne. 0) then
            write (iout,2146)
            call datprt(2)
          end if
          call decode(filt1,nfilt1,ndummyu,keyno1,key1,1)
          if (keyno1 .eq. 2) then
            write (iout,2147)
            call datprt(2)
          end if
          call decode(pxcr2,2,ndummyu,keyno2,key2,1)
c!!!
          keycol(1)=0+iop(81)
          keycol(2)=0+iop(81)
          call savepdb('PDBD',keycol,iconfw,iout,1,nstta,nslv,cgs,
     -      -1,1,0,1,filename1,namlens1,nmc,1,file,namlenf,numrunw,1,1,
     -      inperr,nwarn,nwwarn,5,0,nlwr,0,1,#HA)
        else if (key0 .eq. 'ENGL') then
c---------Calculate energy components over a trajectory
          call decode(engl,nengl,ndummyu,iexcludetyp,key1,1)
          call decode(engl2,nengl2,ndummyu,iaorg,key2,1)
          datalab='energy component calculation atom  limit'
          datalab(30:34)=aorg(iaorg)
          if (iaorg .eq. 1) then
            maxval=nstta
          else
            maxval=nsttg
          end if
          call getint(iafrst,0,1,1)
          call getint(ialast,0,1,maxval)
          call checklim(ifail,iout,inperr,1,maxval,iafrst,1,datalab,40)
          call checklim(ifail,iout,inperr,1,maxval,ialast,1,datalab,40)
          if (iafrst .gt. ialast) then
            write (iout,2158) aorg(iaorg),iafrst,ialast
            inperr=inperr+1
          end if
          call getint(iafrst2,0,1,1)
          call getint(ialast2,0,1,maxval)
          call checklim(ifail,iout,inperr,1,maxval,iafrst2,1,datalab,40)
          call checklim(ifail,iout,inperr,1,maxval,ialast2,1,datalab,40)
          if (iafrst2 .gt. ialast2) then
            write (iout,2158) aorg(iaorg),iafrst2,ialast2
            inperr=inperr+1
          end if
          if (iaorg .eq. 2) then
            iafrst=ifgrslt(iafrst)
            ialast=ilgrslt(ialast)
            iafrst2=ifgrslt(iafrst2)
            ialast2=ilgrslt(ialast2)
          end if
          call inicac
          call getreal(ctonnb,0,cutuu)
          ctdiff3=(cutuu-ctonnb)**3
          ctonnb2=ctonnb**2
          if (iop(65) .le. 2) then
            write (iout,2214)
            nsttg=nsttm
            do ig=1,nsttg
              igrcnt(ig)=molcnt(ig)
              ifgrslt(ig)=ifirstm(ig)
              ilgrslt(ig)=ilastm(ig)
              do ia=ifgrslt(ig),ilgrslt(ig)
                igrslt(ia)=ig
              end do
            end do
          end if
          if (iop(65) .le. 2 .and. iop(43) .gt. 0) then
            write (iout,2215) 'solvent'
            inperr=inperr+1
          else if (iop(65) .gt. 2 .and. iop(43) .eq. 0) then
            write (iout,2215) 'solute'
            inperr=inperr+1
          end if
          igf=igrslt(iafrst)
          igl=igrslt(ialast)
          igf2=igrslt(iafrst2)
          igl2=igrslt(ialast2)
          call checkcompopt(icompopt(2),'ENGL','TN',inperr,iout)
          if (iop(3) .gt. 8) then
            write (iout,2281)
            inperr=inperr+1
          end if
          if (inperr .gt. 0)  call datprt(2)
        else if (key0 .eq. 'FILT') then
c---------Filter solute and/or solvents or whole trajectory frames
          nsltsegdel=0
          nslvsegdel=0
          if (key .ne. 'FRAM') then
            call decode(filt1,nfilt1,ndummyu,keyno2,key2,1)
            nsltbef=nstta
            natsbef=natoms
            nmolbef=nmolec
            irecenter=0
            call indexit(keeppx,1,nstta,0)
          end if
          if (key2 .eq. 'CONF') then
            if (iconffilt .gt. 0) then
              write (iout,2291)
              inperr=inperr+1
              icol=0
              go to 1111
            end if
            call find('CMPC',1,nmainkey,mainkey,npfkey,4)
            call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -        keyno3,keyw,1)
            if (keyno3 .gt. 0) then
              iotyp=keyno3-1
              iformw=0
              if (iotyp .eq. 1) iformw=1
            end if
          else
            call find('TRAJ',1,nmainkey,mainkey,npfkey,4)
            call decode(keys01(ifkey1(npfkey)),nkey1(npfkey),ndummyu,
     -        keynotraj,keyw,1)
            isavopt=keynotraj-1
            nsltsave=nstta
            natssave=natoms
            if (key2 .eq. 'TRAC' .or. key2 .eq. 'TRCO') irecenter=1
            if (key2 .eq. 'TRAO' .or. key2 .eq. 'TRCO') iwriteorg=1
            key4='    '
          end if
          nmolec0=nmolec
          natoms0=natoms
          ichkp0=ichkp
          isltfilt=0
          call fileopen(file,namlenf,filenames(1),namlens(1),26,0,
     -      numrun,99,0,1,iop(24),iversout,iout,ichkp,0)
          call csave(ichkp,0,inperr,26)
          if (iwriteorg .gt. 0)
     -      call fileopen(file,namlenf,filenames(43),namlens(43),42,0,
     -        numrun,1,3,1,iop(24),iversout,iout,iwriteorg,0)
          if (key .eq. 'SOLV') then
c           Solvent-dependent filtering
            call decode(filt,nfilt,ndummyu,keyno4,key4,1)
            call decode(gcen1,ngcen1,ndummyu,keyno3,key3,1)
            if (key3 .ne. 'RWVD' .and. iop(3) .gt. 9) then
              write (iout,2179)
              nchng=nchng+1
              keyno3=1
            end if
            if (keyno4 .lt. 4) then
              call getreal(rslv,1,1.4)
              call getint(nnoffset,0,1,0)
              call getint(minmem,0,1,100)
            else if (keyno4 .ge. 4 .and. keyno4 .le. 6) then
              call getreal(rslv,1,6.0)
              call getreal(cvlim,0,0.5)
              call check01int(cvlim,'CV filter threshold',iout,inperr)
              call getint(nsltcvfirst,0,1,1)
              call getint(nsltcv,0,1,nstta)
              if (nsltcvfirst .gt. nsltcv) then
                write (iout,2299) nsltcvfirst,nsltcv
                inperr=inperr+1
              end if
              if (keyno4 .eq. 6) call getint(leavemol,1,1,0)
              natssave=nstta+leavemol*nslv
            else if (keyno4 .le. nfilt) then
              if (keyno4 .eq. nfilt) then
                call getint(leavemol,1,1,0)
                natssave=nstta+leavemol*nslv
              else
                call getreal(rslv,1,1.4)
              end if
              call readpairlist(nafltrange,iafltrange,50,0,
     -          'iafltrange','solute atoms to solvate','solute atoms',
     -          iout,inperr,nwarn,1,nchng,0,0,0,0)
              nsltpx1=1
              nsltpx2=nstta
              if (nafltrange .gt. 0) then
                call zeroiti(keeppx,0,nstta)
                do ir=1,nafltrange
                  do ia=iafltrange(1,ir),iafltrange(2,ir)
                    keeppx(ia)=1
                  end do
                end do
              end if
            end if
          else if (key .eq. 'GEOM') then
c           Geometry-dependent filtering
            call edgetogredge(gre,elgr,ergr,edgexyz,
     -        0,lgrl,lgru,gcent,gll,glu,iout,nchng,idebug(58))
            keyno4=nfilt+1
            do k=1,3
              call getreal(xyzmin(k),0,elgr(k))
              call getreal(xyzmax(k),0,ergr(k))
              if (xyzmin(k) .gt. xyzmax(k)) then
                write (iout,2180) 'coordinate',xyzmin(k),xyzmax(k)
                inperr=inperr+1
              end if
            end do
            do k=1,3
              call getreal(center(k),0,0.0)
            end do
            call getreal(rcentmin,0,0.0)
            call getreal(rcentmax,0,rboxmax)
            call getreal(cplpmin,0,0.0)
            call getreal(cplpmax,0,1.0)
            if (cplmin .gt. cplmax) then
              write (iout,2180) 'coupling parameter',cplmin,cplmax
              inperr=inperr+1
            end if
            call check01int(cplmin,'coupling parameter minimum',iout,
     -        inperr)
            call check01int(cplmin,'coupling parameter maximum',iout,
     -        inperr)
            call getint(nmolmin,0,1,0)
            call getint(nmolmax,0,1,#MO-1)
            nmolmin=nmolmin+1
            nmolmax=nmolmax+1
            if (nmolmin .gt. nmolmax) then
              write (iout,2181) 'molecule number',nmolmin,nmolmax
              inperr=inperr+1
            end if
            call getint(isltfilt,0,1,0)
          else if (key .eq. 'NMBR') then
c           Atom number based filtering
            keyno4=nfilt+2
            call readpairlist(nsltsegdel,isltdellim,250,natoms,
     -        'isltdellim','list of (solute) atoms to delete',
     -        '(solute) atoms',iout,inperr,nwarn,1,nchng,1,1,1,0)
            call readpairlist(nslvsegdel,islvdellim,250,nmolec,
     -        'islvdellim','list of solvent molecules to delete',
     -        'solvent molecules',iout,inperr,nwarn,1,nchng,1,1,1,0)
            do id=1,nsltsegdel
              nsltsave=nsltsave-(isltdellim(2,id)-isltdellim(1,id)+1)
              natssave=natssave-(isltdellim(2,id)-isltdellim(1,id)+1)
            end do
            do id=1,nslvsegdel
              natssave=natssave-
     -          nslv*(islvdellim(2,id)-islvdellim(1,id)+1)
            end do
            write (iout,2044) natssave,nsltsave
          else if (key .eq. 'ENRG') then
c           Solute energy based filtering
            keyno4=nfilt+3
            call getreal(esuvmin,1,0.0)
            call getreal(esuvmax,1,0.0)
            call inicac
            call setuppx(nmolec,newrfs,1)
            if (iop(3) .gt. 9) then
              write (iout,2168)
              call datprt(2)
            end if
          else if (key .eq. 'FRAM') then
            call decode(framefilt,nframefilt,ndummyu,keynocalc,key3,1)
            if (key3 .eq. 'ETRA' .and. iop(3) .gt. 7) then
              write (iout,2188)
              call datprt(2)
            end if
            if (key3 .eq. 'ECAL' .and. iop(3) .gt. 9) then
              write (iout,2168)
              call datprt(2)
            end if
            call getreal(etotmin,1,0.0)
            call getreal(etotmax,1,0.0)
            call getint(nmolmin,0,1,0)
            call getint(nmolmax,0,1,#MO-1)
            nmolmin=nmolmin+1
            nmolmax=nmolmax+1
            if (nmolmin .gt. nmolmax) then
              write (iout,2181) 'molecule number',nmolmin,nmolmax
              inperr=inperr+1
            end if
            call inicac
            keyno4=0
            nmcwrite=0
          end if
          numconf=0
          if (key2 .eq. 'CONF') then
c           Single configuration
            call getint(incvers,0,1,10)
            if (icord .eq. 0) then
              write (iout,2082)
              inperr=inperr+1
            end if
            if (inperr .gt. 0) go to 1110
            nmolec0=nmolec
            natoms0=natoms
            call filterslv(iout,inperr,nwwarn,c,qslt,ianslt,igrslt,
     -        labslt,nstta,ianslv,nslv,numsolv,nmolec,natoms,crmgs,
     -        rslv,keyno4,nfilt,keyno3,nnoffset,minmem,cvlim,1,iop(24),
     -        0,xyzmin,xyzmax,center,rcentmin,rcentmax,cplpmin,cplpmax,
     -        cplpar,nmolmin,nmolmax,nsltsegdel,isltdellim,nslvsegdel,
     -        islvdellim,leavemol,isltfilt,esuvmin,esuvmax,ic00,
     -        irecenter,iwriteorg,filenames(42),namlens(42),nafltrange,
     -        iafltrange,islvkeep,indexx,nsltcv,nsltcvfirst,frocc2,
     -        bfac2)
            if (iotyp .lt. 3) then
c             MMC formats
              call fileopen(file,namlenf,filename1,namlen1,27,0,
     -          numrun,1+incvers,0,iformw,iop(24),iversout,iout,
     -          icordw,0)
              call savec(icordw,iout,nwarn,c,natoms,nmolec,cplpar,
     -          edgexyz,iop(47),iop(41),iop(90),iop(30),iop(24),
     -          filename1,namlen1,iop(98),1,bfac2)
              call fileclose(icordw,0,iop(24),iout)
            else
c             PDB or Charmm
              if (keyw(1:3) .eq. 'PDB') keyw='PDBw'
              if (ifrocc .eq. 1) then
c               Condense frocc1,bfac1
                ndel=0
                do im=2,nmolec0
                  if (islvkeep(im) .eq. 0) then
                    ndel=ndel+1
                  else
                    frocc1(im-ndel)=frocc1(im)
                    bfac1(im-ndel)=bfac1(im)
                  end if
                end do
                keycol(1)=npxcol+3
                keycol(2)=npxcol+4
              else if (keyno4 .ge. 4 .and. keyno4 .le. 6) then
c               CV filtering, bfac2 is the CV and frocc2 is the distance
c               from the closest solute atom; already condensed
                do im=2,nmolec
                  frocc1(im-1)=frocc2(im)
                  bfac1(im-1)=bfac2(im)
                end do
                keycol(2)=npxcol+1
                if (keyno4 .eq. 5) keycol(2)=npxcol+2
                keycol(1)=npxcol+5
              end if
              call savepdb(keyw,keycol,icordw,iout,1,nstta,nslv,c,
     -          0,0,0,1,filename1,namlen1,nmc,2,file,namlenf,numrun,
     -          1+incvers,0,inperr,nwarn,nwwarn,6,0,nlwr,0,1,
     -          #NA)
            end if
            iconffilt=1
          else
c           Trajectory
            call getint(incvers,0,1,10)
            call getint(nfrmmax,0,1,100000000)
            call getint(nfrmfreq,0,1,1)
            call getint(nfrmskip,0,1,0)
            nfrmwrite=(nfrmmax-nfrmskip)/nfrmfreq
            if (nfrmskip .gt. 0) write (iout,2183) nfrmskip
            if (nfrmfreq .gt. 1) write (iout,2209) nfrmfreq
            write (iout,2182) nfrmmax,nfrmwrite,formatnames(isavopt),
     -        incvers
            if (iop(9) .eq. 0) then
              write (iout,2056)
              inperr=inperr+1
              go to 1110
            end if
            if (iop(41) .eq. 0 .and. iop(9) .le. 3) then
              write (iout,2070)
              go to 1110
            end if
            if (isavopt .ge. 9) then
              if (key .ne. 'NMBR' .and.
     -            key4 .ne. 'NCLS' .and. key4 .ne. 'CVLS') then
                write (iout,2195) formatnames(isavopt)
                call datprt(2)
              end if
            end if
            nmchinc=0
            icntrlr(1)=0
c           Open input trajectories and gather initial config
            call opentraj(filenames(3),namlens(3),nstta,nslv,nsvp,c,0,
     -        nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),0,
     -        uusfac,edgexyz,ieof,nconnfail)
            if (nmolec .ne. nmolec0) then
              nmolec0=nmolec
              natoms0=natoms
            end if
c           Set output file format information
            if ((isavopt .eq. 7 .or. isavopt .eq. 8)
     -           .and. nosltname .eq. 1) then
              write (iout,2107) keyw
              nwwarn=nwwarn+1
            end if
            iformw=iformiop9(isavopt)
c           Open filtered trajectory file with current version+incvers
            if (namlenh .eq. 0) then
              write (iout,2372)
              inperr=inperr+1
            end if
            call fileopen(filenameh,namlenh,filename1,namlen1,3,0,
     -        numrun,-(nhstvers+incvers),1-incrun,iformw,iop(24),
     -        iversout,iout,ihistw,0)
            nrecw=0
            nfrm=0
            if (isavopt .eq. 10) then
              iopcellw=0
              if ((iop(9) .eq. 10 .and. iop(161) .gt. 0) .or.
     -          iop(9) .eq. 10) iopcellw=icntrlr(11)
              if (iop(9) .ne. 11) icntrlr(1)=0
              call writeheader(isavopt,ihistw,iout,natssave,nsltsave,
     -          ntitline,titline,nfrmfreq,nfrmmax,nfrmskip,isltmv,nslv,
     -          nrecw,iopcellw,edgexyz,1,0)
            else
              call writeheader(isavopt,ihistw,iout,natoms,nstta,2,
     -          ident,nfrmfreq,nfrmmax,nfrmskip,isltmv,nslv,nrecw,0,
     -          edgexyz,1,0)
            end if
            nsleftmin=#MO
            nsleftmax=0
            nsleftsum=0
            lastnmc=nmc
            if (ieof .eq. 0) then
              do ii=1,nfrmmax
                if (iop(41) .eq. 0 .and. nmolec0 .gt. 0) then
                  nmolec=nmolec0
                  numsolv=nmolec-1
                  natoms=natoms0
                end if
                if (iskip1 .eq. 0) then
                  call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -              nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -              nmchinc,incrun,ia0,c,0,numrec(3),uusfac,0,nsvp,0)
                  if (ieof .gt. 0) then
                    write (iout,2169) lastnmc,filenames(3)(1:namlens(3))
                    go to 1120
                  end if
                  lastnmc=nmc
                  if (iop(97) .eq. 0 .and. nmolec .ne. nmolec0) then
                    write (iout,2170) nmolec-1,nmolec0-1
                    inperr=inperr+1
                  end if
                  if (isavopt .eq. 7 .and. modelnumh .gt. 0) then
                    isavopt=8
                    write (iout,2373)
                  end if
                else
                  iskip1=0
                end if
                if (ii .gt. nfrmskip .and. mod(ii,nfrmfreq) .eq. 0) then
                  if (key .eq. 'FRAM') then
c                   Filter trajectory frames
                    call filterframes(iout,etotmin,etotmax,nmolmin,
     -                nmolmax,c,keynocalc,nmolec,nmc,nmcwrite,
     -                iskipframe,natoms)
                    if (iskipframe .eq. 0) nmcwrite=nmcwrite+1
                    nmc=nmcwrite
                  else
                    call filterslv(iout,inperr,nwwarn,c,qslt,ianslt,
     -                igrslt,labslt,nstta,ianslv,nslv,numsolvleft,
     -                nmolec,natoms,crmgs,rslv,keyno4,nfilt,keyno3,
     -                nnoffset,minmem,cvlim,ii,iop(24),nmc,xyzmin,
     -                xyzmax,center,rcentmin,rcentmax,cplpmin,cplmax,
     -                cplpar,nmolmin,nmolmax,nsltsegdel,isltdellim,
     -                nslvsegdel,islvdellim,leavemol,isltfilt,esuvmin,
     -                esuvmax,ic00,irecenter,iwriteorg,filenames(42),
     -                namlens(42),nafltrange,iafltrange,islvkeep,indexx,
     -                nsltcv,nsltcvfirst,frocc2,bfac2)
                    if (numsolvleft .lt. nsleftmin)
     -                nsleftmin=numsolvleft
                    if (numsolvleft .gt. nsleftmax)
     -                nsleftmax=numsolvleft
                    nsleftsum=nsleftsum+numsolvleft
                    numconf=numconf+1
                    nrecwprev=nrecw
                    iskipframe=0
                  end if
                  if (iskipframe .eq. 0) then
                    if (iop(121) .gt. 0) then
                      call bestoverlay(c,ianslt,
     -                  natoms,ixovref,ixovref,novuse,atwsuminp,c1,
     -                  trqng,trnisg,cv1,idebug(159),iout,0.00001,nstta)
                      call savcnfh(ihistw,iout,0,1,isavopt,1,c,crmgs,
     -                  filename1,namlen1,nrecwprev,nrecw,nfrm,uusfac,
     -                   #NA,#UV)
                    else
                      call savcnfh(ihistw,iout,0,1,isavopt,1,c,crmgs,
     -                  filename1,namlen1,nrecwprev,nrecw,nfrm,uusfac,
     -                   #NA,#UV)
                    end if
                  end if
                  if (keyno4 .eq. nfilt+2) then
                    nstta=nsltbef
                    natoms=natsbef
                    nmolec=nmolbef
                    numsolv=nmolec-1
                  end if
                end if
              end do
              if (nconnfail .gt. 0) write (iout,2112) nconnfail
            end if
1120        call fileclose(ihistw,0,iop(24),iout)
            call fileclose(ihist,0,iop(24),iout)
            if (iwriteorg .gt. 0)
     -        call fileclose(iwriteorg,0,iop(24),iout)
          end if
1110      if (numconf .gt. 0) then
            avgsleft=float(nsleftsum)/float(numconf)
            write (iout,2178) numconf,avgsleft,nsleftmin,nsleftmax
          end if
          if (key .eq. 'FRAM') write (iout,2239) nmcwrite
          call crstr(0)
          ihist=0
          call fileclose(ichkp,1,iop(24),iout)
          ichkp=ichkp0
        else if (key0 .eq. 'WTRA') then
c---------Transform a trajectory
          call find('TRAJ',1,nmainkey,mainkey,keyno,4)
          call decode(keys01(ifkey1(keyno)+4),nkey1(keyno)-4,ndummyu,
     -      keyno1,key1,0)
          iop9w=keyno1+3
          if ((iop9w .gt. 6 .and. iop9w .lt. 10)
     -        .and. nosltname .eq. 1) then
            write (iout,2107) key
            nwwarn=nwwarn+1
          end if
          if (keyno .eq. 2 .and. iop(5) .ne. 0) then
            write (iout,2109)
            inperr=inperr+1
            go to 1111
          end if
          call trajconv(ihist,iformiop9(iop9w),iop9w,keyno,
     -      inpt,iout,nwarn,nconnfail,c,crm,zv,uusfac)
        else if (key0 .eq. 'DENF') then
c---------Prepare a single configuration of all solvents
          if (key .eq. 'PDB ') icftype=15
          if (key .eq. 'CHRM') icftype=18
          if (key .eq. 'INSG') icftype=11
          call getint(nmcmax,0,1,100000000)
          call getint(nmcfreq,0,1,1)
          call getint(nmcskip,0,1,0)
c         Open input trajectories and gather initial config
          call opentraj(filenames(3),namlens(3),nstta,nslv,nsvp,c,0,
     -      nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),0,
     -      uusfac,edgexyz,ieof,nconnfail)
          if (ieof .eq. 0) then
c           Open new configuration file with file root appended with '_den'
            filename1=file(1:namlenf)//'_den'
            namlen1=namlenf+4
            call fileopen(filename1,namlen1,filename1,namlen1,icftype,0,
     -        numrun,nhstvers,3,0,iop(24),iversout,iout,idens,0)
            if (iop(163) .gt. 0 .and. infopx .eq. 0)
     -        call fileopen(file,namlenf,filenames(8),namlens(8),8,0,
     -          numrun,1,0,iform(8),iop(24),iversout,iout,infopx,0)
            call allsolv(ihist,idens,infopx,nmcskip,nmcfreq,nconf,
     -        file,namlenf,filename1,namlen1,nhstvers+1000,
     -        inpt,iout,nwarn,nwwarn,inperr,nconnfail,c,
     -        icftype,iskip1,numrec(3),uusfac)
            call fileclose(idens,0,iop(24),iout)
          end if
        else if (key0 .eq. 'NMVP') then
c---------Set percentage threshold for acceptance rate for not-moved label
          call getint(nacclim,1,1,0)
          accpmn=float(nacclim)/100.0
        else if (key0 .eq. 'STPS') then
c---------Scale stepsizes if molecs don't move
          call getint(iop(34),0,1,1)
        else if (key0 .eq. 'RFSL') then
c---------Set proximity analysis first shell radius choice method
          if (key .eq. 'STOR') then
            call getreal(rfsfac,0,1.0)
            call getreal(rfsadd,0,0.0)
          else if (key .eq. 'SIGM') then
            call getreal(rfsfac,0,1.05)
            call getreal(rfsadd,0,0.0)
            call getreal(sigmah,0,0.0)
            if (iop(3) .gt. 8) then
              write (iout,2289)
              inperr=inperr+1
            end if
          else
c           (Nothing to read with key=RDFM)
            rfsfac=1.0
            rfsadd=0.0
          end if
          if (nrans .gt. 0) newrfs=1
        else if (key0 .eq. 'GRAV') then
c---------Set RDF critical point averaging options
          call getreal(rkgrmin,0,0.5)
          call getreal(r2kgrmin,0,2.5)
          call getreal(rtkgrmin,0,10.0)
        else if (key0 .eq. 'KMNP') then
c---------Set minimum coordination for property print on PDB files
          call getreal(rkpdbmin,0,0.0)
        else if (key0 .eq. 'PXYZ') then
c---------Read coordinate permuting information
          do k=1,3
            call getint(ixyz(k),1,1,k)
          end do
          if (ixyz(1)*ixyz(2)*ixyz(3) .ne. 6) then
            write (iout,2142) ixyz
            inperr=inperr+1
          else
            do k=1,3
              ixyzinv(ixyz(k))=k
            end do
          end if
        else if (key0 .eq. 'PXCR') then
c---------Select density source and proximity criterion type
          call decode(pxcr1,npxcr1,ndummyu,keyno,key2,0)
          if (keyno .gt. 0) iop(141)=keyno-1
          call decode(pxcr2,npxcr2,ndummyu,keyno,key2,0)
          if (keyno .gt. 0) iop(168)=keyno-1
          if (iop(168) .gt. 1) then
c           Get ranges for atoms to be used
            call readpairlist(npxkeep,ipxkeep,100,nstta,'ipxkeep   ',
     -        'list of atoms to use','solute atoms',iout,inperr,
     -        nwarn,1,nchng,1,1,1,0)
          else
            npxkeep=0
          end if
c         Get the atomic radii squares for radical plane alg.
          if (iop(141) .eq. 0) then
c           Voronoi
            call zeroit(rppxrad2,nstta)
          else if (iop(141) .eq. 1) then
c           Radical plane with VdW radii
            do i=1,nstta
              rppxrad2(i)=vdw(ianslt(i))**2
            end do
          else
c           Radical plane with radii proportional to charges
c           rqwmin,max: atomic radius limits for charge radical planes
            call getreal(rqwmin,0,0.0)
            call getreal(rqwmax,0,1.5)
            qmaxa=0.0
            call trnsfr(texng,qslt,nstta)
            do ia=1,nstta
              if ((iop(168) .eq. 1 .or. iop(168) .eq. 3) .and.
     -            ianslt(ia) .ne. 1) then
c               Sum hydrogen charges to its heavy atom
                do nn=1,nneig(ia)
                  if (ianslt(ineig(nn,ia)) .eq. 1)
     -              texng(ia)=texng(ia)+qslt(ineig(nn,ia))
                end do
              end if
              if (qmaxa .lt. abs(texng(ia))) qmaxa=abs(texng(ia))
            end do
            if (qmaxa .gt. 0.01) then
              do ia=1,nstta
                rppxrad2(ia)=
     -            (rqwmin+(rqwmax-rqwmin)*abs(texng(ia))/qmaxa)**2
              end do
            else
              write (iout,2047)
              inperr=inperr+1
            end if
          end if
          call getreal(pmvslt,0,0.0)
          call getreal(pmvslv,0,18.12004)
        else if (key0 .eq. 'DBLG') then
c---------Double the proximity analysis gridsize
          if (ncnfpx .eq. 0) then
            write (iout,2141)
            inperr=inperr+1
          else
c           Double the proximity analysis gridsize
            call doublepxgrid(iout)
            call echoprpx
            call disfinpx(numrun,volav)
          end if
        else if (key0 .eq. 'GENV') then
c---------Generate additional random volume element estimates
          if (nrans .gt. 0 .or. key .eq. 'WRIT') then
            call getint(nransn,1,1,0)
            maxpoints=0
            rproxmax=0.0
            iwritepx=0
            if (key .eq. 'WRIT') then
              call fileopen(file,namlenf,filename1,namlens1,
     -          21,0,numrun,2,1,0,iop(24),iversout,iout,iwritepx1,0)
              call fileopen(file,namlenf,filename2,namlens2,
     -          16,0,numrun,1,0,0,iop(24),iversout,iout,iwritepx,0)
              call getint(iwritefs,0,1,1)
              call getint(iwritels,0,1,nstta)
              call getint(maxpoints,0,1,100)
              call getreal(rproxmax,0,0.0)
              write (iout,2065) nransn,filename2(1:namlens2),
     -          iwritefs,iwritels
              write (iout,2067) nsttg+iwritefs,nsttg+iwritels,
     -          maxpoints
              if (rproxmax .eq. 0.0) write (iout,2068)
              if (rproxmax .gt. 0.0) write (iout,2069) rproxmax
              if (numrun .eq. numrunst) then
c               If no config was read/generated, use input
                call find('CNFG',1,nmainkey,mainkey,keyno,4)
                if (mainkeyun(keyno) .eq. 0) then
                  call trnsfr(c,rlcslt,3*nstta)
                end if
                call cofms(c,crm,iclslt,1,nstta,0,wx)
              end if
              if (nrans .eq. 0) then
                call setuppx(nmolec,newrfs,0)
                call initgenvol(1,3,nsltpxgr,nsltpx1,nsltpx2,0,newrfs)
              end if
              nrecw=0
              nfrm=0
              uusfac=1.0
              call savcnfh(iwritepx1,iout,1,1,5,0,c,crmgs,filename2,
     -          namlens2,nrecwprev,nrecw,nfrm,uusfac,#NA,#UV)
            else
              write (iout,2066) nransn
            end if
            call genvol(nransn,nransw,iwritefs,iwritels,
     -        maxpoints,rproxmax,iwritepx,c,crm)
c           Update number of atoms
            rewind iwritepx1
            read (iwritepx1,*) nsltw
            write (iwritepx,*) (nsltw+nransw)
c           Copy solute
            do i=1,nsltw
              read (iwritepx1,1000) filename2
              write (iwritepx,1000) filename2
            end do
c           Copy points
            do ifl=1000+iwritefs,1000+iwritels
              rewind ifl
              do i=1,100000
                read(ifl,1000,end=4000) filename2
                write (iwritepx,1000) filename2
              end do
4000          close (ifl,status='delete')
            end do
            call fileclose(iwritepx1,1,iop(24),iout)
            call fileclose(iwritepx,0,iop(24),iout)
          else
            write (iout,2025)
            inperr=inperr+1
          end if
        else if (key0 .eq. 'PXPL') then
c---------Write proximity distributions to unit idistrpx
          call fileopen(file,namlenf,filenames(7),namlens(7),7,0,
     -      numrun,1,0,0,iop(24),iversout,iout,idistrpx,0)
        else if (key0 .eq. 'PXWR') then
c---------Write proximity information to unit infopx
          if (key .ne. 'OFF ') then
            iop(170)=0
            call decode(readwrite,nreadwrite,ndummyu,keyno,key,0)
            if (keyno .gt. 0) iop(170)=keyno-1
            iform(8)=1
            if (iop(163) .eq. 1) iform(8)=0
            if (infopx .ne. 0) then
              write (iout,2104)
              nchng=nchng+1
              call fileclose (infopx,0,iop(24),iout)
            end if
            if (iop(170) .eq. 0) then
              call fileopen(file,namlenf,filenames(8),namlens(8),8,0,
     -          numrun,1,0,iform(8),iop(24),iversout,iout,infopx,0)
            else
c             Open for read
              call getint(numrunpxi,0,1,numrun)
              call fileclose(infopx,0,iop(24),iout)
              call fileopen(file,namlenf,filenames(8),namlens(8),8,0,
     -          numrunpxi,1,2,iform(8),iop(24),iversout,iout,infopx,0)
              iop(170)=numrunpxi
            end if
          end if
        else if (key0 .eq. 'PXWW') then
c---------Calculate solvent-solvent properties
          call decode(pxww,npxww,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(147)=keyno-1
          call getreal(rsolmn,1,0.0)
          call getreal(rsolmx,1,0.0)
          rsmnsq=rsolmn**2
          rsmxsq=rsolmx**2
c         Water-water analysis will be done for waters in a concentric
c         shell around the solute com of radii rsolmn,rsolmx
          if (iop(148) .gt. 0) then
c           rfsww: water first solvation shell radius
c           rceww: water-water energy cutoff radius
            call getreal(rfsww,1,0.0)
            call getreal(rceww,1,0.0)
            rfsww2=rfsww**2
            rceww2=rceww**2
          end if
          if (iop(147) .gt. 0) then
            call getreal(rgpxwwmax,0,10.0)
            call getreal(rpxwwdivi,0,0.1)
            call getint(nijgvv,0,1,0)
            nijgvvp=max0(nijgvv,1)
            call checkdim(ifail,iout,inperr,'ND',nijgvvp,1,0,0)
            do iv=1,nijgvvp
              call getint(islvirep(iv),0,1,1)
              call getint(islvjrep(iv),0,1,1)
            end do
          end if
        else if (key0 .eq. 'PXGR') then
c---------Calculate primary and/or total solute-solvent g(r), <K>, xc(K)
          call decode(pxgr1,npxgr1,ndummyu,keyno,key,1)
          if (keyno .gt. 0) iop(142)=keyno-1
          call decode(pxgr2,npxgr2,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(149)=keyno-1
c         rgpxmax,rpxdiv: range and gridsize for all proximity g(r)'s
          call getreal(rgpxsltmax,0,10.0)
          call getreal(rpxdivi,0,0.1)
c         rpxnear: warning threshold of solute-solvent distance
          call getreal(rpxnear,0,1.0)
          rpxnear2=rpxnear**2
        else if (key0 .eq. 'PXBE') then
c---------Calculate solute-solvent energy QCDF's
c         epmink, epdivk: solute pair energy minimum and QCDF grid in kcal/mol
          call getreal(epmink,1,0.0)
          call getreal(epdivk,1,0.0)
          if (epdivk .eq. 0.0) then
            write (iout,2123)
            inperr=inperr+1
          end if
        else if (key0 .eq. 'SVDP') then
c---------Calculate solvent dipole moment direction distribution
          call unitmat(exyzabc,3)
          do i=1,3
            do k=1,3
              call getreal(exyzabc(k,i),0,exyzabc(k,i))
            end do
          end do
          call dipolemoment(cslv,nslv,qslvdip,dipmomabs,dipmom,1)
        else if (key0 .eq. 'FLDG') then
c---------Calculate and write field-gradients to unit ifldgpx
          if (iop(166) .gt. 0) then
            call decode(fldg,nfldg,ndummyu,keyno,key,1)
            iop(179)=keyno-1
            iform(10)=0
            if (iop(166) .eq. 1 .or. iop(166) .eq. 3) iform(10)=1
            call fileopen(file,namlenf,filenames(10),namlens(10),10,0,
     -        numrun,1,0,iform(10),iop(24),iversout,iout,ifldgpx,0)
            call getreal(fgruucut,1,0.0)
            call getreal(fgruvcut,1,0.0)
            call getreal(fgrvvcut,1,0.0)
            call getreal(rproxfgmax,1,0.0)
            fgruucut2=fgruucut**2
            fgruvcut2=fgruvcut**2
            fgrvvcut2=fgrvvcut**2
            rproxfgmax2=rproxfgmax**2
          end if
        else if (key0 .eq. 'DIFC') then
c---------Calculate diffusion constants
          call getreal(timestep,0,0.15)
          call getreal(dcgrid,0,0.5)
          call getreal(rdc1,0,0.0)
          call getreal(rdc2,0,10.0)
          rdc1=rdc1**2
          rdc2=rdc2**2
        else if (key0 .eq. 'HBBR') then
c---------Calculate hydrogen-bonded bridge energies
          call getreal(rxhmax,0,3.0)
          rxhmax2=rxhmax**2
          call getreal(hbanglemin,0,90.0)
          hbanglemin=hbanglemin/rdtodg
          call setanchor(ianslt,qslt,labslt,nstta,nhbanchor,ihbanchor,
     -      nbridgeat,bridgeat,qbmin,iop(178),inperr,iout)
          iwo=0
          iwh1=0
          iwh2=0
          do ia=1,nslv
            if (ianslv(ia) .eq. 8) iwo=ia
            if (ianslv(ia) .eq. 1) iwh2=ia
          end do
          do ia=1,iwh2-1
            if (ianslv(ia) .eq. 1) iwh1=ia
          end do
          if (iwo*iwh1*iwh2 .eq. 0) then
            write (iout,2197)
            inperr=inperr+1
          end if
        else if (key0 .eq. 'RTIM') then
c---------Calculate residence times
          if (nbits .gt. 32) then
            write (iout,2286) nbits
            inperr=inperr+1
          end if
          call fileopen(file,namlenf,filenames(9),namlens(9),9,0,
     -      numrun,0,3,iform(9),iop(24),iversout,iout,irtm,1)
          call getreal(timestep,0,1.00)
          call getreal(aucmin,0,0.1)
          call check01int(aucmin,'aucmin',iout,inperr)
          call getint(nzerosignore,0,1,0)
          if (key .eq. 'READ') then
            call getreal(rtimlim,0,10.0)
            rtimlim=rtimlim**2
          end if
        else if (key0 .eq. 'TAUC') then
c---------Calculate torsion angle autocorrelation
          call getint(nmctorauc,0,1,#TR)
          call getreal(tauc_timestep,0,1.0)
          call getreal(tauc_min,0,0.0)
          call check01int(tauc_min,'tauc_min',iout,inperr)
          call getint(ntaucprint,0,1,20)
        else if (key0 .eq. 'PROT') then
c---------Protect charge-charge interactions
c         if (iop(26) .ne. 4) then
c           if (MYRANK .eq. 0) write (iout,2055)
c           inperr=inperr+1
c         end if
          if (numrun .gt. numrunst) then
            if (MYRANK .eq. 0) write (iout,2057)
            inperr=inperr+1
          end if
          call getreal(c12prot,1,0.0)
        else if (key0 .eq. 'PLBP') then
c---------Potential library print
          if (key(1:3) .eq. 'CMB') iprtlibcomb=1
          if (key .eq. 'USED' .or. key .eq. 'CMBU') ipflibprint=1
          if (key .eq. 'ALL ' .or. key .eq. 'CMBA') ipflibprint=2
          if (nsttar .eq. 0 .and.
     -       (key .eq. 'USED' .or. key .eq. 'CMBU')) then
            if (MYRANK .eq. 0) write (iout,2218)
            nwarn=nwarn+1
            call setljconst(maxtyp)
          else
            if (nsttar .eq. 0) call setljconst(maxtyp)
            if (key .eq. 'SNGL') then
              call find('SUPT',1,nmainkey,mainkey,keyno,4)
              call decode(keys01(ifkey1(keyno)),nkey1(keyno),ndummyu,
     -          keyno,key,0)
              ipflibprint=-keyno
            end if
            if (MYRANK .eq. 0) call printljconst(0,nmolec,nstta,
     -        nslv,ipflibprint,iprtlibcomb,0,nwarn,iout)
          end if
          ipflibprint=0
          iprtlibcomb=0
        else if (key0 .eq. 'PRAC') then
c---------Acceptance rate printing
          call decode(prac,nprac,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(86)=keyno-1
        else if (key0 .eq. 'FIXD') then
c---------Input round-off error fix frequency
          call getint(nmccd,1,1,0)
          call getint(nmccgd,0,1,nmccd)
          if (nmccd .eq. 0 .and. nmccgd .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2275)
            inperr=inperr+1
          end if
        else if (key0 .eq. 'SEED') then
c---------Input new random-number seed
          do i=1,4
            call getint(ixi,1,1,1)
            rix(i)=ixi
          end do
          call getint(ixo,1,1,1)
          call ranini(iout,0,0,iop(24))
          nseedread=1
        else if (key0 .eq. 'CHKP') then
c---------Input checkpoint file saving frequency
          nrecd0=amin1(25000.0,rnbytyckp/400.0)
          nrecd0=(nrecd0/1000)*1000
          call getint(nrecd,0,1,nrecd0)
          irat=rnbytyckp/nrecd
          nsavepx=nrecd
        else if (key0 .eq. 'LIGA') then
          call getint(ligand_start_molecule, 1, 1, 0)
        else if (key0 .eq. 'TORT' .or. key0 .eq. 'LPST') then
c---------Calculate the energy terms during a torsion cycle
          if (ichkp .eq. 0) call fileopen(file,namlenf,filenames(1),
     -      namlens(1),1,0,numrun,1,0,1,iop(24),iversout,iout,ichkp,0)
          call torsiontest(key0,key,ntang,iquata,looptyp,labslt,esf14,
     -      vdwf14,ichkp,inperr,inpt,iout)
        else if (key0 .eq. 'GENT') then
c         Generate a conformation by replacing the current torsion angles
          call torsionlist(key0,'    ',itt,anginc,file,namlenf,
     -      esf14,vdwf14,99999.9,labslt,0,inperr,inpt,iout)
        else if (key0 .eq. 'RUNS') then
c---------Run MC
C@DMC@NN      if (MYRANK .eq. 0) write (iout,*) '***** ERROR: solvent',
C@DMC@NN     -  ' NN code is not implemented under MPI for now'
C@DMC@NN      call datprt(2)
          if (wsltpdis .eq. 0.0 .and. iop(57) .gt. 0) then
            iop(57)=0
            write (iout,2383) 'displacement'
          end if
          if (wsltptor .eq. 0.0 .and. iop(58) .gt. 0) then
            iop(58)=0
            write (iout,2383) 'torsion'
          end if
          if (cedslt+rtxslt .eq. 0.0 .and. iop(57)+iop(58) .eq. 0 .and.
     -      iop(30) .ne. 7) isltsmpl=0
          if (numsolv+iop(57)+iop(58)+iop(64) .eq. 0) then
c           Check for STEP key
            call find('STEP',1,nmainkey,mainkey,keyno,4)
              if (mainkeyun(keyno) .eq. 0) then
              write (iout,2343)
              inperr=inperr+1
            end if
          end if
          if (iop(84) .eq. 1 .and.
     -        iop(58) .eq. 0 .and. iop(18) .ne. 4) then
            write (iout,2122)
            nwwarn=nwwarn+1
          end if
          if (iop(57)+iop(58)+iop(64) .gt. 0 .and. nsltfreq .eq. 0)
     -      nsltfreq=1
          if (numrun .gt. 999) then
            write (iout,2037)
            call datprt(2)
          else if (iop(11) .eq. 7) then
            write (iout,2217)
            call datprt(2)
          end if
          if (nhstvers .gt. 1) then
            write (iout,2290)
            inperr=inperr+1
          end if
          if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
            if (diamslv .eq. 0.0) then
              if (MYRANK .eq. 0) write (iout,2305)
              inperr=inperr+1
            end if
            maxsh=(nstta/1000+1)*25000
            if (nmcransh .lt. maxsh) then
              if (MYRANK .eq. 0) write (iout,2292) maxsh
              nwwarn=nwwarn+1
            end if
          else if (iop(41) .eq. 3 .and. nmcransh .gt. 0) then
            nmcransh=0
            if (MYRANK .eq. 0) write (iout,2012)
            nchng=nchng+1
          end if
          if ((iop(142)+iop(143)+iop(144)+iop(145)+iop(146)+iop(147)+
     -        iop(148)+iop(166)+iop(169)+iop(171)+iop(174)+iop(176)+
     -        iop(177)+iop(178)+iop(163) .gt. 0 .or.
     -        (iop(30) .ge. 1 .and. iop(30) .le. 3)) .and.
     -      iop(159) .eq. 0) then
            if (MYRANK .eq. 0) write (iout,2258)
            inperr=inperr+1
          end if
          iopdesolvself=iopdesolv
          ihbtypsltsltself=ihbtypsltslt
          if (idebug(142) .eq. 1) then
            iopdesolvself=0
            ihbtypsltsltself=0
          else if (idebug(142) .eq. 2) then
            iopdesolv=0
            ihbtypsltslt=0
            if (MYRANK .eq. 0) write (iout,2268) 'intermolecular'
          end if
c         Input runlength, frequency parameters
          call getint(nmcmax,1,1,0)
          nmcrepdef=nmcmax/100
          if (iop(160) .gt. 0 .and. npxres .eq. 0) npxres=nmcmax/2
          if (iop(10) .gt. 0) nmcrepdef=nmcrep
          if (iop(114) .gt. 0) then
c           Simulated annealing
            if (isannread .eq. -1) then
              write (iout,2270)
              inperr=inperr+1
            end if
            if (iop(109) .eq. 0) then
              write (iout,2322)
              iop(109)=2
              nchng=nchng+1
            end if
            ntempsteptot=(nmcmax-1)/nmctempstep+1
            if (tempfin .eq. 0.0) then
c             Set final temperature
              if (iop(114) .eq. 1) then
                tempfin=temp-(ntempsteptot-1)*tempstep
              else if (iop(114) .eq. 2) then
                tempfin=temp*exp(-float(ntempsteptot-1)*tempexp)
              else if (iop(114) .eq. 3) then
                tempfin=tempexp/alog(float(ntempsteptot+2))
              else
                tempfin=templist(ntemplist)
              end if
            else
c             Set annealing step info
              if (iop(114) .eq. 1) then
                tempstep=(temp-tempfin)/float(max0(1,ntempsteptot-1))
              else if (iop(114) .eq. 2) then
                tempexp=-alog(tempfin/temp)/
     -            float(max0(1,ntempsteptot-1))
              else if (iop(114) .eq. 3) then
                tempexp=tempfin*alog(float(ntempsteptot+2))
              end if
            end if
            isannread=-1
          end if
          call getint(nmcrep,0,1,max0(1,nmcrepdef))
          iopcellw=0
          if (iop(71) .gt. 0) iopcellw=2
          if (iop(10) .eq. 0) then
            call getint(nplt,0,1,max0(1,nmcmax/2))
            if (nrecd .eq. 0) then
              natoms_rec=natoms
              if (iop(41) .gt. 0) then
                natoms_est=vol/10.0
                natoms_rec=max0(natoms_est,natoms)
              end if
              if (natoms_rec .gt. 100000) then
                nrecd=nmcslftst/5
              else if (natoms_rec .gt. 50000) then
                nrecd=nmcslftst/4
              else if (natoms_rec .gt. 20000) then
                nrecd=nmcslftst/2
              else if (natoms_rec .gt. 10000) then
                nrecd=3*nmcslftst/4
              else
                nrecd=nmcslftst
              end if
            else if (irat .ge. 0) then
              if (irat .ge. 5000 .and. irat .lt. nmcmax) then
                if (MYRANK .eq. 0) write (iout,2162) nrecd,(irat/500+1)
                if (idebug(59) .eq. 0) inperr=inperr+1
              else if (rnbytyckp/nrecd .gt. 2000) then
                if (MYRANK .eq. 0) write (iout,2163)
     -            ' ===== STRONG',nrecd,(irat/500+1)
                 nwwarn=nwwarn+1
              else if (rnbytyckp/nrecd .gt. 500) then
                if (MYRANK .eq. 0) write (iout,2163)
     -            ' -----',nrecd,(irat/500+1)
                nwarn=nwarn+1
              end if
              irat=-1
            end if
            if (iop(159) .gt. 0) then
              if (nsavepx .ne. nrecd) then
                nchng=nchng+1
                if (MYRANK .eq. 0) write (iout,2124) nrecd,nsavepx
              end if
              if (nsavepx .lt. nrecd) nrecd=nsavepx
              if (nsavepx .gt. nrecd) then
                nsavepx=nrecd
                if (mod(npxres,nsavepx) .ne. 0)  then
                  npxres=nsavepx*(npxres/nsavepx+1)
                  nchng=nchng+1
                  if (MYRANK .eq. 0) write (iout,2161) npxres
                end if
              end if
              if (npxcntin .eq. 0 .or. npxcntin .gt. nmcmax/10) then
                npxcntin=nmcmax/10
                nchng=nchng+1
                if (MYRANK .eq. 0) write (iout,2196) npxcntin
              end if
            end if
            if (npxres .eq. 0) npxres=nplt
            nmcrecdef=2*nmolec
            if (iop(57)+iop(58) .gt. 0)
     -        nmcrecdef=max0(nmcrecdef,2*nstta)
            call getint(nmcrec,0,1,0)
            if (nmcrec .gt. 0) then
              if (iop(9) .eq. 0) then
                nmcrec=0
                write (iout,2377)
                nwarn=nwarn+1
                write (iout,2379)
                nchng=nchng+1
              end if
            else
              if (iop(9) .gt. 0) then
                nmcrec=nmcrecdef
                write (iout,2378) nmcrecdef
                nchng=nchng+1
              end if
            end if
c           nmcrec: freq of saving c on unit ihist if iop9>1
            call getint(ncntin,0,1,min0(10000,max0(1,nmcmax/100)))
            if (iop(51) .ge. 1) then
              call getint(nmcadp,0,1,nplt)
              if (nmcadp .eq. 0) nmcadp=100000
            end if
            call zeroiti(n12diff,0,20)
            call zeroiti(n13diff,0,20)
            call zeroiti(numrec,0,10)
            call zeroiti(numrecprev,0,10)
            if (iop(4) .eq. 0 .and. numrun .eq. numrunst) call disini
C@DM            if (MYRANK .eq. 0) then
            if (ichkp .le. 0)
     -        call fileopen(file,namlenf,filenames(1),namlens(1),1,0,
     -          numrun,1,0,1,iop(24),iversout,iout,ichkp,0)
            if (iop(9) .gt. 0) then
c             Initialize trajectory file for writing (if needed)
              call writeheader(iop(9),ihist,iout,natoms,nstta,2,ident,
     -          nmcrec,nmcmax,0,isltmv,nslv,numrec(3),iopcellw,edgexyz,
     -          0,0)
              numframe=0
              if (iop(9) .eq. 8 .and. natoms .gt. 99999) then
                write (iout,2177) 'trajectory',natoms
                inperr=inperr+1
              end if
            end if
C@DM            end if
          else
c           Continue from checkpoint file
            iskipfail=0
C@DM            if (MYRANK .eq. 0) then
            if (iop(9) .gt. 0 .or. iop(129) .gt. 0) then
c             For Charmm trajectory, reinitialize header info
              call writeheader(iop(9),ihist,iout,natoms,nstta,2,ident,
     -          nmcrec,nmcmax,0,isltmv,nslv,numrec(3),iopcellw,edgexyz,
     -          0,1)
c              Position the history file
              if (iop(9) .gt. 0 .and. nmcmax .gt. 0)
     -           call skiptoend(3,iunitnos(3),0,0,1,iskipfail)
            end if
            if (iop(41) .gt. 0 .and. iop(42) .gt. 0
     -          .and. nmcmax .gt. 0) then
c             Position the insertion/deletion log file
              call skiptoend(5,iunitnos(5),0,0,1,iskipfail)
            end if
            if (iop(163) .gt. 0 .and. nmcmax .gt. 0) then
c             Position the proximity information file
              call skiptoend(8,iunitnos(8),0,0,1,iskipfail)
            end if
            if (iop(171) .gt. 0 .and. nmcmax .gt. 0) then
c             Position the residence time AC function file
              call skiptoend(9,iunitnos(9),0,0,1,iskipfail)
            end if
            if (iop(166) .gt. 0 .and. nmcmax .gt. 0) then
c             Position the field-gradient file
              call skiptoend(10,iunitnos(10),0,0,1,iskipfail)
            end if
C@DM            end if
C@DM            call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,
C@DM     -        ierr)
            if (iop(67) .eq. 1 .and. mapedone .eq. 0) then
              write (iout,2277)
              inperr=inperr+1
            end if
C@DM            if (NUMNOD .ne. NUMNOD_o) then
C@DM              if (MYRANK .eq. 0) write (iout,3010) NUMNOD,NUMNOD_o
C@DM              call datprt(2)
C@DM            end if
            if (iskipfail .gt. 0) call datprt(2)
          end if
          call trnsfi(mainkeyu,mainkeyun,nmainkey)
          if (iop(142)+iop(143)+iop(144)+iop(145)+iop(146)+iop(147)+
     -        iop(148)+iop(166)+iop(169)+iop(171)+iop(176)+iop(177)+
     -        iop(174) .gt. 0 .or.
     -        (iop(30) .ge. 1 .and. iop(30) .le. 3)) then
            if (iop(159) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2167)
              inperr=inperr+1
            end if
            if (iop(142)+iop(143)+iop(145)+iop(147)+iop(148) .eq. 0
     -        .and. iop(153) .gt. 0) then
              if (MYRANK .eq. 0) write (iout,2228)
              inperr=inperr+1
            end if
          else
            if (iop(175) .gt. 0) then
              if (MYRANK .eq. 0) write (iout,2227)
              inperr=inperr+1
            end if
          end if
          if (nmolec .lt. 2 .and. iop(41) .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2257)
            inperr=inperr+1
          end if
          if (iop(159) .eq. 0) then
            call setup(0,iconfread,iop47read,sltinptyp,1)
          else
            if (iop(10) .eq. 0) then
              if (ichkpx .le. 0 .and. MYRANK .eq. 0)
     -          call fileopen(file,namlenf,filenames(6),namlens(6),
     -            6,0,numrun,1,0,1,iop(24),iversout,iout,ichkpx,0)
              call setup(0,iconfread,iop47read,sltinptyp,1)
              call setuppx(nmolec,newrfs,0)
              call disinipx(nsltpx1,nsltpx2,
     -          rpxdivi,rpxwwdivi,rgpxsltmax,rgpxwwmax)
              if (nrans .eq. 0) call initgenvol(ifrsdim,ndimgen,
     -            nsltpxgr,nsltpx1,nsltpx2,iop(164),newrfs)
              call echoprpx
            else
C@DM              if (MYRANK .eq. 0) then
              if (iop(24) .gt. 0) call echoprpx
              if (nmcmax .eq. 0) call disfinpx(numrun,volav)
              if (iop(22) .gt. 0) call zeroiti(idproxacc,0,4*nstta)
C@DM              end if
            end if
          end if
          iop(10)=0
          if (npfl6 .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2063)
            nwwarn=nwwarn+1
          end if
          if (iop(9) .eq. 0 .and. iop(109) .eq. 1) then
            if (MYRANK .eq. 0) write (iout,2363)
            inperr=inperr+1
          end if
          if (iop(61) .eq. 0 .and. iop(109) .eq. 4) then
            iop(109)=3
            nchng=nchng+1
            if (MYRANK .eq. 0) write (iout,2365)
          end if
          if (inperr .gt. 0) then
            if (MYRANK .eq. 0) write (iout,2043) inperr
            if (nmc .eq. 0) call datprt(-1)
          end if
          itiquad=0
          nmcrun=nmcrun+nmcmax
          call montec
          if (nmcmax .gt. 0) then
            if (iop(117) .gt. 0) call echo_cnst(iorig_of_split,
     -        c,labslt,'final config',12,0,iout,#ST)
            if (iop(109) .gt. 0) then
              if (iop(117) .gt. 0) call echo_cnst(iorig_of_split,
     -          cminsave,labslt,'minimum energy conf',19,0,iout,
     -          #NE)
c             Save a PDB file of the overall minimum energy config
              natoms0=natoms
              nmolec0=nmolec
              eminh=eminsave
              natoms=natomssave
              nmolec=(natoms-nstta)/nslv+1
              if (iop(61) .gt. 0) then
                iop(61)=2
                nstta_save=nstta
                nstta=nstta_full
                call trnsfr(trqng,c,3*nstta_full)
                call reassemble(nstta_save,nstta_full,crmgs,c,cslt,
     -            isplit_of_orig)
                call trnsfr(c,crmgs,3*nstta_full)
              end if
              call fileopen(file,namlenf,filenames(24),namlens(24),24,0,
     -          numrun,1,3,0,iop(24),iversout,iout,icordmin,0)
              write (iout,2303) eminsave,nmcminsave,
     -          filenames(24)(1:namlens(24))
              write (icordmin,2302) eminsave
              call savepdb('PDB ',keycol,icordmin,iout,1,nstta,3,
     -          c,0,0,0,1,filenames(24),namlens(24),nmc,0,file,
     -          namlenf,1,1,3,inperr,nwarn,nwwarn,0,1,nlwr,0,1,#NE)
              call fileclose(icordmin,0,iop(24),iout)
              natoms=natoms0
              nmolec=nmolec0
              if (iop(61) .gt. 0) then
                iop(61)=1
                nstta=nstta_save
                call trnsfr(c,trqng,3*nstta_full)
              end if
            end if
C@DM            if (MYRANK .eq. 0) then
            write (iout,2038) ' C',filenames(1)(1:namlens(1)),nmc
            if (iop(159) .gt. 0) then
              write (iout,2038) ' Proximity analysis c',
     -          filenames(6)(1:namlens(6)),nmc
            end if
            if (iop(9) .eq. 1 .or. iop(9) .eq. 2)
     -        write (ihist) estac,cst,istc,nmcst,becpst
            call gatherckpfiles(iout,ichkp,ichkpx,iop(24))
            numrun=numrun+1
            ickpread=0
            isltread=0
            write (iout,2059) numrun
C@DM            end if
            ntitlin=0
            if (ihist .gt. 0) then
              if (MYRANK .eq. 0) write (iout,2083) numframe,numrec(3)
              if (nhstvers .gt. 1 .and. MYRANK .eq. 0) write (iout,2101)
              nhstvers=1
            end if
            if (iop(47) .gt. 1) then
              if (MYRANK .eq. 0) write (iout,2186)
              iop(47)=0
            end if
C@DM            if (MYRANK .eq. 0) then
            call switchfiles(numrun,inpt,iout,0)
            call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -        iop(47),iop(41),iop(90),iop(30),iop(24),filenames(2),
     -        namlens(2),iop(98),0,c)
            write (iout,2042) filenames(2)(1:namlens(2))
            rewind icord
C@DM            end if
          end if
          call scalestep(iop(110),scalefac,0,0,1,0,iop(24),inperr,iout)
          iop(110)=0
c         Wipe out previous forbids and duplicate counts
          call zeroiti(keyforbid,0,nmainkey)
          iop(10)=0
        else if (key0 .eq. 'STIR') then
c---------Stir up the configuration (to eliminate nasty clashes)
          call getreal(eijmin,0,1000.0)
          call getreal(disp,0,3.0)
          call getreal(dispa,0,90.0)
          write (iout,2051) eijmin,disp,dispa
          call setup(1,iconfread,iop47read,sltinptyp,0)
          call stir(c,crmpmf,eijmin,disp,dispa/rdtodg,iout)
        else if (key0 .eq. 'PXPR') then
c---------Set proximity analysis printing options
          call decode(pxpr1,npxpr1,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(157)=keyno-1
          call decode(pxpr2,npxpr2,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(158)=keyno-1
          call decode(pxpr3,npxpr3,ndummyu,keyno,key,0)
          if (keyno .gt. 0) iop(155)=keyno-1
        else if (key0 .eq. 'PXTD') then
c---------Calculate proximity table differences
          call getname(filename1,namlen1,1,80)
          call getint(numrun1,0,1,1)
          call getname(filename2,namlen2,0,80)
          call getint(numrun2,0,1,1)
          if (namlen2 .eq. 0) then
            filename2=file
            namlen2=namlenf
            numrun2=numrun
            if (ichkp .ne. 0) call fileclose(ichkp,0,iop(24),iout)
          end if
c         Read first system, generate table
          call fileopen(filename1,namlen1,filenames(1),namlens(1),
     -      1,0,numrun1,1,2,1,iop(24),iversout,iout,ichkp,0)
          call crstr(0)
          call fileclose(ichkp,0,iop(24),iout)
          write (iout,2018) filenames(1)(1:namlens(1)),nmc
          call fileopen(filename1,namlen1,filenames(6),namlens(6),
     -      6,0,numrun1,1,2,1,iop(24),iversout,iout,ichkpx,0)
          call crstrpx(0)
          write (iout,2024) filenames(6)(1:namlens(6)),nmc
          call fileclose(ichkpx,0,iop(24),iout)
          call pxtabl(ipxt1,pxt1,ipxt2,pxt2,1,idebug(46),d1,d2,d3,d4,
     -      d5,d6,d7,d8,d9,d10,d11,volav,0,nfgtyp,0,0,1,numrun1)
c         Read second system, generate table
          call fileopen(filename2,namlen2,filenames(1),namlens(1),
     -      1,0,numrun2,1,2,1,iop(24),iversout,iout,ichkp,0)
          call crstr(0)
          call fileclose(ichkp,0,iop(24),iout)
          write (iout,2018) filenames(1)(1:namlens(1)),nmc
          call fileopen(filename2,namlen2,filenames(6),namlens(6),
     -      6,0,numrun2,1,2,1,iop(24),iversout,iout,ichkpx,0)
          call crstrpx(0)
          write (iout,2024) filenames(6)(1:namlens(6)),nmc
          call fileclose(ichkpx,0,iop(24),iout)
          call pxtabl(ipxt2,pxt2,ipxt1,pxt1,1,idebug(46),d1,d2,d3,d4,
     -      d5,d6,d7,d8,d9,d10,d11,volav,0,nfgtyp,0,0,1,numrun2)
          write (iout,2120) filename2(1:namlen2),numrun2,
     -      filename1(1:namlen1),numrun1
          call pxtabl(ipxt1,pxt1,ipxt2,pxt2,-2,1,d1,d2,d3,d4,d5,d6,d7,
     -      d8,d9,d10,d11,r1,0,nfgtyp,0,0,1,numrun1)
          ipxdiff=1
          ickpread=1
        else if (key0 .eq. 'PXLM') then
c---------Read limits on the solute atoms to be used for proximity anal
          call getint(nfadel,1,1,0)
          call getint(nladel,0,1,0)
        else if (key0 .eq. 'PXAN' .or. key0 .eq. 'SCAN') then
c---------Proximity analysis
          if (key0 .eq. 'PXAN') then
c-----------Set up proximity analysis concurrent with MC
            iop(159)=1
c           Specify the extent the solute is moved
            if (isltsmpl .eq. 1) then
              iop(152)=2
            else if (isltmove .eq. 1) then
              iop(152)=1
            else
              iop(152)=0
            end if
          else if (key0 .eq. 'SCAN') then
c-----------Call scanning of history file for proximity analysis
            if (iop(9) .eq. 0 .and. key .ne. 'CONF') then
              if (MYRANK .eq. 0) write (iout,2053)
              inperr=inperr+1
            end if
            if (key .eq. 'TRNC' .and. numrun .eq. numrunst .and.
     -          iop(10) .eq. 0) then
              iop(160)=1
              if (MYRANK .eq. 0) write (iout,2100)
              nchng=nchng+1
            end if
            iop(17)=0
            natoms=nstta+(nmolec-1)*nslv
            npxmax=0
            nmchinc=0
            nconnfail=0
            call ranini(iout,1,0,0)
            if (iop(160) .eq. 1 .or. iop(160) .eq. 2) then
c             npxmax: Maximum number of MC steps to scan to
              call getint(npxmax,1,1,0)
              incc=0
              if (iop(30) .ge. 1 .and. iop(30) .le. 3) incc=nstfa
              iskipfail=0
              if (iop(10) .eq. 0) then
                call zeroiti(numrec,0,10)
                call zeroiti(numrecprev,0,10)
C@DM            if (MYRANK .eq. 0) then
                call opentraj(filenames(3),namlens(3),nstta,nslv,nsvp,
     -            c,incc,nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,
     -            numrec(3),0,uusfac,edgexyz,ieof,nconnfail)
C@DM            end if
C@DM            call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM            call MPI_Bcast(ieof,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM            call MPI_Bcast(nmcstart,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
                if (ifilstat(2) .eq. 0) iconfread=2
C@DM            call MPI_Bcast(iconfread,1,MPI_INTEGER,0,MPI_COMM_WORLD,
C@DM     -        ierr)
C@DM            call MPI_Bcast(iskip1,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM            if (iskip1 .gt. 0)
C@DM     -        call MPI_Bcast(c,3*natoms,MPI_REAL,0,MPI_COMM_WORLD,ierr)
                if (ieof .gt. 0) go to 1111
                if (iconfread .eq. 0 .and.
     -             (iop(30) .eq. 1 .or. iop(30) .eq. 2))
     -             call zeroit(c,3*nstfa0)
                call getunitnos(iunitnos,1)
              else
                if (npxmax .gt. 0) then
c                 Restart - just position history file
                  if (MYRANK .eq. 0) call skiptoend(3,iunitnos(3),0,0,1,
     -              iskipfail)
                end if
C@DM            if (idebug(133) .gt. 0) then
C@DM              do icpu=0,NUMNOD-1
C@DM                call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM                if (icpu .eq. MYRANK) then
C@DM                  call echopr(1)
C@DM                  if (iop(159)+iop(160) .gt. 0) call echoprpx
C@DM                end if
C@DM              end do
C@DM            end if
C@DM            if (idebug(134) .gt. 0) call ranini(iout,0,1,iop(24))
              end if
              if ((iop(10) .gt. 0 .or. iop(160) .eq. 2) .and.
     -            iop(163) .gt. 0 .and. npxmax .gt. 0) then
c               Position the proximity information file
                if (MYRANK .eq. 0) call skiptoend(8,iunitnos(8),0,0,1,
     -            iskipfail)
              end if
              if (iop(171) .gt. 0 .and. npxmax .gt. 0) then
c               Position the residence time AC function file
                if (MYRANK .eq. 0) call skiptoend(9,iunitnos(9),0,0,1,
     -            iskipfail)
              end if
              if (iop(166) .gt. 0 .and. npxmax .gt. 0) then
c               Position the field-gradient file
                if (MYRANK .eq. 0) call skiptoend(10,iunitnos(10),0,0,1,
     -            iskipfail)
              end if
            else
              if (iconfread .eq. 0) then
                if (MYRANK .eq. 0) write (iout,2153) 'SCAN'
                inperr=inperr+1
                icol=0
                go to 1111
              end if
            end if
C@DM            call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,
C@DM     -        ierr)
            if (nmolec .le. 1 .and.
     -          iop(143)+iop(145)+iop(146)+iop(149) .gt. 0) then
              if (MYRANK .eq. 0) write (iout,2118)
              inperr=inperr+1
            end if
          end if
          if (iop(80)  .gt. 0 .and. iconfread .gt. 0)
     -      call initinout(molinout,nmolinout,edgelinxyz,edgerinxyz,
     -        crm,2,nmolec)
          if (iop(160) .lt. 3) then
c           navgpx: use each navgpx-th configuration sampled
c           nranpx: generate nranpx random points each time a config. is seen
c           nmcpxdsc: discard the first nmcpxdsc configurations
c           npxres: print the full result sheet after each npxres-th config.
c           nsavepx: save px data on unit ichkpx after each nsavepx-th conf.
c                   (default: 10000)
c           npxcntin: batch-mean block size (default: ncntin or npxres*somethg)
c                   (can not be changed on continuing from a checkpoint file!)
c           lumppr: fcg error estimates will be done for
c                   blocksize=2^lumppr*npxcntin (default: 2 at start,
c                   previous value on interrupt continuation)
            call getint(navgpx,1,1,1)
            if (navgpx .eq. 0) then
              navgpx=1
              nchng=nchng+1
              if (MYRANK .eq. 0) write (iout,2176)
            end if
          end if
          call getint(nranpx,0,1,0)
          if (iop(142) .le. 1) then
            if (nranpx .gt. 0) then
              nranpx=0
              nchng=nchng+1
              if (MYRANK .eq. 0) write (iout,2174)
            end if
          else
            if (nranpx .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2175)
              inperr=inperr+1
            end if
          end if
          if (iop(160) .lt. 3) then
            call getint(nmcpxdsc,0,1,0)
            call getint(npxres,0,1,max0(npxres,npxmax))
            if (nsavepx .eq. 0) then
              if (natoms .lt. 3000) then
                nsavepx=navgpx*1000
              else if (natoms .lt. 5000) then
                nsavepx=navgpx*750
              else if (natoms .lt. 7500) then
                nsavepx=navgpx*500
              else if (natoms .lt. 10000) then
                nsavepx=navgpx*200
              else
                nsavepx=min0(npxres,navgpx*100)
              end if
              ncdo=(npxmax-nmcpxdsc)/navgpx
              nckp=(npxmax-nmcpxdsc)/nsavepx
              if (ncdo .gt. 100 .and. nckp .lt. 10)
     -          nsavepx=(npxmax-nmcpxdsc)/10
              if (npxres .ne. 0 .and. npxres .lt. nsavepx)
     -          nsavepx=npxres
              if ((iop(30) .eq. 1 .or. iop(30) .eq. 2) .and.
     -          ncdo .gt. 10*nckp) nsavepx=max0(1,nsavepx/10)
            end if
            if (npxres .lt. navgpx) then
              npxres=navgpx
              if (MYRANK .eq. 0) write (iout,2272) npxres
              nchng=nchng+1
            else if (npxres .eq. navgpx) then
              if (MYRANK .eq. 0) write (iout,2273)
              nwwarn=nwwarn+1
            end if
            if (mod(npxres,nsavepx) .ne. 0) then
              npxres=nsavepx*(npxres/nsavepx+1)
              nchng=nchng+1
              if (MYRANK .eq. 0) write (iout,2161) npxres,nsavepx
            end if
            if (iop(160) .gt. 0) then
              nctdef=(npxmax-nmcpxdsc)/#MI
              if (nctdef .eq. 0) nctdef=1
              call getint(npxcntin,0,1,nctdef)
              if (npxcntin .lt. npxres) then
                npxcntin=max0(1,(npxmax/#MI)/navgpx)*navgpx
                nchng=nchng+1
                if (MYRANK .eq. 0) write (iout,2196) npxcntin
              end if
            else
              call getint(npxcntin,0,1,0)
            end if
          end if
          call getint(lumppr,0,1,2)
          call getint(ndimgen,0,1,3)
          call getint(ifrsdim,0,1,1)
          if (lumppr .gt. 20) then
            if (MYRANK .eq. 0) write (iout,2173)
            inperr=inperr+1
          end if
c         The solute is only asymmetric in ndimgen dimensions, starting at the
c         ifrsdim-th. Used for generating symmetry-related random pts
          if (iop(111)+iop(142)+iop(143)+iop(144)+iop(145)+iop(146)+
     -        iop(147)+iop(148)+iop(166)+iop(169)+iop(171)+iop(174)+
     -        iop(176)+iop(177)+iop(178)+iop(163) .eq. 0 .and.
     -        (iop(30) .lt. 1 .or. iop(30) .gt. 3)) then
            if (MYRANK .eq. 0) write (iout,2164)
            inperr=inperr+1
          end if
          if (key0 .eq. 'SCAN') then
            if (iop(10) .eq. 0) then
              if (npxmax .ge. nmc .and. iop(160) .lt. 3) then
c               Compare savings frequency with requested analysis frequency
C@ND                    icpu0=0
C@DM                    icpu0=1
C@DM                    inperr0=inperr
C@DM                if (MYRANK .eq. 0) then
                call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -            nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -            nmchinc,incrun,ia0,c,incc,nrecread,uusfac,icpu0,nsvp,
     -            0)
                nmc1=nmc
                call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -            nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -            nmchinc,incrun,ia0,c,incc,nrecread,uusfac,icpu0,nsvp,
     -            0)
                nmc2=nmc
c               Reopen the trajectory
                call opentraj(filenames(3),namlens(3),nstta,nslv,nsvp,
     -            c,incc,nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,
     -            numrec(3),0,uusfac,edgexyz,ieof,nconnfail)
                if (ieof .gt. 0) then
                  nsavefreq=nmc2-nmc1
                  if (mod(navgpx,nsavefreq) .ne. 0) then
                    write (iout,2250) navgpx,nsavefreq
                    nwarn=nwarn+1
                  end if
                  if (nsavefreq .gt. navgpx) then
                    write (iout,2251) navgpx,nsavefreq
                    nwarn=nwarn+1
                  end if
                end if
C@DM                end if
C@DM                call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,
C@DM     -            ierr)
C@DM                if (inperr .gt. inperr0) call datprt(-1)
                nmc=nmcstart
              else
                nmc=0
              end if
C@DM            if (MYRANK .eq. 0) then
              if (ichkp .eq. 0) call fileopen(file,namlenf,filenames(1),
     -          namlens(1),1,0,numrun,1,0,1,iop(24),iversout,iout,
     -          ichkp,0)
              if (ichkpx .eq. 0) call fileopen(file,namlenf,
     -          filenames(6),namlens(6),6,0,numrun,1,0,1,iop(24),
     -          iversout,iout,ichkpx,0)
C@DM            end if
              if (iop(160) .ne. 2) then
                call inicac
                call findor(orient,orientsltm,c,crm,crm0,iconfread,
     -            iop47read)
                call setuppx(nmolec,newrfs,0)
                call disinipx(nsltpx1,nsltpx2,
     -            rpxdivi,rpxwwdivi,rgpxsltmax,rgpxwwmax)
                if (nrans .eq. 0) call initgenvol(ifrsdim,ndimgen,
     -              nsltpxgr,nsltpx1,nsltpx2,iop(164),newrfs)
              end if
            else
              if (iop(67) .eq. 1 .and. mapedone .eq. 0) then
                write (iout,2277)
                inperr=inperr+1
              end if
            end if
C@DM            if (MYRANK .eq. 0) then
            call echopr(0)
            call echoprpx
C@DM            end if
            call checkdisc(npxmax,nmcpxdsc,iout,inperr)
            if (inperr .gt. 0) then
              if (MYRANK .eq. 0) write (iout,2043) inperr
              call datprt(-1)
            end if
            call trnsfi(mainkeyu,mainkeyun,nmainkey)
            if (iop(160) .eq. 1 .or. iop(160) .eq. 2) then
              if (npxmax .ge. nmc) then
C@ND                call pxscan(ihist,ichkp,ichkpx,inpt,iout,nwarn,
C@ND     -            nconnfail,orient,c,crm,texslt,incc,volav,iskip1,
C@ND     -            numrec(3),uusfac,nstta,nsvp)
C@DM                call mpi_pxscan(ihist,ichkp,ichkpx,inpt,iout,nwarn,
C@DM     -            nconnfail,orient,c,crm,cgs,molcnt,texslt,incc,volav,
C@DM     -            iskip1,numrec(3),uusfac,nstta)
              end if
            else
              call disperpx(orient,c,crm,texslt,ifailpx)
              call genvol(nranpx,nranpxw,1,1,0,0.0,0,c,crm)
            end if
C@DM            call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM            if (MYRANK .eq. 0) then
            call disfinpx(numrun,volav)
            call csave(ichkp,1,inperr,1)
            if (nconnfail .gt. 0) write (iout,2112) nconnfail
C@DM            end if
C@DM            call MPI_Bcast(inperr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM            call MPI_BARRIER(MPI_COMM_WORLD,ierr)
            if (inperr .gt. 0) call datprt(-1)
            iop(10)=0
            call gatherckpfiles(iout,ichkp,ichkpx,iop(24))
            numrun=numrun+1
            ickpread=0
C@DM            if (MYRANK .eq. 0) then
            write (iout,2059) numrun
            if (ihist .gt. 0) then
              write (iout,2083) numframe,numrec(3)
              if (nhstvers .gt. 1) write (iout,2101)
              nhstvers=1
            end if
            call switchfiles(numrun,inpt,iout,0)
C@DM            end if
          end if
        else if (key0 .eq. 'TIQU') then
c---------Run TI quadrature
          if (key .ne. 'DATA')
     -      call decode(tiqu,ntiqu,ndummyu,keyno1,key1,0)
          call tiquad(key,key1,tiinteg,MYRANK)
          itiquad=1
        else if (key0 .eq. 'WMAT') then
c---------Run matching of US runs
          call decode(wmat,nwmat,ndummyu,keyno1,key1,0)
          call decode(wmat2,nwmat2,ndummyu,keyno2,key2,0)
          call decode(wmat3,nwmat3,ndummyu,keyno3,key3,0)
          call getint(nruns,1,1,0)
          call checkdim(ifail,iout,inperr,'WM',nruns,1,1,0)
          if (ifail .gt. 0) call datprt(-1)
          numrun0=numrunr
          if (key .eq. 'REGL') then
            call getint(numrunr,1,1,0)
            call getint(incrnumrun,0,1,1)
            do i=1,nruns
              matchrun(i)=numrunr+(i-1)*incrnumrun
            end do
          else
            do i=1,nruns
              call getint(matchrun(i),1,1,0)
            end do
          end if
          call wmatch(nruns,matchrun,keyno1-1,keyno2-1,keyno3,numrun0)
        else if (key0 .eq. 'OVRA') then
c---------Evaluate overlap ratio free energy
          call getint(numrun1,1,1,0)
          if (numrun1 .eq. 0) numrun1=numrun
          call getint(numrun2,1,1,0)
          if (numrun2 .eq. 0) numrun2=numrun
          if (numrun1 .eq. numrun2) then
            write (iout,2062)
          else
            call fileopen(file,namlenf,filename1,namlen1,2,0,
     -        numrun1,1,2,1,iop(24),iversout,iout,ichkp1,0)
            call fileopen(file,namlenf,filename2,namlen2,2,0,
     -        numrun2,1,2,1,iop(24),iversout,iout,ichkp2,0)
            write (iout,2072) filename1(1:namlen1),filename2(1:namlen2)
            call ovrrat(ichkp1,ichkp2)
          end if
        else if (key0 .eq. 'OPTN') then
c---------Input directly an option (developpers' option)
          call getint(niopin,1,1,0)
          do i=1,niopin
            call getint(iopin,1,1,0)
            if (iopin .lt. 1 .or. iopin .gt. 120) then
              write (iout,2086) iopin
              nwarn=nwarn+1
            else
              call getint(iop(iopin),1,1,0)
            end if
          end do
        else if (key0 .eq. 'TEST') then
c---------Extra calls (developpers' option)
          call testcode(key,cpl,iconfread,file,namlenf, filenames,
     -      namlens,dihang,ifirstm,ilastm,c,crm,crm0,orient,orientsltm,
     -      cic,nmc,ncnfpx,nslv,nsttm,nstta,ntang,nmolec,natoms,ic00,
     -      ic01,g0cpl,wcplus,molcnt,rlcslv,ianslv,icompopt,iout,ichkp,
     -      ichkpx,inperr,nwwarn)
        else if (key0 .eq. 'DBUG') then
c---------Set debug options (developpers' option)
          call getint(niopin,1,1,0)
          do i=1,niopin
            call getint(idbg,1,1,0)
            if (idbg .lt. 1 .or. idbg .gt. 200) then
              if (MYRANK .eq. 0) write (iout,2086) idbg
              nwarn=nwarn+1
            else
              call getint(idebug(idbg),1,1,0)
            end if
          end do
          if (idebug(13) .gt. 0 .and. MYRANK .eq. 0) then
            write (iout,2029) nmainkey,ifrst+1
            do ik=1,nmainkey
              write (iout,2076) ik,mainkey(ik),nodupwarn(ik),
     -          (iopkey(k,ik),k=1,3),
     -          (keys01(kk),kk=ifkey1(ik),ifkey1(ik)+nkey1(ik)-1)
            end do
          end if
        else if (key0 .eq. 'PLCV') then
c---------Plot progress of convergence in Postscript
          call plotprogress(key,numrun,tiinteg,itiquad,inperr,iout)
        else if (key0 .eq. 'WPLT' .or. key0 .eq. 'RAUS') then
          if (key0 .eq. 'WPLT') then
c-----------Plot individual AUS iterations
              if (iop(51) .lt. 1) then
              inperr=inperr+1
              write (iout,2040) 'WPLT'
            end if
            call getname(filename1,namlen1,1,80)
            open (file=filename1(1:namlen1),form='FORMATTED',
     -        status='UNKNOWN',unit=8)
            call getint(nfstplt,0,1,1)
            call getint(maxit,0,1,iterw)
            call getint(nfrplt,0,1,1)
            call getint(nrad,0,0,5)
            call plotiter(8,keyno,maxit,nfstplt,nfrplt,nrad,beta,
     -        iopnrm,fcintra,iout)
            close (8)
          else if (key0 .eq. 'RAUS') then
c-----------Reinput AUS parameters
            if (iop(51) .lt. 1) then
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,2040) 'RAUS'
            end if
            cplmin_prev=cplmin
            cplmax_prev=cplmax
            call readpmf(inpt,iout,iopnrm,iopeql,iopenc,nitssk,faclim,
     -        fcenc1,smplmx,ratmax,rldvmx,diffmx,ngovmn,nsubmn,ngrcor,
     -        negitdel,nwtst,fcenc2,encexp,tolera,cplmin,cplmax,
     -        delcpl,c0cplh,p0cplh,wcplcha,iop(24),iop(51),iop(55),
     -        MYRANK)
            if (cplmin .ne. cplmin_prev .or.
     -          cplmax .ne. cplmax_prev) then
              inperr=inperr+1
              if (MYRANK .eq. 0) write (iout,2049)
            end if
            if (iop(120) .eq. 2) call trnsfi(nfisum_prev,nfisum,#WG)
            if (iop(120) .eq. 3)
     -      call inicpl(faclim,cplpar,cplimn,cplimx,iop(51),tolera)
            irectx=9
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1007,err=980) iterw0,newlim
            if (iop(24) .gt. 0) write (iout,1309) iterw0,newlim
            if (iterw0 .ne. 0) then
              if (iterw0 .lt. 0) iopeql=0
              call scrnit(1,isetac,nitdel,nsubmn,ngovmn,diffmx,iterw0,
     -          beta,iopnrm,nwwarn,iout,MYRANK)
              call wadapt(ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,
     -          rldvmx,ngrcor,iopnrm,iop(55),nitssk,iop(16),nwtst,
     -          iopeql,iopenc,negitdel,iop(24),nsubmn,ngovmn,diffmx,
     -          iout,ichkp,nwarn,nwwarn,cplpar,cplimn,cplimx,beta,1,nmc,
     -          MYRANK)
            end if
          end if
        end if
c       Activate the forbid list of this keyword
        if (key0 .ne. 'OPTN') then
          call getlist(forbid,500,newlist,n,key0)
          do i=1,n
            call markused(newlist(i),mainkey,nmainkey,keyforbid,
     -        key0,forbidk0)
          end do
        end if
c       See if there is an other command on the line
1111    if (icol .gt. 0) call nextchar(line,icol,0,inpt,iout)
      end do
C@DM      call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM      call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      if (nmcrep .gt. 0) then
C@DM        call MPI_Bcast(ichkp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
        if (key .eq. 'SLFT' .and. ichkp .ne. 0) then
          call find('SLFT',1,nmainkey,mainkey,keyno,4)
          call decode(keys01(ifkey1(keyno)),nkey1(keyno),ndummyu,
     -      keyno,key,1)
          nmolck=-1
          if (key .eq. 'ALL ') call getint(nmolck,0,1,nmolec)
          if (nmolck .gt. nmolec) then
            nmolck=nmolec
            nchng=nchng+1
            write (iout,2004)
          end if
          if (keyno .eq. -1) keyno=2
C@DM          if (MYRANK .eq. 0) then
          call fileclose(ichkp,0,iop(24),iout)
          call fileopen(file,namlenf,filename1,namlenf1,
     -      1,0,numrun,1,3,1,iop(24),iversout,iout,ichkp,0)
C@DM          end if
          call selftest(keyno-1,iop(94),nfail,-nmolck,1,1)
C@DM          if (MYRANK .eq. 0) then
          call fileclose(ichkp,1,iop(24),iout)
C@DM          end if
        end if
      else if (key .eq. 'SLFT') then
        nchng=nchng+1
        if (MYRANK .eq. 0) write (iout,2159)
      end if
      call getunitnos(iunitnos,1)
      call datprt(1)
980   call invalidform(iout,irectx)
      call datprt(1)
981   call invalidform(iout,irectx)
      write (iout,2339)
      write (iout,2239) nmcwrite
      call datprt(1)
1000  format(a80)
1001  format(f14.12)
1002  format(i4)
1003  format(i6)
1005  format(10f8.3)
1006  format(' Centers of the periodic cells:',/(i5,3f15.6))
1007  format(2i5,3f10.0)
1008  format(a)
1010  format('GRASP PDB FILE',/,'FORMAT NUMBER=',i1)
1011  format('* = ',a)
1012  format(10f7.0)
1013  format(3f5.2,i5,5f10.5)
1014  format('*',/,i5)
1021  format(1x,a4,4f10.0,i5,2a1,2a4,i5,1x,a4,a8)
1121  format(1x,a6,4f10.0,i5,2a1,2a4,i5,1x,a4,a8)
1022  format(5x,i5,a1,a4,1x,a4,3f10.0,10x,f10.0)
1023  format(11x,a1,a4,1x,a4,1x,i4,4x,3f8.0,2f6.2)
1024  format(3f10.0,6i5,2i10)
1026  format(1x,a4,4f10.0,2x,a4)
1126  format(1x,a6,4f10.0,2x,a4)
1127  format(1x,a6,4f10.0,11x,a4)
1305  format(' rectype  5  : ',3f5.2,i5,5f10.5)
1309  format(' rectype  9  : ',4i5,6f10.4)
1314  format(i6,' rectype 14  : ',1x,a6,4f10.5,i5,2a1,2a4,i5,1x,a4,a8)
1315  format(' rectype ',i2,'  : ',a4,1x,a4,1x,i5,1x,i5,3f10.5,2f7.2)
1316  format(' rectype 15  : ',a6,4f15.5,2x,a4)
1345  format(' rectype 13  : ',2f10.5,f10.2,6i5,2i10)
1336  format(' rectype 27  : ',i5)
1337  format(' rectype 28  : ',10f7.3)
7866  format(i5,' iclslt=',i5,1x,a,' igrslt=',i5,' icnew=',i4,
     -  ' icorig=',i4,2x,2a4)
9359  format(' ***** ERROR: number of data points in the force-bias ',
     -  'scaling is > 9 :',i5)
2000  format(//,10x,' Canonical, grand-canonical and isothermal/',
     -  'isobaric ensemble Monte Carlo simulations and their ',
     -  'analysis',/,50x,'===  Mihaly Mezei ===',//,
     -  ' Computer word size:',i3,' bits  Largest real and double=',
     -  2e9.2,' Number of bits per word in a bitmap=',i3,/,
     -  ' Maximum number of atoms=#NA, solvents+1=#MO,',
     -  ' solute atoms=#ST, solvent atoms/molecule=#SV')
2001  format(' ***** ERROR: atoms of moving solute molecules do not ',
     -  ' form continguous molecules',/,
     -  ' Range of affected atoms: ',i6,' - ',i6)
2002  format(' ***** ERROR: torsion definitions (TORD) must precede ',
     -  ' initial configuration generation')
2003  format(' ***** ERROR: non free energy runs can not have non-zero',
     -  ' number of free energy atoms in the SLTA line')
2004  format(' >>>>> OVERRIDE: number of self tests reset to',i5)
2005  format(' Input line',i6,' : ',a)
2006  format(' ----- WARNING: only 2 title lines are allowed, ',
     -  ' subsequent TITL lines are ignored')
C@DB2007  format(' Number of main keywords=',i3,' Length of the main list=',
C@DB     -  i4)
2008  format(' ----- WARNING: keyword ',a4,' in line ',i4,
     -  ' is used repeatedly before RUN')
2009  format(' ***** ERROR: keyword ',a4,' requires prerequisite',
     -  ' keyword ',a4,' in line ',i4)
2010  format(' ***** ERROR: keyword ',a4,' in line ',i4,
     -  ' can not follow key ',a4)
2011  format(' MMC> ',$)
2012  format(' >>>>> OVERRIDE: grid shifting frequency set to zero for',
     -  ' random insertion strategy')
2013  format(' ===== STRONG WARNING: loop closing tolerance is too ',
     -  'large:',f8.5)
2014  format(' ***** ERROR: Cannot change solute copy number',
     -  ' for single copy')
2015  format(/,' +++++ Third solute conformation has been inserted and',
     -  ' at coupling parameter value=',f8.5,/)
2016  format(' +++++ Third solute conformation has been eliminated ')
2017  format(' ***** ERROR: for now, RCK* does not work with LIMG')
2018  format(' +++++ Checkpoint file is restored from file ',a,
     -  ' Nmc=',i10)
2019  format(' ***** ERROR: Initial dielectric constant (',f6.2,
     -  ') exceeds bulk dielectric constant (',f6.2,')')
2020  format(' ***** ERROR: key OVST requires free energy solute atoms')
2021  format(' Second solute copy will be overlapped with the first ',
     -  ' by trying to match solute atoms ',3(2x,a4,1x,i5))
2022  format(' >>>>> OVERRIDE: number of solute atoms to print is ',
     -  ' reset to ',i6)
2023  format(' ***** ERROR: solute atom index for solute overlap',
     -  ' is out of bound:',3i5)
2024  format(' +++++ Proximity analysis checkpoint file is restored',
     -  ' from file ',a,' Nmc=',i10)
2025  format(' ***** ERROR: Random points can not be added at',
     -  ' this time')
2026  format(' ***** ERROR: All solute atoms are FE atoms - nothing ',
     -  'left to be moved/rotated by PARD')
2027  format(' >>>>> OVERRIDE: Solvent rotation angle changed to zero',
     -  ' from',f8.3,' since there is only one solvent atom')
2028  format(' +++++ Solute COM is reset to the cell center',
     -  ' by a shift of ',2(f8.3,', '),f8.3,' A')
2029  format(' Number of main keywords=',i4,' length of the keyword',
     -  ' list=',i4)
2030  format(' Solute-solvent average Coulomb energy',
     -   ' will be calculated using the initial configuration')
2031  format(' Solute-solvent average Coulomb energy=',
     -   f15.5,' kcal/mole. Coulomb US mixing parameter is=',
     -   f15.5,' it corresponds to a bp=ba-ussca of',f15.5)
2032  format(' +++++ Solute coordinates c0,c1 on file ',a,' have',
     -  ' been permanently modified to',/,
     -  20x,'(1-',f7.4,') * c0 + ',f7.4,' * c1  and (1-',f7.4,') *',
     -  ' c0 + ',f7.4,' * c1')
2033  format(5x,'with the assumption that the',
     -  ' solute coordinates c0,c1 on file ',a,' have been',
     -  ' already previously modified to',/,
     -  20x,'(1-',f7.4,') * c0 + ',f7.4,' * c1  and (1-',f7.4,') *',
     -  ' + ',f6.4,' * c1',/)
2034  format(' ***** ERROR: Number of solute atoms to move (',i5,') is',
     -  ' more than the number of non FE solute atoms (',i4,')')
2035  format(' ***** ERROR: can not pre-combine solutes with ',
     -  ' EPEN/QPEN')
2036  format(' ***** ERROR: coupling parameter (',f6.3,') is ',
     -  ' outside the umbrella sampling range',2f10.4)
2037  format(' ***** ERROR: maximum number of MC runs allowed ',
     -  ' with one input (999) is exceeded')
2038  format(a,'heckpoint file is saved on file ',a,' at Nmc=',i10)
2039  format(' ----- WARNING: the configurations recorded',
     -  ' on the history file (',a,') would not reflect',
     -  ' the correct sampling.',/,' nmcrec was incremented by 1')
2040  format(' ***** ERROR: key ',a4,' is only valid for FREE PMF1 ',
     -  ' **** **** AUS* runs')
2041  format(' ***** ERROR: Global potentials can read at most 10 real',
     -  ' and 10 integer data values')
2042  format(' Current coordinates are saved on file ',a)
2043  format(' ***** Run ABORTED due to ',i4,' input ERRORs')
2044  format(' Number of atoms left=',i8,' number of solute atoms ',
     -  'left=',i7)
2045  format(' ***** ERROR: invalid number of Gaussian quadrature ',
     -  'points:',i3,' (only 3, 5 and 8 are valid for now)')
2046  format(' ***** ERROR: Gaussian quadrature number',i3,' is ',
     -  'invalid with a',i2,'-point quadrature')
2047  format(' ***** ERROR: Solute atom charges appear to be zero - ',
     -  'can not base proximity criterion on them')
2048  format(' ***** ERROR: file ',a,' was not found on restart')
2049  format(' ***** ERROR: Coupling parameter range can not be ',
     -  'modified with the RAUS key')
2050  format(' ***** ERROR: Info missing form this checkpoint file')
2051  format(' Solute molecule pairs with energies above ',e12.5,
     -  ' kcal/mol will be pulled apart by ',f5.2,' A along their',
     -  ' intercenter line',/,
     -  ' and the flexible torsion angles (if any) will be incremented',
     -  ' by ',f8.2,' deg if the intramolecular energy exceeds this ',
     -  'threshold')
2052  format(' ***** ERROR: AUS parameters have to be changed',
     -  ' with the RAUS key')
2053  format(' ***** ERROR: Can not SCAN TRAJ without TRAJ')
2054  format(' Compilation options for data on checkpointfile ',a,':')
c2055  format(' ***** ERROR: Keyword PROT is valid only with ',
c     -  'general solvent')
2056  format(' ***** ERROR: Input trajectory is unspecified - use the ',
     -  'key TRAJ')
2057  format(' ***** ERROR: The keyword PROT can only be used',
     -  ' before the first RUN')
2058  format(' Repeating the grid list generation with cavity radius=',
     -  f8.2,' A')
2059  format(' +++++ Run number is incremented to ',i3)
C@DM2060  format(' ===== STRONG WARNING: HRDW key is ignored when the',
C@DM     -  ' MPI code is compiled (C@DM)')
2061  format(' ***** ERROR: Solute molecule stepsize tunig requires',
     -  ' alternating translation and rotation - see  key MVRT')
2062  format(' ***** ERROR: Overlap ratio checkpoint file ',
     -  'runnumbers have to be different')
2063  format(' ===== STRONG WARNING: potential labels longer than 4 ',
     -  'characters were found - some options may fail')
2064  format(' ***** ERROR: Random number list file ',a,' did not open')
2065  format(i10,' random points are generated and written on file ',a,
     -  ' for solute atoms from iat=',i5,' to iat=',i5)
2066  format(i10,' additional random points are generated')
2067  format(5x,' Proximity region atoms will labeled as be residues ',
     -  i5,' to ',i5,3x,' Maximum number of points written per solute ',
     -  ' atom=',i5)
2068  format(5x,' Points within the first shell radii will be written')
2069  format(5x,' Points with proximity distance less than ',f5.2,
     -  ' A will be written')
2070  format(' ***** ERROR: Can not filter this  trajectory format')
2071  format(/,' The estimated volume of the solute is ',f12.4,' A^3 ',
     -  '(sd=',f10.4,') based on rslv=',f6.3,' A and ',i4,
     -  ' randomly shifted grids')
2072  format(' Overlap ratio calculations between checkpoint files ',
     -  a,' and ',a)
2073  format(' ----- WARNING: New file name root was read: ',a,
     -  ' - all open files are closed')
2074  format(' +++++ Starting configuration generated from a ',
     - 'configuration on file ',a)
2075  format(' ***** ERROR: built-in water description can not be ',
     -  'read. You have to use SVPT GENL')
2076    format(i4,' key=',a4,' nodupwarn=',i1,' iopkey=',3i4,
     -  ' keys=',15(a4,1x),/,20(a5))
2077  format(' +++++ Number of solvents removed from the forbidden ',
     -  'slab=',i5,' Number of solvents left=',i7)
2078  format(' Solute coordinates have been regenerated from torsion ',
     -  'angles - maximum atomic deviation found=',f8.4)
2079  format(/,' Solute functional group and neighbour list')
 
2081  format(' ***** ERROR: trajectory file is missing for CNFG TRAJ')
2082  format(' ***** ERROR: Coordinate file is missing for FILT CONF')
2083  format(' Number of frames in the history file=',i6,
     =  ' number of records=',i7)
2084  format(' ***** ERROR: auxiliary coordinate file run number (',i2,
     - ') is not different from current run number')
2085  format(' ----- WARNING: no fixed solute atom was found, solute ',
     -  'global COM is based on all solute atoms')
2086  format(' ----- WARNING: invalid option number: ',i4,' - value ',
     -  'ignored')
2087  format(' >>>>> OVERRIDE: Nonpositiv dielectric constant read ',
     -  ' set to 1.0 instead')
2088  format(' ***** ERROR: number of solute atoms to move with PARD',
     -  ' does not define full molecules',/,7x,'NOTE: if the moving ',
     -  'solute atoms are the last solute atoms then the input ',
     -  'nsltpardis should be negative')
2089  format(' ***** ERROR: configuration with cloned solute can only ',
     -  'be read from a .crd or from a .hst file or generated randomly')
2090  format(' ***** ERROR: cloned atom range ',i5,' - ',i5,' is not ',
     -  ' above previous cloning ranges')
2091  format(' ***** ERROR: free energy atoms can not be cloned')
2092  format(' ***** ERROR: invalid cloning information:',i5,' - ',i5,
     -  ' *',i4)
2093  format(' ***** ERROR: maximum number of cloning (10) has been ',
     -  ' exceeded - redimension the common block /clone/')
2094  format(' ***** ERROR: invalid free energy atom numbers: nstfa0=',
     -  i5,' nstfa=',i5,' nstta=',i5)
2095  format(' ----- WARNING: Both data columns will have the same ',
     -  'data:',a4)
2096  format(' ----- WARNING: No proximity information - last two ',
     -  'columns might be zero')
2097  format(' ***** ERROR: free energy atoms can not be moved')
2098  format(' ***** ERROR: potential labels for general solvent ',
     -  '(',a,') was not recognized')
2099  format(' ***** ERROR: solvent atom type number (',i5,') is out ',
     -  'of the [1,',i3,'] range')
2100  format(' >>>>> OVERRIDE: SCAN TRNC was changed to SCAN TRAJ ',
     -  'since this is the first SCAN')
2101  format(' +++++ Version number of the history file is reset to 1',
     - ' Use a new TRAJ command if different value is needed')
2102  format(/,' +++++ Solute molecules are spread out in the x-y ',
     -  'plane and saved on file ',a,' in PDB format')
2103  format(' ===== STRONG WARNING: this analysis assumes that the ',
     -  'first three atoms of the solvent are O, H, H')
2104  format(' >>>>> OVERRIDE: a proximity information file was ',
     -  'already open - closing it')
2105  format(' ***** ERROR: a moving solute molecule includes a group',
     -  ' that was shared by two or more molecules.',/,' Range of',
     -  ' affected atoms: ',i6,' - ',i6)
2106  format(' ***** ERROR: number of keys in the program (',i4,') ',
     -  'exceeeds dimensions of mainkey arrays (',i4,')')
2107  format(' ===== STRONG WARNING: ',a4,' trajectory is written ',
     -  'without default solute atom and residue names (element symbol',
     -  ' residue no)')
2108  format(' >>>>> OVERRIDE: torsion coupling should specify only ',
     -  'one torsion copy')
2109  format(' ***** ERROR: shifting by edgexyz/2 is meaningful ',
     -  'only in rectangular cell')
2110  format(' ***** ERROR: the list of torsions can only be changed ',
     -  'in a run from Nmc=0',/,7x,' After restoring the checkpoint ',
     -  'file, ask for a continuing run of zero steps first')
2111  format(' ***** ERROR: RDFs were already collapsed - can not ',
     -  ' modify the RDF grouping. Start a new SCAN')
2112  format(' A total of ',i6,' structures had suspicious distances')
2113  format(' ***** ERROR: multiple solute copies require free energy',
     -  ' options')
C@PG2114  format(' Cavity/pocket occupancy calculation of trajectory ',a,
C@PG     -  ' First frame to use:',i6,' Last frame to use=',i6,
C@PG     -  ' Increment=',i4)
2115  format(' ***** ERROR: invalid potential library key:',a,
     -  ' for first shell radius input')
2116  format(' ***** ERROR: invalid potential key:',a4,' pflib:',a4,
     -  ' for ',a)
2117  format(' ----- WARNING: key ',a,' is used with averaged RDFs')
2118  format(' ***** ERROR: there are no water molecules but some of ',
     -  'the analyses requested require waters')
2119  format(7x,'Use either the FILE key first with run number ',i3,
     -  ' or the RUNS key (with 0 # of steps) to close all open files')
2120  format(/,' Proximity analysis table of the [',a,'.',i3,'] - [',
     -  a,'.',i3,'] differences')
2121  format(' ===== STRONG WARNING: Difference PDB file was requested',
     -  'without proximity difference calculation (PXTD)')
2122  format(' ===== STRONG WARNING: neither the PART key or FREE PMF1',
     -  ' TORS is present - torsion definitions will be ignored')
2123  format(' ***** ERROR: pair-energy distribution grid size is',
     -  ' zero')
2124  format(' >>>>> OVERRIDE: MC and analysis checkpoint file saving',
     -  ' frequencies are unequal:',2i10,' smaller one will be used')
2125  format(' ***** ERROR: stepsze weight exceeds 0.999')
2126  format(' ***** ERROR: run number on checkpoint file=',i4,
     -  ' - disagrees with inputted runnumber:',i4)
2127  format(' +++++ Number of atoms (',i7,') exceeds 99999 - file ',
     -  'format changed from ASCI to BNRY')
2128  format(' Solute molecules will be spread out in the ',a1,'-',a1,
     -  ' plane, ',a1,'=0 for the centers')
2129  format(' ----- WARNING: solute copy switch (SW23) is ',
     -  'incompatible with ',a,'* outputs - ASCI will be used instead')
2130  format(' Operation ',a4,' invalidates the conformation read')
2131  format(' ===== STRONG WARNING: reference file list is too short',
     -  ' - reference PDB file may be overwritten')
2132  format(' ===== STRONG WARNING: configuration number list is too',
     -  ' short - configuration file may be overwritten')
2133  format(' ===== STRONG WARNING: could not save the input ',
     -  'configuration to file ',a,/,
     -  ' without overwriting a previous one')
2134  format(' >>>>> OVERRIDE: key SHRT has been changed to SHON since',
     -  ' no torsions are active')
2135  format(' Average molecular RMSD=',f8.3,' A (',a,') minimum=',
     -  f8.3,' maximum=',f8.3)
2136  format(' ***** ERROR: Key LIMG should precede FREE WIDO/CHIM')
2137  format(' >>>>> OVERRIDE: neither translation, nor rotation was ',
     -  'specified - FREE PMF1 WRTR was changed to FREE PMF1 GENL')
2138  format(' ***** ERROR: FCC, HCP and TOCT PBC can only be used in',
     -  ' the GCE when either random insertions are used (GCEN UNBI) ',
     -  'or',/,14x,'the grid is inside the cell - use key LIMG (the',
     -  ' maximum edge of the inner rectangle allowed is',f10.5,' A)')
2139  format(' >>>>> OVERRIDE: all blank atomnames and/or residuenames',
     -  ' were replaced by chemical symbols and residue nos')
2140  format(' ***** ERROR: STUN ',a,1x,a,' is only valid after ',
     -  'STUN ',a,' PICL runs')
2141  format(' ***** ERROR: no proximity analysis has been run yet',
     -  ' - DBLG is meaningless')
2142  format(' ***** ERROR: invalid permutation of (1,2,3): ',3i4)
2143  format(' ***** ERROR: when groups are split up, SUUC MIGC does',
     -  ' not work - reaarrange solute or use SUUC MIMC or SUUC NONE')
2144  format(' Configuration comparison between configurations on file',
     -  /,a,' and ',a)
2145  format(' ***** ERROR: free energy solute is allowed to move in ',
     -  'all three directions - negates coupling parameter')
2146  format(' ***** ERROR: Voronoi analysis can only be done with ',
     -  'rectangular periodic boundary condition')
2147  format(' ***** ERROR: Voronoi analysis on trajectory is not ',
     -  'implemented yet')
2148  format(' ***** ERROR: solute rotation stepsize around the ',a1,
     -  ' axis is nonzero (',f6.3,') but the selection weight is zero')
2149  format(' Only suspect atoms/groups will be printed')
2150  format(' ----- WARNING: file ',a,' contains more than ',i6,
     -  ' records - first extra record:'/,1x,a)
2151  format(' ***** PROGRAM ERROR: nwcop,nmolec-1=',2i9)
2152  format(' ***** ERROR: coordinate file ',a,' already exists. ',
     -  'Random configuration can only be written to a new file')
2153  format(' ***** ERROR: key ',a,' requires a configuration but ',
     -  'no configuration was read')
2154  format(' Extending the system by its periodic replicas')
2155  format(' ***** ERROR: this function requires the PBCN key')
2156  format(' ***** ERROR: sphere and PHS boundary conditions ',
     -  'have no replica cells')
2157  format(' Original configuration has been restored. Restart the ',
     -  'program with new input to use the modified configuration')
2158  format(' ***** ERROR: invalid ',a,' range:',2i7)
2159  format(' >>>>> OVERRIDE: no MC was run, self test canceled')
2160  format(' >>>>> OVERRIDE: Grand-canonical ensemble requires ',
     -  'solvent - number of solvents is set to 1')
2161  format(' >>>>> OVERRIDE: proximity result sheet frequency has ',
     -  'been changed to ',i10,' to be a multiple of ',/,7x,
     -  'the checkpoint file saving frequency (',i10,')',/,
     -  ' ///// NOTE: the checkpoint file saving frequency can be set',
     -  ' by the CHKP key to override the automatic assignment')
2162  format(' ***** ERROR: Checkpoint file saving frequency (',i6,
     -  ') set with key CHKP is excessive - increse nrecd by ',
     -  'a factor of ',i6)
2163  format(a,' WARNING: Checkpoint file saving frequency (',
     -  i6,') set with key CHKP is high - increase nrecd by a ',
     -  'factor of ',i6)
2164  format(' ***** ERROR: no analysis was requested - SCAN or PXAN',
     -  ' keys have no effect')
2165  format(' ----- WARNING: ',a,'heckpoint file for run number ',i2,
     -  ' could not be removed')
2166  format(' +++++ ',a,'heckpoint file for run number ',i2,
     -  ' was removed')
2167  format(' ***** ERROR: some analysis was requested but analysis ',
     -  'frequency was not specified - use the PXAN key')
2168  format(' ***** ERROR: no solute potential was specified - ',
     -  'can not do energy-based filtering')
2169  format(' Trajectory file scan for filtering stopped at Nmc=',
     -  i10,/,' File scanned was: ',a)
2170  format(' ***** ERROR: number of solvent molecules in the ',
     -  'trajectory file (',i6,') differs form the inputted number (',
     -  i6,')',/,7x,'- Omit the NSLV key if this is legitimate')
2171  format(' ***** ERROR: can not save replicas in BNRY format')
2172  format(' ***** ERROR: can not generate random starting system',
     -  ' with PHS boundary conditions',/,
     -  5x,'Equilibrate first a full box')
2173  format(' ***** ERROR: nsavepx is not to be read with the current',
     -  ' syntax here')
2174  format(' >>>>> OVERRIDE: no random numbers will be generated ',
     -  'since proximity g(r) calculation was not requested')
2175  format(' ***** ERROR: primary g(r) calculations require random ',
     -  'points - change nranpx to a nonzero value')
2176  format(' >>>>> OVERRIDE: nsavepx is changed from zero to one')
2177  format(' ***** ERROR: can not write Charmm CRD ',a,' - number ',
     -  'of atoms (',i9,') exceeds 99999')
2178  format(' Average number of solvents left after filtering',i7,
     -  ' configurations=',f10.2,' Range: [',i6,',',i6,']')
2179  format(' >>>>> OVERRIDE: solute radius source is set to VdW ',
     -  'since no potential information was read')
2180  format(' ***** ERROR: invalid ',a,' limit order:',2f8.2)
2181  format(' ***** ERROR: invalid ',a,' limit order:',2i9)
2182  format(' Number or trajectory frames to read=',i10,/,
     -  ' Number or trajectory frames to write=',i10,/,
     -  ' Output trajectory format:',a,/,
     -  ' Trajectory version number will be incremented by',i4)
2183  format(' The first ',i10,' frames will be skipped')
2184  format(' ***** ERROR: Tsallis exponent must be > 1')
2185  format(' >>>>> OVERRIDE: PDB file only contained ',i6,a,'atoms')
2186  format(' Subsequent runs will save configurations in MMC ASCI ',
     -  'format')
2187  format(' The number of solvents found non-proximal to the ',
     -  'selected solute atoms: ',i6,/,' - use NSLV ',2i6,' to keep ',
     -  'these solvents from being moved')
2188  format(' ***** ERROR: the input trajectory format does not store',
     -  ' the energy use ECAL instead of ETRA')
2189  format(' ***** ERROR: key SIZE has been replaced by key NSLV:',/,
     -  7x,'NSLV <number of solvents> ',
     -  '[<number of solvents to keep fixed>]')
2190  format( ' ----- WARNING: recorded coupling parameter (',f8.5,
     -  ') disagrees with the value deduced from the solute coodinates',
     -  ' (',f8.5,') ',/,7x,' on file ',a)
2191  format(' ***** ERROR: GENS CCAL has to be preceded by RCKP')
2192  format(' ***** ERROR: Number of solute atoms (',i6,',',i6,') ',
     -  'differ for neighbor-based site match')
2193  format(' ***** ERROR: No solute atoms were given  for ',
     -  'neighbor-based site match')
2194  format(7x,'Note: nsltpard should refer to the solute atom ',
     -  'range BEFORE cloning')
2195  format(' ***** ERROR: Filtered trajectory with variable number',
     -  ' of solvents can not be written in ',a,' format')
2196  format(' >>>>> OVERRIDE: proximity analysis block size has been ',
     -  ' set to',i9)
2197  format(' ***** ERROR: hydrogen-bonded bridge calculation ',
     -  'requires water solvent')
2198  format(' >>>>> OVERRIDE: use of inner cutoff (key INCT) with ',
     -  'random initial configuration can freeze the system')
2199  format(' +++++ Input aborted due to errors in the data read ',
     - 'so far')
2200  format(' ----- WARNING: solvents will be ignored for the cavity',
     -  ' and pocket calculations')
c2201  format(' Solute has been shifted by ',3f10.5,' to center it ',
c     -  'in the cell',/,' Minimum distances of the solute to the cell ',
c     -  'wall in the x, y, z directions=',3f8.2,' A')
2202  format(' ***** ERROR: ',a,' map (file ',a,'.map) is missing')
2203  format(' ***** ERROR: H-bond neighbor grid limit (30) is ',
     -  'exceeded - modify the common block energymap')
2204  format(' ===== STRONG WARNING: solute extends beyond the cell ',
     -  'wall in the',1x,a1,'-direction - increase cell size by at ',
     -  'least ',f8.2,'A')
2205  format(' ***** ERROR: TORD INPT requires a positive number of ',
     -  'torsions - use TORD ALL to move all possible torsions')
2206  format(' ----- WARNING:',i6,' solute atoms have larger cavity ',
     -  'threshold than the value of rnearlim read with the PRTG key (',
     -  f5.1,')')
2207  format(' ***** PROGRAM ERROR: key ',a4,' is undefined')
2208  format(' ***** PROGRAM ERROR: neither configuration nor history ',
     -  'file was found on restart')
2209  format(' Only every',i5,'th frame will be used')
2210  format(' Reading map #=',i2,' Atno=',i2,' map file=',a)
2211  format(' ***** ERROR: only',i2,' error-free maps were read ',
     -  '(instead of',i2,')')
2212  format(' ***** ERROR: invalid coordinate indices: ',2i4)
2213  format(' >>>>> OVERRIDE: non-MMC solute input has no potential ',
     -  'type information - SUPT ',a,' is changed to SUPT ATNO')
2214  format(' +++++ Solute group information is replaced by solute ',
     -  'molecule information since molecule-based cutoffs are used')
2215  format(' ***** ERROR: energy decomposition can not use group-',
     -  'based cutoffs for solute-',a,' interactions only')
2216  format(' Number of acceptor oxygens within the grid map=',i4,
     -  ' Number of donor hydrogens (if any) within the grid map=',i4,
     -  /,' Maximum number of acceptor oxygens per cell=',i2,
     -  ' Maximum number of donor hydrogens (if any) per cell=',i2,/,
     -  ' Maximum number of donor hydrogens plus acceptor oxygens ',
     -  'per cell=',i2)
2217  format(' ***** ERROR: can not use CNFG TRAJ to start a  MC ',
     -  'simulation')
2218  format(' ----- WARNING: solute has not been specified yet - ',
     -  'specify the library to print with the SNGL key',/,
     -  7x,'Alternatively, this key can be moved after the SLTA key')
2219  format(' Trajectory extension read:', a)
2220  format(' ***** ERROR: ivalid trajectory increment information:',
     -  i6,' (only 0 or 1 is allowed)')
2221  format(' ----- WARNING: there are no solvents - PXSR or SPSR ',
     -  ' operations are meaningless')
2222  format(' ----- WARNING: no solvents were found',a,'proximal to ',
     -  'the selected solute atoms')
2223  format(' The proximity indices of the solvent molecules:',/,
     -  (1x,20i6))
2224  format(' Solvents ',a,' will be moved before the proximal ones')
2225  format(' Solvents moved will be within ',f7.2,' A of (',
     -  2(f7.2,','),f7.2,')')
2226  format(' Configuration will be written withour solvents')
2227  format(' ***** ERROR: No analysis was requested - PXYZ key is ',
     -  'invalid')
2228  format(' ***** ERROR: No proximity analyis was requested -',
     -  ' PXPL key is invalid')
2229  format(' Creating a preprocessor tailored to this system ',
     -  'to minimize memory use and checkpoint size')
2230  format(' ----- WARNING: No configuration was read - resulting',
     -  ' system may be too small')
2231  format(' >>>>> OVERRIDE: No fractional occupancies were ',
     -  'established - WCNF PDBO is changed to WCNF PDB')
2232  format(' ***** ERROR: Widom-type free energy run allows only ',
     -  'CNFG READ')
2233  format(' Configuration is tranlated by ',3f10.5)
2234  format(' Configuration is rotated by the matrix',/,(1x,3f10.6))
2235  format(' ***** ERROR: No pretransformation information - PRET ',
     -  'key is ignored')
2236  format(' ----- WARNING: key ',a,' is used without insertion/',
     -  'deletion statistcs key IDAC')
2237  format(' ===== STRONG WARNING: No ccheckpoint file was read - ',
     -  ' BTUN NONE and BTUN AVRG are ignored')
2238  format(' Tuning is turned off - ',a,' is used:',f8.4)
2239  format(' Number of frames in the filtered trajectory=',i8)
2240  format(' ***** ERROR: dimension parameter maxstmol (',a2,') can',
     -  ' not be less then maxhunsite (#',a2,')')
2241  format(' If you want a PDB file with the sites ordered by CV, ',
     -  ' use the SLTA and SLVA keys to match the second system')
2242  format(' Solute read differs from the solute specified with the',
     -  ' SLTA key - only the clustered sites will be printed')
2243  format('ATOM  ',i5,'  O   GS  S',i4,4x,3f8.3,3f6.2)
2244  format(' Solute atoms will be readjusted to their definition by ',
     -  'the SLTA key')
2245  format(' Modified configuration was saved on file ',a)
2246  format(' ***** ERROR: PBC cell is undefined - use the PBCN key')
C@DM2247  format(' ***** ERROR: maximum number of processors (',i4,') is ',
C@DM     -  'exceeded. Redimension the common block MPI_DM_ENG')
C@DM2248  format(' ***** ERROR: key ',a4,' can not be used with MPI for ',
C@DM     -  'now')
C@DM2249  format(/,' MPI initialized, Number of nodes used=',i4)
2250  format(' ----- WARNING: analysis frequency (',i8,') is not a ',
     -  'multiple of the saving frequency (',i8,')')
2251  format(' ----- WARNING: analysis frequency (',i8,') does not ',
     -  'exceed the saving frequency (',i8,')')
C@DM2252  format(' ***** ERROR: the only free energy option implemented ',
C@DM     -  'with MPI is FREE WIDO')
2253  format(' >>>>> OVERRIDE: No solute - solute sampling frequency ',
     -  'is set to zero')
2254  format(' Key ',a,' requires ERROR-free input - for now key ',a,
     -  ' will be ignored')
C@DM2255  format(' ***** ERROR: for now, the FILE option is not allowed ',
C@DM     -  'with MPI - use the READ key')
2256  format(' ***** ERROR: general',a,'solvent arrays are not ',
     -  'dimensioned properly set #',a2,' to #',a2)
2257  format(' ***** ERROR: GCE runs without solvent has to be started',
     -  ' with one of the RAN* options')
2258  format(' ***** ERROR: analysis or Widom-type calculation ',
     -  'concurrent with a simulation requires the PXAN key')
2259  format(' ***** ERROR: Widom-type calculation requires solute-',
     -  'solute cutoff (key SUUC) when there are more than one solute ',
     -  'molecules')
2260  format(' ***** ERROR: no solute atoms were found for ',
     -  'cavity/pocket calculation')
2261  format(' Standard ',a,' file ',a,' (unit',i3,') opened')
2262  format(' ***** ERROR: Problem opening file ',a)
2263  format(' ***** ERROR: PDB file contains no atoms')
2264  format(' >>>>> OVERRIDE: atom range upper limit (',i6,') is ',
     -  'reset to ',i6)
2265  format(' Replace the maximum number of donors+acceptors per ',
     - 'grid, maxnhbg (',i2,') with ',i3,' in the common block ',
     -  '/energymap/')
2266  format(' ***** ERROR: Hydrogen-bond ',a,' label ',a,
     -  ' is not defined')
2267  format(' ===== STRONG WARNING: Potential label ',a,' is not used',
     -  ' in the solute')
2268  format(' DEBUG: hydrogen-bond and desolvation ',a,' terms are ',
     -  'not calculated')
2269  format(' ***** POGRAM ERROR: ',a,' key ',a,
     -  ' is missing from the main key list')
2270  format(' ***** ERROR: each repeated RUNS requires a new SANN key',
     -  ' - use SANN NONE to turn off annealing')
c2271  format(' System will be centered along each coordinate direction',
c     -  ' if the midpoint deviates from zero by more than',f9.1,' A')
2272  format(' >>>>> OVERRIDE: result printing frequency changed to ',
     -  i9,' (it can not be less than the sampling frequency')
2273  format(' ===== STRONG WARNING: printing the full result for each',
     -  ' structure sampled will result in a very large output file')
2274  format(' ***** ERROR: atomindex of last atom of molecule',i4,
     -  ' (',i5,') is not greater than that of the previous molecule ',
     -  '(',i5,')')
2275  format(' ***** ERROR: periodic geometry fix requires full system',
     -  ' fixes as well (possibly less frequent)')
2276  format(' Functional group ',i3,':',1x,a4,' (',a,')')
2277  format(' ***** ERROR: energy map has to be re-read after restart',
     -  ' with SPST EMAP')
2278  format(' ***** ERROR: Number of gridpoints requested=',3i5,
     -  ' - minimum number is 2')
2279  format(' ***** ERROR: Number of solute atoms to move with the ',
     -  'key PARD (nsltpardis) is zero')
2280  format(' ----- WARNING: no maps were read for ',i2,' atom types')
2281  format('  ****** ERROR: Energy decomposition calculation needs ',
     -  'a potential choice with the SUPT key')
2282  format(' ****** ERROR: could not open all the new map files')
2283  format(' >>>>> OVERRIDE: ',a,'-axis selection probability was ',
     -  'set to zero since the corresponding stepsize is zero')
2284  format(' ****** ERROR: can not run the analysis since the ',
     -  'maximum matrix dimension is 1',/,'Recompile mmc with # GC ',
     -  'set to larger than the number of sites expected')
2285  format(' >>>>> OVERRIDE: CAEV or ONRM are ignored for GSAN HBTT')
2286  format(' ***** PROGRAM ERROR: change the 32 in the PARAMETER ',
     -  'statement to',i4,' in the subroutine disfinrestim and ',
     -  'recompile')
2287  format(' ***** ERROR: molecule limit given by the MOLD key (',
     -  i6,') exceeds the number of solute atoms (',i6,')')
2288  format(' ***** ERROR: molecule limit given by the MOLD key (',
     -  i6,') does not define the full solute (',i6,' atoms)')
2289  format(' ***** ERROR: no solute potential has been specified ',
     -  ' - use RFSL STOR instead of RSFL SIGM')
2290  format(' ***** ERROR: MC run trajectory should not have version ',
     -  ' number higher than 1 - change the TRAJ statement')
2291  format(' ***** ERROR: Repeat of configuration filtering needs a ',
     -  'structure read again by CNF*')
2292  format(' ===== STRONG WARNING: Cavity grid shift frequency is ',
     -  'too low, resulting in excess CPU time. Increase it to ',i8,
     -  ' or more')
C@DM2293  format(' ///// NOTE: Processor limits were established assuming ',
C@DM     -  'that the number of solvents fluctuate around',i6,/,7x,'If the',
C@DM     -  ' number of solvents deviates too much from this number, the ',
C@DM     -  'parallel efficiency will suffer',/,7x,'Change nslvxp in the ',
C@DM     -  'formatted input to the key GCEN to adjust')
C@DM2294  format(' ----- WARNING: expected number of solvents is too ',
C@DM     -  'close to the maximum (#MO)',/,7x,'- you may want to raise ',
C@DM     -  'maxmol (symbol #',a2,')')
2295  format(' ///// NOTE: the number of solute atoms to be moved ',
     -  'should refer to the solute atom list BEFORE cloning')
2296  format(' ///// NOTE: Configuration file ',a,' was already ',
     -  'open - it had to be closed')
2297  format(' ***** ERROR: file root name is too long')
2298  format(' ===== STRONG WARNING: file root name is long enough to ',
     -  'generate too long file names')
2299  format(' ***** ERROR: invalid solute atom range for CV ',
     -  'calculation: [',i8,',',i8,']')
C@DM2300  format(' ***** ERROR: CNFG RP** and CNFG PMFN is not allowed ',
C@DM     -  'with MPI for now')
2301  format(' ***** ERROR: hydrogen bond calculations were requested ',
     - 'by the ENHB key but no donor acceptor information was found')
2302  format('REMARK E=',e16.8)
2303  format(' Lowest energy conformation (E=',e16.8,' kcal/mol) at ',
     -  'nMC=',i9,' saved in file ',a)
C@PG2304  format(/,10x,'=== Calculating the solvent occupancy of the ',
C@PG     -  'cavities in the solute ===',/,' Solvent radius=',f5.2,' A',/,
C@PG     -  ' Grid sizes in the X, Y, and Z direction:',3f7.4,' A')
2305  format(' ***** ERROR: zero solvent diameter is incompatible with',
     -  ' cavity biasing - switch to GCEN UNBI')
C@PG2306  format(' >>>>> OVERRIDE: Cavity solvent save for trajectory ',
C@PG     -  'scan is not implemented - SAVE key is ignored')
C@PG2307  format(i4,' cavity-occupying solvents were saved with the solute',
C@PG     -  ' on file ',a)
C@PG2308  format(' Cavities with fewer than ',i6,' gridpoints (smaller ',
C@PG     -  'than ',f7.1,' A^3) will be ignored',/)
2309  format(' ***** ERROR: parameter rnearlim is too short (it is ',
     -  'smaller than all atomic radii used for cavity definition')
2310  format(' ///// NOTE: status report below is incomplete')
2311  format(' ***** ERROR: only 3, 5 and 8-point quadratures are ',
     -  'implemented')
2312  format(' ***** ERROR: quadrature point index (',i3,') exceeds ',
     -  'the number of quatdrature points (',i2,')')
2313  format(' ***** ERROR: for now, FLXR and CLON keys can not be ',
     -  'used together')
2314  format(' ***** ERROR: the FLXR key requires MMC input format')
2315  format(' ***** ERROR: the FLXR key requires reading from a file')
2316  format(' ***** ERROR: number of solute atoms read (',i6,') is ',
     -  'different from the number of solute atoms specified (',i6,')')
2317  format(' List of bonds established from the input (printed to ',
     -  'assist cleaning up the data):')
2318  format(' ***** ERROR: SPST C**** requires the FLXR key')
2319  format(' ***** ERROR: key FLXR is only compatible with CNFG READ',
     -  ' or CNFG RANI or CNFG RANC')
2320  format(' >>>>> OVERRIDE: WCNF *** FULL is ignored without the ',
     -  'FLXR key')
2321  format(' Structure saved will contain all atoms')
2322  format(' >>>>> OVERRIDE: simulated annealing turns on the saving',
     -  ' of minimum energy conformation - see  key MINE')
2323  format(' ***** ERROR: number of atoms/solvent (maxslv) hsa to be',
     -  ' at least 5 - change # SV and recompile')
2324  format(' ***** ERROR: solute potential type AMBR (original ',
     -  'Kollman et al. ff) has been removed. Use AM94 or AM02 instead')
2325  format(' ***** ERROR: invalid ',a,' character (',a,') in line',/,
     -  1x,a)
2326  format(' Number of flexible residue ranges=',i4,' ranges ',
     -  'generated from the CA atom list:',/,(5(i8,' - ',i6)))
2327  format(' ***** ERROR: number of residue ranges exceeds limit ',
     -  '(',i4,') -increase the size of the array iafltrange')
2328  format(3(' Range of mobile atoms in the ',a,' direction: [',
     -  f6.1,',',f6.1,'] range extent=',f6.1,' center=',f6.1,/),
     -  ' Grid center coordinates:',3f10.2,' Edge=',f10.2)
2329  format(1x,a,' distance from the box:',/,(8x,'in the -',a1,
     -  ' direction=',f5.2,' in the +',a1,' direction=',f5.2))
2330  format(' ----- WARNING: constraints were inactive - nothing  to',
     -  'turn off')
2331  format(' ***** ERROR: residue numbers in the flexible residue ',
     -  'list are not monotonously increasing:',2(' ir(',i4,')=',i6))
2332  format(' ***** ERROR: cloned segment #',i3,' (',i5,' - ',i5,')',
     -  ' cuts groups')
2333  format(' ///// NOTE: OPLS charges will be read from the .slt ',
     -  'file')
2334  format(' >>>>> OVERRIDE: number of random numbers to write reset',
     -  ' from ',i9,' to ',i9)
2335  format(i10,' random numbers (',i2,'digits beyond the decimal ',
     -  'point) were written to file ',a)
2336  format(' >>>>> OVERRIDE: # of random number digits to write (',i3,
     -  ') exceeds limit; changed to 12')
2337  format(' No cycle was detected')
2338  format(' Random number cycle found - length=',i10)
2339  format(' ///// NOTE: If the input used 4 characters for the ',
     -  'potential label, replace SLTA **** MMC with SLTA **** MMC4')
2340  format(' Older SLTA syntax (4-character PF labels) can be read ',
     - 'by replacing SLTA **** MMC with SLTA *** MMC4')
2341  format(' ***** ERROR: one and only one of clstfin_dmax and ',
     -  'nclust_clstfin can be non-zero')
2342  format(' ***** ERROR: the program is only dimensioned for',i10,
     -  ' random numbers to read',/,7x,'- increase # RN and recompile')
2343  format(' ***** ERROR: The RUNS key needs the STEP key when there',
     -  ' are no solvents and no part of the solute is changed')
2344  format(' ***** ERROR: record read is not a PDB atom record:',/,
     -  1x,a)
2345  format(' ----- WARNING: repeated defintion of the bulk solvent ',
     -  'layer found - the last one will be used')
2346  format(' ***** ERROR: the key BLKW can only be used with PBCN ',
     -  'RECT use the MOND key instead')
2347  format(' ***** ERROR: there are moving atoms way outside the ',
     -  'grid')
2348  format(' ===== STRONG WARNING: there are moving atoms slightly ',
     -  'outside the grid')
2349  format(' ***** ERROR: flexible residue range #',i3,' (',i6,' - ',
     -  i6,') is missing - tentative atom range:(',i6,' - ',i6,')',/,
     -  ' ia,nsttar,igrslt(ia)=',3i7)
2350  format(' Atoms in flexible residue range (input order) [',i6,',',
     -  i6,'] connected to fixed atoms:',10i7)
2351  format(' Anchor atoms of flexible region',i3,':',2i6)
2352  format(i6,1x,2a4,' Neighbours:',10(i7,1x,2a4))
2353  format(' Bond between flexible and fixed atoms:',i6,1x,2a4,' - ',
     -  i6,1x,2a4)
2354  format(' ===== STRONG WARNING: Number of flexible-fixed bonds ',
     -  '(',i2,') exceeds two - some spurious bonds may have to be ',
     -  'removed')
2355  format(' ***** ERROR: CNFG READ requires the FLXR key')
2356  format(' ***** ERROR: Number of solute atoms read (',i7,') does ',
     -  'not match the full solute (',i7,')')
2357  format(' Number of solute atoms reduced to',i6,' from ',i7)
2358  format(' ***** PROGRAM ERROR: Moving location (',i7,') is beyond',
     -  ' the original location (',i7,')')
2359  format(' ***** ERROR: Grid potential assumes implicit solvent - ',
     -  'set the number of solvents (key NSLV) to zero')
2360  format(' ***** ERROR: CNFG RRDEX is only valid for PDB or CHRM ',
     -  'formats')
2361  format(' ***** ERROR: ASCI version of the extracted structure ',
     -  'could not be saved since the file already exists',/,' Remove ',
     -  'the existing and new .crd file and run again')
2362  format(' ----- WARNING: coordinate fiile already exists - saved ',
     -  'as version 2')
2363  format(' ***** ERROR: MINE TRAJ requires the TRAJ key')
2364  format(' ***** ERROR: there are charged atoms but distance-',
     -  'dependent dielectric is turned off',/,' - activate the lines',
     -  ' commented out with C@DD')
2365  format(' >>>>> OVERRIDE: MINE WANF was changed to MINE WANN ',
     -  'since all atoms are treat explictly')
2366  format(' ///// NOTE: default topology (mkb, psf or top) file was',
     -  ' assumed. Specify a different file in the ',
     -  'RDBD line (without extension)')
2367  format(' Flexible residue range #',i3,' (',i5,' - ',i5,') ',
     -  'converted to atom range {',i6,' - ',i6,')')
2368  format(' ///// NOTE: trajectory writing was invoked with the ',
     -  'TRAJ key - saving of solvents as MODELs at each ',
     - 'annealing step is skipped')
2369  format(' >>>>> OVERRIDE: representative atom (',i4,') changed ',
     -  ' to',i5,' by G mark in the input file')
2370  format(' ***** ERROR: zero for the number of solvent atoms only',
     -  ' allowed when reading the solvent from a file')
2371  format(' ///// NOTE: action of self-test failures has been set ',
     -  'to ',a,/,7x,'It can be overridden by a subsequent SLFT key')
2372  format(' ***** ERROR: input trajectory has ot been opened')
2373  format(' >>>>> OVERRIDE: history file format set to PDB MODEL ',
     -  'as MODEL record was found')
2374  format(' ***** ERROR: solvent representative atom # (',i4,') is',
     -  ' greater than the number of solvent atoms (',i4,')')
2375  format(' ***** ERROR: CV cutoff (',f5.1,') is less than the ',
     -  'solvent diameter (',f5.1,') all calculated CV values will be ',
     -  'zero')
2376  format(' ===== STRONG WARNING: CV cutoff (',f5.1,') is less than',
     -  ' two solvent diameters (',f5.1,') - value is too small')
2377  format(' ----- WARNING: nonzero trajectory save frequency was ',
     -  'read but the no TRAJ key was used')
2378  format(' >>>>> OVERRIDE: zero trajectory save frequency was ',
     -  'replaced by th edafult:',i8)
2379  format(' >>>>> OVERRIDE: trajectory save frequency was set to ',
     -  'zero as no TARJkey was used')
2380  format(' ***** ERROR: BTUN AVRG has to be placed after a RUNS ',
     -  'commmand')
2381  format(' ***** ERROR: After reading the maximum number of ',
     -  'solvent atoms (',i4,') there are still records on the file')
2382  format(' ===== STRONG WARNING: non-MMC trajectory likely needs ',
     -  ' alttrajext input')
2383  format(' >>>>> OVERRIDE: partial solute ',a,' moves disabled')
2999  format(' ----- WARNING: run out of data (use the key STOP to ',
     -  'avoid this warning)')
C@DM3000  format(' MPI in driver key0=',a4,' MYRANK=',i3,' nfblam=',i3)
C@DM3001  format(' MPI in driver key0=',a4,' MYRANK=',i3,/,
C@DM     -  5(i4,' rfblam,afblam=',2f10.5))
 
C@DD3003  format(' ***** PROGRAM ERROR: Non-positive argument for the ',
C@DD     -  'logarithm with dielectric constant threshold=',f6.2)
C@DD3004  format(' Mehler-Somayer DD dielectric reciprocal table:',/,
C@DD     -  (5(' r=',f4.1,' 1/eps=',f8.4)))
3005  format(' ***** ERROR: could not open map file ',a,/,7x,'If the ',
     -  'map files have already been created use SPST EMAP')
3006  format(' ***** PROGRAM ERROR: ',i5,'-th donor/acceptor points to',
     -  ' atom ',i5,' but ihbdonacc is zero')
3007  format(' Number of atoms contributing to the energy maps=',i5)
3008  format(' ***** ERROR: CNFG RAN* requires the number of solvents ',
     -  'to be set with the NSLV key')
C@DM3009  format(' >>>>> OVERRIDE: PRCO key under MPI can only be used ',
C@DM     -  'without the second key - it is ignored')
C@DM3010  format(' ***** ERROR: MC run is asked where the number of CPUs (',
C@DM     -  i3,') differs from the previous number of CPU used (',i3,')')
7511  format(' MAIN: nstta,nsttg=',2i8,' nstfa0,nstfg0=',2i8,
     -  ' nstfa1,nstfg1=',2i8,' nstfa,nstfg=',2i8,' cslt, rlcslt=',/,
     - (i4,3f10.5,5x,3f10.5))
7512  format(' MAIN im=',i4,' Del cnt=',3f10.4,' Del cnt (PBC)=',3f10.4)
7513  format(' MAIN im=',i4,' -cent1= ',3f10.4,'        -cent2=',3f10.4)
7514  format(' MAIN im=',i4,' -cent2  (PBC)=',3f10.4)
7515  format(' MAIN im=',i4,' RMS=',f10.4)
      end
C@SPLIT0
      subroutine wordlength
c#    MMC routine   2 lstmod: 03/03/08
c*****Obtain machine-dependent number thresholds
c     Determine the word size of the machine by finding out which
c     two power gives integer owerflow (negative number)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      real*8 dtest,dpm
      i2=1
      do ib=1,10000
        i2=i2*2
        if (i2 .lt. 0) go to 222
        isize=ib
      end do
222   isize=isize+2
c     Word size is isize bits.
c     Determine the largest real in the machine by finding out which
c     is the smallest number that still does not give underflow
      rtest=1.0
      ii=0
      do ib=1,10000
        rtest=rtest/10.0
        if (rtest .eq. 0.0) go to 223
        realmx=rtest
        ii=ib
      end do
223   realmx=realmx*1000.0
      if (realmx .eq. 0.0) then
c       G77 seems to be having trouble otherwise
        realmx=0.7E+38
      else
        do ib=1,ii
          realm=1.0/realmx
          if (abs(realm*realmx-1.0) .lt. 0.001) then
            realmx=realm
            go to 114
          else
            realmx=realmx*10.0
          end if
        end do
      end if
c     realmx is the maximum allowed real number, rlsqmx is its square root.
114   dtest=1.d0
      do ib=1,10000
        dtest=dtest/10.d0
        if (dtest .eq. 0.d0) go to 224
        dpmx=dtest
        ii=ib
      end do
224   dpmx=dpmx*1000.d0
      if (dpmx .eq. 0.0) then
c       G77 seems to be having trouble otherwise
        dpmx=1.0d+300
      else
        do ib=1,ii
          dpm=1.0/dpmx
          if (abs(dpm*dpmx-1.0) .lt. 0.001) then
            dpmx=dpm
            go to 115
          else
            dpmx=dpmx*10.d0
          end if
        end do
      end if
c     nbits: number of bits per words used for mapping
c     Currently it is the wordsize-1 to avoid sign-bit problems
115   nbits=isize-1
c     Check integer range
      itest1=1
      do k=2,nbits
        itest2=itest1*2
        if (itest2/itest1 .ne. 2) then
          nbits=k-1
c         For Cray nbit=46 works only although 48 bits are used for integers
          if (itest2 .gt. 0) nbits=nbits-2
          go to 104
        end if
        itest1=itest2
      end do
c     lvec is the vector length used (128: convex,ibm ?)
104   lvec=128
      lvc3=lvec*3
c     Last check for G77 problem
      if (dpmx .eq. 0.d0) dpmx=1.0D+300
      if (realmx .eq. 0.0) realmx=0.7E+38
      rlsqmx=sqrt(realmx)
      rlsqmxi=1.0/rlsqmx
      rllnmx=alog(realmx)
      dpsqmx=dsqrt(dpmx)
      dblnmx=dlog(dpmx)
      return
      end
C@DM      subroutine mpi_ready(key0,mpi_ok)
C@DMc#    MMC routine   3 lstmod: 07/18/12
C@DM      character*4 key0
C@DM      character*4 mpi_keys(150)
C@DM      data  mpi_keys /'STOP','FILE','TITL','PRNT',
C@DM     -  'HRDW','TEMP','PRAC','SUPT','SVPT','RFCR','OUTP','SETC',
C@DM     -  'NSLV','MAKB','BRKB','MOLD','INCT','SUVC','SUUC','SVVC',
C@DM     -  'PBCN','CHRG','NONB','SLFT','SAMP','PARD','PART','IDAC',
C@DM     -  'CLON','SLTA','SLVA','LIGA','CHKP','PROT','PLBP','MOND',
C@DM     -  'FIXD','MOVE','STEP','FREE','PMOD','MODA','TRAJ','STPX',
C@DM     -  'CNFG','SEED','RUNS','DBUG','LIMG','BTUN','STUN','TAC0',
C@DM     -  'PRFI','SCRM','GCEN','SCAN','PXPR','PXLM','PXAN','RCKP',
C@DM     -  'WCNF','IDLG','IGSV','FETK','TIQU','PRCO',84*'    '/
C@DM      data  nmpikeys /66/
C@DM      mpi_ok=1
C@DM      do i=1,nmpikeys
C@DM        if (key0 .eq. mpi_keys(i)) return
C@DM      end do
C@DM      mpi_ok=0
C@DM      return
C@DM      end
      subroutine compile_ready(key0,icompopt,optname,iout,inperr)
c#    MMC routine   3/a lstmod: 02/22/12
      dimension icompopt(40)
      character*2 optname(40)
      character*4 key0
      dimension needopt(4,50)
      character*4 keys(50)
      data nkeys /7/,keys /'PRTG','CPOC','STVG','ATFR','FLDG',
     -  'IBEN','RFCR',43*'    '/
      data needopt /21,3*0, 21,3*0, 21,3*0, 5,6,2*0, 22,3*0,
     -  19,3*0, 23,3*0, 172*0/
c     write (iout,*) 'COMPILE_ready key0=',key0
      call find(key0,1,nkeys,keys,ifound,4)
      if (ifound .eq. 0) return
      do io=1,4
        icopt=needopt(io,ifound)
        if (icopt .gt. 0) then
          if (icompopt(icopt) .eq. 0) then
            write (iout,1000) key0,optname(icopt),optname(icopt)
            inperr=inperr+1
          end if
        end if
      end do
c     write (iout,*) 'COMPILE_ready done'
      return
1000  format(' ***** ERROR: key ',a,' requires the preprocessor ',
     -  'variable ',a2,' to be set to "T" (to remove the C@',a2,
     -  ' comment lines')
      end
      subroutine decode(keylist,lenlist,keyused,keyno,key,must)
c#    MMC routine   4 lstmod: 02/09/12
c*****Find the next keyword and its position, mark it used
      character*4 key,keylist(lenlist)
      character*80 line,mark
      common /inpline/ line,lineno,icol
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension keyused(lenlist)
      character*4 obsolete(15),new(15)
      data obsolete  /'RUN ','CNFI','DIEL','FCIN','FC14','BLKS','PRAT',
     -  'PRPB','REPT','PLTC','PROP',4*'    '/
      data new       /'RUNS','CNFG','SETC','SETC','SETC','SETC','OUTP',
     -  'OUTP','OUTP','PLCV','OUTP',4*'    '/
      keyno=-1
      key=keylist(1)
C@DB      print *,'DECODE: key,lenlist=',key,lenlist
      call nextchar(line,icol,0,inpt,iout)
      if (icol .gt. 80 .or. icol .lt. 0) then
        if (must .eq. 1) then
          if (keylist(1) .ne. '    ') then
            inperr=inperr+1
            if (MYRANK .eq. 0) then
              write (iout,1001) lineno,line
              write (iout,1003) (keylist(k),k=1,lenlist)
            end if
            keyno=1
          else
            key=keylist(2)
            keyno=2
          end if
        end if
        if (iop(24) .gt. 0  .and. MYRANK .eq. 0 .and. key .ne. 'TITL'
     -      .and. (must .eq. 0 .or. keylist(1) .eq. '    '))
     -    write (iout,1004) key
        return
      end if
      key=line(icol:icol+3)
      call find(key,1,lenlist,keylist,keyno,4)
      icol=icol+4
      if (keyno .gt. 0) then
        keyused(keyno)= keyused(keyno)+1
      else
c       Send a message about invalid keyword
        inperr=inperr+1
c       Check first if it is an obsolete one
        call find(key,1,15,obsolete,iobsolete,4)
        if (iobsolete .eq. 0) then
          do i=1,icol-1
            mark(i:i)='-'
          end do
          mark(icol:icol)='^'
          if (MYRANK .eq. 0) then
            write (iout,1000) line,mark(1:icol),key,lineno
            write (iout,1002) (keylist(k),k=1,lenlist)
          end if
        else
          if (MYRANK .eq. 0) then
            if (new(iobsolete) .eq. 'SETC' .or.
     -         new(iobsolete) .eq. 'OUTP') then
              write (iout,1006) key,lineno,new(iobsolete),key
            else
              write (iout,1005) key,lineno,new(iobsolete)
            end if
          end if
        end if
        keyno=1
      end if
C@DM      if (iop(24) .gt. 2) write (iout,3000) MYRANK,key,keyno
      return
1000  format(1x,a,/,1x,a,/,
     -  ' ***** ERROR: invalid keyword (',a4,') in line ',i5)
1001  format(' ***** ERROR: keyword missing in line',i5,' :',/,
     -  1x,a80)
1002  format(7x,'Permissible keywords:',20(1x,a4),/,7(8x,24(1x,a4)/))
1003  format(7x,'One of the following keywords are needed:',20(1x,a4))
1004  format(' Default key set: ',a4)
1005  format(' ***** ERROR: obsolete keyword (',a4,') in line ',i5,
     -  ' - replace it with ',a4)
1006  format(' ***** ERROR: obsolete keyword (',a4,') in line ',i5,
     -  ' - replace it with ',a4,1x,a4)
C@DM3000  format(' MPI in decode  MYRANK=',i3,' key=',a,' keyno=',i3)
      end
      subroutine find(key,ifrst,n,list,ifound,nc)
c#    MMC routine   5 lstmod: 06/02/95
c*****Find key in the list of keys (ifrst,n)
      character*(*) key,list
      dimension list(n)
C@DB      print *,'FIND range:',ifrst,n,' key=',key
      ifound=0
      do i=ifrst,n
        if (list(i)(1:nc) .eq. key(1:nc)) then
          ifound=i
          return
        end if
        if (list(i)(1:4) .eq. '#-#-') return
      end do
      return
      end
      subroutine markused(key,list,n,iused,key0,forbidk0)
c#    MMC routine   6 lstmod: 04/26/95
c*****Mark a keyword that has been used
      character*4 key,list,key0,forbidk0(200)
      dimension list(n),iused(n)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      call find(key,1,n,list,ifound,4)
      if (ifound .gt. 0) then
         iused(ifound)=-2
         forbidk0(ifound)=key0
      else
        write (iout,1000) key
        inperr=inperr+1
      end if
      return
1000  format(' ***** Program ERROR: invalid key to mark ',a4)
      end
      subroutine getlist(listall,nall,newlist,n,key)
c#    MMC routine   7 lstmod: 04/26/95
c*****Extract the indices of the prerequisites/forbids belonging to key
      character*4 listall,key,newlist
      dimension listall(nall),newlist(100)
      n=0
      ifound=0
      ifrst=2
      lockey=0
C@DB      print *,'GETLIST key=',key
      do while (ifound .eq. 0)
        call find(key,ifrst,nall,listall,ifnd,4)
         ifrst=ifnd
        if (ifrst .eq. 0) then
          ifound=1
        else if (listall(ifrst-1) .eq. '****') then
          ifound=1
          lockey=ifrst+1
        else
          ifrst=ifrst+1
        end if
      end do
C@DB      print *,'List for key ',key,' starting at ',lockey
      if (lockey .gt. 0) then
c       List found, extract indices
        do while (listall(lockey) .ne. '****')
          n=n+1
          newlist(n)=listall(lockey)
          lockey=lockey+1
        end do
C@DB        write (6,1234) (newlist(i),i=1,n)
C@DB1234    format(' Extracted: ',12(1x,a4))
      end if
      return
      end
      subroutine getint(int,isit,noneg,idefault)
c#    MMC routine   8 lstmod: 01/07/09
c*****Read an integer from the line
      character*80 line
      common /inpline/ line,lineno,icol
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      call nextchar(line,icol,0,inpt,iout)
      i1=icol
      i0=i1
      if (icol .ge. 80 .or. icol .lt. 1) then
        int=idefault
        if (isit .eq. 1) then
          inperr=inperr+1
          if (MYRANK .eq. 0) then
            write (iout,2000) lineno,line
            call lastchar(line,lstc,80)
            if (lstc .gt. 70) write (iout,2005)
          end if
        else if (iop(24) .gt. 0 .and. MYRANK .eq. 0) then
          write (iout,2004) int
        end if
        go to 999
      end if
      call nextblank(line,icol,0)
      i2=icol-1
      if (icol .lt. 0) i2=-icol-1
      isign=1
      if (line(i1:i1) .eq. '-') then
        i1=i1+1
        isign=-1
      else if (line(i1:i1) .eq. '+') then
        i1=i1+1
      end if
      int=0
      i11=i1
      do while (line(i11:i11) .ne. ' ' .and. line(i11:i11) .ne. '~'
     -         .and. line(i11:i11) .ne. tab .and. i1 .le. 80)
        ii=-1
        do i=1,10
          if (line(i1:i1) .eq. idigit(i)) ii=i-1
        end do
        if (ii .ge. 0) then
          int=10*int+ii
          i1=i1+1
          i11=i1
          if (i11 .gt. 80) i11=80
        else
          if (MYRANK .eq. 0) write (iout,2001)
     -      line(i0:i1),i0,i1,lineno,line
          i1=i1+1
          inperr=inperr+1
          int=idefault
        end if
      end do
      int=int*isign
c     Inputted zero is also set to default for optional input
      if (isit .eq. 0 .and. int .eq. 0) then
        int=idefault
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,2004) int
      else
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,2003) int
      end if
      if (noneg .gt. 0 .and. int .lt. 0) then
        if (MYRANK .eq. 0) write (iout,2002)
     -    int,line(i0:i1),i0,i1,lineno,line
        inperr=inperr+1
        int=0
      end if
999   continue
C@DM      if (iop(24) .gt. 2) write (iout,3000) MYRANK,int
      return
2000  format(' ***** ERROR: missing integer on line ',i4,' :',a80)
2001  format(' ***** ERROR: Invalid integer character while ',
     -  'reading: ',a,' (cols',i3,'-',i3,') ,line',i5,/,' line:',a80)
2002  format(' ***** ERROR: invalid negative integer:',i10,' while ',
     -  'reading: ',a,' (cols',i3,'-',i3,') ,line',i5,' line:',a80)
2003  format(' Integer number read: ',i10)
2004  format(' Integer default set to ',i10)
2005  format(7x,'///// NOTE: input line is limited to 80 characters. ',
     -  'Use the continuation character ~ to enter data in multiple ',
     -  'lines')
C@DM3000  format(' MPI in getint MYRANK=',i3,' int=',i9)
      end
      subroutine getreal(real,isit,default)
c#    MMC routine   9 lstmod: 01/28/11
c*****Read a real from the line
      character*80 line
      common /inpline/ line,lineno,icol
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      definp=default
      call nextchar(line,icol,0,inpt,iout)
      i1=icol
      if (icol .gt. 80 .or. icol .lt. 1) then
        real=definp
        if (isit .eq. 1) then
          inperr=inperr+1
          if (MYRANK .eq. 0) then
            write (iout,2000) lineno,line
            call lastchar(line,lstc,80)
            if (lstc .gt. 70) write (iout,2005)
          end if
        else if (iop(24) .gt. 0 .and. MYRANK .eq. 0) then
          write (iout,2002) real
        end if
        go to 999
      end if
      call nextblank(line,icol,0)
c     Check for invalid characters
      do ic=i1,icol-1
        do id=1,15
          if (line(ic:ic) .eq. rdigit(id)) go to 100
        end do
        inperr=inperr+1
        if (MYRANK .eq. 0) write (iout,2001) line(ic:ic),ic,lineno,line
        line(ic:ic)='0'
100     continue
      end do
      isign=1
      if (line(i1:i1) .eq. '-') then
        i1=i1+1
        isign=-1
      else if (line(i1:i1) .eq. '+') then
        i1=i1+1
      end if
      real=0
      do while (line(i1:i1) .ne. '.' .and. line(i1:i1) .ne. 'e' .and.
     -          line(i1:i1) .ne. 'E' .and. line(i1:i1) .ne. ' ' .and.
     -          line(i1:i1) .ne. '~' .and. line(i1:i1) .ne. tab)
        read (line(i1:i1),1000) i
        real=10*real+i
        i1=i1+1
      end do
      if (line(i1:i1) .eq. '.') then
c       Digits after the decimal point
        i1=i1+1
        rdiv=10.0
        i11=i1
        do while (line(i11:i11) .ne. 'E' .and. line(i11:i11) .ne. 'e'
     -     .and. line(i11:i11) .ne. ' ' .and.  line(i11:i11) .ne. tab
     -     .and. line(i11:i11) .ne. '~' .and. i11 .le. 80)
          read (line(i1:i1),1000) i
          real=real+float(i)/rdiv
          rdiv=rdiv*10.0
          i1=i1+1
          i11=i1
          if (i11 .gt. 80) i11=80
        end do
      end if
      if (line(i1:i1) .eq. 'e' .or. line(i1:i1) .eq. 'E') then
        i1=i1+1
        iexp=0
        iexpsig=1
        if (line(i1:i1) .eq. '-') then
          iexpsig=-1
          i1=i1+1
        else if (line(i1:i1) .eq. '+') then
          i1=i1+1
        end if
        do while (line(i1:i1) .ne. ' ' .and. line(i1:i1) .ne. tab .and.
     -            line(i1:i1) .ne. '~')
          read (line(i1:i1),1000) i
          iexp=10*iexp+i
          i1=i1+1
        end do
        iexp=iexp*iexpsig
        real=real*10.0**iexp
      end if
      real=real*isign
c     Inputted zero is also set to default for optional input
      if (isit .eq. 0 .and. real .eq. 0.0) then
        real=definp
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,2002) real
      else
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,2003) real
      end if
999   continue
C@DM      if (iop(24) .gt. 2) write (ioutdb,3000) MYRANK,real
      return
1000  format(i1)
2000  format(' ***** ERROR: missing real on line ',i4,' :',a80)
2001  format(' ***** ERROR: invalid real character (',a1,', col',i3,')',
     -  ' in line ',i4,' :',a80)
2002  format(' Real default set to ',f15.6)
2003  format(' Real number read: ',f18.6)
2005  format(7x,'///// NOTE: input line is limited to 80 characters. ',
     -  'Use the continuation character ~ to enter data in multiple ',
     -  'lines')
C@DM3000  format(' MPI in getreal MYRANK=',i3,' real=',f12.5)
      end
      subroutine getname(name,namlen,isit,maxlen)
c#    MMC routine  10 lstmod: 05/05/10
c*****Read a name from the line
      character*(*) name
      character*80 line
      common /inpline/ line,lineno,icol
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      namlen=0
      call nextchar(line,icol,0,inpt,iout)
      if (icol .ge. 1 .and. icol .le. 80) then
        i1=icol
        call nextblank(line,icol,0)
        i2=iabs(icol)-1
        namlen=i2-i1+1
        if (namlen .le. maxlen) then
          name(1:namlen)=line(i1:i2)
        else
          write (iout,1002) namlen,maxlen
          name(1:maxlen)=line(i1:i1+maxlen-1)
          inperr=inperr+1
        end if
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -     write (iout,1000) name(1:namlen)
      end if
      if (isit .eq. 1 .and. namlen .le. 0) then
        write (iout,1001)
        inperr=inperr+1
      end if
c     Send results if MPI
C@DM      if (iop(24) .gt. 2 .and. namlen .gt. 0)
C@DM     -  write (ioutdb,3000) MYRANK,name(1:namlen),namlen
      return
1000  format(' Name read:',a)
1001  format(' ***** ERROR: missing name')
1002  format(' ***** ERROR: name length ',i4,' exceeeds limit (',i3,')')
C@DM3000  format(' MPI in getname MYRANK=',i3,' name=',a,' len=',i3)
      end
      subroutine readpairlist(n,list,maxlist,maxval,arrname,dataname,
     -  limitname,iout,inperr,nwarn,isameok,nchng,iord,ieqok,must,iprt)
c#    MMC routine  11 lstmod: 05/26/19
c*****Read in a bond list
      dimension list(2,maxlist)
      character*10 arrname
      character*(*) dataname,limitname
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      call getint(n,must,1,0)
      inperr0=inperr
      if (n .gt. maxlist) then
        if (MYRANK .eq. 0)  write (iout,1000) n,maxlist,arrname
        inperr=inperr+1
        n=maxlist
      end if
      do i=1,n
        do k=1,2
          call getint(list(k,i),1,1,0)
          if (list(k,i) .gt. maxval .and. maxval .gt. 0) then
            if (MYRANK .eq. 0)
     -        write (iout,1002) i,list(k,i),limitname,maxval,dataname
            list(k,i)=maxval
            inperr=inperr+1
          else if (list(k,i) .lt. 1) then
            if (MYRANK .eq. 0) write (iout,1004) i,list(k,i),dataname
            inperr=inperr+1
          end if
        end do
        if (ieqok .eq. 0) then
          if (list(1,i) .eq. list(2,i)) then
            if (isameok .eq. 0) then
              if (MYRANK .eq. 0)
     -          write (iout,1006) i,list(1,i),list(2,i),dataname
              inperr=inperr+1
            else
              if (MYRANK .eq. 0)
     -          write (iout,1005) i,list(1,i),list(2,i),dataname
              nwarn=nwarn+1
            end if
          end if
        end if
        if (iord .eq. 1) then
          if (list(1,i) .gt. list(2,i)) then
            l1=list(1,i)
            l2=list(2,i)
            list(1,i)=l2
            list(2,i)=l1
            if (MYRANK .eq. 0) write (iout,1001) l1,l2,dataname
            nchng=nchng+1
          end if
          if (i .gt. 1) then
            if (list(2,i-1) .gt. list(2,i)) then
              write (iout,1008) i,(list(k,i),k=1,2)
              inperr=inperr+1
            else if (list(2,i-1) .gt. list(1,i)) then
              write (iout,1009) i-1,(list(k,i-1),k=1,2),
     -          i,(list(k,i),k=1,2)
              inperr=inperr+1
            end if
          end if
        end if
      end do
      if (iprt .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,1007) dataname,((list(k,i),k=1,2),i=1,n)
      if (inperr .gt. inperr0) n=0
      return
1000  format(' ***** ERROR: list length (',i4,') exceeds limit (',
     -  i4,') - redimension the array ',a)
1001  format(' >>>>> OVERRIDE: range limits ',2i6,' were swapped for ',
     -  a)
1002  format(' ***** ERROR:',i4,'-th pair list element (',i6,') ',
     -  'exceeds the number of ',a,' (',i6,') ',/,7x,'in the ',a)
1004  format(' ***** ERROR:',i4,'-th pair list element (',i6,
     -  ') is nonpositive for ',a)
1005  format(' ----- WARNING:',i4,'-th pair list elements (',2i6,
     -  ') are the same for ',a)
1006  format(' ***** ERROR:',i4,'-th pair list elements (',2i6,
     -  ') are the same for ',a)
1007  format(1x,a,':',10('[',i5,',',i5,'] '))
1008  format(' ***** ERROR:',i4,'-th pair ([',i6,',',i6,']) is out of ',
     -  'order')
1009  format(' ***** ERROR: pairs ',i4,' ([',i6,',',i6,']) and ',
     -  i4,' ([',i6,',',i6,']) overlap')
      end
      subroutine getnextrec(inpt,iout,irectx,nwwarn)
c#    MMC routine  12 lstmod: 12/18/14
c*****Read the next non-comment line for formatted data input
      character*4 keyname
      character*40 dataname
      common /errorname/ maxrect,dataname(60),keyname(60)
      character*80 line
      common /inpline/ line,lineno,icol
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      common /option/ iop(200),idebug(200)
      ncolp=80
      if (irectx .lt. 1 .or. irectx  .gt. maxrect) then
        if (MYRANK .eq. 0) write (iout,2004) irectx,maxrect
        call datprt(2)
      else if (keyname(irectx) .eq. '   ') then
        if (MYRANK .eq. 0) write (iout,2002) irectx
      end if
100   continue
C@DM      if (MYRANK .eq. 0) then
      ireadok=0
      call blankout(line,1,ncolp)
      read (inpt,1000,end=999) line
      do ic=1,80
        if (line(ic:ic) .eq. ctrlM) ncolp=ic-1
      end do
      ireadok=1
999   continue
C@DM      end if
C@DM      call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      if (ireadok .eq. 0) then
        if (irectx .ne. 15 .and. irectx .ne. 16 .and.
     -      irectx .ne. 51 .and. irectx .ne. 52) then
          if (MYRANK .eq. 0) write (iout,2000)
     -      keyname(irectx),irectx,dataname(irectx),line(1:ncolp)
          call datprt(2)
        else
          irectx=-irectx
        end if
        return
      end if
C@DM        call MPI_Bcast(line,80,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
      lineno=lineno+1
      icol=1
      call nextchar(line,icol,0,inpt,iout)
      if (icol .eq. 82) then
c       Comment or empty line found
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,2001) lineno,line(1:ncolp)
        lineno=lineno+1
        go to 100
      end if
c     Check for Tab
      ic=1
      do while (ic .lt. 80 .and. line(ic:ic) .ne. '!' .and.
     -  line(ic:ic) .ne. '~')
        if (line(ic:ic) .eq. tab
C@G7     -      .and. .false.
     -      ) then
          line(ic:ic)=' '
          if (MYRANK .eq. 0) write (iout,2003)
     -      ic,irectx,dataname(irectx),keyname(irectx),line(1:ncolp)
          nwwarn=nwwarn+1
        end if
        if (line(ic:ic) .eq. ctrlM) then
          line(ic:ic)=' '
          ic=ic-1
          return
        end if
        ic=ic+1
      end do
      return
1000  format(a80)
2000  format(' ***** ERROR: Run out of data while trying to read ',
     -  'formatted record for key ',a4,' record type',i3,
     -  /,' (',a40,')',/,' The line read was:',a)
2001  format(' Input line ',i6,' :',/,a)
2002  format(' ***** PROGRAM ERROR: undefine record number read:',i10)
2003  format(' ===== STRONG WARNING: Tab in column',i3,
     -  ' replaced by blank - record type=',i3,' (',a40,') key=',a4,/,
     -  ' The line read was:',a)
2004  format(' ***** PROGRAM ERROR: record number=',i6,
     -  ' is outside the range [1,',i4,']')
      end
      subroutine invalidform(iout,irectx)
c#    MMC routine  13 lstmod: 05/16/05
c*****Read the next non-comment line for formatted data input
      character*4 keyname
      character*40 dataname
      common /errorname/ maxrect,dataname(60),keyname(60)
      character*80 line
      common /inpline/ line,lineno,icol
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      if (MYRANK .eq. 0) then
      if (irectx .lt. 1 .or. irectx .gt. maxrect) then
        write (iout,2000) lineno
      else
        write (iout,2000) lineno,' ',keyname(irectx),irectx,
     -    dataname(irectx),line
      end if
C@DM      end if
      call datprt(2)
      return
2000  format(' ***** ERROR: invalid format data encountered in line #',
     -  i5,' while reading a formatted record',a,/,' key=',a4,
     -  ' record type=',i2,' - ',a40,/,' The line read was:',/,a80)
      end
      subroutine check01int(r,lab,iout,inperr)
c#    MMC routine  14 lstmod: 03/21/12
c*****Check if a number is in the [0.0,1.0] interval
      character*(*) lab
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      if (r .lt. 0.0 .or. r .gt. 1.0) then
        if (MYRANK .eq. 0) write (iout,1000) lab,r
        inperr=inperr+1
      end if
      return
1000  format(' ***** ERROR: ',a,' is outside the [0,1] interval:',f10.5)
      end
      subroutine getunitnos(iunit,itofrom)
c#    MMC routine  15 lstmod: 03/20/96
c*****Transfer the various unitnumbers into an array (like equivalence)
      dimension iunit(10)
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      do itype=1,10
        if (itofrom .eq. 1) iunit(itype)=ifiles(itype)
        if (itofrom .eq. 0) ifiles(itype)=iunit(itype)
      end do
      return
      end
      subroutine switchfiles(numrun,inpt,iout,icloseonly)
c#    MMC routine  16 lstmod: 03/21/21
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /option/ iop(200),idebug(200)
      dimension iunitnos(10)
      call getunitnos(iunitnos,1)
      do itype=1,10
        if (iunitnos(itype) .gt. 0 .and.
     -      iunitnos(itype) .ne. inpt) then
          call fileclose(iunitnos(itype),0,iop(24),iout)
          if (numrun .gt. 0 .and. icloseonly .eq. 0) then
            if (itype .eq. 3) then
c             Make sure to use the inputted trajectory name root
              nl=namlens(itype)-4
              if (isdigit(filenames(itype)(nl:nl)) .eq. 1) then
                ic=nl
                do while (ic .gt. 1 .and.
     -                    filenames(itype)(ic:ic) .ne. '.')
                  ic=ic-1
                end do
                if (ic .gt. 1) nl=ic-1
              end if
              call fileopen(filenames(itype),nl,
     -          filenames(itype),namlens(itype),itype,0,numrun,1,0,
     -          iform(itype),iop(24),iversout,iout,iunitnos(itype),0)
              numrec(3)=0
            else
              call fileopen(file,namlenf,filenames(itype),
     -          namlens(itype),itype,0,numrun,1,0,iform(itype),
     -          iop(24),iversout,iout,iunitnos(itype),0)
            end if
          end if
        end if
      end do
      call getunitnos(iunitnos,0)
      return
      end
      subroutine fileopen(label,lablen,filename,namlen,ityp0,itypealt,
     -  numrun,iversin,mode,iform,iverbos,iversout,iout,iunit,nostop)
c#    MMC routine  17 lstmod: 10/17/20
c*****Generates filename from the filename root, filetype and run number
      character*(*) label,filename
      character*80 filenamen,filename1,form
      character*3 namunit
      common /extnames/ namunit(50)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      character*80 scratchpath
      common /localdisk/ lscratchpath,scratchpath
      common /option/ iop(200),idebug(200)
      character*3 modes(3)
      character*23 ftnm,filetypname(50)
      data modes /'OLD','XXX','NEW'/
      data filetypname /
     -  'checkpoint             ','initial configuration  ',
     -  'history (trajectory)   ','distribution function  ',
     -  'insertion/deletion log ','analysis checkpoint    ',
     -  'proximity distribution ','proximity information  ',
     -  'autocorr-residence     ','field gradient         ',
     -  'InsightII configuration','cavity grid            ',
     -  'coordinate source      ','last good checkpoint   ',
     -  'PDB                    ','proximity visualization',
     -  'matched PMF file       ','Charmm .CRD file       ',
     -  'Charmm .DCD file       ','solute description     ',
     -  'temporary storage      ','temporary storage      ',
     -  'Standard input         ','2nd PDB file           ',
     -  '2nd Charmm .CRD file   ','2nd checkpoint file    ',
     -  '2nd configuration file ','2nd history file       ',
     -  '2nd analysis checkpoint','standard output        ',
     -  'postscript graph       ','slv-to-site assignment ',
     -  'site information file  ','S calculator (stow) inp',
     -  'Amber trajectory       ','dipole covariance matrx',
     -  'dipole correlation matr','interaction energy matr',
     -  'hydrogen-bond matrix   ','occupancy correlation m',
     -  'slt hydrogen-bond matrx','eigenvalue/eigenvectors',
     -  'original solvent number','frame-averaged connect.',
     -  'Charmm .dcd file       ','MAKB bond list         ',
     -  'Charmm .psf file       ','Amber .top file        ',
     -  'General solvent input f',' Input trajectory ext. '/
c     mode = 0/1/2/3 : New or old/ new / old /new with new versionnumbers
c     itype=1 (.ckp) ichkp: Checkpoint file (containing full info on the status
c                           of the run)
c     itype=2 (.crd) icord: initial configuration file
c     itype=3 (.hst) ihist: history file
c     itype=4 (.dst) idstr: distribution function file (for plot)
c     itype=5 (.idl) iindel: file for insertion and deletion log
c     itype=6 (.pxc) ichkpx: proximity analysis checkpoint file
c     itype=7 (.pxp) idistrpx: proximity analysis distribution function file
c     itype=8 (.pxi) infopx: proximity information file
c     itype=9 (.rtm) : Autocorrelation fct for residence time calc.
c     itype=10 (.fgd) : field gradient file
c     itype=11 (.dat) : configuration file for InsightII
c     itype=12 (.grd) : grid file for cavity visualization
c     itype=13 (.crd) : coordinate source file (for modification)
c     itype=14 (.ckp) : last good checkpointfile
c     itype=15 (.pdb) : PDB
c     itype=16 (.pxv) : proximity region visualization file
c     itype=17 (.wmp) : matched PMF file
c     itype=18 (.CRD) : Charmm .CRD file (coordinates)
c     itype=19 (.dcd) : Charmm .DCD file (trajectory)
c     itype=20 (.slt) : solute input description file
c     itype=21 (.tmp) : temporary storage file
c     itype=22 (.tm1) : temporary storage file
c     itype=23 (.inp) : Standard input
c     itype=24 (.pdb) : 2nd PDB file
c     itype=25 (.CRD) : 2nd Charmm .CRD file
c     itype=26 (.ckp) : 2nd checkpoint file
c     itype=27 (.crd) : 2nd configuration file
c     itype=28 (.hst) : 2nd history file
c     itype=29 (.pxc) : 2nd proximity analysis checkpoint file
c     itype=30 (.   ) : Standard output
c     itype=31 (.ps ) : Postcript graph
c     itype=32 (.wsl) : Solvent assignment file
c     itype=33 (.inf) : Generic site information file
c     itype=34 (.sto) : S calculation (stow) input
c     itype=35 (.trj) : Amber trajectory
c     itype=36 (.cov) : Dipole covariance matrix
c     itype=37 (.cor) : Dipole correlation matrix
c     itype=38 (.eng) : Interaction energy matrix
c     itype=39 (.hbd) : Hydrogen-bond matrix
c     itype=40 (.ocr) : Generic site occupancy correlation
c     itype=41 (.hbt) : Hydrogen-bond matrox including the solute
c     itype=42 (.eiv) : Eigenvalue/eigenvector
c     itype=43 (.oro) : Original solvent number
c     itype=44 (.hbf) : Frame-averaged overall connectivity
c     itype=45 (.DCD) : Charmm .DCD file (trajectory)
c     itype=46 (.mkb) : Bond list to read instead of generating it
c     itype=47 (.psf) : Charmm topology (PSF) file
c     itype=48 (.top) : Amber topology file
c     itype=49 (.slv) : Solvent input file
c     itype=50 (.iii) : Input trajectory extension
c     nfiletyp: number of types
c     ifilstat(itype) : 0 -file closed; <0 - old file open; >0 - new file open
      if (idebug(93) .gt. 0) call reportfile(1,1,iunit)
      itype=iabs(ityp0)
      itypeopen=itype
      ivers=iabs(iversin)
      iversout=ivers
      ifilstatinp=ifilstat(itype)
      if (ifilstat(itype) .ne. 0) then
        if (iversin .ge. 0) then
c         File was already open
          ftnm=filetypname(itype)
          call lastchar(ftnm,ilc,23)
          write (iout,1008) itype,ftnm(1:ilc),iabs(ifilstat(itype))
          if (nostop .eq. 0) call datprt(2)
          return
        else
          if (iverbos .gt. 0) write (iout,1010)
        end if
      end if
      call findnewunit(iunit,0,iout)
      iversi=ivers
      ios=0
      if (iform .eq. 0) then
        lenform=9
        form(1:lenform)='FORMATTED'
      else
        lenform=11
        form(1:lenform)='UNFORMATTED'
      end if
      if (ityp0 .lt. 0) then
c       Just open file with the name already made
        if (namlen .gt. 80) then
          write (iout,1012) filename(1:namlen),namunit(itype)
          call datprt(2)
        end if
        namlenn=namlen
        filenamen(1:namlenn)=filename(1:namlen)
        if (mode .eq. 2) then
          open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -      form=form(1:lenform),iostat=ios)
          if (ios .eq. 0) ifilstat(itype)=-iunit
        else if (mode .eq. 3) then
          write (iout,1013)
          call datprt(-1)
        else
          open(unit=iunit,status='new',file=filenamen(1:namlenn),
     -      form=form(1:lenform),iostat=ios)
          if (ios .eq. 0) then
             ifilstat(itype)=iunit
          else if (mode .eq. 0) then
            open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -        form=form(1:lenform),iostat=ios)
            if (ios .eq. 0) ifilstat(itype)=-iunit
          end if
        end if
        if (ios .gt. 0) then
          write (iout,1009) filenamen(1:namlenn)
          call datprt(-1)
        end if
        if (namlen .gt. 80) then
          write (iout,1012) filename,namunit(itype)
          call datprt(2)
        end if
        namlenn=namlen
        filenamen(1:namlenn)=filename(1:namlen)
        if (mode .eq. 2) then
          open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -      form=form(1:lenform),iostat=ios)
          if (ios .eq. 0) ifilstat(itype)=-iunit
        else if (mode .eq. 3) then
          write (iout,1013)
          call datprt(-1)
        else
          open(unit=iunit,status='new',file=filenamen(1:namlenn),
     -      form=form(1:lenform),iostat=ios)
          if (ios .eq. 0) then
             ifilstat(itype)=iunit
          else if (mode .eq. 0) then
            open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -        form=form(1:lenform),iostat=ios)
            if (ios .eq. 0) ifilstat(itype)=-iunit
          end if
        end if
        if (ios .gt. 0) then
          write (iout,1009) filenamen(1:namlenn)
          call datprt(-1)
        end if
      else
        if (lablen .eq. 0) then
          write (iout,1006)
          call datprt(-1)
        end if
        if (lscratchpath .gt. 0 .and. (itype .eq. 1 .or. itype .eq. 6
     -    .or. itype .eq. 21 .or. itype .eq. 22)) then
c         Prefix file name with the path to the local scratch space
          filenamen(1:lscratchpath)=scratchpath(1:lscratchpath)
          filenamen(lscratchpath+1:lscratchpath+lablen)=label(1:lablen)
          namlenn=lscratchpath+lablen
        else
          filenamen(1:lablen)=label(1:lablen)
          namlenn=lablen
        end if
        if (numrun .ne. 1) then
          filenamen(namlenn+1:namlenn+1)='.'
          namlenn=namlenn+1
          call writeint(filenamen,namlenn,numrun,iout)
        end if
        namlenv0=namlenn
100     namlenn=namlenv0
        if (iversi .gt. 1) then
          filenamen(namlenn+1:namlenn+1)='_'
          namlenn=namlenn+1
          call writeint(filenamen,namlenn,iversi,iout)
        end if
        filenamen(namlenn+1:namlenn+1)='.'
        filenamen(namlenn+2:namlenn+4)=namunit(itype)
        lext=4
        if (itype .eq. 31) lext=3
        namlenn0=namlenn
        if (ios .eq. 0) then
          namlenn=namlenn+lext
          if (namlenn .gt. 80) then
            write (iout,1012) filenamen(1:namlenn),namunit(itype)
            call datprt(2)
          end if
          if (mode .eq. 0 .or. mode .eq. 2) then
c           Try first as old
            open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -        form=form(1:lenform),iostat=ios)
            if (ios .ne. 0) then
              if (iverbos .gt. 1)
     -          write (iout,1001) filenamen(1:namlenn),' ','OLD'
              if (itypealt .gt. 0) then
c               Try to open with alternate type
                filename1=filenamen
                filenamen(namlenn-2:namlenn)=namunit(itypealt)
                open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -            form=form(1:lenform),iostat=ios)
                if (ios .eq. 0) then
                  ifilstat(itype)=-iunit
                  itypeopen=itypealt
                else
                  if (iverbos .gt. 1)
     -              write (iout,1001) filenamen(1:namlenn),' ','OLD'
                  if (numrun .eq. 1) then
c                   Try with .1. explicit in the file name
                    filename1=filenamen
                    filenamen(namlenv0+1:namlenv0+2)='.1'
                    filenamen(namlenv0+3:namlenn+2)=
     -                filename1(namlenv0+1:namlenn)
                    namlenn=namlenn+2
                    open(unit=iunit,status='old',
     -                file=filenamen(1:namlenn),form=form(1:lenform),
     -                iostat=ios)
                    if (ios .eq. 0) then
                      ifilstat(itype)=-iunit
                    else
                      if (iverbos .gt. 1)
     -                  write (iout,1001) filenamen(1:namlenn),' ','OLD'
                      filenamen=filename1
                      namlenn=namlenn-2
                    end if
                  else
                    filename1=filenamen
                  end if
                end if
              end if
              if (ios .ne. 0 .and. numrun .eq. 1) then
c               Try with .1. explicit in the file name
                filenamen(namlenn-2:namlenn)=namunit(ityp0)
                filename1=filenamen
                filenamen(namlenv0+1:namlenv0+2)='.1'
                filenamen(namlenv0+3:namlenn+2)=
     -            filename1(namlenv0+1:namlenn)
                namlenn=namlenn+2
                open(unit=iunit,status='old',file=filenamen(1:namlenn),
     -            form=form(1:lenform),iostat=ios)
                if (ios .eq. 0) then
                  ifilstat(itype)=-iunit
                else
                  if (iverbos .gt. 1)
     -              write (iout,1001) filenamen(1:namlenn),' ','OLD'
                  filenamen=filename1
                  namlenn=namlenn-2
                end if
              end if
            else
              ifilstat(itype)=-iunit
            end if
            if (mode .eq. 0 .and. ios .ne. 0) then
c             File not found,as old, open as new
              open(unit=iunit,status='new',file=filenamen(1:namlenn),
     -          form=form(1:lenform),iostat=ios)
              if (ios .eq. 0) ifilstat(itype)=iunit
            end if
          else if (mode .eq. 1) then
c           New - can't be present
            open(unit=iunit,status='new',file=filenamen(1:namlenn),
     -        form=form(1:lenform),iostat=ios)
            if (ios .eq. 0) ifilstat(itype)=iunit
          else if (mode .eq. 3) then
c           New - keep increasing the version number until no file found
            open(unit=iunit,status='new',file=filenamen(1:namlenn),
     -        form=form(1:lenform),iostat=ios)
            if (ios .ne. 0) then
              if (iverbos .gt. 0)
     -          write (iout,1007) filenamen(1:namlenn)
              iversi=iversi+1
              iversout=iversi
              ios=0
              go to 100
            else
              ifilstat(itype)=iunit
            end if
          else
            write (iout,1005) filenamen(1:namlenn),mode
            ios=1
          end if
        end if
      end if
      if (ios .ne. 0) then
        call returnunit(iunit,iout)
        if (nostop .eq. 0) then
          if (itypealt .gt. 0) write (iout,1002) filename1(1:namlenn)
          write (iout,1002) filenamen(1:namlenn)
          if (mode .eq. 1) write (iout,1003) 'present'
          if (mode .eq. 2) write (iout,1003) 'missing'
          iunit=0
          call datprt(2)
        end if
        iunit=-iunit
        if (iverbos .gt. 0) write (iout,1001) filenamen(1:namlenn)
      else
        namlen=namlenn
        filename(1:namlen)=filenamen(1:namlenn)
        if (iverbos .gt. 0) then
          mm=1
          if (ifilstat(itype) .lt. 0) mm=-1
          write (iout,1000) form(1:lenform),filename(1:namlenn),
     -      iunit,modes(mm+2),itypeopen
        end if
      end if
      if (ifilstatinp .ne. 0) then
        ifilstat(itype)=ifilstatinp
        if (iverbos .gt. 0) write (iout,1011) ifilstatinp
       end if
      if (idebug(93) .gt. 0) call reportfile(1,2,iunit)
      return
1000  format(' +++++ ',a,' file ',a,' as unit ',i6,', Mode=',a3,
     -  ', type=',i2,' has been opened')
1001  format(' ----- Unsuccessful attempt to open file ',a,a,'as ',a)
1002  format(' ***** ERROR in opening file ',a)
1003  format(13x,'File is likely to be ',a)
1005  format(' ***** PROGRAM ERROR invalid mode for file ',a,':',i4)
1006  format(' ***** ERROR: file-name root is missing - see key FILE')
1007  format(' File ',a,' is already present')
1008  format(' ***** PROGRAM ERROR: File type',i3,' (',a,' file) ',
     -  'is already open as unit',i3)
1009  format(' ***** ERROR: file ',a,' did not open')
1010  format(' Opening new version coexisting with an old one')
1011  format(' File status index reset to ',i3)
1012  format(' ***** ERROR: file name is longer than 80 characters:',
     -  a,'* Extension:',a)
1013  format(' ***** PROGRAM ERROR: pre-inputted file name can not ',
     -  ' be used vith flexible version numbers (mode=4)')
      end
      subroutine writeint(name,lname,intg,iout)
c#    MMC routine  17/a lstmod: 06/11/20
      character*(*) name
      if (intg .le. 9) then
        len=1
        write (name(lname+1:lname+len),11) intg
        lname=lname+len
      else if (intg .le. 99) then
        len=2
        write (name(lname+1:lname+len),12) intg
        lname=lname+len
      else if (intg .le. 999) then
        len=3
        write (name(lname+1:lname+len),13) intg
        lname=lname+len
      else if (intg .le. 9999) then
        len=4
        write (name(lname+1:lname+len),14) intg
        lname=lname+len
      else if (intg .le. 99999) then
        len=5
        write (name(lname+1:lname+len),15) intg
        lname=lname+len
      else
        write (iout,1000) intg
        ios=1
      end if
      return
11    format(i1)
12    format(i2)
13    format(i3)
14    format(i4)
15    format(i5)
1000  format(' ***** ERROR: integer to write into a name can no be ',
     -  'greater than 99999:',i9)
      end
      subroutine fileclose(iunit,idel,iverbos,iout)
c#    MMC routine  18 lstmod: 12/16/03
c*****Closes file unit=iunit, deletes if empty
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /option/ iop(200),idebug(200)
      if (idebug(93) .gt. 0) call reportfile(2,1,iunit)
      if (iunit .gt. 0) then
        call returnunit(iunit,iout)
        do i=1,nfiletyp
          if (iunit .eq. ifilstat(i) .or. iunit .eq. -ifilstat(i))
     -      ifilstat(i)=0
        end do
        if (idel .eq. 1) then
          close (iunit,status='delete')
          if (iverbos .gt. 0) write (iout,1000) iunit
        else
c         Check if file is empty
          iok=0
          rewind iunit
          read (iunit,100,end=991,err=991)
          iok=iok+1
991       rewind iunit
          read (iunit,end=992,err=992)
          iok=iok+1
992       if (iok .eq. 0) then
            close (iunit,status='delete')
            if (iverbos .gt. 0) write (iout,1002) iunit
          else
            close (iunit)
            if (iverbos .gt. 0) write (iout,1001) iunit
          end if
        end if
        iunit=0
      end if
      if (idebug(93) .gt. 0) call reportfile(2,2,iunit)
      return
100   format(a)
1000  format(' +++++ Closing and deleting unit ',i5)
1001  format(' +++++ Closing unit ',i5)
1002  format(' +++++ Closing and deleting unit ',i5,' (file was empty)')
      end
      subroutine findnewunit(iunew,init,iout)
c#    MMC routine  19 lstmod: 10/17/01
c*****Finds an unused unit number
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      if (init .eq. 1) then
        call zeroiti(iuchoice,9,99)
      else
        iun=10
        do while (iuchoice(iun) .gt. 0)
          iun=iun+1
          if (iun .eq. 100) then
            write (iout,1000)
            call datprt(2)
          end if
        end do
        iuchoice(iun)=1
        iunew=iun
      end if
      return
1000  format(' ***** PROGRAM ERROR: all unit numbers between 10 ',
     -  'and 99 are used')
      end
      subroutine returnunit(iuold,iout)
c#    MMC routine  20 lstmod: 01/28/03
c*****Returns a unit number into the pool
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /timing/ ireset_tim,ncount_st,iday_st,month_st,iexit,nmcrun
      if (iuchoice(iuold) .eq. 0) then
        write (iout,1000) iuold
c       If iexit > 0 then call was made from datprt
        if (iexit .eq. 0) call datprt(2)
      else
        iuchoice(iuold)=0
      end if
      return
1000  format(' ***** PROGRAM ERROR: unit number to return was marked',
     -  ' unused:',i4)
      end
      subroutine reportfile(iopclos,istartend,iunit)
c#    MMC routine  21 lstmod: 09/12/20
c*****Prints the file unit and status numbers
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*5 ise(2),ioc(2)
      data ise/'start','end  '/, ioc/'open ','close'/
      write (iout,1000) ioc(iopclos),ise(istartend),iunit,
     -  ifilstat,iform,ifiles
      return
1000  format(' FILE',a,' at ',a,' iunit=',i10,/,' ifilstat=',50i4,/,
     -  '    iform=',50i4,/,'   ifiles=',10i4)
      end
      subroutine skiptoend(iftyp,iunitno,isitckp,irewind,iverb,
     -  iskipfail)
c#    MMC routine  22 lstmod: 01/07/09
      character*1 char1
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /io/ inpt,iout,iunit(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension ltypunit(18)
      character*22 typunit(18)
      data typunit /2*'                      ','History               ',
     -  'MC distribution       ','GCE i/d log           ',
     -  '                      ','Proximity distribution',
     -  'Proximity information ','Residence time data   ',
     -  'Field gradient        ',3*'                      ',
     -  'Last good checkpoint  ',4*'                      '/
      data ltypunit /1,1,7,15,11,1,22,21,19,14,3*1,20,4*1/
      if (isitckp .eq. 0) then
c       Not checkpoint file
        if (iftyp .gt. 10) then
          write (iout,2000) iftyp
          iskipfail=iskipfail+1
        end if
        if (iunitno .lt. 0) then
          if (iop(49) .eq. 0) then
            write (iout,2001) typunit(iftyp)(1:ltypunit(iftyp)),
     -        filenames(iftyp)(1:namlens(iftyp)),iftyp
            iskipfail=iskipfail+1
          else
c           Recover whatever is there
            write (iout,2008) typunit(iftyp)(1:ltypunit(iftyp)),
     -        filenames(iftyp)(1:namlens(iftyp))
            call fileopen(file,namlenf,filenames(iftyp),
     -        namlens(iftyp),iftyp,0,numrun,0,0,iform(iftyp),iop(24),
     -        iversout,iout,iunitno,0)
            numrec(iftyp)=0
            numrecprev(iftyp)=0
            return
          end if
        end if
        if (numrec(iftyp) .eq. 0) then
          write (iout,2009) typunit(iftyp)(1:ltypunit(iftyp))
          return
        end if
      end if
      if (isitckp+irewind .eq. 1) then
        close (iunitno)
        if (iform(iftyp) .eq. 0) open(unit=iunitno,status='old',
     -    file=filenames(iftyp)(1:namlens(iftyp)),form='FORMATTED',
     -    iostat=ios)
        if (iform(iftyp) .eq. 1) open(unit=iunitno,status='old',
     -    file=filenames(iftyp)(1:namlens(iftyp)),form='UNFORMATTED',
     -    iostat=ios)
      end if
      ifound=0
      nrecread=numrec(iftyp)
200   if (iverb .gt. 0 .and.  isitckp .eq. 0) write (iout,2002)
     -  numrec(iftyp),filenames(iftyp)(1:namlens(iftyp))
      if (iform(iftyp) .eq. 1) then
        do i=1,nrecread
          read (iunitno,end=100)
          ifound=i
        end do
      else
        do i=1,numrec(iftyp)
          read (iunitno,1000,end=100) char1
          ifound=i
        end do
      end if
100   if (ifound .lt. numrec(iftyp)) then
c       File was short
        if (ifound .lt. numrecprev(iftyp)) then
          write (iout,2003) typunit(iftyp)(1:ltypunit(iftyp)),
     -      filenames(iftyp)(1:namlens(iftyp))
          write (iout,2007) ifound
          iskipfail=iskipfail+1
        else
          if (iop(49) .gt. 0) then
            write (iout,2004)  typunit(iftyp)(1:ltypunit(iftyp)),
     -        filenames(iftyp)(1:namlens(iftyp))
            write (iout,2007) ifound
            nwwarn=nwwarn+1
            nrecread=numrecprev(iftyp)
            rewind iunitno
            go to 200
          else
            write (iout,2005)  typunit(iftyp)(1:ltypunit(iftyp)),
     -        filenames(iftyp)(1:namlens(iftyp))
            write (iout,2007) ifound
            iskipfail=iskipfail+1
          end if
        end if
      end if
      if (iverb .gt. 0) write (iout,2006)
     -  typunit(iftyp)(1:ltypunit(iftyp)),
     -  filenames(iftyp)(1:namlens(iftyp)),nrecread
      return
1000  format(a1)
2000  format(' ***** PROGRAM ERROR: invalid filetype in skiptoend:',i9)
2001  format(' ***** PROGRAM ERROR: in skiptoend ',a,' file ',a,
     -  '(type: ',i4,') is missing ',/,
     -  7x,'- use RCK* **** FXTR to start a new file and continue')
2002  format(' Repositioning: skipping',i12,' records on ',a,' file ',a)
2003  format(' ***** ERROR: ',a,' file ',a,' is missing more than its',
     -  ' last record')
2004  format(' ===== STRONG WARNING: ',a,' file ',a,' is incomplete,',
     -  ' - a repair is attempted')
2005  format(' ***** ERROR: ',a,' file ',a,' is incomplete - use RCKP ',
     -  '**** FXTR to attempt to fix it')
2006  format(' +++++ ',a,' file ',a,' was succesfully positioned,',
     -  ' number of records skipped=',i9)
2007  format(' Number of records found:',i10)
2008  format(' ===== STRONG WARNING: ',a,' file ',a,' was missing ',
     -  '- counter is reset to zero')
2009  format(1x,a,' file is empty - buffer not saved')
      end
      subroutine checkdim(ifail,iout,inperr,sym,minval,ireset,inc,iskip)
c#    MMC routine  23 lstmod: 03/29/10
c*****Prints a detailed message when an array limit is exceeded
      character*2 sym,optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      ifail=0
      do i=1,70
        if (sizesym(i) .eq. sym) then
c         i-th symbol to be examined
          if (minval+inc .gt.  iasize(i)) then
c           Violation
            do j=1,38
              if (sizelname(i) (38-j+1:38-j+1) .ne. ' ') then
                len=38-j+1
                go to 100
              end if
            end do
            if (MYRANK .eq. 0) write (iout,1002) i
            len=10
100         if (iskip .eq. 0 .and. MYRANK .eq. 0) then
              write (iout,1000) sizelname(i)(1:len),iasize(i)
              write (iout,1001) sym,sizename(i),minval+inc
            end if
            if (ireset .eq. 1) minval=iasize(i)-inc
            inperr=inperr+1
            ifail=1
          end if
          go to 999
        end if
      end do
      if (MYRANK .eq. 0) write (iout,1003) sym
999   continue
C@DM      if (iskip .ge. 0) then
C@DM        call MPI_Bcast(inperr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(ifail,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM      end if
      return
1000  format(' ***** ERROR: maximum number of ',a,' (',i8,
     -  ') is exceeded')
1001  format('       Recompile the program with #',a2,' (',a,
     -  ') set to at least ',i8)
1002  format(' ***** PROGRAM ERROR: No symbol description was found ',
     -  'for the ',i2,'-th symbol')
1003  format(' ***** PROGRAM ERROR: Invalid dimension symbol: ',a2)
      end
      subroutine checklim(ifail,iout,inperr,minval,maxval,intg,ireset,
     -  label,llabel)
c#    MMC routine  23/a lstmod: 05/06/05
c*****Checks an integer for valid range
      character*(*) label
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      inperr0=inperr
      if (intg .lt. minval) then
        if (MYRANK .eq. 0) write (iout,1000) label(1:llabel),intg,
     -    'under its lower',minval
        inperr=inperr+1
        if (ireset .eq. 1) intg=minval
      end if
      if (intg .gt. maxval) then
        if (MYRANK .eq. 0) write (iout,1000) label(1:llabel),intg,
     -    'over its upper',maxval
        inperr=inperr+1
        if (ireset .eq. 1) intg=maxval
      end if
      ifail=inperr-inperr0
      return
1000  format(' ***** ERROR: ',a,'=',i9,' is ',a,' limit (',i9,')')
      end
      subroutine checkcompopt(icompopt,key,sym,inperr,iout)
c#    MMC routine  23/b lstmod: 11/08/21
c*****Checks Check if a preprocessor option needes has been set
      character*2 sym
      character*4 key
      if (icompopt .eq. 0) then
        write (iout,1000) key,sym
        inperr=inperr+1
      end if
      return
1000  format(' ***** ERROR: the ',a4,' key needs the lines with C@',a2,
     -  /,7x,'- in the preprocesor change F to T in the corresponding ',
     -  'setdefopt call')
      end
      subroutine checkdisc(nmcmax,nmcdisc,iout,inperr)
c#    MMC routine  24 lstmod: 11/19/04
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      if (nmcdisc .ge. nmcmax .and. nmcmax .gt. 0) then
        if (MYRANK .eq. 0) write (iout,1000) nmcmax,nmcdisc
        inperr=inperr+1
      end if
      return
1000  format(' ***** ERROR: the number of steps to use (',i10,
     -  ') does not exceed the number of steps to discard (',i10,')')
      end
      subroutine checkint(intg,label,nlen,iout,nwwarn,inperr)
c#    MMC routine  25 lstmod: 11/19/04
      character*(*) label
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      maxint=2**(isize-2)
      if (intg .lt. 0) then
        if (MYRANK .eq. 0) write (iout,1000) label(1:nlen),intg
        inperr=inperr+1
      else if (intg .gt. 0) then
        if (maxint/intg .lt. 2) then
          if (MYRANK .eq. 0) write (iout,1001) label(1:nlen),intg
          nwwarn=nwwarn+1
        end if
      end if
      return
1000  format(' ***** PROGRAM ERROR: the value of ',a,' is negative:',
     -  i10)
1001  format(' ===== STRONG WARNING: the value of ',a,' (',i10,') is ',
     -  'more than half of the largest integer(',i10,')')
      end
      subroutine nextchar(line,ifc,nocomm,inpt,iout)
c#    MMC routine  26 lstmod: 05/07/20
c*****Finds the next nonblank in line
      character*80 line
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      if (ifc .gt. 80 .or. ifc .lt. 1) return
10    ifc1=ifc
      do i=ifc1,80
        ifc=i
        if (line(i:i) .ne. ' ' .and. line(i:i) .ne. tab) then
          if (line(i:i) .eq. '~') then
C@DM            if (MYRANK .eq. 0) then
            ireadok=0
            read (inpt,1000,end=999) line
            ireadok=1
999         write (iout,2005) line
C@DM            end if
C@DM            call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
            if (ireadok .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2000)
              return
            end if
C@DM            call MPI_Bcast(line,80,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
            ifc=1
            go to 10
          else if (line(i:i) .eq. ctrlM) then
            line(i:i)=' '
            ifc=82
          else if (line(i:i) .eq. '|') then
            ifc=-ifc
          else if (line(i:i) .eq. '!' .and. nocomm .eq. 0) then
            ifc=82
          end if
          return
        end if
      end do
      ifc=81
      return
1000  format(a80)
2000  format(' ***** ERROR: Run out of data')
2005  format(' Input continuation line : ',a80)
      end
      subroutine nextblank(line,ifc,nocomm)
c#    MMC routine  27 lstmod: 05/07/20
c*****Finds the next blank in line
      character*80 line
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      if (ifc .gt. 80 .or. ifc .lt. 1) return
      ifc1=ifc
      do i=ifc1,80
        ifc=i
        if (line(i:i) .eq. ' ' .or. line(i:i) .eq. tab .or.
     -      line(i:i) .eq. '~') return
        if (line(i:i) .eq. '!' .and. nocomm .eq. 0
     -      .or. line(i:i) .eq. ctrlM) then
c         Comments or line end found - just blank out the rest of the line
          do j=i,80
            line(j:j)=' '
          end do
          return
        else if (line(i:i) .eq. '|') then
          ifc=-ifc
          return
        end if
      end do
      ifc=81
      return
      end
      subroutine blankout(line,ifc,ilc)
c#    MMC routine  27/a lstmod: 110/266
c*****Blanks out a line
      character*(*) line
      do ic=ifc,ilc
        line(ic:ic)=' '
      end do
      return
      end
      subroutine lastchar(line,ilc,maxchar)
c#    MMC routine  27/b lstmod: 10/26/06
c*****Finds the last nonblank, non tab, non cntrl-M in line
      character*(*) line
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      ilc=maxchar
      do while (ilc .gt. 1 .and. (line(ilc:ilc) .eq. ' ' .or.
     -  line(ilc:ilc) .eq.  tab .or. line(ilc:ilc) .eq. ctrlM))
        ilc=ilc-1
      end do
      return
      end
      subroutine readpmf(inpt,iout,iopnrm,iopeql,iopenc,nitssk,faclim,
     -  fcenc1,smplmx,ratmax,rldvmx,diffmx,ngovmn,nsubmn,ngrcor,
     -  negitdel,nwtst,fcenc2,encexp,tolera,cplmin,cplmax,delcpl,
     -  c0cplh,p0cplh,wcplcha,iop24,iop51,iop55,MYRANK)
c#    MMC routine  28 lstmod: 07/31/12
c*****Input PMF parameters, set defaults
c     cplmin,cplmax: cplpar limits for probability ratio meth
c     for harmonic weighting, uh=c0cplh*(cplpar-p0cplh)**2
c     delcpl: stepsize for coupling parameter
c     wcplcha: relative frequency of cpl par changes wrt slt move and
c     partial slt changes
      character*80 line
      common /inpline/ line,lineno,icol
      irectx=6
      call getnextrec(inpt,iout,irectx,nwwarn)
      read (line,1005,err=999) j,j,j,iop55,
     -  cplmin,cplmax,delcpl,c0cplh,p0cplh,wcplcha
      if (iop24 .gt. 0 .and. MYRANK .eq. 0) write (iout,1306)
     -   j,j,j,iop55,cplmin,cplmax,delcpl,c0cplh,p0cplh,wcplcha
      if (wcplcha .eq. 0.0) wcplcha=1.0
      if (iop51 .ge. 1) then
        irectx=7
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1005,err=999) iopnrm,iopeql,iopenc,nitssk,
     -    faclim,fcenc1,smplmx,ratmax,rldvmx,diffmx
        if (iop24 .gt. 0 .and. MYRANK .eq. 0) write (iout,1307) iopnrm,
     -    iopeql,iopenc,nitssk,faclim,fcenc1,smplmx,ratmax,rldvmx,diffmx
        irectx=8
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1005,err=999) ngovmn,nsubmn,ngrcor,nwtst,
     -    fcenc2,encexp,tolera
        if (iop24 .gt. 0 .and. MYRANK .eq. 0) write (iout,1308)
     -    ngovmn,nsubmn,ngrcor,nwtst,fcenc2,encexp,tolera
        cplpar=0.0
        if (ngrcor .eq. 0) ngrcor=5
        if (ratmax .eq. 0.0) ratmax=2.0
        if (faclim .eq. 0.0) faclim=0.5
        if (fcenc1 .eq. 0.0) fcenc1=2.0
        if (rldvmx .eq. 0.0) rldvmx=1.e-4
        if (ngovmn .eq. 0) ngovmn=4
        if (nsubmn .eq. 0) nsubmn=5
c       For now,
        negitdel=2
        if (diffmx .eq. 0.0) diffmx=0.9
        if (fcenc2 .eq. 0.0) fcenc2=1.05
        if (iopenc .gt. 0 .and. encexp .eq. 0.0) encexp=0.75
        if (iopenc .lt. 0 .and. encexp .eq. 0.0) encexp=1.00
        if (tolera .eq. 0.0) tolera=0.06001
      end if
      return
999   call invalidform(iout,irectx)
1005  format(4i5,6f10.0)
1306  format(' rectype  6  : ',4i5,6f10.4)
1307  format(' rectype  7  : ',4i5,6f10.4)
1308  format(' rectype  8  : ',4i5,6f10.4)
      end
      subroutine anneal_inp(key,temp)
c#    MMC routine  28/a lstmod: 12/18/14
c*****Input simulated annealing parameters
      character*4 key
      real*8 ucsm_prev,u_prev,uslt_prev,uttnb_prev,uinnb_prev
      common /anneal/ ucsm_prev,u_prev,uslt_prev,uttnb_prev,
     -  uinnb_prev,nmctempstep,ntemplist,ntempstep,ntempsteptot,
     -  ntempstepcum,isannread,templist(100),temp0,tempstep,tempexp,
     -  tempfin
      common /io/ inpt,iout,ifiles(10),ic0,itx,inperr,nwarn,nwwarn,nchng
      ntempstep=0
      tempfin=0.0
      if (key .ne. 'NONE') call getint(nmctempstep,1,1,0)
      if (key .eq. 'LINE') then
        call getreal(tempstep,1,0.0)
        if (tempstep .eq. 0.0) then
          call getreal(tempfin,1,0.0)
          if (tempfin .eq. 0) then
            write (iout,2183) 'tempstep'
            inperr=inperr+1
          end if
        end if
      else if (key .eq. 'EXPO') then
        call getreal(tempexp,1,0.0)
        if (tempexp .eq. 0.0) then
          call getreal(tempfin,1,0.0)
          if (tempfin .eq. 0) then
            write (iout,2183) 'tempexp'
            inperr=inperr+1
          else
          end if
        end if
      else if (key(1:3) .eq. 'LOG') then
        call getreal(tempexp,1,0.0)
        if (tempexp .eq. 0.0) then
          call getreal(tempfin,1,0.0)
          if (tempfin .eq. 0) then
            write (iout,2183) 'coef_log'
            inperr=inperr+1
          else
          end if
        end if
      else if (key .eq. 'LIST') then
        call getint(ntemplist,1,1,0)
        if (ntemplist .gt. 100) then
          write (iout,2182)
          inperr=inperr+1
        end if
        tempprev=temp
        do i=1,ntemplist
          call getreal(templist(i),1,0.0)
          if (templist(i) .ge. tempprev) then
            write (iout,2209) i,templist(i),tempprev
            nwarn=nwarn+1
          end if
          tempprev=templist(i)
        end do
      end if
      ucsm_prev=0.d0
      u_prev=0.d0
      uslt_prev=0.d0
      uttnb_prev=0.d0
      uinnb_prev=0.d0
      return
2182  format(' ***** ERROR: temperature list exceeds limit (100)')
2183  format(' ***** ERROR: either ',a,' or tempfin should be non-zero')
2209  format(' ----- WARNING: temperature list member #',i4,' (',f8.2,
     -  ') is greater than the previous temperature (',f8.2,')')
      end
      subroutine anneal_cp_inp(bincr,nmcsacpstep,cav_fract_lim)
c#    MMC routine  28/b lstmod: 03/27/21
c*****Input chemical potential simulated annealing parameters
      call getreal(bincr,1,0.0)
      call getint(nmcsacpstep,1,1,0)
      call getreal(cav_fract_lim,1,0.85)
      return
      end
      subroutine extrap_ann_2(ntarget,incr,iout)
c#    MMC routine  28/c lstmod: 06/06/22
c     Extrapolate B to N=0
      common /anneal_cp/ nmcsacpstep,nmcsacpsteppnmol,maxbsave,
     -  nstep_ann,nmcav0,nligsave(500),avgligsave(500),bsave(500),
     -  bincr,cav_fract_lim
      write (iout,2000) (i,bsave(i),nligsave(i),avgligsave(i),
     -  i=incr+1,nstep_ann)
      call extrap_ann(ntarget,avgligsave,bsave,nstep_ann,incr,'<N>',3,
     -  iout,maxbsave)
      do i=incr+1,nstep_ann
        avgligsave(i)=float(nligsave(i))
      end do
      call extrap_ann(ntarget,avgligsave,bsave,nstep_ann,incr,'N',1,
     -  iout,maxbsave)
      return
2000  format(/,' Annealing data for extrapolation',/,
     -  (' Step ',i4,' B=',f9.2,' N=',i7,' <N>=',f9.2))
      end
      subroutine extrap_ann(ntarget,avgligsave,bsave,nstep_ann,incr,lab,
     -  llab,iout,maxbsave)
c#    MMC routine  28/d lstmod: 06/06/22
      dimension avgligsave(maxbsave),bsave(maxbsave)
      character*(*) lab
      real*8 rnsum,rbsum,rnum,rden
      rnsum=0.d0
      rbsum=0.d0
      do i=incr+1,nstep_ann
        if (avgligsave(i) .gt. 0.0) then
          avgligsave(i)=alog(avgligsave(i))
        else
          write (iout,2001) i
          call datprt(2)
        end if
        rnsum=rnsum+avgligsave(i)
        rbsum=rbsum+bsave(i)
      end do
      rnsum=rnsum/dfloat(nstep_ann-incr)
      rbsum=rbsum/dfloat(nstep_ann-incr)
      rnum=0.d0
      rden=0.d0
      do i=incr+1,nstep_ann
        rnum=rnum+(avgligsave(i)-rnsum)*(bsave(i)-rbsum)
        rden=rden+(avgligsave(i)-rnsum)**2
      end do
      a=rnum/rden
      b=rbsum-a*rnsum
      write (iout,2000) lab(1:llab),lab(1:llab),a,b,ntarget,
     -  a*alog(float(ntarget))+b
      return
2000  format(/,' Fitting ln(',a,') to B as B=a*ln(',a,')+b:',/,
     -  ' a=',e12.5,' b=',e12.5,' B(',i4,')=',f9.2)
2001  format(' ***** PROGRAM ERROR: <N> is zero at annealing step',i6)
      end
      subroutine setanchor(ianslt,qslt,labslt,nslt,nhbanchor,ihbanchor,
     -  nbridgeat,bridgeat,qbmin,ianctyp,inperr,iout)
c#    MMC routine  29 lstmod: 05/05/10
      character*4 labslt,bbats,bridgeat
      dimension ianslt(nslt),qslt(nslt),labslt(2,nslt),ihbanchor(nslt)
      dimension bbats(6),bridgeat(100)
      character*4 name
      data bbats /'O   ',' O  ','H   ',' H  ','HN  ',' HN '/,nbbats /6/
c*****Establish H-bonded bridge anchor atoms
      nhbanchor=0
      if (ianctyp .eq. 1) then
c       Input anchor list
        call getint(nhbanchor,1,1,0)
        if (nhbanchor .gt. nslt) then
          write (iout,1000) nhbanchor
          inperr=inperr+1
          nhbanchor=0
        end if
        do ia=1,nhbanchor
          call getint(ihbanchor(ia),1,1,0)
          if (ihbanchor(ia) .gt. nslt) then
            write (iout,1001) ihbanchor(ia)
            inperr=inperr+1
          end if
        end do
      else if (ianctyp .eq. 2 .or. ianctyp .eq. 3) then
        if (ianctyp .eq. 2) then
c         Select backbone atoms
          do it=1,nbbats
            bridgeat(it)=bbats(it)
          end do
          nbridgeat=nbbats
        else
c         Input atom name list
          call getint(nbridgeat,1,1,0)
          if (nbridgeat .gt. 100) then
            write (iout,1002) nbridgeat
            inperr=inperr+1
            nbridgeat=100
          end if
          do it=1,nbridgeat
            call getname(name,len,1,4)
            bridgeat(it)='    '
c           Replace period with space
            do ic=1,len
              if (name(ic:ic) .ne. '.') bridgeat(it)(ic:ic)=name(ic:ic)
            end do
          end do
        end if
c       Gather all solute atoms with bridgeat names
        do ia=1,nslt
          do it=1,nbridgeat
            if (labslt(2,ia) .eq. bridgeat(it)) then
c             Anchor atom found
              nhbanchor=nhbanchor+1
              ihbanchor(nhbanchor)=ia
              go to 9133
            end if
          end do
9133      continue
        end do
      else
c       Select by partial charge
        call getreal(qbmin,0,0.3)
        do ia=1,nslt
          if (qslt(ia) .lt. -qbmin .or.
     -       (qslt(ia) .gt. qbmin .and. ianslt(ia) .eq. 1)) then
            nhbanchor=nhbanchor+1
            ihbanchor(nhbanchor)=ia
          end if
        end do
      end if
      return
1000  format(' ***** ERROR: invalid number of H-bonded bridge anchor ',
     -  'atoms:',i7)
1001  format(' ***** ERROR: invalid H-bonded bridge anchor atom:',i7)
1002  format(' ***** ERROR: number of H-bonded bridge anchor atoms ',
     -  'exceeds 100 - redimension bridgeat')
      end
      subroutine scalestep(itype,scalefac,isetscale,iscalestep,
     -  irestorestep,ireport,iverb,inperr,iout)
c#    MMC routine  29/a lstmod: 10/31/07
c*****Temporary rescaling of a selected stepsize type
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /stepscale/ scalefactors(8),
     -  cedslv0,rtxslv0,cedslt0,rtxslt0,cedpslt0(3),rtxpslt0(3)
      character*27 movename
      common /move_name/ movename(8)
      if (itype .eq. 0) return
      if (isetscale+iscalestep+irestorestep+ireport .ne. 1) then
        write (iout,1000) isetscale,iscalestep,irestorestep,ireport
        inperr=inperr+1
        return
      end if
      if (isetscale .eq. 1) then
        scalefactors(itype)=scalefac
        if (iverb .gt. 1) write (iout,1002) movename(itype)
      else if (iscalestep .eq. 1) then
c       Modfy requisite stepsizes
        if (iverb .gt. 1) write (iout,1003)
        if (scalefactors(1) .ne. 1.0) then
          cedslv0=cedslv
          cedslv=cedslv*scalefactors(1)
        else if (scalefactors(2) .ne. 1.0) then
          rtxslv0=rtxslv
          rtxslv=rtxslv*scalefactors(2)
        else if (scalefactors(3) .ne. 1.0) then
          cedslt0=cedslt
          cedslt=cedslt*scalefactors(3)
        else if (scalefactors(4) .ne. 1.0) then
          rtxslt0=rtxslt
          rtxslv=rtxslv*scalefactors(4)
        else if (scalefactors(5) .ne. 1.0) then
          do k=1,3
            cedpslt0(k)=cedpslt(k)
            cedpslt(k)=cedpslt(k)*scalefactors(5)
          end do
        else if (scalefactors(6) .ne. 1.0) then
          do k=1,3
            rtxpslt0(k)=rtxpslt(k)
            rtxpslt(k)=rtxpslt(k)*scalefactors(6)
          end do
        else if (scalefactors(7) .ne. 1.0) then
          do it=1,#TR
            accsumtor(it)=torstep(it)
            torstep(it)=torstep(it)*scalefactors(7)
          end do
        else if (scalefactors(8) .ne. 1.0) then
          do it=1,#LT
            stepsumloop(it)=steploop(it)
            steploop(it)=steploop(it)*scalefactors(8)
          end do
        end if
      else if (irestorestep.eq. 1) then
c       Restore stepsizes
        if (iverb .gt. 1) write (iout,1004)
        if (scalefactors(1) .ne. 1.0) then
          cedslv=cedslv0
        else if (scalefactors(2) .ne. 1.0) then
          rtxslv=rtxslv0
        else if (scalefactors(3) .ne. 1.0) then
          cedslt=cedslt0
        else if (scalefactors(4) .ne. 1.0) then
          rtxslt=rtxslt0
        else if (scalefactors(5) .ne. 1.0) then
          call trnsfr(cedpslt,cedpslt0,3)
        else if (scalefactors(6) .ne. 1.0) then
          call trnsfr(rtxpslt,rtxpslt0,3)
        else if (scalefactors(7) .ne. 1.0) then
          do it=1,#TR
            torstep(it)=accsumtor(it)
          end do
        else if (scalefactors(8) .ne. 1.0) then
          do it=1,#LT
            steploop(it)=stepsumloop(it)
          end do
        end if
        do i=1,8
          scalefactors(i)=1.0
        end do
      else
c       Report stepsize changes
        do i=1,8
          if (scalefactors(i) .ne. 1.0)
     -       write (iout,1001) movename(i),scalefactors(i)
        end do
      end if
      return
1000  format(' ***** PROGRAM ERROR: not exactly one of the options is ',
     -  'set: setscale,iscalestep,irestorestep,ireport=',2i3)
1001  format(' Stepsize(s) for ',a,' have been scaled by ',f8.4,
     -  ', for this run only')
1002  format(' Setting stepsize scale factor for ',a)
1003  format(' Stepsizes are scaled as requested')
1004  format(' Scaled stepsizes are restored')
      end
      subroutine pfswinp(ipfs,iecho,npf,rpf,apf,iopcent,wpfcen,stiff,
     -  irecnoincr,inperr,inpt,iout)
c#    MMC routine  30 lstmod: 09/19/07
c*****Input preferential sampling specification
      dimension rpf(9),apf(9),wpfcen(3)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*80 line
      common /inpline/ line,lineno,icol
      if (iopcent .eq. 2) then
        call getreal(wpfcen(1),1,0.0)
        call getreal(wpfcen(2),1,0.0)
        call getreal(wpfcen(3),1,0.0)
      end if
      if (ipfs .lt. 3) then
        irectx=irecnoincr+1
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1007,err=999) npf
        if (iecho .gt. 0) write (iout,1332) npf
        if (npf .gt. 9) then
          inperr=inperr+1
         if (MYRANK .eq. 0)  write (iout,9356) npf
        end if
      end if
      if (ipfs .eq. 1) then
c       Input piecewise linear weight function
        irectx=irecnoincr+2
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1011,err=999) (rpf(i),apf(i),i=1,npf)
        if (iecho .gt. 0) write (iout,1333)
     -    (rpf(i),apf(i),i=1,npf)
        do i=2,npf
          if (rpf(i) .lt. rpf(i-1)) then
            inperr=inperr+1
            if (MYRANK .eq. 0) write (iout,9350) rpf(i),rpf(i-1)
          end if
        end do
      else if (ipfs .eq. 2) then
c       Input polynomial weight function
        if (npf .lt. 3) then
          inperr=inperr+1
          if (MYRANK .eq. 0) write (iout,9351) npf
        end if
        irectx=irecnoincr+3
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1011,err=999) (apf(i),i=1,npf)
        if (iecho .gt. 0) write (iout,1334) (apf(i),i=1,npf)
      else
c       Input exponential weight function
        irectx=irecnoincr+4
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1011,err=999) stiff,stvar
        if (iecho .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1335) stiff,stvar
        if (stvar .lt. 0.00001) then
          stiff=0.
        else
          stiff=stiff/stvar**2
        end if
      end if
      return
999   call invalidform(iout,irectx)
1007  format(i5)
1011  format(10f7.0)
1332  format(' rectype 1  : ',i5)
1333  format(' rectype 2  : ',10f7.3)
1334  format(' rectype 3  : ',10f7.3)
1335  format(' rectype 4  : ',10f7.3)
9350  format(' ***** ERROR: piecewise linear function r values ',
     -  'are not increasing:',2f8.3)
9351  format(' ***** ERROR: polynomial weight function needs at',
     -  ' least 3 terms and only ',i2,' was given')
9356  format(' ***** ERROR: number of terms in the preferential ',
     -  'sampling weight data is > 9 :',i5)
      end
      subroutine setup(noenergy,iconfread,iop47read,sltinptyp,itang)
c#    MMC routine  31 lstmod: 05/30/20
c*****Performs initalization calls before the MC run
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      character*4 sltinptyp
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /wadaptf/ ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,rldvmx,
     -  diffmx,tolera,iopnrm,iopeql,iopenc,nitssk,nwtst,nsubmn,ngovmn,
     -  ngrcor,negitdel
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      common /fblam/ wfblam(#PG),rfblam(9),afblam(9),nfblam
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 ew0nb,teslt1,teslt1n,uwnb,uwnbn,uwnbmin,uwnbmax,
     -  etsincr
      common /nonboltz/ ew0nb,teslt1,teslt1n,
     -  uwnb,uwnbn,uwnbmin,uwnbmax,etsincr,tornbfac,repnbfac,slttmp,
     -  sltsltfac,signincfac,tsexp,tsfac
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      real*8 setpoint,gain_n,gain_den,integraltime,oldpv,controlerror,
     -  dbetadt,dpvdt
      common /control/ setpoint,gain_n,gain_den,integraltime,oldpv,
     -  controlerror,dbetadt,dpvdt
      real*8 rnsumprev,uavcorprev,delndelbsum
      common /tuneb/ rnsumprev(2),uavcorprev,delndelbsum,nitconv,
     -  nunphys,nmctunskip,nmctunave,nmclastch,ntune,nmccorprev,
     -  ndelndelbsum,inorout,targetden,targetn,tolden,toln,delndelb0,
     -  rnaviprev,baprev,chabmax,pv
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      real*8 x1a,x2a,x3a,x1b,x2b,x3b
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 efieldst0,efieldmst
      common /fieldenergy/ efieldst0,efieldmst(#MM),
     -  efieldsv(#MO),esltfldo(#ST),esltfldn(#ST)
      real*8 emolstsm,emolsvsm,emolim
      common /specenergy/ emolsvsm(#MO),emolstsm(#MM),emolim
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      character*7 inoutlab
      common /inoutlabel/ inoutlab(2)
      common /griderror/ ngriderr,nhbgriderr,igridprint,griderrmax
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /mcydat/ qq,dqq,a1,a2,a3,a4,b1,b2,b3,b4,ab1,ab2,ab3,ab4,qqq
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      character*1 lxyz
      common /names/ lxyz(3)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 stinout,esmslv,uwcpl,teslt
C@FR      real*8 vsumx
      dimension rgd(3),stinout(2),nstinout(2),keycol(2)
      character*7 filnam
C@DM      include "mpif.h"
      if (iop(99) .eq. 0) iop(99)=1
      if (iop(58) .eq. 0) call zeroiti(moltused,0,nsttm)
      call settol(nstta,nstfa,nmolec,iout)
      if (iop(10) .eq. 0) then
c       Initialize
        if (iop(30) .eq. 7 .and. iop(120) .eq. 0)
     -    call inicpl(faclim,cplpar,cplimn,cplimx,iop(51),tolera)
        call inicac
C@DB        print *,'INICAC done'
C@DB        call echopr(1)
        if (inperr .gt. 0) then
c         With errors in the input just call echopr and abort the run
C@DM          if (MYRANK .eq. 0) then
          call echopr(1)
          call checksizes(iop,ifail,inperr,iout,nmolec,nslvn,nsltn,
     -      nslte,nsttg,nstta,ngfree,nstfa0)
C@DM          end if
          call datprt(-1)
        end if
        call findor(orient,orientsltm,c,crm,crm0,iconfread,iop47read)
        if (iop(58) .gt. 0 .and. iop(91) .eq. 0) then
c         When torsion is active, regenerate solute
c         to reduce error accumulation and consequent self test failure
          call regenerate(c,0,1,iout,nerr,devmax)
          if (nerr .gt. 0) then
C@DM          if (MYRANK .eq. 0) then
            if (devmax .gt. 0.5 .and. idebug(61) .eq. 0) then
              write (iout,2019) '***** ERROR',devmax
              inperr=inperr+1
              if (idebug(97) .gt. 0) then
                lfilnam=11
                filnam(1:lfilnam)='DEBUG_T.pdb'
                call savepdb('PDB ',keycol,iupdb1,iout,1,nstta,3,c,
     -            -1,0,0,1,file,nfl,nmc,2,filnam,lfilnam,1,1,0,inperr,
     -            nwarn,nwwarn,9,0,nlwr,0,1,#NA)
              end if
            else
              write (iout,2019) '----- WARNING',devmax
              nwarn=nwarn+1
            end if
C@DM          end if
          end if
          if (MYRANK .eq. 0) write (iout,2020)
          call findor(orient,orientsltm,c,crm,crm0,iconfread,iop47read)
        end if
C@DB        print *,'FINDOR done'
        if (iop(41) .eq. 1 .or. iop(41) .eq. 2 .and. inperr .eq. 0) then
          do k=1,3
            ranshift(k)=0.5d0
          end do
c         First call initgrid with zero cavity radius to estimate solute vol
          if (diamslv .gt. 0.0) call initgrid(1,0.0,diamslv/2.0,1,
     -      vsltgr,vol,c,crm,0,0,0,'GCEN R0',1,0)
          call initgrid(nmolec,1.,diamslv/2.0,1,vsltgrx,vol,
     -      c,crm,0,0,0,'GCEN RR',1,0)
          ncrossin=0
          ncrossout=0
        else
          vsltgr=0.0
        end if
        if (iop(76) .gt. 0) then
c         B-tuning initialization
          call initinout(molinout,nmolinout,edgelinxyz,edgerinxyz,crm,
     -      2,nmolec)
          if (targetn .le. 0) then
            if (inorout .eq. 1)targetn=targetden*volin/(wmslv*wmmltona3)
            if (inorout .eq. 2)
     -        targetn=targetden*(vol-volin)/(wmslv*wmmltona3)
          else
            if (inorout .eq. 1)targetden=targetn*(wmslv*wmmltona3)/volin
            if (inorout .eq. 2)
     -        targetden=targetn*(wmslv*wmmltona3)/(vol-volin)
          end if
          if (iop(76) .lt. 3) then
c           Discrete iterations
            toln=tolden*targetden/targetn
            ntune=0
c           For SPC water at <N>=90, <N**2>-<N>**2=4.1
            delndelb0=4.1*sqrt(targetn/90.0)
            delndelbsum=0.d0
            ndelndelbsum=0
            nitconv=0
            if (iop(76) .eq. 1) then
c             Adaptive version
              nunphys=0
              rnaviprev=0.0
            else
              if (iop(11) .eq. 3 .or. iop(11) .eq. 4) then
                write (iout,2043)
                write (iout,2042)
                inperr=inperr+1
              else
                diffperc=(float(nmolinout(inorout))-targetn)/targetn
                if (diffperc .lt. -0.1) then
                  idiffperc=-100.0*diffperc
                  write (iout,2040) idiffperc
                  write (iout,2042)
                  nwwarn=nwwarn+1
                end if
              end if
            end if
          else if (iop(76) .eq. 3) then
c           B-tuning initialization (process control version)
            setpoint=targetn
            gain_n=gain_den*targetden/targetn
            pv=nmolinout(inorout)
            oldpv=pv
            if (idebug(40) .gt. 1) write (iout,2039) setpoint,oldpv,
     -        targetden,targetn,gain_n,gain_den
          end if
c         Check if solute is inside/outside the MOND box
          call initinout(l1,nstinout,edgelinxyz,edgerinxyz,c,1,nstta)
          if (nstinout(inorout) .gt. 0) then
            write (iout,2041) inoutlab(inorout),nstinout(inorout)
            nwwarn=nwwarn+1
          end if
        end if
        if (iop(107)+idebug(40) .gt. 0 .and. itang .eq. 1) then
c         Stepsize tuning initialization
c         Set initial acc rate 0 (instead of target) to avoid extra weight
          if (iop(57) .gt. 0) then
            do im=movmolf,movmoll
              accsumtrans(im)=0.d0
              accsumtransprev(im)=0.d0
              ntrantune(im)=0
              do k=1,3
                accsumrot(k,im)=0.d0
                accsumrotprev(k,im)=accsumrot(k,im)
                stepsumtrans(k,im)=cedpsltim(k,im)
                stepsumrot(k,im)=rtxpsltim(k,im)
                stepsumtranscumu(k,im)=0.d0
                stepsumrotcumu(k,im)=0.d0
                nrottune(k,im)=0
              end do
            end do
          end if
          do it=1,ntang
            accsumtor(it)=0.d0
            stepsumtorcumu(it)=0.d0
            accsumtorprev(it)=accsumtor(it)
            stepsumtor(it)=torstep(it)
            if (iop(91) .gt. 0) then
              accsumloop(it)=0.d0
              stepsumloopcumu(it)=0.d0
              accsumloopprev(it)=accsumloop(it)
              stepsumloop(it)=steploop(it)
            end if
          end do
        end if
        if (noenergy .eq. 1) return
        if (MYRANK .eq. 0) call echopr(0)
C@DB        print *,'ECHOPR done'
        call checksizes(iop,ifail,inperr,iout,nmolec,nslvn,nsltn,nslte,
     -    nsttg,nstta,ngfree,nstfa0)
        if (iop(3) .gt. 9) then
C@DM          if (MYRANK .eq. 0) then
          if (sltinptyp .eq. 'CRD ' .or. sltinptyp .eq. 'PDB ') then
            write (iout,2038)
          else
            write (iout,2035)
          end if
C@DM          end if
          inperr=inperr+1
        end if
        if (inperr .gt. 0) return
        if (iop(6) .eq. 6)
     -     call linwgt(nfblam,rfblam,afblam,wfblam,ri,#PG,inperr,iout)
        dijmin=1.e+10
c       Calculation of initial total energy
c       etoto, etotn: total energy before and after a perturbation in kcal/mol
c       emin, emax: minimum and maximum accepted total energies during the run
c       nmin,nmax: stepnumbers/1000 for the occurrence of emin,emax, resp.
        igridprint=1
        ngriderr=0
        nhbgriderr=0
        call eism0(1,0,noverl,nfsslt,nfslww,ksltmn,ncor,
     -    tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -    tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -    nslvdsid,gbuupd,gbuupt,esmslv,c,crm,nmc)
        if (ngriderr .gt. 0) write (iout,2045) ngriderr,' '
        if (nhbgriderr .gt. 0)
     -    write (iout,2045) nhbgriderr,' hydrogen-bond '
        nwarn=nwarn+nhbgriderr+ngriderr
        igridprint=0
        if (iop(53) .ge. 1 .and. uscpma .lt. -1000.) then
          uscpma = tss1 / float(nmolec-1)
          bxxx=ba-beta*uscpma
          if (MYRANK .eq. 0) write (iout,2025) uscpma,usmixp,bxxx
        end if
        if (iop(96) .ge. 1) then
          if (iop(96) .eq. 1) then
c           Scale torsion terms
            if (ew0nb .eq. 0.d0) ew0nb=eslttoro
            write (iout,2036) 'torsion',ew0nb
            uwnb=dexp(-dble(beta*tornbfac)*(eslttoro-ew0nb))
          else if (iop(96) .eq. 2) then
c           Scale slt-slv repulsion terms
            if (ew0nb .eq. 0.d0) ew0nb=tss12
            write (iout,2036) 'solute-solvent repulsion',ew0nb
            uwnb=dexp(-dble(beta*repnbfac)*(tss12-ew0nb))
          else if (iop(96) .eq. 3) then
c           Switch solute temperature
            teslt=tesi(1)+ettnbo+einnbo+es14o+eslttoro
            if (ew0nb .eq. 0.d0) ew0nb=teslt
            uwnb=dexp(dble(beta*(temp/slttmp-1.0))*(teslt-ew0nb))
            write (iout,2036) 'off-temperature',ew0nb
            if (idebug(84) .gt. 0) write (iout,2037) uwnb,teslt
          else if (iop(96) .eq. 4) then
c           Tsallis
            teslt=tesi(1)+ettnbo+einnbo+es14o+eslttoro
            teslt1=(1.d0-(1.d0-tsexp))*(beta*teslt)
            if (teslt1 .lt. 0.d0) then
c             Make sure that no negative logarithm argument will arise
              etsincr=-signincfac*teslt1
              teslt1=teslt1+etsincr
            else
              etsincr=0.d0
            end if
            if (ew0nb .eq. 0.d0)
     -        ew0nb=(dble(tsfac/beta)*dlog(teslt1)+teslt)
            uwnb=dexp(-dble(beta)*
     -        (dble(tsfac/beta)*dlog(teslt1)+teslt-ew0nb))
            if (MYRANK .eq. 0) write (iout,2036) 'solute',ew0nb
            if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,2037) uwnb,teslt,' ',teslt1,etsincr
          else if (iop(96) .eq. 5) then
c           Scale solute intra non-bonded term
            if (ew0nb .eq. 0.d0) ew0nb=einnbo
            if (MYRANK .eq. 0) write (iout,2036)
     -        'solute non-bonded intra',ew0nb
            uwnb=dexp(-dble(beta*sltsltfac)*(einnbo-ew0nb))
          else
c           Scale solute non-bonded  and torsion terms
            if (ew0nb .eq. 0.d0) ew0nb=eslttoro
            if (MYRANK .eq. 0) write (iout,2036)
     -        'solute non-bonded',ew0nb
            uwnb=dexp(-dble(beta*tornbfac)*(eslttoro-ew0nb))
          end if
          uwnbmin=uwnb
          uwnbmax=uwnb
        end if
        call trnsfr(tsind,tsindn,nmol3)
        if (noverl .gt. 0) then
          if (MYRANK .eq. 0) then
            write (iout,2022) noverl
            if (iop(24) .lt. 2) write (iout,2023)
            if (iop(41) .gt. 0) write (iout,2021)
          end if
          nwarn=nwarn+1
          if ((iop(21) .eq. 1 .or. iop(21) .eq. 2)
     -        .and. iop(33) .ne. 0) then
c           Stop calculation when overlap was found and vectorized routines
c           are called since getxy, getevy do not handle inner cutoff
            if (MYRANK .eq. 0) write (iout,2017)
            call datprt(2)
          end if
        end if
        emin=etoto
        emax=etoto
        emaxchange=0.0
        eminh=etoto
c       dele: current energy difference e1-e2 (for perturbation method calc.)
c       delest is the initial energy difference e&+ - e&- (in kcal/mol)
        delest=e1o-e0o+(einnb01(2,1)-einnb01(1,1))
c       del0st, del1st: initial energy differences e& - e&- , e&+ - e&, (au)
        del0st=tesi(1)-e0o
        del1st=e1o-tesi(1)
c       Correct the energy grid minima with del0st, del1st
        gmor0k=gmor0k-del0st
        gmor1k=gmor1k-del1st
c       de01mn, de01mx: min and max of (e1-e0) found at nmc=
c       nm01mn, nm01mx, respectively
        de01mn=delest
        de01mx=de01mn
        nm01mn=0
        nm01mx=0
        nmin=0
        nmax=0
c       Save the contributions to the slt eng from outside the inscr. sphere
        eout0=tesi(1)-estsco
c       Initialize preferential weight tables
        if (iop(12) .gt. 3 .and. nmolec-mvfst .gt. 0) then
c         Move weight
          call iniprftab(iop(12)-3,npfmv,rpfmv,apfmv,stiffmv,wpsmvn,ri,
     -      inperr,iout)
          call iniprflim(mvfst,nmolec,ipsmv,#MO,'MO',limpsmv,
     -      npfsmv,iout,inperr)
          call iniprf(mvfst,nmolec,wpsmvn,nslvds,wpsmv,wpsmvsum,
     -      wpfpsmv,wpsmax,limpsmv,npfsmv,0)
          if (wpsmvsum .eq. 0.0) then
            write (iout,2010) 'solvent move'
            inperr=inperr+1
          end if
          frcmax=0.4*dlog(dpmx)/(wpsmax*amax1(cd0bt2,cd1bt2,0.1)/2.0)
          trqmax=0.4*dlog(dpmx)/(wpsmax*amax1(ra0bt2,ra1bt2,0.1)/2.0)
        else
          wpsmax=1.0
        end if
        if (iop(63) .gt. 0) then
c         I/D weights of molecules
          call iniprftab(iop(63),npfid,rpfid,apfid,stiffid,wpsidn,ri,
     -      inperr,iout)
          call iniprflim(idsvfst,nmolec,ipsid,#MO,'MO',limpsid,
     -      npfsid,iout,
     -      inperr)
          call iniprf(idsvfst,nmolec,wpsidn,nslvdsid,wpsid,wpsidsum,
     -      wpfpsid,wpsidmax,limpsid,npfsid,iop(79))
c         I/D weights of grid points
          call iniprflim(1,ngfree,ipsgd,#PP,'PP',limpsgd,
     -      npfsgd,iout,inperr)
c         Calculate integer distances for new grids
          do ig=1,ngfree
            indx=igfree(ig)
            call unpackijk(indx,ng1,ic,jc,kc)
            rgd(1)=e2gm(1)+ic*grid(1)
            rgd(2)=e2gm(2)+jc*grid(2)
            rgd(3)=e2gm(3)+kc*grid(3)
c           Obtain integer distance of this grid from PS center
            igfn(ig)=intgpsdis(iop(8),rgd,wpfidcen,rri,c,crm)
          end do
          call iniprf(1,ngfree,wpsidn,igfn,wpsgd,wpsgdsum,
     -      wpfpsgd,wpsidnmax,limpsgd,npfsgd,iop(79))
          if (wpsgdsum .eq. 0.0) then
            write (iout,2010) 'solvent insertion/deletion'
            inperr=inperr+1
          end if
        end if
        call csave(ichkp,1,iskipfail,1)
C@DM        call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
        inperr=inperr+iskipfail
      else
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0) call echopr(0)
      end if
C@FR      vsumx=0.d0
C@FR      do is=2,nmolec
C@FR        do k=1,3
C@FR          vsumx=vsumx+vrcslt(k,is)
C@FR        end do
C@FR      end do
      if (nmolec .eq. 1) then
        evv=0.0
        xsv=0.0
      else
        evv=etoto-tesi(1)-(ettnbo+einnbo+es14o+eslttoro+efieldo+esmolo)
        xsv=evv/(nmolec-1)
        if (xsv .gt. 999.999) xsv=999.998
      end if
      eintra=einnbo+es14o+eslttoro
      emol=efieldo+esmolo
      if (MYRANK .eq. 0) then
        write (iout,2028) etoto,tesi(1),evv,ettnbo,eintra,emol
        if (eintra .ne. 0.0 .or. ettnbo .ne. 0.0)
     -    write (iout,2032) ettnbo,einnbo,es14o,eslttoro
        if (iop(117) .gt. 0) write (iout,2044) econstro
        if (iop(41) .gt. 0) then
          write (iout,2031) nmolec-1
          if (iop(79) .gt. 0)
     -      write (iout,2026) (molinoutgr(im),im=1,nmolec)
        end if
      end if
      if (nmolec .gt. 1) then
C@FR        vs=virial(1)+virial(2)+virial(3)
C@FR        vd=vs-vsumx
C@FR        if (MYRANK .eq. 0) write (iout,2029) vs,vsumx,vd
        if (iop(92) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,2034) ephso,nphsout
          call trnsfr(rphs0isn,rphs0iso,nmolec)
        end if
        if (iop(30) .eq. 5) then
          call e123sum(x1a,x2a,x3a,eone,nmolec)
          call e123sum(x1b,x2b,x3b,etwo,nmolec)
          x12= cplpar**ptiexp(1)*x1b+(1.0-cplpar)**ptiexp(1)*x1a
          x6=-(cplpar**ptiexp(2)*x2b+(1.0-cplpar)**ptiexp(2)*x2a)
          x1= cplpar**ptiexp(3)*x3b+(1.0-cplpar)**ptiexp(3)*x3a
        else
          x12=tss12
          x6=-tss6
          x1=tss1
        end if
        if (MYRANK .eq. 0) write (iout,2024) x12,x6,x1,xsv
      end if
      if (iop(30) .ge. 7 .and. MYRANK .eq. 0) write (iout,2033) cplpar
      if (iop(51) .ge. 1) then
c       Check if the cplpar is in the overflow range of uwcpl
        call cplweight(cplpar,uwcpl,iop(51))
        if (uwcpl .le. 1.d+6/(faclim*dpmx)) then
          if (MYRANK .eq. 0) write (iout,2018) uwcpl
          if (nmcmax .gt. 0 .or. iop(13) .eq. 0) call datprt(2)
        end if
      end if
      if (iop(80) .gt. 0) then
        stinout(1)=nmolinout(1)
        stinout(2)=nmolinout(2)
         if (MYRANK .eq. 0) call denincalc(stinout,stinout,1,
     -    volin,volav,wmslv,wmmltona3,'Current',nmc,nmc,1,1,iout)
      end if
      if (inperr .gt. 0) return
      if (MYRANK .eq. 0) write (iout,2016)
      if (nmcmax .gt. 0 .and. idebug(118) .eq. 0) then
c       Check data on unit ichkp for consistency and start run
        iopfix=iop(48)
        if (iop(10) .eq. 0) iopfix=iop(95)
        ncnt=1
        if (idebug(100) .gt. 0) ncnt=-nmolec
        call selftest(2,iopfix,nfail,ncnt,0,0)
        if (nfail .gt. 0 .and. iop(21) .ne. 3) then
          if (MYRANK .eq. 0) write (iout,2030)filenames(1)(1:namlens(1))
c         Fix situation by calling eism0 and reinitialize
          call fixdev(iout,iopfix,0,noverl,nfsslt,nfslww,ksltmn,
     -      vsltgrx,nwwarn,nfail,ncor,tesi,frctot,trqtot,texslt,
     -      vrcslt,frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind,rcomiso,
     -      rijpso,rphs0iso,diamslv,ipxo,nslvds,nslvdsid,mvfst,ri,rri,
     -      gbuupd,gbuupt,etoto,cslto,nmc,devmax)
        end if
      else if (nmcmax .eq. 0) then
c       nmcmax=0 - just check and print distributions
        if (iop(13) .gt. 0 .and. idebug(118) .eq. 0)
     -    call selftest(iop(13),iop(48),nfail,1,0,0)
        nminus=nmc-nrpt+1
        if (iop(4)+iop(111) .gt. 0)
     -    call wrapup(nminus,nmolec,c,orient,crm,nstta,nslv,iout)
        call disfin(nminus,c,orient,crm,orientsltm,crm0)
        nmcmax=0
      else
        call csave(ichkp,1,iskipfail,1)
      end if
      return
2010  format(' ***** ERROR: weight sum for ',a,' is zero - check the',
     -  ' weight function')
2016  format(' ')
2017  format(' ***** ERROR: Calculation stopped due to overlapping',
     -  ' solvents since vectorized version', /,'      is not able',
     -  ' to handle overlaps. Resubmit with INCT NONE or HRDW SCAL',
     -  ' for the equilibration phase')
2018  format(' ***** ERROR: coupling parameter is too far out',
     -  '  US weight=',e12.5)
2019  format(1x,a11,': solute regenerated from torsion angles ',
     -  'differs from the solute in the .crd file by ',f8.4)
2020  format(' Both torsions and solute molecule moves are active: ',
     -  'solute coordinates have been regenerated from torsion angles',
     -  /,' Solute check is repeated')
2021  format(' If the overlaps do not resolve during the run, remove ',
     -  'the offending molecules and start again')
2022  format(' ----- WARNING:',i5,' solvent pairs overlap')
2023  format(' Use PRNT DETL to see the first 50 overlaps')
2024  format(' Solute-solvent energy terms:',e12.5,
     -  ' (1/r**12) ',e12.5,' (1/r**6) ',e12.5,' (1/r) ',
     -  'Solvent energy/molec=',f8.3,' kcal/mol')
2025  format(' Solute-solvent average Coulomb energy=',
     -   f15.5,' kcal/mole. Coulomb US mixing parameter is=',
     -   f15.5,' this value will be used during the run',
     -   ' and corresponds to a bp=ba-ussca of',f15.5)
2026  format(' Molecule labels 0: fixed; 1: inside the grid; ',
     -  '2: outside the grid',/,(10(1x,10i1)))
2028  format(/,' Starting configuration:',/,19x,'Total',6x,
     -  'Solute-solvent',2x,'Solvent-solvent',4x,'Solute-solute',
     -  '   Intramolecular      Field',/,
     -       ' Energy:     ',e14.8,5(3x,e14.8),' kcal/mol')
C@FR2029  format(' Virial sums (total, solute-solvent, solvent-',
C@FR     -  'solvent):',7x,3(3x,e14.8))
2030  format(' ***** Discrepancy may be due to internal inconsistency',
     -  ' in the data on checkpoint file ',a,' or program error')
2031  format(' Current number of solvent molecules=',i6)
2032  format(29x,'Nonbonded inter  Nonbonded intra',7x,'1-4',12x,
     -  'Torsion',/,' Solute energy terms:',6x,4(3x,e14.8),
     -  ' kcal/mol')
2033  format(5x,' Coupling parameter=',f9.6)
2034  format(' Restraining shell energy=',e12.5,' kcal/mol number of ',
     -  'solvents in the restraining shell=',i4)
2035  format(' ***** ERROR: SUPT key did not specify any solute ',
     -  'potential (ATNO or DUMM) - can not run MC, only analysis')
2036  format(' Reference ',a,' energy for non-Boltzmann sampling=',
     -  f10.4,' kcal/mol')
2037  format(' SETUP uwnb=',e14.6,' teslt=',e14.6,a,
     -  'teslt1,estincr=',2e14.6)
2038  format(' ***** ERROR: non-MMC solute input format was used. ',
     -  'Since it does not carry potential information, MC can not ',
     -  'be run')
2039  format(' SETUP setpoint,oldpv=',2f10.1,' targetden,targetn=',
     -  f10.5,f10.1,' gain_n,gain_den=',2e13.5)
2040  format(' ===== STRONG WARNING: number of solvents is less than ',
     -  'the targeted number by ',i3,'%')
2041  format(' ===== STRONG WARNING: the bulk region is considered the',
     -  ' region ',a,' the MOND rectangle but it contains',i7,' solute',
     -  ' atoms')
2042  format(7x,'Run first without BTUN to get close - use the STPX ',
     -  'key and set the nslvxp parameter of the GCEN key to the ',
     -  'target number')
2043  format(' ***** ERROR: BTUN FLUC is not working when random ',
     -  'initial configuration (CNFG RAN*) is used')
2044  format(' Total constraint energy=',e13.5,' kcal/mol')
2045  format(' ----- WARNING:',i6,' coordinates were outside the ',
     -  a,'energy grid map')
      end
      subroutine settol(nstta,nstfa,nmolec,iout)
c#    MMC routine  32 lstmod: 05/24/15
c*****Sets the self test tolerance values
      common /slfttolerance/ tol(10),tolr(10),told(10)
      common /option/ iop(200),idebug(200)
      do i=1,10
        if (tolr(i) .eq. 0.0) tol(i)=told(i)
        if (tolr(i) .ne. 0.0) tol(i)=tolr(i)
      end do
      if (tolr(1) .eq. 0.0) then
c       For runs with partial solute change or (TPN) ensemble relax virtol
        if (iop(57)+iop(58) .gt. 0 .or.
     -    (iop(30) .eq. 7 .and. nstfa .lt. nstta)) then
          if (tolr(1) .eq. 0) tol(1)=told(1)*100.0
          if (tolr(2) .eq. 0) tol(2)=told(2)*100.0
        else if (iop(71) .gt. 0) then
          tol(1)=0.0001
        end if
        if (nmolec .gt. 1000 .or. nstta .gt. 1000) tol(1)=tol(1)*10.0
c       g77 appears to accumulate round-off errors faster than others
C@G7        tol(1)=tol(1)*10.0
      end if
      if (iop(91) .gt. 0 .and. tolr(3) .eq. 0.0) tol(3)=20.0
      if (nstta .gt. 200 .and. tolr(6) .eq. 0.0) tol(6)=0.01
      if (idebug(171) .gt. 0) write (iout,1000) tol
      return
1000  format(' engtol=',e10.3,' virtol=',e10.3,' tortol=',e10.3,
     -  ' comtol=',e10.3,' zmattol=',e10.3,/,
     -  ' cslttol=',e10.3,' d12tol=',e10.3,' d13tol=',e10.3,
     -  ' wsumtol=',e10.3)
      end
      subroutine montec
c#    MMC routine  33 lstmod: 12/27/23
c*****The main driver of the Monte Carlo simulation
c---------------------- Explanation of options -------------------------
c     iop(1)  =0: Print all distributions, row-wise
c     iop(1)  =1: Print only g(r) and coord no. distributions, row-wise
c     iop(1)  =2: Don't print any distribution function at all
c     iop(1)  =3: Print all distributions, column-wise
c     iop(1)  =4: Print only g(r) and coord no. distributions, column-wise
c     iop(2)  =1: Solute is periodic along the x axis
c                 - no displacement in the x-direction
c     iop(2)  =2: Solute is periodic along all 3 axes - don't move
c     iop(3)  =1: Solute-solvent potential is Clementi's
c     iop(3)  =2: Solute-solvent potential is QPEN
c     iop(3)  =3: Solute-solvent potential is Amber 2002
c     iop(3)  =4: Solute-solvent potential is Amber (Cornell 94)
c     iop(3)  =5: Solute-solvent potential is Charmm - parm22
c     iop(3)  =6: Solute-solvent potential is Berendsen/vGunsteren-Gromos87
c     iop(3)  =7: Solute-solvent potential is Berendsen/vGunsteren-Gromos96
c     iop(3)  =8: Solute-solvent potential is Jorgensen's OPLS
c     iop(3)  =9: Hard spheres
c     iop(3) =10: No solute-solvent potential, input atomic no for type
c     iop(4)  =2: Calculate the pair property distributions
c     iop(4)  =0: Don't calculate any distribution function
c     iop(5)  =0: Simple cubic or rectangular boundary conditions
c     iop(5)  =1: Face-centered cubic boundary conditions
c     iop(5)  =2: Hexagonal close packed (HCP) boundary conditions
c     iop(5)  =3: Truncated octahedron (TOCT) boundary conditions (not done yet)
c     iop(5)  =4: Hexagonal prism boundary conditions
c     iop(5)  =5: Sphere boundary conditions
c     iop(5)  =6: Primary boundary shell bc of Beglov & Roux
c     iop(5)  =7: Input boundary conditions
c     iop(6)  =0: Regular Metropolis: move is inside a cube
c     iop(6)  =1: Regular Metropolis: move is inside a sphere
c     iop(6)  =2: Regular Metropolis: fixed magnitude steps
c     iop(6)  =3: Regular Metropolis: magnitude range steps
c     iop(6)  =5: Force biased moves
c     iop(6)  =6: Force biased with slt distance scaling
c     iop(6)  =9: Stepside determined outside deploy
c     iop(7)  =0: Slt-slv: spherical cut
c     iop(7)  =1: Slt-slv: minimum image
c     iop(7)  =2: Slt-slv: iso-energy (lemniscata) cutoff
c     iop(7)  =3: Slt-slv: group based spherical cut (temporary use)
c     iop(7)  =4: Slt-slv: group based minimum image (temporary use)
c     iop(8)  =0: I/D preferential sampling uses COM-COM distance
c     iop(8)  =1: I/D pref. sampl. uses 1st solvent-nearest heavy atom d.
c     iop(8)  =2: I/D pref. sampl. uses a given center
c     iop(9)  =1: Save all the orientations and energies on unit ihist
c                 if iop(41)>0: save water coordinates periodically
c     iop(9)  =2: like iop(9)=1 but save the virial sum instead of the b.e.
c                 if iop(41)>0: save also the solute coordinates
c     iop(9)  =3: Not used
c     iop(9)  =4: Save the bare config (in ASCII) at every nmcrec-th step
c     iop(9)  =5: Save the annotated (ASCII) config at every nmcrec-th step
c     iop(9)  =6: Save the config (binary/unformatted) at every nmcrec-th step
c     iop(9)  =7: Read/write PDB format
c     iop(9)  =8: Read/write MODEL/ENDMDL PDB format
c     iop(9)  =9: Read/write Charmm CRD format
c     iop(9)  =10: Read/write an Amber trajectory
c     iop(9)  =11: Read/write a Charmm trajectory
c     iop(10) .ne. 0: Restart, input from unit ichkp
c     iop(11) =0: Read starting configuration from unit icord
c     iop(11) =1: Create starting configuration by replacing the
c                 solute of an other system.
c     iop(11) =2: Create starting configuration from a different
c                 system by preserving solute and solvent orientations
c     iop(11) =3: No starting configuration exists. create one
c                 randomly, avoiding the solute's VdW envelope.
c                 COM of the solute will be at the cell center.
c     iop(11) =4: Same as 3, but the solute will be left in the
c                 coordinate system used at its input.
c     iop(11) =5: Starting configuration is created for
c                 conformational transition
c     iop(11) =6: Same as iop(11)=1 but vdw overlaps are allowed
c     iop(11) =7: Initial configuration gathered from the trajectory
c     iop(12) =0: Move the molecules randomly
c     iop(12) =1: Move the molecules sequentially
c     iop(12) =2: Move the molecules randomly within one cycle
c     iop(12) =3: Cyclic selection in reverse order (mainly for torsions)
c     iop(12) =4: Preferential sampling move, weight is piecewise linear
c     iop(12) =5: Preferential sampling move, weight is polynomial
c     iop(12) =6: Preferential sampling move, weight is exponential
c     iop(13) >0: Chk force,torque and binding eng by recomputing them
c                 don't supress underflow messages
c     iop(13) >1: Recompute etotn,virial from scratch for test
c                 recompute coordination nos, check bit map for symm.
c                 if iop(5) <> 7, check PBC images.
c     iop(13) >2: Repeat basic test for all molecules
c     iop(14) >0: Do not move the first iop(14) molecule
c     iop(15) >0: In GCE stop when Nmolxp is reached
c     iop(16) =1: Print distributions after the plot
c     iop(16) >1: Print control function and cv before plot
c     iop(17) =0: Move preferential sampling uses COM-COM distance
c     iop(17) =1: Move pref. sampling uses 1st solvent-nearest heavy
c                      atom distance
c     iop(17) =2: Move pref. sampling uses a given center
c     iop(18) =0: Linear coupling in solute cartesian space
c     iop(18) =1: Linear coupling - PMF calc moving two rigid parts
c     iop(18) =2: Like iop(18)=1 but the first part is fixed
c     iop(18) =3: Like iop(18)=2 but the first part is fixed and the
c                 second part is translated and rotated
c     iop(18) =4: Linear coupling in solute torsion angle space
c     iop(18) =5: Translate/rotate after coupling the center of masses
c     iop(19) =1: No force-bias on solute
c     iop(20) >0: Read in extra atom-types
c     iop(21) =0: Scalar energy calculation
c     iop(21) =1: Vector energy calculation  - 32-bit (order-sensitive) version
c     iop(21) =2: Vector energy calculation  - Cray (order insensitive) version
c     iop(21) =3: Parallel energy calculation  - MPI/DM version
c     iop(22) =1: Generate proximity insertion/deletion acceptance counts
c     iop(23) =1: Plot ui,utot instead of ui,Cv at the end of each run
c     iop(24) >0: Echo formatted input, announce file openings
c     iop(24) >1: Additional output
c     iop(24) >2: Debug level output (like intermediate px anal tables)
c     iop(24) >3: Also echo from each processor
c     iop(25) >0: Functional group definitions are obtained from input
c     iop(25) =2: Functional group definitions are used for indxrdf
c     iop(26) =0: Solvent-solvent potential is MCY water
c     iop(26) =1: Solvent-solvent potential is TIPS/TIP3P water
c     iop(26) =2: Solvent-solvent potential is TIPS2/TIP4P/BF water
c     iop(26) =3: Solvent-solvent potential is TIP5P water
c     iop(26) =4: Solvent-solvent potential is a general 1-6-12 potential
c                 of type iop(37)
c     iop(27) =1: Determine cell size from the number of waters and pmv's.
c     iop(27) =2: Determine cell size, number of waters from pmv's and
c                 number of water shells.
c     iop(28) <4: Axis of the chimera grid (1, 2 or 3)
c     iop(28) =4: chimera grid is for residue proximities
c     iop(29)   : Potential type for the second copy with 2-copy TI
c     iop(30) =1: Widom method - leave room for ghost molecules
c     iop(30) =2: Chimera method - leave room for ghost molecule
c     iop(30) =3: Add-on Widom - leave room for ghost molecules
c     iop(30) =4: Not used
c     iop(30) =5: Free energy calculation with energy coupling TI
c     iop(30) =6: Free energy calculation with exponential US
c     iop(30) =7: Free energy calculation with probability ratio method.
c                 adaptive or harmonic potential umbrella sampling
c     iop(30) =8: Free energy calculation with overlap ratio method,
c                 combined with calculation using the perturb. method
c     iop(31) =0: Use stored slt charges with OPLS potential
c     iop(31) =1: Use inputted slt charges with OPLS potential
c     iop(32) =1: Write plot file unit idistr
c     iop(33) =0: Don't use inner modification on solvent-solvent
c     iop(33) =1: Use inner modification on solvent-solvent
c     iop(34) >0: Scale stepsize down when the a molecule was found
c                      unmoved after a certain number of cycles (noldmx)
c     iop(34) =1: Number of allowed cycles = 100
c     iop(34) >1: Number of allowed cycles =10 * iop(34)
c     iop(35) =1: Scale input coordinates to define window
c                 for perturbation calculation
c     iop(35) =2: Scale also  coordinates on unit icord for iop(11)=0
c     iop(36) =1: Torsion angle scan - print absolute energies
c     iop(36) =2: Torsion angle scan - print relative energies
c     iop(37) =0: Input solvent-solvent parameters
c     iop(37) =1: iop(26)=0: use stored MCY-CI-II parameters
c     iop(37) =1: iop(26)=1: use stored TIPS parameters
c     iop(37) =2: iop(26)=0: use stored Yoon-Morokuma-Davidson params
c     iop(37) =2: iop(26)=2: use stored Bernal-Fowler parameters
c     iop(37) =3: Use stored SPC parameters
c     iop(37) =4: Use stored TIPS2 parameters
c     iop(37) =5: Use stored TIP3P parameters
c     iop(37) =6: Use stored TIP4P parameters
c     iop(37) =7: Use stored SPC/E parameters
c     iop(37) =8: Use stored TIP5P parameters
c     iop(37)   : When iop(26)=4 it gives the solvent potential type
c                 using the same coding as the solute-solvent potential
c     iop(38) =0: For flexible solute, only the geometry is changed
c     iop(38) =1: For flexible solute, geometry and charges are changed.
c     iop(38) =2: For flexible solute, geometry, charges, c6, c12 change.
c     iop(39) =0: Built-in solvent description was used
c     iop(39) =1: Solvent description was read with the SLVA key
c     iop(39) =2: Solvent description was read with the SLVA key or TIP5P water
c     iop(40) >0: Save checkpointfile periodically with different names
c     iop(41) =1: Cavity-biased grand-canonical ensemble simulation
c                 using the grid insertion technique.
c     iop(41) =2: Grand-canonical ensemble simulation, cavity biasing with
c                 fuzzy insertion
c     iop(41) =3: Grand-canonical ensemble simulation, random insertions
c     iop(42) >0: Write a log of insertions and deletions on unit iindel
c     iop(42) =2: Write also the nearest solute atom to the I/D site
c     iop(43) >0: Use group-based cutoff slt atoms
c     iop(44) >0: Alternate between translation & rotation (slt/slv/slt+slv)
c     iop(45) >0: Try to overlap the 2nd solute copy with the first
c     iop(46) =1: Turn off the charges on the solute (for random start)
c     iop(47) =0: Formatted (ASCII) icord file
c     iop(47) =1: Unformatted (binary) icord file
c     iop(47) =2: Annotated formatted (ASCII) icord file
c     iop(47) =3: PDB icord file
c     iop(47) =4: Charmm CRD icord file
c     iop(48) =1: In case of failed self test on start, continue run.
c     iop(48) =2: For failed self test on start
c                 call eism0 to fix but stop if can't
c     iop(49) =1: Restart from unit ichkp, recover if hist fl is short
c     iop(50) =1: Replace solute on unit icord with input configuration
c                 if findor finds deviations >0.1
c     iop(50) =2: Replace solute on unit icord with input configuration
c                 if findor finds deviations >0.001
c     iop(50) =3: Replace input configuration of solute with unit icord
c                 config if findor finds deviations >0.1
c     iop(50) =4: Ignore if findor finds deviations of solute coords
c     iop(51) =0: Harmonic umbrella sampling
c     iop(51) =1: Adaptive umbrella sampling, linear interpolation
c     iop(51) =2: Adaptive umbrella sampling, exponential interpolation
c     iop(52) =0: Use geometric mean for the LJ sigma combination
c     iop(52) =1: Use arithmetic mean for the LJ sigma combination
c     iop(53) =0: Use full solute-solvent en
c     iop(53) =1: Use the short-range part of the solute-solvent en
c                 to accept/reject the insertion/deletion of particles.
c                 ensemble averages are not corrected for the approx.
c     iop(53) =2: Use the short-range part of the solute-solvent en
c                 to accept/reject the insertion/deletion of particles.
c                 ensemble averages are corrected for the approximation
c     iop(53) =3: Use the short-range part of the solute-solvent en
c                 to accept/reject the moves (applies to both steps).
c                 this is umbrella sampling wrt solute-solvent
c                 Coulomb interaction energy.
c     iop(54) =0: Slv-slv: spherical cut
c     iop(54) =1: Slv-slv: minimum image
c     iop(55) >0: In AUS, continue iteration if at least iop(55) sweeps
c                 have been completed
c     iop(56) >0: Move pref. sampl. distance is different from I/D PS dist.
c     iop(57) =0: No partial solute displacements
c     iop(57) =1: partial solute displacements with no stepsize scaling
c     iop(57) =2:    displacements with linear stepsize scaling, max. ext
c     iop(57) =3:    displacements with sqrt stepsize scaling, max. ext
c     iop(57) =4:    displacements with sqrt stepsize scaling, RMS ext
c     iop(57) =5:    displacements with linear stepsize scaling, avg. ext
c     iop(57) =6:    displacements with sqrt stepsize scaling, avg. ext
c     iop(58) =1: Partial torsion of solute, uniform sampling
c     iop(58) >1: Partial torsion of solute, extension bias (like iop(57))
c     iop(59) =0: Save all solute atoms in trajectory file (if applicable)
c     iop(59) =1: Save only mobile slt atoms in trajectory file
c     iop(59) =2: Save only solvent atoms in trajectory file
c     iop(59) =3: Save only solute atoms in trajectory file
c     iop(60) =1: Protect charge-charge interactions with a repulsion term
c     iop(61) >0: Part of the system creates a grid, but all bbs are fixed
c     iop(62) =0: Default (textbook) VdW radii used in grid definition
c     iop(62) =1: LJ sigma is used in grid definition
c     iop(62) =2: LJ sigma is used in grid definition, hydrogens get 1.0
c     iop(63) >0: Preferential sampling type for insertion/deletion moves:
c                      Piecewise linear, polynomial, exponential
c     iop(64) =1: Perform solute group swapping attempts
c     iop(65) =0: No solute-solute cutoff/pbc
c     iop(65) =1: Solute-solute interactions: molecule-center based pbc, MI
c     iop(65) =2: Solute-solute interactions: molecule-center based pbc, SC
c     iop(65) =3: Solute-solute interactions: group-center based pbc, MI
c     iop(65) =4: Solute-solute interactions: group-center based pbc, SC
c     iop(66) >0: Make a correlated 2-solute molecule move - see iop(57)
c     iop(67) =1: Use a map-based field dependent potential, read from files
c     iop(67) =2: Calculate map-based field dependent potential
c     iop(67) =3: Calculate map-based field dependent potential, save maps
c     iop(68) =1: Use special sampling techniqe too
c     iop(69) =1: solute molecules were cloned
c     iop(70) =0: Only summary acceptance rates are printed in disfin
c     iop(70) =1: Per molec and per step acceptance rates are also printed
c     iop(70) =2: Per molec number of trials are also printed
c     iop(71) =1: (T,P,N) ensemble, uniform sampling
c     iop(71) =2: (T,P,N) ensemble, isotropic virial-biased sampling
c     iop(71) =3: (T,P,N) ensemble, unisotropic virial-biased sampling
c     iop(72) =0: volume changes in all 3 D in every step
c     iop(72) =1: volume changes in one of the all 3 D's
c     iop(72) =2: volume changes in either the X or in the Y,Z directions
c     iop(73) =0,1,2,3: Partial solute moves molecs selected radomly, in a
c                       cycle, in a shuffled cycle, or in reverse cycle
c     iop(74) =0,1,2,3: Molecs for partial solute torsions selected radomly, in
c                       a cycle, in a shuffled cycle, or with neigbour limited
c     iop(75) =0,1,3: torsions selected radomly, in a cycle, in rev. cyc.
c     iop(76) =1: GCE run with adaptive B parameter calibration
c     iop(76) =2: GCE run with B parameter calibration based on fluctuation
c     iop(76) =3: GCE run with B parameter calibration based on process control
c     iop(76) =4: GCE run with B parameter from the average value of a tuned run
c     iop(77) =1: Trajectory copied will be shifted to solute com
c     iop(77) =2: Trajectory copied will be shifted by -edgexyz/2
c     iop(78) >0: Compression move VB is scaled down
c     iop(79) >0: The cavity grid is only covering part of the system
c     iop(79) =1: Free crossing of the cavity grid region boundary
c     iop(79) =2: Monitor only crossing the cavity grid region boundary
c     iop(79) =3: Forbid crossing the cavity grid region boundary
c     iop(80) =1: Calculate inner and outer solvent densities
c     iop(81) =1: Ignore PBC for Voronoi calculation
c     iop(82) >0: Collect contributions to derivatives w.r.t. to the solute
c                 potential parameters at each 10^(iop(82)-1)-th step.
c     iop(83) >0: Reset solute atoms to central cell for grid cover calc.
c     iop(84) =1: Torsion list is user-specified
c     iop(84) =2: Torsion list includes automatically all rotatable bonds
c     iop(84) =3,4: Same as iop(84) 1,2 but for peptide/protien backbones
c                 (if any) the BB atoms will be used for the four defining atoms
c                 and the center will be set to the first N atom
c     iop(85) >0: Molecule definition is by input instead of the topology
c     iop(86) >0: Print all acceptance rates in all reports
c     iop(87) >0: History file buffers will be written with checkpointing
c     iop(88) =0: Alternating insertion/deletion
c     iop(88) =1: Randomly selected insertion/deletion
c     iop(89) =0: Pcav is ngfree/total number of grids
c     iop(89) =1: Pcav is ngfree/number of grids not covered by the solute
c     iop(90) =1: Last 4 characters of a solute record is Charmm segment id
c     iop(91) >0: Torsion moves will use loop closing algorithms, if poss.
c     iop(91) =1: Iterate to the nearest using cref at each step
c     iop(91) =2: Search the r3 circle and check all 4 solutions, nearest
c     iop(91) =3: Search the r3 circle and check all 4 solutions, Jacobian
c     iop(92) =1: PHS model, slt radii from built in atomic vdw radii
c     iop(92) =2: PHS model, slt radii from L-J sigmas
c     iop(93) =0: PHS model targets total restraining energy
c     iop(93) =1: PHS model targets restraining energy / molecule
c     iop(93) =2: like iop(93)=1, but solvent too far out are ignored
c     iop(94) =0: Stop if SLFT-requested self test fails
c     iop(94) =1: Ignore SLFT-requested self test failure
c     iop(94) =2: Try to fix SLFT-requested self test failure, stop if can't
c     iop(94) =3: Try to fix SLFT-requested self test failure, continue if can't
c     iop(94) =4: Stop if SLFT-requested self test fails and save ckp file
c                 on job.99.ckp if passes
c     iop(95) =0: Stop if compulsory or FIXD called self test fails
c     iop(95) =1: Ignore if compulsory or FIXD called self test fails
c     iop(95) =2: Try fixing if compulsory or FIXD called self test fails
c     iop(95) =3: Try fixing if compulsory or FIXD called self test fails,
c                 but keep running either way
c     iop(96) =1: Non-Boltzmann sampling - scale down torsion term
c     iop(96) =2: Non-Boltzmann sampling - scale down solute-solvent repulsion
c     iop(96) =3: Non-Boltzmann sampling - solute is sampled at a different T
c     iop(96) =4: Non-Boltzmann sampling - Tsallis formulation
c     iop(96) =5: Non-Boltzmann sampling - scale down solute NB intra term
c     iop(96) =6: Non-Boltzmann sampling - iop(95)=1 & iop(96)=5
c     iop(97) >0: Allow for variable number of molecules (GCE, filtered history)
c     iop(98) >0: Convert PDB atomnames to regular (1) or leftadjusted (2) form
c     iop(99)   : 1 - uniform distribution for angle change sampling
c                 2/3 - 2D or 3D magnitude distribution
c     iop(100)>0: H-H bonds will be allowed
c     iop(101)>0: H bonds to different residues will be allowed
c     iop(102)>0: Torsion angles were scrambled at start
c     iop(103)  : Forward/backward/triangle inequality based/both ways solution
c                 of the loop-closing problem (LOOP PROX)
c     iop(104)>0: Treat ligands differently than rest of solute (Tom)
c     iop(105)=0: Ligand is fixed during the simulation (relevant for addwidom)
c     iop(105)=1: Ligand changes during the simulation (relevant for addwidom)
c     iop(106)=1: Virtual volume change to calculate pressure
c     iop(106)=2: Virtual volume change to calculate surface tension; X normal
c     iop(106)=3: Virtual volume change to calculate surface tension; Y normal
c     iop(106)=4: Virtual volume change to calculate surface tension; Z normal
c     iop(107)=1: Selected solute sampling stepsizes will be tuned
c     iop(108)>0: Use a potential depending on the molecular positions
c     iop(109)=1: Save the minimum energy over the save interval when iop(9)>3
c     iop(109)=2: Save the minimum energy over all confingurations
c     iop(109)=3: Save the minimum energy over all confingurations and the
c                 conformation at each temperature change step
c     iop(109)=4: Like iop(109)=3, but save the reconstituted conformation
c                 (if applicable)
c     iop(110)>0: Temporary stepsize scaling
c     iop(111)>0: Calculate solvent dipole distribution in the cell
c     iop(112)=1: use only simple (one angle dependent) H-bonding potential
c     iop(112)=1: use two angle dependent H-bonding potential (also)
c     iop(113)=1: Use desolvation term for all atoms; UA carbons
c     iop(113)=2: Use desolvation term for carbons only; UA carbons
c     iop(113)=3: Don't use desolvation term polar hydrogens
c     iop(113)=4: Don't use desolvation term between polar atoms (H,O,N,S) and
c                 consider C polar if UA ccharge is above a threshold
c     iop(113)=5: Desolvation term is applied only to nonpolar carbons
c     iop(114)=1: Simulated annealing, linear schedule
c     iop(114)=2: Simulated annealing, exponential schedule
c     iop(114)=3: Simulated annealing, input schedule
c     iop(115)>0: Ignore the Jacobian in the loop moves (No Boltzmann sampling!)
c     iop(116)=1: Skewed torsion sampling - bias single (driver) torsion
c     iop(116)=2: Skewed torsion sampling - select loop solution
c     iop(116)=3: Skewed torsion sampling - bias both driver and loop selection
c     iop(116)=4: Skewed torsion sampling - selectively accept loop move
c     iop(116)=5: Skewed torsion sampling - bias both driver and loop acceptance
c     iop(116)=6: Skewed torsion sampling - bias both driver and loop acceptance
c                  and selectively accept loop move
c     iop(117)>0: Apply additional constraint potential
c     iop(118)>0: Write solvent-to-site assignment information file (.wsl)
c     iop(118)=1: Write input file for entropy calculation (.sto)
c     iop(118)=2: Don't write input file for entropy calculation (.sto)
c     iop(119)=1: Solvent-solvent interactions are ignored
c     iop(120)=1: RAUS key was used
c     iop(120)=2: When RAUS key is used, initialize sampling frequency counter
c     iop(120)=3: When RAUS key is used, initialize all AUS counters
c     iop(121)>9: Perform a superimposition of the structure read from a traj
c     iop(122)=1: Calculate water dipole covariance  matrix at generic sites
c     iop(122)=2: Calculate water dipole correlation matrix at generic sites
c     iop(122)=3: Calculate the matrix of average site-site interaction energies
c     iop(122)=4: Calculate the matrix of fraction of h-bonds between sites
c     iop(122)=6: Calculate the average number of frames between jumps
c     iop(123)>0: Graph analysis frame-by frame; =2: frame-by frame printout
c     iop(123)>1: Frame-by frame printout; =3: add list of H bonds
c     iop(124)=0: Original MMC RNG
c     iop(124)=1: Linear congruential generator, input constants
c     iop(124)=2: Mersenne twister
c     iop(124)=3: Input random number stream
c     iop(124)=4: Output random number stream
c     iop(125)=1: Turn off solvent-solvent electrostatic interactions
c     iop(126)>0: Torsion force-field parameters were read
c     iop(127)=1: Ignore solute-solute energies for acceptance decision
c     iop(127)=2: Don't even calculate solute-solute energies
c     iop(128)=1: Read the full bond list in MAKB format instead of generating
c     iop(128)=2: Read the full bond list in Charmm PSF format
c     iop(128)=3: Read the full bond list in Amber top format
c     iop(129)>0: Simulated annealing of the chemical potential
c     iop(130)-iop(140): Not used
c     Proximity analysis options:
c     iop(141)=0: Use Voronoi polyhedra for proximity criterion
c     iop(141)=1: Use radical plane polyhedra for proxi with VdW radius
c     iop(141)=2: Use radical plane polyhedra for proxi with chrg radius
c     iop(142)=1: Compute primary K's
c     iop(142)=2: Compute primary g(r), K and xc(k)
c     iop(143)>0: Compute total g(r)'s for each solute atom
c     iop(144)=1: Compute solvent moderated pair forces on slt atoms
c     iop(145)=1: Compute slt-slv angular correlations
c     iop(146)=1: Compute primary solute binding and pair energies
c                 and slt-slv pair energy QCDFs
c     iop(147)=1: Compute water-water g(r)
c     iop(148)=1: Compute slv-slv pair energy and binding energy avgs
c     iop(149)=0: Density weighting is not used
c     iop(149)=1: Slt-slv primary g(r)s weighted by total
c                 primary area slv density
c     iop(149)=2: Slt-slv primary g(r)s weighted by considered
c                 primary area slv density
c     iop(150)>0: Not used.
c     iop(151)>0: Use the solute atom first shell radii for
c                 sub-grouping on the functional groups
c     iop(152)=0: Rigid solute, not moved during the simulation
c     iop(152)=1: Rigid solute, but moved during the simulation
c     iop(152)=2: Solute conformation is also allowed to vary
c     iop(153)>0: Write the proximity distributions on unit idistrpx
c     iop(154)>0: NOT USED
c     iop(155)=1: Print run parameters before each distr. print
c     iop(156)>0: Don't print the computed distribution fcts
c     iop(156)>1: Don't print the average forces on the atoms
c     iop(157)=1: Print the volume-element estimates
c     iop(158)=0: Print the full fcg table when condensed table is printed
c     iop(158)=1: Don't print the full fcg table with condensed
c     iop(158)=2: Don't print the fcg table at all (only the residue table)
c     iop(158)=3: Print the full fcg table (only)
c     iop(159)>0: Perform proximity analysis concurrent with MC
c     iop(160)=1: Don't run MC, scan history file instead
c     iop(160)=2: Scan the next history file without reinitalizing
c     iop(160)=3: Don't run MC, analyze current configuration only
c     iop(161)>0: Reading an Amber trajectory, read box information too
c     iop(161)=2: Reading an Amber trajectory, ignore new box information
c     iop(162)=0: No proximity criterion analysis
c     iop(162)=1: Bulk density is from Nmolec, cell volume and inp slt vol.
c     iop(162)=2: Bulk density is from considered primary area.
c     iop(162)=3: Bulk density is from water at 25 Deg C.
c     iop(162)=4: Bulk density is from Nmolec, cell volume and slt
c                      vol from MC estimate
c     iop(163)=0: No proximity info file (.pxi)
c     iop(163)=1: Write solvent proximity labels, dist, eng. on ascii .pxi
c     iop(163)=2: Write solvent proximity labels, dist, eng. on binary .pxi
c     iop(163)=3: Write solvent proximity labels and dist on binary .pxi
c     iop(164)=1: Keep volume element estimates from previous runs (unless
c                      new solute is read in)
c     iop(165)>0: Empty proximity regions will not be printed
c     iop(166)>0: Calculate field gradients at the solvent COM's
c                      =1: binary file written; =2: ASCI file is written
c                      =3: binary, only total ; =4: ASCI, only total
c     iop(167)=0: Built-in first shell radii are used
c     iop(167)=1: LJ-sigma based first shell radii are used
c     iop(167)=2: Use individual first minima from primary RDF
c     iop(168)=1: Ignore hydrogens in proximity analysis
c     iop(168)=2: Ignore atoms in inputted range in proximity analysis
c     iop(168)=3: Ignore both hydrogens and atoms in inputted range
c     iop(169)>0: Calculate dipole fluctuations in the proximity regions
c     iop(170)=0: Write proximity info file (.pxi)
c     iop(170)>0: Read proximity proximity info file (.pxi)
c     iop(171)=1: Calculate solvent residence time in 1st shell
c     iop(171)=2: Calculate solvent residence time in 1st+2nd shell
c     iop(171)=3: Calculate solvent residence time in shell with fixed input r
c     iop(172)=1: Calculate averages of RDF critical values over elements
c     iop(172)=2: Calculate averages of RDF critical values over atom types
c     iop(173)>0: Built in first shell radii have been modified
c     iop(174)>0: Energy decomposition analysis (1: averages only; 2: all cnfs)
c     iop(175)>0: Permute coordinates before analysis, trajectory conv. or
c                      writing out a configuration.
c     iop(176)>0: Calculate solute torsion angle distributions
c     iop(177)>0: Calculate solvent diffusion constant
c     iop(178)  : Hydrogen-bond bridge anchor specification type
c     iop(179)>0: Don't calculate field gradients at solvent sites
c     iop(180)>0: Calculate torsion angle autocorrelation functions
c     iop(181)-iop(200): not used.
c-----------------------------------------------------------------------
C@D1      common /eijtest/ eij(216,216)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      common /isoeng/ dimax,dijs,dijq,dijso,dijqo,eniemx,eniemo
      common /wadaptf/ ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,rldvmx,
     -  diffmx,tolera,iopnrm,iopeql,iopenc,nitssk,nwtst,nsubmn,ngovmn,
     -  ngrcor,negitdel
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      character*80 scratchpath
      common /localdisk/ lscratchpath,scratchpath
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      real*8 ucsm_prev,u_prev,uslt_prev,uttnb_prev,uinnb_prev
      common /anneal/ ucsm_prev,u_prev,uslt_prev,uttnb_prev,
     -  uinnb_prev,nmctempstep,ntemplist,ntempstep,ntempsteptot,
     -  ntempstepcum,isannread,templist(100),temp0,tempstep,tempexp,
     -  tempfin
      common /anneal_cp/ nmcsacpstep,nmcsacpsteppnmol,maxbsave,
     -  nstep_ann,nmcav0,nligsave(500),avgligsave(500),bsave(500),
     -  bincr,cav_fract_lim
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 ew0nb,teslt1,teslt1n,uwnb,uwnbn,uwnbmin,uwnbmax,
     -  etsincr
      common /nonboltz/ ew0nb,teslt1,teslt1n,
     -  uwnb,uwnbn,uwnbmin,uwnbmax,etsincr,tornbfac,repnbfac,slttmp,
     -  sltsltfac,signincfac,tsexp,tsfac
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
CJJ   variables
      real*8 setpoint,gain_n,gain_den,integraltime,oldpv,controlerror,
     -  dbetadt,dpvdt
      common /control/ setpoint,gain_n,gain_den,integraltime,oldpv,
     -  controlerror,dbetadt,dpvdt
      real*8 rnsumprev,uavcorprev,delndelbsum
      common /tuneb/ rnsumprev(2),uavcorprev,delndelbsum,nitconv,
     -  nunphys,nmctunskip,nmctunave,nmclastch,ntune,nmccorprev,
     -  ndelndelbsum,inorout,targetden,targetn,tolden,toln,delndelb0,
     -  rnaviprev,baprev,chabmax,pv
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      common /sweep/ nsweep,nlast,nswavg,nswav2,minswp,maxswp,
     -  nswpit(#WI),nswrep(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /tpn/ edgexyz0(3),edge2xyz0(3),rinscr0(3),vol0,cic0(3,27),
     -  dex0(5),dey0(5),dez0(5),chexdx0(2),chexy0(2),dexhex0(5),vrange,
     -  volfac(3),vlam,vlamt,vvlmt,vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyy,
     -  vvlmtzz,vvlmtyz,complfac,sqcomplfac,ixyzfreeze(3),iscaletyplast
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /griderror/ ngriderr,nhbgriderr,igridprint,griderrmax
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      real*8 eminsave,eminhsave
      common /mine/ eminsave,eminhsave,cminsave(3,#NE),
     -  cminhsave(3,#NE),nmcminsave,nmcminhsave,natomssave,
     -  natomshsave,nminsave,nminhsave
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /ecell/ cic(3,27),ncell
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 efieldst0,efieldmst
      common /fieldenergy/ efieldst0,efieldmst(#MM),
     -  efieldsv(#MO),esltfldo(#ST),esltfldn(#ST)
      real*8 emolstsm,emolsvsm,emolim
      common /specenergy/ emolsvsm(#MO),emolstsm(#MM),emolim
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      real*8 fsmslt,fsmslv,tsmslt,tsmslv,wpsmvi
      common /quantm/ fsmslt,fsmslv,tsmslt(3),tsmslv(3),wpsmvi,nsslt
      common /cage/ delc(3,#MO),deln(3)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /howfar/ dtot(#MI,2),decay(#MI,2),nhowfar,nhowfarsamp
      character*11 stunen
      common /tunelab/ stunen(4)
      real*8 blkavs
      common /btchav/ blkavs(#MI,11),nblcks
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      common /fcgdatpx/ fcgavg(101,12),sdev2(101,11),ndupfg(100),nfge
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /option/ iop(200),idebug(200)
      character*1 lxyz
      common /names/ lxyz(3)
      character*40 itcplp
      common /cplnames/ itcplp
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      real*8 ue0ind,ue1ind,ue0ttnb,ue1ttnb,ue0innb,ue1innb,
     -  ue0t14,ue1t14,ue0tor,ue1tor
      common /frind5/ ue0ind(3),ue1ind(3),ue0ttnb(3),ue1ttnb(3),
     -  ue0innb(3),ue1innb(3),ue0t14(3),ue1t14(3),ue0tor(3),ue1tor(3)
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      real*8 ufe
      real*8 ufeadd,ufe2add,ufinnmco,uewold,uewnew,estcop,estcnp,
     -  beg,beggd(#MM),beggt(#TR)
      dimension ufeadd(3),ufe2add(3),ufinnmco(3)
      common /frind7/ ufeindnmc(3,#MI),ufinnmco
      common /cavprb/ ndistr(#MO),ninstr(#MO),nocavf(#MO),
     -  ndela,nran,ndlast,nmdlst,niddst,namin,namax
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv123(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      common /coptor/ ncoptoract,ncoptorfact
      common /liga/ ligand_start_molecule,last_slt_mol_g
C@dc      character*4 labcall
C@dc      common /testprint/ labcall
      real*8 cplfcd,drno,grsum1,grsum1o,grsum2,grsum2o,grsum12,
     -  ddummy,grsum12o,gsumselfo,gsumselfn,gsum14o,gsum14n,gsuml0o,
     -  gsuml0n,gsuml1o,gsuml1n,gbeoldsw,torsensumn,torsensumo,einbcorr,
     -  einbcorrs,e14corr,e14corrs,delfac,uusfac,ephslimsum,ucsmmv0,
     -  ucsmdiff,ucsmid0,ucsmvv0,ut0,uslt0,usind120,usind60,usind10,
     -  tss1n,tss12n,teslt,dnbsdiff,u,uuav,cv,sd2,efieldimn,efieldimn1,
     -  efieldimo,efieldcha,efieldcha1,efieldtst,vsum0,rnsum0,
     -  stepsumloopprev,stepsumtorprev,uusdiff,ddintra
      dimension gbeoldsw(#ST),gsuml0o(3),gsuml0n(3),gsuml1o(3),
     -  gsuml1n(3),rgd(3),crmj(3),crmx(3),rsx(3,#SV),drno(1),angincr(1),
     -  ptiexpr(3),blockav1(#MI),blockav2(#MI),looptry(#TR)
      dimension iusave(10)
C@DM      dimension indlgrix(4),indlgrixsum(4)
      dimension keycol(2)
      character*80 filename1
      character*64 ipltub,ipltuu
      character*48 itcplj
      character*17 ipltti,ipltpm
      character*41 ipltvol
      character*54 ipltnm,ipltxm,ipltba
      character*8 iengr,ipress,ifti,ifpm,inavg,ivol
      character*132 linepr
      character*3 mtn,movtypn(7),inout(2)
      character*2 accrej(2)
      character*1 loopmark,eunit
      data movtypn /'MOV','CPL','PSM','TOR','SWC','2ST','SPC'/,
     -  accrej/' R',' A'/,inout /'in ','out'/
      data gsuml0n /3*0.d0/,gsuml0o /3*0.d0/,gsuml1n /3*0.d0/,
     -  gsuml1o /3*0.d0/,uewold /0.d0/,einbcorr /0.d0/,einbcorrs /0.d0/,
     -  e14corr /0.d0/,e14corrs /0.d0/,dnbsdiff /0.d0/,ucsmmv0 /0.d0/,
     -  ucsmid0 /0.d0/,ucsmvv0 /0.d0/,vsum0 /0.d0/,risn /0.0/,
     -  riso /0.0/,rphs0isnn /0.0/,ephsisn /0.0/,scdifln /0.0/,
     -  corris /0.0/,rnsum0 /0.d0/,rnn /0.0/,natomsnmc /0/,
     -  ignorehsref /0/,istepmag /0/,istep /0/,imn /0/,iaccrej /0/
C@D4      idebug(110)=1
C@D4      call checkeijmol(0,nstta,ifirstm(1),ilastm(1),ixislt)
      ipltub=
     -'Energy block averages: *            Heat capacity: o            '
      ipltuu=
     -'           Energy block avg: *            Energy running avg: o '
      itcplj='*: -kT*ln(p(coupl par)) + e(6-12)   o:  e(6-12) '
      ipltnm='Number of solvents  block average: * Cumulative avg: o'
      ipltxm='Energy/molecules    block average: * Cumulative avg: o'
      ipltvol='Volume block average: * Cumulative avg: o'
      ipltba='GCE B parameter     block average: * Cumulative avg: o'
      ipltti='TI   integrand   '
      ipltpm='exp(-(e1-e0)/kT) '
      iengr= 'Energy  '
      ipress='Vir. sum'
      inavg= '# of mol'
      ivol = 'Volume  '
      ifti=  'TI integ'
      ifpm=  'e(E-E0) '
      ipsdist=0
      ncor1ok=1
      ediff=0.0
      if (iop(17) .gt. 0 .and. iop(92) .eq. 0 .and.
     -   (iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4)) ncor1ok=0
c     ncor1ok=0: no solute-solvent distribution function is calculated
      if (iop(17) .eq. 1 .or. iop(8) .eq. 1 .or. iop(6) .eq. 6 .or.
     -    iop(92) .gt. 0) ipsdist=1
c     ipsdist: no solute-solvent preferential sampling distribution is calctd.
      if (ncor1ok*ipsdist .eq. 0) then
        if (iop(4) .eq. 0) ncor1ok=0
        if (iop(4) .gt. 0) ipsdist=1
      end if
      if ((iop(24) .gt. 1 .and. ipsdist .eq. 0 .or. ncor1ok .eq. 0)
     -  .and. nstta .gt. 0 .and. MYRANK .eq. 0) write (iout,2033)
      if (nmcmax .eq. 0 .or. inperr .gt. 0) go to 9996
c     ut0,uslt0,nmc0: the values of usum, uslt and nmc at the start of this job.
c      idebug(60) = 1
c      idebug(84) = 3
c     PHS debug messages
c      idebug(99) = 2
      ut0=usum
      ucsmmv0=ucsmmv
      ucsmid0=ucsmid
      ucsmvv0=ucsmvv
      uslt0=uslt
      vsum0=vsum
      usind120=tscum(1)
      usind60=tscum(2)
      usind10=tscum(3)
      rnsum0=rnsum
      nmc0=nmc
      nmcrun=0
      wpsmvnew=1.0
      cpl0mn=cplpar
      cpl0mx=cplpar
      edifmx=alog(realmx/1.e+10)/beta
      expmax=alog(realmx/1.e+10)
      uwnb=1.d0
      epmfn=0.0
      etotpo=0.0
      etotpn=0.0
      imolck=0
      iskipfail=0
      igphslim=maxphsgrid
      if (iop(13) .gt. 1) imolck=1
      if (iop(91) .eq. 0) call zeroiti(looptry,0,#TR)
      if (iop(109) .gt. 0) then
        call trnsfr(cminsave,c,natoms*3)
        call trnsfr(cminhsave,c,natoms*3)
        nmcminsave=nmc
        natomssave=natoms
        nminsave=0
        nmcminhsave=nmc
        natomshsave=natoms
        nminhsave=0
        eminsave=etoto
        eminhsave=etoto
      end if
      nmolecdo=nmolec
      nstta0=nstta
      if (iop(127) .gt. 1) then
        call zeroitd(gbenew,nstta)
        call zeroitd(gbeold,nstta)
        call zeroitd(gbernew,nstta)
        call zeroitd(gberold,nstta)
        call zeroitd(torsen,ntorsinp)
        call zeroitd(torsennew,ntorsinp)
        call zeroitd(upmftt,#WG)
        call zeroitd(upmfttsum,#WG)
        gbeg=0.d0
        einnbo=0.d0
        es14o=0.d0
        iuuon=0
      end if
      nmcsacp0=nmc
      nmcav0=0
      if (iop(129) .eq. 2) nmcsacpstep=numsolv*nmcsacpsteppnmol
c-----Monte Carlo loop
      call checkfixedats(isltmv,c,nstta,1,0.2,0,' ',iout)
      iii=0
      do while (iii .lt. nmcmax)
        iii=iii+1
c       Increment MC step counter
        nmc=nmc+1
        if (idebug(10) .gt. 2) write (iout,7511) ' Top of main loop',
     -    nmc,(ia,(c(k,ia),k=1,3),(cslto(k,ia),k=1,3),
     -    sqrt(arrdist(c(1,ia),cslto(1,ia))),ia=1,nstta)
        if (npfused(9) .gt. 0) then
          if (ignorehs .eq. 0) then
            if (etoto .lt. realmx/10.0) ignorehs=1
          end if
c         Disable ignoring HS terms for energy calculation of the move
          ignorehsref=ignorehs
          ignorehs=0
        end if
        loopmark=' '
c       Select next molecule to move
        call selectmol
        isolvp=isolv
        if (iop(53) .eq. 3) then
          uewold=tss1-uscpma*dfloat(nmolec-1)
          uewold=usmixp*dble(beta)*uewold
          uuscor=exp(-uewold)
        end if
c       Make the trial change
        ptaccfac=1.0
        molmovs=0
        ettnbn=ettnbo
        einnbn=einnbo
        es14n=es14o
        eslttorn=eslttoro
        uwnbn=uwnb
        if (movtyp .eq. 1) then
c         Regular displacement
          call deploy(orient,c,crm,ch,phi,0)
          nmovtry=nmovtry+1
          npckd(isolv)=npckd(isolv)+1
          ityptry=1
          if (isolv .gt. nmolec) then
            if (nmolec .eq. nsolvfix+1 .and. iop(41) .gt. 0) then
c             GCE - empty box, nothing to move
              go to 609
            else
c             There was an error! Bail out
              if (MYRANK .eq. 0) write (iout,2023) isolv,nmolec
              call datprt(2)
            end if
          end if
        else
          if (movtyp .eq. 2) then
c           Coupling parameter displacement
            call deploycpl(c,crm)
            npmftry=npmftry+1
            isolvp=molmov
            if (iop(18) .eq. 4) then
c             Torsion angles on a molecule change in a correlated fashion
              ityptry=4
              molstftt=molstf
            else if (iop(18) .eq. 1) then
c             Two rigid molecules change their relative distances, both move
              ityptry=3
            else
c             iop(18) = 0,2,3, or 5
c             One molec changes with linear coupling on all atoms or
c             two rigid molecs change their relative distances, the 1st moves
c             If iop(18)=3, the moving one also rotates
              ityptry=2
            end if
          else if (movtyp .eq. 3) then
c           Partial solute displacement
            call deploypd(c,orientsltm,ch,dihang)
            isolvp=molmov
            ityptry=2
c           Overall, per molec, per stepmag stat of trials and acceptances
            npdslttry=npdslttry+1
            npdsttry(molmov)=npdsttry(molmov)+1
            if (iaxis .gt. 0) then
              if (dispmax(iaxis) .gt. 0.0) then
                istepmag=min0(50,int(50.0*displace/dispmax(iaxis))+1)
                nptatry(iaxis,istepmag)=nptatry(iaxis,istepmag)+1
              else
                istepmag=0
              end if
            else
              istepmag=0
            end if
          else if (movtyp .eq. 4) then
c           Partial solute torsion
            call deploypt(c,nmc,ptaccfac,nsol,nsolo,lasttorgen,looptry,
     -        nochange)
C@DB        call printloopdat('MOVED',5,itormov,iquata,looplist,
C@DB     -    iprecursor,nrot,irotlist,irotlinc,bond,bond2,angle,cangle,
C@DB     -    bond13,bond12,angle13,cangle13,bondf,bondproj,xfac13,xfac12,
C@DB     -    iout,#ST,#TR,#LT)
            nptslttry=nptslttry+1
            it=ifdhgrlst(itormov)
            call origtor(it,itorig,iop(69),itn)
            if (looptry(it) .eq. 0) then
              nptsttry(itn)=nptsttry(itn)+1
            else
              nptlooptry(itn)=nptlooptry(itn)+1
            end if
            isolvp=molmov
            ityptry=4
            molstftt=molstf
            if (iamolslt(iquata(ifdhgrlst(itormov),2)) .lt.
     -          molstfti) then
              molstftt=molstfti
            end if
            if (nochange .eq. 1) then
              it=ifdhgrlst(itormov)
              if (idebug(60) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,2035) it
              nptsltacc=nptsltacc+1
              if (looptry(it) .eq. 0) then
                if (istune(3) .gt. 0) then
                  call origtor(it,itorig,iop(69),itn)
                  accsumtorprev(itn)=accsumtor(itn)
                  accsumtor(itn)=wsum(3)*accsumtor(itn)+wsum1(3)
                  stepsumtorprev=stepsumtor(itn)
cwww              stepsumtor(itn)=wstepsum(3)*stepsumtor(itn)+
cwww -              wstepsum1(3)*torstep(itn)
                  stepsumtor(itn)=wstepsum(3)*stepsumtor(itn)+
     -              torstep(itn)
                  stepsumtorcumu(itn)=stepsumtorcumu(itn)+torstep(itn)
                  if (idebug(40) .gt. 1) write (iout,7532) '(A)',itn,
     -              itormov,'tor',accsumtor(itn),accsumtorprev(itn),
     -              stepsumtor(itn),stepsumtorprev
                end if
              else
                nloopacc=nloopacc+1
                nptloopacc(itormov)=nptloopacc(itormov)+1
                loopmark='L'
                if (istune(4) .gt. 0) then
                  call origtor(it,itorig,iop(69),itn)
                  accsumloopprev(itn)=accsumloop(itn)
                  accsumloop(itn)=wsum(4)*accsumloop(itn)+wsum1(4)
                  stepsumloopprev=stepsumloop(itn)
cwww              stepsumloop(itn)=wstepsum(4)*stepsumloop(itn)+
cwww -              wstepsum1(4)*steploop(itn)
                  stepsumloop(itn)=wstepsum(4)*stepsumloop(itn)+
     -              steploop(itn)
                  stepsumloopcumu(itn)=stepsumloopcumu(itn)+
     -              steploop(itn)
                  if (idebug(40) .gt. 1) write (iout,7532) '(A)',itn,
     -              itormov,'loop',accsumloop(itn),accsumloopprev(itn),
     -              stepsumloop(itn),stepsumloopprev
                end if
              end if
              go to 609
            end if
            if (ptaccfac .eq. 0.0) then
              if (idebug(60) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,2034) irejtyp,nsol,nsolo
              go to 910
            end if
          else if (movtyp .eq. 5) then
c           Solute group swap
            call deploy2slt(c,orientsltm,dihang,1)
            nswaptry=nswaptry+1
            nswtry(molmov)=nswtry(molmov)+1
            nswtry(molmovs)=nswtry(molmovs)+1
            isolvp=molmov
            ityptry=3
          else if (movtyp .eq. 6) then
c           Correlated 2-solute molecule move
            call deploy2slt(c,orientsltm,dihang,2)
            nmv2stry=nmv2stry+1
            n2stry(molmov)=n2stry(molmov)+1
            n2stry(molmovs)=n2stry(molmovs)+1
            isolvp=molmov
            ityptry=3
          else
c           Special move
            call deploysp(iout)
            nspslttry=nspslttry+1
            nspsttry(itormov)=nspsttry(itormov)+1
            isolvp=molmov
c           ityptry=5
          end if
        end if
        if (idebug(60) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,7500) 'Trying',
     -      isolvp,movtyp,icopy,ityptry
        end if
        cplfac=1.0
        if (idebug(175) .gt. 0)
     -     call checkhdist(c,183,201,iout,'after move',10,0,nstta)
        if (idebug(10) .gt. 0) then
          if ((movtyp .gt. 1 .or. idebug(10) .gt. 1)
     -        .and. MYRANK .eq. 0) then
            if (movtyp .gt. 1) then
              if (idebug(10) .gt. 1) then
                iprf=1
                iprl=nstta
              else
                iprf=ifirstm(molmov)
                iprl=ilastm(molmov)
              end if
            else
              iprf=1
              iprl=nstta
            end if
            write (iout,7511) ' After trial change',
     -        nmc,(ia,(c(k,ia),k=1,3),(cslto(k,ia),k=1,3),
     -        sqrt(arrdist(c(1,ia),cslto(1,ia))),ia=iprf,iprl)
            if (movtyp .eq. 5) write (iout,7511) ' After trial change',
     -        nmc,(ia,(c(k,ia),k=1,3),(cslto(k,ia),k=1,3),
     -        sqrt(arrdist(c(1,ia),cslto(1,ia))),
     -        ia=ifirstm(molmovs),ilastm(molmovs))
             do im=1,nsttm
               if (im .ne. molmov .and. im .ne. molmovs) then
c                Check to see if coordinates are really unchanged
                 do ia=ifirstm(im),ilastm(im)
                   if (arrdist(c(1,ia),cslto(1,ia)) .gt. 0.0001)
     -               write (iout,7511) '***** ERROR ',
     -                 nmc,(ja,(c(k,ia),k=1,3),(cslto(k,ja),k=1,3),
     -               sqrt(arrdist(c(1,ja),cslto(1,ja))),ja=iprf,iprl)
                 end do
               end if
             end do
          end if
        end if
        if (idebug(28) .gt. 0) then
          if (movtyp .eq. 4 .and. MYRANK .eq. 0) write (iout,7512)
     -      (it,dihang(it)*rdtodg,dihango(it)*rdtodg,it=1,ntang)
        end if
        if (isolv .gt. 1) then
c         Solvent move
          call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolecdo)
          if (iop(67) .gt. 0) then
            call eslvfield(c(1,ic01+isolv*nslv),nslv,efieldismn)
            efieldcha=efieldismn-efieldsv(isolv)
            etotn=etotn+efieldcha
          end if
          risn=rijpsis
          ipxn(isolv)=ipxis
          if (iop(92) .gt. 0) then
c           Primary hydration shell
            if (idebug(99) .gt. 0 .and. MYRANK .eq. 0) then
              write (iout,7521) (rijpso(is),is=2,nmolec)
              write (iout,7522) (uphs(is),is=2,nmolec)
              write (iout,7523) (ipxo(is),is=2,nmolec)
            end if
            rphs0isnn=rphs0is
            riso=rijpso(isolv)
            ephsiso=uphs(isolv)
            ephsisn=0.0
            if (risn .gt. rphs) ephsisn=phsk*(risn-rphs)**2
            etotn=etotn+ephsisn-ephsiso
            ephsn=ephso+ephsisn-ephsiso
          end if
        else
          if (movtyp .eq. 1 .or.
     -        (ityptry .eq. 2 .and. nsttm-nstfm1 .eq. 1) .or.
     -        (ityptry .eq. 3 .and. nsttm-nstfm1 .eq. 2)) then
c           Full solute has been changed
            call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolecdo)
            if (iop(67) .gt. 0) then
              call esltfield(c,ixislt,1,nstta0,efieldimn,esltfldn,
     -          iop(67),inperr,iout,#ST)
              call ixsum(esltfldo,ixislt,1,nstta,nstta,efieldimo)
              efieldcha=efieldimn-efieldimo
              etotn=etotn+efieldcha
            end if
          end if
          if (ityptry .eq. 2 .and. nsttm-nstfm1 .gt. 1) then
c           ityptry=2 - move 1 solute molecule
c          Calculate interaction energy between solute molecules
c          Tom: doesn't compute ligand-ligand interaction energies
            call esltsltg(c,molstf,nsttm,ifirstm,ilastm,ifgrmolslt,
     -        ilgrmolslt,ifgrslt,ilgrslt,gbenew,gbernew,1,istf,nstta,
     -        iclsltt,qslteps,molmov,0,0,grsum12,nsttia0,nsttia1,
     -        cpl1tix,cpl0tix,gsuml0n,gsuml1n,igrcnt,molcnt,crmx,iop(5),
     -        iop(65),indexx,ivopt,riijjv,cgs,cutuus,iop(127))
            call dsum(gbernew,ifirstm(molmov),ilastm(molmov),gbeg)
C@D4            call checkeijmol(2,nstta,ifirstm(molmov),ilastm(molmov),
C@D4     -        ixislt)
c          Calculate interaction energy between all solvent molecules and
c          1 solute molecule(?)
c          No need to modify this
            call epsltslv(cslto,c(1,nstta+1),igrcnt,crm,
     -        crmpmf,ixislt,nstta,igrslt,ifgrmolslt(molmov),
     -        ilgrmolslt(molmov),0,0,1,#GR,ifgrslt,ilgrslt,2,nmolec,
     -        icopy,ipfgr,ianslt,texo,vrslto,tsindo,frco,trqois,trqo,
     -        e01sto,rijpso,rijpso,rphs0iso,rphs0iso,iaphsslt,0,ipxo,
     -        ipxn,etotpo,estcop,virsco,nstta,realmx)
            call epsltslv(c,c(1,nstta+1),igrcnt,crm,
     -        crmpmf,ixislt,nstta,igrslt,ifgrmolslt(molmov),
     -        ilgrmolslt(molmov),0,0,1,#GR,ifgrslt,ilgrslt,2,nmolec,
     -        icopy,ipfgr,ianslt,texn,vrsltn,tsindn,frcn,trqnis,trqn,
     -        e01stn,rijpso,rijpsn,rphs0iso,rphs0isn,iaphsslt,ipsdist,
     -        ipxo,ipxn,etotpn,estcnp,virscn,nstta,realmx)
            if (iop(127) .eq. 0) then
              etotn=etoto+(etotpn-etotpo+gbeg-gbuupd(molmov))
            else
              etotn=etoto+(etotpn-etotpo)
            end if
            ettnbn=ettnbo+gbeg-gbuupd(molmov)
            estscn=estsco+(estcnp-estcop)
            if (movtyp .eq. 2 .and. imolcent2 .ne. 0) epmfn=grsum12
            if (iop(67) .gt. 0) then
              call esltfield(c,ixislt,ifirstm(molmov),ilastm(molmov),
     -          efieldimn,esltfldn,iop(67),inperr,iout,#ST)
              efieldcha=efieldimn-efieldmst(molmov)
              etotn=etotn+efieldcha
            end if
          else if (ityptry .eq. 3) then
c           ityptry=3 - move 2 solute molecules
            call esltsltg(c,molstf,nsttm,ifirstm,ilastm,
     -        ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbenew,gbernew,1,
     -        istf,nstta,iclsltt,qslteps,molmov,molmovs,0,grsum12,
     -        nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0n,gsuml1n,igrcnt,
     -        molcnt,crmx,iop(5),iop(65),indexx,ivopt,riijjv,cgs,cutuus,
     -        iop(127))
            call dsum(gbernew,ifirstm(molmov),ilastm(molmov),grsum1)
            call dsum(gbernew,ifirstm(molmovs),ilastm(molmovs),grsum2)
            if (nsttm-nstfm1 .gt. 2) then
              call epsltslv(cslto,c(1,nstta+1),igrcnt,crm,crmpmf,ixislt,
     -          nstta,igrslt,ifgrmolslt(molmov),ilgrmolslt(molmov),
     -          ifgrmolslt(molmovs),ilgrmolslt(molmovs),2,#GR,ifgrslt,
     -          ilgrslt,2,nmolec,icopy,ipfgr,iclslt,texo,vrslto,tsindo,
     -          frco,trqois,trqo,e01sto,rijpso,rijpso,rphs0iso,rphs0iso,
     -          iaphsslt,0,ipxo,ipxn,etotpo,estcop,virsco,nstta,realmx)
              call epsltslv(c,c(1,nstta+1),igrcnt,crm,crmpmf,ixislt,
     -          nstta,igrslt,ifgrmolslt(molmov),ilgrmolslt(molmov),
     -          ifgrmolslt(molmovs),ilgrmolslt(molmovs),2,#GR,ifgrslt,
     -          ilgrslt,2,nmolec,icopy,ipfgr,ianslt,texn,vrsltn,
     -          tsindn,frcn,trqnis,trqn,e01stn,rijpso,rijpsn,rphs0iso,
     -          rphs0isn,iaphsslt,ipsdist,ipxo,ipxn,etotpn,estcnp,
     -          virscn,nstta,realmx)
              if (iop(67) .gt. 0) then
                call esltfield(c,ixislt,ifirstm(molmov),ilastm(molmov),
     -            efieldimn,esltfldn,iop(67),iout,inperr,#ST)
                call esltfield(c,ixislt,ifirstm(molmovs),
     -            ilastm(molmovs),efieldimn1,esltfldn,iop(67),
     -            inperr,iout,#ST)
                efieldcha=efieldimn-efieldmst(molmov)
                efieldcha1=efieldimn1-efieldmst(molmovs)
                etotn=etotn+efieldcha+efieldcha1
              end if
            end if
            if (movtyp .eq. 2) epmfn=grsum12
c           Get the old energy between molmov and molmovs
c           To avoid it, one needs to store an ngr*ngr matrix !!??
            call esltsltg(cslto,molstf,nsttm,ifirstm,ilastm,
     -        ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbeoldsw,gberold,1,
     -        istf,nstta,iclsltt,qslteps,molmov,molmovs,1,grsum12o,
     -        nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0n,gsuml1n,igrcnt,
     -        molcnt,crmx,iop(5),iop(65),indexx,ivopt,riijjv,cgs,cutuus,
     -        iop(127))
            call dsum(gberold,ifirstm(molmov),ilastm(molmov),grsum1o)
            ddintra=grsum1-gbuupd(molmov)+grsum2-
     -        gbuupd(molmovs)-(grsum12-grsum12o)
            ettnbn=ettnbo+ddintra
            if (iop(127) .gt. 0) ddintra=0.d0
            if (nsttm-nstfm1 .gt. 2) then
              etotn=etoto+((etotpn-etotpo)+ddintra)
              estscn=estsco+(estcnp-estcop)
            else
              etotn=etotn+ddintra
            end if
          else if (ityptry .eq. 4) then
c           ityptry=4 - change torsion on 1 solute molecule
            cplfac=cplcoef(icopy)
            call epsltslv(cslto,c(1,nstta+1),igrcnt,crm,
     -        crmpmf,lsttorgrp,#TA,igrslt,iftormovgrgr(itormov),
     -        iltorgrgr,0,0,1,#TL,iftormovgra,iltormovgra,2,nmolec,
     -        icopy,ipftor,ianslt,texo,vrslto,tsindo,frco,trqois,
     -        trqo,e01sto,rijpso,rijpso,rphs0iso,rphs0iso,iaphsslt,0,
     -        ipxo,ipxn,etotpo,estcop,virsco,nstta,realmx)
            call epsltslv(c,c(1,nstta+1),igrcnt,crm,
     -        crmpmf,lsttorgrp,#TA,igrslt,iftormovgrgr(itormov),
     -        iltorgrgr,0,0,1,#TL,iftormovgra,iltormovgra,2,nmolec,
     -        icopy,ipftor,ianslt,texn,vrsltn,tsindn,frcn,trqnis,
     -        trqn,e01stn,rijpso,rijpsn,rphs0iso,rphs0isn,iaphsslt,
     -        ipsdist,ipxo,ipxn,etotpn,estcnp,virscn,nstta,realmx)
C@dc      labcall='TRYN'
            call esltsltt(c,lsttorgrp,molstftt,nsttm,ifirstm,ilastm,
     -        ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,
     -        iftormovgrgr(itormov),iltorgrgr,iftormovgra,iltormovgra,
     -        iftorgrp(itormov),iltorgrp(itormov),ilhbtorgrp(itormov),
     -        mapbitu,#UW,#ST,nbits,istf,nstta,iclsltt,qslteps,
     -        molmov,nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0n,gsuml1n,
     -        igrslt,igrcnt,molcnt,crmpmf,gbenew,gbernew,gsumselfn,
     -        iop(5),iop(65),1,indexx,ivopt,riijjv,cgs,cutuus,iop(127),
     -        #TA,#TL)
C@D4              call checkeijmol(2,nstta,iftorgrp(itormov),
C@D4     -          iltorgrp(itormov),lsttorgrp)
C@dc      labcall='TRYO'
            call esltsltt(cslto,lsttorgrp,molstftt,nsttm,ifirstm,ilastm,
     -        ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,
     -        iftormovgrgr(itormov),iltorgrgr,iftormovgra,iltormovgra,
     -        iftorgrp(itormov),iltorgrp(itormov),ilhbtorgrp(itormov),
     -        mapbitu,#UW,#ST,nbits,istf,nstta,iclsltt,qslteps,
     -        molmov,nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0o,gsuml1o,
     -        igrslt,igrcnt,molcnt,crmpmf,gbeold,gberold,gsumselfo,
     -        iop(5),iop(65),2,indexx,ivopt,riijjv,cgs,cutuus,iop(127),
     -        #TA,#TL)
C@dc      labcall='SLFT'
            gbeg=0.d0
            lasttoratmov=iltormovgra(iltorgrgr)
            do ia=iftorgrp(itormov),lasttoratmov
              gbeg=gbeg+gbernew(lsttorgrp(ia))
            end do
            call esltslt14(c,lsttorgrp,iftorgrp(itormov),
     -        lasttoratmov,nneig3,nneig4,ineig,iclsltt,qslteps,
     -        esf14,vdwf14,gsum14n,indexx,iop(127),#NL)
            call esltslt14(cslto,lsttorgrp,iftorgrp(itormov),
     -        lasttoratmov,nneig3,nneig4,ineig,iclsltt,qslteps,
     -          esf14,vdwf14,gsum14o,indexx,iop(127),#NL)
            call diheng(torsensumn,itormov,torsensumo,torsen,torsennew,
     -        iop(127))
            if (iop(127) .eq. 0) then
              etotn=etoto+cplfac*(etotpn-etotpo)+(gbeg-gbuupt(itormov))+
     -          fcintra*((gsumselfn-gsumselfo)+(gsum14n-gsum14o)+
     -          (torsensumn-torsensumo))
              if (idebug(177) .gt. 0) write (iout,7767) cplfac,etotpn,
     -          etotpo,gbeg,gbuupt(itormov),fcintra,gsumselfn,
     -          gsumselfo,gsum14n,gsum14o,torsensumn,torsensumo
            else
              etotn=etoto+cplfac*(etotpn-etotpo)
            end if
            ettnbn=ettnbo+gbeg-gbuupt(itormov)
            einnbn=einnbo+gsumselfn-gsumselfo
            es14n=es14o+(gsum14n-gsum14o)
            eslttorn=eslttoro+torsensumn-torsensumo
            estscn=estsco+cplfac*(estcnp-estcop)
            if (iop(67) .gt. 0) then
              call esltfield(c,lsttorgrp,iftorgrp(itormov),lasttoratmov,
     -          efieldimn,esltfldn,iop(67),inperr,iout,#TA)
              call ixsum(esltfldo,lsttorgrp,iftorgrp(itormov),
     -          lasttoratmov,nstta,efieldtst)
              efieldcha=efieldimn-efieldtst
              etotn=etotn+efieldcha
              if (idebug(84) .gt. 0) write (iout,7766)
     -          itormov,etotn,efieldcha,efieldimn,efieldtst
            end if
          else
c           Special move
          end if
          if (iop(91) .gt. 0) then
            if (ityptry .eq. 2 .or. ityptry .eq. 3) then
c             Update moved solute's intra energy as well to avoid energy drift
c             (This is not the most efficient way)
              call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,
     -          nbits,#NL,ifirstm(molmov),ilastm(molmov),iclsltt,
     -          qslteps,esf14,vdwf14,gsumselfn,gsum14n,indexx,iuuon)
              call intrasums(cslto,nneig3,nneig4,ineig,mapbitu,#UW,
     -          #ST,nbits,#NL,ifirstm(molmov),ilastm(molmov),iclsltt,
     -          qslteps,esf14,vdwf14,gsumselfo,gsum14o,indexx,iuuon)
              einbcorr=gsumselfn-gsumselfo
              einnbn=einnbo+einbcorr
              e14corr=gsum14n-gsum14o
              es14n=es14o+e14corr
              etotn=etotn+fcintra*(einbcorr+e14corr)
              if (ityptry .eq. 3) then
                call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,
     -            #ST,nbits,#NL,ifirstm(molmovs),ilastm(molmovs),
     -            iclsltt,qslteps,esf14,vdwf14,gsumselfn,gsum14n,
     -            indexx,iuuon)
                call intrasums(cslto,nneig3,nneig4,ineig,mapbitu,#UW,
     -            #ST,nbits,#NL,ifirstm(molmovs),ilastm(molmovs),
     -            iclsltt,qslteps,esf14,vdwf14,gsumselfo,gsum14o,
     -            indexx,iuuon)
                einbcorrs=gsumselfn-gsumselfo
                einnbn=einnbo+einbcorrs
                e14corrs=gsum14n-gsum14o
                es14n=es14o+e14corrs
                etotn=etotn+fcintra*(einbcorrs+e14corrs)
              end if
            end if
          end if
        end if
c       Restore HS ignoring for energy recalculating
        if (iop(79) .eq. 3 .and. isolv .gt. 1) then
c         Don't allow crossing in/out the grid
          call solvinout(inoutisolv,crm(1,isolv),edgelgr,edgergr)
          if (molinoutgr(isolv) .ne. inoutisolv) then
            if (molinoutgr(isolv) .gt. inoutisolv)
     -        ncrossout=ncrossout+1
            if (molinoutgr(isolv) .lt. inoutisolv) ncrossin=ncrossin+1
            go to 910
          end if
        end if
        if (iop(92) .gt. 0) then
c         Update shell energy when part of the solute was moved
          if (isolv .eq. 1) then
            nphsoutn=0
            ephsn=0.d0
            do is=mvfst,nmolec
              if (rijpsn(is) .gt. rphs) then
                nphsoutn=nphsoutn+1
                iphsoutn(nphsoutn)=is
                if (rijpso(is) .ne. rijpsn(is)) then
                  uphsn(is)=phsk*(rijpsn(is)-rphs)**2
                else
                  uphsn(is)=uphs(is)
                end if
                ephsn=ephsn+uphsn(is)
              else
                uphsn(is)=0.0
              end if
            end do
            etotn=etotn+ephsn-ephso
          end if
        end if
c       Calculate biasing factors
        delfac=1.0d0
        if (isolv .eq. 1) then
          if (movtyp .eq. 2) then
c           Compute umbrella sampling biasing factor
            call cplweight(cplprn,uwcpln,iop(51))
            uwcpln=1.0d0/uwcpln
c           Reject if cplpar bumped into the limit
            if (uwcpln .ge. 1.0d0/(1.d+6/dpmx)) go to 910
            delfac=uwcplo/uwcpln
          else if (movtyp .eq. 4) then
            delfac=ptaccfac
          end if
        else
c         Accumulate stepsize statistics
          if (notrans .eq. 0) then
            if (iop(6) .eq. 2) then
              istep=1
            else
              rnn=sqrt(deln(1)**2+deln(2)**2+deln(3)**2)
              if (iop(6) .eq. 3) then
                istep=50.0*rnn/(cedslv+0.0001)+1
              else
                istep=50.0*rnn/((cedslv/2.0)*sqrt(3.0)+0.0001)+1
              end if
              nrtry(istep)=nrtry(istep)+1
            end if
          end if
          if (iop(12) .gt. 3) then
c           Update pref sampling weight sum, compute biasing factor
            wpsmvnew=prfwgt(nis(1),wpsmvn,0)
            delfac=wpsmvnew/wpsmv(isolv)
          end if
        end if
        if (movtyp .eq. 1) then
          call biasfc(delfac)
        else if (iop(117) .gt. 0) then
          call eslt_constraint(c,econstrn)
          etotn=etotn+econstrn-econstro
        end if
        if (kut .gt. 0) nftcut=nftcut+1
c       Test for acceptance
C@EF        if (isnan(etotn)) etotn=realmx
        ediff=-etotn+etoto
        if (iop(53) .eq. 3) then
          call parsum(isolv,nmolec,movtyp,3,nstfm,iop(18),tss1n,tsind,
     -      tsindn,tsindo)
          tss1n=tss1n+tss1
          uewnew=tss1n-uscpma*dfloat(nmolec-1)
          uewnew=usmixp*dble(beta)*uewnew
          ediff=ediff+(uewnew-uewold)/beta
        end if
        if (iop(96) .gt. 0) then
c         Use only part of the solute energy for accept/reject
          if (iop(96) .eq. 1 .and. ityptry .eq. 4) then
c           Chop torsion term
            dnbsdiff=-dble(beta*tornbfac)*(eslttorn-ew0nb)
            if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,7760) 'eslttorn',eslttorn
          else if (iop(96) .eq. 2) then
c           Modified slt-slv repulsion sampling - need the repulsion term now
            if (isolv .eq. 1) then
              call parsum(isolv,nmolec,movtyp,1,nstfm,iop(18),tss12n,
     -          tsind,tsindn,tsindo)
              tss12n=tss12n+tss12
            else
              tss12n=tss12+tsindn(1,isolv)-tsindo(1,isolv)
            end if
            dnbsdiff=-dble(beta*repnbfac)*(tss12n-ew0nb)
            if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -         write (iout,7760) 'tss12n',tss12n
          else if (iop(96) .eq. 5) then
c           Chop solute intra NB term
            dnbsdiff=-dble(beta*sltsltfac)*(einnbn-ew0nb)
            if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,7760) 'einnbn',einnbn
          else if (iop(96) .eq. 6) then
c           Chop torsion and solute intra NB term
            dnbsdiff=-dble(beta*sltsltfac)*(einnbn-ew0nb)
            if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,7760) 'einnbn',einnbn
            if (ityptry .eq. 4) then
              dnbsdiff=dnbsdiff-dble(beta*tornbfac)*(eslttorn-ew0nb)
              if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,7760) 'eslttorn',eslttorn
            end if
          else if (iop(96) .eq. 3 .or. iop(96) .eq. 4) then
c           Need total solute energy
            if (isolv .eq. 1) then
              if (movtyp .eq. 1 .or.
     -            (ityptry .eq. 2 .and. nsttm-nstfm1 .eq. 1) .or.
     -            (ityptry .eq. 3 .and. nsttm-nstfm1 .eq. 2)) then
                teslt=tesiis+ettnbn+einnbn+es14n+eslttorn
              else
     -          teslt=tesi(1)+etotpn-etotpo+
     -            ettnbn+einnbn+es14n+eslttorn
              end if
            else
              teslt=tesi(1)+tesiis-tesi(isolv)+
     -          ettnbn+einnbn+es14n+eslttorn
            end if
            if (idebug(84) .gt. 1 .and. MYRANK .eq. 0)
     -        write (iout,7761) isolv,ettnbn,einnbn,es14n,eslttorn,
     -          tesi(1),tesiis,tesi(isolv)
            if (iop(96) .eq. 3) then
c             Solute is at a different T
              dnbsdiff=dble(beta*(temp/slttmp-1.0))*(teslt-ew0nb)
              if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,7760) 'teslt',teslt
            else if (iop(96) .eq. 4) then
c             Tsallis sampling
              teslt1n=(1.d0-(1.d0-tsexp))*(beta*teslt)+etsincr
              if (teslt1n .lt. 0.d0) then
                if (MYRANK .eq. 0) write (iout,2031) teslt1n
                call datprt(2)
              end if
              uwnbn=dexp(-dble(beta)*
     -          (dble(tsfac/beta)*dlog(teslt1n)+teslt-ew0nb))
              delfac=delfac*(teslt1/teslt1n)**tsfac
              if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -           write (iout,7760) 'teslt',teslt,' ',teslt1n
            end if
          end if
          if (iop(96) .ne. 4) then
            if (dabs(dnbsdiff) .gt. dblnmx) then
c             Avoid overflow - reject for sure
              delfac=1.d0
              ediff=-rllnmx/beta-1.0
            else
              uwnbn=dexp(dnbsdiff)
              delfac=delfac*uwnbn/uwnb
            end if
          end if
          if (idebug(84) .gt. 0 .and. MYRANK .eq. 0)
     -      write (iout,7762) uwnbn,delfac
        end if
C@DB        iudb1=81
C@DB        iudb2=82
C@DB        lenfpdb=10
C@DB        filename1(1:lenfpdb)='cslt_n.pdb'
C@DB        call savepdb('PDB ',keycol,iudb1,iout,1,nstta,3,c,
C@DB     -    -1,0,0,1,filename1,lenfpdb,nmc,2,file,namlenf,1,1,0,inperr,
C@DB     -    nwarn,nwwarn,7,0,nlwr,0,-1,#ST)
C@DB        lenfpdb=10
C@DB        filename1(1:lenfpdb)='cslt_o,pdb'
C@DB        call savepdb('PDB ',keycol,iudb2,iout,1,nstta,3,cslto,
C@DB     -    -1,0,0,1,filename1,lenfpdb,nmc,2,file,namlenf,1,1,0,inperr,
C@DB     -    nwarn,nwwarn,8,0,nlwr,0,-1,#ST)
        if (ediff .gt. emaxchange) emaxchange=ediff
        scdifln=ediff*beta+dlog(delfac)
        if (scdifln .gt. 0.0) then
c         scdif > 1 --> accept for sure
          go to 909
        else
c         Avoid underflow - reject if scdif would be too small
          if (scdifln .lt. -rllnmx) go to 910
c         Now the Metropolis test
          scdif=exp(scdifln)
          call mmc_random(1,drno)
          if (scdif .gt. drno(1)) go to 909
        end if
c-------Configuration rejected - restore crm, c(isolv)
910     nrpt=nrpt+1
        nrejis(isolv)=nrejis(isolv)+1
        iaccrej=1
        if (idebug(60) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,7842) 'Rejecting',ediff,delfac,etotn,etoto,
     -      exp(amax1(-rllnmx,scdifln)),drno(1),texn(1),texslt(isolv),
     -      etotpn,etotpo,ettnbn,ettnbo,einnbn,einnbo,es14n,es14o,
     -      eslttorn,eslttoro,econstrn,econstro
        if (npfused(9) .gt. 0) ignorehs=ignorehsref
c       Restore the coordinates
        if (ityptry .eq. 1) then
          call trnsfr(crm(1,isolv),crmi,3)
          if (isolv .eq. 1) then
            call trnsfr(c(1,icsol1),cslto,natm3)
          else
            call trnsfr(c(1,icsol1),cslvo,natm3)
          end if
        else if (ityptry .eq. 2) then
          call trnsfr(c(1,ifirstm(molmov)),cslto(1,ifirstm(molmov)),
     -      3*(ilagr-ifagr+1))
          if (movtyp .eq. 2) then
            if (iop(38) .gt. 0) call lincmb(c,crm,cplpar,1,qslt,nstfa0)
            if (iop(18) .eq. 5) then
              call trnsfr(crmpmf,crmi,3)
              call trnsfr(ort2nd,orj,9)
            end if
          end if
        else if (ityptry .eq. 3) then
          if (iop(7) .eq. 2 .and. movtyp.eq. 2) then
            dijs=dijso
            dijq=dijqo
            eniemx=eniemo
          end if
          call trnsfr(c(1,ifirstm(molmov)),cslto(1,ifirstm(molmov)),
     -      3*(ilagr-ifagr+1))
          call trnsfr(c(1,ifirstm(molmovs)),cslto(1,ifirstm(molmovs)),
     -      3*(ilagrs-ifagrs+1))
          if (movtyp .eq. 2) then
            if (iop(38) .gt. 0) call lincmb(c,crm,cplpar,1,qslt,nstfa0)
          end if
        else if (ityptry .eq. 4) then
c         Restore the atoms affected by the rotation
          if (ptaccfac .gt. 0.0 .or. irejtyp .eq. 4 .or.
     -        ifdhgrlst(itormov) .ne. ildhgrlst(itormov)) then
            if (iop(18) .eq. 4) then
c             Torsion coupling
              do ia=ifagr,ilagr
                do k=1,3
                  c(k,lsttorgrp(ia))=cslto(k,lsttorgrp(ia))
                end do
              end do
            else
              do ia=ifagr,ilagr
                do itorcp=ncoptorfact,ncoptoract
                  do k=1,3
                    c(k,lsttorgrp(ia)+(itorcp-1)*nstfa0)=
     -                cslto(k,lsttorgrp(ia)+(itorcp-1)*nstfa0)
                  end do
                end do
              end do
            end if
            if (idebug(10) .gt. 2)
     -        write (iout,8797) (lsttorgrp(ia),ia=ifagr,ilagr)
8797          format(' RESTORING atoms ',100i6)
          else
            it=ifdhgrlst(itormov)
            nrotrest=1
            if (looptyp(it) .eq. 3 .or. looptyp(it) .eq. 4) nrotrest=2
            do ii=1,nrotrest
              itt=irotlist(irotlinc(it)+ii)
              call trnsfr(c(1,itt),cslto(1,itt),3)
            end do
cc          if (looptyp(it) .eq. 3) then
c             All atoms rotated by the loop root were changed
cc            do ii=1,nrot(it)
cc              itt=irotlist(irotlinc(it)+ii)
cc              call trnsfr(c(1,itt),cslto(1,itt),3)
cc            end do
cc          else
cc            i4=iquata(ifdhgrlst(itormov),4)
cc            call trnsfr(c(1,i4),cslto(1,i4),3)
cc          end if
          end if
c         Restore the torsion angles affected by the rotation
          do it=ifdhgrlst(itormov),ildhgrlst(itormov)
            dihang(it)=dihango(it)
            if (ptaccfac .ne. 0.0 .or. irejtyp .eq. 4) then
              if (looptry(it) .ne. 0) then
                loopmark='L'
c               Restore all the torsions affected by the loop move
                do k=1,6
                  itl=looplist(k,it)
                  dihang(itl)=dihango(itl)
                end do
                if (ptaccfac .ne. 0.0)
     -            call restoreloop(it,iquata,looplist,
     -              iprecursor,nrot,irotlist,irotlinc,bond,bond2,angle,
     -              cangle,bond13,bond12,angle13,cangle13,
     -              bondf,bondproj,xfac13,xfac12,idebug(67),iout,
     -              #ST,#TR,#LT)
              end if
            else
              if (looptry(ifdhgrlst(itormov)) .ne. 0) loopmark='L'
            end if
          end do
        else
c         Special move
        end if
        if (iop(107)+idebug(40) .gt. 0) then
          if (movtyp .eq. 3) then
            if (norot .eq. 1) then
              accsumtransprev(molmov)=accsumtrans(molmov)
              accsumtrans(molmov)=wsum(1)*accsumtrans(molmov)
              ntrantune(molmov)=ntrantune(molmov)+1
              do k=1,3
cwww            stepsumtrans(k,molmov)=wstepsum(1)*stepsumtrans(k,molmov)+
cwww -             wstepsum1(1)*cedpsltim(k,molmov)
                stepsumtrans(k,molmov)=
     -            wstepsum(1)*stepsumtrans(k,molmov)+cedpsltim(k,molmov)
                stepsumtranscumu(k,molmov)=stepsumtrans(k,molmov)
              end do
            else
              accsumrotprev(iaxis,molmov)=accsumrot(iaxis,molmov)
              accsumrot(iaxis,molmov)=wsum(2)*accsumrot(iaxis,molmov)
cwww          stepsumrot(iaxis,molmov)=wstepsum(2)*
cwww -          stepsumrot(iaxis,molmov)+
cwww -          wstepsum1(2)*rtxpslt(iaxis,molmov)
              stepsumrot(iaxis,molmov)=wstepsum(2)*
     -          stepsumrot(iaxis,molmov)+rtxpsltim(iaxis,molmov)
              stepsumrotcumu(iaxis,molmov)=stepsumrot(iaxis,molmov)
              nrottune(iaxis,molmov)=nrottune(iaxis,molmov)+1
            end if
            if (idebug(40) .gt. 1) then
              write (iout,7530) '(R)',accsumtransprev(molmov),
     -          (accsumrotprev(k,molmov),k=1,3)
              write (iout,7531) '(R)',norot,iaxis,accsumtrans(molmov),
     -          (accsumrot(k,molmov),k=1,3),(stepsumtrans(k,molmov),
     -          k=1,3),(stepsumrot(k,molmov),k=1,3)
            end if
          else if (movtyp .eq. 4) then
            do it=ifdhgrlst(itormov),ildhgrlst(itormov)
              if (looptry(it) .eq. 0) then
                call origtor(it,itorig,iop(69),itn)
                accsumtorprev(itn)=accsumtor(itn)
                accsumtor(itn)=wsum(3)*accsumtor(itn)
                stepsumtorprev=stepsumtor(itn)
cwww            stepsumtor(itn)=wstepsum(3)*stepsumtor(itn)+
cwww -             wstepsum1(3)*torstep(itn)
                stepsumtor(itn)=wstepsum(3)*stepsumtor(itn)+torstep(itn)
                stepsumtorcumu(itn)=stepsumtorcumu(itn)+torstep(itn)
                if (idebug(40) .gt. 1) write (iout,7532) '(R)',itn,
     -            itormov,'tor',accsumtor(itn),accsumtorprev(itn),
     -            stepsumtor(itn),stepsumtorprev,dihang(it)*rdtodg
              else
                call origtor(it,itorig,iop(69),itn)
                accsumloopprev(itn)=accsumloop(itn)
                accsumloop(itn)=wsum(4)*accsumloop(itn)
                stepsumloopprev=stepsumloop(itn)
cwww            stepsumloop(itn)=wstepsum(4)*stepsumloop(itn)+
cwww -            wstepsum1(4)*steploop(itn)
                stepsumloop(itn)=wstepsum(4)*stepsumloop(itn)+
     -            steploop(itn)
                stepsumloopcumu(itn)=stepsumloopcumu(itn)+steploop(itn)
                if (idebug(40) .gt. 1) write (iout,7532) '(R)',itn,
     -            itormov,'loop',accsumloop(itn),accsumloopprev(itn),
     -            stepsumloop(itn),stepsumloopprev,dihang(it)*rdtodg
              end if
            end do
          end if
        end if
        go to 609
c-------Configuration accepted
909     continue
        iaccrej=2
        nrejis(isolv)=0
        if (idebug(60) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,7842) 'Accepting',ediff,delfac,etotn,etoto,
     -      exp(amin1(rllnmx,scdifln)),drno(1),texn(1),texslt(isolv),
     -      etotpn,etotpo,ettnbn,ettnbo,einnbn,einnbo,es14n,es14o,
     -      eslttorn,eslttoro,econstrn,econstro
        call checkfixedats(isltmv,c,nstta,0,0.2,idebug(129),
     -    'Driver, start accept',iout)
        if (npfused(9) .gt. 0) ignorehs=ignorehsref
        if (iop(109) .eq. 1) then
c         Minimum over structures in this stretch before next saving
          if (etotn .lt. eminhsave) then
            eminhsave=etotn
            call trnsfr(cminhsave,c,natoms*3)
            nmcminhsave=nmc
            natomshsave=natoms
            if (idebug(136) .gt. 1) write (iout,7401) 'stretch',
     -        nmc,etotn
            nminhsave=nminhsave+1
          end if
        else if (iop(109) .ge. 2) then
c         Minimum over all structures
          if (etotn .lt. eminsave) then
            eminsave=etotn
            call trnsfr(cminsave,c,natoms*3)
            nmcminsave=nmc
            natomssave=natoms
            if (idebug(136) .gt. 1) write (iout,7401) 'overall',
     -        nmc,etotn
            nminsave=nminsave+1
          end if
        end if
c       Minimum/maximum energy to be updated
        if (etotn .lt. emin) then
          emin=etotn
          nmin=nmc/1000
        else if (etotn .gt. emax) then
          emax=etotn
          nmax=nmc/1000
        end if
        if (movtyp .eq. 1) then
          nmvd(isolv)=nmvd(isolv)+1
          nmovacc=nmovacc+1
        end if
        if (iop(96) .gt. 0) then
          uwnb=uwnbn
          if (uwnbmin .gt. uwnb) uwnbmin=uwnb
          if (uwnbmax .lt. uwnb) uwnbmax=uwnb
          if (iop(96) .ge. 3) then
            teslt1=teslt1n
          end if
        end if
c       Restore old configuration and recompute old energy
        if (isolv .eq. 1) then
          if (movtyp .eq. 1 .or.
     -        (ityptry .eq. 2 .and. nsttm-nstfm1 .eq. 1) .or.
     -        (ityptry .eq. 3 .and. nsttm-nstfm1 .eq. 2)) then
c           Full solute has been changed
            call trnsfr(rcomiso,rcomisn,nmolec)
            call engold(iop(21),iop(119),isolv,texslt,vrcslt,
     -        frcslt,trtslt,trvslt,c,crm)
            if (iop(82) .gt. 0) call trnsfi(iopbst,iopbso,nmolec)
            if (iop(57)+iop(58) .gt. 0 .and. movtyp .eq. 1)
     -        call trnsfr(cslto,c,nstta3)
            call savsusvfull(isolv,nmolec,texslt,vrcslt,frcslt,
     -        trtslt,trvslt,tss12,tss6,tss1,tsind)
            if (movtyp .eq. 1) then
              if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
c               Update the solute grid covering
                call movcovu(iout,cslto,c,1,nstta,ixislt,ianslt)
              end if
            end if
          else
c           Save solute-solvent changes
            call savsusvpar(nmolec,icopy,cplfac,texslt,vrcslt,
     -        frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind)
C@FR            call e123sum(frci(1),frci(2),frci(3),frcslt,nmolec)
C@FR            do k=1,3
C@FR              frci(k)=-frci(k)
C@FR              trqi(k)=0.d0
C@FR            end do
C@FRC@TS            call e123sum(trqi(1),trqi(2),trqi(3),trtslt,nmolec)
            tesiis=tesi(1)+cplfac*(etotpn-etotpo)
          end if
          if (movtyp .gt. 1) then
            if (movtyp .eq. 2) then
              npmfacc=npmfacc+1
              epmfo=epmfn
              uwcplo=uwcpln
              cplpar=cplprn
              cplpr1=cp1prn
              if (cpl0mn .gt. cplpar) cpl0mn=cplpar
              if (cpl0mx .lt. cplpar) cpl0mx=cplpar
              if (cplimn .gt. cplpar) cplimn=cplpar
              if (cplimx .lt. cplpar) cplimx=cplpar
              if (iop(51) .ge. 1) then
c               Check if a sweep has been completed
                if (cplpar .lt. cplmin+g0cpl) then
                  if (nlast .ne. 1) then
                    nsweep=nsweep+1
                    nlast=1
                  end if
                else if (cplpar .gt. cplmax-g0cpl) then
                  if (nlast .ne. 2) then
                    nsweep=nsweep+1
                    nlast=2
                  end if
                end if
              end if
            else if (movtyp .eq. 3) then
c             Partial solute move
              npdsltacc=npdsltacc+1
              npdstacc(molmov)=npdstacc(molmov)+1
              if (istepmag .gt. 0)
     -          nptaacc(iaxis,istepmag)=nptaacc(iaxis,istepmag)+1
              sltstepsum(molmov)=sltstepsum(molmov)+absstep
              if (iop(107)+idebug(40) .gt. 0) then
                if (norot .eq. 1) then
                  accsumtransprev(molmov)=accsumtrans(molmov)
                  accsumtrans(molmov)=wsum(1)*accsumtrans(molmov)+
     -              wsum1(1)
                  ntrantune(molmov)=ntrantune(molmov)+1
                  do k=1,3
cwww                stepsumtrans(k,molmov)=wstepsum(1)*stepsumtrans(k,molmov)+
cwww -                wstepsum1(1)*cedpsltim(k,molmov)
                    stepsumtrans(k,molmov)=wstepsum(1)*
     -                stepsumtrans(k,molmov)+cedpsltim(k,molmov)
                    stepsumtranscumu(k,molmov)=
     -                stepsumtranscumu(k,molmov)+cedpsltim(k,molmov)
                  end do
                else
                  accsumrotprev(iaxis,molmov)=accsumrot(iaxis,molmov)
                  accsumrot(iaxis,molmov)=wsum(2)*
     -              accsumrot(iaxis,molmov)+wsum1(2)
cwww              stepsumrot(iaxis,molmov)=wstepsum(2)*stepsumrot(iaxis,molmov)+
cwww -              wstepsum1(2)*rtxpsltim(iaxis,molmov)
                  stepsumrot(iaxis,molmov)=wstepsum(2)*
     -              stepsumrot(iaxis,molmov)+rtxpsltim(iaxis,molmov)
                  stepsumrotcumu(iaxis,molmov)=
     -              stepsumrotcumu(iaxis,molmov)+
     -              stepsumrot(iaxis,molmov)
                  nrottune(iaxis,molmov)=nrottune(iaxis,molmov)+1
                end if
              end if
              if (idebug(40) .gt. 1) then
                write (iout,7530) '(A)',accsumtransprev(molmov),
     -            (accsumrotprev(k,molmov),k=1,3)
                write (iout,7531) '(A)',norot,iaxis,
     -            accsumtrans(molmov),(accsumrot(k,molmov),k=1,3),
     -            (stepsumtrans(k,molmov),k=1,3),
     -            (stepsumrot(k,molmov),k=1,3)
              end if
            else if (movtyp .eq. 4) then
c             Partial solute torsion
              nptsltacc=nptsltacc+1
              it=ifdhgrlst(itormov)
              call origtor(it,itorig,iop(69),itn)
              if (looptry(it) .eq. 0) then
                nptstacc(itn)=nptstacc(itn)+1
              else
                nptloopacc(itn)=nptloopacc(itn)+1
              end if
              if (iop(107)+idebug(40) .gt. 0) then
                do it=ifdhgrlst(itormov),ildhgrlst(itormov)
                  if (looptry(it) .eq. 0) then
                    call origtor(it,itorig,iop(69),itn)
                    accsumtorprev(itn)=accsumtor(itn)
                    accsumtor(itn)=wsum(3)*accsumtor(itn)+wsum1(3)
                    stepsumtorprev=stepsumtor(itn)
cwww                stepsumtor(itn)=wstepsum(3)*stepsumtor(itn)+
cwww -                wstepsum1(3)*torstep(itn)
                    stepsumtor(itn)=wstepsum(3)*stepsumtor(itn)+
     -                torstep(itn)
                    stepsumtorcumu(itn)=stepsumtorcumu(itn)+torstep(itn)
                    if (idebug(40) .gt. 1) write (iout,7532) '(A)',itn,
     -                itormov,'tor',accsumtor(itn),accsumtorprev(itn),
     -                stepsumtor(itn),stepsumtorprev,dihang(it)*rdtodg
                  else
                    call origtor(it,itorig,iop(69),itn)
                    accsumloopprev(itn)=accsumloop(itn)
                    accsumloop(itn)=wsum(4)*accsumloop(itn)+wsum1(4)
                    stepsumloopprev=stepsumloop(itn)
cwww                stepsumloop(itn)=wstepsum(4)*stepsumloop(itn)+
cwww -                wstepsum1(4)*steploop(itn)
                    stepsumloop(itn)=wstepsum(4)*stepsumloop(itn)+
     -                steploop(itn)
                    stepsumloopcumu(itn)=stepsumloopcumu(itn)+
     -                steploop(itn)
                    if (idebug(40) .gt. 1) write (iout,7532) '(A)',itn,
     -                itormov,'loop',accsumloop(itn),
     -                accsumloopprev(itn),stepsumloop(itn),
     -                stepsumloopprev,dihang(it)*rdtodg
                  end if
                end do
              end if
              do it=ifdhgrlst(itormov),ildhgrlst(itormov)
                tstep=amin1(abs(dihang(it)-
     -            dihango(it)),abs(dihang(it)-dihango(it)-pi2),
     -            abs(dihang(it)-dihango(it)+pi2))
                if (idebug(31) .gt. 0 .and. MYRANK .eq. 0)
     -            write (iout,7730) it,
     -              tstep*rdtodg,dihang(it)*rdtodg,dihango(it)*rdtodg
                if (looptry(ifdhgrlst(itormov)) .eq. 0) then
                  tstepsum(it)=tstepsum(it)+tstep
                  if (tstepmax(it) .lt. tstep) tstepmax(it)=tstep
                else
                  tlstepsum(it)=tlstepsum(it)+tstep
                  if (tlstepmax(it) .lt. tstep) tlstepmax(it)=tstep
                end if
              end do
            else if (movtyp .eq. 5) then
c             Solute group swap
              nswapacc=nswapacc+1
              nswacc(molmov)=nswacc(molmov)+1
              nswacc(molmovs)=nswacc(molmovs)+1
            else if (movtyp .eq. 6) then
c             2-solute molec move
              nmv2sacc=nmv2sacc+1
              n2sacc(molmov)=n2sacc(molmov)+1
              n2sacc(molmovs)=n2sacc(molmovs)+1
            else
c             Special step
              nspsltacc=nspsltacc+1
              nspstacc(molmov)=nspstacc(molmov)+1
            end if
            if (ityptry .eq. 2) then
              if (movtyp .eq. 3) then
                if (notrans .eq. 0) then
                  steptot=0.0
                  do k=1,3
                    stepk=abs(ch(k)-cd(k))
                    avststp(k)=avststp(k)+stepk
                    steptot=steptot+stepk**2
                  end do
                  avststptot2=avststptot2+steptot
                  avststptot=avststptot+sqrt(steptot)
                end if
                if (norot .eq. 0) avstrot(iaxis)=avstrot(iaxis)+phiabs
              end if
c             1-molecule move
              ettnb01(icopy,1)=ettnb01(icopy,1)+gbeg-gbuupd(molmov)
              if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
c               Update the solute grid covering
                call movcovu(iout,cslto,c,ifagr,ilagr,ixislt,ianslt)
              end if
              if (nsttm-nstfm1 .gt. 1) then
                call esltsltg(cslto,molstf,nsttm,ifirstm,
     -            ilastm,ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbeold,
     -            gberold,1,istf,nstta,iclsltt,qslteps,molmov,0,0,
     -            grsum12,nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0o,
     -            gsuml1o,igrcnt,molcnt,crmx,iop(5),iop(65),indexx,
     -            ivopt,riijjv,cgs,cutuus,iop(127))
C@D4                call checkeijmol(4,nstta,ifirstm(molmov),
C@D4     -            ilastm(molmov),ixislt)
C@D4                call checkeijmol(3,nstta,ifirstm(molmov),i
C@D4     -              ilastm(molmov),ixislt)
                if (idebug(12) .gt. 0 .and. MYRANK .eq. 0) then
                  if (idebug(12) .gt. 1) then
                    write (iout,7731) 'gbeold=   ',(gbeold(i),i=1,nstta)
                    write (iout,7731) 'gbenew=   ',(gbenew(i),i=1,nstta)
                  end if
                  write (iout,7731) 'gbuupd(o)=',
     -              (gbuupd(im),im=ngrdmn,ngrdmx)
                  if (ntang .gt. 0) write (iout,7731) 'gbuupt(o)=',
     -              (gbuupt(itg),itg=1,ntorgrp)
                end if
c               Update here the group binding energies
                if (idebug(57) .gt. 0) then
                  call grpsum(gbenew,imolpd,imolpt,ifirstm,ilastm,
     -              ngrdmn,ngrdmx,iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,
     -              istf,nstta,beggd,beggt,beg)
                  if (MYRANK .eq. 0) write (iout,7738)
     -              molmov,(im,beggd(im),im=ngrdmn,ngrdmx)
                end if
                do i=istf,nstta
                  gbenew(i)=gbenew(i)-gbeold(i)
                end do
                call grpsum(gbenew,imolpd,imolpt,ifirstm,ilastm,
     -            ngrdmn,ngrdmx,iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,
     -            istf,nstta,beggd,beggt,beg)
                do im=ngrdmn,ngrdmx
                  gbuupd(im)=gbuupd(im)+beggd(im)
                end do
                gbuupd(molmov)=gbeg
                if (ntang .gt. 0) then
                  do itg=1,ntorgrp
                    gbuupt(itg)=gbuupt(itg)+beggt(itg)
                  end do
c                 Special handling for torsions on the moving molecule
c                 since beggt(itg) will be zero for those
                  do itg=nmtmn(molmov),nmtmx(molmov)
                    do ia=iftorgrp(itg),iltorgrp(itg)
                      gbuupt(itg)=gbuupt(itg)+
     -                  gbernew(lsttorgrp(ia))-gberold(lsttorgrp(ia))
                    end do
                  end do
                end if
                if (idebug(12) .gt. 0 .and. MYRANK .eq. 0) then
                  if (idebug(12) .gt. 1)
     -              write (iout,7731) 'gbedif=',(gbenew(i),i=1,nstta)
                  write (iout,7731) 'gbuupd(n)=',
     -              (gbuupd(im),im=ngrdmn,ngrdmx)
                  if (ntang .gt. 0) write (iout,7731) 'gbuupt(n)=',
     -              (gbuupt(itg),itg=1,ntorgrp)
                end if
              end if
              if (movtyp .eq. 2) empfo=epmfn
              call trnsfr(cslto(1,ifagr),c(1,ifagr),
     -          3*(ilagr-ifagr+1))
              call trnsfr(orientsltm(1,1,molmov),orj,9)
            else if (ityptry .eq. 3) then
c             2-molecule move
              ettnb01(icopy,1)=ettnb01(icopy,1)+grsum1-
     -          gbuupd(molmov)+grsum2-gbuupd(molmovs)
              if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
c               Update the solute grid covering
                call movcovu(iout,cslto,c,ifagr,ilagr,ixislt,ianslt)
                call movcovu(iout,cslto,c,ifagrs,ilagrs,ixislt,ianslt)
              end if
              if (nsttm .gt. nstfm) then
                call esltsltg(cslto,molstf,nsttm,ifirstm,ilastm,
     -            ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbeold,gberold,
     -            0,istf,nstta,iclsltt,qslteps,molmov,molmovs,2,ddummy,
     -            nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0o,gsuml1o,
     -            igrcnt,molcnt,crmx,iop(5),iop(65),indexx,ivopt,riijjv,
     -            cgs,cutuus,iop(127))
                call dsum(gberold,ifirstm(molmov),ilastm(molmov),
     -            grsum1o)
                if (idebug(12) .gt. 0 .and. MYRANK .eq. 0) then
                  if (idebug(12) .gt. 1) then
                    write (iout,7731) 'gbeold=   ',(gbeold(i),i=1,nstta)
                    write (iout,7731) 'gbenew=   ',(gbenew(i),i=1,nstta)
                  end if
                  write (iout,7731) 'gbuupd(o)=',
     -              (gbuupd(im),im=ngrdmn,ngrdmx)
                  if (ntang .gt. 0) write (iout,7731) 'gbuupt(o)=',
     -              (gbuupt(itg),itg=1,ntorgrp)
                end if
c               Update here the group binding energies
                do ia=istf,nstta
                  gbenew(ia)=gbenew(ia)-gbeold(ia)
                end do
                call grpsum2(gbenew,imolpt,ifirstm,ilastm,ngrdmn,ngrdmx,
     -            iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,istf,nstta,
     -            beggd,beggt,grsum1o,grsum2o)
                do im=ngrdmn,ngrdmx
                  gbuupd(im)=gbuupd(im)+beggd(im)
                end do
              end if
                gbuupd(molmov)=grsum1
                gbuupd(molmovs)=grsum2
                if (ntang .gt. 0) then
                  do itg=1,ntorgrp
                    gbuupt(itg)=gbuupt(itg)+beggt(itg)
                  end do
c                 Update the torsion contribution from torsions on moving mols
                  do im=molmov,molmovs,(molmovs-molmov)
                    do itg=nmtmn(im),nmtmx(im)
                      do ia=iftorgrp(itg),iltorgrp(itg)
                         gbuupt(itg)=gbuupt(itg)+
     -                     gbernew(lsttorgrp(ia))-gberold(lsttorgrp(ia))
                      end do
                    end do
                  end do
                end if
c             end if
              if (idebug(12) .gt. 0 .and. MYRANK .eq. 0) then
                if (idebug(12) .gt. 1)
     -            write (iout,7731) 'gbedif=   ',(gbenew(i),i=1,nstta)
                write (iout,7731) 'gbuupd(n)=',
     -            (gbuupd(im),im=ngrdmn,ngrdmx)
                if (ntang .gt. 0) write (iout,7731) 'gbuupt(n)=',
     -            (gbuupt(itg),itg=1,ntorgrp)
              end if
              if (movtyp .eq. 2) empfo=epmfn
              call trnsfr(cslto(1,ifagr),c(1,ifagr),
     -          3*(ilagr-ifagr+1))
              call trnsfr(cslto(1,ifagrs),c(1,ifagrs),
     -          3*(ilagrs-ifagrs+1))
              if (idebug(32) .eq. 1 .and. movtyp .eq. 5 .and.
     -          MYRANK .eq. 0)
     -            write (iout,7742) etotn,etoto,(etotn-etoto)
            else if (ityptry .eq. 4) then
c             Torsion move
              if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
                call movcovu(iout,cslto,c,ifagr,ilagr,lsttorgrp,ianslt)
              end if
              einnb01(icopy,1)=einnb01(icopy,1)+(gsumselfn-gsumselfo)
              es1401(icopy,1)=es1401(icopy,1)+(gsum14n-gsum14o)
              eslttor01(icopy)=eslttor01(icopy)+torsensumn-torsensumo
C@dc      labcall='ACCO'
              call esltsltt(cslto,lsttorgrp,molstftt,nsttm,ifirstm,
     -          ilastm,ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,
     -          iftormovgrgr(itormov),iltorgrgr,iftormovgra,iltormovgra,
     -          iftorgrp(itormov),lasttoratmov,ilhbtorgrp(itormov),
     -          mapbitu,#UW,#ST,nbits,istf,nstta,iclsltt,qslteps,
     -          molmov,nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0o,gsuml1o,
     -          igrslt,igrcnt,molcnt,crmpmf,gbeold,gberold,gsumselfo,
     -          iop(5),iop(65),0,indexx,ivopt,riijjv,cgs,cutuus,
     -          iop(127),#TA,#TL)
C@dc      labcall='SLFT'
C@D4                call checkeijmol(4,nstta,iftorgrp(itormov),
C@D4     -            lasttoratmov,lsttorgrp)
C@D4                call checkeijmol(3,nstta,iftorgrp(itormov),
C@D4     -            lasttoratmov,lsttorgrp)
c             Update here the group binding energies
              if (idebug(12) .gt. 0 .and. MYRANK .eq. 0) then
                if (idebug(12) .gt. 1) then
                  write (iout,7731) 'gbeold=   ',(gbeold(i),i=1,nstta)
                  write (iout,7731) 'gbenew=   ',(gbenew(i),i=1,nstta)
                end if
                write (iout,7731) 'gbuupd(o)=',
     -            (gbuupd(im),im=ngrdmn,ngrdmx)
                if (ntang .gt. 0) write (iout,7731) 'gbuupt(o)=',
     -              (gbuupt(itg),itg=1,ntorgrp)
              end if
c             Update the intermolecular contributions
              do ia=istf,nstta
                gbenew(ia)=gbenew(ia)-gbeold(ia)
              end do
              call grpsum(gbenew,imolpd,imolpt,ifirstm,ilastm,
     -          ngrdmn,ngrdmx,iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,
     -          istf,nstta,beggd,beggt,beg)
              if (imolpd .gt. 0) then
c               Update molecule-molecule energy terms
                do im=ngrdmn,ngrdmx
                  gbuupd(im)=gbuupd(im)+beggd(im)
                end do
                gbuupd(molmov)=gbuupd(molmov)+
     -            gbeg-gbuupt(itormov)
              end if
              do itg=1,ntorgrp
                gbuupt(itg)=gbuupt(itg)+beggt(itg)
              end do
              do itg=nmtmn(molmov),nmtmx(molmov)
                if (itg .ne. itormov) then
                  do ia=iftorgrp(itg),iltorgrp(itg)
                    gbuupt(itg)=gbuupt(itg)+
     -                gbernew(lsttorgrp(ia))-gberold(lsttorgrp(ia))
                  end do
                end if
              end do
              gbuupt(itormov)=gbeg
              if (idebug(12) .gt. 0 .and. MYRANK .eq. 0) then
                if (idebug(12) .gt. 1) then
                  write (iout,7731) 'gbedif=   ',(gbenew(i),i=1,nstta)
                  write (iout,7731) 'gbernew=  ',(gbernew(i),i=1,nstta)
                end if
                write (iout,7731) 'gbuupd(n)=',
     -            (gbuupd(im),im=ngrdmn,ngrdmx)
                write (iout,7731) 'gbuupt(n)=',
     -            (gbuupt(itg),itg=1,ntorgrp)
              end if
              do icoptor=ncoptorfact,ncoptoract
                do ia=ifagr,ilagr
                  do k=1,3
                    cslto(k,lsttorgrp(ia)+(icoptor-1)*nstfa0)=
     -                c(k,lsttorgrp(ia)+(icoptor-1)*nstfa0)
                  end do
                end do
              end do
              em14(molmov)=em14(molmov)+(gsum14n-gsum14o)
              eintranb(molmov)=eintranb(molmov)+(gsumselfn-gsumselfo)
              einnbo=einnbn
              es14o=es14n
              eslttoro=eslttorn
              do it=ifdhgrlst(itormov),ildhgrlst(itormov)
                torsen(it)=torsennew(it)
                if (looptry(it) .ne. 0) then
                  loopmark='L'
                  nloopacc=nloopacc+1
                  do ntl=1,6
                    torsen(looplist(ntl,it))=torsennew(looplist(ntl,it))
                  end do
                end if
              end do
            else
c             Special move
            end if
            if (iop(91) .gt. 0) then
              if (ityptry .eq. 2 .or. ityptry .eq. 3) then
                em14(molmov)=em14(molmov)+e14corr
                eintranb(molmov)=eintranb(molmov)+einbcorr
                einnbo=einnbn
                es14o=es14n
                if (ityptry .eq. 3) then
                  em14(molmovs)=em14(molmovs)+e14corrs
                  eintranb(molmovs)=eintranb(molmovs)+einbcorrs
                end if
              end if
              if (loopmark .eq. 'L') numnearacc=numnearacc+nearpicked
            end if
            ettnbo=ettnbn
            if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
              do k=1,3
                ettnb01(1,k)=ettnb01(1,k)+(gsuml0n(k)-gsuml0o(k))
                ettnb01(2,k)=ettnb01(2,k)+(gsuml1n(k)-gsuml1o(k))
              end do
            end if
          end if
        else
c         Solvent moved - recalculate
          if (notrans .eq. 0) nracc(istep)=nracc(istep)+1
          call trnsfr(rsx,c(1,icsol1),natm3)
          call trnsfr(c(1,icsol1),cslvo,natm3)
          call trnsfr(crmj,crm(1,isolv),3)
          call trnsfr(crm(1,isolv),crmi,3)
          call engold(iop(21),iop(119),isolv,texslt,vrcslt,frcslt,
     -      trtslt,trvslt,c,crm)
c         Move the new values of c, crm back
          call trnsfr(c(1,icsol1),rsx,natm3)
          call trnsfr(crm(1,isolv),crmj,3)
          if (iop(82) .gt. 0) iopbst(isolv)=iopbso(isolv)
          if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
c           Cavity biased GCE with grid insertion
            call movcov(crmi,crmj,iout,c,crm,rsphs,rspvpe2,rspvme2)
          end if
C@FR          do k=1,3
C@FR            vsltsm(k)=vsltsm(k)+cplfac*(vrsltn(k,isolv)-vrcslt(k,isolv))
C@FR          end do
          call savsusvfull(isolv,nmolec,texslt,vrcslt,frcslt,
     -        trtslt,trvslt,tss12,tss6,tss1,tsind)
        end if
        if (iop(4)+iop(111) .gt. 0) call disper(iout)
        lstmvd(isolv)=nmc
c-------Update the binding energy / force components when molec isolv is moved
C@D1        if (movtyp .eq. 1 .or.
C@D1     -      (movtyp .eq. 2 .and. iop(18) .le. 2)) then
C@D1          call eijtst(eij,216,nmolec,isolv,texo,tesi,2)
C@D1          call eijtst(eij,216,nmolec,isolv,texn,tesi,1)
C@D1        end if
        cplfcd=dble(cplfac)
C@DM        if (iop(21) .ne. 3) then
        call updsum(tesi,texo,texn,nmolec,cplfac)
C@FR        call updsum(frctot,frco,frcn,nmol3,cplfac)
C@FR        call updsum(trqtot,trqo,trqn,nmol3,cplfac)
C@DM        else
C@DMc         Each processor should update its own segment
C@DM          do i=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM            tesi(i)=tesi(i)+dble(texn(i)-texo(i))*cplfcd
C@DMC@FR            do k=1,3
C@DMC@FR              frctot(k,i)=frctot(k,i)+dble(frcn(k,i)-frco(k,i))*cplfcd
C@DMC@FR              trqtot(k,i)=trqtot(k,i)+dble(trqn(k,i)-trqo(k,i))*cplfcd
C@DMC@FR            end do
C@DM          end do
C@DMc         Each processor should update the solute contribution
C@DM          tesi(1)=tesi(1)+dble(texn(1)-texo(1))*cplfcd
C@DMC@FR          do k=1,3
C@DMC@FR            frctot(k,1)=frctot(k,1)+dble(frcn(k,1)-frco(k,1))*cplfcd
C@DMC@FRC@TS            trqtot(k,1)=trqtot(k,1)+dble(trqn(k,1)-trqo(k,1))*cplfcd
C@DMC@FR          end do
C@DM        end if
        tesi(isolv)=tesiis
C@FR        do k=1,3
C@FR          frctot(k,isolv)=frci(k)
C@FR          trqtot(k,isolv)=trqi(k)
C@FR        end do
C@D1        if (movtyp .eq. 1 .or.
C@D1     -      (movtyp .eq. 2 .and. iop(18) .le. 2))
C@D1     -    call eijtst(eij,216,nmolec,isolv,texn,tesi,3)
        if (iop(67) .gt. 0) then
          efieldo=efieldo+efieldcha
          if (isolv .eq. 1) then
            if (movtyp .eq. 1 .or.
     -        (ityptry .eq. 2 .and. nsttm-nstfm1 .eq. 1) .or.
     -        (ityptry .eq. 3 .and. nsttm-nstfm1 .eq. 2)) then
              call trnsfr(esltfldo,esltfldn,nstta)
            else if (movtyp .eq. 2) then
              if (iop(18) .lt. 2) efieldmst(impmf1)=efieldimn1
              efieldmst(impmf2)=efieldimn
            else if (ityptry .eq. 2) then
              efieldmst(molmov)=efieldimn
              call trnsfr(esltfldo(ifirstm(molmov)),
     -          esltfldn(ifirstm(molmov)),
     -          ilastm(molmov)-ifirstm(molmov)+1)
            else if (ityptry  .eq. 3) then
              efieldmst(molmov)=efieldimn
              efieldmst(molmovs)=efieldimn1
              call trnsfr(esltfldo(ifirstm(molmov)),
     -          esltfldn(ifirstm(molmov)),
     -          ilastm(molmov)-ifirstm(molmov)+1)
              call trnsfr(esltfldo(ifirstm(molmovs)),
     -          esltfldn(ifirstm(molmovs)),
     -          ilastm(molmovs)-ifirstm(molmovs)+1)
              efieldstn0=efieldstn0+efieldcha1
            else if (ityptry  .eq. 4) then
              do it=iftorgrp(itormov),lasttoratmov
                esltfldo(lsttorgrp(it))=esltfldn(lsttorgrp(it))
              end do
              if (iop(57) .gt. 0)
     -          efieldmst(molmov)=efieldmst(molmov)+efieldcha
            end if
            efieldst0=efieldst0+efieldcha
          else
            efieldsv(isolv)=efieldismn
          end if
        end if
        if (iop(108) .gt. 0) esmolo=esmoln
        if (iop(92) .gt. 0) then
c         Primary hydration shell
          nphsouto=nphsout
          if (isolv .gt. 1) then
c           Solvent moved
            uphs(isolv)=ephsisn
            ipxo(isolv)=ipxn(isolv)
            rphs0iso(isolv)=rphs0isnn
            rphs0isn(isolv)=rphs0isnn
            if (risn .le. rphs .and. riso .gt. rphs) then
c             Remove isolv from the list (would be faster with reverse indexing)
              is=1
              do while (iphsout(is) .ne. isolv .and. is .le. nphsout)
                is=is+1
              end do
              if (is .le. nphsout) then
                iphsout(is)=iphsout(nphsout)
                nphsout=nphsout-1
              end if
            else if (riso .le. rphs .and. risn .gt. rphs) then
              nphsout=nphsout+1
              iphsout(nphsout)=isolv
            end if
          else
c           Solute part moved
            nphsout=nphsoutn
            call trnsfi(iphsout,iphsoutn,nphsoutn)
            call trnsfr(rphs0iso,rphs0isn,nmolec)
            call trnsfr(uphs,uphsn,nmolec)
          end if
c         Update distance grid
          do is=mvfst,nmolec
            if (rijpso(is) .gt. rphsmin) then
              ig=min0(maxphsgrid,int((rijpso(is)-rphsmin)/gphs+1))
              iphsdst(ig)=iphsdst(ig)+nrpt
            end if
          end do
          ephso=ephsn
          ephssum=ephssum+nrpt*ephso
          eephssum=eephssum+nrpt*ephso**2
          rphssum=rphssum+nrpt*rphs
          rrphssum=rrphssum+nrpt*rphs**2
          sumnphs=sumnphs+nrpt*nphsout
          sumnnphs=sumnnphs+nrpt*nphsout**2
          iupphs=0
          do imc=nmc-nrpt+1,nmc
            if (mod(imc,nmcphs) .eq. 0) iupphs=1
          end do
          if (iupphs .eq. 1) then
c           Update rphs - iphsdst has the distribution since step nmcphslast
            ig0=min0(maxphsgrid,int((rphs-rphsmin)/gphs)+1)
            sumni=0.0
            sumnri=0.0
            ephslimsum=0.d0
            igphsmax=ig0
            if (iop(93) .eq. 2) igphslim=min0(maxphsgrid,ig0+igphswid)
            do ig=ig0,igphslim
              if (iphsdst(ig) .gt. 0) then
                fphssum=fphssum+iphsdst(ig)*phsk*(rphsdst(ig)-rphs)
                ephslimsum=ephslimsum+
     -            iphsdst(ig)*phsk*(rphsdst(ig)-rphs)**2
                sumni=sumni+iphsdst(ig)
                sumnri=sumnri+iphsdst(ig)*(rphsdst(ig)-rphs)
                igphsmax=ig
              end if
            end do
            if (sumni .eq. 0.0) then
c             Shell is empty - reduce radius
              delta=-0.001*rphsn
            else
              aphs=sumni
              bphs=-2.0*sumnri
              ephsav=(ephssum-ephssumlast)/(nmc-nmcphslast)
              if (iop(93) .eq. 0) then
                uphsrf=uphsref
              else if (iop(93) .eq. 1) then
                uphsrf=uphsref*(sumnphs-sumnphslast)/(nmc-nmcphslast)
              else
                uphsrf=uphsref*sumni/(nmc-nmcphslast)
                ephsav=ephslimsum/(nmc-nmcphslast)
              end if
              cphs=(ephsav-uphsrf)*(nmc-nmcphslast)/phsk
              discr=bphs**2-4.0*aphs*cphs
              if (discr .ge. 0.0) then
                discr=sqrt(discr)
                delta1=(-bphs-discr)/(2.0*aphs)
                delta2=(-bphs+discr)/(2.0*aphs)
                if (abs(delta1) .lt. abs(delta2)) then
                  delta=delta1
                else
                  delta=delta2
                end if
                rphsn=amax1(rphsmin,rphs+delta)
                ig1=(rphsn-rphsmin)/gphs+1
                if (ig1 .ne. ig0) then
c                 Grid range changed - scale down the change
                  deltan=delta/2.0
                  rphsn=rphs+deltan
                end if
              else
c               Radius is way off, just change by 0.5 A
                if (cphs .lt. 0.0) rphsn=amax1(rphsmin,rphs-0.5)
                if (cphs .ge. 0.0) rphsn=amin1(rphsmax,rphs+0.5)
              end if
              if (rphsn .lt. rphsmin .or. rphsn .gt. rphsmax) then
C@DM                if (MYRANK .eq. 0) then
                write (iout,2030) rphsn,rphsmin,rphsmax
                if (ichkpx .gt. 0) call csavepx(ichkpx,1,inperr,6)
C@DM                end if
                call csave(ichkp,1,inperr,1)
                call datprt(2)
              end if
            end if
            rphso=rphs
            rphs=rphsn
            if (idebug(82) .gt. 0) then
              ephsigo=0.d0
              ephsign=0.d0
              do ig=ig0,maxphsgrid
                ephsigo=ephsigo+iphsdst(ig)*(rphsdst(ig)-rphso)**2
                ephsign=ephsign+iphsdst(ig)*(rphsdst(ig)-rphsn)**2
              end do
              ephsigo=phsk*ephsigo/(nmc-nmcphslast)
              ephsign=phsk*ephsign/(nmc-nmcphslast)
            end if
c           Reinitialize
            ephssumlast=ephssum
            sumnphslast=sumnphs
            call initphs(mvfst,nmolec,nmc,ephsn,rijpso,rijmax)
            etotn=etotn+ephsn-ephso
            if (idebug(82) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,7560) nmc,nphsouto,
     -          nphsout,rphso,rphsn,ephso,ephsn,ephsigo,ephsign,ephsav
            ephso=ephsn
            do i=1,nphsout
              usphsout=usphsout+tesi(iphsout(i))
              ussphsout=ussphsout+tesi(iphsout(i))-texslt(iphsout(i))
            end do
            rnphsout=rnphsout+nphsout
          end if
        end if
        etoto=etotn
        if (iop(117) .gt. 0) econstro=econstrn
C@FR        do k=1,3
C@FR          virial(k)=virial(k)+cplfac*(virscn(k)-virsco(k))
C@FR        end do
        if (movtyp .eq. 1) then
c         Save the new rotation matrix
          call trnsfr(orient(1,1,isolv),orj(1,1),9)
          if (iop(12) .gt. 3) then
c           Update move pref. sampl. weigth(s) and their sum
            if (isolv .eq. 1) then
              call iniprf(mvfst,nmolec,wpsmvn,nslvds,wpsmv,wpsmvsum,
     -          wpfpsmv,wpsmvnmax,limpsmv,npfsmv,0)
            else
              call pfpsumup(wpsmvnew,isolv,wpsmv,wpfpsmv,wpsmvsum,
     -          ipsmv,npfsmv)
            end if
          end if
          if (iop(63) .gt. 0) then
c           Update i/d pref. sampl. weigth(s) and their sum
            if (isolv .eq. 1) then
              call iniprf(mvfst,nmolec,wpsidn,nslvdsid,wpsid,wpsidsum,
     -          wpfpsid,wpsidnmax,limpsid,npfsid,iop(79))
            else
              wpsidnew=prfwgt(nslvdsid(isolv),wpsidn,iop(79))
              call pfpsumup(wpsidnew,isolv,wpsid,wpfpsid,wpsidsum,
     -          ipsid,npfsid)
            end if
          end if
        end if
        if (isolv .eq. 1) then
C@D1          if (movtyp .eq. 1 .or.
C@D1     -        (movtyp .eq. 2 .and. iop(18) .le. 2))
C@D1     -      call eijtst(eij,216,nmolec,isolv,texslt,tesi,1)
          estsco=estscn
C@FR          do k=1,3
C@FR            vsltsm(k)=vsltsm(k)+cplfac*(virscn(k)-virsco(k))
C@FR          end do
        else
          if (rcomiso(isolv) .lt. rinscs) estsco=estsco-texo(1)
          if (rijnis .lt. rinscs) estsco=estsco+texn(1)
          rcomiso(isolv)=rijnis
c         Translate starting position and last update position
c         if the molec went out of the box
C@NN          do k=1,3
C@NN            clstup(k,isolv)=clstup(k,isolv)+cd(k)
C@NN          end do
          do k=1,3
            crm0(k,isolv)=crm0(k,isolv)+cd(k)
          end do
          avstp=avstp+sqrt(chsq)
          avrot=avrot+phiabs
c---------Compute the angle between successive moves of molecule isolv
          if (notrans .eq. 0) then
            roo=0.0
            ron=0.0
            do k=1,3
              roo=roo+delc(k,isolv)**2
              ron=ron+delc(k,isolv)*deln(k)
            end do
            if (roo .gt. 0.0 .and. rnn .gt. 0.0) then
              if (iop(6) .eq. 2) then
                istep=1
              else
                roo=sqrt(roo)
                ncorav=ncorav+1
                corris=ron/(roo*rnn)
                corrav=corrav+corris
c               Collect statistics for step-correlation vs stepsize
                if (iop(6) .eq. 3) then
                  istep=50.0*roo/(cedslv+0.0001)+1
                else
                  istep=50.0*roo/((cedslv/2.0)*sqrt(3.0)+0.0001)+1
                end if
              end if
              nrcorr(istep)=nrcorr(istep)+1
              drcorr(istep)=drcorr(istep)+corris
            end if
c           deln: accepted solvent displacement
c           delc(3,is): last accepted displacement of molec is.
            call trnsfr(delc(1,isolv),deln,3)
          end if
c---------Update in/out status
          if (iop(80) .gt. 0) then
            nmolinout(molinout(isolv))=nmolinout(molinout(isolv))-1
            call solvinout(molinout(isolv),crm(1,isolv),edgelinxyz,
     -        edgerinxyz)
            nmolinout(molinout(isolv))=nmolinout(molinout(isolv))+1
          end if
          if (iop(79) .gt. 0) then
            ioold=molinoutgr(isolv)
            nmolinoutgr(molinoutgr(isolv))=
     -        nmolinoutgr(molinoutgr(isolv))-1
            call solvinout(molinoutgr(isolv),crm(1,isolv),edgelgr,
     -        edgergr)
            nmolinoutgr(molinoutgr(isolv))=
     -        nmolinoutgr(molinoutgr(isolv))+1
            if (iop(79) .eq. 2) then
              ionew=molinoutgr(isolv)
              if (ionew .gt. ioold) then
                ncrossout=ncrossout+1
                if (ncrossout .le. 10 .and. MYRANK .eq. 0)
     -            write (iout,2027) isolv,'out of'
              else if (ionew .lt. ioold) then
                ncrossin=ncrossin+1
                if (ncrossin .le. 10 .and. MYRANK .eq. 0)
     -           write (iout,2027) isolv,'into'
              end if
            end if
          end if
        end if
        if (kut .gt. 0) nftcta=nftcta+1
        if ((iop(9) .eq. 1 .or. iop(9) .eq. 2) .and. MYRANK .eq. 0) then
          call savcnfh(ihist,iout,0,0,0,1,c,crmgs,filenames(3),
     -      namlens(3),numrecprev(3),numrec(3),numframe,uusfac,
     -      #NA,#UV)
        end if
        nrpt=1
c-------Calculation of thermodynamic properties
609     call accumulate(uusfac,loopmark)
        ucsmmv=ucsmmv+uusfac
        if (iop(43) .gt. 0) then
c         Accumulate solute group energies
          do ig=1,nsttg
            estgrs(ig)=estgrs(ig)+estgr(ig)*uuscor*uwnb*uwcplo*nrpt
          end do
        end if
        if (iop(30) .gt. 3) then
c         Free energy calculations
          if (iop(30) .eq. 7) then
c           Update probability ratio US accumulators (iop(30) = 7).
c           uusfac is the combined US weight (from PMF and scaled el.stat)
            uwtav=uwtav+uusfac
            igr=(cplpar-d0cpl)/g0cpl
            if (igr .lt. 1) igr=1
            if (igr .gt. #WG) igr=#WG
            dstcpl(igr)=dstcpl(igr)+uusfac
            nfisum(igr)=nfisum(igr)+1
            upmftot(igr)=upmftot(igr)+etoto*uusfac
            upmftv(igr)=upmftv(igr)+tesi(1)*uusfac
            upmftt(igr)=upmftt(igr)+
     -        (ettnbo+einnbo+es14o+eslttoro)*uusfac
c           write (iout,8791) nmc,igr,ettnbo,einnbo,es14o,eslttoro,
c    -        uusfac,upmftt(igr)
c8791 format(' nmc=',i6,' igr=',i3,' ettnbo,einnbo,es14o,eslttoro=',
c    -        4f12.3,' UUSFAC,umftt=',2e12.5)
          else
c           Coulomb term umbrella sampling correction (iop(53)=3)
c           is allowed only for iop(30)=0 (???)
c           Accumulate free energy calculation sums (iop(30)=5,6 or 8)
            dele=e1o-e0o+(einnb01(2,1)-einnb01(1,1))
c           Update min and max for (e1-e0)
            if (dele .le. de01mn) then
              de01mn=dele
              nm01mn=nmc
            else if (dele .ge. de01mx) then
              de01mx=dele
              nm01mx=nmc
            end if
            ue1=ue1+e1o
            ue0=ue0+e0o
            ue0ind(1)=ue0ind(1)+e0o12
            ue0ind(2)=ue0ind(2)-e0o6
            ue0ind(3)=ue0ind(3)+e0o1
            ue1ind(1)=ue1ind(1)+e1o12
            ue1ind(2)=ue1ind(2)-e1o6
            ue1ind(3)=ue1ind(3)+e1o1
            do k=1,3
              ue0ttnb(k)=ue0ttnb(k)+ettnb01(1,k)
              ue1ttnb(k)=ue1ttnb(k)+ettnb01(2,k)
              ue0innb(k)=ue0innb(k)+einnb01(1,k)
              ue1innb(k)=ue1innb(k)+einnb01(2,k)
            end do
            ue0t14(1)=ue0t14(1)+es1401(1,1)
            ue1t14(1)=ue1t14(1)+es1401(2,1)
            ue0tor(1)=ue0tor(1)+eslttor01(1)
            ue1tor(1)=ue1tor(1)+eslttor01(2)
            if (iop(30) .eq. 6) then
c             Accumulate exp(e(uspar1)-e(cplpar)) and exp(e(uspar0)-e(cplpar))
c             at cplpar and e(uspar0), e(uspar1) at uspar0, uspar1, resp,
c             with half US.
              deleb=(dele-delest)*beta
              wschk=exp(amin1(expmax,-deleb*(uspar0-cplpar)))
              uus0=uus0+(e0o*uspr01+e1o*uspar0)*wschk
              uws0=uws0+wschk
              wschk=exp(amin1(expmax,-deleb*(uspar1-cplpar)))
              uus1=uus1+(e0o*uspr11+e1o*uspar1)*wschk
              uws1=uws1+wschk
            else if (iop(30) .eq. 8) then
c             Overlap ratio and perturbation method with explicite middle state
              dele0=tesi(1)-e0o-del0st
              dele1=e1o-tesi(1)-del1st
              if (dele0 .lt. -edifmx) dele0=edifmx
              if (dele1 .lt. -edifmx) dele1=edifmx
c             Accumulate the exponential sums:
              wschk0=exp(-dele0*beta)
              wschk1=exp(-dele1*beta)
              uws0=uws0+wschk0
              uws1=uws1+wschk1
c             Accumulate the us sums for &- and for &+ averages
              uus0=uus0+e0o*wschk0
              uus1=uus1+e1o*wschk1
c             Accumulate the energy distributions for overlap ratio calculations
              ig0=(dele0-gmor0k)/gdvork+1
              if (ig0 .lt. 1) ig0=1
              if (ig0 .gt. #OR) ig0=#OR
              norde0(ig0)=norde0(ig0)+1
              ig1=(dele1-gmor1k)/gdvork+1
              if (ig1 .lt. 1) ig1=1
              if (ig1 .gt. #OR) ig1=#OR
              norde1(ig1)=norde1(ig1)+1
            end if
          end if
        end if
c       Accumulate force and torque component squares for quantum correction
C@FR        if (isolv .eq. 1) then
C@FR          nsslt=nsslt+1
C@FR          do k=1,3
C@FR            fsmslt=fsmslt+frctot(k,isolv)**2
C@FR            tsmslt(k)=tsmslt(k)+trqtot(k,isolv)**2
C@FR          end do
C@FR        else
C@FR          do k=1,3
C@FR            fsmslv=fsmslv+frctot(k,isolv)**2/wpsmvnew
C@FR            tsmslv(k)=tsmslv(k)+trqtot(k,isolv)**2/wpsmvnew
C@FR          end do
C@FR          wpsmvi=wpsmvi+1.0/wpsmvnew
C@FR        end if
        mplt=mod(nmc,nplt)
        if ((mod(nmc,nmcrep) .eq. 0  .or. mplt .eq. 0 .or.
     -      iii .eq. nmcmax) .and. MYRANK .eq. 0) then
c---------Print periodic report
          u=usum/(ucsmid+ucsmvv+ucsmmv)
c         u, uuav: average total energy and energy square in kcal/mol
c         sd2: standard deviation of the total energy (in kcal/mol)
          uuav=uusum/(ucsmid+ucsmvv+ucsmmv)
          sd2=uuav-u*u
          us=uslt/(ucsmid+ucsmvv+ucsmmv)
c         u, uuav: average total energy and energy square in kcal/mol
          if (movtyp .eq. 1) then
            if (isolv . gt. 1) then
              acc=float(nmovacc-nmvd(1))/float(nmovtry-npckd(1))
            else
              acc=float(nmvd(1))/float(npckd(1))
            end if
          else if (movtyp .eq. 2) then
            acc=float(npmfacc)/float(npmftry)
          else if (movtyp .eq. 3) then
            acc=float(npdstacc(molmov))/float(npdsttry(molmov))
          else if (movtyp .eq. 4) then
            it=ifdhgrlst(itormov)
            call origtor(it,itorig,iop(69),itn)
            if (loopmark .eq. 'L') then
              acc=float(nptloopacc(itn))/float(nptlooptry(itn))
            else
              acc=float(nptstacc(itn))/float(nptsttry(itn))
            end if
          else if (movtyp .eq. 5) then
            acc=float(nswapacc)/float(nswaptry)
          else if (movtyp .eq. 6) then
            acc=float(nmv2sacc)/float(nmv2stry)
          else
            acc=float(nspsltacc)/float(nspslttry)
          end if
          cv=sd2*1000.0/(rnsum/(ucsmid+ucsmmv+ucsmvv)+nsttm)/
     -      (boltz*temp**2)
          eunit='K'
          nmn=nmin
          nmx=nmax
          if (nmc .ge. 10000000) then
            eunit='M'
            nmn=nmin/1000
            nmx=nmax/1000
          end if
          mtn=movtypn(movtyp)
          if (movtyp .eq. 1 .or. movtyp .eq. 3) then
            if (notrans .eq. 1) mtn(3:3)=lxyz(iaxis)
            if (norot .eq. 1) mtn(3:3)='D'
          end if
          if (loopmark .eq. 'L') mtn='LPT'
          if (movtyp .eq. 1) isolvp=isolvp-1
          if (u .ge. 1.d+7 .or. abs(emin) .ge. 1e+6 .or.
     -      emax .ge. 1.e+6 .or. us .ge. 1.d+6 .or.
     -      -us .ge. 1.d+5) then
            write (linepr,2001) nmc,etotn,u,emin,nmn,
     -        eunit,emax,nmx,eunit,us,acc,isolvp,mtn,accrej(iaccrej)
          else
            write (linepr,2000) nmc,etotn,u,emin,nmn,
     -        eunit,emax,nmx,eunit,us,acc,isolvp,mtn,accrej(iaccrej)
          end if
c         if (linepr(32:32) .eq. '*') write (linepr(32:41),1004) u
c         if (linepr(47:47) .eq. '*') write (linepr(47:55),1005) emin
c         if (linepr(69:69) .eq. '*') write (linepr(69:77),1005) emax
c         if (linepr(90:90) .eq. '*') write (linepr(90:98),1005) us
          if (movtyp .eq. 4) then
            linepr(119:121)='t='
            write (linepr(122:125),1001) itormov
            linepr(126:127)=accrej(iaccrej)
            if (loopmark .eq. 'L')
     -        write (linepr(117:117),1002) looptyp(itormov)
            if (iop(69) .gt. 0) then
              it=iabs(itorig(ifdhgrlst(itormov)))
              write (linepr(127:130),1001) it
              linepr(131:132)=accrej(iaccrej)
            end if
          end if
          if (movtyp .eq. 5) then
            linepr(119:121)='m2='
            write (linepr(123:126),1001) molmovs
            linepr(127:128)=accrej(iaccrej)
          end if
          if (nmc .lt. 10000000) linepr(2:3)='N='
          write (iout,1000) linepr
          if (iop(53) .gt. 0) then
            xxx1=ucsmmv/float(nmc)
            xxx2=0.
            if (nidmc .ne. 0) xxx2=ucsmid/float(nidmc)
            write (iout,2008) uusfac,xxx1,xxx2
          end if
c         Solute energy contributions by terms
          usind12=tscum(1)/(ucsmid+ucsmmv)
          usind6=tscum(2)/(ucsmid+ucsmmv)
          usind1=tscum(3)/(ucsmid+ucsmmv)
          nsttmin=0
          if (iop(30) .gt. 0 .and. iop(30) .le. 3) nsttmin=nstfa
          if ((iop(30) .le. 3 .or. iop(30) .eq. 7) .and. iop(24) .gt. 0
     -      .and. numsolv .gt. 0 .and. nstta .gt. nsttmin)
     -      write (iout,2017) usind12,usind6,usind1
          if (iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4) then
            usg=uttnb/(ucsmid+ucsmmv)
            uin=uinnb/(ucsmid+ucsmmv)
            us14=uslt14/(ucsmid+ucsmmv)
            ustor=uslttor/(ucsmid+ucsmmv)
            esg=ettnbo
            es14=es14o
            estor=eslttoro
            if (uin .ge. 1.e+6 .or. -uin .ge. 1.e+5 .or.
     -          usg .ge. 1.e+6 .or. -usg .ge. 1.e+5 .or.
     -          us14 .ge. 1.e+6 .or. -us14 .ge. 1.e+5 .or.
     -          ustor .ge. 1.e+6 .or. -ustor .ge. 1.e+5) then
              write (linepr,2045) esg,usg,einnbo,uin,es14,us14,estor,
     -          ustor
            else
              write (linepr,2009) esg,usg,einnbo,uin,es14,us14,estor,
     -          ustor
            end if
c           if (linepr(57:57) .eq. '*') write (linepr(57:66),1004) uin
c           if (linepr(24:24) .eq. '*') write (linepr(24:33),1004) usg
c           if (linepr(88:88) .eq. '*') write (linepr(88:97),1004) us14
c           if (linepr(121:121) .eq. '*')
c    -         write (linepr(121:130),1004) ustor
            write (iout,1000) linepr
          end if
          if (iop(92) .gt. 0) then
            rphsav=(rphssum+(nrpt-1)*rphs)/nmc
            ephsav=(ephssum+(nrpt-1)*ephso)/nmc
            fphsav=fphssum/nmc
            avnphsout=(sumnphs+(nrpt-1)*nphsout)/nmc
            ephspm=0.0
            if (avnphsout .gt. 0.0) ephspm=ephsav/avnphsout
            write (iout,2029) rphs,rphsav,ephso,
     -        ephsav,ephspm,fphsav,nphsout,avnphsout,rphsdst(igphsmax)
          end if
          if (iop(30) .gt. 3) then
c           Free energy calculations, no Coulomb us is allowed
            x=float(nidmc+nvchmc+nmc)
            if (iop(30) .le. 6 .or. iop(30) .eq. 8) then
              if (iop(1) .eq. 0) then
                write (iout,2006) 'solvent',ue0ind(1)/x,ue0ind(2)/x,
     -            ue0ind(3)/x,ue1ind(1)/x,ue1ind(2)/x,ue1ind(3)/x
                if (nsttm .gt. nstfm)
     -            write (iout,2006) 'solute ',ue0ttnb(1)/x,ue0ttnb(2)/x,
     -            ue0ttnb(3)/x,ue1ttnb(1)/x,ue1ttnb(2)/x,ue1ttnb(3)/x
              end if
            end if
            if (iop(30) .eq. 7) then
c             Umbrella sampling for pmf calcs
              write (iout,2011)
     -          nmc,cplpar,cplprn,cplimn,cplimx,1.d0/uwcplo,1.d0/uwcpln
            else
c             Two-state free energy calculations
              ae0=ue0/x
              ae1=ue1/x
              ade=ae1-ae0
              write (iout,2010) e0o,e1o,ae0,ae1,usind12,usind6,usind1
            end if
          end if
          if (iop(86) .gt. 0) then
c           Print all acceptance rates
            acc1s=0.0
            acc1i=0.0
            acc2=0.0
            acc3=0.0
            acc4t=0.0
            acc4l=0.0
            acc5=0.0
            acc6=0.0
            acc7=0.0
            if ((nmovtry-npckd(1)) .ne. 0)
     -        acc1s=float(nmovacc-nmvd(1))/float(nmovtry-npckd(1))
            if (npckd(1) .ne. 0)
     -        acc1i=float(nmvd(1))/float(npckd(1))
            if (npmftry .ne. 0)
     -        acc2=float(npmfacc)/float(npmftry)
            if (npdslttry .ne. 0)
     -        acc3=float(npdsltacc)/float(npdslttry)
            if (nptslttry .ne. 0)
     -        acc4t=float(nptsltacc)/float(nptslttry)
            if (nloopmtry .ne. 0)
     -        acc4l=float(nloopacc)/float(nloopmtry)
            if (nmv2stry .ne. 0)
     -        acc6=float(nmv2sacc)/float(nmv2stry)
            if (nswaptry .ne. 0)
     -        acc5=float(nswapacc)/float(nswaptry)
            if (nspslttry .ne. 0)
     -        acc7=float(nspsltacc)/float(nspslttry)
            write (iout,2020) movtypn(1),acc1s,acc1i,
     -        movtypn(2),acc2,movtypn(3),acc3,movtypn(4),acc4t,'LPT',
     -        acc4l,movtypn(5),acc5,movtypn(6),acc6,movtypn(7),acc7
          end if
          if (idebug(40) .gt. 0) then
            if (movtyp .eq. 3) then
              write (iout,7770) accsumtrans(molmov),
     -          (accsumrot(k,molmov),k=1,3),
     -          (stepsumtrans(k,molmov),k=1,3),
     -          (stepsumrot(k,molmov),k=1,3)
            else if (movtyp .eq. 4) then
              itormv=ifdhgrlst(itormov)
              if (loopmark .eq. 'L') then
                write (iout,7771) 'loop',accsumloop(itormv),
     -            stepsumloop(itormv),stepsumloopcumu(itormv)
              else
                write (iout,7771) 'tors',accsumtor(itormv),
     -            stepsumtor(itormv),stepsumtorcumu(itormv)
              end if
            end if
          end if
        end if
        if (iop(51) .ge. 1) then
          if (mod(nmc,nmcadp) .eq. 0) call wadapt(ratmax,smplmx,
     -      faclim,fcenc1,fcenc2,encexp,rldvmx,ngrcor,iopnrm,
     -      iop(55),nitssk,iop(16),nwtst,iopeql,iopenc,negitdel,iop(24),
     -      nsubmn,ngovmn,diffmx,iout,ichkp,nwarn,nwwarn,cplpar,cplimn,
     -      cplimx,beta,0,nmc,MYRANK)
          if (nmc .ne. nmcmax) then
            call checkdim(ifail,iout,inperr,'WI',iterw+1,0,0,0)
            if (ifail .eq. 1) then
              nxxx=nmc
              call disfin(nxxx,c,orient,crm,orientsltm,crm0)
              call datprt(-1)
            end if
          end if
        end if
        if (idebug(76) .gt. 0 .and. iop(91) .gt. 0
     -      .and. mtn .eq. 'LPT') then
c         Check new torsion generation constants
          call regenerate(c,molmov,2,iout,nerr0,devmax)
        end if
c-------Insert/delete attempt
        if (iop(41) .gt. 0) then
          ndistr(nmolec)=ndistr(nmolec)+1
          if (idebug(51) .gt. 0)
     -      call selftest(iop(13),iop(94),nfail,1,0,0)
          if (nmcransh .gt. 0) then
            if (mod(nmc,nmcransh) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2018)
              call mmc_random(3,ranshift)
              call initgrid(nmolec,1.0,diamslv/2.0,1,vsltgrx,vol,
     -          c,crm,nmc,0,0,' ',iop(24)-1,0)
              if (iop(63) .gt. 0) then
c               I/D weights of grid points
                call iniprflim(1,ngfree,ipsgd,#PP,'PP',limpsgd,
     -            npfsgd,iout,inperr)
c               Calculate integer distances for new grids
                do ig=1,ngfree
                  indx=igfree(ig)
                  call unpackijk(indx,ng1,ic,jc,kc)
                  rgd(1)=e2gm(1)+ic*grid(1)
                  rgd(2)=e2gm(2)+jc*grid(2)
                  rgd(3)=e2gm(3)+kc*grid(3)
c                 Obtain integer distance of this grid from PS center
                  igfn(ig)=intgpsdis(iop(8),rgd,wpfidcen,rri,c,crm)
                end do
                call iniprf(1,ngfree,wpsidn,igfn,wpsgd,wpsgdsum,
     -            wpfpsgd,wpsidnmax,limpsgd,npfsgd,iop(79))
              end if
              if (iop(79) .gt. 0) then
c               Grid shifted - update in/out status
                do im=idsvfst,nmolec
                  call solvinout(molinoutgr(im),crm(1,im),edgelgr,
     -              edgergr)
                end do
              end if
            end if
          end if
          if (mod(nmc,idfreq) .eq. 0) then
            call indlgr(uusfac,indel,isid,iaccid,istop)
            if (istop .eq. 1) iii=nmcmax
C@DM            if (iaccid .eq. 1) then
C@DM              indlgrix(1)=indel
C@DM              indlgrix(2)=isid
C@DM              indlgrix(3)=ngfree
C@DM              indlgrix(4)=iflslv(2,NUMNOD)
C@DM              call MPI_Allreduce(indlgrix,indlgrixsum,4,MPI_INTEGER,
C@DM     -          MPI_SUM,MPI_COMM_WORLD,ierr)
C@DM              if ((indlgrixsum(1) .ne. NUMNOD .and.
C@DM     -             indlgrixsum(1) .ne. -NUMNOD) .or.
C@DM     -             indlgrixsum(2) .ne. NUMNOD*indlgrix(2) .or.
C@DM     -             indlgrixsum(3) .ne. NUMNOD*indlgrix(3) .or.
C@DM     -             indlgrixsum(4) .ne. NUMNOD*indlgrix(4)) then
C@DM                write (iout,2037) MYRANK,indlgrix,indlgrixsum
C@DM                call datprt(2)
C@DM              end if
C@DM              if (iflslv(2,NUMNOD) .gt. nmolec) then
C@DM                if (iflslv(2,NUMNOD) .ge. iflslv(1,NUMNOD)) then
C@DM                  write (iout,2042) MYRANK,iflslv(2,NUMNOD),nmolec
C@DM                  call datprt(2)
C@DM                end if
C@DM              end if
C@DM            end if
            ucsmid=ucsmid+uusfac
            nmolecdo=nmolec
          end if
c         Tuning update (of B)
          if (iop(76) .eq. 1 .or. iop(76) .eq. 2) then
c           Adaptive tuning
c           Tuning based on fluctuations
            if (nmc-nmclastch .eq. nmctunskip) then
c             Skip this part
              rnsumprev(1)=suminout(1)
              rnsumprev(2)=suminout(2)
              nmccorprev=nmc+nidmc
            else if (nmc-nmclastch .eq. nmctunskip+nmctunave) then
              ntune=ntune+1
              rnavi=(suminout(inorout)-rnsumprev(inorout))/
     -          (nmc+nidmc-nmccorprev)
              bacha=0.0
              nocha=0
              iconv=0
              if (iop(76) .eq. 1) then
                if (ntune .gt. 1) then
                  delrn=rnavi-rnaviprev
                  delb=ba-baprev
                  if (delb*delrn .gt. -0.001) then
c                   Change is not unphysical change - use info for update B
                    if (abs(rnavi-targetn) .gt. toln) then
                      if (abs(delb) .gt. 0.1) then
                        delndelbsum=delndelbsum+delrn/delb
                        ndelndelbsum=ndelndelbsum+1
                      end if
                      nitconv=0
                    else
                      iconv=1
                      nocha=0
                      nitconv=nitconv+1
                    end if
                  else
                    nunphys=nunphys+1
                    nocha=1
                  end if
                end if
                delndelb=(delndelb0+delndelbsum)/(ndelndelbsum+1)
                iunphys=nunphys
                if (nocha .eq. 0 .or. nunphys .gt. 2) then
                  nunphys=0
                  bacha=(targetn-rnavi)/delndelb
                  if (bacha .lt. -chabmax) bacha=-chabmax
                  if (bacha .gt. chabmax) bacha=chabmax
                  baprev=ba
                  rnaviprev=rnavi
                  ba=ba+bacha
                end if
                if (nunphys .gt. 0) write (iout,2024) 'no change in B'
                if (nunphys .eq. 0 .and. iunphys .gt. 0 .and.
     -            MYRANK .eq. 0) write (iout,2024) 'B is changed ayway'
                if (idebug(40) .gt. 0) write (iout,7750)
     -            bacha,delrn,delb,delndelb,delndelb0
              else
c               Tuning based on fluctuations
                if (abs(rnavi-targetn) .le. toln) then
                  iconv=1
                  nitconv=nitconv+1
                else
                  delrn=rnavi-rnaviprev
                  uavcor=ucsmmv+ucsmid+ucsmvv
                  fluct=rnnsum/uavcor-(rnsum/uavcor)**2
                  fracout=suminout(inorout)/(suminout(1)+suminout(2))
                  delndelb1=fluct*sqrt(fracout)
                  delndelb=(delndelb0+ntune*delndelb1)/(ntune+1)
                  bacha=(targetn-rnavi)/delndelb
                  if (bacha .lt. -chabmax) bacha=-chabmax
                  if (bacha .gt. chabmax) bacha=chabmax
                  baprev=ba
                  rnaviprev=rnavi
                  ba=ba+bacha
                  if (idebug(40) .gt. 0) write (iout,7751) bacha,
     -              delndelb,delndelb0,delndelb1,fluct,fracout,uavcor,
     -              rnsum/uavcor,inout(inorout)
                  nitconv=0
                end if
              end if
C@DM          if (MYRANK .eq. 0) then
              write (iout,2019) ntune,ba,rnavi,targetn
              if (iconv .gt. 0) write (iout,2025) nitconv
C@DM          end if
              rnsumprev(1)=suminout(1)
              rnsumprev(2)=suminout(2)
              nmccorprev=nmc+nidmc
              nmclastch=nmc
            end if
          else if (iop(76) .eq. 3) then
c           Control algorithm (Jason Banfelder & Joshua Speidel)
c           Gain is proportional to effect of beta on density
c           empirically derived from many simulations
            if (idebug(40) .gt. 1) write (iout,7763) nmc,nmolinout(2),
     -        targetn
            oldpv=pv
            pv=nmolinout(inorout)
c           dt = 1 b/c doing each step
            dpvdt=pv-oldpv
            controlerror=pv-setpoint
            dbetadt=gain_n*dpvdt+(gain_n/integraltime)*controlerror
            ba=ba+dbetadt
            if (idebug(40) .gt. 0)
     -         write(iout,7764) nmc,pv,ba,controlerror
            if (idebug(40) .gt. 1) write (iout,7765) oldpv,dpvdt,
     -        dbetadt,gain_n,integraltime
          end if
          if (iop(129) .gt. 0) then
c-----------B-parameter change check
            imod=0
            ihalfmod=0
            if (iop(129) .eq. 1) then
              if (mod(nmc,nmcsacpstep) .eq. 0) imod=1
              if (imod .eq. 0) then
                if (mod(nmc,nmcsacpstep/2) .eq. 0) ihalfmod=1
              end if
            else
              if (nmc-nmcsacp0 .eq. nmcsacpstep) then
                imod=1
                nmcsacp0=nmc
                nmcsacpstep=numsolv*nmcsacpsteppnmol
              end if
              if (nmc-nmcsacp0 .eq. nmcsacpstep/2) ihalfmod=1
            end if
            if (ihalfmod .eq. 1) then
              nligsum=0
              nmcav0=nmc
            else if (nmcav0 .gt. 0) then
              nligsum=nligsum+nmolec-1
            end if
            if (imod .gt. 0) then
              nstep_ann=nstep_ann+1
              if (nstep_ann .gt. maxbsave) then
                write (iout,2051)
                call datprt(2)
              end if
              nligsave(nstep_ann)=nmolec-1
              if (ihalfmod .eq. 1) then
                avgligsave(nstep_ann)=float(nligsum)/float(nmc-nmcav0)
              else
                avgligsave(nstep_ann)=nmolec-1
              end if
              bsave(nstep_ann)=ba
              if (idebug(176) .gt. 0) write (iout,2052) nstep_ann,
     -          nmc,nmcav0,nligsum,nmolec
              nmcav0=0
              if (iop(9) .eq. 0) write (ihist,2050) ba,nmolec-1,
     -          avgligsave(nstep_ann)
              if (iop(9) .eq. 0) call savcnfh(ihist,iout,0,1,8,1,c,
     -          crmgs,filenames(3),namlens(3),numrecprev(3),numrec(3),
     -          numframe,uusfac,219950,219950)
              write (iout,2048) nmc,ba,nmolec-1,ba-bincr
              ba=ba-bincr
              if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
c               Check if cavity biasing should be turned off
                fract_free=float(ngfree)/float(ng3)
                if (fract_free .gt. cav_fract_lim) then
                  iop(41)=3
                  write (iout,2049) fract_free,cav_fract_lim
                end if
              end if
            end if
          end if
        end if
        if (iop(71) .gt. 0) then
c---------Volume change attempt - (TPN) ensemble
          if (mod(nmc,nvchfreq) .eq. 0) then
            uusfac=uuscor*uwnb*uwcplo
            ucsmvv=ucsmvv+uusfac
C@IB            call volcha(uusfac,nfsslt,nfslww,ksltmn,ncor)
          end if
        else if (iop(106) .gt. 0) then
c---------Virtual volume change attempt
          if (mod(nmc,nvvchfreq) .eq. 0)
     -      call volcha(uusfac,nfsslt,nfslww,ksltmn,ncor)
        else if (iop(114) .gt. 0) then
c---------Temperature change check
          if (mod(nmc,nmctempstep) .eq. 0) then
            ntempstep=ntempstep+1
            ntempstepcum=ntempstepcum+1
            temp_prev=temp
            if (iop(114) .eq. 1) then
              temp=temp-tempstep
            else if (iop(114) .eq. 2) then
              temp=temp*exp(-tempexp)
            else if (iop(114) .eq. 3) then
              temp=tempexp/alog(float(ntempstep+2))
            else
              temp=templist(min0(ntemplist,ntempstep))
            end if
            if (temp .le. 0.0) then
              write (iout,2040) temp
              nwwarn=nwwarn+1
              nmc=nmcmax
            else
              write (iout,2041) ntempstep,ntempstepcum,temp,temp_prev,
     -          nminsave
              if (iop(109) .ge. 3) then
c               Save the conformation
                if (iop(109) .eq. 3) then
                  filename1=file(1:namlenf)//'_annh.'
                  lfilename1=namlenf+6
                else
                  filename1=file(1:namlenf)//'_annfh.'
                  lfilename1=namlenf+7
                end if
                call writeint(filename1,lfilename1,ntempstepcum,len)
                filename1(lfilename1+1:lfilename1+4)='.pdb'
                lfilename1=lfilename1+4
                open(unit=90,status='new',file=filename1(1:lfilename1),
     -            form='FORMATTED',iostat=iopenok)
                if (iopenok .ne. 0)
     -            open(unit=90,status='old',
     -              file=filename1(1:lfilename1),form='FORMATTED',
     -              iostat=iopenok)
                if (iopenok .eq. 0) then
                  if (iop(109) .eq. 4) then
                    call reassemble(nstta,nstta_full,crmgs,c,cslt,
     -                isplit_of_orig)
                    iop(61)=2
                    call savepdb('PDB ',keycol,90,iout,1,nstta_full,3,
     -                crmgs,-1,0,0,1,filename1,lfilename1,nmc,0,' ',1,
     -                1,1,3,inperr,nwarn,nwwarn,0,0,nlwr,0,1,#NA)
                  else
                    iop(61)=1
                    call savepdb('PDB ',keycol,90,iout,1,nstta,3,c,
     -                -1,0,0,1,filename1,lfilename1,nmc,0,' ',1,1,1,3,
     -                inperr,nwarn,nwwarn,0,0,nlwr,0,1,#NA)
                  end if
                  write (iout,*) 'Configuration saved on file ',
     -              filename1(1:lfilename1)
                  close (90)
                else
                  write (iout,*) '***** ERROR: failed to open file ',
     -              filename1(1:lfilename1)
                  call datprt(2)
                end if
              end if
              nminsave=0
              beta=1.0/(boltz*temp)
c             For now, just copy the code from inicac
              if (iop(71) .gt. 0) then
                pressv=press*avogad*0.02418*1.e-27
                pvbeta=pressv*beta
                vlamt=(boltz*temp)/vlam
                vvlmt=(vrange/2.0)/vlamt
                rangefac=((vol+vrange)/vol)**(1.0/3.0)
                vvlmtx=(edgexa*(rangefac-1.0)/2.0)/vlamt
                vvlmty=(edgeya*(rangefac-1.0)/2.0)/vlamt
                vvlmtz=(edgea*(rangefac-1.0)/2.0)/vlamt
                vvlmtxx=((vrange/(edgeya*edgea))/2.0)/vlamt
                vvlmtyy=((vrange/(edgexa*edgea))/2.0)/vlamt
                vvlmtzz=((vrange/(edgexa*edgeya))/2.0)/vlamt
                vvlmtyz=((vrange/edgea)/2.0)/vlamt
              end if
              if (iop(6) .gt. 4) then
                beta2=beta*fblamd
                beta4=beta2/2.0
                cd0bt2=beta4*cedslt
                ra0bt2=beta4*rtxslt
                cd1bt2=beta4*cedslv
                ra1bt2=beta4*rtxslv
                frcmax=0.4*dlog(dpmx)/
     -            (wpsmax*amax1(cd0bt2,cd1bt2,0.1)/2.0)
                trqmax=0.4*dlog(dpmx)/
     -            (wpsmax*amax1(ra0bt2,ra1bt2,0.1)/2.0)
              end if
            end if
            uusdiff=(ucsmid+ucsmvv+ucsmmv)-ucsm_prev
            if (uusdiff .gt. 0.d0) then
              write (iout,2044) temp,(usum-u_prev)/uusdiff,
     -          (uslt-uslt_prev)/uusdiff,(uttnb-uttnb_prev)/uusdiff,
     -          (uinnb-uinnb_prev)/uusdiff
              ucsm_prev=ucsmid+ucsmvv+ucsmmv
              u_prev=usum
              uslt_prev=uslt
              uttnb_prev=uttnb
              uinnb_prev=uinnb
            end if
          end if
        end if
        if (iop(9) .ge. 4 .and. MYRANK .eq. 0) then
          if (mod(nmc+nmchinc,nmcrec) .eq. 0) then
            if (iop(109) .eq. 1) then
c             Get the minimum energy conf in this stretch
              etotn=etoto
              etoto=eminhsave
              if (iop(41) .gt. 0) then
                natomsnmc=natoms
                natoms=natomshsave
                numsolv=(natoms-nstta)/nslv
                nmolec=numsolv+1
              end if
              call savcnfh(ihist,iout,0,0,0,1,cminhsave,crmgs,
     -          filenames(3),namlens(3),numrecprev(3),numrec(3),
     -          numframe,uusfac,#NA,#UV)
c             Check for global min too
              if (etoto .lt. eminsave) then
                eminsave=eminhsave
                call trnsfr(cminsave,cminhsave,natomshsave*3)
                nmcminsave=nmcminhsave
                natomssave=natomshsave
                if (idebug(136) .gt. 0) write (iout,7401) 'global',
     -            nmcminsave,eminsave
                nminsave=nminsave+1
              end if
              if (iop(41) .gt. 0) then
                natoms=natomsnmc
                numsolv=(natoms-nstta)/nslv
                nmolec=numsolv+1
              end if
              if (idebug(136) .gt. 0)
     -          write (iout,7400) nmcminhsave,eminhsave,nmc-nmcrec,nmc
c             Reset minimum energy to current config
              etoto=etotn
              call trnsfr(cminsave,c,natoms*3)
              eminhsave=etotn
              nmcminhsave=nmc
              natomshsave=natoms
            else
              call savcnfh(ihist,iout,0,0,0,1,c,crmgs,filenames(3),
     -          namlens(3),numrecprev(3),numrec(3),numframe,uusfac,
     -          #NA,#UV)
            end if
          end if
        end if
c-------Collect derivative contributions
        if (iop(82) .gt. 0) then
          if (mod(nmc,10**(iop(82)-1)) .eq. 0) call dvpslt(c,cic)
        end if
c-------Call proximity analysis
        if (iop(159) .gt. 0) then
          if (nmc .gt. nmcpxdsc) then
            if (nmcransh .gt. 0 .and. iop(30) .eq. 3) then
c             Generate new random torsion shift?
              if (mod(nmc-nmcpxdsc,nmcransh) .eq. 0) then
                call randpx(1,angincr)
                call initaddwidom(c,esf14,vdwf14,cutuus,angincr(1),1,
     -            inperr,iout)
                if (inperr .gt. 0) call datprt(2)
              end if
            end if
            if (mod(nmc-nmcpxdsc,navgpx) .eq. 0) then
              call disperpx(orient,c,crm,texslt,ifailpx)
              call genvol(nranpx,nranpxw,1,nstta,0,0.0,0,
     -          c,crm)
              nmcpxo=nmc
            end if
            if (mod(nmc-nmcpxdsc,nsavepx) .eq. 0) then
              call csavepx(ichkpx,1,iskipfail,6)
              write (iout,2038) 'Proximity analysis c',
     -          filenames(6)(lscratchpath+1:namlens(6)),nmc
C@DM              call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,
C@DM     -          ierr)
            end if
            if (iskipfail .gt. 0) call datprt(2)
            if (iop(142)+iop(146)+iop(148) .gt. 0) then
              if (mod(nmc-nmcpxdsc,npxcntin) .eq. 0) then
c               Accumulate block averages
c               blkavs(1,i): cumulative averages (i-th) for primary slt
c               coordination no, slv density in frst shell, slt frst shell
c               binding energy, frst shell slt-slv pair energy, total slt
c               primary coordination no, total primary slt binding energy,
c               primary solvent coordination no, slv-slv pair energy and
c               slv binding energy.
                if (nblcks .eq. #MI) then
c                 Double up block averages
                  do i=1,nfge
                    do ib=1,#MI/2
                      blkavs(ib,i)=(blkavs(2*ib,i)+blkavs(2*ib-1,i))/2.0
                    end do
                  end do
                  nblcks=nblcks/2
                  npxcntin=2*npxcntin
                  if (lumppr .ge. 2) lumppr=lumppr-1
                end if
                nblcks=nblcks+1
                call pxtabl(ipxt1,pxt1,ipxt2,pxt2,0,iop(24)-1,
     -            blkavs(nblcks,1),blkavs(nblcks,2),blkavs(nblcks,3),
     -            blkavs(nblcks,4),blkavs(nblcks,5),blkavs(nblcks,6),
     -            blkavs(nblcks,7),blkavs(nblcks,8),blkavs(nblcks,9),
     -            blkavs(nblcks,10),blkavs(nblcks,11),
     -            volav,0,nfgtyp,0,0,1,numrun)
              end if
            end if
            if ((mod(nmc-nmcpxdsc,npxres) .eq. 0 .and.
     -        (nmcmax-nmc)/navgpx .ge. 5) .or. iii .eq. nmcmax)
     -        call disfinpx(numrun,volav)
          end if
        end if
c-------Optional self test on the molecule selected
        if ((mod(nmc,nmcrep) .eq. 0 .or. iii .eq. nmcmax) .and.
     -      iop(13) .gt. 0) then
          if (idebug(10) .gt. 2) write (iout,7511) ' Before self test',
     -      nmc,(ia,(c(k,ia),k=1,3),(cslto(k,ia),k=1,3),
     -      sqrt(arrdist(c(1,ia),cslto(1,ia))),ia=1,nstta)
          if (iop(13) .eq. 3) then
            call selftest(2,iop(94),nfail,-nmolec,0,0)
          else if (iop(13) .gt. 0) then
            call selftest(iop(13),iop(94),nfail,1,0,0)
          end if
          if (iop(13) .gt. 0 .and. nfail .gt. 0) then
            call fixdev(iout,iop(94),0,noverl,nfsslt,nfslww,
     -        ksltmn,vsltgrx,nwwarn,nfail,ncor,tesi,frctot,trqtot,
     -        texslt,vrcslt,frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind,
     -        rcomiso,rijpso,rphs0iso,diamslv,ipxo,nslvds,nslvdsid,
     -        mvfst,ri,rri,gbuupd(1),gbuupt(1),etoto,cslto,nmc,devmax)
          end if
        end if
C@DMc       For now, block averages are not collected under MPI
        if (mod(nmc,ncntin) .eq. 0 .and. MYRANK .eq. 0) then
c---------Save data for control function plots.
c         ncntrl: number on control function blocks
c         xnmc(i): nmc of the i-th block
c         unmc(i), vnmc(i): i-th block average of energy, virial sum
c         cvnmc(i): i-th cumulative heat capacity
          ncntrl=ncntrl+1
          uwnmc(ncntrl)=ucsmmv
          unmc(ncntrl)=usum
          u=usum/(ucsmid+ucsmvv+ucsmmv)
          uuav=uusum/(ucsmid+ucsmvv+ucsmmv)
          sd2=uuav-u*u
          if (sd2 .gt. realmx/1000.0) sd2=realmx/1000.0
          cvnmc(ncntrl)=sd2*1000.0/(rnsum/(ucsmid+ucsmmv+ucsmvv)+nsttm)/
     -      (boltz*temp**2)
          virnmc(ncntrl)=vircsm(1)+vircsm(2)+vircsm(3)
          if (iop(41) .gt. 0) then
            uwnmc(ncntrl)=uwnmc(ncntrl)+ucsmid
            rnnmc(ncntrl)=rnsum
          end if
          if (iop(71) .gt. 0) then
            uwnmc(ncntrl)=uwnmc(ncntrl)+ucsmvv
            vnmc(ncntrl)=vsum
            uvvnmc(ncntrl)=ucsmvv
          else if (iop(76) .eq. 3) then
c           B-parameter block average for process control tuning
            vnmc(ncntrl)=bsum
            uvvnmc(ncntrl)=2*nmc
          end if
          if (iop(30) .gt. 3 .and. iop(30) .ne. 7) then
            if (iop(30) .eq. 6 .or. iop(30) .eq. 8) then
c             Collect block averages for <exp((e1-e)/kT)>  (pert. meth.)
              ufe=uws0
              ufe2=uws1
              call zeroitd(ufeadd,3)
              call zeroitd(ufe2add,3)
            else if (iop(30) .eq. 5) then
c             Collect block averages for <d(e1-e0)/d cplpar> (termdyn. integ.)
              if (ptiexpmax .le. 1.0) then
                do ix=1,3
                  ufe2add(ix)=ue1ind(ix)-ue0ind(ix)
                  ufeadd(ix)=ufe2add(ix)+ue1ttnb(ix)-ue0ttnb(ix)
                end do
              else
                do ix=1,3
                  ufe2add(ix)=tifacone(ix)*ue1ind(ix)-
     -              tifactwo(ix)*ue0ind(ix)
                  ufeadd(ix)=ufe2add(ix)+tifacone(ix)*ue1ttnb(ix)-
     -              tifactwo(ix)*ue0ttnb(ix)
                end do
              end if
              ufe=ufeadd(1)+ufeadd(2)+ufeadd(3)
              ufe2=ufe2add(1)+ufe2add(2)+ufe2add(3)
            else
              ufe=0.0
              ufe2=0.0
              call zeroitd(ufeadd,3)
            end if
            ufenmc(ncntrl)=ufe
            do ix=1,3
              ufeindnmc(ix,ncntrl)=ufeadd(ix)
            end do
            uf2nmc(ncntrl)=ufe2
          else
            ufe=0.0
            ufe2=0.0
            ufenmc(ncntrl)=0.0
            do ix=1,3
              ufeindnmc(ix,ncntrl)=0.0
            end do
            uf2nmc(ncntrl)=0.0
          end if
          xnmc(ncntrl)=nmc
          if (ncntrl .eq. #MI) then
c           Double the control function blocksize to make room
            ncntin=2*ncntin
            ncntrl=ncntrl/2
            do i=1,ncntrl
              xnmc(i)=xnmc(2*i)
              unmc(i)=unmc(2*i)
              if (iop(71) .gt. 0 .or. iop(76) .eq. 3) then
                vnmc(i)=vnmc(2*i)
                uvvnmc(i)=uvvnmc(2*i)
              end if
              uwnmc(i)=uwnmc(2*i)
              ufenmc(i)=ufenmc(2*i)
              do ix=1,3
                ufeindnmc(ix,i)=ufeindnmc(ix,2*i)
              end do
              uf2nmc(i)=uf2nmc(2*i)
              cvnmc(i)=cvnmc(2*i)
              if (iop(41) .gt. 0) rnnmc(i)=rnnmc(2*i)
            end do
            write (iout,2043) 'C',ncntin,nmc
          end if
        end if
        justfixed=0
c-------Compulsory self test
        if (iop(13) .eq. 0 .and. mod(nmc,nmcslftst) .eq. 0 .and.
     -      iii .ne. nmcmax .and. iop(21) .lt. 3) then
          write (iout,2014) nmc
          imolck=0
          if (isltsmpl .gt. 0) imolck=1
          if (iop(41) .gt. 0) imolck=nmolec
          ngriderr=0
          call selftest(2,iop(95),nfail,imolck,0,0)
          if (ngriderr .gt. 0) write (iout,2016) ngriderr
          if (nfail .gt. 0) then
            write (iout,2004) nmc
            call fixdev(iout,iop(95),0,novl,nfsslt,nfslww,ksltmn,
     -        vsltgrx,nwwarn,nfail,ncor,tesi,frctot,trqtot,texslt,
     -        vrcslt,frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind,rcomiso,
     -        rijpso,rphs0iso,diamslv,ipxo,nslvds,nslvdsid,mvfst,ri,rri,
     -        gbuupd(1),gbuupt(1),etoto,cslto,nmc,devmax)
            justfixed=1
            if (nfail .eq. 0) write (iout,2032)
          end if
          write (iout,2028)
        end if
c-------Eliminate accumulated round-off errors
        if (nmccd+nmccgd .gt. 0 .and. justfixed .eq. 0) then
          call checkfixedats(isltmv,c,nstta,0,0.2,idebug(129),
     -      'Driver, bef roerr elim',iout)
          ifullfix=0
          igeofix=0
          if (nmccd .gt. 0) then
            if (mod(nmc,nmccd) .eq. 0) ifullfix=1
          end if
          if (nmccgd .gt. 0) then
            if (mod(nmc,nmccgd) .eq. 0) igeofix=1
          end if
          if (ifullfix .eq. 1) then
c           Full fix
            estltp=tesi(1)
            etotp=etoto
            ettnbp=ettnbo
            einnbp=einnbo
            es14p=es14o
            eslttorp=eslttoro
            evvp=etoto-tesi(1)-
     -        (ettnbo+einnbo+es14o+eslttoro+efieldo+esmolo)
            call fixdev(iout,iop(95),0,novl,nfsslt,nfslww,ksltmn,
     -        vsltgrx,nwwarn,0,ncor,tesi,frctot,trqtot,texslt,
     -        vrcslt,frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind,rcomiso,
     -        rijpso,rphs0iso,diamslv,ipxo,nslvds,nslvdsid,mvfst,ri,rri,
     -        gbuupd(1),gbuupt(1),etoto,cslto,nmc,devmax)
            evv=etoto-tesi(1)-
     -        (ettnbo+einnbo+es14o+eslttoro+efieldo+esmolo)
            write (iout,2021) nmc,etoto-etotp,tesi(1)-estltp,evv-evvp
            if (ntang+iop(57) .gt. 0) write (iout,2022) ettnbo-ettnbp,
     -        einnbo-einnbp,es14o-es14p,eslttoro-eslttorp,devmax
            nacortry=nacortry+1
            ngcortry=ngcortry+1
            if (igcorfail .eq. 1) ngcorfail=ngcorfail+1
          else if (igeofix .eq. 1) then
c           Geometry fix
            call fixdev(iout,iop(95),1,novl,nfsslt,nfslww,ksltmn,
     -        vsltgrx,nwwarn,0,ncor,tesi,frctot,trqtot,texslt,
     -        vrcslt,frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind,rcomiso,
     -        rijpso,rphs0iso,diamslv,ipxo,nslvds,nslvdsid,mvfst,ri,rri,
     -        gbuupd(1),gbuupt(1),etoto,cslto,nmc,devmax)
            ngcortry=ngcortry+1
            if (igcorfail .eq. 1) ngcorfail=ngcorfail+1
            if (igcorfail .eq. 0) write (iout,2039) nmc
          end if
          call checkfixedats(isltmv,c,nstta,0,
     -      0.2,idebug(129),'Driver, aft roerr elim',iout)
        end if
        ipxsave=0
        if (iop(159) .gt. 0) then
          if (nmc .gt. nmcpxdsc .and. mod(nmc-nmcpxdsc,nsavepx) .ne. 0)
     -      ipxsave=1
        end if
        if (mplt .eq. 0 .or. iii .eq. nmcmax) then
c---------Print distributions, averages; save distributions
          if (nmolec .gt. 1 .and. nsltfreq .ne. 1) then
c           Find the solvent molecule that was not moved the longest
            lstmvm=nmc
            do is=mvfst,nmolec
              if (lstmvd(is) .le. lstmvm) then
                lstmvm=lstmvd(is)
                imn=is
              end if
            end do
            noldst=nmc-lstmvm
          end if
          nminus=nmc-nrpt+1
          if (iop(4)+iop(111) .gt. 0)
     -      call wrapup(nminus,nmolec,c,orient,crm,nstta,nslv,iout)
          nxxx=nmc
          call disfin(nxxx,c,orient,crm,orientsltm,crm0)
          call checkfixedats(isltmv,c,nstta,0,0.2,idebug(129),
     -      'Driver, aft disfin',iout)
          if (nmolec .gt. 1 .and. nsltfreq .ne. 1) then
            ncycle=noldst/nmolec+1
            pstuck=0.0
            acc=0
            if (nmovtry-npckd(1) .gt. 1)
     -        acc=float(nmovacc-nmvd(1))/float(nmovtry-npckd(1))
            if (acc .eq. 0.0) then
              pstuck=1.0
            else if (1.d0-dble(acc) .gt. 0.0) then
              if (dlog(1.d0-dble(acc))*ncycle .gt. -rllnmx) then
                pstck=(1.d0-dble(acc))**ncycle
                if (dlog(1.d0-pstck)*nmolec .gt. -rllnmx) then
                  pstuck=1.d0-(1.d0-pstck)**nmolec
                end if
              end if
            end if
            if (MYRANK .eq. 0) write (iout,2005) noldst,imn-1,pstuck
            if (mod(nmc,nplt) .eq. 0) then
c             If molecules appear to be stuck then scale down stepsizes.
              if (iop(34) .gt. 0) then
                noldmx=100*nmolec
                if (iop(34) .gt. 1) noldmx=nmolec*10*iop(34)
                if (noldst .gt. noldmx) then
                  fac=0.90
                  stpfac=stpfac*fac
                  cd0bt2=cd0bt2*fac
                  cd1bt2=cd1bt2*fac
                  ra0bt2=ra0bt2*fac
                  ra1bt2=ra1bt2*fac
                  cedslt=cedslt*fac
                  rtxslt=rtxslt*fac
                  cedslv=cedslv*fac
                  rtxslv=rtxslv*fac
                  write (iout,2007) fac
                  nwarn=nwarn+1
                  call csave(ichkp,1,iskipfail,1)
                end if
              end if
            end if
          end if
c         See if stepsize accumulators need to be zeroed out
          do i=1,4
            if (nmc_zeroacc(i) .eq. nmc) then
              if (i .eq. 1) then
                do im=movmolf,movmoll
                  ntrantune(im)=0
                  do k=1,3
                    stepsumtranscumu(k,im)=0.d0
                  end do
                end do
                write (iout,2036) ' ',stunen(i),nmc_zeroacc(i)
              else if (i .eq. 2) then
                do im=movmolf,movmoll
                  do k=1,3
                    stepsumrotcumu(k,im)=0.d0
                    nrottune(k,im)=0
                  end do
                end do
                write (iout,2036) ' ',stunen(i),nmc_zeroacc(i)
              else if (i .eq. 3) then
                do it=1,ntangorg
                  stepsumtorcumu(it)=0.d0
                  nptsttry(it)=0
                  nptstacc(it)=0
                end do
                write (iout,2036) ' and acceptance rate ',
     -            stunen(i),nmc_zeroacc(i)
              else if (i .eq. 4) then
                do it=1,ntangorg
                  stepsumloopcumu(it)=0.d0
                  nptlooptry(it)=0
                  nptloopacc(it)=0
                end do
                write (iout,2036) ' and acceptance rate ',
     -            stunen(i),nmc_zeroacc(i)
              end if
            end if
          end do
        end if
c-------Save checkpoint file(s)
CJJ        if (mod(nmc,nrecd) .eq. 0 .or. mplt .eq. 0 .or.
CJJ     -      iii .eq. nmcmax) then
        if (mod(nmc,nrecd) .eq. 0 .or.
     -      ( mplt .eq. 0 .and. ipxsave .eq. 1) .or.
     -      iii .eq. nmcmax) then
c         Make sure that the regular and proximity checkpoint files
c         are synchronized
          call csave(ichkp,1,iskipfail,1)
C@DM          if (MYRANK .eq. 0) then
          if (ipxsave .eq. 1) call csavepx(ichkpx,1,iskipfail,6)
C@DM          end if
C@DM          call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
          if (iskipfail .gt. 0) call datprt(2)
        end if
c-------Save separate checkpoint file
        if (iop(40) .gt. 0) then
          if (mod(nmc-nmc0,nsavckpf) .eq. 0) then
            call fileopen(file,namlenf,filename1,namlens1,26,0,
     -        numrun,1+(nmc-nmc0)/nsavckpf,0,1,1,iversout,iout,ichkpw,0)
            call csave(ichkpw,1,iskipfail,26)
            write (iout,2038) 'C',filename1(1:namlens1),nmc
            call fileclose (ichkpw,0,iop(24),iout)
            if (iop(159) .gt. 0 .or. iop(160) .gt. 0) then
              call fileopen(file,namlenf,filename1,namlens1,29,0,
     -          numrun,1+(nmc-nmc0)/nsavckpf,0,1,1,iversout,iout,
     -          ichkpxw,0)
              call csavepx(ichkpxw,1,iskipfail,29)
              write (iout,2038) 'Proximity c',filename1(1:namlens1),nmc
              call fileclose (ichkpxw,0,iop(24),iout)
            end if
          end if
        end if
        if (temp .le. 0.0) then
c         Annealing aborted
          temp=temp_prev
          go to 9996
        end if
      end do
9996  if (iop(9) .gt. 0 .and. MYRANK .eq. 0) write (iout,2002) numrec(3)
C@DMc      For now, no block averages are saved under MPI - no error est either
      if (ncntrl-ncntrlskip .ge. 2 .and. iop(21) .lt. 3) then
        write (iout,2046) ncntrl
        if (ncntrlskip .gt. 0) write (iout,2013) ncntrlskip*ncntin
        ncntrlc=ncntrl
        if (ncntrllim .lt. ncntrl) then
          ncntrlc=ncntrllim
          write (iout,2047) ncntrllim*ncntin
        end if
        if (unmc(ncntrlc)/uwnmc(ncntrlc) .lt. rlsqmx)
     -    call btchmn(ncntrlc,ncntrlskip,ncntin,uwnmc,unmc,iengr,iout,
     -      0,sd2i)
C@FR        call btchmn(ncntrlc,ncntrlskip,ncntin,uwnmc,virnmc,ipress,iout,
C@FR     -    0,sd2i)
        if (iop(41) .gt. 0)
     -    call btchmn(ncntrlc,ncntrlskip,ncntin,uwnmc,rnnmc,inavg,iout,
     -      0,sd2i)
        if (iop(71) .gt. 0)
     -    call btchmn(ncntrlc,ncntrlskip,ncntin,uvvnmc,vnmc,ivol,iout,
     -      0,sd2i)
        if (iop(30) .eq. 5)
     -    call btchmn(ncntrlc,ncntrlskip,ncntin,uwnmc,ufenmc,ifti,iout,
     -      0,sd2i)
        if (iop(30) .eq. 6 .or. iop(30) .eq. 8)
     -    call btchmn(ncntrlc,ncntrlskip,ncntin,uwnmc,ufenmc,ifpm,iout,
     -      0,sd2i)
      end if
      if (nmcmax .gt. 0 .and. MYRANK .eq. 0) then
        ucsmdiff=(ucsmmv+ucsmid+ucsmvv-ucsmmv0-ucsmid0-ucsmvv0)
        ut0=(usum-ut0)/ucsmdiff
        uslt0=(uslt-uslt0)/ucsmdiff
        write (iout,2003) (nmc0+1),nmc,ut0,uslt0
        usind120=(tscum(1)-usind120)/ucsmdiff
        usind120=usind120
        usind60=(tscum(2)-usind60)/ucsmdiff
        usind60=usind60
        usind10=(tscum(3)-usind10)/ucsmdiff
        usind10=usind10
        write (iout,3003) (nmc0+1),nmc,usind120,usind60,usind10
        if (iop(41) .gt. 0) then
          rn0=(rnsum-rnsum0)/ucsmdiff
          write (iout,2015) 'N',rn0
        end if
        if (iop(71) .gt. 0) then
          v0=(vsum-vsum0)/ucsmdiff
          write (iout,2015) 'V',v0
        end if
      end if
      if (iop(91) .gt. 0 .and. nmc .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,2026) nmc-numrevrej-numrej0
      if (iop(30) .eq. 7 .and. nmcmax .gt. 0)
     -  write (iout,2012) cpl0mn,cpl0mx
      if (iop(51) .ge. 1 .and. MYRANK .eq. 0) then
        kgf=#WG/4+1
        if (iterws .gt. 0) then
          call rngplt(iout)
          ngsum=0
          do k=1,#WG
            ngsum=ngsum+nfisum(k)-nfisum_prev(k)
            pbzavi(k)=0.0
            if (pbzavg(k) .gt. 0.0) pbzavi(k)=-alog(pbzavg(k))/beta
          end do
          do k=1,#WG
            rndh(k)=float(nfisum(k)-nfisum_prev(k))/float(ngsum)
          end do
          if (nmcmax .eq. 0 .or. iop(24) .gt. 1 .or. iop(1) .ge. 2)
     -      call plot(cpl(kp1zro),pbzavi(kp1zro),rndh(kp1zro),#WG/2,
     -        0.0,0.0,0.0,0.0,20,99,4,40,20,itcplp,0,0,1)
        end if
      end if
      if (ncntrl .ge. 2 .and. MYRANK .eq. 0) then
        if (iop(71) .gt. 0) then
          call blockfromcum(blockav1,vnmc,uvvnmc,ncntrl)
          call dividedr(blockav2,vnmc,uvvnmc,ncntrl)
          call plot(xnmc,blockav1,blockav2,ncntrl,0.0,0.0,0.0,0.0,50,
     -      2,iop(16),41,23,ipltvol,1,0,0)
        end if
        if (iop(41) .gt. 0) then
          call blockfromcum(blockav1,rnnmc,uwnmc,ncntrl)
          call dividedr(blockav2,rnnmc,uwnmc,ncntrl)
          call plot(xnmc,blockav1,blockav2,ncntrl,0.0,0.0,0.0,0.0,50,
     -      2,iop(16),54,36,ipltnm,1,0,0)
c         Plot energy/molecule
          call blockfromcum(blockav2,unmc,uwnmc,ncntrl)
          do i=1,ncntrl
            if (blockav1(i) .ne. 0.0)
     -        blockav1(i)=blockav2(i)/blockav1(i)
            blockav2(i)=unmc(i)/rnnmc(i)
          end do
          call plot(xnmc,blockav1,blockav2,ncntrl,0.0,0.0,0.0,0.0,50,
     -      2,iop(16),54,36,ipltxm,1,0,0)
          if (iop(76) .eq. 3) then
c           Plot the B parameter
            call dividedr(blockav2,vnmc,uvvnmc,ncntrl)
            call blockfromcum(blockav1,vnmc,uvvnmc,ncntrl)
            call plot(xnmc,blockav1,blockav2,ncntrl,0.0,0.0,0.0,0.0,50,
     -        2,iop(16),54,36,ipltba,1,0,0)
          end if
        end if
        call blockfromcum(blockav1,unmc,uwnmc,ncntrl)
        if (iop(23) .gt. 0) then
c         Plot cumulative total energy averages for plot instead of Cv
          call dividedr(cvnmc,unmc,uwnmc,ncntrl)
          call plot(xnmc,blockav1,cvnmc,ncntrl,0.0,0.0,0.0,0.0,50,
     -      2,iop(16),64,32,ipltuu,1,0,0)
        else
          call plot(xnmc,blockav1,cvnmc,ncntrl,0.0,0.0,0.0,0.0,50,
     -      2,iop(16),64,32,ipltub,0,0,0)
        end if
        if (iop(30) .eq. 5) then
          ipltuu(33:49)=ipltti
          ipltuu(1:17)=ipltti
          call blockfromcum(blockav1,ufenmc,uwnmc,ncntrl)
          call dividedr(blockav2,ufenmc,uwnmc,ncntrl)
        else if (iop(30) .eq. 6 .or. iop(30) .eq. 8) then
          ipltuu(33:49)=ipltpm
          ipltuu(1:17)=ipltpm
c         NOTE: vnmc,unmc are reusable only because of the crstr below
          call getqd('ALL ',numrun,0,vnmc,unmc,blockav1,nblkr,ncntinr,
     -      cplprr,ptiexpr,iopfe)
          do i=1,ncntrl
            blockav2(i)=unmc(i)
          end do
        end if
        if (iop(30) .eq. 5 .or. iop(30) .eq. 6 .or. iop(30) .eq. 8)
     -    call plot(xnmc,blockav1,blockav2,ncntrl,0.0,0.0,0.0,0.0,50,
     -      2,iop(16),64,32,ipltuu,1,0,0)
      end if
      if (nhowfar .gt. 2 .and. MYRANK .eq. 0) then
        do i=1,nhowfar
          xnmc(i)=i*nplt*nhowfarsamp
        end do
        if (iop(57) .gt. 0)
     -    call plot(xnmc,dtot(1,1),decay(1,1),nhowfar,0.0,0.0,0.0,0.1,
     -    50,99,iop(16),55,24,
     -    'Solute diffusion (A**2): * Orientational correlation: O',0,
     -    1,2)
        if (nmolec .gt. 1 .and. iop(41) .eq. 0)
     -    call plot(xnmc,dtot(1,2),decay(1,2),nhowfar,0.0,0.0,0.0,0.1,
     -    50,99,iop(16),56,25,
     -    'Solvent diffusion (A**2): * Orientational correlation: O',0,
     -    1,2)
      end if
C@DM      if (MYRANK .eq. 0) then
      call getunitnos(iusave,1)
      call crstr(0)
      call getunitnos(iusave,0)
C@DM      end if
      return
1000  format(a)
1001  format(i4)
1002  format(i1)
c1004  format(e10.4)
c1005  format(e9.3)
2000  format(i10,' E=',e13.7,' <E>=',f10.2,' Emn=',f9.1,' (',i4,a1,
     -  ') Emx=',f9.1,' (',i4,a1,') Us=',f9.2,' a=',f4.2,' m=',i5,1x,a3,
     -  a2)
2001  format(i10,' E=',e13.7,' <E>=',e10.4,' Emn=',e9.3,' (',i4,a1,
     -  ') Emx=',e9.3,' (',i4,a1,') Us=',e9.3,' a=',f4.2,' m=',i5,1x,a3,
     -  a2)
2002  format(' Number of records on the (current) history file=',i10)
2003  format(' Average from',i10,' to',i10,' : <U>=',e15.7,' <Uslt>=',
     -  e15.7)
2004  format(' ***** Internal inconsistency developed during the run ',
     -  'at Nmc=',i10,' (POSSIBLE PROGRAM PROBLEM)')
2005  format(' The oldest position is ',i10,' configurations old',
     -  ' for solvent ',i6,' probability of getting stuck=',e10.3)
2006  format(' Solute-',a,' <E0(12,6,1)>=',3e12.5,' <E1(12,6,1)>=',
     -  3e12.5)
2007  format(' ----- WARNING: all stepsizes have been',
     -  ' decreased by a factor of',f5.2,/,
     -  31x,'since some solvent(s) appear not to be able to move')
2008  format(' uscorr=',e12.4,' mvcorr=',e12.4,' idcorr=',e12.4)
2009  format(' Egnb=',e11.5,' Ugnb=',f10.3,' Einb=',e11.5,' Uinb=',
     -  f10.3,' E14=',e11.5,' U14=',f10.3,' Etor=',e11.5,' Utor=',f10.3,
     -  2x)
2010  format(' E0,E1=',2e14.6,' <E0>,<E1>=',2e14.7,
     -  ' <Us(12,6,1)>=',3f11.4)
2011  format(' Nmc=',i10,' cplpar(o,n)=',2f8.4,
     -  ' cplmin=',f8.4,' cplmax=',f8.4,' Uwt(o,n)=',2e10.3)
2012  format(' Smallest and largest coupling parameter sampled in',
     -  ' this run=',2f9.5)
2013  format(' First',i10,' Monte Carlo steps were skipped for the',
     -  ' error estimate calculations')
2014  format(1x,40('.'),' Programmed self test at Nmc=',i10,1x,39('.'))
2015  format(39x,'<',a,'>=',f10.4)
2016  format(' ///// NOTE: ',i6,' solute atoms are outside the grid')
2017  format(' <Uslt(12,6,1)>=',3f20.5,' kcal/mol')
2018  format(' +++++ Cavity grid regenerated with a random shift')
2019  format(' +++++ Tuning iteration ',i3,' new B parameter=',f10.4,
     -  ' Number of bulk solvents=',f9.3,' Targeted number=',f9.3)
2020  format(' Various average acceptance ratios:',/,
     -       ' Move type ',a3,' (solvent,solute):',2f6.3,/,
     -      (' Move type ',a3,'                 :',f6.3))
2021  format(' Accumulators are refreshed at Nmc=',i10,
     -  ' Energy changes: total=',e10.3,' solute-solvent=',e10.3,
     -  ' solvent-solvent=',e10.3)
2022  format(17x,'solute-solute NB=',e10.3,' solute intra NB=',e10.3,
     -  ' 1-4=',e10.3,' torsion=',e10.3,' devmax=',f8.5)
2023  format(' ***** PROGRAM ERROR: molecule selected for move (',i6,
     -  ') exceeds the number of molecules=',i6)
2024  format(7x,'Unphysical change in <N> - ',a)
2025  format(7x,'Convergence reached  - B is left unchanged',/,
     -  7x,'Number of consecutive convergent iterations=',i3)
2026  format(' Effective number of MC steps (not counting outright ',
     -  'or reverse rejections)=',i10)
2027  format(' +++++ Molecule ',i6,' moved ',a,' the grid region')
2028  format(1x,120('.'))
2029  format(' PHS: r=',f6.2,' <r>=',f6.2,' e=',e11.4,' <e>=',
     -  e11.4,' <e>/<nout>=',f6.3,' <f>=',e10.3,' nout=',i4,
     -  ' <nout>=',f7.2,' rmax=',f4.1,' A')
2030  format(' ***** ERROR: new shell radius=',f10.5,' A is outside ',
     -  'the requested range [',f10.5,',',f10.5,']')
2031  format(' ***** ERROR: Tsallis sampling energy term is negative:',
     -  e14.5,' increase sigincfac')
2032  format(' Self-test tolerances can be loosened with the SLFT key',
     -  ' to avoid marginal self-test failures')
2033  format(11x,'Solute coordination number accumulation is ',
     -  'turned off')
2034  format(' Rejected outright, irejtyp=',i1,' nsol,nsolo=',2i4)
2035  format(' Torsion',i5,' kept unchanged - accept')
2036  format(' Stepsize',a,'accumulators for ',a,' have been reset at ',
     -  'MC setp #',i10)
C@DM2037  format(' ***** PROGRAM ERROR: GCE insert/delete action ',
C@DM     -  'discrepancy MYRANK=',i3,' indel=',i2,' isid=',i6,
C@DM     -  ' ngfree=',i9,' iflslv(2,NUMNOD)=',i8,/,
C@DM     -  44x,'NUMNOD* (control values): indel=',i2,' isid=',i6,
C@DM     -  ' ngfree=',i9,' iflslv(2,NUMNOD)=',i8)
2038  format(1x,a,'heckpoint file is saved on file ',a,' at Nmc=',i10)
2039  format(' Geometry was reinitialized at Nmc=',i10)
2040  format(' ===== STRONG WARNING: Annealing resulted in ',
     -  'non-positive temperature (',f10.2,')',/,7x,'Annealing stopped')
2041  format(' +++++ Simulated annealing step #',i4,' cumulative step#',
     -  i4,' new temperature=',f7.1,' K previous temperature=',f7.1,
     -  ' K # of saves=',i5)
C@DM2042  format(' ***** PROGRAM ERROR: MYRANK=',i3,' Top CPU solvent ',
C@DM     -  'limit (',i8,') exceeds the number of molecules (',i8,')')
2043  format(' +++++ ',a,'ontrol function block',
     -  ' size has been doubled to',i8,' at Nmc=',i10)
2044  format(' Averages over this temperature step:',/,' T=',f7.1,' K',
     -  ' <E>=',e12.5,' <E(slt-slv)>=',e12.5,' <E(slt-slt)nb>=',e12.5,
     -  ' <E(intra)slt>=',e12.5)
2045  format(' Egnb=',e11.5,' Ugnb=',e10.4,' Einb=',e11.5,' Uinb=',
     -  e10.4,' E14=',e11.5,' U14=',e10.4,' Etor=',e11.5,' Utor=',e10.4,
     -  2x)
2046  format(' Current number of blocks for error estimate ',
     -  'calculation=',i4)
2047  format(' Error estimates are based on the part of the run ending',
     -  ' the ',i10,'th Monte Carlo step')
2048  format(' Chemical potential annealing at nMC=',i9,' - Current B ',
     -  'parameter=',f7.2,' Number of ligands=',i6,' New B parameter=',
     -  f7.2)
2049  format(' Cavity biasing turned off since the fraction of free ',
     -  'grids (',f5.3,') exceeded the threshold (',f5.3,')')
2050  format('REMARK SACP B=',f9.2,' N=',i8,' <N>=',f10.3)
2051  format(' ***** ERROR: number of anneling steps exceed limit ',
     -  ' change maxbsave and the arrays in the common block anneal_cp')
2052  format(' Nstep=',i5,' nmc,nmcav0=',2i10,' nligsum=',i10,
     -  ' nmolec=',i6)
3003  format(' Average from',i10,' to',i10,' : <Uslt(12,6,1)>=',
     -  3(e15.7,2x))
7400  format(' MONTEC minimum energy at Nmc=',i10,' :',e14.6,
     -  ' over the interval nmc=',i10,' - ',i10)
7401  format(' MONTEC current minimum ',a,' energy at Nmc=',i10,' :',
     -  e14.6)
7500  format(' MONTEC ',a,' isolvp=',i6,' movtyp=',i3,' icopy=',i1,
     -      ' ityptry=',i2)
7511  format(' MONTEC: ',a,' nMC=',i9,' c, cslto,dist=',/,
     -  (i4,3f10.5,5x,3f10.5,5x,f10.5))
7512  format(' MONTEC: t,tang,tang0=',/,(3(i5,2f10.5)))
7521  format(' MONTEC rijpso:',10f10.5)
7522  format(' MONTEC uphs  :',10f10.5)
7523  format(' MONTEC ipxo  :',10i10)
7530  format(' MONTEC accsumprev ',a,' trans=',f10.7,' rot=',3f11.7)
7531  format(' MONTEC accsum ',a,' norot=',i2,' iax=',i2,
     -  ' trans=',f10.7,' rot=',3f11.7,/,8x,'stepsum trans=',3f11.7,
     -  ' rot=',3f11.7)
7532  format(' MONTEC ',a,' itn,itormov=',2i5,' accsum ',a,'=',e12.5,
     -  ' prev=',e12.5,' stepsum=',e12.5,' prev=',e12.5,' t=',f6.2)
7560  format(' MONTEC nmc=',i7,' nouto,n=',2i4,' rsho,n=',2f5.2,/,
     -  ' eo,n=',2e12.5,' ego,n=',2e12.5,' eav=',e12.5)
7730  format(' MONTEC it:',i5,' tstep, dihn,o=',3f10.5)
7731  format(' MONTEC ',a10,/,(2x,10f13.5))
7738  format(' MONTEC molecule-molecule energy between ',
     -  'solute molecule',i4,' and',/,(5(i4,'=',e12.5)))
7742  format(' MONTEC SWAP accepted, new and old energy, difference: ',
     -         (3(e10.5,2x)))
7750  format(' MONTEC bacha=',f8.4,' delrn,delb=',2e12.5,/,
     -  ' delndelb,0=',2e12.5)
7751  format(' MONTEC bacha=',f8.4,' delndelb,1,0=',3e12.5,
     -  ' fluct, fracout=',2e12.5,/,
     -  8x,'uavcor=',e12.5,' <N>=',f10.3,' Region=',a)
7842  format(' MONTEC ',a,' ediff=',e13.6,' delfac=',e13.6,
     -  ' etotn,o=',2e13.6,' scdif=',e12.5,' drno=',f6.3,/,
     -  ' tex1n,o=',2e13.6,' etotpn,o=',2e13.6,' ettnbn,o=',2e13.6,/,
     -  ' einnbn,o=',2e13.6,' es14n,o=',2e13.6,' eslttorn,o=',2f9.3,
     -  ' econstrn,o=',2e13.6)
7760  format(' MONTEC ',a,'=',e14.6,a,'teslt1n=',e14.6)
7761  format(' MONTEC is=',i4,' ettnbn,einnbn,es14n,eslttorn=',4e14.6,/,
     -  8x,'tesi(1),tesiis,tesi(isolv)=',3e14.6)
7762  format(' MONTEC uwnbn=',e14.6,' delfac=',e12.6)
7763  format(' MONTEC nmc=',i10,' nmolinout(2)=',i6,' targetn=',f10.2)
7764  format(' MONTEC nmc=',i10,' pv,ba=',f10.2,f10.3,
     -  ' controlerror=',f10.4)
7765  format(' MONTEC oldpv=',f10.2,' dpvdt,dbetadt=',2e13.6,
     -  ' gain_n,integraltime=',2f10.2)
7766  format(' MONTEC itormov=',i5,' etotn,ediffcha,efieldo,efieldn=',
     -  4e14.6)
7767  format(' MONTEC cplfac=',f6.2,' etotpn,o=',2f9.2,' gbeg,gbuupt=',
     -  2f9.2,' fcintra=',f6.2,' gsumselfn,o=',2f9.2,' gsum14n,o=',
     -  2f9.2,' torsensumn,o=',2f9.4)
7770  format(' Tuning <acc(trans)>=',f7.4,' <acc(rot)>=',3f8.4,/,
     -  8x,'<step(trans)>=',3e13.6,' <step(rot)>=',3e13.6)
7771  format(' Tuning ',a,' <acc>=',f7.4,' <step>=',e13.6,
     -  ' cumulative stepsum=',f12.4)
      end
      block data
c#    MMC routine  34 lstmod: 06/21/22
c*****Initialize potential constants, numerical constants
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /slfttolerance/ tol(10),
     -  engtolr,virtolr,tortolr,comtolr,zmattolr,cslttolr,d12tolr,
     -  d13tolr,wsumtolr,costolr,engtold,virtold,tortold,comtold,
     -  zmattold,cslttold,d12told,d13told,wsumtold,costold
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*1 charlist
      common /characters/ charlist(52)
      character*1 lxyz
      common /names/ lxyz(3)
      character*4 iatnam
      character*6 pflclm,pflqpn,pflamb02,pflkol94,pflcha,pflbvg,
     -  pflgro,pfljrg,pflhs,pflan,pfldu
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),ianfg(99),
     -  ianclm(#AT),ianqpn(#AT),ianamb02(#AT),iankol94(#AT),
     -  iancha(#AT),ianbvg(#AT),iangro(#AT),ianjrg(#AT),ianhs(#AT),
     -  ian(#AT),iandum(#AT),
     -  ifcclm(#AT),ifcqpn(#AT),ifcamb02(#AT),ifckol94(#AT),ifccha(#AT),
     -  ifcbvg(#AT),ifcgro(#AT),ifcjrg(#AT),ifchs(#AT),ifcan(#AT),
     -  ifcdu(#AT),
     -  pflclm(#AT),pflqpn(#AT),pflamb02(#AT),pflkol94(#AT),pflcha(#AT),
     -  pflbvg(#AT),pflgro(#AT),pfljrg(#AT),pflhs(#AT),pflan(#AT),
     -  pfldu(#AT)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      character*4 namfcg,namfcg0
      character*20 nmlfcg,nmlfcg0
      common /fcgnam/ igrdup(100),namfcg0(100),namfcg(100),
     -  nmlfcg0(100),nmlfcg(100)
      common /allpfdat/ ao(#AT),ah(#AT),bo(#AT),bh(#AT),co(#AT),ch(#AT),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      common /frslvr/ fsrclm(#AT),fsrqpn(#AT),fsramb02(#AT),
     -  fsrkol94(#AT),fsrcha(#AT),fsrbvg(#AT),fsrgro(#AT),fsrjrg(#AT),
     -  fsrhs(#AT),fsran(#AT),fsrdu(#AT)
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /clemcw/ cwclem(10,2)
      common /wlj3q/ abljqh(3,8)
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /oldedge/ exyzo(3),ionemessage
      common /bondmod/ nmake,imake(2,250),nbreak,ibreak(2,250),nhhb,nhrb
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 rstack,rix,rira,rirb
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
      real*8 d16,di16,di32,di48,di64
      common /rancon/ d16,di16,di32,di48,di64
      common /rangen/ xlim,ylim,zlim,xlim2,ylim2,zlim2,ixpxo
      common /lcg_const/ lcg_fac,lcg_add,lcg_seed,lcg_modexp,lcg_mod,i31
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /overlay/ covref(3,#ST),rangerad,ixovref(#ST),
     -  icrefok,ixrefok,irangetyp,novuse
      common /stepscale/ scalefactors(8),
     -  cedslv0,rtxslv0,cedslt0,rtxslt0,cedpslt0(3),rtxpslt0(3)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /dispar/ rfsslv,rfsslt,rssmin,rssmax,dmnslt,dmxslt,
     -  dmnslv,dmxslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /hcp_rotmat/ hcprot_p(3,3),hcprot_m(3,3),ishift_pm(19)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /cplp358/ cpl358(8,3),cq358(8,3),ixcpl(8)
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      character*10 mapname
      common /engmapnames/ mapname(10)
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      character*27 movename
      common /move_name/ movename(8)
      character*40 itcplp
      common /cplnames/ itcplp
      character*4 ipf
      character*8 namh2o,nammcy
      character*32 namstp
      common /pfnames/ ipf(11),namstp(11),namh2o(9),nammcy(3)
      character*4 keyname
      character*40 dataname
      common /errorname/ maxrect,dataname(60),keyname(60)
      character*17 formatnames
      common /trajform/ formatnames(11)
      character*3 namunit
      common /extnames/ namunit(50)
      character*60 configs(26)
      common /confignames/ configs,lconfigs(26)
      character*7 inoutlab
      common /inoutlabel/ inoutlab(2)
      common /option/ iop(200),idebug(200)
      character*15 selectname
      character*23 movname
      character*36 exbiname
      common /stratnames/ selectname(4),movname(7),exbiname(5)
      character*30 looptypname
      common /loopnames/ looptypname(9)
      character*5 inin
      common /interintra/ inin(2)
      common /warncount/ ichsegwarn,ipdbcherr(11)
      character*3 terend(2)
      character*36 datainfo(30)
      common /pdbinfo/ ntabcol,npxcol,nothercol,terend,datainfo
      character*11 stunen
      common /tunelab/ stunen(4)
      character*44 sitesortlab
      common /sitesort/ sitesortlab(6),lsitesortlab(6)
      character*1 tab,ctrlM,idigit,rdigit
      integer*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
c     tab4: b'00001001000010010000100100001001'
      data tab4 /151587081/
c     ctrlM4: b'00001101000011010000110100001101'
      data ctrlM4 /218959117/
      data idigit/'0','1','2','3','4','5','6','7','8','9'/
      data rdigit/'0','1','2','3','4','5','6','7','8','9',
     -  '-','+','e','E','.','.'/
      data engtold/0.0001/,virtold/0.001/,tortold/0.1/,comtold/0.001/,
     -  zmattold/0.0001/,cslttold/0.001/,d12told/0.2/,d13told/0.3/,
     -  wsumtold/0.0001/,costold/1.01/,engtolr/0.0/,virtolr/0.0/,
     -  tortolr/0.0/,comtolr/0.0/,zmattolr/0.0/,cslttolr/0.0/,
     -  d12tolr/0.0/,d13tolr/0.0/,wsumtolr/0.0/,costolr/0.0/
      data terend /'TER','END'/
      data datainfo /
     -  'First-shell volume                  ',
     -  'Second-shell volume                 ',
     -  'First-shell coordination number     ',
     -  'Second-shell coordination number    ',
     -  'First-shell density                 ',
     -  'Second-shell density                ',
     -  'First-shell solvent binding energy  ',
     -  'First shell solvent pair energy     ',
     -  'Total solvent coordination number   ',
     -  'Total solvent binding energy        ',
     -  'Solvent-solvent coordination number ',
     -  'Solvent-solvent pair energy         ',
     -  'Solvent-solvent binding energy      ',
     -  'First minimum of the proximity g(r) ',
     -  'g(r)-based first-shell coord. number',
     -  'g(r)-based first-shell volume       ',
     -  'g(r)-based first-shell density      ',
     -  'Circular variance (use all atoms)   ',
     -  'Circular variance (ignore hydrogens)',
     -  'Insertion acceptance rate*100       ',
     -  'Deletion acceptance rate*100        ',
     -  'Fractional occupancy                ',
     -  'B factor or RMS                     ',
     -  'Distance from generic site / solvent',
     -  'atomic radius                       ',
     -  'partial charge                      ',
     -  'proximal solute atom index          ',
     -  'distance from proximal solute atom  ',
     -  'distance of the closest deletionsite',
     -  '# of sites proximal to this atom    '/
      data ntabcol /13/, npxcol /17/, nothercol /7/
      data configs /
     -  'Initial configuration of the CMPC key',
     -  'Final configuration of the CMPC key',
     -  'Configuration written by the WCNF key',
     -  'Solute molecules spread out with the SPRD key',
     -  'Result of VORO run',
     -  'Filtered configuration',
     -  'New configuration before MC step',
     -  'New configuration after MC step',
     -  'Regenerated solute failing test',
     -  'DEPLOYPT: original configuration',
     -  'DEPLOYPT: modified configuration',
     -  'Configuration with close solute-solvent contact',
     -  'Best representative configuration for the generic sites',
     -  'Composite configuration, solvents nearest to generic sites',
     -  'Full solute plus the generic sites',
     -  'Full solute plus the clustered generic sites',
     -  'Best representative configuration, all high-occupancy sites',
     -  'Unsorted representative configuration',
     -  'Waters in average orientation at the generic sites',
     -  'Clustered generic sites',
     -  'Aggregated insertion-deletion sites',
     -  'Backbone loop solution',
     -  'Waters in average orientation at clustered generic sites',
     -  'Clustered generic sites (in cluster order)',
     -  'Full solute plus cavity occupying solvents',
     -  'Torsion driven cnformation'/
      data lconfigs /37,35,37,45,18,22,32,31,31,32,32,47,55,58,34,44,
     -  59,37,50,23,35,22,56,42,42,26/
      data movname /
     -  'solute moves           ','coupling parameter move',
     -  'partial displacements  ','partial torsions       ',
     -  'solute group swaps     ','correlated 2-slt moves ',
     -  'special moves          '/
      data exbiname/
     -  'maximum extension                   ',
     -  'square root of the maximum extension',
     -  'square root of the RMS extension    ',
     -  'mean absolute extension             ',
     -  'square root of the mean extensions  '/
      data selectname / 'random-uniform ','cyclic         ',
     -  'shuffled-cyclic','reverse cyclic '/
      data looptypname /
     -  'Consecutive torsions (------) ',
     -  'Peptide backbone     (3[-=-]) ',
     -  'Peptide backbone     (3[=--]) ',
     -  'One frozen torsion   (=------)',
     -  'One frozen torsion   (-=-----)',
     -  'One frozen torsion   (--=----)',
     -  'One frozen torsion   (---=---)',
     -  'One frozen torsion   (----=--)',
     -  'One frozen torsion   (-----=-)'/
c     iop(9)  =1: Save all the orientations and energies on unit ihist
c                 if iop(41)>0: save water coordinates periodically
c     iop(9)  =2: like iop(9)=1 but save the virial sum instead of the b.e.
c                 if iop(41)>0: save also the solute coordinates
c     iop(9)  =3: Not used
c     iop(9)  =4: Save the bare config (in ASCII) at every nmcrec-th step
c     iop(9)  =5: Save the annotated (ASCII) config at every nmcrec-th step
c     iop(9)  =6: Save the config (binary/unformatted) at every nmcrec-th step
c     iop(9)  =7: Read/write PDB format
c     iop(9)  =8: Read/write MODEL/ENDMDL PDB format
c     iop(9)  =9: Read/write Charmm CRD format
c     iop(9)  =10: Read/write an Amber trajectory
c     iop(9)  =11: Read/write a Charmm trajectory
      data formatnames /'MMC: changes + E ','MMC: changes + VS',
     -  'Minimum energy cf','MMC ASCII        ','MMC ASCII (annot)',
     -  'MMC binary       ','PDB              ','MODEL/ENDMDL PDB ',
     -  'Charmm CRD       ','Amber            ','Charmm DCD       '/
      data namunit /'ckp','crd','hst','dst','idl','pxc','pxp','pxi',
     -  'rtm','fgd','dat','grd','crd','ckp','pdb','pxv','wmp','CRD',
     -  'dcd','slt','tmp','tm1','dcd','pdb','CRD','ckp','crd','hst',
     -  'pxc','   ','ps ','wsl','inf','sto','trj','cov','cor','eng',
     -  'hbd','ocr','hbt','eiv','oro','hbf','DCD','mkb','psf','top',
     -  'slv','  '/
      data stunen /'translation','rotation   ','torsion    ',
     -  'loop move  '/
      data sitesortlab /
     -  'decreasing occupancy                        ',
     -  'increasing RMSD                             ',
     -  'increasing convergence                      ',
     -  'increasing distance from the solute         ',
     -  'decreasing CV wrt the solute                ',
     -  'increasing index of the proximal solute atom'/
      data lsitesortlab /20,15,22,35,28,48/
      data inin/'Inter','Intra'/
      data inoutlab /'inside ','outside'/
      data charlist /'A','B','C','D','E','F','G','H','I','J','K','L',
     -  'M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
     -               'a','b','c','d','e','f','g','h','i','j','k','l',
     -  'm','n','o','p','q','r','s','t','u','v','w','x','y','z'/
      data lxyz/'X','Y','Z'/
c     iasize: array size values (nasize of them)
      data nasize /70/
c     sizesym(i): the 2-character dimensioning symbol list
      data sizesym
     - /'MO','MA','SX','MM','UW','TN','VN','TE','VE','LS',
     -  'VW','ST','GR','TA','SV','VT','NA','TL','GT','GV',
     -  'DT','DM','RG','PG','WG','OR','GX','GY','GZ','CV',
     -  'W2','WS','WI','MI','TR','AT','UU','UV','TG','VG',
     -  'ND','DG','LG','GE','GQ','PP','PS','WM','TD','FE',
     -  'MH','LT','MD','DC','RC','MW','MS','NH','MG','HA',
     -  'GM','GH','NE','AU','GC','RN','NL','NS',2*'  '/
c     iasize(i): the actual value of the dimension symbol sizesym(i)
      data iasize
     - /#MO,#MA,#SX,#MM,#UW,#TN,#VN,#TE,#VE,#LS,
     -  #VW,#ST,#GR,#TA,#SV,#VT,#NA,#TL,#GT,#GV,
     -  #DT,#DM,#RG,#PG,#WG,#OR,#GX,#GY,#GZ,#CV,
     -  #W2,#WS,#WI,#MI,#TR,#AT,#UU,#UV,#TG,#VG,
     -  #ND,#DG,#LG,#GE,#GQ,#PP,#PS,#WM,#TD,#FE,
     -  #MH,#LT,#MD,#DC,#RC,#MW,#MS,#NH,#MG,#HA,
     -  #GM,#GH,#NE,#AU,#GC,#RN,#NL,#NS,2*1/
c     sizename(i): the name used in pre.f for the dimension symbol sizesym(i)
      data sizename
     -/'maxmol    ','maxatmol  ','mxpxslt   ','maxsltmol ','maxwnnu   ',
     - 'maxnst    ','maxnsv    ','maxest    ','maxesv    ','maxloopslt',
     - 'maxwnnv   ','maxslt    ','maxgslt   ','maxtslt   ','maxslv    ',
     - 'maxss     ','maxat     ','maxtrgrgr ','maxstg    ','maxsvg    ',
     - 'maxsst    ','maxmst    ','maxgrid   ','maxpfgr   ','maxcggr   ',
     - 'maxorgr   ','maxxgr    ','maxygr    ','maxzgr    ','maxcav    ',
     - 'maxlin    ','maxausp   ','maxauit   ','maxavit   ','maxtors   ',
     - 'maxatyp   ','maxatypu  ','maxstmol  ','maxtgrid  ','maxwrgrid ',
     - 'maxgvv    ','maxdrgrid ','maxdagrid ','maxpegrid ','mxpxgslt  ',
     - 'maxcavps  ','maxpfsum  ','maxmatch  ','maxtagrid ','mxfeslt   ',
     - 'maxhunsite','mxlooptor ','mxdiffmol ','mxdiffcr  ','mxrescr   ',
     - 'maxwidslt ','maxphsmol ','maxhmneig ','maxmolfg  ','maxath    ',
     - 'maxmapgrid','maxhbgrid ','maxatsave ','maxaucsave','maxgrdclst',
     - 'maxrandinp','maxnnlist ','maxsitehb ',2*'          '/
c     sizelname(i): the description of the dimension symbol sizesym(i)
      data sizelname /
     -  'solvent molecules+1                   ',
     -  'atoms per solute molecule             ',
     -  'solute atoms for proximity analysis   ',
     -  'solute molecules                      ',
     -  'words for solute neighbour bit list   ',
     -  'nuclei on solute                      ',
     -  'nuclei on solvent                     ',
     -  'EPEN electrons on solute              ',
     -  'EPEN electrons on solvent             ',
     -  'number of solute molecules w loop move',
     -  'words for solvent neighbour bit list  ',
     -  'solute centers (all copies)           ',
     -  'solute groups (residues) - all copies ',
     -  'solute centers for torsion option     ',
     -  'solvent centers/solvent               ',
     -  'solute or solvent centers             ',
     -  'centers (atoms and pseudoatoms)       ',
     -  'solute groups within torsion groups   ',
     -  'solute centers with a general solvent ',
     -  'solvent centers in a general solvent  ',
     -  'solute centers for sensitivity analyss',
     -  'molecules for sensitivity analysis    ',
     -  'full g(r) and primary g(r) grid-points',
     -  'preferential sampling grid points     ',
     -  'coupling parameter distribution grids ',
     -  'energy difference distribution grids  ',
     -  'grids in the x dir for grid search    ',
     -  'grids in the y dir for grid search    ',
     -  'grids in the z dir for grid search    ',
     -  'cavities                              ',
     -  'adaptive US matching workspace        ',
     -  'stored probabilities                  ',
     -  'iterations allowed for adaptive US+1  ',
     -  'block average entries                 ',
     -  'torsions                              ',
     -  'atom types the program can store      ',
     -  'atom types in a given solute          ',
     -  'molecules or solute atoms             ',
     -  'total g(r) grid points                ',
     -  'grid points for solvent-solvent g(r)s ',
     -  'number of solvent-solvent g(r)s       ',
     -  'dipole correlation QCDF radial grids  ',
     -  'dipole correlation QCDF angular grids ',
     -  'solute-solvent PE QCDF energy grids   ',
     -  'different QCDFs                       ',
     -  'cavities with pref. sampl. weights    ',
     -  'preferential sampling weight sub sums ',
     -  'AUS iterations to match               ',
     -  'torsion angle distribution grids      ',
     -  'free energy solute atoms              ',
     -  'sites for Hungarian method matching   ',
     -  'torsion loops                         ',
     -  'molecules for diffusion and residence ',
     -  'structures for diffusion              ',
     -  'structures for residence time         ',
     -  'number of Widom solutes               ',
     -  'number of primary hydr shell molecules',
     -  'number of neighbors for full match try',
     -  'number of molecules for fg calculation',
     -  'number of representative atoms        ',
     -  'number of potential function map grids',
     -  'number of hydrogen-bond grids         ',
     -  'number of atoms for min energy save   ',
     -  'number of frames saved for torsion auc',
     -  'number of cavity/pocket grid clusters ',
     -  'number of random numbers read         ',
     -  'number of 1st+2nd+3rd neighbors       ',
     -  'number of sites H-bonded to a residue ',
     -  2*'                                      '/
c     ncompopt: number of compilation options, icompopt(i) 0/1 = off/on
c     for i-th option. Assigned in echopr
      data ncompopt /40/,icompopt/40*0/
c     optname(i): the i-th program option (used as C@** to comment out lines)
      data optname/'NN','TN','NA','NL','TS','FR','DB','UX','  ','UG',
     -  'AX','PS','EF','16','DM', 'HP','I2','VC','IB','G7','PG','FG',
     -  'RF','AB','DD','1R','G9','GF',2*'  ','ND','NV','NR',7*'  '/
c     optlname(i): the description of the program option optname(i)
      data optlname /
     -  'Solvent near-neighbor map','Solute near-neighbor map ',
     -  'Arithmetic bit-map code  ','Logical bit-map handling ',
     -  'Solute torque calculation','Force/torque calculations',
     -  'Debugging code           ','Generic Unix             ',
     -  '                         ','SGI Unix                 ',
     -  'AIX Unix                 ','SGI auto parallelization ',
     -  'Intel Fortan calls       ','Quadruple precision      ',
     -  'MPI-distributed memory   ','Hewlett-Packard          ',
     -  'Integer*2                ','Vectorized search        ',
     -  'Isobaric ensemble        ','Gnu Fortran77            ',
     -  'Cavity grid analysis     ','Field gradient calcs.    ',
     -  'Reaction-field correction','Absoft Fortran 90/95     ',
     -  'Mehler-Solmayer DD diele.','1/r dielectric           ',
     -  'Gnu Fortran 95           ','GFortran                 ',
     -  2*'                         ',
     -  'Not MPI                  ','Non-vectorized search    ',
     -  'Not 1/r dielectric       ',
     -  7*'                         '/
c     dataname(i): the description of formatted input record number i
      data maxrect /60/
      data dataname /
     -  'number of weight function terms         ',
     -  'piecewise linear weight function        ',
     -  'polynomial weight function              ',
     -  'exponential weight function             ',
     -  'coupling parameter data                 ',
     -  'adaptive umbrella sampling limits       ',
     -  'adaptive umbrella sampling options      ',
     -  'adaptive umbrella sampling thresholds   ',
     -  'adaptive umbrella iteration updates     ',
     -  'atom modification record                ',
     -  'short and long functional group names   ',
     -  'functional group description            ',
     -  'grand-canonical ensemble parameters     ',
     -  'solute atom record                      ',
     -  'solvent atom record                     ',
     -  'hydrogen-bond acceptor oxygen           ',
     -  'atomtype to modify, its fcg and Rfsh    ',
     -  'new potential parameters                ',
     -  'EPEN/QPEN solute parameters             ',
     -  'EPEN/QPEN solvent parameters            ',
     -  'EPEN/QPEN cutoff parameters             ',
     -  '                                        ',
     -  'atomtypes of old structure              ',
     -  'torsion description                     ',
     -  'solute coordinates of old structure     ',
     -  'solvent coordinates of old structure    ',
     -  'number of scaled force bias weights     ',
     -  'scaled force bias weights               ',
     -  'input boundary conditions               ',
     -  '                                        ',
     -  'reference system solute atom records    ',
     -  'RDF gridsizes                           ',
     -  'RDF ranges                              ',
     -  'near-neighbour definitions              ',
     -  'near-neighbour distribution gridsizes   ',
     -  '                                        ',
     -  '                                        ',
     -  'inputted cell centers                   ',
     -  'number of inputted cell centers         ',
     -  '                                        ',
     -  'TI quadrature options                   ',
     -  'number of blocks to skip for TI quadr.  ',
     -  'TI quadrature descriptor                ',
     -  'block descriptors for TI quadrature     ',
     -  'block averages for TI quadrature        ',
     -  'trapesoid rule endpoints                ',
     -  'Gaussian polynomial integration endpts  ',
     -  'AUS matching options                    ',
     -  'AUS match points                        ',
     -  'Charmm CRD atom record                  ',
     -  'PDB atom record                         ',
     -  'MMC configuration atom record           ',
     -  'Number of atoms                         ',
     -  'Charmm comments                         ',
     -  'MMC solute atom record                  ',
     -  'Preferential insertion/deletion         ',
     -  'Preferential insertion/deletion         ',
     -  'Preferential insertion/deletion         ',
     -  'Preferential insertion/deletion         ',
     -  ' ***** PROGRAM ERROR: wrong inp. rec. no'/
c     keyname(i): the input key invoking formatted input record number i
      data keyname /
     -  'MOVE','MOVE','MOVE','MOVE','FREE','FREE','FREE','FREE',
     -  'RAUS','MODA','FCGD','FCGD','GCEN','SLTA','SLVA','ENHB',
     -  'PMOD','PMOD','SLTA','SLTA','SLTA','    ','CNFG','TORD',
     -  'CNFG','CNFG','SAMP','SAMP','PBCN','    ','CNFG','DSTC',
     -  'DSTC','DSTC','DSTC','    ','    ','PBCN','PBCN','    ',
     -  'TIQU','TIQU','TIQU','TIQU','TIQU','TIQU','TIQU','WMAT',
     -  'WMAT','SLTA','SLTA','CNFG','CNFG','CNFG','SLTA',
     -  4*'PRFI','    '/
      data moddate /'02/27/2024'/,cmoddate/'06/05/2022'/,
     -  cpxmoddate/'10/29/2014'/
c     inpt: standard input file; iout: standard output file;
      data inpt/5/,iout/6/,itempxxx /0/,mainkeyu/200*0/
      data nfiletyp /46/
c     Data file unit numbers are initialized to 0 - i.e., unopened
      data ifiles /10*0/
c     ifilstat(i)=0/iunit/-iunit:  file closed/ newly opened iunit / reopened
      data ifilstat/50*0/
c     iform(i) the format type of the i-th file (0: formatted, 1: unformatted)
      data iform /1,0,1,1,0,1,0,1,0,0, 0,0,0,1,0,0,0,0,1,0, 1,4*0,
     -  1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,7*0/
c     boltz: Boltzmann constant in kcal/mol; avogad: Avogadro's number.
      data boltz/.001987/,avogad/6.022045e+23/
      data ione /1/
      data itcplp/'o: n(coupl par) *: -kT*ln(p(coupl par)) '/
      data movename /
     -  'solvent translation        ', 'solvent rotation           ',
     -  'whole solute translation   ', 'whole solute rotation      ',
     -  'solute molecule translation', 'solute molecule rotation   ',
     -  'regular torsion            ', 'loop torsion               '/
c     Quadrature points (cpl358) and coefficients (cq358) for 3,5, and 8 pts
      data ixcpl /0,0,1,0,2,0,0,3/
      data cq358 /0.277777,0.444444,0.277777,5*0.0,
     -            0.118464,0.239314,0.284444,0.239314,0.118464,3*0.0,
     -            0.05061427,0.11119052,0.15685332,0.18134189,
     -            0.18134189,0.15685332,0.11119052,0.05061427/
      data cpl358 /0.112702,0.5,0.887298,5*0.0,
     -             0.046910,0.230765,0.5,0.769235,0.953089,3*0.0,
     -             0.019855,0.101667,0.237234,0.408283,
     -             0.591717,0.762766,0.898333,0.980145/
      data ipf/'CLMG','QPEN','AM02','AM94','CHRM','GR87','GR96','OPLS',
     -  'HSPH','ATNO','DUMM'/
      data namstp/
     -  'Clementi et al. library         ',
     -  'QPEN/EPEN                       ',
     -  'Kollman et al. library (AMBER02)',
     -  'Kollman et al. library (AMBER94)',
     -  'Charmm (Parm 22)                ',
     -  'Beren.-Gunst. library (GROMOS87)',
     -  'Groningen library (GROMACS)     ',
     -  'Jorgensen et al. library (OPLS) ',
     -  'Hard spheres                    ',
     -  'No potentials, atomic nos only  ',
     -  'Dummy atoms                     '/
      data namh2o/'inputted','TIPS    ','Ber-Fowl','SPC     ',
     -            'TIPS2   ','TIP3P   ','TIP4P   ','SPC/E   ',
     -            'TIP5P   '/
      data nammcy/'inputted','MCY-CI-2','YMD     '/
c     MCY-type potential parameters.
c     a1, a2, a3, a4: coefs for the exponential energy terms for
c     the (O,O), (H,H), (O,H), (O,H) terms.
c     b1, b2, b3, b4: coefs on the distance in the exponent for the
c     exponential terms (O,O), (H,H), (O,H), (O,H), resp.
c     qq: q(hydrogen)**2, rlp: distance between oxygen and neg. center.
c     cwclem(i,1): parameters for the MCY-CI-II water-water potential
      data cwclem /1734.196,1.061887,2.319395,0.436006,
     -  2.726696,1.460975,1.567367,1.181792,   0.514783,0.267637,
     -  661.3624,0.406239,1.736907,0.162914,
     -  2.468903,1.146178,1.465192,0.832632,   0.503973,0.2969324/
c     Stored LJ parameters and H charges for TIPS-SPC, etc. potentials
      data abljqh/525.000,580000.0,0.400,837.000,560400,0.490,
     -            625.456,629358.0,0.410,600.000,695000.0,0.535,
     -            595.000,582000.0,0.417,610.000,600000,0.520,
     -            625.4064,629308.92,0.4238,
     -            590.3000,544500.00,0.2410/
c     iatnam: atom name; aw: atomic weight.
c     First three rows of the periodic table are built in.
c     at.no. 87: blank (error); 88: point charge; 89: lone-pair;
c     90: electron; 91: CH1; 92: CH2; 93:CH3
      data iatnam/'H   ','He  ','Li  ','Be  ','B   ','C   ','N  ' ,
     -     'O   ','F   ','Ne  ','Na  ','Mg  ','Al  ','Si  ','P   ',
     -     'S   ','Cl  ','Ar  ','K   ','Ca  ','Sc  ','Ti  ','V   ',
     -     'Cr  ','Mn  ','Fe  ','Co  ','Ni  ','Cu  ','Zn  ','Ga  ',
     -     'Ge  ','As  ','Se  ','Br  ','Kr  ',
     -     'Rb  ','Sr  ','Y   ','Zr  ','Nb  ','Mo  ','Tc  ','Ru  ',
     -     'Rh  ','Pd  ','Ag  ','Cd  ','In  ','Sn  ','Sb  ','Te  ',
     -     'I   ','Xe  ','Cs  ','Ba  ','La  ',14*'    ',
     -     'Hf  ','Ta  ','W   ','Re  ','Os  ','Ir  ','Pt  ','Au  ',
     -     'Hg  ','Tl  ','Pb  ','Bi  ','Po  ','At  ','Rn  ',
     -     '    ','q   ','LP  ','El  ','C1  ','C2  ','C3  ',5*'**  ',
     -     'Du  '/
c     namfcg0: functional group short names
      data namfcg0   /
     -  '>C< ','>CH-','>CH2','-CH3','=C< ','=CH-','=CH2','=C= ',
     -  '-=CH','==C ','>N- ','>NH ','-NH2','=N- ','=NH ','-=N ',
     -  '>C=O','H/CO','-O- ','P-O-','-OH ','>PO2','>N+<','N+H1',
     -  'N+H2','N+H3','COO-','-SH ','-S- ','MNH+','PO4-','HPO3',
     -  8*'    ',
     -  '  Li',' Li+','  Be','Be2+','  Na',' Na+','  Mg','Mg2+',
     -  '   K','  K+','  Ca','Ca2+','  Zn','Zn2+','  Fe','Fe2+',
     -  'Cu  ','Cu2+',4*'    ',
     -  ' -CF','-CF2','-CF3','  F-',' -Cl','-Cl2','-Cl3',' Cl-',
     -  ' -Br','-Br2','-Br3',' Br-','  -I','  I-',22*'    ',
     -  '????','VERR'/
c     nmlfcg0: long names for functional groups'
      data nmlfcg0 /'Quaternary carbon   ','Methyne group       ',
     -  'Methylene group     ','Methyl group        ',
     -  'Methylene (disubst.)','Methylene (monosub.)',
     -  'Methylene group     ','                    ',
     -  'Methylidyne group   ','                    ',
     -  'Tertiary nitrogen   ','Amide group         ',
     -  'Amine group         ','Substituted imino gr',
     -  'Imino group         ','                    ',
     -  'Carbonyl group      ','Hydrogen on carbonyl',
     -  'Ester oxygen        ','Phospho ester group ',
     -  'Hydroxyl group      ','Phosphate group     ',
     -  '                    ','                    ',
     -  '                    ','                    ',
     -  'Carboxyl anion      ','Thiol group         ',
     -  'Sulfide group       ','                    ',
     -  'Phosphate anion     ','Hypophosphate anion ',
     - 8*'                    ',
     -  'Lithium             ','Lithium ion         ',
     -  'Beryllium           ','Beryllium ion       ',
     -  'Sodium              ','Sodium ion          ',
     -  'Magnesium           ','Magnesium ion       ',
     -  'Potassium           ','Potassium ion       ',
     -  'Calcium             ','Calcium ion         ',
     -  'Zinc                ','Zinc ion            ',
     -  'Iron                ','Iron ion            ',
     -  'Copper              ','Copper ion          ',
     - 4*'                    ',
     -  'Monoflouride        ','Difluoride          ',
     -  'Triflouride         ','Fluoride ion        ',
     -  'Monochloride        ','Dichloride          ',
     -  'Trichloride         ','Chloride ion        ',
     -  'Monbromide          ','Dibromide           ',
     -  'Tribromide          ','Bromide ion         ',
     -  'Iodide              ','Iodine ion          ',
     -  22*'                    ',
     -  'Unclassified group  ','Valence error atoms '/
c     ianfg(i): if an atom is a functional group by itself, the fcg no
c     of atomic number i.
      data ianfg /98,98,41,43,4*98,61,98,45,47,4*98,63,98,49,51,14*98,
     -  65,98,50*98,4*98,2,3,4,6*98/
c     aw: array of atomic weights
      data aw/1.00797,4.0026,6.939,9.0122,10.811,12.01115,
     -  14.0067,15.9994,18.9984,20.17,22.98977,24.305,
     -  26.98154,28.08,30.97376,32.06,35.453,39.94,
     -  39.09,40.08,44.96,47.90,50.94,51.97,54.94,55.85,58.33,
     -  58.71,63.55,65.38,69.72,72.59,74.92,78.96,79.90,83.80,
     -  85.47,87.62,88.91,91.22,
     -  92.91,95.94,98.91,101.07,102.91,106.4,107.87,112.40,114.84,
     -  118.69,
     -  121.75,127.60,126.90,131.3,132.91,137.34,138.91,14*0.0,
     -  178.49,180.95,183.85,186.2,190.2,192.2,195.09,197.97,200.59,
     -  204.37,207.19,208.98,210.0,210.0,222.0,
     -  0.0,3*0.00001,13.01912,14.02709,15.03506,5*0.0,0.00001/
c     vdw: array of atomic van der Waals radii
c     data vdw/1.2,4*1.0,1.6,1.5,1.4,1.35,5*1.5,1.8,1.85,1.8,2.0,
c    -     18*2.5,50*2.5,
c    -     4*0.0,3*2.0,6*0.0/
c     Radii from the Cambridge Structural Database
      data vdw /
     -  1.09,1.40,1.82,2.00,2.00,1.70,1.55,1.52,1.47,1.54,
     -  2.27,1.73,2.00,2.10,1.80,1.80,1.75,1.88,2.75,2.00,
     -  2.00,2.00,2.00,2.00,2.00,2.00,2.00,1.63,1.40,1.39,
     -  1.87,2.00,1.85,1.90,1.85,2.02,2.00,2.00,2.00,2.00,
     -  2.00,2.00,2.00,2.00,2.00,1.63,1.72,1.58,1.93,2.17,
     -  2.00,2.06,1.98,2.16,2.00,2.00,2.00,2.00,2.00,2.00,
     -  2.00,2.00,2.00,1.72,1.66,1.55,1.96,2.02,2.00,2.00,
     -  2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,
     -  2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,
     -  2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00,2.00/
 
      data nval/1,0, 1,2,3,4,4,2,1,0, 1,2,3,4,5,6,1,0,
     -  68*0, 4*0,3,2,1,6*0/
c     Connectivity info constants
c     Values from Simulaid
      data ramax /1.3,0.0,3*1.60,1.65,3*1.7,0.0,
     -  3*1.7,2*1.8,2.30,1.95,0.0,
     -  18*2.5, 50*2.5, 4*0.0, 3*1.615,5*0.0,2.0/
c     ianprt converts general atomic number (including ch,ch1,ch2) to atno
      data ianprt /1,2,3,4,5,6,7,8,9,10, 11,12,13,14,15,16,17,18,19,20,
     -    21,22,23,24,25,26,27,28,29,30, 31,32,33,34,35,36,37,38,39,40,
     -    41,42,43,44,45,46,47,48,49,50, 51,52,53,54,55,56,57,58,59,60,
     -    61,62,63,64,65,66,67,68,69,70, 71,72,73,74,75,76,77,78,79,80,
     -    81,82,83,84,85,86,87,88,89,90,  6,6,6,6*98/
c     iatnos(#AT,i): atomic numbers corresponding to various atom types
c     for slt-slv potential of type i+1.
c     Current block data assumes # AT (maxatyp) = 350
      data ianclm/4*1,4*6,2*8,3*7,6,7,1,5*6,16,1,3*6,8,6,1,8,7,6,
     -   6,8,1,7,1,6,1,6,8,6,8,1,1,8,7,7,2*37,15,8,6,1,8,87,1,8,1,6,1,
     -   1,1,6,8,6,0,8,0,30,3*0,89,88,275*0/
      data ianamb02/
     -   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
     -   6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     -   9,17,35,53,12, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
     -   6, 6,15,16,16,30,90,
     -   6, 6, 6, 6,
     -   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
     -   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9,17,35,53, 7,
     -   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,15,15,
     -  15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,
     -   213*0/
c     parm10:65; gaff:72 rest:#AT-137=213
      data iankol94/6,6,92,93,6,6,6,91,91,6,4*91,6,6,91,6,
     -     6*1,89,8*7,4*8,15,2*16,8,1,5*6,2*1,88,2*1,11,17,1,
     -     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1,
     -     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9,12,35,53, 7, 7, 7, 7, 7, 7,
     -     7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,15,15,15,15,15,15,15,16,16,
     -    16,16,16,16,16,16,20,228*0/
      data iancha /20*6, 26, 10*1, 11*7, 7*8, 3*16, 30, 8*1, 8*7, 8*8,
     -  12*6, 15, 11, 12, 1,1,1,1,6,6,6,6,8,8,8,8,7,7,15,17,16,6,6,1,1,
     -  6,6,1,1,1,1,6,6,8,8,1,7,7,8,6,6,6,6,15,2,10,19,99,3*7,3*17,3*35,
     -  53,3*6,2*1,3*6,5*1,
c     CGENFF parameters
     -  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     -  1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
     -  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
     -  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
     -  6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
     -  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8,
     -  8, 8, 8, 8, 8, 8, 8, 8, 8, 8,16,16,16,16,16,16,16,16, 9, 9,
     -  9, 9, 9,17,17,17,35,35,35,35,53,15,15,15,13,89,3*16,32*0/
      data ianbvg /
     -   8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 6,91,92,93,93,93,91,91, 6, 1,
     -   1, 1, 1,16,26,30,11,10,15, 8, 6, 7, 7, 6,14,11,11,17,20,12,
     -   9,92,93, 6, 6, 1, 8,16, 8,93,91, 8, 8, 7, 6,91,92,15, 8,92,
     -  93,93,92,287*0/
      data iangro /
     -   8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 6,91,92,93,93,91, 1, 1,88,16,
     -   1,16,26,30,12,20,15, 8, 9,17, 7,93, 8,11,17, 6,17, 1,16, 6,
     -   8, 6,17,14, 7, 1, 8, 8, 7, 6,91,92,15, 8,92,93,93,92,292*0/
c-----Types 68 and 69 are types 230 and 231 (aromatic C and H, JACS 112, 4768)
      data ianjrg /6,8,7,1,92,91,93,91,92,93, 91,7,1,91,92,92,6,8,92,7,
     -     01,92,08,01,91,06,92,92,92,91, 92,16,01,92,16,93,92,16,93,07,
     -     01,07,91,91,06,07,01,91,91,06, 07,01,06,07,01,92,92,06,08,91,
     -     92,08,93,06,93,91,17,6,1,15*00,8,1,03,11,09,17,
     -     91,08,91,91,93,93,8,1,88,88,250*0/
      data ianhs /#AT*0/,iandum /#AT*0/
c     ifcnos (ifc***):
c     Functional group indices for the different solute atom types
      data ifcclm/13,2,4,21,17,4,3,3,21,17, 13,14,13,6,12,6,5,6,5,5,
     -     4,31,98,5,6,17,17,5,26,27, 26,27,17,17,18,12,12,3,3,17,
     -     17,17,17,13,13,17,12,14,98,98, 22,20,4,3,22,98,21,21,2,4,
     -     2,2,21,3,21,5,98,19,282*98/
      data ifcqpn/#AT*98/
c     Only two ions have been turned on in this version, i.e., Na+ and Cl-
      data ifcamb02 /#AT*98/
      data ifckol94/
     -     17,05,03,04,05,05,05,06,06,06, 05,02,06,06,05,05,06,01,12,13,
     -     26,98,21,28,98,12,14,13,26,12, 14,14,11,17,98,21,19,22,29,98,
     -     21,21,5*6,5*98,46,70,30,
     -     5,10,5,1,5,5,5,5,5,5,5,10,10,1,1,5,5,2,2,2,2,2,6,2,12,21,98,
     -     28,21,2,63,67,71,75,15,16,14,11,11,14,14,14,14,14,14,
     -     14,98,14,21,19,21,98,98,98,98,98,98,98,98,98,98,98,28,
     -     29,98,98,52,26,02,03,03,03,223*98/
      data ifccha/ 350*98/
      data ifcbvg /
     -  17,27,21,21,12,13,26,14,11,98,98, 2, 3, 4, 4, 4, 6, 6, 5,98,
     -  21,21,28,29,98,98,45,98,22,19, 2,14,11, 3,98,46,46,70,52,48,
     -  66, 3, 4, 5, 5,98,21,29,17, 4, 6,17,17,26,98, 6, 3,22,27, 3,
     -   4, 4, 3,287*0/
      data ifcgro /
     -  17,27,21,21,12,13,26,14,11,98,98, 2, 3, 4, 4, 6,98,98,98,29,
     -  28,29,98,98,48,52,22,19,66,70,11, 4,21,46,70,98,70,98,29,98,
     -  17,98,70,98,11,98,17,17,26,98, 6, 3,22,27, 3, 4, 4, 3,292*0/
      data ifcjrg/17,17,12,12,3,2,4,2,3,4, 6,13,13,2,3,3,27,27,3,26,
     -     26,03,21,21,02,05,03,03,03,02, 02,28,28,03,29,04,03,29,04,12,
     -     12,14,02,02,02,98,98,98,98,98, 98,98,98,98,98,03,03,17,17,02,
     -     03,19,04,98,04,2*98,6,21,15*98,2*21,42,46,66,70,
     -     2,19,2,2,4,4,3*21,98,250*0/
      data ifchs /#AT*98/,ifcan /#AT*98/, ifcdu /#AT*98/
c     Potential function labels
      data pflclm/#AT*'    '/,pflqpn/#AT*'    '/
c     PC designates Point Charge, formely known as IP, in the original
c     version of the program. IP and IM, like in AMBER 4.1, designate
c     Na+ and Cl- ions, respectively. Only these two ions have been turned
c     on in the present version.
      data pflamb02/
     -  'C   ','CA  ','CB  ','CC  ','CD  ','CI  ','CK  ','CP  ','CM  ',
     -  'CS  ','CN  ','CQ  ','CR  ','CT  ','CV  ','CW  ','C*  ','CX  ',
     -  'CY  ','CZ  ','C5  ','C4  ','C0  ','H   ','HC  ','H1  ','H2  ',
     -  'H3  ','HA  ','H4  ','H5  ','HO  ','HS  ','HW  ','HP  ','HZ  ',
     -  'F   ','Cl  ','Br  ','I   ','MG  ','N   ','NA  ','NB  ','NC  ',
     -  'N2  ','N3  ','NT  ','N*  ','NY  ','O   ','O2  ','OW  ','OH  ',
     -  'OS  ','OP  ','P   ','S   ','SH  ','Zn  ','EP  ',
     -  'CO  ','2C  ','3C  ','C8  ',
     -  'c   ','c1  ','c2  ','c3  ','ca  ','cp  ','cq  ','cc  ','cd  ',
     -  'ce  ','cf  ','cg  ','ch  ','cx  ','cy  ','cu  ','cv  ','cz  ',
     -  'h1  ','h2  ','h3  ','h4  ','h5  ','ha  ','hc  ','hn  ','ho  ',
     -  'hp  ','hs  ','hw  ','hx  ','f   ','cl  ','br  ','i   ','n   ',
     -  'n1  ','n2  ','n3  ','n4  ','na  ','nb  ','nc  ','nd  ','ne  ',
     -  'nf  ','nh  ','no  ','o   ','oh  ','os  ','ow  ','p2  ','p3  ',
     -  'p4  ','p5  ','pb  ','pc  ','pd  ','pe  ','pf  ','px  ','py  ',
     -  's   ','s2  ','s4  ','s6  ','sh  ','ss  ','sx  ','sy  ','ss  ',
     -   213*'    '/
      data pflkol94/
     -  'C     ','C*    ','C2    ','C3    ','CA    ','CB    ','CC    ',
     -  'CD    ','CE    ','CF    ','CG    ','CH    ','CI    ','CJ    ',
     -  'CM    ','CN    ','CP    ','CT    ','H     ','H2    ','H3    ',
     -  'HC    ','HO    ','HS    ','LP    ','N     ','N*    ','N2    ',
     -  'N3    ','NA    ','NB    ','NC    ','NT    ','O     ','O2    ',
     -  'OH    ','OS    ','P     ','S     ','SH    ','OT    ','HT    ',
     -  'CK    ','CQ    ','CR    ','CV    ','CW    ','H1    ','H4    ',
     -  'PC    ','H5    ','HA    ','IP    ','IM    ','HP    ',
     -  'c     ','c1    ','c2    ','c3    ','ca    ','cp    ','cq    ',
     -  'cc    ','cd    ','ce    ','cf    ','cg    ','ch    ','cx    ',
     -  'cy    ','cu    ','cv    ','h1    ','h2    ','h3    ','h4    ',
     -  'h5    ','ha    ','hc    ','hn    ','ho    ','hp    ','hs    ',
     -  'hw    ','hx    ','f     ','cl    ','br    ','i     ','n     ',
     -  'n1    ','n2    ','n3    ','n4    ','na    ','nb    ','nc    ',
     -  'nd    ','ne    ','nf    ','nh    ','no    ','o     ','oh    ',
     -  'os    ','ow    ','p2    ','p3    ','p4    ','p5    ','pb    ',
     -  'px    ','py    ','s     ','s2    ','s4    ','s6    ','sh    ',
     -  'ss    ','sx    ','sy    ','C0    ','CX    ','2C    ','3C    ',
     -  'CO    ','C8    ',223*'      '/
      data pflcha /
     -  'C     ','CA    ','CAL   ','CC    ','CD    ','CM    ','CP1   ',
     -  'CP2   ','CP3   ','CPA   ','CPB   ','CPH1  ','CPH2  ','CPM   ',
     -  'CPT   ','CS    ','CT1   ','CT2   ','CT3   ','CY    ','FE    ',
     -  'H     ','HA    ','HB    ','HC    ','HP    ','HR1   ','HR2   ',
     -  'HR3   ','HS    ','HT    ','N     ','NC2   ','NH1   ','NH2   ',
     -  'NH3   ','NP    ','NPH   ','NR1   ','NR2   ','NR3   ','NY    ',
     -  'O     ','OB    ','OC    ','OH1   ','OM    ','OS    ','OT    ',
     -  'S     ','SM    ','SS    ','ZN    ','HN1   ','HN2   ','HN3   ',
     -  'HN4   ','HN5   ','HN6   ','HN7   ','HT    ','NN1   ','NN2   ',
     -  'NN2G  ','NN2U  ','NN3   ','NN3A  ','NN4   ','NN5   ','ON1   ',
     -  'ON1C  ','ON2   ','ON3   ','ON4   ','ON5   ','ON6   ','OT    ',
     -  'CN1   ','CN2   ','CN3   ','CN3B  ','CN4   ','CN5   ','CN6   ',
     -  'CN6B  ','CN6C  ','CN7   ','CN8   ','CN9   ','P     ','SOD   ',
     -  'MG    ','HOL   ','HAL   ','HCL   ','HL    ','CL    ','CTL1  ',
     -  'CTL2  ','CTL3  ','OBL   ','O2L   ','OHL   ','OSL   ','NH3L  ',
     -  'NTL   ','PL    ','CLA   ','SL    ','CEL1  ','CEL2  ','HAL1  ',
     -  'HAL2  ','CE1   ','CE2   ','HA1   ','HA2   ','HOS   ','HAS   ',
     -  'CTS   ','CBS   ','OHS   ','OES   ','HN3B  ','NN1   ','NN2   ',
     -  'ON1   ','CN1A  ','CN3A  ','CN3C  ','CN3D  ','P2    ','HE    ',
     -  'NE    ','K     ','DUM   ','F1    ','F2    ','F3    ','CLAL  ',
     -  'CLA2  ','CLA3  ','BRAL  ','BRA2  ','BRA3  ','IAL   ','CF1   ',
     -  'CF2   ','CF3   ','HF1   ','HF2   ','CAI   ','CT    ','CT2A  ',
     -  'HB1   ','HB2   ','HE1   ','HE2   ','HA3   ',
c     CGENFF parameters
     - 'HGA1  ','HGA2  ','HGA3  ','HGA4  ','HGA5  ','HGA6  ','HGA7  ',
     - 'HGAAM0','HGAAM1','HGAAM2','HGP1  ','HGP2  ','HGP3  ','HGP4  ',
     - 'HGP5  ','HGPAM1','HGPAM2','HGPAM3','HGR51 ','HGR52 ','HGR53 ',
     - 'HGR61 ','HGR62 ','HGR63 ','HGR71 ','CG1T1 ','CG1T2 ','CG1N1 ',
     - 'CG2D1 ','CG2D2 ','CG2D1O','CG2D2O','CG2DC1','CG2DC2','CG2DC3',
     - 'CG2N1 ','CG2N2 ','CG2O1 ','CG2O2 ','CG2O3 ','CG2O4 ','CG2O5 ',
     - 'CG2O6 ','CG2O7 ','CG2R51','CG2R52','CG2R53','CG2R57','CG25C1',
     - 'CG25C2','CG251O','CG252O','CG2R61','CG2R62','CG2R63','CG2R64',
     - 'CG2R66','CG2R67','CG2RC0','CG2R71','CG2RC7','CG301 ','CG302 ',
     - 'CG311 ','CG312 ','CG314 ','CG321 ','CG322 ','CG323 ','CG324 ',
     - 'CG331 ','CG334 ','CG3C50','CG3C51','CG3C52','CG3C53','CG3C54',
     - 'CG3C31','CG3C41','CG3RC1','CG3AM0','CG3AM1','CG3AM2','NG1T1 ',
     - 'NG2D1 ','NG2S0 ','NG2S1 ','NG2S2 ','NG2S3 ','NG2O1 ','NG2P1 ',
     - 'NG2R43','NG2R50','NG2R51','NG2R52','NG2R53','NG2R57','NG2R60',
     - 'NG2R61','NG2R62','NG2R67','NG2RC0','NG301 ','NG311 ','NG321 ',
     - 'NG331 ','NG3C51','NG3N1 ','NG3P0 ','NG3P1 ','NG3P2 ','NG3P3 ',
     - 'OG2D1 ','OG2D2 ','OG2D3 ','OG2D4 ','OG2D5 ','OG2N1 ','OG2P1 ',
     - 'OG2R50','OG3R60','OG301 ','OG302 ','OG303 ','OG304 ','OG311 ',
     - 'OG312 ','OG3C31','OG3C51','OG3C61','SG2D1 ','SG2R50','SG311 ',
     - 'SG301 ','SG302 ','SG3O1 ','SG3O2 ','SG3O3 ','FGA1  ','FGA2  ',
     - 'FGA3  ','FGP1  ','FGR1  ','CLGA1 ','CLGA3 ','CLGR1 ','BRGA1 ',
     - 'BRGA2 ','BRGA3 ','BRGR1 ','IGR1  ','PG0   ','PG1   ','PG2   ',
     - 'ALG1  ','LPH   ','SG2P1 ','OG2S1 ','SG2P1 ',32*'      '/
      data pflbvg /
     -  'O     ','OM    ','OA    ','OW    ','N     ','NT    ','NL    ',
     -  'NR5   ','NR5*  ','NP    ','C     ','CH1   ','CH2   ','CH3   ',
     -  'CH4   ','CM    ','CR51  ','CR61  ','CB    ','H     ','HO    ',
     -  'HW    ','HS    ','S     ','FE    ','ZN    ','NZ    ','NE    ',
     -  'P     ','OS    ','CS1   ','NR6   ','NR6*  ','CS2   ','SI    ',
     -  'NA    ','K     ','CL    ','CA    ','MG    ','F     ','CP2   ',
     -  'CP3   ','CR5   ','CR6   ','HCR   ','OWT3  ','SD    ','OD    ',
     -  'CD    ','CHE   ','LO    ','LOM   ','LNL   ','LC    ','LH1   ',
     -  'LH2   ','LP    ','LOS   ','LP2   ','LP3   ','LC3   ','LC2   ',
     -  287*'      '/
      data pflgro /
     -  'O     ','OM    ','OA    ','OW    ','N     ','NT    ','NL    ',
     -  'NR    ','NZ    ','NE    ','C     ','CH1   ','CH2   ','CH3   ',
     -  'CH4   ','CR1   ','HC    ','H     ','DUM   ','S     ','CU1+  ',
     -  'CU2+  ','FE    ','ZN2+  ','MG2+  ','CA2+  ','P     ','AR    ',
     -  'F     ','CL    ','BR    ','CMET  ','OMET  ','NA+   ','CL-   ',
     -  'CCHL  ','CLCH  ','HCHL  ','SDMS  ','CDMS  ','ODMS  ','CCL4  ',
     -  'CLCL  ','SI    ','MNH3  ','MW    ','LO    ','LOM   ','LNL   ',
     -  'LC    ','LH1   ','LH2   ','LP    ','LOS   ','LP2   ','LP3   ',
     -  'LC3   ','LC2   ',292*'      '/
      data pfljrg/#AT*'    '/,pflhs/#AT*'    '/,pflan/#AT*'    '/,
     -  pfldu/#AT*'      '/
c     First shell radii
      data fsrclm/ 2.2,2*4.3,2.3,4*5.3,5*3.3,5.3,3.3,4.3,5*5.3,4.3,
     -   3.3,3*5.3,3.3,5.3,2.2,2*3.3,2*5.3,3.3,4.3,3.3,4.3,5.3,4.3,
     -   5.3,3.3,5.3,3.3,2*2.2,3*3.3,4.0,3.3,5.3,4.3,3.3,2.3,3.3,4.3,
     -   5.3,4.3,6*0.,3.3,285*0.0/
      data fsrqpn/ #AT*0.0/
      data fsramb02/ #AT*0.0/
      data fsrkol94/ 3*5.3,6.0,5.3,4.5,12*2.2,3*4.0,2*3.3,5*3.6,
     -     4.0,4.5,2*4.0,318*0.0/
      data fsrcha/ #AT*0.0/
      data fsrbvg /
     -  3.3,2.3,3.3,3.3,3.3,3.3,3.3,3.3,3.3,3.3,3.3,5.3,5.3,5.3,5.3,
     -  5.3,5.3,5.3,5.3,5.3,2.3,2.3,2.3,4.0,4.0,4.0,3.3,3.3,4.0,3.3,
     -  5.3,3.3,3.3,5.3,4.0,0.0,0.0,0.0,0.0,0.0,0.0,5.3,5.3,5.3,5.3,
     -  5.3,3.3,4.0,3.3,5.3,5.3,3.3,3.3,3.3,3.3,5.3,5.3,4.0,2.3,5.3,
     -  5.3,5.3,5.3,287*0.0/
      data fsrgro /
     -  3.3,2.3,3.3,3.3,3.3,3.3,3.3,3.3,3.3,3.3,3.3,5.3,5.3,5.3,5.3,
     -  5.3,5.3,5.3,0.0,4.0,2.3,4.0,4.0,4.0,0.0,0.0,4.0,3.3,0.0,0.0,
     -  3.3,5.3,3.3,0.0,0.0,3.3,0.0,5.3,4.0,3.3,3.3,3.3,0.0,4.0,3.3,
     -  5.3,3.3,3.3,3.3,3.3,5.3,5.3,4.0,2.3,5.3,5.3,5.3,5.3,292*0.0/
      data fsrjrg/ 5.3,2*3.3,2.2,7*5.3,3.3,2.3,4*5.3,3.3,5.3,3.3,
     -   2.2,5.3,3.3,2.3,7*5.3,3.3,4.0,3.0,3*5.3,4.0,5.3,3.3,
     -   2.2,3.3,5.3,5.3,3.3,3.3,2.2,5.3,5.3,3.3,
     -   3.3,2.2,5.3,3.3,2.2,5.3,5.3,5.3,3.3,5.3,
     -   5.3,5.3,5.3,3.3,5.3,21*0.0,2.65,3.0,3.3,4.1,
     -   5.3,3.3,4*5.3,3.3,2.3,2*0.0,250*0.0/
      data fsrhs /#AT*0.0/
      data fsran /2.2,0.0,3*2.2,5.3,3*3.3,0.0,
     -   3.0,5*3.5,3*4.1,0.0,20*4.5,
     -   7*5.3,303*0.0/
      data fsrdu /#AT*0.0/
c-----Built-in parameters for Clementi solute - water potentials
c     1-12,14-23: e. Clementi, f. Cavallone and R. Scordamaglia,
c                 JACS, vol. 99, 5531 (1977).
c     25-28: R. Scordamaglia, F. Cavallone and e. Clementi,
c               JACS, vol. 99, 5545 (1977).
c     29-32: L. Carozzo, G. Corongiu and C. Petrongolo,
c               J. Chem. Phys., vol 68, 787 (1978).
c     13,33-44: M. Ragazzi, D.R. Ferro and E. Clementi,
c               J. Chem. Phys., vol 70,1040 (1979); 71, 3552 (1979).
c     45-48: ......
c     50-61: E. Clementi, G. Corongiu, F. Lejl, J.C.P.,
c            vol 70., 3726 (1979).
c     62-66: types 2,4,8,9,17 from J.C.P. 68, 787 (1978).
c     68: O02 from S. Romano, E. Clementi, Gazz. Chim. Ital.,
c                     vol 108, p 273 (1978).
c     70: Zn2+, E. Clementi, G. Corongiu, B. Jonsson, S. Romano,
c               Gazz. Chim. Ital. vol 109, p 669 (1979).
c     75: point charge
c     c6clm (ao, ah): 1/r**6 coefs for Clementi et al. potentials
c     c12cml (bo, bh): 1/r**12 coefs for Clementi et al. potential.
      data ao /0.227048e+3,0.344879e+1,0.344879e+1,0.389675e+3,
     -  0.242699e+3,0.102073e+2,0.110689e+3,0.102073e+2,0.112917e+2,
     -  0.102073e+2,0.124076e+2,0.220215e+2,
     -  0.3444e+3,0.126181e+3,0.161787e+4,0.233496e+3,0.102073e+2,
     -  0.102073e+2,0.199325e+3,0.655664e+3,0.229296e+3,0.139064e+2,
     -  0.254667e+3,0.167215e+4,0.149724e+2,0.229376e+2,0.223568e+2,
     -  .102073e+2,0.3313037e+3,0.1334429e-2,0.8894036e-02,0.2997570e+4,
     -  0.3481e+3,0.7065e+1,0.2910e+1,0.4071e+2,0.2721e+3,0.3349e+2,
     -  0.1132e+2,0.2442e+3,0.1817e+1,0.1026e+3,0.3772e+0,0.2839e+3,
     -  .589117e+2,.625915e+3,.108180e+4,.217249e+4,2*0.0,
     -  0.947036e-2,0.169627e-3,0.350523e-1,0.682239,2033.34,0.0,
     -  273.470,84.1028,0.527956e-1,0.101592e-1,0.344351,
     -  0.129702e-2,0.711437e-1,0.878129e+3,0.420283e+3,0.252190e-1,
     -  0.0,.651678e+3,0.0,-988.184,
     -  5*0.0,275*0.0/
      data ah /
     -  0.207522e+1,0.824253e+1,0.130720e+1,0.159769e+1,
     -  0.356004e+1,0.356004e+1,0.190354e+2,0.117873e+3,0.845312e+2,
     -  0.163285e+3,0.141508e+3,0.491524e+2,
     -  0.6188e+0,0.968582e+1,0.441930e+3,0.356528e+1,0.356004e+1,
     -  0.356004e+1,0.356004e+1,0.385323e+2,0.604174e+1,0.259414e+3,
     -  0.102959e+3,0.943063e+3,0.649989e+1,0.974940e+1,0.207783e+3,
     -  0.649989e+1,0.4313838e+2,0.2073513e+3,0.3711397e-2,0.3438321e-2,
     -  0.1168e+2,0.2413e+3,0.1803e+2,0.8305e+2,0.4256e+1,0.1383e+3,
     -  0.1467e+1,0.1126e+1,0.1071e+3,0.1400e+1,0.1477e+3,0.6574e-1,
     -  .510656,.124080e-3,.190500e-2,.147935e+3,2*0.0,
     -  1916.13,150.751,0.203372e-2,0.777036e-2,0.788963,0.0,
     -  1.08208,110.39,0.325242,0.259016e-2,0.829444,
     -  0.231091e-3,0.221144e-2,0.572417e-2,0.212451e-2,0.618684e-2,
     -  0.0,.808524e+2,0.0,263.886,
     -  5*0.0,275*0.0/
      data bo /0.319285e+4,0.332071e+4,0.704514e+4,0.307583e+4,
     -  0.570163e+4,0.294559e+6,0.276484e+6,0.345948e+6,0.305269e+6,
     -  0.261569e+6,0.631828e+6,0.200655e+6,
     -  0.5394e+6,0.130406e+6,0.626338e+6,0.792550e+4,0.102468e+6,
     -  0.520450e+6,0.136719e+5,0.911957e+6,0.155507e+5,0.174305e+7,
     -  0.369866e+5,0.576041e+6,0.241461e+6,0.211942e+6,0.341007e+6,
     -  0.360926e+5,0.332723e+4,0.2954239e+6,0.459548e+6,0.1519053e+7,
     -  0.1169e+5,0.5700e+6,0.9539e+4,0.5190e+6,0.3382e+4,0.3253e+6,
     -  0.5448e+4,0.4360e+4,0.1986e+6,0.3211e+3,0.1936e+6,0.3560e+4,
     -  .550118e+3,.244930e+6,.209999e+6,.821471e+6,2*0.0,
     -  0.882034e+7,699235.,494428.,2.01122,0.473613e+6,0.0,3729.64,
     -  410173.,27530.7,0.227628e+7,4.37999,
     -  0.278185e+4,0.730785e+4,0.490950e+6,0.204892e+6,0.440103e+6,
     -  0.0,.649934e+6,0.0,5537.40,
     -  5*0.0,275*0.0/
      data bh /
     -  0.173851e+4,0.145269e+4,0.280375e+3,0.463125e+4,0.184585e+6,
     -  0.389186e+5,0.618961e+4,0.235847e+4,0.870601e+3,0.762465e+4,
     -  0.277917e+4,0.486883e+4,
     -  0.2029e+5,0.130162e+6,0.127116e+5,0.104377e+4,0.121598e+6,
     -  0.404496e+5,0.157258e+6,0.177231e+6,0.545685e+5,0.918035e+4,
     -  0.776556e+4,0.970811e+6,0.173948e+6,0.189976e+6,0.296327e+4,
     -  0.649862e+6,0.2590136e+4,0.159129e+4,0.572114,0.4890765e+5,
     -  0.1242e+6,0.2396e+4,0.1953e+4,0.9119e+4,0.2040e+4,0.4837e+4,
     -  0.9434e+3,0.6979e+5,0.1617e+4,0.1248e+5,0.2524e+4,0.2317e+4,
     -  .142096e+1,.362149e+3,.154862e+6,.174527e+4,2*0.0,
     -  110182.,1359.39,85790.4,281.765,1.90055,0.0,1973.5,1764.47,
     -  44.0144,0.281405e+7,127.75,
     -  0.217801e+3,0.906543,0.187501e+5,0.199674e+4,0.466416e+5,
     -  0.0,.163569e+3,0.0,.112959,
     -  5*0.0,275*0.0/
      data co /0.998202,0.999967,0.998411,1.00094,0.999941,0.999956,
     -  0.999073,1.00345,0.999646,1.00093,0.999097,0.996604,1.000,
     -  1.01623,1.00060,1.00239,0.993571,0.999983,1.10000,1.01061,
     -  1.00122,0.995094,1.05506,1.005737,0.999617,0.996846,0.994164,
     -  1.087848,1.004381,1.001209,0.989214,1.00192,
     -  1.008,1.004,1.019,1.000,0.9994,0.9999,1.001,1.001,1.000,
     -  0.9974,1.000,1.002,
     -  1.05010,.998433,.990097,.992592,2*1.0,
     -  0.964714,1.0038,1.01258,0.995922,1.00378,1.0,0.986732,
     -  0.997871,1.00348,0.86537,0.996636,
     -  1.00462,1.00635,0.981432,0.987425,1.0053,
     -  1.0,.986802,1.0,1.43489,
     -  5*1.0,275*1.0/
      data ch /
     -  1.00089,1.00000,0.998704,1.00094,0.999760,1.00028,1.00000,
     -  1.00101,1.00005,0.999389,1.00009,0.998375,0.9959,1.00081,
     -  1.00051,0.998747,0.992950,1.00237,0.874550,0.981899,1.00150,
     -  1.01108,1.02515,0.998235,0.995093,0.997791,1.006008,0.856380,
     -  1.006976,0.999350,0.988388,1.002652,
     -  1.001,0.9996,1.003,0.9998,1.000,0.9992,1.000,1.001,1.000,
     -  0.9992,1.003,1.002,
     -  1.021318,.993293,.981080,1.00257,2*1.0,
     -  0.98629,1.00025,1.00322,0.998827,1.03204,1.0,1.00436,
     -  0.997871,1.0,1.12826,1.03402,
     -  1.00917,1.00277,0.996095,0.993806,0.980923,
     -  1.0,.9912285,1.0,1.41499,
     -  5*1.0,275*1.0/
c-----Data for Amber calculations (1999-2002)
c     rminamb02, enminamb02: distance of energy min, minimum energy
      data rminamb02 /
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.7131, 0.6000,
     -   1.4870, 1.3870, 1.2870, 1.1870, 1.4590, 1.4090, 1.3590, 0.0000,
     -   0.6000, 0.0000, 1.1000, 1.4590, 1.7500, 1.9480, 2.2200, 2.3500,
     -   0.7926, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240,
     -   1.8240, 1.8240, 1.6612, 1.6612, 1.7683, 1.7210, 1.6837, 1.8500,
     -   2.1000, 2.0000, 2.0000, 1.1000, 0.0000,
     -   1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.9080, 1.3870, 1.2870, 1.1870, 1.4090, 1.3590, 1.4590,
     -   1.4870, 0.6000, 0.0000, 0.6000, 0.6000, 0.0000, 1.1000, 1.7500,
     -   1.9480, 2.0200, 2.1500, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240,
     -   1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240,
     -   1.6612, 1.7210, 1.6837, 1.7683, 2.1000, 2.1000, 2.1000, 2.1000,
     -   2.1000, 2.1000, 2.1000, 2.1000, 2.1000, 2.1000, 2.1000, 2.0000,
     -   2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000,
     -   213*0.0/
      data enminamb02 /
     -   0.0860, 0.0860, 0.0860, 0.0860, 0.0860, 0.1094, 0.0860, 0.0860,
     -   0.0860, 0.0860, 0.0860, 0.0860, 0.0860, 0.1094, 0.0860, 0.0860,
     -   0.0860, 0.1094, 0.0860, 0.0860, 0.0860, 0.0860, 0.4598, 0.0157,
     -   0.0157, 0.0157, 0.0157, 0.0157, 0.0150, 0.0150, 0.0150, 0.0000,
     -   0.0157, 0.0000, 0.0157, 0.0150, 0.0610, 0.2650, 0.3200, 0.4000,
     -   0.8947, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700,
     -   0.1700, 0.1700, 0.2100, 0.2100, 0.1520, 0.2104, 0.1700, 0.1700,
     -   0.2000, 0.2500, 0.2500, 0.0125, 0.0000,
     -   0.1094, 0.1094, 0.1094, 0.0860,
     -   0.0860, 0.2100, 0.0860, 0.1094, 0.0860, 0.0860, 0.0860, 0.0860,
     -   0.0860, 0.0860, 0.0860, 0.2100, 0.2100, 0.0860, 0.0860, 0.0860,
     -   0.0860, 0.0860, 0.0157, 0.0157, 0.0157, 0.0150, 0.0150, 0.0150,
     -   0.0157, 0.0157, 0.0000, 0.0157, 0.0157, 0.0000, 0.0157, 0.0610,
     -   0.2650, 0.4200, 0.5000, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700,
     -   0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700,
     -   0.2100, 0.2104, 0.1700, 0.1520, 0.2000, 0.2000, 0.2000, 0.2000,
     -   0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2500,
     -   0.2500, 0.2500, 0.2500, 0.2500, 0.2500, 0.2500, 0.2500, 0.2500,
     -   213*0.0/
c-----Cornell Kollman parameters DB94 (JACS vol. 117, pg. 5179, yr. 1995)
       data rmin94 /2*1.908,1.925,2.000,14*1.908,0.6,
     -   1.287,1.187,1.487,0.0,0.6,1.2,4*1.824,
     -   3*1.824,1.850,2*1.6612,1.721,1.6837,2.100,
     -   2*2.000,2*0.000,5*1.908,1.387,1.409,1.868,1.359,1.459,1.868,
     -   2.47,1.10,
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   1.9080, 1.3870, 1.2870, 1.1870, 1.4090, 1.3590, 1.4590, 1.4870,
     -   0.6000, 0.0000, 0.6000, 0.6000, 0.0000, 1.1000, 1.7500, 1.9480,
     -   2.0200, 2.1500, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240,
     -   1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.8240, 1.6612,
     -   1.7210, 1.6837, 1.7683, 2.1000, 2.1000, 2.1000, 2.1000, 2.1000,
     -   2.1000, 2.1000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000, 2.0000,
     -   2.0000, 2.0000, 1.7131, 1.9080, 1.9080, 1.9080, 1.9080, 1.9080,
     -   223*0.0000/
       data enmin94
     -   /2*0.086,0.12,0.15,13*0.086,0.1094,
     -   4*0.0157,0.0,0.0157,0.016,7*0.17,
     -   0.12,2*0.21,0.2104,0.17,0.2,2*0.25,0.20,
     -   0.0,5*0.086,0.0157,0.015,0.00277,2*0.015,0.00277,0.1,0.0157,
     -   0.0860, 0.2100, 0.0860, 0.1094, 0.0860, 0.0860, 0.0860, 0.0860,
     -   0.0860, 0.0860, 0.0860, 0.2100, 0.2100, 0.0860, 0.0860, 0.0860,
     -   0.0860, 0.0157, 0.0157, 0.0157, 0.0150, 0.0150, 0.0150, 0.0157,
     -   0.0157, 0.0000, 0.0157, 0.0157, 0.0000, 0.0157, 0.0610, 0.2650,
     -   0.4200, 0.5000, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700,
     -   0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.1700, 0.2100,
     -   0.2104, 0.1700, 0.1520, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000,
     -   0.2000, 0.2000, 0.2500, 0.2500, 0.2500, 0.2500, 0.2500, 0.2500,
     -   0.2500, 0.2500,8.459789,0.1094, 0.1094, 0.1094, 0.0860, 0.1094,
     -  223*0.000/
c-----Charmm-Parm 22 types
c     Bromide parameter from Johan Bredenberg (Charmm BB)
        data emincha /
     -  0.1100, 0.0700, 0.1200, 0.0700, 0.0700, 0.1100, 0.0200,
     -  0.0550, 0.0550, 0.0900, 0.0900, 0.0500, 0.0500, 0.0900,
     -  0.0900, 0.1100, 0.0200, 0.0550, 0.0800, 0.0700,  0.0000,
     -  0.0460, 0.0220, 0.0220, 0.0460, 0.0300, 0.0460, 0.0460,
     -  0.0078, 0.1000, 0.0460, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.1200, 0.1200, 0.1200, 0.1521, 0.1200, 0.1521, 0.1521,
     -  0.4500, 0.3800, 0.4700, 0.2500, 0.0460, 0.0460, 0.0220,
     -  0.0460, 0.0460, 0.0220, 0.0220, 0.0460, 0.20 ,  0.20 ,
     -  0.20 ,  0.20 ,  0.20 ,  0.20 ,  0.20 ,  0.20 ,  0.1200,
     -  0.1200, 0.1521, 0.1200, 0.1521, 0.1521, 0.1521, 0.1521,
     -  0.14  , 0.14  , 0.18  , 0.18  , 0.12  , 0.12  , 0.02  ,
     -  0.02  , 0.055 , 0.02  , 0.055 , 0.08  , 0.585 , 0.1000,
     -  0.001,  0.046 , 0.022 , 0.046 , 0.046 , 0.0700, 0.02  ,
     -  0.0550, 0.0800, 0.12  , 0.12  , 0.1521, 0.1521, 0.20  ,
     -  0.20  , 0.585 , 0.15  , 0.4700, 0.0680, 0.0640, 0.0310,
     -  0.0260, 0.0680, 0.0640, 0.0310, 0.0230, 0.0460, 0.0220,
     -  0.0200, 0.0200, 0.1521, 0.1521, 0.0460, 0.2000, 0.2000,
     -  0.1200, 0.0700, 0.1800, 0.1800, 0.1800, 0.5850, 0.0000,
     -  0.0000, 0.3600, 0.0000, 0.1350, 0.1050, 0.0970, 1.9082,
     -  1.9082, 1.9082, 0.8000, 0.8000, 0.8000, 0.6500, 0.0600,
     -  0.0420, 0.0200, 0.0280, 0.0300, 0.0730, 0.0200, 0.0560,
     -  0.0220, 0.0280, 0.0310, 0.0260, 0.0240,
c     CGENFF parameters
     -  0.0450, 0.0350, 0.0240, 0.0310, 0.0260, 0.0280, 0.0300,
     -  0.0280, 0.0280, 0.0400, 0.0460, 0.0460, 0.1000, 0.0460,
     -  0.0460, 0.0090, 0.0100, 0.0120, 0.0300, 0.0460, 0.0460,
     -  0.0300, 0.0460, 0.0460, 0.0300, 0.1670, 0.1032, 0.1800,
     -  0.0680, 0.0640, 0.0680, 0.0680, 0.0680, 0.0680, 0.0640,
     -  0.1100, 0.1100, 0.1100, 0.0980, 0.0700, 0.0600, 0.0900,
     -  0.0700, 0.0580, 0.0500, 0.0200, 0.0200, 0.0500, 0.0680,
     -  0.0680, 0.0680, 0.0680, 0.0700, 0.0900, 0.1000, 0.0400,
     -  0.0700, 0.0700, 0.0990, 0.0670, 0.0990, 0.0320, 0.0200,
     -  0.0320, 0.0420, 0.0310, 0.0560, 0.0600, 0.1100, 0.0550,
     -  0.0780, 0.0770, 0.0360, 0.0360, 0.0600, 0.0350, 0.0590,
     -  0.0560, 0.0650, 0.0320, 0.0700, 0.0780, 0.0800, 0.1800,
     -  0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.0600,
     -  0.2000, 0.0500, 0.2000, 0.2000, 0.0350, 0.0450, 0.0600,
     -  0.0700, 0.2000, 0.0600, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.1200, 0.1200, 0.0500, 0.1200, 0.1650, 0.1200, 0.1200,
     -  0.1200, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1921,
     -  0.1200, 0.1000, 0.1000, 0.1000, 0.5650, 0.4500, 0.4500,
     -  0.3800, 0.4700, 0.4700, 0.3500, 0.3500, 0.1350, 0.1050,
     -  0.0970, 0.0970, 0.1200, 0.3430, 0.3100, 0.3200, 0.4800,
     -  0.5300, 0.5400, 0.4200, 0.5500, 0.5850, 0.5850, 0.5850,
     -  0.6500, 0.0000, 0.6308, 0.1423, 0.6199, 32*0.0/
      data rmincha /
     -  2.0000, 1.9924, 1.7100, 2.0000, 2.0000, 2.1000, 2.2750,
     -  2.1750, 2.1750, 1.8000, 1.8000, 1.8000, 1.8000, 1.8000,
     -  1.8000, 2.2000, 2.2750, 2.1750, 2.0600, 1.9924, 0.6500,
     -  0.2245, 1.3200, 1.3200, 0.2245, 1.3582, 0.9000, 0.7000,
     -  1.4680, 0.4500, 0.2245, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.7000, 1.7000, 1.7000, 1.7700, 1.7000, 1.7700, 1.7682,
     -  2.0000, 1.9750, 2.2000, 1.0900, 0.2245, 0.2245, 1.3200,
     -  0.2245, 0.2245, 1.3200, 1.3200, 0.2245, 1.85,   1.85,
     -  1.85,   1.85,   1.85,   1.85 ,  1.85,   1.85,   1.70  ,
     -  1.70 ,  1.77  , 1.70  , 1.77  , 1.77  , 1.77  , 1.7682,
     -  1.8000, 1.8000, 1.8000, 1.8000, 1.8000, 1.8000, 2.2750,
     -  2.2750, 2.1750, 2.2750, 2.1750, 2.0600, 2.15  , 1.532 ,
     -  1.65,   0.2245, 1.32  , 0.2245, 0.7   , 2.00,   2.275 ,
     -  2.175,  2.0600, 1.7000, 1.7000, 1.7700, 1.7700, 1.8500,
     -  1.85,   2.1500, 2.4000, 2.1000, 2.090,  2.080,  1.2500,
     -  1.2600, 2.0900, 2.0800, 1.2500, 1.2600, 0.2245, 1.3200,
     -  2.2750, 2.2750, 1.7700, 1.7700, 0.9000, 1.8500, 1.8500,
     -  1.7000, 2.0000, 1.8000, 1.8000, 1.8000, 2.1500, 0.02127,
     -  0.0860, 1.8860, 1.0000, 1.6300, 1.6300, 1.6000, 0.0300,
     -  0.0300, 0.0300, 2.0000, 2.0000, 2.0000, 2.4000, 1.9000,
     -  2.0500, 2.3000, 1.3200, 1.3000, 1.9900, 2.2750, 2.0100,
     -  1.3200, 1.3400, 1.2500, 1.2600, 1.3400,
c     CGENFF parameters
     -  1.3400, 1.3400, 1.3400, 1.2500, 1.2600, 1.3200, 1.3000,
     -  1.2800, 1.2800, 1.2600, 0.2245, 0.2245, 0.4500, 0.2245,
     -  0.7000, 0.8750, 0.8750, 0.8700, 1.3582, 0.9000, 0.7000,
     -  1.3582, 1.1000, 0.9000, 1.3582, 1.8400, 1.9925, 1.8700,
     -  2.0900, 2.0800, 2.0900, 2.0900, 2.0900, 2.0900, 2.0800,
     -  2.0000, 2.0000, 2.0000, 1.7000, 2.0000, 1.8000, 2.0000,
     -  2.0000, 1.5630, 2.1000, 2.2000, 2.2000, 2.1000, 2.0900,
     -  2.0900, 2.0900, 2.0900, 1.9924, 1.9000, 1.9000, 2.1000,
     -  1.9000, 1.9924, 1.8600, 1.9948, 1.8600, 2.0000, 2.3000,
     -  2.0000, 2.0500, 2.1650, 2.0100, 1.9000, 2.2000, 2.1750,
     -  2.0500, 2.2150, 2.0100, 2.0100, 2.0200, 2.1750, 2.1850,
     -  2.0100, 2.0200, 2.0000, 1.9700, 1.9800, 1.9900, 1.7900,
     -  1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8900,
     -  1.8500, 2.0600, 1.8500, 1.8500, 2.0000, 2.0000, 1.9900,
     -  1.9800, 1.8500, 2.0500, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.7000, 1.7000, 1.7000, 1.7000, 1.6920, 1.7000, 1.7000,
     -  1.7000, 1.6500, 1.6500, 1.6500, 1.6500, 1.6500, 1.7650,
     -  1.7500, 1.6500, 1.6500, 1.6500, 2.0500, 2.0000, 2.0000,
     -  1.9750, 2.2000, 2.1000, 2.0000, 2.0000, 1.6300, 1.6300,
     -  1.6000, 1.6000, 1.7000, 1.9100, 1.9100, 1.9300, 1.9700,
     -  2.0500, 2.0000, 2.0700, 2.1900, 2.1500, 2.1500, 2.1500,
     -  2.0000, 0.0000, 2.0937, 1.6796, 2.0546, 32*0.0/
c-----Charmm-Parm 22 types - 1-4 parameters
        data emincha14 /
     -  0.1100, 0.0700, 0.1200, 0.0700, 0.0700, 0.1100, 0.0100,
     -  0.0100, 0.0100, 0.0900, 0.0900, 0.0500, 0.0500, 0.0900,
     -  0.0900, 0.1100, 0.0100, 0.0100, 0.0100, 0.0700,  0.0000,
     -  0.0460, 0.0220, 0.0220, 0.0460, 0.0300, 0.0460, 0.0460,
     -  0.0078, 0.1000, 0.0460, 0.0001, 0.2000, 0.2000, 0.2000,
     -  0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.1200, 0.1200, 0.1200, 0.1521, 0.1200, 0.1521, 0.1521,
     -  0.4500, 0.3800, 0.4700, 0.2500, 0.0460, 0.0460, 0.0220,
     -  0.0460, 0.0460, 0.0220, 0.0220, 0.0460, 0.20 ,  0.20 ,
     -  0.20 ,  0.20 ,  0.20 ,  0.20 ,  0.20 ,  0.20 ,  0.1200,
     -  0.1200, 0.1521, 0.1200, 0.1521, 0.1521, 0.1521, 0.1521,
     -  0.14  , 0.14  , 0.18  , 0.18  , 0.12  , 0.12  , 0.0100,
     -  0.0100, 0.0100, 0.0100, 0.0100, 0.0100, 0.585 , 0.1000,
     -  0.001,  0.046 , 0.022 , 0.046 , 0.046 , 0.0700, 0.0100,
     -  0.0100, 0.0100, 0.12  , 0.12  , 0.1521, 0.1521, 0.20  ,
     -  0.20  , 0.585 , 0.15  , 0.5850, 0.0680, 0.0640, 0.0310,
     -  0.0260, 0.0680, 0.0640, 0.0310, 0.0230, 0.0460, 0.0220,
     -  0.0100, 0.0100, 0.1521, 0.1521, 0.0460, 0.2000, 0.2000,
     -  0.1200, 0.0700, 0.1800, 0.1800, 0.1800, 0.5850, 0.0000,
     -  0.0000, 0.3600, 0.0000, 0.1350, 0.1050, 0.0970, 1.9082,
     -  1.9082, 1.9082, 0.8000, 0.8000, 0.8000, 0.6500, 0.0600,
     -  0.0420, 0.0200, 0.0280, 0.0300, 0.0730, 0.0200, 0.0560,
     -  0.0220, 0.0280, 0.0310, 0.0260, 0.0240,
c     CGENFF parameters
     -  0.0450, 0.0350, 0.0240, 0.0310, 0.0260, 0.0280, 0.0300,
     -  0.0280, 0.0280, 0.0400, 0.0460, 0.0460, 0.1000, 0.0460,
     -  0.0460, 0.0090, 0.0100, 0.0120, 0.0300, 0.0460, 0.0460,
     -  0.0300, 0.0460, 0.0460, 0.0300, 0.1670, 0.1032, 0.1800,
     -  0.0680, 0.0640, 0.0680, 0.0680, 0.0680, 0.0680, 0.0640,
     -  0.1100, 0.1100, 0.1100, 0.0980, 0.0700, 0.0600, 0.0900,
     -  0.0700, 0.0580, 0.0500, 0.0200, 0.0200, 0.0500, 0.0680,
     -  0.0680, 0.0680, 0.0680, 0.0700, 0.0900, 0.1000, 0.0400,
     -  0.0700, 0.0700, 0.0990, 0.0670, 0.0990, 0.0320, 0.0200,
     -  0.0320, 0.0420, 0.0310, 0.0560, 0.0600, 0.1100, 0.0550,
     -  0.0780, 0.0770, 0.0360, 0.0360, 0.0600, 0.0350, 0.0590,
     -  0.0560, 0.0650, 0.0320, 0.0700, 0.0780, 0.0800, 0.1800,
     -  0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.2000, 0.0600,
     -  0.2000, 0.0500, 0.2000, 0.2000, 0.0350, 0.0450, 0.0600,
     -  0.0700, 0.2000, 0.0600, 0.2000, 0.2000, 0.2000, 0.2000,
     -  0.1200, 0.1200, 0.0500, 0.1200, 0.1650, 0.1200, 0.1200,
     -  0.1200, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1921,
     -  0.1200, 0.1000, 0.1000, 0.1000, 0.5650, 0.4500, 0.4500,
     -  0.3800, 0.4700, 0.4700, 0.3500, 0.3500, 0.1350, 0.1050,
     -  0.0970, 0.0970, 0.1200, 0.3430, 0.3100, 0.3200, 0.4800,
     -  0.5300, 0.5400, 0.4200, 0.5500, 0.5850, 0.5850, 0.5850,
     -  0.6500, 0.0000, 0.6308, 0.1423, 0.6199, 32*0.0/
      data rmincha14 /
     -  2.0000, 1.9924, 1.7100, 2.0000, 2.0000, 2.1000, 1.9000,
     -  1.9000, 1.9000, 1.8000, 1.8000, 1.8000, 1.8000, 1.8000,
     -  1.9000, 2.2000, 1.9000, 1.9000, 1.9000, 1.9924, 0.6500,
     -  0.2245, 1.3200, 1.3200, 0.2245, 1.3582, 0.9000, 0.7000,
     -  1.4680, 0.4500, 0.2245, 1.8500, 1.8500, 1.5500, 1.8500,
     -  1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.4000, 1.4000, 1.7000, 1.7700, 1.7000, 1.7700, 1.7682,
     -  2.0000, 1.9750, 2.2000, 1.0900, 0.2245, 0.2245, 1.3200,
     -  0.2245, 0.2245, 1.3200, 1.3200, 0.2245, 1.85,   1.85,
     -  1.85,   1.85,   1.85,   1.85 ,  1.85,   1.85,   1.70  ,
     -  1.70 ,  1.77  , 1.70  , 1.77  , 1.77  , 1.77  , 1.7682,
     -  1.8000, 1.8000, 1.8000, 1.8000, 1.8000, 1.8000, 1.9000,
     -  1.9000, 1.9000, 1.9000, 1.9000, 1.9000, 2.15  , 1.532 ,
     -  1.65,   0.2245, 1.32  , 0.2245, 0.7   , 2.00  , 1.9000,
     -  1.9000, 1.9000, 1.40,   1.70,   1.77,   1.77,   1.85 ,
     -  1.85,   2.15,   2.4000, 2.1000, 2.090,  2.080,  1.2500,
     -  1.2600, 2.0900, 2.0800, 1.2500, 1.2600, 0.2245, 1.3200,
     -  1.9000, 1.9000, 1.7700, 1.7700, 0.9000, 1.8500, 1.8500,
     -  1.7000, 2.0000, 1.8000, 1.8000, 1.8000, 2.1500, 0.02127,
     -  0.0860, 1.8860, 1.0000, 1.6300, 1.6300, 1.6000, 0.0300,
     -  0.0300, 0.0300, 2.0000, 2.0000, 2.0000, 2.4000, 1.9000,
     -  2.0500, 2.3000, 1.3200, 1.3000, 1.9900, 2.2750, 2.0100,
     -  1.3200, 1.3400, 1.2500, 1.2600, 1.3400,
c     CGENFF parameters
     -  1.3400, 1.3400, 1.3400, 1.2500, 1.2600, 1.3200, 1.3000,
     -  1.2800, 1.2800, 1.2600, 0.2245, 0.2245, 0.4500, 0.2245,
     -  0.7000, 0.8750, 0.8750, 0.8700, 1.3582, 0.9000, 0.7000,
     -  1.3582, 1.1000, 0.9000, 1.3582, 1.8400, 1.9925, 1.8700,
     -  2.0900, 2.0800, 2.0900, 2.0900, 2.0900, 2.0900, 2.0800,
     -  2.0000, 2.0000, 2.0000, 1.7000, 2.0000, 1.8000, 2.0000,
     -  2.0000, 1.5630, 2.1000, 2.2000, 2.2000, 2.1000, 2.0900,
     -  2.0900, 2.0900, 2.0900, 1.9924, 1.9000, 1.9000, 2.1000,
     -  1.9000, 1.9924, 1.8600, 1.9948, 1.8600, 2.0000, 2.3000,
     -  2.0000, 2.0500, 2.1650, 2.0100, 1.9000, 2.2000, 2.1750,
     -  2.0500, 2.2150, 2.0100, 2.0100, 2.0200, 2.1750, 2.1850,
     -  2.0100, 2.0200, 2.0000, 1.9700, 1.9800, 1.9900, 1.7900,
     -  1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8500, 1.8900,
     -  1.8500, 2.0600, 1.8500, 1.8500, 2.0000, 2.0000, 1.9900,
     -  1.9800, 1.8500, 2.0500, 1.8500, 1.8500, 1.8500, 1.8500,
     -  1.7000, 1.7000, 1.7000, 1.7000, 1.6920, 1.7000, 1.7000,
     -  1.7000, 1.6500, 1.6500, 1.6500, 1.6500, 1.6500, 1.7650,
     -  1.7500, 1.6500, 1.6500, 1.6500, 2.0500, 2.0000, 2.0000,
     -  1.9750, 2.2000, 2.1000, 2.0000, 2.0000, 1.6300, 1.6300,
     -  1.6000, 1.6000, 1.7000, 1.9100, 1.9100, 1.9300, 1.9700,
     -  2.0500, 2.0000, 2.0700, 2.1900, 2.1500, 2.1500, 2.1500,
     -  2.0000, 0.0000, 1.0937, 1.6796, 2.0546, 32*0.0/
c-----Data for Berendsen/van Gunsteren potential
c     c6bvg, c12bvg: 1/r**6, 1/r**12 coefs.
      data c6bvg /
     -  23.25,23.25,23.25,25.01,24.13,24.13,24.13,24.13,24.13,24.13,
     -  23.65,54.65,46.63,46.06,46.06,46.06,36.30,36.30,23.65, 0.00,
     -   0.00, 0.00, 0.00,48.85, 0.00, 0.00,24.13,24.13,59.35,23.25,
     -  54.65,24.13,24.13,46.63,59.35, 4.15, 4.15,57.44,15.50, 3.95,
     -  57.44,46.63,46.06,23.65,23.65, 0.00,25.01,48.85,23.25,46.06,
     -  36.30,23.25,23.25,24.13,23.65,36.30,46.63,59.35,23.25,46.63,
     -  46.06,46.06,46.63,287*0.0/
      data c12bvg /
     -   550.0, 900.0, 600.0, 793.3, 950.0,1100.0,1500.0, 900.0, 900.0,
     -   636.0, 898.0,4141.0,2906.0,2500.0,2500.0,2500.0,1901.0,1901.0,
     -   898.0,   0.0,   0.0,   0.0,   0.0,1768.0,   0.0,  47.5,1050.0,
     -   970.0,2303.0, 600.0,4141.0, 900.0, 900.0,2906.0,2303.0,  70.9,
     -    70.9,5505.0, 345.0,  28.5,5505.0,2906.0,2500.0, 898.0, 898.0,
     -     0.0, 793.3,1768.0, 550.0,2500.0,1901.0, 550.0, 550.0,1500.0,
     -   898.0,1901.0,2906.0,2303.0, 900.0,2906.0,2500.0,2500.0,2906.0,
     -   287*0.0/
      data c6bvg14 /
     -  23.25,23.25,23.25,25.01,24.13,24.13,24.13,24.13,24.13,24.13,
     -  23.65,54.65,46.63,46.06,46.06,46.06,36.35,36.35,23.65, 0.00,
     -   0.00, 0.00, 0.00,48.85, 0.00, 0.00,24.13,24.13,59.35,23.25,
     -  26.38,24.13,24.13,33.60,59.35, 4.15, 4.15,57.44,15.50, 3.95,
     -  43.26,33.55,40.42,36.35,36.35, 4.50,24.39,50.24,23.30,46.51,
     -  36.30,23.25,23.25,24.13,23.65,36.30,46.63,59.35,23.25,46.63,
     -  46.06,46.06,46.63,287*0.0/
      data c12bvg14 /
     -   421.0, 421.0, 421.0, 421.0, 636.0, 636.0, 636.0, 636.0, 636.0,
     -   636.0, 898.0,4141.0,2906.0,2500.0,2500.0,2500.0,1411.0,1411.0,
     -   898.0,   0.0,   0.0,   0.0,   0.0,1768.0,   0.0,  47.5, 636.0,
     -   636.0,2303.0, 421.0, 945.0, 636.0, 636.0,1304.0,2303.0,  70.9,
     -    70.9,5054.9, 345.0,  28.5,2454.6,1754.8,2114.2,1411.0,1411.0,
     -    60.1, 762.9,2266.8, 423.8,2280.4,1901.0, 550.0, 550.0,1500.0,
     -   898.0,1901.0,2906.0,2303.0, 900.0,2906.0,2500.0,2500.0,2906.0,
     -   287*0.0/
      data c6gro /
     -  23.25,23.25,23.25,25.01,24.13,24.13,24.13,24.13,24.13,24.13,
     -  23.65,26.38,33.60,40.47,56.12,36.35, 4.50, 0.00, 0.00,48.85,
     -  10.00,10.00, 0.00,10.00, 3.95,15.50,59.35,38.70,16.78,45.77,
     -  16.79,46.06,23.25, 4.15,57.44,25.08,44.56, 3.00,50.24,46.51,
     -  23.30,25.08,42.63, 0.00,24.13, 0.00,23.25,23.25,24.13,23.65,
     -  36.30,46.63,59.35,23.25,46.63,46.06,46.06,46.63,292*0.0/
      data c12gro /
     -   421.0, 421.0, 550.0, 754.8, 636.0, 636.0, 636.0, 636.0, 636.0,
     -   636.0, 898.1, 945.0,1303.8,1697.9,2865.8,1410.9,  60.1,   0.0,
     -     0.0,1767.8,  35.0,  35.0,   0.0,  47.5,  28.5, 345.0,2303.1,
     -  1534.1, 426.4,1912.0,3956.0,2232.5, 550.0,  70.9,5055.0, 985.6,
     -  1813.8,  32.1,2266.8,2280.4, 423.8,1347.8,1746.9,   0.0, 900.0,
     -     0.0, 550.0, 550.0,1500.0, 898.0,1901.0,2906.0,2303.0, 900.0,
     -  2906.0,2500.0,2500.0,2906.0,292*0.0/
      data c6gro14 /
     -  23.25,23.25,23.25,25.01,24.13,24.13,24.13,24.13,24.13,24.13,
     -  23.65,54.65,46.63,46.06,46.06,36.30, 0.00, 0.00, 0.00,48.85,
     -   0.00,48.85, 0.00, 0.00, 3.95,15.50,59.35,23.25,57.44,57.44,
     -  24.13,46.06,23.25, 4.15,57.44,23.65,57.44, 0.00,48.85,23.65,
     -  23.25,23.65,57.44,59.35,24.13, 0.00,23.25,23.25,24.13,23.65,
     -  36.30,46.63,59.35,23.25,46.63,46.06,46.06,46.63,292*0.0/
      data c12gro14 /
     -   550.0, 900.0, 600.0, 793.3, 950.0,1100.0,1500.0, 900.0, 900.0,
     -   636.0, 898.0,4141.0,2906.0,2500.0,2500.0,1901.0,   0.0,   0.0,
     -     0.0,1768.0,   0.0,1768.0,   0.0,  47.5,  28.5, 345.0,2303.0,
     -   600.0,5505.0,5505.0, 900.0,2500.0, 600.0,  70.9,5505.0, 898.0,
     -  5505.0,   0.0,1768.0, 898.0, 550.0, 898.0,5505.0,2303.0, 900.0,
     -     0.0, 550.0, 550.0,1500.0, 898.0,1901.0,2906.0,2303.0, 900.0,
     -  2906.0,2500.0,2500.0,2906.0,292*0.0/
c-----Jorgensen OPLS list as of 04/85
c     sigjrg, epsjrq, qjrg: sigma, epsilon and charge for OPLS type i.
      data sigjrg/3.750,2.960,3.250,0.0,3.80,3.80,3.91,3.85,3.905,3.905,
     -  3.75,3.25,0.0,3.8,3.8,3.905,3.75,2.96,3.905,3.25,
     -  0.0,3.905,3.07,0.0,3.85,3.75,3.8,3.8,3.8,3.8,
     -  3.905,3.550,0.000,3.800,3.550,3.800,3.800,3.550,3.800,3.250,
     -  0.000,3.250,3.750,3.750,3.750,3.250,0.000,3.750,3.750,3.750,
     -  3.250,0.000,2.250,3.250,0.000,3.905,3.905,3.750,2.960,3.800,
     -  3.800,3.000,3.800,3.800,3.960,3.80,3.47,3.55,2.42,15*0.000,
     -  3.165557,0.000,1.259921,1.897439,0.864234,4.417233,
     -  3.8,3.046831,3.85,3.85,3.8,3.8,3.1536,3*0.0,250*0.0/
      data epsjrg/0.105,0.21,0.17,0.0,0.118,0.08,0.16,0.08,0.118,0.175,
     -  0.11,0.17,0.0,0.08,0.118,0.118,0.105,0.21,0.118,0.17,
     -  0.0,0.118,0.17,0.0,0.08,0.11,0.118,0.118,0.08,0.08,
     -  0.118,0.250,0.000,0.118,0.250,0.170,0.118,0.250,0.170,0.170,
     -  0.000,0.170,0.145,0.145,0.145,0.170,0.000,0.145,0.145,0.145,
     -  0.170,0.000,0.050,0.170,0.000,0.118,0.118,0.105,0.210,0.080,
     -  0.118,0.170,0.170,0.050,0.145,0.080,0.300,0.07,0.03,15*0.000,
     -  0.1553945,0.000,6.25,1.607142,720.0,0.117788,
     -  0.115,.1953125,0.08,0.08,0.17,0.17,0.15504,3*0.0,250*0.0/
      data qjrg/0.5,-0.5,-0.57,0.37,0.2,0.2,0.0,0.0,0.0,0.0,
     -  0.0,-0.85,0.425,0.285,0.285,-0.10,0.70,-0.8,0.31,-0.3,
     -  0.33,0.265,-0.7,0.435,0.265,0.265,0.31,0.1,0.31,0.1,
     -  0.180,-.450,0.270,0.235,-.470,0.235,0.300,-.300,0.200,-.570,
     -  0.420,-.490,0.410,0.100,0.130,-.540,0.460,0.500,0.330,-.055,
     -  -.800,0.460,0.640,-.700,0.440,0.310,0.070,0.550,-.450,0.250,
     -  0.250,-.400,0.250,0.200,0.000,0.42,-0.14,-0.115,0.115,15*0.000,
     -  -0.82,0.42,1.0,1.0,-1.0,-1.0,0.5,-0.58,0.555,0.29,0.2,0.285,
     -  0.0,0.52,-1.04,0.0,250*0.0/
c-----Hard spheres
      data sighs /#AT*0.0/
c-----Autodock types, hydrogen-bond constants
      data iatdatnos /6,6,7,8,15,16,1,1,0,0/,maxmaptyp /10/,
     -  maxhbtyp /10/,nhbdontyp /3/,nhbacctyp /3/,nhbdonacctyp /4/,
     -  nhbdonaccp /0/,ixdonacc /1,2,5,7*0,3,4,6,7*0,7,8,9,7*0,70*0/,
     -  rminhbheavy2 /100*0.0/
      data hbdonlab /'D>NH','D-OH','DNH+',7*'    '/
      data hbacclab /'AC=O','AH-O','AC-O',7*'    '/
      data mapname /'Carbon    ','Arom. Carb','Nitrogen  ','Oxygen    ',
     -              'Phosphorus','Sulphur   ','Hydrogen  ','Desolv.   ',
     -              '          ','El. Stat. '/
c*****Random number seed initialization
c     d16 is 2**16
      data d16/65536.d0/
c     dinn is 2**(-nn)
      data di16/.152587890625d-04/,di32/.232830643653870d-09/,
     -  di48/.355271367880050d-14/,di64/.542101086242752d-19/
c     ia is pi/4, ib is 0.5-sqrt(2)/6. ia (mod) 8 =5 and ia (mod)2=1
      data rira/63445.d0,47547.d0,14142.d0,34061.d0/,
     -  rirb/60517.d0,65346.d0,49487.d0,9164.d0/
      data ixpxo/1357/
      data irng /0/
 
      data lcg_fac /314159269/, lcg_add /453806245/,lcg_seed /1357/,
     -  lcg_modexp /31/, lcg_mod /-2147483648/, i31 /2147483648/
c     Seeds get initialized in ranini
      data dielcau /1.0/
      data hcprot_p/0.5,-0.8660254,0.0, +0.8660254,0.5,0.0, 0.0,0.0,1.0/
      data hcprot_m/0.5,+0.8660254,0.0, -0.8660254,0.5,0.0, 0.0,0.0,1.0/
c     data ishift_pm /7*0,6*1,6*(-1)/
      data ishift_pm /7*0,3*1,3*0,-1,-1,-1,3*0/
c     Zero out input variables
      data iop/2,22*0,1,176*0/,idebug /200*0/
c*****Initialize distribution function parameters
      data rdmx/0.0/,ri/0.05/,rfsslv/0.0/,empslv/0.0/,egrslv/0.0/,
     -  rssmin/0.0/,rssmax/0.0/,rfsslt/0.0/,empslt/0.0/,egrslt/0.0/,
     -  ksltmn/0/,dmnslt/0.0/,dmxslt/0.0/,dmnslv/0.0/,dmxslv/0.0/,
     -  emnslt/0.0/,egpslt/0.0/,emnslv/0.0/,egpslv/0.0/,
     -  ipxt1/0/,ipxt2/0/,nmake /0/,nbreak /0/
c*****Initialize variables that may be left uninitialized
      data e0o/0.d0/,e1o/0.d0/,e0o12/0.d0/,e0o6/0.d0/,e0o1/0.d0/,
     -  e1o12/0.d0/,e1o6/0.d0/,e1o1/0.d0/,
     -  rccon /0.0/,cplpar/0.0/,uspar0/0.0/,uspar1/0.0/,ptiexp/0,0,0/,
     -  cplmin/0.0/,cplmax/0.0/,c0cplh/0.0/,p0cplh/0.0/,
     -  islvrep /1/,nrans /0/,numrun/1/,nhstvers/1/, namlenf /0/,
     -  nmcrec /1/, nmcrep /1/, nmcadp /1/,nrecd /0/,nmccd /0/,
     -  nmccgd /0/,nmolec /0/, nslv /0/, natoms /0/,
     -  newrfs /0/,ncntin /0/,nsolvfix /0/,isltmove /0/,isltsmpl /0/,
     -  ichsegwarn /0/,ipdbcherr /11*0/,fcintra /1.0/, ipfmod /9*0/,
     -  epsrf /-1.0/,ionemessage /0/,icrefok /0/,ixrefok /0/
      data mixrule /0,0,1,1,1,0,0,0,0,1,0/
c     nslvst is the number of centers on the solvent used in Slt-slv eng calc.
      data nslvst /3,7,3,3,3,3,3,4,3,0,0/
c     maxtyp is the maximum number of types for each slt-slv potential.
      data maxtyp /#AT,50,#AT,#AT,#AT,#AT,#AT,#AT,#AT,99,99/
      data eps0_ddd /1.0/,a_ddd /1.0/,rlambda_ddd /0.0/,rk_ddd /0.0/,
     -  rdiv_ddd /0.1/,ngrid_ddd /301/
c     Most 1-4 interaction factors are set to Amber default
c     Charmm: (1.0,1.0); OPLS: (0.5,0.5)
      data es14fac/4*0.8333333,1.0,2*0.8333333,0.5,3*0.8333333/,
     -  vdw14fac/4*0.5,1.0,6*0.5/
      data scalefactors /8*1.0/
      end
      subroutine pfpinp(ipftyp,ntyp)
c#    MMC routine  35 lstmod: 03/30/16
c*****Read in new atom-type information
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      common /frslvr/ fsrad(#AT,11)
      character*4 ipf
      character*8 namh2o,nammcy
      character*32 namstp
      common /pfnames/ ipf(11),namstp(11),namh2o(9),nammcy(3)
      character*4 namfcg,namfcg0
      character*20 nmlfcg,nmlfcg0
      common /fcgnam/ igrdup(100),namfcg0(100),namfcg(100),
     -  nmlfcg0(100),nmlfcg(100)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*80 line
      common /inpline/ line,lineno,icol
      character*6 pfl,pflabifc(#AT)
c     Potential type, no of types to input
      if (ipftyp .lt. 0) return
      ipfmod(ipftyp)=1
      if (ipftyp .eq. 2) then
        if (MYRANK .eq. 0) write (iout,2006) ipftyp
        inperr=inperr+1
      end if
      if (MYRANK .eq. 0) write (iout,2004) ipf(ipftyp),ntyp
      do i=1,maxtyp(ipftyp)
        pflabifc(i)=pflab(i,ipftyp)
      end do
      do i=1,ntyp
c       New type index, funct. group and first shell radius, pf label
        irectx=17
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=9900) ityp,ifc,rfshl,pfl
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1317) ityp,ifc,rfshl,pfl
        call leftadjust(pfl,pfl,6)
        if (pfl .ne. '      ') then
          call find(pfl,1,maxtyp(ipftyp),pflabifc,itypfound,6)
        else
          itypfound=0
        end if
        if (ityp .eq. 0 .and. pfl .eq. '    ') then
c         Index or label is reqired
          if (MYRANK .eq. 0) write (iout,2008)
          inperr=inperr+1
        else if (ityp .eq. 0 .and. itypfound .gt. 0) then
c         Modify existing type - get type number from label
          ityp=itypfound
          if (MYRANK .eq. 0) write (iout,2003) ityp,pfl,ipf(ipftyp)
          nwarn=nwarn+1
        else if (ityp .eq. 0 .and. itypfound .eq. 0) then
c         Index was missing, but label is unknown
          if (MYRANK .eq. 0) write (iout,2009) pfl,ipf(ipftyp)
          inperr=inperr+1
        else if (itypfound .gt. 0 .and. ityp .gt. 0 .and.
     -           ityp .ne. itypfound) then
c         Attempt to introduce new index for existing label
          if (MYRANK .eq. 0) write (iout,2010) pfl,ipf(ipftyp)
          inperr=inperr+1
        end if
        if (ityp .gt. maxtyp(ipftyp) .or. ityp .lt. 1) then
          if (MYRANK .eq. 0) write (iout,2000) ityp
          inperr=inperr+1
          ityp=maxtyp(ipftyp)
        end if
        if (pfl .ne. '    ') pflab(ityp,ipftyp)=pfl
        if (ifc .eq. 0) ifc=98
        ifcnos(ityp,ipftyp)=ifc
        fsrad(ityp,ipftyp)=rfshl
        write (iout,2002) ityp,pfl,rfshl,namfcg0(ifc)
        irectx=18
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1001,err=9900) ian
        if (ian .gt. 0) then
          if (ipftyp .eq. 1) then
c           Clementi library
            read (line,1001,err=9900) ian,c6clm(ityp,1),c6clm(ityp,2),
     -        c12clm(ityp,1),c12clm(ityp,2)
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1002,err=9900) c1clm(ityp,1),c1clm(ityp,2)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13181)
     -        ian,c6clm(ityp,1),c6clm(ityp,2),
     -        c12clm(ityp,1),c12clm(ityp,2),c1clm(ityp,1),c1clm(ityp,2)
          else if (ipftyp .eq. 3) then
c           Kollman et al. library  (1999-2002)
            read (line,1003,err=9900) ian,rminamb02(ityp),
     -        enminamb02(ityp)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13182)
     -        ian,rminamb02(ityp),enminamb02(ityp)
            enminamb02(ityp)=abs(enminamb02(ityp))
            sigma=rminamb02(ityp)/2**(1.0/6.0)
            if (MYRANK .eq. 0) write (iout,2011) ityp,pfl,
     -        iatnam(ian),rminamb02(ityp),sigma,enminamb02(ityp)
          else if (ipftyp .eq. 4) then
c           Kollman et al. library (DB94)
            read (line,1003,err=9900) ian,rmin94(ityp),enmin94(ityp)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13182)
     -        ian,rmin94(ityp),enmin94(ityp)
            enmin94(ityp)=abs(enmin94(ityp))
            sigma=rmin94(ityp)/2**(1.0/6.0)
            if (MYRANK .eq. 0) write (iout,2011) ityp,pfl,
     -        iatnam(ian),rmin94(ityp),sigma,enmin94(ityp)
          else if (ipftyp .eq. 5) then
c           Charmm (Parm 22)
            read (line,1001,err=9900) ian,rmincha(ityp),emincha(ityp),
     -        rmincha14(ityp),emincha14(ityp)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13182)
     -        ian,rmincha(ityp),emincha(ityp),
     -        rmincha14(ityp),emincha14(ityp)
            emincha(ityp)=abs(emincha(ityp))
            emincha14(ityp)=abs(emincha14(ityp))
            if (rmincha14(ityp) .eq. 0.0 .and.
     -          emincha14(ityp) .eq. 0.0) then
                rmincha14(ityp)=rmincha(ityp)
                emincha14(ityp)=emincha(ityp)
            end if
            if (MYRANK .eq. 0) then
              sigma=rmincha(ityp)/2**(1.0/6.0)
              write (iout,2012) ityp,pfl,
     -          iatnam(ian),rmincha(ityp),sigma,emincha(ityp)
              sigma=rmincha14(ityp)/2**(1.0/6.0)
              write (iout,2012) ityp,pfl,
     -          iatnam(ian),rmincha14(ityp),sigma,emincha14(ityp),
     -          ' (1-4 interactions)'
            end if
          else if (ipftyp .eq. 6) then
c           Berendsen-van Gunsteren library (Gromos87)
            read (line,1001,err=9900) ian,c6bvg(ityp),c12bvg(ityp),
     -        c6bvg14(ityp),c12bvg14(ityp)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13183)
     -       ian,c6bvg(ityp),c12bvg(ityp),c6bvg14(ityp),c12bvg14(ityp)
            c6bvg(ityp)=sqrt(abs(c6bvg(ityp)))
            c12bvg(ityp)=sqrt(c12bvg(ityp))
            if (c6bvg14(ityp) .eq. 0.0 .and.
     -          c12bvg14(ityp) .eq. 0.0) then
              c6bvg14(ityp)=c6bvg(ityp)
              c12bvg14(ityp)=c12bvg(ityp)
            else
              c6bvg14(ityp)=sqrt(c6bvg14(ityp))
              c12bvg14(ityp)=sqrt(c12bvg14(ityp))
            end if
            if (MYRANK .eq. 0) then
              rmin=(2.0*c12bvg(ityp)/c6bvg(ityp))**(1.0/6.0)/2.0
              sigma=rmin*2**(1.0/6.0)
              eps=(c6bvg(ityp)**2/c12bvg(ityp))/4.0
              write (iout,2011) ityp,pfl,
     -          iatnam(ian),rmin,sigma,eps
              rmin=(2.0*c12bvg14(ityp)/c6bvg14(ityp))**(1.0/6.0)/2.0
              sigma=rmin*2**(1.0/6.0)
              eps=(c6bvg14(ityp)**2/c12bvg14(ityp))/4.0
              write (iout,2011) ityp,pfl,
     -          iatnam(ian),rmin,sigma,eps,' (1-4 interactions)'
            end if
          else if (ipftyp .eq. 7) then
c           Berendsen-van Gunsteren library (Gromos96)
            read (line,1001,err=9900) ian,c6gro(ityp),c12gro(ityp),
     -        c6gro14(ityp),c12gro14(ityp)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13183)
     -        ian,c6gro(ityp),c12gro(ityp),c6gro14(ityp),c12gro14(ityp)
            c6gro(ityp)=sqrt(c6gro(ityp))
            c12gro(ityp)=sqrt(c12gro(ityp))
            if (c6gro14(ityp) .eq. 0.0 .and.
     -          c12gro14(ityp) .eq. 0.0) then
              c6gro14(ityp)=c6gro(ityp)
              c12gro14(ityp)=c12gro(ityp)
            else
              c6gro14(ityp)=sqrt(c6gro14(ityp))
              c12gro14(ityp)=sqrt(c12gro14(ityp))
            end if
            if (MYRANK .eq. 0) then
              rmin=(2.0*c12gro(ityp)/c6gro(ityp))**(1.0/6.0)/2.0
              sigma=rmin*2**(1.0/6.0)
              eps=(c6gro(ityp)**2/c12gro(ityp))/4.0
              write (iout,2011) ityp,pfl,
     -          iatnam(ian),rmin,sigma,eps
              rmin=(2.0*c12gro14(ityp)/c6gro14(ityp))**(1.0/6.0)/2.0
              sigma=rmin*2**(1.0/6.0)
              eps=(c6gro14(ityp)**2/c12gro14(ityp))/4.0
              write (iout,2011) ityp,pfl,
     -          iatnam(ian),rmin,sigma,eps,' (1-4 interactions)'
            end if
          else if (ipftyp .eq. 8) then
c           Jorgensen's OPLS
            read (line,1003,err=9900)
     -        ian,sigjrg(ityp),epsjrg(ityp),qjrg(ityp)
            if (MYRANK .eq. 0) then
              if (iop(24) .gt. 0) write (iout,13185)
     -          ian,sigjrg(ityp),epsjrg(ityp),qjrg(ityp)
              rmin=sigjrg(ityp)*2**(1.0/6.0)
              write (iout,2011) ityp,pfl,
     -          iatnam(ian),rmin,sigjrg(ityp),epsjrg(ityp),qjrg(ityp)
              if (qjrg(ityp) .eq. 0.0) then
                write (iout,2013) ityp
                nwwarn=nwwarn+1
              end if
            end if
          else if (ipftyp .eq. 9) then
c           Hard spheres
            read (line,1003,err=9900) ian,sighs(ityp)
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,13184)
     -        ian,sighs(ityp)
          end if
          iatnos(ityp,ipftyp)=ian
          if (ian .lt. 1 .or. ian .gt. 99) then
            if (MYRANK .eq. 0) write (iout,2001) ian
            inperr=inperr+1
          else if (iatnam(ian) .eq. '    ') then
            if (MYRANK .eq. 0) write (iout,2005) ian
            nwarn=nwarn+1
          end if
        else if (iatnos(ityp,ipftyp) .eq. 0) then
          if (MYRANK .eq. 0) write (iout,2007) ityp,ipftyp
          inperr=inperr+1
        end if
      end do
      return
9900  call invalidform(iout,irectx)
1000  format(2i5,f10.0,1x,a6)
1001  format(i5,4e15.6)
1002  format(2f10.0)
1003  format(i5,3e15.6)
1317  format(' rectype 17  : ',2i5,f10.5,1x,a4)
13181 format(' rectype 18a : ',i5,4e15.6,/,2f10.10)
13182 format(' rectype 18b : ',i5,4e15.6)
13183 format(' rectype 18c : ',i5,4e15.6)
13184 format(' rectype 18d : ',i5,3e15.6)
13185 format(' rectype 18e : ',i5,3e15.6)
2000  format(' ***** ERROR: invalid atomtype=',i8)
2001  format(' ***** ERROR: invalid atomic number=',i8)
2002  format(' Atom type # ',i3,' label:',a,' first shell radius=',
     -  f6.2,' A functional group (if known):',a)
2003  format(' ----- WARNING: type',i3,' (',a,') is redefined ',
     -  'for potential ',a4)
2004  format(' Potential modification for potential library ',a4,/,
     -  ' Number of new atom types=',i3)
2005  format(' ----- WARNING: atom name for atomic number ',i3,
     -  ' is not coded yet')
2006  format(' ***** ERROR: EPEN/QPEN potentials are not to be',
     -  ' modified')
2007  format(' ***** ERROR: non-bonded parameters are unspecified for',
     -  ' new atom type ',i3,' potential type',i2)
2008  format(' ***** ERROR: both type number and label are missing')
2009  format(' ***** ERROR: potential label (type) ',a,
     -  ' for potential library',a4,' is not defined',/,
     -  14x,'For new types a nonzero atomtype is required')
2010  format(' ***** ERROR: potential label ',a4,' for potential ',a4,
     -  ' already exists',/,14x,'To modify it, set ityp to zero')
2011  format(i4,1x,a,' Element: ',a,' Rmin=',f6.3,' A sigma=',f6.3,
     -  ' A epsilon/Emin=',f8.5,' kcal/mol charge=',f6.3)
2012  format(i4,1x,a,' Element: ',a,' Rmin=',f6.3,' A sigma=',f6.3,
     -  ' A epsilon/Emin=',f8.5,' kcal/mol ',a)
2013  format(' ===== STRONG WARNING: OPLS partial charge is zero ',
     -  '(missing) for atom type',i4)
      end
      subroutine pfparaminp(keyno)
c#    MMC routine  35/a lstmod: 12/23/17
c*****Read in new atom-type information
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      character*4 keyno
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      character*4 iatnam
      character*6 pflclm,pflqpn,pflamb02,pflkol94,pflcha,pflbvg,
     -  pflgro,pfljrg,pflhs,pflan,pfldu
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),ianfg(99),
     -  ianclm(#AT),ianqpn(#AT),ianamb(#AT),iankol94(#AT),
     -  iancha(#AT),ianbvg(#AT),iangro(#AT),ianjrg(#AT),ianhs(#AT),
     -  ian(#AT),iandum(#AT),
     -  ifcclm(#AT),ifcqpn(#AT),ifcamb(#AT),ifckol94(#AT),ifccha(#AT),
     -  ifcbvg(#AT),ifcgro(#AT),ifcjrg(#AT),ifchs(#AT),ifcan(#AT),
     -  ifcdu(#AT),
     -  pflclm(#AT),pflqpn(#AT),pflamb02(#AT),pflkol94(#AT),pflcha(#AT),
     -  pflbvg(#AT),pflgro(#AT),pfljrg(#AT),pflhs(#AT),pflan(#AT),
     -  pfldu(#AT)
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*4 rectyp
      character*6 newlab(#AT),lab,labx
      character*80 parmfile
      character*132 line
      dimension newian(#AT)
      call zeroiti(newian,0,#AT)
      if (iop(24) .gt. 0) write (iout,*) 'Input ',keyno,' parameters'
      if (keyno .eq. 'CHRM' .or. keyno .eq. 'OPLS') then
c       Charmm or OPLS in Charmm format
        call getname(parmfile,lparmfile,1,80)
        open(unit=90,status='old',file=parmfile(1:lparmfile),
     -    form='FORMATTED',iostat=iopenok)
        if (iopenok .gt. 0) then
          if (MYRANK .eq. 0) write (iout,2000) parmfile(1:lparmfile)
          inperr=inperr+1
          return
        else if (iop(24) .gt. 0) then
          if (MYRANK .eq. 0)
     -      write (iout,*) 'File ',parmfile(1:lparmfile),' opened'
        end if
        call getint(iswitchcase,0,1,0)
        if (iswitchcase .eq. 1 .and. MYRANK .eq. 0) write (iout,2010)
        nparam=#AT
        if (keyno .eq. 'CHRM') then
          do while (pflcha(nparam) .eq. '      ')
            nparam=nparam-1
          end do
        else
          do while (sigjrg(nparam) .eq. 0.0)
            nparam=nparam-1
          end do
        end if
        nparam_org=nparam
        write (iout,2012) nparam
        if (keyno .eq. 'CHRM') then
c         Read labels, find out atomic numbers
          line(1:1)='*'
          do while (line(1:4) .ne. 'ATOM')
            read (90,1000) line
          end do
          nl=0
          ll=2
          rectyp='ATOM'
          do while (line(1:4) .ne. 'BOND')
            call blankout(line,1,132)
            read (90,1000,end=777) line
            call lastchar(line,ll,132)
            iskip=0
            if (ll .lt. 6) iskip=1
            if (line(1:5) .eq. 'BONDS') iskip=1
            if (line(1:1) .eq. '!') iskip=1
            if (line(1:1) .eq. ' ' .or. line(1:1) .eq. tab) then
              ic=1
              call nextchar(line(1:80),ic,0,inpt,iout)
              if (ic .gt. 80) iskip=1
            end if
            if (iskip .eq. 0) then
              if (ll .gt. 1) then
                nl=nl+1
                if (nl .gt. #AT) then
                  write (iout,2009) #AT
                  inperr=inperr+1
                  nl=nl-1
                end if
                newlab(nl)='      '
                read (line(5:ll),*,err=999,end=999) ix,newlab(nl),wm
                if (iswitchcase .eq. 1) call lowtoup(newlab(nl),6)
                mw=wm
                if (mw .eq. 0) newian(nl)=89
                if (mw .eq. 1) newian(nl)=1
                if (mw .eq. 12) newian(nl)=6
                if (mw .eq. 14) newian(nl)=7
                if (mw .eq. 15 .or. mw .eq. 16) newian(nl)=8
                if (mw .eq. 18) newian(nl)=9
                if (mw .eq. 26) newian(nl)=13
                if (mw .eq. 30) newian(nl)=15
                if (mw .eq. 32) newian(nl)=16
                if (mw .eq. 35) newian(nl)=17
                if (mw .eq. 79) newian(nl)=35
                if (mw .eq. 126) newian(nl)=53
                if (newian(nl) .eq. 0) then
                  write (iout,2001) wm
                  nwwarn=nwwarn+1
                else if (iop(24) .gt. 0) then
                  write (iout,2002) nl,newlab(nl),newian(nl)
                end if
              end if
            end if
          end do
        end if
        rectyp='NONB'
        do while (line(1:9) .ne. 'NONBONDED')
          call blankout(line,1,132)
          read (90,1000,end=777) line
        end do
c       Skip continuation line(s)
        call lastchar(line,ll,132)
        do while (line(ll:ll) .eq. '-')
          call blankout(line,1,132)
          read (90,1000) line
          call lastchar(line,ll,132)
        end do
        do while (line(1:5) .ne. 'HBOND' .and. line(1:5) .ne. 'NBFIX')
          call blankout(line,1,132)
          read (90,1000,end=888) line
          call lastchar(line,ll,132)
          iskip=0
          if (ll .lt. 6) iskip=1
          if (line(1:5) .eq. 'HBOND') iskip=1
          if (line(1:1) .eq. '!') iskip=1
          if (line(1:1) .eq. ' ' .or. line(1:1) .eq. tab) then
            ic=1
            call nextchar(line(1:80),ic,0,inpt,iout)
            if (ic .gt. 80) iskip=1
          end if
          if (iskip .eq. 0) then
c           Not a comment or blank line
c           First read the main params for sure
            lab='      '
            read (line,*,err=999,end=999) lab,x,eps,rmin2
            no14=1
            read (line,*,err=100,end=100)
     -        labx,x,xx,xxx,xxxx,eps14,rmin214
            no14=0
100         if (no14 .eq. 1) then
              eps14=eps
              rmin214=rmin2
            end if
c            write (6,9988) lab,eps,rmin2,eps14,rmin214
c9988        format(1x,a4,' eps,rmin2=',2f10.5,' eps14,rmin214=',2f10.5)
            if (iswitchcase .eq. 1) call lowtoup(lab,6)
            if (keyno .eq. 'CHRM') then
              call find(lab,1,maxtyp(5),pflcha,ifound,6)
              if (ifound .gt. 0) then
c               Label found - replace constants
                if (iop(24) .gt. 0)
     -            write (iout,2004) lab,'replaced',ifound,eps,rmin2
              else
c               New label - add constants
                nparam=nparam+1
                if (nparam .le. #AT) then
                  if (iop(24) .gt. 0)
     -              write (iout,2004) lab,'added',nparam,eps,rmin2
                  ifound=nparam
                  pflcha(nparam)=lab
                  call find(lab,1,nl,newlab,new,6)
                  if (new .eq. 0) then
                    write (iout,2007) lab
                    nwwarn=nwwarn+1
                    iancha(ifound)=99
                  else
                    iancha(ifound)=newian(new)
                  end if
                  ifccha(ifound)=98
                else
                  write (iout,2005) #AT,lab
                  inperr=inperr+1
                  go to 888
                end if
              end if
              sigcha(ifound)=2.0*rmin2/(2.0**(1.0/6.0))
              sigcha14(ifound)=2.0*rmin214/(2.0**(1.0/6.0))
              epscha(ifound)=-eps
              epscha14(ifound)=-eps14
              rmincha(ifound)=rmin2
              rmincha14(ifound)=rmin214
              emincha(ifound)=-eps
              emincha14(ifound)=-eps14
            else
              call find(lab,1,maxtyp(8),pfljrg,ifound,6)
              if (ifound .gt. 0) then
c               Label found - replace constants
                if (iop(24) .gt. 0)
     -            write (iout,2004) lab,'replaced',ifound,eps,rmin2
              else
c               New label - add constants
                nparam=nparam+1
                if (nparam .le. #AT) then
                  if (iop(24) .gt. 0)
     -              write (iout,2004) lab,'added',nparam,eps,rmin2
                  ifound=nparam
                  pfljrg(nparam)=lab
                  ianjrg(nparam)=ianum(lab,1,iout,inperr)
                  ifcjrg(nparam)=98
                else
                  write (iout,2005) #AT,lab
                  inperr=inperr+1
                  go to 888
                end if
              end if
              sigjrg(ifound)=2.0*rmin2/(2.0**(1.0/6.0))
              epsjrg(ifound)=-eps
            end if
          end if
        end do
      end if
888   if (nparam .gt. nparam_org) write (iout,2006) nparam_org,nparam
      if (nparam .eq. nparam_org) write (iout,2008) nparam_org
      close (90)
      return
777   write (iout,2011) rectyp,line
      return
999   write (iout,2003) rectyp,line(1:ll)
      inperr=inperr+1
      close (90)
      return
1000  format(a)
2000  format(' ***** ERROR: parameter file ',a,' was not opened')
2001  format(' ==== STRONG WARNING : Could not find atomic number for',
     -  ' molecular weight ',f6.2)
2002  format(i4,' label=',a,' atomic number=',i3)
2003  format(' ***** ERROR: invalid ',a,' record: ',a)
2004  format(' Potential label=',a,' parameters ',a,' code=',i3,
     -  ' eps=',f8.4,' rmin2=',f8.4)
2005  format(' ***** ERROR: number of parameters exceeds limit (',i4,
     -  ') - increase the parameter # AT and recompile',/,
     -  7x,'Last label read:',a4)
2006  format(' Number of parameters increased from ',i4,' to ',i4)
2007  format(' ===== STRONG WARNING: label ',a,' is not found in the ',
     -  'atom list')
2008  format(' Number of parameters is unchanged:',i4)
2009  format(' ***** ERROR: number of ATOM records exceeds',i5,' - ',
     -  'increase the parameter # AT and recompile.',/,' This will ',
     -  'need changes in some of the data statements in the block data')
2010  format(' Lower-case potenial labels will be switched to upper ',
     -  'case')
2011  format(' ***** ERROR: run out of data while reading ',a,
     -  ' last line:',/,a)
2012  format(' Number of parameters stored=',i3)
      end
      subroutine lowtoup(label,len)
c#    MMC routine  35/a lstmod: 10/24/14
      character*(*) label
      character*1 charlist
      common /characters/ charlist(52)
c     Convert L.C. characters to u.c.
      do ic=1,len
        if (label(ic:ic) .ne. ' ') then
          ifound=0
          do k=27,52
            if (label(ic:ic) .eq. charlist(k)) then
              label(ic:ic)=charlist(k-26)
              go to 110
            end if
          end do
        end if
110     continue
      end do
      return
      end
      subroutine atommod(nmod)
c#    MMC routine  36 lstmod: 01/09/04
c*****Read in new atom descriptions
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*80 line
      common /inpline/ line,lineno,icol
      character*4 namr
      irectx=10
      do i=1,nmod
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) ian,ianpr,ifgr,namr,awr,vdwr,ramaxr,nvr
        if (iop(24) .gt. 1 .and. MYRANK .eq. 0) write (iout,2000)
     -    ian,ianpr,ifgr,namr,awr,vdwr,ramaxr,nvr
        if (ian .lt. 1 .or. ian .gt. 99) then
          if (MYRANK .eq. 0) write (iout,1002) ian
          inperr=inperr+1
        end if
        if (namr .ne. '    ') iatnam(ian)=namr
        if (ianpr .ne. 0) ianprt(ian)=ianpr
        if (awr .ne. 0.0) aw(ian)=awr
        if (vdwr .ne. 0.0) vdw(ian)=vdwr
        if (ifgr .ne. 0) ianfg(ian)=ifgr
        if (ramaxr .ne. 0.0) ramax(ian)=ramaxr
        if (nvr .ne. 0) nval(ian)=nvr
        if (MYRANK .eq. 0) write (iout,2001) ian,iatnam(ian),aw(ian),
     -    vdw(ian),ianfg(ian),ianprt(ian),ramax(ian),nval(ian)
      end do
      call printljconst(0,nmolec,0,0,0,0,1,nwarn,iout)
      return
999   if (MYRANK .eq. 0) write (iout,1001) line
      inperr=inperr+1
      return
1000  format(3i5,1x,a4,3f10.0,i5)
1001  format(' ***** ERROR: invalid input for atom modification: ',a)
1002  format(' ***** ERROR: invalid atomic number to modify: ',i5)
2000  format(' rectype 10  :',3i5,1x,a4,3f10.0,i5)
2001  format(' Atomic number',i3,' modified to name=',a4,' A.W.=',f10.5,
     -  ' amu VdW rad=',f6.3,' A FCG=',i2,' Atno to print:',i3,/,
     -  17x,' Max radius for bond=',f6.3,' A Valence=',i2)
      end
      subroutine initpf(noutwarn,nsplitwarn,noutwmin,noutwmax,
     -  nsplitwmin,nsplitwmax,nsttanoclone,qslvdip,naflxrange,
     -  iaflxrange,maxflxrange)
c#    MMC routine  37 lstmod: 12/03/20
c*****Initialize/convert potential function constants, create solvent
      dimension qslvdip(#SV)
      character*4 iatnam
      character*6 pflab
      dimension iaflxrange(2,maxflxrange)
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      common /param/ edgexyz(3),edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /cqpen/ qnn(#TN,#VN),qne(#TN,#VE),qen(#TE,#VN),
     -  qee(#TE,#VE),aee(#TE,#VE),bee(#TE,#VE),cee(#TE,#VE),
     -  iopict,nsltn,nslvn,nslte,nslve
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /bondmod/ nmake,imake(2,250),nbreak,ibreak(2,250),nhhb,nhrb
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /clemcw/ cwclem(10,2)
      common /mcydat/ qq,dqq,a1,a2,a3,a4,b1,b2,b3,b4,ab1,ab2,ab3,ab4,qqq
      common /wlj3q/ abljqh(3,8)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      character*4 ipf
      character*8 namh2o,nammcy
      character*32 namstp
      common /pfnames/ ipf(11),namstp(11),namh2o(9),nammcy(3)
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      character*80 line
      common /inpline/ line,lineno,icol
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      character*6 pflabifc(#AT),pflabmiss(#AT)
c     autokc, autoa: conversion multiplier from a.u. to kcal/mol, Angstrom
      data autokc/627.55/,autoa/0.529167/,rlpw /0.0/,jamin /0/
c     Convert to kcal/A
      dielc=dielcau/(autokc*autoa)
      do i=1,99
        ramax2(i)=ramax(i)**2
      end do
c     Determine group counts
      if (nstfa0 .gt. 0) then
c       Free energy solute group count
        nstfg0=0
        nstfg1=0
        call grouplist(1,nstfa0,1,0,igrslt,nstfg0,
     -    ifgrslt,ilgrslt,0,#GR,'GR')
        if (nsltcp(iop(30)+1) .eq. 1) nstfg=nstfg0
        if (nsltcp(iop(30)+1) .eq. 2) then
          call grouplist(nstfa0+1,nstfa,nstfg0+1,nstfg0,igrslt,nstfg,
     -      ifgrslt,ilgrslt,0,#GR,'GR')
        else if (nsltcp(iop(30)+1) .eq. 3) then
          call grouplist(nstfa0+1,2*nstfa0,nstfg0+1,nstfg0,igrslt,
     -      nstfg1,ifgrslt,ilgrslt,0,#GR,'GR')
          call grouplist(2*nstfa0+1,nstfa,nstfg1+1,nstfg1,igrslt,
     -      nstfg,ifgrslt,ilgrslt,0,#GR,'GR')
        end if
        iafs=nstfa+1
        igfs=nstfg+1
      else
        nstfg=0
        nstfg0=0
        nstfm=0
        nstfm0=0
        iafs=1
        igfs=1
      end if
      if (iop(85) .eq. 0) then
        call grouplist(iafs,nstta,igfs,igfs-1,igrslt,nsttg,
     -    ifgrslt,ilgrslt,0,#GR,'GR')
      else
        if (ilastm(nsttm) .gt. nstta) then
          iop(85)=0
          if (MYRANK .eq. 0) write (iout,2158) ilastm(nsttm),nstta
          inperr=inperr+1
        end if
      end if
      if (iop(85) .gt. 0) then
        do im=1,nsttm
          if (ilastm(im) .lt. nstta) then
            if (igrslt(ilastm(im)) .eq. igrslt(ilastm(im)+1)) then
              iop(85)=0
              if (MYRANK .eq. 0)
     -          write (iout,9133) im,ilastm(im),igrslt(ilastm(im))
              inperr=inperr+1
            end if
          end if
        end do
        if (ilastm(nsttm) .lt. nstta) then
          iop(85)=2
          if (MYRANK .eq. 0) write (iout,9134) ilastm(im),nstta
          nwarn=nwarn+1
        end if
        igfs=1
        nstg0=0
        do im=1,nsttm
          call grouplist(ifirstm(im),ilastm(im),igfs,nstg0,igrslt,nsttg,
     -      ifgrslt,ilgrslt,0,#GR,'GR')
          igfs=nsttg+1
          nstg0=nsttg
        end do
        if (iop(85) .eq. 2) then
c         Get grouplist for the atoms not pre-assigned to molecules
          call grouplist(ilastm(nsttm)+1,nstta,igfs,nstg0,igrslt,nsttg,
     -      ifgrslt,ilgrslt,0,#GR,'GR')
          igfs=nsttg+1
          nstg0=nsttg
        end if
      end if
      call checkdim(ifail,iout,inperr,'GR',nsttg,0,0,0)
      call setljconst(maxtyp)
      if (iop(46) .eq. 1) then
c       Set solute charges to zero
        do i=1,nstta
          qslt(i)=0.0
        end do
      end if
      do j=1,nstta
        do i=1,2
          c6ji(j,i)=0.0
          c12ji(j,i)=0.0
          qji(j,i)=0.0
        end do
      end do
      nslvn=0
      nslve=0
c     Atomic number is identical with atomic type in case of QPEN
      do i=1,#AT
        iatnos(i,2)=i
        iatnos(i,10)=i
      end do
c     Set default water for solvent
      if (iop(26) .lt. 4) then
        namslv='HOH '
        labslv(1)='O   '
        labslv(2)='H1  '
        labslv(3)='H2  '
        labslv(4)='LP  '
        labslv(5)='LP  '
      else
        if (nslv .eq. 0) then
          if (MYRANK .eq. 0) write (iout,9124)
          inperr=inperr+1
        end if
        iop(39)=2
      end if
c     Transfer stored a, b and qh parameters for the water potential selected
      call zeroit(epsslv,#SV)
      call zeroit(sigslv,#SV)
      if (iop(26) .eq. 0) then
c-------MCY-type water-water
        if (iop(37) .gt. 0) then
          a1=cwclem(1,iop(37))
          a2=cwclem(2,iop(37))
          a3=cwclem(3,iop(37))
          a4=cwclem(4,iop(37))
          b1=cwclem(5,iop(37))
          b2=cwclem(6,iop(37))
          b3=cwclem(7,iop(37))
          b4=cwclem(8,iop(37))
          qq=cwclem(9,iop(37))
          rlpw=cwclem(10,iop(37))
        else
          if (MYRANK .eq. 0) write (iout,9120)
          inperr=inperr+1
        end if
c       ab1,ab2,ab3,ab4: MCY exponential term multipliers for force calc
        ab1=a1*b1
        ab2=a2*b2
        ab3=a3*b3
        ab4=a4*b4
c       dqq: q(hydrogen)*q(oxygen) for MCY-type water
        dqq=2.0*qq
c       qqq: 4*q(hydrogen)**2 for MCY-type water
        qqq=4.0*qq
        qh=sqrt(qq)
      else if (iop(26) .ge. 1 .and. iop(26) .le. 3) then
c-------TIP3P/TIP4P/TIP5P ... water-water
        if (iop(37) .gt. 0) then
          alj6=abljqh(1,iop(37))
          blj12=abljqh(2,iop(37))
          qh=abljqh(3,iop(37))
        end if
        call c6c12toes(alj6,blj12,sigmaw,epsilonw)
        sigslv(1)=sigmaw
        epsslv(1)=epsilonw
c       alj6, blj12: coefs of the 1/r**6 and 1/r**12
c       alj66, blj122: 1/r**6, 1/r**12 coefs to use for force calj
        alj66=6.0*alj6
        blj122=12.0*blj12
c       qhh, qho, qoo: product of charges on H and H; H and O; O and O; resp.
        qhh=qh**2*(autokc*autoa)
        qho=2.0*qhh
        qoo=4.0*qhh
        if (iop(125) .eq. 1) then
          qhh=0.0
          qho=0.0
          qoo=0.0
        end if
        rlpw=0.0
        if (iop(26) .eq. 2) rlpw=0.15
        if (iop(26) .eq. 3) then
          rlpw=0.70
          labslv(4)='LP1 '
          labslv(5)='LP2 '
          do i=2,5
            do j=2,5
              qqt5(i,j)=qhh
              if (i .lt. 4 .and. j .gt. 3 .or.
     -            j .lt. 4 .and. i .gt. 3) qqt5(i,j)=-qhh
            end do
          end do
          iop(39)=2
        end if
c     else
c-------General solvent setup will be taken care of later
      end if
      npfmiss=0
      npftypmiss=0
c     Members of the ig-th group are in igrslt from ifgrslt(ig) to ilgrslt(ig)
      do ig=1,nsttg
c       Determine pf type for this group
        ichange=0
        do ia=ifgrslt(ig),ilgrslt(ig)
          if (iopslt(ia) .ne. 0) ichange=ia
        end do
        if (ichange .eq. 0) then
c         Set all atoms to the type sepcified by SUPT
          ipfgr(ig)=iop(3)
          if ((iop(30) .eq. 5 .or. iop(30) .eq. 6) .and.
     -        ifgrslt(ig) .gt. nstfg0 .and. ifgrslt(ig) .le. nstfg)
     -          ipfgr(ig)=iop(29)
        else
c         Check group if types don't conflict
          do ia=ifgrslt(ig),ilgrslt(ig)
            if (iopslt(ia) .gt. 0 .and.
     -        iopslt(ia) .ne. iopslt(ichange)) then
              if (MYRANK .eq. 0)
     -          write (iout,9100) ig,iopslt(ia),ipfgr(ig)
              inperr=inperr+1
            end if
          end do
          ipfgr(ig)=iopslt(ichange)
        end if
        do ia=ifgrslt(ig),ilgrslt(ig)
c         iopslt(ia): slt-slv pot code for atom ia
          iopslt(ia)=ipfgr(ig)
          if (iopslt(ia) .eq. 10) then
c           Atom type is atomic number
            pflabslt(ia)='      '
            if (iclslt(ia) .gt. 0) then
              ianslt(ia)=iclslt(ia)
            else
              if (pflabslt(ia) .ne. '      ') then
                ianslt(ia)=ianum(pflabslt(ia)(1:4),0,iout,inperr)
              else
                ianslt(ia)=ianum(labslt(2,ia),0,iout,inperr)
              end if
              iclslt(ia)=ianslt(ia)
            end if
          else if (iopslt(ia) .eq. 11) then
c           Dummy atom
            ianslt(ia)=99
          else
            if (iclslt(ia) .eq. -1) then
c             Convert pf labels to pf number
              do i=1,maxtyp(iopslt(ia))
                pflabifc(i)=pflab(i,iopslt(ia))
              end do
              call find(pflabslt(ia),1,maxtyp(iopslt(ia)),
     -          pflabifc,iclslt(ia),6)
              if (iclslt(ia) .eq. 0) then
                if (MYRANK .eq. 0)
     -            write (iout,9115) pflabslt(ia),ipf(iopslt(ia)),
     -              'solute',ia
                iclslt(ia)=1
                ianslt(ia)=1
                inperr=inperr+1
                npfmiss=npfmiss+1
                call find(pflabslt(ia),1,npftypmiss,pflabmiss,ifound,6)
                if (ifound .eq. 0) then
                  npftypmiss=npftypmiss+1
                  pflabmiss(npftypmiss)=pflabslt(ia)
                end if
              end if
            else if (iclslt(ia) .gt. maxtyp(iopslt(ia))) then
              if (MYRANK .eq. 0)
     -          write (iout,9101) maxtyp(iopslt(ia)),iclslt(ia),ia
              iclslt(ia)=maxtyp(iopslt(ia))
              inperr=inperr+1
            else
              pflabslt(ia)=pflab(iclslt(ia),iopslt(ia))
            end if
            ianslt(ia)=iatnos(iclslt(ia),iopslt(ia))
            if (ianslt(ia) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,9105) iclslt(ia),ia
              inperr=inperr+1
              ianslt(ia)=1
            end if
          end if
        end do
      end do
      if (npfmiss .gt. 0 .and. MYRANK .eq. 0) write (iout,9116)
      do ia=1,nstta
        if (labslt(1,ia) .eq. '    ') labslt(1,ia)='SLTE'
        if (iatnos(iclslt(ia),iopslt(ia)) .gt. 0) then
          if (labslt(2,ia) .eq. '    ') labslt(2,ia)=pflabslt(ia)(1:4)
          if (labslt(2,ia) .eq. '    ') labslt(2,ia)=
     -      iatnam(iatnos(iclslt(ia),iopslt(ia)))
        end if
      end do
      if (iop(92) .gt. 0) then
c       Set the list of solute atoms to use
        if (naphsrange .gt. 0) then
          call zeroiti(iaphsslt,0,nstta)
          do ir=1,naphsrange
            do ia=iaphsrange(1,ir),iaphsrange(2,ir)
              iaphsslt(ia)=ianslt(ia)
            end do
          end do
        else
          call trnsfi(iaphsslt,ianslt,nstta)
        end if
      end if
c     Generate connectivity matrix
      nntest=1
      if (MYRANK .gt. 0) nntest=0
      if (iop(128) .gt. 0 .and. iop(30)+iop(85)+iop(69) .gt. 0) then
        write (iout,2005)
        iop(128)=0
        inperr=inperr+1
      end if
      if (iop(128) .eq. 0) then
        if (iop(30) .eq. 1 .or. iop(30) .eq. 2) then
          do ig=1,nstfg
            call nneiglist(cslt,ifgrslt(ig),ilgrslt(ig),ianslt,
     -        iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          end do
        else if (iop(30) .eq. 3) then
          do ig=1,nstfg
c???
            call nneiglist(cslt,ifgrslt(ig),ilgrslt(ig),ianslt,
     -        iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          end do
        else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
          call nneiglist(cslt,1,nstfa0,ianslt,iout,inperr,nwarn,
     -      nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          call nneiglist(cslt,nstfa0+1,nstfa,ianslt,iout,inperr,nwarn,
     -      nwwarn,nneig,nneiga,nneigh,ineig,#NL)
        else if (iop(30) .eq. 7 .or. iop(30) .eq. 8) then
          if (nstfa0 .eq. 0) nstfa0=nstfa/3
c         nstfm0 is the # of molecules in the first nstfa0 solute atoms
          if (iamolslt(nstfa0) .gt. 0) then
            nstfm0=iamolslt(nstfa0)
            do im=1,nstfm0
              do ic=1,3
                call nneiglist(cslt,ifirstm(im+(ic-1)*nstfm0),
     -            ilastm(im+(ic-1)*nstfm0),ianslt,iout,inperr,nwarn,
     -            nwwarn,nneig,nneiga,nneigh,ineig,#NL)
              end do
            end do
          else
            do ic=1,3
              call nneiglist(cslt,(ic-1)*nstfa0+1,ic*nstfa0,ianslt,
     -          iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
            end do
          end if
        end if
        nonnerr=0
        if (iop(85) .eq. 1) nonnerr=1
        if (iop(85) .gt. 0) then
c         Inputted solute molecule limits
          do im=1,nsttm
            call nneiglist(cslt,ifirstm(im),ilastm(im),ianslt,
     -        iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
c           Check if the molecule defined by the user is contiguous
            call clstrs(ineig,nneig,l1,ifirstm(im),ilastm(im),l2,l3,l4,
     -        0,nofcls,indexx,iout,inperr,nww,nonnerr,#ST,#GR,#NL,
     -        5,nntest)
            if (nofcls .gt. 1) then
              if (iop(58) .gt. 0) then
                write (iout,2000) im,nofcls
                inperr=inperr+1
              else
                write (iout,2001) im,nofcls
                nwwarn=nwwarn+1
              end if
            end if
          end do
          if (iop(85) .eq. 2 .and. iop(69) .eq. 0) then
c           Get neighbor list for the atoms not pre-assigned to molecules
            call nneiglist(cslt,ilastm(nsttm)+1,nstta,ianslt,iout,
     -        inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          end if
        else if (iop(69) .eq. 0) then
          call nneiglist(cslt,nstfa+1,nstta,ianslt,iout,inperr,nwarn,
     -      nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          nclone=0
        end if
      else
c       Read the bond list
        inpt_save=inpt
        inpt=iabs(ifilstat(45+iop(128)))
        call zeroiti(nneig,0,nstta)
        call readbond(iop(128),nstta,inpt,nneig,nneigh,ineig,ianslt,
     -    nstta_full,isplit_of_orig,inperr,iout,#NL,#ST)
        if (idebug(14) .gt. 0) then
          do ia=1,nstta
            write (iout,2008)ia,ianslt(ia),(ineig(in,ia),in=1,nneig(ia))
          end do
        end if
        call trnsfi(nneiga,nneig,nstta)
        iok=1
        if (iok .eq. 0) write (iout,2006) i
        inpt=inpt_save
        call clstrs(ineig,nneig,l1,1,nstta,l2,ifirstm,ilastm,0,nofcls,
     -    indexx,iout,inperr,nww,nonnerr,#ST,#GR,#NL,5,nntest)
      end if
      if (idebug(170) .gt. 0)
     -  call checknnlist(1,nstta,nneig,ineig,iout,inperr,nwwarn,nerr,1,
     -    1,0,#NL,#ST)
      if (iop(30) .eq. 7 .or. iop(30) .eq. 8) then
c       Compare neighbor list of three solute copies
        do ic=2,3
          inc=nstfa0*(ic-1)
          do ia=1,nstfa0
            if (nneig(ia) .eq. nneig(inc+ia)) then
              idiff=0
              do in=1,nneig(ia)
                if (ineig(in,inc+ia)-ineig(in,ia) .ne. inc) idiff=1
              end do
            else
              idiff=1
            end if
            if (idiff .eq. 1) then
              inperr=inperr+1
              write (iout,2003) ic,ia,inc+ia
              write (iout,2004) ia,(ineig(in,ia),in=1,nneig(ia))
              write (iout,2004) inc+ia,
     -          (ineig(in,inc+ia),in=1,nneig(inc+ia))
            end if
          end do
        end do
      end if
      if (iop(69) .gt. 0) then
c       Cloned solute - generate neighbour list in segments
        if (iop(85) .eq. 2) then
c         Part of the solute is predefined and is taken care of above
          nsttm0=nsttm
          natdone=ilastm(nsttm)
        else
          nsttm0=nstfm
          natdone=nstfa
        end if
        ia1=natdone+1
c       Calculate nn list by separately for cloned and not cloned segments
        if (iaclnf(1) .gt. ia1) then
          call nneiglist(cslt,ia1,iaclnf(1)-1,ianslt,
     -      iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          ia1=iaclnf(1)
        end if
        do icln=1,nclone
          lenclon1=iaclnl(icln)-iaclnf(icln)
          call nneiglist(cslt,ia1,ia1+lenclon1,ianslt,
     -      iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          lenclon=lenclon1+1
          nclones=ncopcln(icln)
          ia0=ia1-1
          do ic=2,nclones
            do ia=1,lenclon
              nneig(ia0+(ic-1)*lenclon+ia)=nneig(ia0+ia)
              nneiga(ia0+(ic-1)*lenclon+ia)=nneiga(ia0+ia)
              nneigh(ia0+(ic-1)*lenclon+ia)=nneigh(ia0+ia)
              do in=1,nneig(ia0+ia)
                ineig(in,ia0+(ic-1)*lenclon+ia)=
     -            ineig(in,ia0+ia)+(ic-1)*lenclon
              end do
            end do
          end do
          ia1=ia0+lenclon*nclones+1
          if (icln .eq. nclone) then
            if (ia1 .le. nstta) call nneiglist(cslt,ia1,nstta,ianslt,
     -        iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
          else if (iaclnl(icln)+1 .lt. iaclnf(icln+1)) then
            ia0=ia1+iaclnf(icln+1)-iaclnl(icln)-2
            call nneiglist(cslt,ia1,ia0,ianslt,
     -        iout,inperr,nwarn,nwwarn,nneig,nneiga,nneigh,ineig,#NL)
            ia1=ia0+1
          end if
        end do
      end if
      nhhb=0
      nhrb=0
      if (iop(100)*iop(101) .eq. 0) then
c       Break some bonds involving hydrogens
        do ia=1,nstta
          if (ianslt(ia) .eq. 1) then
            igh=igrslt(ia)
            jja=1
            do while (jja .le. nneig(ia))
              ja=ineig(jja,ia)
              if (iop(100) .eq. 0 .and. ianslt(ja) .eq. 1 .or.
     -            iop(101) .eq. 0 .and. igh .ne. igrslt(ja)) then
                call breakbond(nneig,nneiga,nneigh,ineig,ianslt,ia,ja,
     -            n1,n2,iout,nwarn,nstta,#NL)
                if (iop(24) .gt. 1 .and. n1*n2 .gt. 0 .and.
     -              MYRANK .eq. 0) write (iout,9130) 'Breaking',ia,
     -            (labslt(k,ia),k=1,2),ja,(labslt(k,ja),k=1,2),
     -            sqrt(arrdist(cslt(1,ia),cslt(1,ja)))
                if (ianslt(ja) .eq. 1) nhhb=nhhb+1
                if (ianslt(ja) .ne. 1) nhrb=nhrb+1
              end if
              jja=jja+1
            end do
          end if
        end do
      end if
c-----Make or break bonds
      nprob=0
      do ib=1,nmake
        ii1=imake(1,ib)
        ii2=imake(2,ib)
        if (ii1 .gt. nstta_full .or. ii2 .gt. nstta_full) then
          if (MYRANK .eq. 0) write (iout,9155) ii1,ii2,'formed'
          inperr=inperr+1
        end if
        if (iop(61) .eq. 0) then
          i1=ii1
          i2=ii2
        else
          i1=isplit_of_orig(ii1)
          i2=isplit_of_orig(ii2)
          if (i1 .gt. nstta .and. i2 .gt. nstta) then
            if (MYRANK .eq. 0) write (iout,9153) ii1,ii2,i1,i2
            nwwarn=nwwarn+1
          else if (.not. (i1 .le. nstta .and. i2 .le. nstta)) then
            if (MYRANK .eq. 0) write (iout,9154) ii1,ii2,i1,i2
            inperr=inperr+1
          end if
        end if
        if (i1 .gt. nstta_full .or. i2. gt. nstta_full) then
          if (MYRANK .eq. 0) write (iout,9136) 'making',ii1,ii2
            if (MYRANK .eq. 0 .and. iop(61) .gt. 0)
     -        write (iout,9152) i1,i2,nstta_full
           inperr=inperr+1
        else
          if (MYRANK .eq. 0)
     -      write (iout,9130) 'Making',ii1,(labslt(k,i1),k=1,2),ii2,
     -      (labslt(k,i2),k=1,2),sqrt(arrdist(cslt(1,i1),cslt(1,i2)))
          n2=0
          do in=1,nneig(i1)
            if (ineig(in,i1) .eq. i2) n2=in
          end do
          if (n2. eq. 0) then
            nneig(i1)=nneig(i1)+1
            nneiga(i1)=nneiga(i1)+1
            if (ianslt(i2) .eq. 1) nneigh(i1)=nneigh(i1)+1
            ineig(nneig(i1),i1)=i2
            nneig(i2)=nneig(i2)+1
            nneiga(i2)=nneiga(i2)+1
            if (ianslt(i1) .eq. 1) nneigh(i2)=nneigh(i2)+1
            ineig(nneig(i2),i2)=i1
          else if (i1*i2 .gt. 0) then
            if (MYRANK .eq. 0) write (iout,9122) i1,i2
            nwarn=nwarn+1
            imake(1,ib)=0
            imake(2,ib)=0
            nprob=nprob+1
            do ibb=ib+1,nmake
              imake(1,ibb-1)=imake(1,ibb)
              imake(2,ibb-1)=imake(2,ibb)
            end do
          end if
        end if
      end do
      nmake=nmake-nprob
      nprob=0
      do ib=1,nbreak
        ii1=ibreak(1,ib)
        ii2=ibreak(2,ib)
        if (ii1 .gt. nstta_full .or. ii2 .gt. nstta_full) then
          if (MYRANK .eq. 0) write (iout,9155) ii1,ii2,'broken'
          inperr=inperr+1
        end if
        if (iop(61) .eq. 0) then
          i1=ii1
          i2=ii2
        else
          i1=isplit_of_orig(ii1)
          i2=isplit_of_orig(ii2)
        end if
        if (i1 .gt. nstta_full .or. i2. gt. nstta_full) then
           if (MYRANK .eq. 0) write (iout,9136) 'breaking',ii1,ii2
           if (MYRANK .eq. 0 .and. iop(61) .gt. 0)
     -       write (iout,9152) i1,i2,nstta_full
           inperr=inperr+1
        else
          call breakbond(nneig,nneiga,nneigh,ineig,ianslt,i1,i2,n1,n2,
     -      iout,nwarn,nstta,#NL)
          if (n1*n2 .eq. 0 .and. i1*i2 .gt. 0) then
            if (MYRANK .eq. 0) write (iout,9121) ii1,ii2
            ibreak(1,ib)=0
            ibreak(2,ib)=0
            nwarn=nwarn+1
            nprob=nprob+1
            do ibb=ib+1,nbreak
              ibreak(1,ibb-1)=ibreak(1,ibb)
              ibreak(2,ibb-1)=ibreak(2,ibb)
            end do
          else
            if (MYRANK .eq. 0) write (iout,9130) 'Breaking',
     -        ii1,(labslt(k,i1),k=1,2),ii2,
     -        (labslt(k,i2),k=1,2),sqrt(arrdist(cslt(1,i1),cslt(1,i2)))
          end if
        end if
      end do
      if (nmake+nbreak .gt. 0 .and. iop(69) .gt. 0) then
        if (MYRANK .eq. 0) write (iout,9135)
        nwarn=nwarn+1
      end if
c     Check for the symmetry of the neighbour table
      do ia=1,nstta
        do in=1,nneig(ia)
          ja=ineig(in,ia)
          do jn=1,nneig(ja)
            if (ia .eq. ineig(jn,ja)) go to 200
          end do
          if (MYRANK .eq. 0) write (iout,9128) ja,ia,ia,ja
          inperr=inperr+1
200       continue
        end do
      end do
c     Check for possible topology problems
      nwwarn0=nwwarn
      nbreakn=0
      do ia=1,nstta
        if (icorig (ia) .ge. 0 .or. iop(13) .gt. 1) then
c         Deduct dummy neighbors from the neighbor count
          ndummy=0
          do in=1,nneig(ia)
            iaa=ineig(in,ia)
            ndummy=ndummy+idummy(ianslt(iaa))
          end do
          if (ianslt(ia) .eq. 1) then
c           Hydrogens can and must have one neighbour
            if (nneig(ia)-ndummy .ne. 1) then
              idist=nstta
              do ja=1,nneig(ia)
                if (ianslt(ineig(ja,ia)) .lt. 88) then
                  jadist=iabs(ia-ineig(ja,ia))
                  if (idist .gt. jadist) then
                    idist=jadist
                    jamin=ja
                  end if
                end if
              end do
              do ja=1,nneig(ia)
                if (ja .ne. jamin) then
                  nbreakn=nbreakn+1
                  indexx(nbreakn)=ia
                  indexn(nbreakn)=ineig(ja,ia)
                end if
              end do
              if (MYRANK .eq. 0)
     -            write (iout,9126) ia,(labslt(k,ia),k=1,2),nneig(ia)
              if (nneig(ia) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,9137) (ineig(jaa,ia),
     -           (labslt(k,ineig(jaa,ia)),k=1,2),
     -           sqrt(arrdist(cslt(1,ia),cslt(1,ineig(jaa,ia)))),
     -           sqrt(bondthresh2(ianslt(ia),ianslt(ineig(jaa,ia)))),
     -           jaa=1,nneig(ia))
              nwwarn=nwwarn+1
            else
              do jaa=1,nneig(ia)
                ja=ineig(jaa,ia)
                if (iabs(ia-ja) .gt. 25) then
                  if (MYRANK .eq. 0) write (iout,9127) ia,
     -              (labslt(k,ia),k=1,2),ja,(labslt(k,ja),k=1,2),
     -              sqrt(arrdist(cslt(1,ia),cslt(1,ja))),
     -              sqrt(bondthresh2(ianslt(ia),ianslt(ja)))
                  nbreakn=nbreakn+1
                  indexx(nbreakn)=ia
                  indexn(nbreakn)=ja
                end if
              end do
            end if
          else
            ian=ianslt(ia)
            if ((nneig(ia)-ndummy .gt. nval(ian) .and.
     -        nval(ian) .gt. 0) .or. (nneig(ia) .eq. 0 .and.
     -        (ian .eq. 1 .or. ian .eq. 6 .or. ian .eq. 7 .or.
     -         ian .eq. 8 .or. ian .eq. 15 .or. ian .eq. 16))) then
              if (MYRANK .eq. 0)
     -            write (iout,9139) ia,(labslt(k,ia),k=1,2),ianslt(ia),
     -          nneig(ia)
              if (nneig(ia) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,9137) (ineig(jaa,ia),
     -           (labslt(k,ineig(jaa,ia)),k=1,2),
     -           sqrt(arrdist(cslt(1,ia),cslt(1,ineig(jaa,ia)))),
     -           sqrt(bondthresh2(ianslt(ia),ianslt(ineig(jaa,ia)))),
     -           jaa=1,nneig(ia))
            end if
          end if
        end if
      end do
      nwarn=nwarn+nbreakn
      if (nbreakn .gt. 0) then
        ib=2
        do while (ib .le. nbreakn)
          idup=0
          do i1=1,ib-1
            if ((indexn(i1) .eq. indexn(ib) .and.
     -           indexx(i1) .eq. indexx(ib)) .or.
     -          (indexn(i1) .eq. indexx(ib) .and.
     -           indexx(i1) .eq. indexn(ib))) then
c             Duplicate found - delete
              do i2=ib+1,nbreakn
                indexx(i2-1)=indexx(i2)
                indexn(i2-1)=indexn(i2)
              end do
              nbreakn=nbreakn-1
              idup=1
            end if
          end do
          if (idup .eq. 0) ib=ib+1
        end do
        if (MYRANK .eq. 0) write (iout,9131)
     -    'BRKB',nbreakn,(indexx(ja),indexn(ja),ja=1,nbreakn)
        if (MYRANK .eq. 0) write (iout,9132)
      end if
      nbreak=nbreak-nprob
      rgmolmax2=0.0
      do ig=1,nsttg
c       Check for multiple groupcenter definition
        ngc=0
        igc=0
        do ia=ifgrslt(ig),ilgrslt(ig)
          ngc=ngc+ivtm(ia)
          if (ivtm(ia) .eq. 1 .and. ngc .eq. 1) igc=ia
          if (ngc .gt. 1) then
            if (MYRANK .eq. 0) write (iout,9144) ig,ifgrslt(ig),
     -        ilgrslt(ig),ia
            inperr=inperr+1
          end if
        end do
c       Determine group center atomindex
        if (ngc .eq. 0) then
          call findtcent(ineig,nneig,l1,l2,l3,ifgrslt(ig),ilgrslt(ig),
     -      igrcnt(ig),ncentfound,1,iout,inperr,#ST,#NL)
        else
          igrcnt(ig)=igc
        end if
        if (iop(159)+iop(160) .gt. 0 .or. iop(65) .eq. 4) then
          rgmax2=0.0
c         Find group radius
          do ia=ifgrslt(ig),ilgrslt(ig)
            r2=arrdist(cslt(1,ia),cslt(1,igrcnt(ig)))
            if (r2 .gt. rgmax2) rgmax2=r2
          end do
          gcut2(ig)=rgmax2
          if (rgmolmax2 .lt. rgmax2) rgmolmax2=rgmax2
        end if
      end do
      call trnsfi(nneig3,nneig,nstta)
      do ig=1,nsttg
c       Check for group connectivity - temporarily delete out bonds
        do ia=ifgrslt(ig),ilgrslt(ig)
          call trnsfi(ineig(nneig(ia)+1,ia),ineig(1,ia),nneig3(ia))
          do ja=1,nneig3(ia)
            if (ineig(ja,ia) .lt. ifgrslt(ig) .or.
     -          ineig(ja,ia) .gt. ilgrslt(ig)) ineig(ja,ia)=0
          end do
          ndel=0
          do ja=1,nneig3(ia)
            if (ineig(ja,ia) .eq. 0) then
              ndel=ndel+1
            else
              ineig(ja-ndel,ia)=ineig(ja,ia)
            end if
          end do
          nneig(ia)=nneig(ia)-ndel
        end do
        call clstrs(ineig,nneig,l1,ifgrslt(ig),ilgrslt(ig),l2,l3,l4,
     -    0,nofcls,indexx,iout,inperr,nww,nonnerr,#ST,#GR,#NL,
     -    5,nntest)
        if (nofcls .gt. 1) then
          write (iout,9119) ig,labslt(1,ifgrslt(ig)),ifgrslt(ig),
     -      ilgrslt(ig),nofcls-1
            nwwarn=nwwarn+1
        end if
        do ia=ifgrslt(ig),ilgrslt(ig)
          call trnsfi(ineig(1,ia),ineig(nneig3(ia)+1,ia),nneig3(ia))
        end do
      end do
      call trnsfi(nneig,nneig3,nstta)
      rmx=sqrt(rgmolmax2)
      call nn34list(nneig,ineig,#NL,1,nstta,nneig3,nneig4,idebug(27),
     -  inperr,iout)
      if (iop(65) .eq. 4) then
        if (cutuu .le. 2.0*rmx) then
          if (MYRANK .eq. 0) write (iout,9148) '***** ERROR:',rmx,
     -      'exceeds','solute',cutuu,'SUUC'
          inperr=inperr+1
        else if (0.8*cutuu .le. 2.0*rmx) then
          if (MYRANK .eq. 0) write (iout,9148) '===== STRONG WARNING',
     -      rmx,'is close to','solute',cutuu,'SUUC'
          nwwarn=nwwarn+1
        end if
      end if
      if (iop(7) .eq. 0 .and. iop(43) .eq. 1) then
        if (cutslt .le. rmx) then
          if (MYRANK .eq. 0) write (iout,9148) '***** ERROR:',rmx,
     -      'exceeds','solvent',cutslt,'SUVC'
          inperr=inperr+1
        else if (0.8*cutslt .le. rmx) then
          if (MYRANK .eq. 0) write (iout,9148) '===== STRONG WARNING',
     -      rmx,'is close to','solvent',cutslt,'SUVC'
          nwwarn=nwwarn+1
        end if
      end if
      nSG=0
      if (iop(61) .gt. 0) then
c       Check for disulfide-bond forming cysteins
        do ia=1,nstta
          if ((labslt(1,ia)(1:3) .eq. 'CYS' .or.
     -        labslt(1,ia)(1:3) .eq. 'CYX') .and. (labslt(2,ia) .eq.
     -      'SG  ' .or. labslt(2,ia) .eq. ' SG ')) then
            do ja=1,nstta_full
              if (ja .gt. ia) then
                if ((labslt(1,ja)(1:3) .eq. 'CYS' .or.
     -               labslt(1,ja)(1:3) .eq. 'CYX') .and. (labslt(2,ja)
     -            .eq. 'SG  ' .or. labslt(2,ja) .eq. ' SG ')) then
                  if (arrdist(cslt(1,ia),cslt(1,ja)) .lt. 10.0) then
c                   nSG=nSG+1
                    ig=igrslt(ia)
                    ir_i_o=ir_split_orig(iorig_of_split(ia))
                    write (iout,2120) ig,labslt(1,ia),ir_i_o
                    if (ja .le. nstta) then
c                     nSG=nSG+1
                      ig=igrslt(ja)
                      ir_j_o=ir_split_orig(iorig_of_split(ja))
                      write (iout,2120) ig,labslt(1,ja),ir_j_o
c                     Check if on same stretch
                      ir_i=0
                      ir_j=0
                      do ifl=1,naflxrange
                        if (ir_i_o .ge. iaflxrange(1,ifl) .and.
     -                      ir_i_o .le. iaflxrange(2,ifl)) ir_i=ifl
                        if (ir_j_o .ge. iaflxrange(1,ifl) .and.
     -                      ir_j_o .le. iaflxrange(2,ifl)) ir_j=ifl
                      end do
                      if (ir_i .ne. ir_j) then
                        inperr=inperr+1
                        write (iout,2121)
                      end if
                    end if
                  end if
                end if
              end if
            end do
          end if
        end do
c       if (nSG .gt. 0) then
c         inperr=inperr+1
c         write (iout,2121)
c       end if
      end if
      call initmol(nsttm,0,nstta,nsttanoclone,nneig,ineig,
     -  ifirstm,ilastm,iamolslt,mask,ifgrmolslt,ilgrmolslt,igrcnt,
     -  molcnt,igrslt,iorig_of_split,ianslt,labslt,noutwarn,
     -  nsplitwarn,noutwmin,noutwmax,nmolwid,ifdummy,nsplitwmin,
     -  nsplitwmax,#ST,#GR,#MM,#NL,#MW)
c     Check for atoms with all-H neighbours
      do ia=1,nstta
        im=iamolslt(ia)
        if (im .gt. 0) then
          if (nneig(ia) .eq. nneigh(ia) .and. nneig(ia) .gt. 0
     -        .and. ilastm(im)-ifirstm(im) .gt. 4) then
            if (MYRANK .eq. 0) write (iout,9129) ia
            nwwarn=nwwarn+1
          end if
        end if
      end do
      do im=1,nsttm
        do ia=ifirstm(im),ilastm(im)
          do jaa=1,nneig(ia)
            ja=ineig(jaa,ia)
            r2=arrdist(cslt(1,ia),cslt(1,ja))
            if (r2 .lt. 0.01) then
              if (MYRANK .eq. 0) write (iout,9147) ia,
     -          (labslt(k,ia),k=1,2),ja,(labslt(k,ja),k=1,2),sqrt(r2)
              nwwarn=nwwarn+1
            else if (idummy(ianslt(ia))+idummy(ianslt(ja)) .eq. 0) then
              if (r2 .lt. 0.64) then
                if (MYRANK .eq. 0) write (iout,9146) '----- WARNING',ia,
     -            (labslt(k,ia),k=1,2),ja,(labslt(k,ja),k=1,2),sqrt(r2)
                nwarn=nwarn+1
              else if (r2 .lt. 0.25) then
                if (MYRANK .eq. 0) write (iout,9146)
     -            '===== STRONG WARNING',ia,
     -            (labslt(k,ia),k=1,2),ja,(labslt(k,ja),k=1,2),sqrt(r2)
                nwwarn=nwwarn+1
              end if
            end if
          end do
        end do
      end do
      ntopwwarn=nsplitwarn+noutwarn
      if (iop(117) .gt. 0) then
c       Check constraint list atoms
        do i=1,nconstr_pair
          ipair1w=iconstr_pair(1,i)
          ipair2w=iconstr_pair(2,i)
          ipair1=ipair1w
          ipair2=ipair2w
          if (iop(61) .gt. 0) then
c           Convert atom indices to new order
            if (isplitdone .eq. 0) then
              ipair1=isplit_of_orig(ipair1w)
              ipair2=isplit_of_orig(ipair2w)
              iconstr_pair(1,i)=ipair1
              iconstr_pair(2,i)=ipair2
            end if
            if (ipair1 .gt. nstta .and. ipair2 .gt. nstta) then
              if (MYRANK .eq. 0) write(iout,9151) ipair1w,ipair2w,
     -          ipair1,ipair2
              inperr=inperr+1
            end if
          end if
          if (ipair1 .gt. nstta_full .or. ipair1 .lt. 1 .or.
     -        ipair2 .gt. nstta_full .or. ipair2 .lt. 1) then
            if (MYRANK .eq. 0) write (iout,9149)
     -          ipair1w,ipair2w,nstta_full
            inperr=inperr+1
          end if
          do in=1,nneig(ipair1)
            if (ineig(in,ipair1) .eq. ipair2) then
              if (MYRANK .eq. 0) write(iout,9150)
     -          ipair1w,ipair2w,'bonded'
              inperr=inperr+1
            end if
          end do
          do in=nneig(ipair1)+1,nneig3(ipair1)
            if (ineig(in,ipair1) .eq. ipair2) then
              if (MYRANK .eq. 0) write (iout,9150)
     -          ipair1w,ipair2w,'1 bond apart'
              inperr=inperr+1
            end if
          end do
          do in=nneig3(ipair1)+1,nneig4(ipair1)
            if (ineig(in,ipair1) .eq. ipair2) then
              if (MYRANK .eq. 0) write (iout,9150)
     -          ipair1w,ipair2w,'2 bonds apart'
              inperr=inperr+1
            end if
          end do
        end do
        isplitdone=1
      end if
c     Collect pf list used
      call zeroiti(npfused,0,11)
      call zeroiti(lprmfil,0,9)
      do ia=1,nstta
        npfused(iopslt(ia))=npfused(iopslt(ia))+1
      end do
      if (npfused(1) .gt. 0 .and. npfused(2) .gt. 0) then
        if (MYRANK .eq. 0) write (iout,9102)
        inperr=inperr+1
      end if
      if (npfused(1) .gt. 0 .and. iop(26) .ne. 0) then
        if (MYRANK .eq. 0) write (iout,9104)
        inperr=inperr+1
      end if
      if (npfused(2) .gt. 0) call qpenin
c     Check for mixing rule consistency
      if (iop(52) .ne. mixrule(iop(3)) .and. iop(3) .le. 10) then
        if (MYRANK .eq. 0) write (iout,9123)
        nwarn=nwarn+1
      end if
c     Gromos intra is not implemented properly yet
      if (iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        if (npfused(6) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,9125)
          nwwarn=nwwarn+1
        else if (npfused(9) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,9141)
          nwwarn=nwwarn+1
        end if
      end if
c     Charge center info for vectorized energy routines
c     iaq=0 for charge in oxygen type, 3 for separated charge type
      iaq=3
      if (iop(26) .eq. 1) iaq=0
      nqoplsrep=0
      do ig=1,nsttg
        qp=qh
        qn=-2.0*qh
        if (iop(26) .eq. 3) qn=-qh
        do ia=ifgrslt(ig),ilgrslt(ig)
c         Prepare constant products for eslt
c         qji, c6ji, c12ji: 1/r, 1/r**6, a/r**12 interaction coefs for the
c         Solute-water eng for each atom (to simplify indexing in eng calc)
          if (ipfgr(ig) .eq. 1) then
c...........Generate constants for Clementi et al. library
            do i=1,2
              if (i .eq. 1)  then
                qji(ia,i)=-2.0*c1clm(iclslt(ia),i)*qh*qslt(ia)/dielc
              else
                qji(ia,i)=c1clm(iclslt(ia),i)*qh*qslt(ia)/dielc
              end if
              c6ji(ia,i)=c6clm(iclslt(ia),i)
              c12ji(ia,i)=c12clm(iclslt(ia),i)
            end do
          else if (ipfgr(ig) .eq. 3) then
c...........Generate constants for Kollman potential (1999-2002)
            call sltcoefs(sigmaw,epsilonw,qp,qn,sigslt,
     -        epsslt,iclslt,qslt,dielc,sigamb02,epsamb,qji,c6ji,c12ji,
     -        sig14,eps14,sigamb02,epsamb,ia,iop(52))
          else if (ipfgr(ig) .eq. 4) then
c...........Generate constants for Kollman potential (DB94)
            call sltcoefs(sigmaw,epsilonw,qp,qn,sigslt,
     -        epsslt,iclslt,qslt,dielc,sigkol94,epskol94,qji,c6ji,c12ji,
     -        sig14,eps14,sigkol94,epskol94,ia,iop(52))
          else if (ipfgr(ig) .eq. 5) then
c...........Generate constants for Charmm potential
            call sltcoefs(sigmaw,epsilonw,qp,qn,sigslt,
     -        epsslt,iclslt,qslt,dielc,sigcha,epscha,qji,c6ji,c12ji,
     -        sig14,eps14,sigcha14,epscha14,ia,iop(52))
          else if (ipfgr(ig) .eq. 6) then
c...........Generate constants for BVG (Gromos87) potential
            call sltcoefs(sigmaw,epsilonw,qp,qn,sigslt,
     -        epsslt,iclslt,qslt,dielc,sigbvg,epsbvg,qji,c6ji,c12ji,
     -        sig14,eps14,sigbvg14,epsbvg14,ia,iop(52))
          else if (ipfgr(ig) .eq. 7) then
c...........Generate constants for BVG (Gromos96) potential
            call sltcoefs(sigmaw,epsilonw,qp,qn,sigslt,
     -        epsslt,iclslt,qslt,dielc,siggro,epsgro,qji,c6ji,c12ji,
     -        sig14,eps14,siggro14,epsgro14,ia,iop(52))
          else if (ipfgr(ig) .eq. 8) then
c...........Jorgensen's OPLS
c           Get the stored charges into qslt if needed
            if (iop(31) .eq. 0) then
              qslt(ia)=qjrg(iclslt(ia))
              nqoplsrep=nqoplsrep+1
            end if
c           Prepare the constant products for eslt
            call sltcoefs(sigmaw,epsilonw,qp,qn,sigslt,
     -        epsslt,iclslt,qslt,dielc,sigjrg,epsjrg,qji,c6ji,c12ji,
     -        sig14,eps14,sigjrg,epsjrg,ia,iop(52))
          else if (ipfgr(ig) .eq. 9) then
c...........HS
            c12ji(ia,1)=sighs(iclslt(ia))**2
            sigslt(ia)=sighs(iclslt(ia))*2.0**(1.0/6.0)
            epsslt(ia)=0.0
            sig14(ia)=0.0
            eps14(ia)=0.0
            if (sigslt(ia) .eq. 0.0 .and. ianslt(ia) .gt. 1 .and.
     -          icorig(ia) .ge. 0) then
              if (MYRANK .eq. 0) write (iout,9140) ia,pflabslt(ia)
              nwarn=nwarn+1
            end if
            if (qslt(ia) .ne. 0.0) then
              if (icorig(ia) .ge. 0 .and. MYRANK .eq. 0)
     -          write (iout,9142) ia,pflabslt(ia),qslt(ia)
              nchng=nchng+1
              qslt(ia)=0.0
            end if
          else if (ipfgr(ig) .eq. 10 .or. ipfgr(ig) .eq. 11) then
c...........Dummy group or just atomic number information was available
            do i=1,2
              qji(ia,i)=0.0
              c6ji(ia,i)=0.0
              c12ji(ia,i)=0.0
            end do
          end if
          if (iop(60) .gt. 0) then
            if (c12ji(ia,1) .eq. 0.0) c12ji(ia,1)=c12prot
          end if
        end do
      end do
      if (nqoplsrep .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,9138) 'solute'
      if (iop(26) .eq. 4) then
c-------Solvent is a general 1-6-12 type molecule
        if (iop(37) .gt. 9) then
c         Atom type is atomic number or dummy
          do ia=1,nslv
            if (iop(37) .eq. 10) then
              if (ianslv(ia) .lt. 0) then
                ianslv(ia)=ianum(pflabslv(ia)(1:4),0,iout,inperr)
              else
                pflabslv(ia)=iatnam(ianslv(ia))
              end if
            else if (iop(37) .eq. 11) then
c             Dummy atom
              ianslv(ia)=99
            end if
          end do
        else
          if (idebug(172) .gt. 0) write (iout,5711) 'before',
     -      (ia,ianslv(ia),iclslv(ia),pflabslv(ia),labslv(ia),ia=1,nslv)
          do ia=1,nslv
            if (ianslv(ia) .eq. -1) then
c             Convert pf labels to pf number
              do i=1,maxtyp(iop(37))
                if (pflab(i,iop(37)) .eq. pflabslv(ia)) then
                  ianslv(ia)=i
                  go to 7101
                end if
              end do
              if (MYRANK .eq. 0)
     -          write (iout,9115) pflabslv(ia),ipf(iop(37)),'solvent',ia
              ianslv(ia)=1
              inperr=inperr+1
              npfmiss=npfmiss+1
              call find(pflabslv(ia),1,npftypmiss,pflabmiss,ifound,6)
              if (ifound .eq. 0) then
                npftypmiss=npftypmiss+1
                pflabmiss(npftypmiss)=pflabslv(ia)
              end if
            end if
7101        continue
          end do
          if (idebug(172) .gt. 0) write (iout,5711) 'after ',
     -      (ia,ianslv(ia),iclslv(ia),pflabslv(ia),labslv(ia),ia=1,nslv)
        end if
        do ia=1,nslv
          if (iclslv(ia) .eq. 0 .or.
     -        iclslv(ia) .gt. maxtyp(iop(37))) then
            if (MYRANK .eq. 0)
     -          write (iout,9110) maxtyp(iop(37)),iclslv(ia),ia
            inperr=inperr+1
            iclslv(ia)=maxtyp(iop(37))
          end if
          if (iop(37) .ne. 10) ianslv(ia)=iatnos(iclslv(ia),iop(37))
          if (labslv(ia) .eq. '    ') labslv(ia)=pflabslv(ia)(1:4)
          if (ianslv(ia) .eq. 0) then
            if (MYRANK .eq. 0) write (iout,9111) iclslv(ia),ia
            inperr=inperr+1
            ianslv(ia)=100
          end if
          if (iop(37) .eq. 1 .or. iop(37) .eq. 2) then
c           Clementi & QPEN - not implemented
            inperr=inperr+1
            if (MYRANK .eq. 0) write (iout,9112) namstp(iop(37))
            return
          else if (iop(37) .eq. 3) then
c           Kollman et al. (old)
            sigslv(ia)=sigamb02(iclslv(ia))
            epsslv(ia)=epsamb(iclslv(ia))
          else if (iop(37) .eq. 4) then
c           Kollman et al. (new - DB94)
            sigslv(ia)=sigkol94(iclslv(ia))
            epsslv(ia)=epskol94(iclslv(ia))
          else if (iop(37) .eq. 5) then
c           Charmm - Parm 22
            sigslv(ia)=sigcha(iclslv(ia))
            epsslv(ia)=epscha(iclslv(ia))
          else if (iop(37) .eq. 6) then
c           Berendsen - van Gunsteren - Gromos87
            sigslv(ia)=sigbvg(iclslv(ia))
            epsslv(ia)=epsbvg(iclslv(ia))
          else if (iop(37) .eq. 7) then
c           Berendsen - van Gunsteren - Gromos96
            sigslv(ia)=siggro(iclslv(ia))
            epsslv(ia)=epsgro(iclslv(ia))
          else if (iop(37) .eq. 8) then
c           Jorgensen OPLS
            sigslv(ia)=sigjrg(iclslv(ia))
            epsslv(ia)=epsjrg(iclslv(ia))
          else if (iop(37) .eq. 9) then
c           HS
            sigslv(ia)=sighs(iclslv(ia))
            epsslv(ia)=0.0
          else if (iop(37) .eq. 10 .or. iop(37) .eq. 11) then
c           Atomic numbers only
            sigslv(ia)=1.0
            epsslv(ia)=0.0
          end if
        end do
c       Prepare solvent-solvent interaction coefficient matrix
c       qslt has to be filled in from qjrg if iop(31) .ne. 0
c-------General solvent-solvent type potential
c       Get charges for OPLS
        if (iop(31) .eq. 0 .and. iop(37) .eq. 8) then
          do i=1,nslv
            qslv(i)=qjrg(iclslv(i))
          end do
          if (MYRANK .eq. 0) write (iout,9138) 'solvent'
        end if
        call trnsfr(qslvdip,qslv,nslv)
        if (iop(46) .gt. 0) then
c         Set solvent charges to zero
          call zeroit(qslv,nslv)
        end if
c       Combine charges, epsilons and sigmas
        if (iop(37) .le. 9) then
          do i=1,nslv
            do j=1,nslv
              qvv(j,i)=qslv(j)*qslv(i)/dielc
              if (iop(125) .eq. 1) qvv(j,i)=0.0
              call combestoc6c12(sigslv(i),sigslv(j),epsslv(i),
     -          epsslv(j),c6vv(j,i),c12vv(j,i),iop(52))
            end do
          end do
        end if
        if (idebug(43) .gt. 0 .and. MYRANK .eq. 0) write (iout,5713)
     -    ((i,j,qvv(i,j),c6vv(i,j),c12vv(i,j),i=1,nslv),j=1,nslv)
c       Prepare solute-solvent interaction coefficient matrix
c-------Jorgensen, Kollman or BVG solute-general solvent type potential
        do j=1,nstta
          if (iopslt(j) .le. 9) then
            do i=1,nslv
              qtv(j,i)=qslt(j)*qslv(i)/dielc
              call combestoc6c12(sigslv(i),sigslt(j),epsslv(i),
     -          epsslt(j),c6tv(j,i),c12tv(j,i),iop(52))
              if (c6tv(j,i) .lt. 0.0 .or. c6tv(j,i) .lt. 0.0)
     -          write (iout,9867) j,i,sigslv(i),sigslt(j),epsslv(i),
     -            epsslt(j),c6tv(j,i),c12tv(j,i)
9867  format(' j,i=',i6,i3,' sigslv,slt=',2f10.5,' epsslv,slt=',2e12.5,
     -  ' c6,c12=',2e12.5)
              if (i .eq. 1) then
c               Save c6, c12 coefs for echopr
                c6ji(j,i)=c6tv(j,i)
                c12ji(j,i)=c12tv(j,i)
              end if
              if (c12tv(j,i) .eq. 0.0 .and. iop(60) .gt. 0)
     -          c12tv(j,i)=c12prot
            end do
          end if
        end do
      end if
      if (npftypmiss .gt. 0 .and. MYRANK .eq. 0) write (iout,9145)
     -  npftypmiss,(pflabmiss(i),i=1,npftypmiss)
      do ig=1,nstfg
        noppti(ig)=0
      end do
      if (iop(30) .eq. 5) then
c       Find out if there are groups that are identical in the two copies
        do ig=1,nstfg0
c         When noppti(ig) is one, k=1 will be used througout
          noppti(ig)=0
          ndiff=0
          ndifft=0
          do ia=ifgrslt(ig),ilgrslt(ig)
            ia2=ifgrslt(nstfg0+ig)+(ia-ifgrslt(ig))
            if (abs(sigslt(ia)-sigslt(ia2)) .gt. sigtol .or.
     -        abs(epsslt(ia)-epsslt(ia2)) .gt. epstol .or.
     -        abs(qslt(ia)-qslt(ia2)) .gt. qtol .or.
     -        arrdist(cslt(1,ia),cslt(1,ia2)) .gt. xyztol2)
     -           ndifft=ndifft+1
            if (abs(sigslt(ia)-sigslt(ia2)) .gt. 0.0 .or.
     -        abs(epsslt(ia)-epsslt(ia2)) .gt. 0.0 .or.
     -        abs(qslt(ia)-qslt(ia2)) .gt. 0.0 .or.
     -        arrdist(cslt(1,ia),cslt(1,ia2)) .gt. 0.0) ndiff=ndiff+1
          end do
          if (ndiff .eq. 0) then
            noppti(ig)=2
          else if (ndifft .eq. 0) then
            noppti(ig)=1
          end if
          noppti(nstfg0+ig)=noppti(ig)
        end do
      end if
c     For deformation path, set third copy of type
      if (iop(30) .ge. 7) then
        do ig=1,nstfg0
          if (ipfgr(ig) .eq. ipfgr(nstfg0+ig)) then
c           FE - pf types are the same
            if (ipfgr(nstfg1+ig) .ne. ipfgr(ig)) then
              if (MYRANK .eq. 0)
     -          write (iout,9118) ig,ipfgr(nstfg1+ig),ipfgr(ig)
              nwarn=nwarn+1
              ipfgr(nstfg1+ig)=ipfgr(ig)
            end if
          else
c           FE - pf types are different
            if (ipfgr(nstfg1+ig) .ne. ipfgr(ig) .and.
     -             ipfgr(nstfg1+ig) .ne. ipfgr(nstfg0+ig)) then
              if (MYRANK .eq. 0)
     -          write (iout,9118) ig,ipfgr(nstfg1+ig),ipfgr(ig)
              ipfgr(nstfg1+ig)=ipfgr(ig)
            end if
          end if
        end do
      end if
      if (iop(43) .eq. 0 .and. iop(7) .ne. 2 .and. nstfg0 .gt. 1) then
c       Images are solute com based - contract solute groups by potential
c       4 possible segments: up to 3 FE copy and the rest
        npfg=1
        ifpfgr(1)=1
        ipfref=ipfgr(1)
        if (iop(30) .ge. 1. and. iop(30) .le. 3) then
c         Widom -type molecules (1 copy only)
          do im=1,nmolwid
            do ig=ifgrmolslt(im),ilgrmolslt(im)
              if (ipfgr(ig) .ne. ipfref) then
                ilpfgr(npfg)=ilgrslt(ig-1)
                ipfgr(npfg)=ipfref
                ipfref=ipfgr(ig)
                npfg=npfg+1
                ifpfgr(npfg)=ifgrslt(ig)
              end if
            end do
            ilpfgr(npfg)=ilastm(im)
            if (im .lt. nmolwid) then
              npfg=npfg+1
              ifpfgr(npfg)=ifirstm(im+1)
            end if
          end do
          do ic=1,3
            npfgr(ic)=npfg
          end do
        else if (iop(30) .ge. 5) then
          if (iop(30) .eq. 5) then
            nopptiref=noppti(1)
            ifpfgr(npfg+1)=2
            do ig=2,nstfg0
              if (ipfgr(ig) .ne. ipfref .or. ipfgr(nstfg0+ig) .ne.
     -            ipfref .or. noppti(ig) .ne. nopptiref .or.
     -            noppti(nstfg0+ig) .ne. nopptiref) then
                ilpfgr(npfg)=ilgrslt(ig-1)
                ipfgr(npfg)=ipfref
                ipfref=ipfgr(ig)
                noppti(npfg)=nopptiref
                nopptiref=noppti(ig)
                npfg=npfg+1
                ifpfgr(npfg)=ifgrslt(ig)
              end if
            end do
          else
            do ig=2,nstfg0
              ndiff=0
              do ic=1,nsltcp(iop(30)+1)
                if (ipfgr(ig+(ic-1)*nstfg0) .ne. ipfref) ndiff=ndiff+1
              end do
              if (ndiff .gt. 0) then
                ilpfgr(npfg)=ilgrslt(ig-1)
                ipfgr(npfg)=ipfref
                ipfref=ipfgr(ig)
                npfg=npfg+1
                ifpfgr(npfg)=ifgrslt(ig)
              end if
            end do
          end if
c         Close the last segment of the first copy, copy segments
          ilpfgr(npfg)=nstfg0
          npfgr(1)=npfg
          do ic=2,nsltcp(iop(30)+1)
            npfgr(ic)=ic*npfgr(1)
            do ig=1,npfg
              ifpfgr((ic-1)*npfg+ig)=ifpfgr(ig)+(ic-1)*nstfg0
              ilpfgr((ic-1)*npfg+ig)=ilpfgr(ig)+(ic-1)*nstfg0
              ipfgr((ic-1)*npfg+ig)=ipfgr(ig)
              if (iop(30) .eq. 5) noppti((ic-1)*npfg+ig)=noppti(ig)
            end do
          end do
          npfg=nsltcp(iop(30)+1)*npfg
          do ic=nsltcp(iop(30)+1)+1,3
            npfgr(ic)=npfg
          end do
        else
c         iop(30)=0 case
          do ic=1,3
            npfgr(ic)=0
          end do
        end if
        if (nsttg .gt. nstfg) then
c         Contract the non-free-energy groups
          if (iop(30) .eq. 0) nstfm=0
          if (iop(30) .gt. 0) nstfm=iamolslt(nstfa)
          if (iop(30) .gt. 3 .or. nsttm-nstfm .gt. 1) then
            write (iout,9143)
            inperr=inperr+1
          end if
          if (iop(30) .gt. 0) npfg=npfg+1
          ipfref=ipfgr(nstfg+1)
          ifpfgr(npfg)=ifgrslt(nstfg+1)
          do ig=nstfg+1,nsttg
            if (ipfgr(ig) .ne. ipfref) then
              ilpfgr(npfg)=ilgrslt(ig-1)
              ipfgr(npfg)=ipfref
              ipfref=ipfgr(ig)
              npfg=npfg+1
              ifpfgr(npfg)=ifgrslt(ig)
            end if
          end do
          ilpfgr(npfg)=nstta
        end if
        npfgr(4)=npfg
c       igrpf(ia) is the contracted group index of atom ia
        do ig=1,npfg
          do ia=ifpfgr(ig),ilpfgr(ig)
            igrpf(ia)=ig
           end do
        end do
      else
c       No contraction of groups
        do ic=1,3
          npfgr(ic)=min0(ic,nsltcp(iop(30)+1))*nstfg0
        end do
        npfgr(4)=nsttg
        do ig=1,nsttg
          ifpfgr(ig)=ifgrslt(ig)
          ilpfgr(ig)=ilgrslt(ig)
        end do
        do ia=1,nstta
          igrpf(ia)=igrslt(ia)
        end do
      end if
c     Set the eslt call parameters
      ig0=0
      do ic=1,4
        do ig=ig0+1,npfgr(ic)
          if (ipfgr(ig) .gt. 9) then
c           Dummy group
            nslvggr(ig)=0
            nstsvgr(ig)=0
            ipfgr(ig)=10
          else if (iop(26) .eq. 0) then
c           MCY-type water
            nslvggr(ig)=3
            nstsvgr(ig)=3
          else if (iop(26) .eq. 3) then
c           TIP5P water
            ipfgr(ig)=6
            nslvggr(ig)=5
            nstsvgr(ig)=5
          else if (iop(26) .eq. 4) then
c           General solvent
            ipfgr(ig)=7
            nslvggr(ig)=nslv
            nstsvgr(ig)=nslv
          else if (ipfgr(ig) .eq. 9) then
c           General solvent
            ipfgr(ig)=8
            nslvggr(ig)=nslv
            nstsvgr(ig)=nslv
          else if (ipfgr(ig) .eq. 2) then
c           EPEN/QPEN
            nslvggr(ig)=nslv
            nstsvgr(ig)=nslvn+nslve
          else if (rlpw .eq. 0) then
c           Three-center water
            ipfgr(ig)=3
            nslvggr(ig)=3
            nstsvgr(ig)=3
          else
c           Four-center water
            ipfgr(ig)=6
            nslvggr(ig)=4
            nstsvgr(ig)=4
          end if
        end do
        ig0=npfgr(ic)
      end do
      if (idebug(2) .eq. 1) then
        ig0=1
        do ic=1,4
          do ig=ig0,npfgr(ic)
            if (MYRANK .eq. 0)
     -        write (iout,5712) ic,ig,ipfgr(ig),ifpfgr(ig),ilpfgr(ig),
     -        nslvggr(ig),nstsvgr(ig)
          end do
          if (npfgr(ic) .ne. 0) ig0=npfgr(ic)+1
        end do
      end if
      if (iop(26) .lt. 4) then
c-------Solvent is water, generate coordinates, types, charges
        do i=1,#SV
          ianslv(i)=89
          qslv(i)=0.0
          islvtp(i)=0
        end do
        call zeroit(cslv,3*#SV)
        roh=0.9572
        ahoh2=104.52/2.0/rdtodg
c       For MCY water, HOH angle is 104 deg 52 min
        if (iop(26) .eq. 0 .and. iop(37) .eq. 1) ahoh2=104.87/2.0/rdtodg
        if (iop(26) .eq. 1 .and.
     -    (iop(37) .eq. 3 .or. iop(37) .eq. 7)) then
c         For SPC(/E) waters the bond length is 1A and the angle is tetrahedral
          roh=1.0
          ahoh2=109.47/2.0/rdtodg
        end if
        cslv(1,2)=roh*cos(ahoh2)
        cslv(3,2)=roh*sin(ahoh2)
        cslv(1,3)=cslv(1,2)
        cslv(3,3)=-cslv(3,2)
        ianslv(1)=8
        ianslv(2)=1
        ianslv(3)=1
        qslv(2)=qh
        qslv(3)=qh
c       islvtp(i):solvent atom type -  1-oxygen, 2-hydrogen, 0-other
        islvtp(2)=2
        islvtp(3)=2
        if (iop(26) .eq. 1) then
          nslv=3
          qslv(1)=-2.0*qh
          islvtp(1)=1
        else if (iop(26) .eq. 2) then
          nslv=4
          qslv(4)=-2.0*qh
          islvtp(4)=1
          cslv(1,4)=rlpw
        else if (iop(26) .eq. 3) then
          nslv=5
          qslv(4)=-qh
          qslv(5)=-qh
          islvtp(4)=1
          islvtp(5)=1
          cslv(1,4)=rlpw
          alol2=109.47/2.0/rdtodg
          cslv(1,4)=-rlpw*cos(alol2)
          cslv(2,4)=rlpw*sin(alol2)
          cslv(1,5)=cslv(1,4)
          cslv(2,5)=-cslv(2,4)
        end if
      end if
      if (iop(26) .lt. 4) then
        call trnsfr(qslvdip,qslv,nslv)
        if (iop(46) .gt. 0) call zeroit(qslv,nslv)
      end if
c     ic00,ic01: increments when extracting water coordinates from c
      ic00=nstta-2*nslv
      ic01=ic00+1
      if (iop(35) .gt. 0) then
c-------Prepare the uspar0 and uspar1 linear combinations of the potential coefs
        call lincm3(qslt,#ST,1,nstfa0,1,uspar0,uspar1)
        if (iop(26) .eq. 4) then
c         General 1-6-12 solvent
          call lincm3(qtv,#GT,#GV,nstfa0,nslv,uspar0,uspar1)
          call lincm3(c6tv,#GT,#GV,nstfa0,nslv,uspar0,uspar1)
          call lincm3(c12tv,#GT,#GV,nstfa0,nslv,uspar0,uspar1)
        else
c         Water solvent
          call lincm3(qji,#ST,2,nstfa0,2,uspar0,uspar1)
          call lincm3(c6ji,#ST,2,nstfa0,2,uspar0,uspar1)
          call lincm3(c12ji,#ST,2,nstfa0,2,uspar0,uspar1)
        end if
      end if
      lclen=1
      if (iop(30) .ge. 7) then
c       Flexible solute
c       lclen is the number of columns in the pre-combined slt-slt arrays
c       For the L-J interactions (energy coupling) - 2 only for Clem lib
        if (iop(3) .eq. 1 .or. iop(29) .eq. 1) lclen=2
      end if
c     Use qslteps for intramolecular energy calcs to incorporate the diel. c.
      do i=1,nstta
        qslteps(i)=qslt(i)/sqrt(dielc)
      end do
      if (iop(26) .eq. 4) then
        sigpxa=sigslv(islvrep)
      else
        sigpxa=sigmaw
      end if
      if (sigpxa .eq. 0.0) sigpxa=3.15
      return
2000  format(' ***** ERROR: user-defined molecule #',i3,' is found to ',
     -  'be',i3,'molecules - this will interfere with setting up the ',
     -  'torsions',/,7x,'Either modify the MOLD key to reflect the ',
     -  'molecule boundaries or use the MAKB key to connect the ',
     -  'fragments')
2001  format(' ===== STRONG WARNING: user-defined molecule #',i3,
     -  ' is found to be',i5,' molecules')
2003  format(' ***** ERROR: neighbor lists for colute copies 1 and',i2,
     -  ' differ for atoms ',i4,' and ',i4,':')
2004  format(' Neighbors for atom ',i4,':',20i5)
2005  format(' ***** ERROR: key RDBD is incompatible with keys MOLD, ',
     -  'CLON and FREE')
2006  format(' ***** ERROR: bond list file ended after',i6,' bonds')
2008  format(' NNREAD:',i5,' ian=',i3,(' in=',10i5))
2120  format(' Residue # ',i6,1x,a,' is in a disulfide-bond ',
     -  '(original residue #=',i6,')')
2121  format(' ***** ERROR: map-based potential use can not sample ',
     -  'cysteins in disulfide bonds that are not on the same flexible',
     -  ' stretch',/,14x,'- remove these residues ',
     -  ' from the FLXR list')
2158  format(' ***** ERROR: atom number of the last defined ',
     -  'solute molecule (',i6,') exceeds the number of solute ',
     -  'atoms (',i6,')')
5711  format(' INITPF ',a,' conversion:',/,(i4,' ianslv=',i3,
     -  ' iclslv=',i3,' pflabslv=',a,' labslv=',a))
5712  format(' INITPF: ic,ig=',2i4,' ipfgr=',i2,' ipff,l=',2i5,
     -        ' nslvg,nsvst=',2i3)
5713  format(' INITPF: i,j=',2i4,' qvv=',f10.5,' c6vv=',e12.5,
     -  ' c12vv=',e12.5)
9100  format(' ***** ERROR: group ',i4,' contains atoms with ',
     -  'different potentials:',2i6)
9101  format(' ***** ERROR: solute atom type is out of range',
     -  ' [1,',i3,'] :',i4,/,59x,'for solute atom ',i4)
9102  format(' ***** ERROR: QPEN solute-solvent potential can ',
     -  'not be combined with other potentials')
9104  format(' ***** ERROR: Clementi potentials can only be used ',
     -  'with MCY water')
9105  format(' ***** ERROR: solute atom type',i8,' is not defined',
     -  ' for solute atom ',i4)
 
9110  format(' ***** ERROR: solvent atom type is out of range',
     -  ' [1,',i3,'] :',i4,/,59x,'for solvent atom ',i4)
9111  format(' ***** ERROR: solvent atom type',i8,' is not defined'
     -  ,' for solvent atom ',i4)
9112  format(' ***** ERROR: general solvent of type ',a,' is ',
     - 'not implemented')
 
9115  format(' ***** ERROR: potential label (type) ',a,
     -  ' potential library ',a,1x,a,' atom ',i5,' is not defined')
9116  format(' NOTE: missing potential types can be defined with the ',
     -  'PMOD key',/,7x,'Potential library can be specified either ',
     -  'with the SUPT key or individually in each atom record')
9118  format(' ----- WARNING: potential type for the third copy',
     -  ' of group',i4,' is changed from ',i2,' to ',i2)
9119  format(' ===== STRONG WARNING: group',i5,' (',a,' atom range: [',
     -  i6,',',i6,']) is not fully connected - at least',i3,' bonds ',
     -  'are needed',/,' Use the MAKB key to fix this problem')
9120  format(' ***** PROGRAM ERROR: iop37=0 and iop(26)=0')
9121  format(' ----- WARNING: can not break bond between atoms ',i4,
     -  ' and ',i4,': bond does not exist')
9122  format(' ----- WARNING: can not make bond between atoms ',i4,
     -  ' and ',i4,': bond already exists')
9123  format(' ===== STRONG WARNING: the mixing rule of the solute ',
     -  'potential disagrees with the mixing rule set - see MIXR key')
9124  format(' ***** ERROR: general solvent potential requires the ',
     -  'SLVA key')
9125  format(' ===== STRONG WARNING: Gromos intramolecular parameters',
     -  ' have been implemented only using combination rules')
9126  format(' ===== STRONG WARNING: atom ',i5,' (',2a4,') is a ',
     -  'hydrogen with',i2,' neighbours:')
9127  format(' ----- WARNING: bond between (listwise) distant atoms:',
     -  2(i5,' (',2a4,')'),' Distance=',f6.3,' Threshold=',f6.3)
9128  format(' ***** PROGRAM ERROR: atom ',i5,' is a neighbour of ',
     -  'atom ',i5,' but atom ',i5,' is NOT a neighbour of atom ',i5)
9129  format(' ===== STRONG WARNING: all neighbours of atom ',i5,
     -  ' are hydrogens - a bond is likely to be missing')
9130  format(1x,a,' bond between atoms ',i5,' (',a4,1x,a4,') and ',i5,
     -  ' (',a4,1x,a4,') distance=',f8.3,' A')
9131  format(' To eliminate warnings, try using either ',a4,i5,' ~',/,
     -  (12i6,' ~'))
9132  format(24x,'or change the built-in bond threshold values with ',
     -  'the key MODA')
9133  format(' ***** ERROR: the end of the',i4,'-th defined solute ',
     -  'molecule (',i6,') is in the middle of group(residue) ',i6)
9134  format(' ----- WARNING: the end of last defined solute molecule ',
     -  '(',i8,') ','is in not the last solute atom (',i6,')')
9135  format(' ----- WARNING: cloned solute: making/breaking of bonds ',
     -  'have to be done on each copy')
9136  format(' ***** ERROR: invalid pair of atoms for ',a,' a bond: ',
     -  2i9)
9137  format((3x,2(4x,'Atom',i5,' (',2a4,') Distance=',f6.3,
     -  ' Threshold=',f6.3)))
9138  format(' +++++ Inputted ',a,' charges replaced by the stored ',
     -  'OPLS charges')
9139  format(' ----- WARNING: atom',i5,' (',2a4,'), atomic no=',i3,
     -  ' has',i3,' neighbours:')
9140  format(' ----- WARNING: atom ',i6,' type=',a,' hard sphere ',
     -  'radius is zero')
9141  format(' ===== STRONG WARNING: Hard sphere intramolecular ',
     -  'interactions are implemented as 2**(1/6)*SIGMA repulsions')
9142  format('  >>>>> OVERRIDE:: atom ',i6,' type=',a,' is a hard ',
     -  'sphere - charge (',f6.3,') is set to zero')
9143  format(' ***** ERROR: COM-based cutoff on solute consisting of ',
     -  'more than one molecules is meaningless')
9144  format(' ***** ERROR: solute group ',i4,' (',i6,' - ',i6,') ',
     -  'has more an additional center specified (atom #',i7,')')
9145  format(' ***** ERROR: There are ',i3,' atom types unknown to ',
     -  'MMC (see also above) - use the PMOD key to define them:',/,
     -  (20(1x,a4)))
9146  format(1x,a,' short bond between atoms ',i5,' (',a4,1x,a4,') and',
     -  i6,' (',a4,1x,a4,') r=',f6.2,' A')
9147  format(' ***** ERROR: coordinates of solute atoms ',
     -  i5,' (',a4,1x,a4,') and ',i5,' (',a4,1x,a4,') are identical')
9148  format(1x,a,' largest group radius (',f5.1,' A) ',a,
     -  ' the half of the solute-',a,' cutoff (',f5.1,')',/,
     -  7x,' - increase it with the ',a,' key')
9149  format(' ***** ERROR: constrained atom in pair (',i6,',',i6,') ',
     -  'is outside the solute atom range [0,',i6,']')
9150  format(' ***** ERROR: constrained atom pair (',i6,',',i6,') ',
     -  ' is ',a)
9151  format(' ***** ERROR: both atoms of the constrained atom pair (',
     -  i6,',',i6,') is outside the sampled part of the solute',/,
     -  14x,'New indices:',i6,',',i6)
9152  format(' New indices:',i6,',',i6,' New limit=',i6)
9153  format(' ===== STRONG WARNING: Bond ',i6,' - ',i6,' is between ',
     -  ' grid-contributing atoms (new indices:',2i7,')')
9154  format(' ***** ERROR: Bond ',i6,' - ',i6,' is between explicit ',
     -  ' and grid-contributing atoms (new indices:',2i7,')')
9155  format(' ***** ERROR: one or both atoms of bond ',i6,' - ',i6,
     -  ' to be ',a,' is out of range')
      end
      subroutine breakbond(nneig,nneiga,nneigh,ineig,ianslt,i1,i2,n1,n2,
     -  iout,nwarn,maxat,maxneig)
c#    MMC routine  38 lstmod: 11/17/03
c*****Remove a bond
      dimension nneig(maxat),nneiga(maxat),nneigh(maxat),ianslt(maxat),
     -  ineig(maxneig,maxat)
      n1=0
      n2=0
      if (i1 .gt. maxat .or. i2 .gt. maxat) then
        write (iout,1000) i1,i2,maxat
        nwarn=nwarn+1
      else
        do in=1,nneig(i1)
          if (ineig(in,i1) .eq. i2) n2=in
        end do
        do in=1,nneig(i2)
          if (ineig(in,i2) .eq. i1) n1=in
        end do
      end if
      if (n1*n2 .gt. 0) then
        do in=n1,nneig(i2)
          ineig(in,i2)=ineig(in+1,i2)
        end do
        nneig(i2)=nneig(i2)-1
        if (n1 .le. nneiga(i2)) nneiga(i2)=nneiga(i2)-1
        if (ianslt(i1) .eq. 1) nneigh(i2)=nneigh(i2)-1
        do in=n2,nneig(i1)
          ineig(in,i1)=ineig(in+1,i1)
        end do
        nneig(i1)=nneig(i1)-1
        if (n2 .le. nneiga(i1)) nneiga(i1)=nneiga(i1)-1
        if (ianslt(i2) .eq. 1) nneigh(i1)=nneigh(i1)-1
      end if
      return
1000  format(' ----- WARNING: illegal bond definition to break:',i6,
     -  ' -',i6,' - atomindex can not exceed',i6)
      end
      subroutine sltcoefs(sigw,epsw,qp,qn,sigslt,epsslt,
     -  iclslt,qslt,dielc,sig,eps,qji,c6ji,c12ji,sig14,eps14,
     -  sigpf14,epspf14,ia,iopcomb)
c#    MMC routine  39 lstmod: 05/19/16
c*****Generate constants for a L-J type potential
      dimension sigslt(#ST),epsslt(#ST),iclslt(#ST),
     -  qslt(#ST),sig(#AT),eps(#AT),sigpf14(#AT),epspf14(#AT),
     -  sig14(#ST),eps14(#ST),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
c     Prepare constant products for eslt, collect slt eps, sig.
      sigslt(ia)=sig(iclslt(ia))
      epsslt(ia)=eps(iclslt(ia))
c     Special 1-4 LJ parameters (for Charmm)
      sig14(ia)=sigpf14(iclslt(ia))
      eps14(ia)=epspf14(iclslt(ia))
      qji(ia,1)=qslt(ia)*qn/dielc
      call combestoc6c12(sigslt(ia),sigw,epsslt(ia),epsw,c6ji(ia,1),
     -  c12ji(ia,1),iopcomb)
      qji(ia,2)=qslt(ia)*qp/dielc
      c6ji(ia,2)=0.0
      c12ji(ia,2)=0.0
      return
      end
      subroutine combestoc6c12(sig1,sig2,eps1,eps2,c6,c12,iopcomb)
c#    MMC routine  40 lstmod: 01/17/07
c*****Obtain the c6, c12 coefs from the epsilons and sigmas with the
c     requested combination rule.
      real*8 sigma,epsilon,dsig1,dsig2,deps1,deps2
      dsig1=sig1
      dsig2=sig2
      deps1=eps1
      deps2=eps2
      if (iopcomb .eq. 0) then
        sigma=dsqrt(dsig1*dsig2)
        epsilon=dsqrt(deps1*deps2)
      else
        sigma=(dsig1+dsig2)/2.0
        epsilon=dsqrt(deps1*deps2)
      end if
      c6=4.d0*epsilon*sigma**6
      c12=4.d0*epsilon*sigma**12
      return
      end
      subroutine c6c12toes(c6,c12,sigma,epsilon)
c#    MMC routine  41 lstmod: 09/08/00
c*****Obtain the the epsilons and sigmas from the c6 and c12's
      if (c6 .gt. 0.0) then
        sigma=(dble(c12)/dble(c6))**(1.d0/6.d0)
        epsilon=dble(c6)**2/(4.d0*dble(c12))
      else
        sigma=1.0
        epsilon=0.0
      end if
      return
      end
      subroutine setljconst(maxtyp)
c#    MMC routine  42 lstmod: 12/22/14
      dimension maxtyp(11)
c*****Set all c6/12; eps/sig values for the built-in types
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /wlj3q/ abljqh(3,8)
c-----Prepare epsilon and sigma (in kcal/mol & A) for both Kollmann potentials
c     and Charmm
      do i=1,max0(maxtyp(3),maxtyp(4),maxtyp(5))
        sigamb02(i)=2.0*rminamb02(i)/(2.0**(1.0/6.0))
        epsamb(i)=enminamb02(i)
        sigkol94(i)=2.0*rmin94(i)/(2.0**(1.0/6.0))
        epskol94(i)=enmin94(i)
        sigcha(i)=2.0*rmincha(i)/(2.0**(1.0/6.0))
        epscha(i)=emincha(i)
c       Charmm 22 has separate 1-4 LJ parameters
        sigcha14(i)=2.0*rmincha14(i)/(2.0**(1.0/6.0))
        epscha14(i)=emincha14(i)
      end do
c     Define TIPS3P parameters
c     Kollman-Cornell types 41&42 refer to O&H(TIP3P water), respectively
      call c6c12toes(abljqh(1,5),abljqh(2,5),sigkol94(41),epskol94(41))
      sigkol94(42)=0.0
      epskol94(42)=0.0
c-----Prepare epsilon and sigma (in in kcal/mol & A) for BVG/Gromos potentials
      do i=1,max0(maxtyp(6),maxtyp(7))
        call c6c12toes(c6bvg(i)**2,c12bvg(i)**2,sigbvg(i),epsbvg(i))
        call c6c12toes(c6bvg14(i)**2,c12bvg14(i)**2,
     -    sigbvg14(i),epsbvg14(i))
        call c6c12toes(c6gro(i)**2,c12gro(i)**2,siggro(i),epsgro(i))
        call c6c12toes(c6gro14(i)**2,c12gro14(i)**2,
     -    siggro14(i),epsgro14(i))
      end do
c     write (6,*) 'SETLJ epscha1-3=',(epscha(i),i=1,3)
      return
      end
      subroutine initpfslt(nslt0,nslt,iopslt,iclslt,iclsltt,indextyp)
c#    MMC routine  43 lstmod: 04/24/15
c*****Prepare the solute-solute c6 c12 coefficient matrix
      dimension iopslt(#ST),iclslt(#ST),iclsltt(#ST),
     -  indextyp(#UU)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /worksp/ l1(#NA),ityporg(#UV),ipot(#UV),
     -  l4(#UV)
      ntypused=0
      do i=nslt0,nslt
        ict=iclslt(i)+#AT*iopslt(i)
        do j=1,ntypused
          if (ict .eq. indextyp(j)) then
c           This type has been already found
            iclsltt(i)=j
            go to 8001
          end if
        end do
c       New type
        ntypused=ntypused+1
        call checkdim(ifail,iout,inperr,'UU',ntypused,0,0,0)
        if (ifail .eq. 1) go to 8999
        indextyp(ntypused)=ict
        ityporg(ntypused)=i
        ipot(ntypused)=iopslt(i)
        iclsltt(i)=ntypused
c       iclsltt(i) will point to the condensed type list
8001    continue
      end do
8999  do i=1,ntypused
        do j=1,ntypused
          call combestoc6c12(sigslt(ityporg(i)),sigslt(ityporg(j)),
     -      epsslt(ityporg(i)),epsslt(ityporg(j)),
     -      c6tt(j,i),c12tt(j,i),iop(52))
          call combestoc6c12(sig14(ityporg(i)),sig14(ityporg(j)),
     -      eps14(ityporg(i)),eps14(ityporg(j)),
     -      c6tt14(j,i),c12tt14(j,i),iop(52))
          if (idebug(153) .gt. 0) write (iout,1001) i,j,
     -      c6tt(j,i),c12tt(j,i),c6tt14(j,i),c12tt14(j,i)
        end do
      end do
      return
1001  format(' INITPFSLT i,j=',2i3,' c6,c12=',2e12.5,' c614,c1214=',
     -  2e12.5)
      end
      subroutine qpenin
c#    MMC routine  44 lstmod: 07/13/00
c*****Initialization routine for solute-solvent pot fun in QPEN form.
c     Reads all the requisite parameters.
c     Originally written by P.K. Mehrotra
      common /param/ edgexyz(3),edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /cqpen/ qnn(#TN,#VN),qne(#TN,#VE),qen(#TE,#VN),
     -  qee(#TE,#VE),aee(#TE,#VE),bee(#TE,#VE),cee(#TE,#VE),
     -  iopict,nsltn,nslvn,nslte,nslve
      common /qpnabc/ aslt(#TE),bslt(#TE),dslt(#TE),aslv(#VE),
     -  bslv(#VE),dslv(#VE)
      common /option/ iop(200),idebug(200)
      common /cvdw/ vdm2(#TN,#VN),cutin,escale
      character*80 line
      common /inpline/ line,lineno,icol
c     nsltn - no of nuclei on solute
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
c     nslvn - no of nuclei on solvent
c     nslte - no of electrons on solute
c     nslve - no of electrons on solvent
c     Find nsltn,nslte from iclslt
      nsltn=0
      do i=1,nstta
        if (iclslt(i) .gt. 36) go to 11
        nsltn=nsltn+1
      end do
11    n2=nsltn+1
      nslte=0
      do i=n2,nstta
        if (iclslt(i) .eq. 40) nslte=nslte+1
        if (iclslt(i) .le. 36) then
          inperr=inperr+1
          write (iout,105) i
105       format(' ***** ERROR:',i4,'-th solute center is out of ',
     -      'order (EPEN/QPEN)')
        end if
      end do
c     Find nslvn,nslve from ianslv
      nslvn=0
      do i=1,nslv
        if (ianslv(i) .gt. 36) go to 21
        nslvn=nslvn+1
      end do
21    n2=nslvn+1
      do i=n2,nslv
        if (ianslv(i) .lt. 39) then
          inperr=inperr+1
          write (iout,205) i
205       format(' ***** ERROR:',i4,'-th solvent center is out of ',
     -      'order (EPEN/QPEN)')
        end if
      end do
      n2=nslvn+1
      nslve=0
      do i=n2,nslv
        if (ianslv(i) .eq. 40) nslve=nslve+1
        if (ianslv(i) .lt. 40) then
          inperr=inperr+1
          write (iout,205) i
        end if
      end do
c     a,b and c parameters for the solute electrons
      irectx=19
      call getnextrec(inpt,iout,irectx,nwwarn)
      read (line,130,err=999) (aslt(i),bslt(i),dslt(i),i=1,nslte)
      if (iop(24) .gt. 0) write (iout,1319) (aslt(i),bslt(i),dslt(i),
     -  i=1,nslte)
c     a,b and c parameters for  the solvent electrons
      irectx=20
      call getnextrec(inpt,iout,irectx,nwwarn)
      read (line,130,err=999) (aslv(i),bslv(i),dslv(i),i=1,nslve)
      if (iop(24) .gt. 0) write (iout,1320) (aslv(i),bslv(i),dslv(i),
     -  i=1,nslve)
      do i=1,nslte
        do j=1,nslve
          cee(i,j)=sqrt(dslt(i)*dslv(j))
          aee(i,j)=sqrt(aslt(i)*aslv(j))
          bee(i,j)=0.5*(bslt(i)+bslv(j))
        end do
      end do
      do i=1,nsltn
        do j=1,nslvn
          qnn(i,j)=qslt(i)*qslv(j)/dielc
        end do
      end do
      do i=1,nsltn
        do j=1,nslve
          qne(i,j)=qslt(i)*qslv(nslvn+j)/dielc
        end do
      end do
      do i=1,nslte
        do j=1,nslvn
          qen(i,j)=qslt(nsltn+i)*qslv(j)/dielc
        end do
      end do
      do i=1,nslte
        do j=1,nslve
          qee(i,j)=qslt(nsltn+i)*qslv(nslvn+j)/dielc
        end do
      end do
c     Parm for the inner cutofs for QPEN potential
c     iopict .eq. 0 : regular QPEN, no inner cutoff
c     iopict .eq. 1 : QPEN with hard sphere around the cm of the solute
c     iopict .eq. 2 : QPEN with van der Waals envelop on solute, solvent
      call getnextrec(inpt,iout,irectx,nwwarn)
      read (line,131,err=999) cutin,escale,iopict
      if (iop(24) .gt. 0) write (iout,1321) cutin,escale,iopict
      if (escale.eq.0.0) escale=1.0
      if (iopict .ne. 2) return
c     Set up van der Waals radius matrix
      do i=1,nsltn
        do j=1,nslvn
          vdm2(i,j)=(vdw(ianslt(i))+vdw(ianslv(j)))**2
        end do
      end do
      return
999   call invalidform(iout,irectx)
130   format(3f20.10)
131   format(2f20.10,i5)
1319  format(' rectype 19  : ',3f20.10)
1320  format(' rectype 20  : ',3f20.10)
1321  format(' rectype 21  : ',3f20.10,i5)
      end
      subroutine initbc(iop5,edg1,edg2,edg3,iop24,inpt,iout)
c#    MMC routine  45 lstmod: 06/27/07
c*****Initialize the boundary-condition characteristics
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /rangen/ xlim,ylim,zlim,xlim2,ylim2,zlim2,ixpxo
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      character*80 line
      common /inpline/ line,lineno,icol
c     For FCC bc the unit cell volume is 2*edge**3, the max inscribed
c     sphere radius is edge/sqrt(2.0) and the near neighbour cells
c     are centered at (+/-edge,+/-edge,+/-edge).
c     For hexagonal prism unit cell the volume is edgex*edge**2*3*
c     sqrt(3)/2; the inscribed sphere radius is min(edgex/2,edge*sqrt(3)/2)
c     constants for hexagonal prism bc.
      call zeroit(cci,3*#MO)
      if (iop5 .eq. 0) then
c       Rectangular (generalized simple cubic)
c       edgexa,edgeya,edgea: box edges in the x,y,z directions, resp.
c       edgex2,edgey2,edge2: half box edges in the x,y,z directions, resp.
        edgexa=edg1
        edgeya=edg2
        edgea=edg3
        edgex2=edgexa/2.0
        edgey2=edgeya/2.0
        edge2=edgea/2.0
        rinscr=amin1(edgexa,edgeya,edgea)/2.0
        rcirc=sqrt(edgexa**2+edgeya**2+edgea**2)/2.0
        rboxmax=amax1(edgexa,edgeya,edgea)/2.0
        vol=edgexa*edgeya*edgea
c       dex,dey and dez: shifts needed in the vectorized rectangular PBC calc.
        dex(1)=edgexa
        dex(2)=edgexa
        dex(3)=0.0
        dex(4)=-edgexa
        dex(5)=-edgexa
        dey(1)=edgeya
        dey(2)=edgeya
        dey(3)=0.0
        dey(4)=-edgeya
        dey(5)=-edgeya
        dez(1)=edgea
        dez(2)=edgea
        dez(3)=0.0
        dez(4)=-edgea
        dez(5)=-edgea
        xlim=edgex2
        ylim=edgey2
        zlim=edge2
      else if (iop5 .eq. 1) then
c       Face-centered cubic
c       edgexa,edgeya,edgea: FCC cell parameter (all 3 the same)
        edgea=edg1
        edgexa=edgea
        edgeya=edgea
        edge2=edgea
        edgex2=edge2
        edgey2=edge2
        rinscr=edgea/sqrt(2.0)
        rcirc=edgea
        rboxmax=edgea
        vol=2.0*edgea**3
        xlim=edgea
        ylim=edgea
        zlim=edgea
      else if (iop5 .eq. 2) then
c       HCP
c       edgexa,edgeya,edgea: HCP cell diameter (all 3 the same)
        edgea=edg1
        edgexa=edgea
        edgeya=edgea
        edge2=edgea/2.0
        edgex2=edge2
        edgey2=edge2
        rinscr=edge2
        rcirc=edgea*3.0/(sq5*2.0)
        rboxmax=rcirc
        vol=edgea**3/sqrt(2.0)
        xlim=edgea/2.0
        ylim=edgea/sqrt(3.0)
        zlim=rboxmax
        edgsq3p2=edgexa*sq3p2
        edgsq2p3=edgexa*sq2p3
        edgp2sq3=edgexa/(2.0*sq3)
        edgpsq3=edgexa/sq3
        edg2psq3=edgexa/sq3p2
      else if (iop5 .eq. 3) then
c       TOCT
c       edgexa,edgeya,edgea: distance of squares from center (all 3 the same)
        edgea=edg1
        edgexa=edgea
        edgeya=edgea
        edge2=edgea
        edgex2=edge2
        edgey2=edge2
        rinscr=edgea*sqrt(3.0)/2.0
        rcirc=edgea*sq5/2.0
        rboxmax=edgea
        vol=4.0*edgea**3
        xlim=edgea
        ylim=edgea
        zlim=edgea
        et1=4.0*edgexa
        et2=4.0*edgexa**2
        et3=2.0*edgexa
        et4=3.0*edgexa**2
      else if (iop5 .eq. 4) then
c       Hexagonal prism
c       edgexa: length of the hex prism
c       edgea=edgeya=edge2: edge of the hexagon
        edgea=edg2
        edgexa=edg1
        edgeya=edgea
        edgex2=edgexa/2.0
        edge2=edgea
        rinscr=amin1(edgexa/2.0,edgea*sq3p2)
        rcirc=sqrt((edgexa/2.0)**2+edgea**2)
        rboxmax=amax1(edgexa/2.0,edgea)
        vol=edgexa*edgea**2*3.0*sq3p2
c       dexhex: shift needed in the vectorized PBC calc.
        dexhex(1)=edgexa
        dexhex(2)=edgexa
        dexhex(3)=0.0
        dexhex(4)=-edgexa
        dexhex(5)=-edgexa
c       Constants for the cell limit decision for the vectorized calcs.
        chexdx(1)=1.0
        chexdx(2)=sq3
        chexy(1)=edge2*sq3p2
        chexy(2)=edge2
        xlim=edgex2
        ylim=edgea*sq3p2
        zlim=edgea
      else if (iop5 .eq. 5 .or. iop5 .eq. 6) then
c       Sphere or PHS boundary conditions
        rinscr=edg1
        rcirc=edg1
        rboxmax=edg1
        if (iop5 .eq. 6) rboxmax=amax1(999.9,edg1)
        vol=pi43*rinscr**3
        edge2=edg1
        edgex2=edge2
        edgey2=edge2
        edgea=2.0*edge2
        edgexa=edgea
        edgeya=edgea
        xlim=rinscr
        ylim=xlim
        zlim=xlim
      else
c       Input boundary conditions
        irectx=29
        ireadok=0
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) rinscr,vol,rboxmax
        ireadok=1
999     if (iop24 .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1338) rinscr,vol,rboxmax
C@DM        call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
        if (ireadok .eq. 0) call invalidform(iout,irectx)
C@DM          call MPI_Bcast(rinscr,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
C@DM          call MPI_Bcast(vol,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
C@DM          call MPI_Bcast(rboxmax,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
C@DM          if (iop24 .gt. 2 .and. MYRANK .eq. 0)
C@DM     -       write (iout,3000) MYRANK,rinscr,vol,rboxmax
        edgexa=edg1
        edgeya=edg2
        edgea=edg3
        edgex2=edgexa/2.0
        edgey2=edgeya/2.0
        edge2=edgea/2.0
        xlim=edgex2
        ylim=edgey2
        zlim=edge2
      end if
c     rinscr: inscribed sphere radius in a,rinscs: its square;
c     rboxmax: minimum radius enclosing the whole cell
      rinscs=rinscr**2
c     Random point range [-xlim,+xlim]
      xlim2=xlim*2.0
      ylim2=ylim*2.0
      zlim2=zlim*2.0
      return
1000  format(3f10.0)
1338  format(' rectype 29  : ',3f10.5)
C@DM3000  format(' MPI in initbc MYRANK=',i3,' rectype 29:',3f10.5)
      end
      subroutine inicac
c#    MMC routine  46 lstmod: 08/06/17
c*****Initialize constants, accumulators
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /liga/ ligand_start_molecule,last_slt_mol_g
      common /reactionfield/ epsrf,rccon
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      real*8 ue0ind,ue1ind,ue0ttnb,ue1ttnb,ue0innb,ue1innb,
     -  ue0t14,ue1t14,ue0tor,ue1tor
      common /frind5/ ue0ind(3),ue1ind(3),ue0ttnb(3),ue1ttnb(3),
     -  ue0innb(3),ue1innb(3),ue0t14(3),ue1t14(3),ue0tor(3),ue1tor(3)
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 fsmslt,fsmslv,tsmslt,tsmslv,wpsmvi
      common /quantm/ fsmslt,fsmslv,tsmslt(3),tsmslv(3),wpsmvi,nsslt
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /howfar/ dtot(#MI,2),decay(#MI,2),nhowfar,nhowfarsamp
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /shuffl/ isser,isserpd,isserpt,itry(#MO),
     -  itrypd(#MM),itrypt(#MM)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      common /torauc/ nmctorauc,ntorsaved,ntaucprint,nauc(#AU),
     -  tauc_timestep,tauc_min,torsave(#AU,#TR),auctor(#AU,#TR)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /cqpen/ qnn(#TN,#VN),qne(#TN,#VE),qen(#TE,#VN),
     -  qee(#TE,#VE),aee(#TE,#VE),bee(#TE,#VE),cee(#TE,#VE),
     -  iopict,nsltn,nslvn,nslte,nslve
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /cavprb/ ndistr(#MO),ninstr(#MO),nocavf(#MO),
     -  ndela,nran,ndlast,nmdlst,niddst,namin,namax
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      character*15 selectname
      character*23 movname
      character*36 exbiname
      common /stratnames/ selectname(4),movname(7),exbiname(5)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /gather/ indexx(#UV),l1(#UV),l2(#UV),l3(#UV),
     -  ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /ecell/ cic(3,27),ncell
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /tpn/ edgexyz0(3),edge2xyz0(3),rinscr0(3),vol0,cic0(3,27),
     -  dex0(5),dey0(5),dez0(5),chexdx0(2),chexy0(2),dexhex0(5),vrange,
     -  volfac(3),vlam,vlamt,vvlmt,vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyy,
     -  vvlmtzz,vvlmtyz,complfac,sqcomplfac,ixyzfreeze(3),iscaletyplast
      real*8 ediffsm,ediffsm2,expediffsm
      common /virtvolcha/ ediffsm,ediffsm2,expediffsm,ediffmn,ediffmx,
     -  volchaperc,volchafac(3),volchadiff(3),delvvol,delvarea
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      character*11 stunen
      common /tunelab/ stunen(4)
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      dimension c23(3),c2x(3)
      data rfac /1.0/,itnowid /1/
      numdiscr=0
      call initcutoff(iout,nwarn)
      if (epsrf .ne. -1.0) then
        rccon=((epsrf-1.0)/(2.0*epsrf+1.0))/cutslv**3
        if (iop(57)+iop(58)+iop(64)+iop(66) .gt. 0 .and.
     -    abs(cutslv-cutuu) .gt. 0.001) then
          if (MYRANK .eq. 0) write (iout,1027) 'solute-solute',cutuu
          inperr=inperr+1
        end if
        if (nmolec .gt. 1 .and. abs(cutslv-cutslt) .gt. 0.001) then
          if (MYRANK .eq. 0) write (iout,1027) 'solute-solvent',cutslt
          inperr=inperr+1
        end if
      end if
      if (iop(71) .gt. 0 .or. iop(106) .gt. 0) then
c       (TPN) ensemble initialization
        vol0=vol
        vmin=vol
        vmax=vol
        call trnsfr(cic0,cic,3*ncell)
        call trnsfr(edgexyz0,edgexyz,3)
        call trnsfr(edge2xyz0,edge2xyz,3)
        if (iop(5) .eq. 0 .or. iop(5) .eq. 5) then
c         Rectangular or spherical
          call trnsfr(rinscr0,edge2xyz0,3)
        else if (iop(5) .eq. 4) then
c         HEXP
          rinscr0(1)=edge2xyz0(1)
          rinscr0(2)=edgexyz0(2)*sq3p2
          rinscr0(3)=rinscr0(2)
        else if (iop(5) .lt. 5) then
c         FCC
          if (iop(5) .eq. 1) rfac=1.0/sqrt(2.0)
c         HCP
          if (iop(5) .eq. 2) rfac=1.0/2.0
c         TOCT
          if (iop(5) .eq. 3) rfac=sq5/2.0
          do k=1,3
            rinscr0(k)=edgexyz(k)*rfac
          end do
        end if
        rinscr=amin1(rinscr0(1),rinscr0(2),rinscr0(3))
        do k=1,3
          volfac(k)=1.0
        end do
        call trnsfr(dex0,dex,5)
        call trnsfr(dey0,dey,5)
        call trnsfr(dez0,dez,5)
        if (iop(5) .eq. 4) then
          call trnsfr(chexdx0,chexdx,2)
          call trnsfr(chexy0,chexy,2)
          call trnsfr(dexhex0,dexhex,5)
        end if
        iscaletyplast=4
      end if
      if (iop(106) .gt. 0) then
c       Virtual volume changes
        ediffsm=0.0d0
        ediffsm2=0.0d0
        expediffsm=0.0d0
        nvvchmc=0
        ediffmn=realmx
        ediffmx=-realmx
        vpincr=volchaperc/100.0
        if (iop(106) .eq. 1) then
c         Pressure calculation, isotropic volume scaling
          do k=1,3
            volchafac(k)=(1.0+vpincr)**(1.0/3.0)
            volchadiff(k)=volchafac(k)-1.0
          end do
          delvvol=vol*vpincr
        else
          delx=(sqrt(vpincr**2+4.0*vpincr)-vpincr)/2.0
          delyz=vpincr/delx
          do k=1,3
            volchafac(k)=1.0+delyz
            volchadiff(k)=delyz
          end do
          volchafac(iop(106)-1)=1.0-delyz
          volchadiff(iop(106))=delyz
          delvarea=(vol/edgexyz(iop(106)-1))*delyz
        end if
        if (idebug(38) .gt. 0) write (iout,1711) volchafac,volchadiff
      end if
      volav=vol
c     nsvtmx: the maximum number of solvent centers participating
c     in slt-slv interactions
      nsvtmx=0
      do ig=1,npfgr(4)
        if (nstsvgr(ig) .gt. nsvtmx) nsvtmx=nstsvgr(ig)
      end do
c     nslvsv: number of solvent centers used for solvent-solvent eng.
c     nslv3 is 3*nslvsv.
      if (iop(26) .eq. 0) nslvsv=4
      if (iop(26) .eq. 1) nslvsv=3
      if (iop(26) .eq. 2) nslvsv=4
      if (iop(26) .eq. 3) nslvsv=5
      if (iop(26) .eq. 4) nslvsv=nslv
      nslv3=3*nslvsv
c     indats(i) is a reference index to select from the solvent
c     molecule the necessary atoms.
      do i=1,nslv
        indats(i)=i
        if (i .gt. nslvn .and. iop(3) .eq. 2) indats(i)=i
      end do
      if (iop(57)+iop(58) .gt. 0 .or. iop(18) .gt. 0) then
        if (iop(3) .eq. 2 .or. iop(29) .eq. 2) then
          if (MYRANK .eq. 0) write (iout,1030)
          inperr=inperr+1
        end if
      end if
      if (iop(58) .eq. 0) then
        if (iop(96) .eq. 1 .or. iop(96) .gt. 4) then
          iop(96)=0
          if (MYRANK .eq. 0) write (iout,1060) 'SCTR'
          nchng=nchng+1
        end if
      end if
      if (iop(18) .eq. 4 .and. iop(38) .gt. 0) then
        iop(38)=0
        nchng=nchng+1
        if (MYRANK .eq. 0) write (iout,1058)
      end if
      if (iop(104) .gt. 0) then
c       Tom: Set the last solute molecule to consider in calls to esltsltg
        last_slt_mol_g = nsttm - ligand_start_molecule
      else
        last_slt_mol_g = nsttm
      end if
      if (iop(30) .le. 2) then
        iop(18)=0
        call trnsfr(c,cslt,3*nstfa)
      else if (iop(30) .eq. 3) then
c       Create add-on fragments in the reference conformation
        do it=ifirstt(1),ilastt(nmolwid)
          dihang(it)=0.0
        end do
        do im=1,nmolwid
          ifatw=ifirstm(im)
          ifatw1=ifatw-1
          ilatw=ilastm(im)
          do k=1,nghanchor
            call trnsfr(c(1,ifatw1+k),c(1,ighanchor(k)),3)
          end do
          call arrdiff(c2x,c(1,ighanchor(nghanchor+1)),
     -      c(1,ighanchor(nghanchor)),3)
          call arrdiff(c23,c(1,ifatw1+nghanchor+1),
     -      c(1,ifatw1+nghanchor),3)
          facins(im)=sqrt(sclprd(c23,c23)/sclprd(c2x,c2x))
c         Generate the replacement atom (the end of the torsion bond)
          do k=1,3
            c(k,ifatw+nghanchor)=c(k,ifatw-1+nghanchor)+
     -        c2x(k)*facins(im)
          end do
          iti=ifirstt(im)
          itg=ilastt(im)
          call inittor(ifirstt(im),ilastt(im),c,itangindx,
     -      iprecursor,nrot,irotlist,irotlinc,bond,bond2,angle,
     -      cangle,bond13,bond12,cangle13,bondf,bondproj,
     -      xfac13,xfac12,cangle40,bond420,idebug(23),iout,
     -      #TR,#ST)
          call gentor(ifirstt(im),ilastt(im),dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -      bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -      #TR,#ST)
        end do
        if (idebug(127) .gt. 0)
     -     write (iout,6433) (ia,(c(k,ia),k=1,3),ia=1,ilastm(nmolwid))
      end if
c     imolpd, imolpt are nonzero when part of the solute is moved or has torsion
c     itmfrst,itgfrst are the first solute molecule and torsion group, resp.,
c     that is not on a Widom soluet molecule
      imolpd=0
      if ((iop(30) .eq. 7 .and. iop(18) .ne. 4) .or. iop(57) .gt. 0)
     -  imolpd=1
      imolpt=0
      if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        imolpt=1
        itnowid=1
        itmfrst=1
        itgfrst=1
        if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
c         Find the first non-widom torsion group
          itmfrst=nstfm+1
          do while (itmfrst .lt. nsttm .and. ifirstt(itmfrst) .lt. 1)
            itmfrst=itmfrst+1
          end do
          itnowid=ifirstt(itmfrst)
          itgfrst=itorgrp(itnowid)
        end if
      end if
      ngrdmn=1
      ngrdmx=1
      if (iop(57) .gt. 0) then
        ngrdmn=movmolf
        ngrdmx=movmoll
      end if
      if (iop(30) .ge. 7) then
        ngrdmn=impmf1
        ngrdmx=max0(nstfm,ngrdmx)
      end if
      ngrddo=ngrdmx-ngrdmn+1
      if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        ngrtmn=nsttm
        ngrtmx=itmfrst
        do it=itnowid,ntang
          im=iamolslt(iquata(it,2))
          if (ngrtmn .gt. im) ngrtmn=im
          if (ngrtmx .lt. im) ngrtmx=im
        end do
        if (iop(30) .eq. 5) then
c         Make sure ppti is not turned off for groups affected by torsion
          do ia=1,nstta
            if (isltmv(ia) .eq. 2) noppti(igrslt(ia))=0
          end do
        end if
      else if (iop(30) .ne. 3 .and. iop(36) .eq. 0) then
c       if (iop(144) .eq. 0) ntorgrp=0
c       Set limits of flexible atoms
        do im=1,nsttm
          ifirstt(im)=1
          ilastt(im)=0
        end do
      end if
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) nwidta=ilastt(nmolwid)
      if (iop(7) .eq. 2 .and. (nstfm0 .ne. 2 .or. nstfg0 .ne. 2)) then
        if (MYRANK .eq. 0) write (iout,1015)
        inperr=inperr+1
      end if
c     For periodic solute, the solute-solvent distances are in 2d only
c     kxmn: first slt-slv distance component to be used in calculating dist.
      if (iop(2) .eq. 1) kxmn=2
      if (iop(2) .eq. 2) then
c       Crystal solute: don't move the slt and use min. image for slt-slv
        if (cedslt .ne. 0.0 .or. rtxslt .ne. 0.0) then
          cedslt=0.0
          rtxslt=0.0
          if (MYRANK .eq. 0) write (iout,1004)
          nchng=nchng+1
        end if
        if (iop(7) .eq. 0) then
          iop(7)=iop(7)+1
          if (MYRANK .eq. 0) write (iout,1005)
          nchng=nchng+1
        end if
      end if
      if (nstfa0 .eq. 1 .or. nstta  .eq. 1) then
        if (rtxslt .ne. 0.0) then
          if (MYRANK .eq. 0) write (iout,1045) rtxslt
          nchng=nchng+1
        end if
        rtxslt=0.0
      end if
      if (iop(43) .eq. 0 .and. numsolv .gt. 0) then
        if (iop(57)+iop(58) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,1048)
          inperr=inperr+1
          nchng=nchng+1
        else if (nsttg .gt. 10) then
          if (MYRANK .eq. 0) write (iout,1049) ' ===== STRONG',nsttg
          nwwarn=nwwarn+1
        else if (nsttg .gt. 3) then
          if (MYRANK .eq. 0) write (iout,1049) ' -----',nsttg
          nwarn=nwarn+1
        end if
      end if
      if (iop(30) .eq. 7) then
c       PMF solute
        if (iop(18) .ne. 4) then
c         No torsion coupling
c         Generate PMF center
          do k=1,3
            crmpmf(k)=(c(k,icent1-nstfa0)+c(k,icent2-nstfa0)+
     -        c(k,icent1-nstfa1)+c(k,icent2-nstfa1))/4.0
          end do
          if (iop(18) .eq. 0) then
            if (iop(58) .gt. 0) then
c             Can't use torsions with general linear combination
              if (MYRANK .eq. 0) write (iout,1028)
              nwarn=nwarn+1
            end if
          end if
        end if
        if (iop(19) .eq. 0 .and. iop(6) .gt. 4) then
c         Can't use FB on flexible solute
          iop(19)=1
          if (MYRANK .eq. 0) write (iout,1006)
          nchng=nchng+1
        end if
      end if
      if (iop(30) .eq. 7 .or. iop(57)+iop(58) .gt. 0) then
c       Immobilize solute
        if (cedslt .ne. 0.0 .or. rtxslt .ne. 0.0) then
          cedslt=0.0
          rtxslt=0.0
          isltmove=0
          if (MYRANK .eq. 0) write (iout,1016)
          nchng=nchng+1
        end if
      end if
      if (iop(107) .gt. 0) then
        do i=1,4
          if (istune(i) .gt. 0) then
            if (i .lt. 3 .and. iop(57) .eq. 0 .or.
     -          i .gt. 2 .and. iop(58) .eq. 0 .or.
     -          i .eq. 4 .and. iop(91) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,1059) stunen(i)
              nchng=nchng+1
              istune(i)=0
            end if
          end if
        end do
      end if
      if (iop(160) .eq. 0) then
        if (isltmove .gt. 0 .and. iop(50) .eq. 4) then
c         Solute that is not immobilized has to match unit icord
          inperr=inperr+1
          if (MYRANK .eq. 0) write (iout,1033)
        end if
        if (iop(50) .ge. 1 .and. iop(50) .le. 3 .and.
     -     iop(69) .gt. 0) then
c         Cloned solute can't be 'fixed'
          inperr=inperr+1
          if (MYRANK .eq. 0) write (iout,1047)
        end if
c       nsltfreq: explicitly given frequency of slt perturbations
        if (isltsmpl .eq. 0) then
c         If there is nothing to move on the solute, nsltfreq should be 0
          if (nsltfreq .gt. 0) then
            nsltfreq=0
            if (MYRANK .eq. 0) write (iout,1035)
            nchng=nchng+1
          end if
        else if (nmolec .eq. 1 .and. iop(41) .eq. 0) then
          if (nsltfreq .ne. 1) then
            nsltfreq=1
            if (MYRANK .eq. 0) write (iout,1043)
            nchng=nchng+1
          end if
        else
          if (nsltfreq .eq. 1) then
            nwwarn=nwwarn+1
            if (MYRANK .eq. 0) write (iout,1031)
          end if
        end if
      end if
      if (iop(82) .gt. 0 .and. iop(43) .gt. 0) then
c       Can't use group-based COM's with sensitivity analysis
        inperr=inperr+1
        if (MYRANK .eq. 0) write (iout,1024)
      end if
c     Set primitive PBC routine if required
      if (iop(30) .gt. 0 .and. iop(30) .le. 6) then
        if (iop(67)+iop(108) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,1018)
          inperr=inperr+1
        end if
c       Set default for coupling parameter exponent
        do k=1,3
          if (ptiexp(k) .eq.  0.0) ptiexp(k)=1.0
          tifacone(k)=1.0
          tifactwo(k)=1.0
        end do
c       Generate the TI integrand coefficients
        do k=1,3
          if (ptiexp(k) .ne. 1.0) then
            tifacone(k)=ptiexp(k)*cplpar**(ptiexp(k)-1.0)
            tifactwo(k)=ptiexp(k)*(1.0-cplpar)**(ptiexp(k)-1.0)
          end if
        end do
      end if
      if (iop(169) .gt. 0 .and. iop(175) .gt. 0) then
c       Permuting before analysis can only be run with MC using symmetric PBC
        if (iop(5) .eq. 4 .or. (iop(5) .eq. 1 .and.
     -    (edgexyz(1) .ne. edgexyz(2) .or.
     -     edgexyz(1) .ne. edgexyz(3)))) then
          if (MYRANK .eq. 0) write (iout,1019)
          inperr=inperr+1
        end if
      end if
      if (iop(6) .eq. 6 .and. iop(12) .lt. 4) then
        if (MYRANK .eq. 0) write (iout,1052)
        iop(6)=5
        nchng=nchng+1
      end if
c     For Metropolis, switch to Metropolis is meaningless
      if (iop(6) .lt. 5) iop(19)=0
      if (iop(41) .gt. 0) then
c       Only random particle selection is allowed
        if (iop(12) .ge. 1 .and. iop(12) .le. 3) then
          iop(12)=0
          if (MYRANK .eq. 0) write (iout,1042)
          nchng=nchng+1
        end if
      end if
      if (iop(41) .ne. 1 .and. iop(41) .ne. 2 .and. iop(30) .ne. 1
     -    .and. iop(30) .ne. 2 .and. iop(79) .gt. 0) then
        if (MYRANK .eq. 0) write (iout,1056)
        iop(79)=0
        nchng=nchng+1
      end if
      if (iop(79) .gt. 1 .and. nmcransh .ne. 0) then
        if (MYRANK .eq. 0) write (iout,1057)
        nmcransh=0
        nchng=nchng+1
      end if
      call scalestep(iop(110),scalefac,0,1,0,0,iop(24),inperr,iout)
      if ((cedslv .eq. 0.0 .or. rtxslv .eq. 0.0) .and.
     -    iop(6) .gt. 4) then
c       Solvent translation or rotation is forbidden - switch to Metropolis
        iop(6)=0
        if (MYRANK .eq. 0) write (iout,1014)
        nchng=nchng+1
      end if
      do k=1,3
        if (iop(57) .eq. 0) dispmax(k)=0.0
        if (iop(57) .eq. 1) dispmax(k)=rtxpslt(k)/2.0
c       Extension-biased - assume smallest extension is 2 A
        if (iop(57) .gt. 1) dispmax(k)=rtxpslt(k)/(2.0*2.0)
        if (iop(57) .eq. 3 .or. iop(57) .eq. 6)
     -    dispmax(k)=dispmax(k)*sqrt(2.0)
      end do
c     Set derived constants, table for Mehler-Solmayer DD Diel.
      if (temp .le. 0.0) then
        inperr=inperr+1
        beta=1.0
        write (iout,1003)
      else
c       beta: 1/kT in kcal/mol
        beta=1.0/(boltz*temp)
      end if
      if (iop(71) .gt. 0) then
        pressv=press*avogad*0.02418*1.e-27
        pvbeta=pressv*beta
        vlamt=(boltz*temp)/vlam
        vvlmt=(vrange/2.0)/vlamt
        rangefac=((vol+vrange)/vol)**(1.0/3.0)
        vvlmtx=(edgexyz(1)*(rangefac-1.0)/2.0)/vlamt
        vvlmty=(edgexyz(2)*(rangefac-1.0)/2.0)/vlamt
        vvlmtz=(edgexyz(3)*(rangefac-1.0)/2.0)/vlamt
        vvlmtxx=((vrange/(edgexyz(2)*edgexyz(3)))/2.0)/vlamt
        vvlmtyy=((vrange/(edgexyz(1)*edgexyz(3)))/2.0)/vlamt
        vvlmtzz=((vrange/(edgexyz(1)*edgexyz(2)))/2.0)/vlamt
        vvlmtyz=((vrange/edgexyz(1))/2.0)/vlamt
        if (idebug(38) .gt. 0 .and. MYRANK .eq. 0) write (iout,1046)
     -     vlamt,vvlmt,vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyz
      end if
c     stpfac is a factor on the stepsize for a possible self-regulating
c     stepsize algorithm, not yet implemented. iop6ol is the original
c     inputted sampling  technique.
      stpfac=1.0
      iop6ol=iop(6)
c     Initialize force-biased MC constants
c     beta2, beta4: 1/(2kT) and 1/(4kT)
      beta2=beta*fblamd
      beta4=beta2/2.0
c     cd0bt2, ra0bt2: max stepsize/(4kT) for slt displacement and rotation
c     cd1bt2, ra1bt2: sama as cd0bt2, ra0bt2, but for the solvent.
c     cdbt2, rabt2: for slt perturbation: cd0bt2, ra0bt2; for solvent
c     perturbation: cd1bt2, ra1bt2.
      cd0bt2=beta4*cedslt
      ra0bt2=beta4*rtxslt
      cd1bt2=beta4*cedslv
      ra1bt2=beta4*rtxslv
c     frcmax, trqmax: the largest force, torque component allowed (mach. dep.)
      frcmax=0.4*dlog(dpmx)/(amax1(cd0bt2,cd1bt2,0.1)/2.0)
      trqmax=0.4*dlog(dpmx)/(amax1(ra0bt2,ra1bt2,0.1)/2.0)
c     kuttyp=1: switch to Metropolis if force/torque limit was reached
      kuttyp=1
c     Initialize all accumulators
c     usum: total energy; uusum: total energy square; vircsm: virial sum;
c     uslt,uuslt: solute binding energy and its square;
c     estsca,estsaa: solute binding eng. with inscr. sph. cutoff and its square;
c     estsua: product of solute binding eng. with inscr. sph. cutoff and normal
c     estgrs(i): solute-solvent interaction for solute group i (iop43>0)
c     avstp: average accepted step-size;
c     e0o: first FE slt contribution
c     e1o: second FE slt contribution
c     ue0,ue1: accumulator for e0o,e1o
c     uws0, uws1: us weight accumulators for consistency check.
c     uus0, uus1: accumulator for u(uspar0) and u(uspar1) for constncy chk
c     cplpr0, cplpr1: cpl par dependent coefs of the two energy terms
c     uspr01, uspr11: complements of the perturbation method limit cpl pars
c     dusp12: cpl par range for perturbation method calc.
c     nftcut: the number of times the force/torque cutoff was activated
c     nftcta: number of accepted steps with force/torque cutoff applied
c     nrejfl: number of times the rejection number cutoff was activated
c     corrav: average correlation between successive accepted moves;
c     avrot: average accepted rotation angle;
c     fsmslt, fsmslv: sum of solute, solvent force suares;
c     tsmslt, tsmslv: sum of solute, solvent torque component squares
c     ncorav: number of terms summed into corrav
c     nmovacc,nmovtry: number of accepted and tried displacement/rotation steps
c     npmf*, npdslt* , nptslt*,nsw*, nspslt: analogous items for cpl parameter
c     move, solute molec move, torsion, swap or special move
c     npdsttry, npdsttry (*acc): distribution of trials/acceptances for torsions
c     and displacements
c     partial solute displacement and torsion
c     nmc: step number;
c     nrpt: repetition count; isolv: index of moved molecule;
c     wpsmvi: sum of 1/w(pref. sampl.)
c     wmslt: solute molecular weight; wmslv: solvent molecular weight
c     nssslt: counter of contributions to slt quantum corrections.
c     norde0, norde1: counters for energy diff distributions (or method)
c     uttnb,uuttnb: accumulators for intermolecular nb energy of solute molecs
c     uinnb,uuinnb: accumulators for intramolecular nb energy of solute molecs
c     usltt,uusltt: accumulators for intra energies of torsion groups (w/o 1-4)
c     uslt14,uuslt14: accumulators for 1-4 intra energies of torsion groups
c     uslttor,uuslttor: accumulators for torsion energies
      usum=0.d0
      uusum=0.d0
      uslt=0.d0
      do mx=1,3
        tscum(mx)=0.d0
      end do
      uuslt=0.d0
      uttnb=0.d0
      uuttnb=0.d0
      uinnb=0.d0
      uuinnb=0.d0
      usltt=0.d0
      uusltt=0.d0
      uslt14=0.d0
      uuslt14=0.d0
      uslttor=0.d0
      uuslttor=0.d0
      usltf=0.d0
      uusltf=0.d0
      uslvf=0.d0
      uuslvf=0.d0
      usltms=0.d0
      uusltms=0.d0
      estsca=0.d0
      estsaa=0.d0
      estsua=0.d0
      einoxs=0.d0
      eoutxs=0.d0
      ephssum=0.d0
      ephssumlast=0.d0
      sumnphslast=0.d0
      eephssum=0.d0
      fphssum=0.d0
      ffphssum=0.d0
      rphssum=0.d0
      rrphssum=0.d0
      sumnphs=0.d0
      sumnnphs=0.d0
      epijsum=0.d0
      epijct=0.d0
      vsum=0.d0
      vvsum=0.d0
      hsum=0.d0
      hhsum=0.d0
      exsum=0.d0
      eysum=0.d0
      ezsum=0.d0
      exsum_2=0.d0
      eysum_2=0.d0
      ezsum_2=0.d0
      unsum=0.d0
      ufsum=0.d0
      fnsum=0.d0
      rnsum=0.d0
      rnnsum=0.d0
      bsum=0.d0
      bbsum=0.d0
      rnsumprv=0.d0
      rnnsumprv=0.d0
      uavcorprv=0.d0
      ucsmmv=0.d0
      ucsmid=0.d0
      ucsmvv=0.d0
      if (iop(43) .gt. 0) then
        do ig=1,nsttg
          estgrs(ig)=0.d0
        end do
      end if
      do im=1,nsttm
        uintranb(im)=0.d0
        uinter(im)=0.d0
        um14(im)=0.d0
        uuintranb(im)=0.d0
        uuinter(im)=0.d0
        uum14(im)=0.d0
      end do
      ue0=0.d0
      ue1=0.d0
      do mx=1,3
       ue0ind(mx)=0.d0
       ue1ind(mx)=0.d0
       ue1ind(mx)=0.d0
       ue0ttnb(mx)=0.d0
       ue1ttnb(mx)=0.d0
       ue0innb(mx)=0.d0
       ue1innb(mx)=0.d0
       ue0t14(mx)=0.d0
       ue1t14(mx)=0.d0
       ue0tor(mx)=0.d0
       ue1tor(mx)=0.d0
      end do
      uws0=0.d0
      uws1=0.d0
      uus0=0.d0
      uus1=0.d0
c     The followings are distribution function accumulators.
c     dnrww: solvent-solvent g(r); dnrslt: solute-solvent g(r);
c     dkcrslv: solvent coordination number; dkcrslt: solute coord. no.;
c     ksltmn: lowest solute coord no to be stored in dkcrslt
c     dnesmww: solvent binding energy; dnesslt: solute binding energy;
c     dnslvpe: solvent pair-energy; dnsltpe: solute pair energy;
c     dndipc: solvent near-neighbour dipole-correlation.
c     dndipmom: solvent dipole moment component distribution
c     dngwws     : number of water molecules summed into dnrww
      dngwws=0.d0
      call zeroitd(dnrslt,500)
      call zeroitd(dnrww,500)
      call zeroitd(dkcrslv,20)
      call zeroitd(dkcrslt,30)
      call zeroitd(dnsltpe,100)
      call zeroitd(dnslvpe,100)
      call zeroitd(dnesslt,100)
      call zeroitd(dnesmww,100)
      call zeroitd(dndipc,180)
      call zeroitd(dndipmom,3*180)
c     mxcslv: first integerized distance grid for which eww recalc is not needed
      mxcslv=(cutslv+cedslv*sq3p2)/ri+2.0
      if (iop(6) .eq. 2) mxcslv=mxcslv+1
      cplpr0=cplpar
      cplpr1=1.0-cplpar
      cplpar1=1.0-cplpar
      ptiexpmax=-10.0
      crat60=1.0
      crat61=1.0
      crat10=1.0
      crat11=1.0
      if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
        do mx=1,3
          if (ptiexp(mx) .eq. 0.0) ptiexp(mx)=1.0
          if (ptiexp(mx) .gt. ptiexpmax) ptiexpmax=ptiexp(mx)
          cpl0tix(mx)=cplpar**ptiexp(mx)
          cpl1tix(mx)=(1.0-cplpar)**ptiexp(mx)
        end do
        if (ptiexp(2) .ne. ptiexp(1)) then
          if (cplpar .ne. 0.0) crat60=cplpar**(ptiexp(2)-ptiexp(1))
          if (cplpar .ne. 1.0)
     -      crat61=(1.0-cplpar)**(ptiexp(2)-ptiexp(1))
        end if
        if (ptiexp(3) .ne. ptiexp(1)) then
          if (cplpar .ne. 0.0) crat10=cplpar**(ptiexp(3)-ptiexp(1))
          if (cplpar .ne. 1.0)
     -      crat11=(1.0-cplpar)**(ptiexp(3)-ptiexp(1))
        end if
      end if
c     write (iout,*) ' ratios: crat60,crat61,crat10,crat11,=',
c    -                 crat60,crat61,crat10,crat11,
c     The solute force array limits and L.C. coefs are set here, used in engslt
      cplcoef(3)=1.0
      incrpmf=1
      if (iop(30) .eq. 0) then
        ntorcop=1
        nslttf(1)=1
        nslttl(1)=nstta
      else if (iop(30) .eq. 1 .or. iop(30) .eq. 2) then
        ntorcop=1
        nslttf(1)=nstfa+1
        nslttl(1)=nstta
      else if (iop(30) .eq. 3) then
c???
        ntorcop=1
        nslttf(1)=nstfa+1
        nslttl(1)=nstta
      else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
        ntorcop=2
        nslttf(1)=1
        nslttl(1)=nstfa0
        nslttf(2)=nslttl(1)+1
        nslttl(2)=nstfa
        cplcoef(1)=cpl1tix(1)
        cplcoef(2)=cpl0tix(1)
      else if (iop(30) .ge. 7) then
        ntorcop=1
        nslttf(1)=nstfa1+1
        nslttl(1)=nstta
        incrpmf=nstfa1+1
      end if
      uspr01=1.0-uspar0
      uspr11=1.0-uspar1
      dusp12=uspar1-uspar0
      do k=1,3
        vircsm(k)=0.d0
        avstrot(k)=0.d0
        avststp(k)=0.d0
        vxstep(k)=0.d0
        nxstep(k)=0
      end do
      avststptot=0.d0
      avststptot2=0.d0
      avstp=0.d0
      avrot=0.d0
      corrav=0.d0
      vstep=0.d0
c     uuscor, uwcplo are the US weights fro GCE us or PMF us, resp
      uuscor=1.0d0
      if (iop(30) .ne. 7) uwcplo=1.0d0
c     accpmn is the acceptance rate limit under which solvents are listed
      if (accpmn .eq. 0.0) accpmn=0.02
      fsmslt=0.d0
      fsmslv=0.d0
      do k=1,3
        tsmslt(k)=0.d0
        tsmslv(k)=0.d0
      end do
      wpsmvi=0.d0
      nsslt=0
      wmslt=0.0
      if (iop(30) .gt. 3) then
c       Adjust wmslt for multiple solute copies
        do i=1,nstfa
          wmslt=wmslt+aw(ianslt(i))
        end do
        wmslt=wmslt/max0(1,nsltcp(iop(30)+1))
      end if
      do i=nstfa+1,nstta
        wmslt=wmslt+aw(ianslt(i))
      end do
      wmslv=0.0
      do i=1,nslv
        wmslv=wmslv+aw(ianslv(i))
      end do
      ncorav=1
      nftcut=0
      nftcta=0
      nrejfl=0
      nmc=0
      nmcprv=0
      nidmc=0
      nvchmc=0
      nvchacc=0
      lstac=0
      nrpt=1
      nmovacc=0
      nmovtry=0
      npmfacc=0
      npmftry=0
      npdslttry=0
      npdsltacc=0
      nptslttry=0
      nptsltacc=0
      nswaptry=0
      nswapacc=0
      nspslttry=0
      nspsltacc=0
      do it=1,ntang
        lastrot(it)=0
        dlastrot(it)=0.d0
        tangav(it)=0.d0
        do k=1,#TD
          itangd(k,it)=0
          dtangd(k,it)=0.d0
        end do
        if (iop(180) .gt. 0) then
          ntorsaved=0
          do ic=1,#AU
            auctor(ic,it)=0.0
          end do
        end if
        tang2av(it)=0.d0
        sinsum(it)=0.d0
        cossum(it)=0.d0
        nptsttry(it)=0
        nptstacc(it)=0
        tstepsum(it)=0.d0
        tstepmax(it)=0.0
      end do
      do im=1,nsttm
        npdsttry(im)=0
        npdstacc(im)=0
        nswacc(im)=0
        nswtry(im)=0
        nspsttry(im)=0
        nspstacc(im)=0
        sltstepsum(im)=0.d0
      end do
      if (iop(91) .gt. 0) then
        nloopmtry=0
        call zeroiti(nloopctry,0,3*2)
        nloopacc=0
        numnosol=0
        call zeroiti(nosoltyps,0,10*3*2)
        evalnum=0.d0
        solnum=0.d0
        numrevrej=0
        numrej0=0
        numnearpicked=0
        numnearacc=0
        call zeroiti(nsectry,0,nlooptyp)
        call zeroiti(nsecact,0,3*nlooptyp)
        call zeroiti(nimptry,0,3*2)
        call zeroiti(nimpfound,0,3*2*2)
        call zeroiti(nptlooptry,0,ntang)
        call zeroiti(nptloopacc,0,ntang)
        call zeroitd(tlstepsum,ntang)
        call zeroit(tlstepmax,ntang)
        ngcortry=0
        nacortry=0
        ngcorfail=0
        njacsing=0
      end if
      nfixtry=0
      ndiffign=0
      do i=1,#OR
        norde0(i)=0
        norde1(i)=0
      end do
      isolv=nmolec
      isolvc=0
c     mvfst: first SOLVENT molecule that is allowed to be moved.
      mvfst=nsolvfix+2
      if (mvfst .gt. nmolec .and. iop(160) .eq. 0 .and.
     -    iop(36)+iop(41)+iop(57)+iop(58)+iop(174) .eq. 0) then
        write (iout,1010) numsolv,nsolvfix
        if (nmolec .eq. 1 .and. MYRANK .eq. 0) write (iout,1009)
        inperr=inperr+1
      end if
      if (iop(59) .eq. 1) then
        if (iop(57) .eq. 0 .and. iop(160) .eq. 0) then
          if (MYRANK .eq. 0) write (iout,1032)
          nwarn=nwarn+1
          iop(59)=2
        end if
        if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
          if (MYRANK .eq. 0) write (iout,1041)
          inperr=inperr+1
        end if
      end if
      if (iop(57)+iop(58)+iop(68) .gt. 0 .or. iop(30) .eq.  7) then
        if ((iop(9) .eq. 1 .or. iop(9) .eq. 2)  .and.
     -       iop(57)+iop(58)+iop(68) .gt. 0) then
          iop(9)=6
          if (MYRANK .eq. 0) write (iout,1020)
          nchng=nchng+1
        end if
        if (nsltfreq .eq. 0 .and. iop(160) .eq. 0) then
c         Partial slt or cpl par moves require explicitly given frequency
          if (MYRANK .eq. 0) write (iout,1008)
          inperr=inperr+1
        end if
      end if
      if (iop(75) .eq. 2) then
        iop(75)=0
        nchng=nchng+1
        if (MYRANK .eq. 0) write (iout,1055)
      end if
      if (iop(91) .gt. 0) then
        if (iop(58) .eq. 0) then
          iop(91)=0
          nchng=nchng+1
          if (MYRANK .eq. 0) write (iout,1053) 'torsions are not active'
        end if
        if (iop(116) .gt. 0 .and. iop(115) .eq. 0) then
          iop(115)=1
          if (MYRANK .eq. 0) write (iout,1061)
          nchng=nchng+1
        end if
      end if
      if (iop(160) .eq. 0) then
        ntrytyp=7
        if (iop(57) .eq. 0) wsltpdis=0.0
        if (iop(58) .eq. 0) wsltptor=0.0
        if (iop(64) .eq. 0) wswap=0.0
        if (iop(66) .eq. 0) wmv2s=0.0
        if (iop(30) .ne. 7) wcplcha=0.0
        if (iop(30) .eq. 7 .and. wcplcha .eq. 0.0) wcplcha=1.0
        wmove=1.0
        if (cedslt .eq. 0.0 .and. rtxslt .eq. 0.0) wmove=0.0
        wtsum=wmove+wcplcha+wsltpdis+wsltptor+wswap+wmv2s+wspec
        if (wtsum .eq. 0.0) then
          call zeroit(wslttry,ntrytyp)
          wslttry(1)=1.0
          if (nsltfreq .gt. 0) then
            if (MYRANK .eq. 0) write (iout,1051) nsltfreq
            nchng=nchng+1
            nsltfreq=0
          end if
        else
          wslttry(1)=wmove/wtsum
          wslttry(2)=wslttry(1)+wcplcha/wtsum
          wslttry(3)=wslttry(2)+wsltpdis/wtsum
          wslttry(4)=wslttry(3)+wsltptor/wtsum
          wslttry(5)=wslttry(4)+wswap/wtsum
          wslttry(6)=wslttry(5)+wmv2s/wtsum
          wslttry(7)=wslttry(6)+wspec/wtsum
        end if
c       Make sure that roundoff errors don't call unwanted moves
        i=ntrytyp
        do while (i .gt. 1 .and. abs(1.0-wslttry(i)) .lt. 0.0001)
          wslttry(i)=1.0
          i=i-1
        end do
      end if
      if (nsltcp(iop(30)+1) .eq. 2 .and. iop(59) .eq. 1) then
        iop(59)=0
        if (MYRANK .eq. 0) write (iout,1036)
        nwarn=nwarn+1
      end if
      if (mvfst .ge. nmolec .and. numsolv .gt. 0 .and.
     -    numsolv .gt. 0) then
        if (iop(41) .gt. 0) iop(12)=0
        if (iop(41) .eq. 0) iop(12)=2
        if (MYRANK .eq. 0) write (iout,1011) selectname(iop(12)+1)
        nchng=nchng+1
      end if
      isser=0
      isserpd=movmoll+1
      if (iop(73) .eq. 2) isserpd=0
      isserpt=ngrtmx+1
      if (iop(74) .eq. 2) isserpt=0
      if (idebug(7) .gt. 0 .and. MYRANK .eq. 0) write (iout,1714)
     -  imolpd,imolpt,itmfrst,itgfrst,movmolf,movmoll,ngrdmn,ngrdmx,
     -  ngrtmn,ngrtmx,istf,igstf,molstf,molstfti
c     npckd(is): number of times the molec is was perturbed
c     nmvd(is): number of accepted moves for molec is.
      do is=1,#MO
        ndistr(is)=0
        npckd(is)=0
        nmvd(is)=0
        lstmvd(is)=0
        nrejis(is)=0
      end do
      do i=1,50
        nrcorr(i)=0
        drcorr(i)=0.d0
        nrtry(i)=0
        nracc(i)=0
        do k=1,3
          nptatry(k,i)=0
          nptaacc(k,i)=0
        end do
      end do
      if (iop(41) .gt. 0) then
        namin=nmolec-1
        namax=nmolec-1
        nitry=0
        nran=0
        nmdlst=0
        niddst=0
        ndlast=0
        niaccp=0
        ndaccp=0
c       Cavity-biased accumulators
        do is=1,#MO
          ninstr(is)=0
          nocavf(is)=0
        end do
c       ndistr(is): number of configurations with nmolec=i
c       ninstr(is): number of insertion trials for nmolec=i
c       nocavf(is): number of times no cavity was found for nmolec=i
        suminout(1)=0.d0
        suminout(2)=0.d0
        suminout2(1)=0.d0
        suminout2(2)=0.d0
      end if
c     Accumulators for the derivative wrt the solute parameters
      nsltdv=0
      do iv=1,#SV
        do i=1,#DT
          df1(i,iv)=0.d0
          df6(i,iv)=0.d0
          df12(i,iv)=0.d0
          de1(i,iv)=0.d0
          de6(i,iv)=0.d0
          de12(i,iv)=0.d0
          ds1(i,iv)=0.d0
          ds6(i,iv)=0.d0
          ds12(i,iv)=0.d0
        end do
      end do
c     Control fct information: values for accumulators at the end
c     of the previous block
      ncntrl=0
      ncntrlskip=0
      ncntrllim=#MI
      nhowfar=0
      nhowfarsamp=1
c     nupdat: last solv neighbour table update (=-1: no bitmap initialization)
      nupdat=-1
      if (rccomp .eq. 0.0) rccomp=cutslv+2.0
c     rccmp2: cutoff square for neighbourhood
      rccmp2=rccomp**2
C@NN      nupdat=0
C@NNc     nmolmp: number of computer words per molecule for neighbour bits
C@NN      nmolmp=(nmolec-1)/nbits+1
C@NN      call checkdim(ifail,iout,inperr,'VW',nmolmp,0,0,0)
C@NNc     nlastwv: number of bits used in the last word of the solvent bit map.
C@NN      nlastwv=nmolec-(nmolmp-1)*nbits
C@NNc     rcmin: the minimum radius of the neighbourhood definition.
C@NNc     It has to prevent the penetration of the energy cutoff sphere
C@NNc     by two or one steps.
C@NN      rcmin=cutslv+cedslv*sq3
C@NN      if (rccomp .le. rcmin) then
C@NN        if (MYRANK .eq. 0) write (iout,1001) rcmin
C@NN        if (abs(rccomp-2.0-cutslv) .lt. 0.001 .and. MYRANK .eq. 0)
C@NN     -    write (iout,1002)
C@NN        inperr=inperr+1
C@NN      end if
C@NNc     drmx22: cutoff square in for displacement before table update
C@NN      drmx22=((rccomp-cutslv)/2.0)**2
c     itwop(i)=2**(i-1)
c     ibiton(i): all bits off except the i-th (starting bit: 1)
c     ibitof(i): all bits on except the i-th
      iallon=(2**(nbits-1)-1)*2+1
      do i=1,nbits
        itwop(i)=2**(i-1)
        ibiton(i)=2**(i-1)
        ibitof(i)=iallon-ibiton(i)
      end do
C@TNc     Set up solute-solute bitmap
C@TN      maxmola=0
C@TN      do im=1,nsttm
C@TN        if (ilastm(im)-ifirstm(im)+1 .gt. maxmola)
C@TN     -    maxmola=ilastm(im)-ifirstm(im)+1
C@TN      end do
C@TNc     nsltmp: number of computer words per solute atom for neighbour bits
C@TN      nsltmp=(maxmola-1)/nbits+1
C@TN      call checkdim(ifail,iout,inperr,'UW',nsltmp,1,0,0)
C@TNc     Default: all interactions are on
C@TN      do ia=1,nstta
C@TN        do iw=1,nsltmp
C@TN          mapbitu(iw,ia)=iallon
C@TN        end do
C@TN      end do
C@TN      do im=1,nsttm
C@TNc       Forbid 1-2, 1-3, 1-4 interactions for all atoms
C@TN        do ia=ifirstm(im),ilastm(im)
C@TN          do in=1,nneig4(ia)
C@TN            isw=(ineig(in,ia)-ifirstm(im))/nbits+1
C@TN            if (isw .gt. 0) then
C@TN              isb=ineig(in,ia)-ifirstm(im)+1-(isw-1)*nbits
C@TNC@NL              mapbitu(isw,ia)=mapbitu(isw,ia) .and. ibitof(isb)
C@TNC@NA              mapbitu(isw,ia)=ibclr(mapbitu(isw,ia),isb-1)
C@TN            end if
C@TN          end do
C@TN        end do
C@TN      end do
C@TNc     Sort the 1-4 ng list
C@TN      do ia=1,#NL
C@TN        cv1(ia)=0.0
C@TN      end do
C@TN      do ia=1,nstta
C@TN        do ja=nneig3(ia)+1,nneig4(ia)
C@TN          cv1(ja-nneig3(ia))=ineig(ja,ia)
C@TN        end do
C@TN        call mrgsrt(iout,ineig(nneig3(ia)+1,ia),cv1,
C@TN     -    nneig4(ia)-nneig3(ia),l1,l2,l3,cv2,#UV)
C@TN      end do
C@TN      if (idebug(7) .gt. 1) then
C@TN        do ia=1,nstta
C@TN          im=iamolslt(ia)
C@TN          natsprt=ilastm(im)-ifirstm(im)+1
C@TN          call readbitc(mapbitu,ia,indexx,1,natsprt,
C@TN     -        #UW,#ST,nbits)
C@TN          if (MYRANK .eq. 0)
C@TN     -      write (iout,1712) im,ia,(indexx(i),i=1,natsprt)
C@TN          if (MYRANK .eq. 0) write (iout,1713) im,ia,nneig3(ia),
C@TN     -      nneig4(ia),(ineig(in,ia),in=nneig3(ia)+1,nneig4(ia))
C@TN        end do
C@TN      end if
      return
C@NN1001  format(' ***** ERROR: current solvent cutoff and stepsize ',
C@NN     -  'require a near-neighbor cutoff of at least',f8.2,' A')
C@NN1002  format(59x,'Give near-neighbor cutoff explicitly after key SVVC')
1003  format(' ***** ERROR: nonpositive temperature:',f8.2)
1004  format(' >>>>> OVERRIDE: Crystal solute is not allowed to move -',
     -  ' solute stepsizes set to zero')
1005  format(' >>>>> OVERRIDE: Crystal solute requires minimum image -',
     -  ' SUVC MI** is set')
1006  format(' >>>>> OVERRIDE: Flexible solute requires Metropolis',
     -  ' sampling on the solute - NFBU is set')
1008  format(' ***** ERROR: Partial solute move or coupling ',
     -  'parameter move requires explicitly given move frequency ',
     -  '(key STEP)')
1009  format(14x,'When no solvent is present, some solute sampling is',
     -  ' required')
1010  format(' ***** ERROR: the number of solvent molecules (',i6,') ',
     -  'does not exceed the number of solvents to be kept fixed (',i6,
     -  ')')
1011  format(' >>>>> OVERRIDE: there are not enough moving solvents -',
     -  ' preferential sampling is changed to ',a)
1014  format(' >>>>> OVERRIDE: Solvent stepsize is given as zero - ',
     -  ' switch to Metropolis sampling')
1015  format(' ***** ERROR: iso-energy cutoff requires exactly two',
     -  ' solute molecules and two groups per copy')
1016  format(' >>>>> OVERRIDE: solute with intra changes can not be ',
     -  'translated/rotated as a whole - solute stepsizes set to zero')
1018  format(' ***** ERROR: this free energy option is currently ',
     -  'incompatible with global molecular potentials')
1019  format(' ***** ERROR: Coordinate permuting before analysis ',
     -  '(PXYZ) requires symmetric PBC')
1020  format(' >>>>> OVERRIDE: Partial solute moves require the saving',
     -  ' of full configurations - TRAJ ALLB is set')
1024  format(' ***** ERROR: group-based PBC (SUVC MI**) is not',
     -  ' implemented yet for sensitivity analysis (SENS)')
1027  format(' ***** ERROR: ',a,' cutoff (',f6.2,') is different ',
     -  'from the solvent-solvent cutoff',/,7x,'Reaction field ',
     -  'correction would be incorrect')
1028  format(' ----- WARNING: torsion is used with general ',
     -  ' linear combination PMF')
1030  format(' ***** ERROR: EPEN/QPEN can not be used with ',
     -  ' partial solute moves of any kind')
1031  format(' ===== STRONG WARNING: solute move frequency was given ',
     - 'as one - solvent will be kept fixed')
1032  format(' ----- WARNING: no partial solute movement was specified',
     -  ' - TRAJ **** **** MVST was changed to TRAJ **** **** NOST')
1033  format(' ***** ERROR: if the solute is to be displaced or ',
     -  'rotated then CNFG READ **** IGND is invalid')
1035  format(' >>>>> OVERRIDE: Solute move frequency is set to ',
     -  'zero since no solute change is requested')
1036  format(' ----- WARNING: Partial solute saving on trajectory',
     -  ' file is not implemented yet for 2-solute free energy runs')
1041  format(' ***** ERROR: TRAJ MVST is not implemented yet with',
     -  ' FREE TICA or FREE PMLI ')
1042  format(' >>>>> OVERRIDE: In GCE cyclic moves are not allowed,',
     -  ' MOVE RAND is set')
1043  format(' >>>>> OVERRIDE: Solute move frequency is set to one',
     -  ' since there are no solvent molecules')
1045  format(' >>>>> OVERRIDE: Solute rotation angle changed to zero',
     -  ' from ',f8.3,' since there is only one solute atom')
1046  format(' INICAC: vlamt,vvlmt=',2e12.5,
     -  ' vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyz=',5e12.5)
1047  format(' ***** ERROR: cloned solute can not be fixed - use ',
     -  'CNFG **** **** NOFX or CNFG **** **** IGND')
1048  format(' ***** ERROR: Non-rigid solute can use only group-based ',
     -  'cutoff,  - change SUVP **CC is to SUVP **GC')
1049  format(a,' WARNING: solute has more than ',i4,' groups ',
     -  'but COM-based cutoff is used - consider changing SUVC **CC to',
     -  ' SUVC **GC')
1051  format(' >>>>> OVERRIDE: No solute move type has nonzero ',
     -  'selection weight but solute is asked to be moved at every ',i6,
     -  ' step - ignored')
1052  format(' >>>>> OVERRIDE: SAMP SCFB requires a MOVE option with ',
     -  'preferential sampling - stepsize scaling is turned off')
1053  format(' >>>>> OVERRIDE: ',a,' - key LOOP is ignored')
1055  format(' >>>>> OVERRIDE: shuffled cylic torsion angle selection ',
     -  'is not implemented - changed to random')
1056  format(' >>>>> OVERRIDE: reduced grid option (LIMG) is only ',
     -  'valid with GCEN CAVB, GCEN CVBF or FREE WIDO keys')
1057  format(' >>>>> OVERRIDE: cavity grid shifting frequency is set ',
     -  'to zero to avoid wrong in/out counts')
1058  format(' >>>>> OVERRIDE: potential coupling is meaningless for',
     -  ' coupling in torsion space',/,
     -  5x,' - FREE PMF1 TORS GEOC is set')
1059  format(' >>>>> OVERRIDE: solute ',a,' is not sampled - stepsize ',
     -  'tuning is turned off')
1060  format(' >>>>> OVERRIDE: torsions are not changed, NONB ',a,' is',
     -  ' ignored')
1061  format(' >>>>> OVERRIDE: SKWT key requires the ignore Jacobian ',
     - 'option (IGJA key) when LOOP moves are used')
1711  format(' INICAC: volchafac=',3e14.6,' volchadiff=',3e14.6)
C@TN1712  format(' INICAC: im,ia=',2i5,(' ix=',100i1))
C@TN1713  format(' INICAC: im,ia=',2i5,' n3,n4=',2i3,
C@TN     -  ' in=',15i5,/,15i5)
1714  format(' INICAC: molpd,imolpt=',2i2,' itmfrst,itgfrst=',2i5,
     -  ' movmolf,movmoll=',2i3,' ngrdmn,mx=',2i6,
     -  ' ngrtmn,mx=',2i6,/,' istf,igstf,molstf=',4i4)
6433  format(' INICAC Widom atoms ',i4,'=',3f10.5)
      end
      subroutine initcutoff(iout,nwarn)
c#    MMC routine  47 lstmod: 01/07/09
C*****Initialize the various cutoffs and their squares
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /isoeng/ dimax,dijs,dijq,dijso,dijqo,eniemx,eniemo
      common /option/ iop(200),idebug(200)
c     cutslv: solvent-solvent cutoff in A, ctslvs: its square;
c     cutslt: solute-solvent cutoff in A, ctslts: its square;
c     cutuu : solute-solute cutoff in A, cutuus: its square;
c     cutexp: cutoff for exponential terms in MCY, ctexps: its square
      if (iop(5) .eq. 6) then
c       PHS
        ctslts=cutslt**2
      else
        call modcut(iop(7),cutslt,ctslts,rinscr,rboxmax,nmolec,
     -    'solute-solvent',14,iout,nwarn)
      end if
      if (iop(7) .eq. 2) then
c       Iso-energy cutoff
        cellx=edgexa
        if (iop(5) .eq. 1 .or. iop(5) .eq. 3) cellx=2.0*edgexa
c       dimax is the limit on r(i-i) such that rc+dimax+rc spans the cell
        dimax=cellx-2.0*cutslt
      end if
      call modcut(iop(54),cutslv,ctslvs,rinscr,rboxmax,nmolec,
     -  'solvent-solvent',15,iout,nwarn)
      if (cutexp .gt. cutslv) cutexp=cutslv
      if (cutexp .eq. 0) cutexp=5.5
      ctexps=cutexp**2
      nosc=1
      if (iop(65) .eq. 2 .or. iop(65) .eq. 4) nosc=0
      rfac=1.0
      if (iop(65) .eq. 0) rfac=2.0
      call modcut(nosc,cutuu,cutuus,rinscr,rfac*rboxmax,2,
     -  'solute-solute',13,iout,nwarn)
      if (idebug(121) .gt. 0)
     -  write (iout,1000) cutslv,cutexp,cutslt,cutuu,
     -    ctslvs,ctexps,ctslts,cutuus,rinscr,rboxmax
      return
1000  format(' INITCUTOFF cutslv,cutexp,cutslt,cutuu=',4f10.5,/,
     -  ' ctslvs,ctexps,ctslts,cutuus=',4f10.4,
     -  ' rinscr,rboxmax=',2f10.4)
      end
      subroutine modcut(nosc,cut,cuts,rinscr,rboxmax,nmolec,label,len,
     -  iout,nwarn)
c#    MMC routine  48 lstmod: 12/03/03
c*****Set default, check range for a cutoff
      character*(*) label
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      if (nosc .eq. 0) then
        if (cut .eq. 0.0) cut=rinscr
        if (cut .gt. rinscr .and. nmolec .gt. 1) then
          cut=rinscr
          if (MYRANK .eq. 0) write (iout,1000) label(1:len),cut
          nwarn=nwarn+1
        end if
      else
        cut=rboxmax
      end if
      cuts=cut**2
      return
1000  format(' ----- WARNING: ',a,' cutoff has been',
     -  ' reduced to ',f6.2,' A')
      end
      function intgpsdis(irpfs,rgd,wpscen,rri,c,crm)
      dimension c(3,#NA),crm(3)
c#    MMC routine  49 lstmod: 07/03/10
c*****Calculate integerized preferential sampling distance
      dimension rgd(3),wpscen(3),r(3)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /option/ iop(200),idebug(200)
      if (irpfs .eq. 0) then
c       Solute COM based
        do k=1,3
          r(k)=rgd(k)-crm(k)
        end do
        call pbcnd(r(1),r(2),r(3),iop(5),iopt,riijj)
      else if (irpfs .eq. 1) then
c       Proximity-based
        riijj=1.e+5
        jdel=0
        if (nsltcp(iop(30)+1) .eq. 3) jdel=nstfa1
        do j=jdel+1,nstta
          if (ianslt(j) .gt. 1) then
            do k=1,3
              r(k)=rgd(k)-c(k,j)
            end do
            call pbcnd(r(1),r(2),r(3),iop(5),iopt,riijja)
            if (riijj .gt. riijja) riijj=riijja
          end if
        end do
      else if (irpfs .eq. 2) then
c       Special center-based
        do k=1,3
          r(k)=rgd(k)-wpscen(k)
        end do
        call pbcnd(r(1),r(2),r(3),iop(5),iopt,riijj)
      end if
      intgpsdis=int(sqrt(riijj)*rri)+1
      return
      end
      subroutine iniprftab(ipfs,npf,rpf,apf,stiff,wpstab,ri,inperr,iout)
c#    MMC routine  50 lstmod: 03/06/96
C*****Initialize the preferential sampling weight table and partial sum limits
      dimension rpf(9),apf(9),wpstab(#PG)
c     wps(i) : weighting function at r=ri*i
      if (ipfs .eq. 1) then
c       Weight fct was given as a table
        call linwgt(npf,rpf,apf,wpstab,ri,#PG,inperr,iout)
      else if (ipfs .eq. 2) then
c       Weight fct is a polynomial
c       r < R=apfmv(1)    weight=constant=C
c       r > R    weight=C + sum(n=0 to npf-1) apfmv*/r**n
        rcapit=apf(1)
        do id=1,#PG
          r=id*ri
          rip=1.0
          prfw=0.0
          do i=1,npf-1
            prfw=prfw+rip*apf(i+1)
            rip=rip/r
          end do
          wpstab(id)=prfw
        end do
        ircut=rcapit/ri+1
        do id=1,ircut-1
          wpstab(id)=wpstab(ircut)
        end do
C@DB        write (iout,*) 'ri=',ri,' apf(1)=',apf(1),' icut=',ircut
      else
c       Weight function is an exponential
        do id=1,#PG
          r=id*ri
          wpstab(id)=exp(-stiff*r*r)
        end do
      end if
C@DB      write (iout,*) ' preferential weight array='
C@DB      do id=1,#PG
C@DB        r=id*ri
C@DB        write (iout,8765) r,wpstab(id)
C@DB      end do
C@DB8765  format(f8.3,f13.4)
      return
      end
      subroutine iniprflim(ifirst,n,ips,maxps,sym,limps,nps,iout,inperr)
c#    MMC routine  51 lstmod: 06/08/99
c*****Initialize partial weight-sum related arrays:
      dimension ips(maxps),limps(#PS)
      character*2 sym
c     wpfps(j)= sum (i=1,limps(j)) of wpf(i) (done by pfsumin)
      call zeroiti(ips,0,maxps)
      ndo=n-ifirst+1
      nps=#PS
      if (ndo .lt. nps) nps=ndo
      nseg=ndo/nps
      nleft=ndo-nps*nseg
      lsum=ifirst-1
      do i=1,nps
        limps(i)=lsum+nseg
        if (i .le. nleft) limps(i)=limps(i)+1
        lsum=limps(i)
        if (limps(i) .gt. maxps) then
          if (i .eq. nps) write (iout,1001) sym,limps(nps)
          limps(i)=maxps
          n=#PP
          inperr=inperr+1
        end if
      end do
      j0=1
      do i=1,nps
        do j=j0,limps(i)
          ips(j)=i
        end do
        j0=limps(i)+1
      end do
C@DB      write (6,1000) ifirst,n,nps,(limps(i),i=1,nps)
C@DB1000  format(' ifirst=',i4,' n=',i7,' nps=',i3,' limps=',10i5)
1001  format(' ***** ERROR: Weight grid list is too short, ',
     -  'redimension with #',a2,' of at least ',i8)
      return
      end
      subroutine iniprf(ifirst,n,wpsn,intr,wps,wpssum,wpfps,wpsmax,
     -  limps,nps,iop79)
c#    MMC routine  52 lstmod: 05/05/10
C*****Initialize the preferential sampling parameters and constants
      dimension wpsn(#PG),intr(n),wps(n),wpfps(nps),limps(nps)
      real*8 wpssum,wpfps,sum
c     wps(i) : weighting fct value for molecule i
c     wpsn(i) : weighting function at r=ri*i
c     wpssum : sum of all wps(i)-s
c     Calculate p.f. weight of all molecules
      wpsmax=0.0
      wpssum=0.d0
      do i=ifirst,n
        w=prfwgt(intr(i),wpsn,iop79)
        wps(i)=w
        wpssum=wpssum+w
        if (w .gt. wpsmax) wpsmax=w
      end do
c     Assign the values of the partial weight sums
      sum=0.d0
      j0=ifirst
      do i=1,nps
        do j=j0,limps(i)
          sum=sum+wps(j)
        end do
        wpfps(i)=sum
        j0=limps(i)+1
      end do
      return
      end
      function prfwgt(nisi,wpsmvn,iop79)
c#    MMC routine  53 lstmod: 11/07/89
c*****Compute the weighting fct at r=ri*id
      dimension wpsmvn(#PG)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      in=nisi
      if (in .gt. #PG) in=#PG
      if (iop79 .eq. 0) then
        prfwgt=wpsmvn(in)
      else
c       For limited grid runs set weight to zero outside the grid
        if (molinoutgr(in) .eq. 1) then
          prfwgt=wpsmvn(in)
        else
          prfwgt=0.0
        end if
      end if
      return
      end
      subroutine chaslt(nodisc,ieqc,noslt,filename1,namlen1,cgs,c,crm)
c#    MMC routine  54 lstmod: 08/29/02
c*****Program to generate starting guess conf for your system
c     Originally written by P.K. Mehrotra.
c     from the coordinates of a conf obtained from another
c     system. This is done in the following way.
c     The new solute is inserted in its local orientation at the COM of
c     the old solute. Solvents overlapping the VdW envelope of the solute
c     are discarded whenever nodisc is zero.
      character*80 filename1
      dimension cgs(3,#HA),c(3,#NA),crm(3,#MO)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /option/ iop(200),idebug(200)
      dimension cmcrd(3),iocslt(#ST)
      character*80 line
      common /inpline/ line,lineno,icol
      irectx=23
      call getnextrec(inpt,iout,irectx,nwwarn)
      read (line,1001,err=999) (iocslt(i),i=1,noslt)
      if (iop(24) .gt. 0) write (iout,1323) (iocslt(i),i=1,noslt)
      natso=natoms+(noslt-nstta)
      call checkdim(ifail,iout,inperr,'NA',natso,0,1,0)
      call checkdim(ifail,iout,inperr,'ST',noslt,0,0,0)
      call readcrd(cgs,ieqc,nmolec,nmol3,numsolv,natso,noslt,0,noslv,
     -  cplx,edgexyz,icplp,1,0,0,filename1,namlen1,0,iout,nwwarn,inperr)
      if (icplp .eq. 0) cplpar=cplx
      call cofms(cgs,cmcrd,iocslt,1,noslt,0,wx)
      call trnsfr(c(1,nstta+1),cgs(3,natso+1),3*(natso-noslt+1))
      ndel=0
      if (nstta .gt. 1) then
c       Insert the new solute
        call grelcd(cslt,rlcslt,iclslt,nstta,0)
        do i=1,3
          do j=1,nstta
            c(i,j)=cmcrd(i)+rlcslt(i,j)
          end do
        end do
c       Check for overlap
        if (nodisc .eq. 0) then
          ifat=nstta+1
          do im=2,nmolec
            do j=1,nstta
              iatno=ianslt(j)
              do iv=1,nslv
                r2=arrdist(c(1,j),c(1,ic00+im*nslv+iv))
                if (r2 .lt. (vdw(iatno)+1.1)**2) then
                  ndel=ndel+1
                  go to 60
                end if
              end do
            end do
            if (ndel .gt. 0)
     -        call trnsfr(c(1,ifat),c(1,ifat+ndel*nslv),3*nslv)
            ifat=ifat+nslv
60          continue
          end do
        end if
      end if
      if (iop(30) .ge. 7)
     -  call lincmb(c,crm,cplpar,0,qslt,nstfa0)
      call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -  iop(47),iop(41),iop(90),iop(30),iop(24),filenames(2),namlens(2),
     -  iop(98),0,c)
      write (iout,1000) filename1(1:namlen1),noslt,
     -  filenames(2)(1:namlens(2))
      if (ndel .eq. 0) return
      nmolec=nmolec-ndel
      numsolv=nmolec-1
      write (iout,1002) nmolec-1
      natoms=natoms-ndel*nslv
      return
999   call invalidform(iout,irectx)
1000  format(' +++++ File ',a,' has a solute with nslt=',i4,
     -  ' replaced it with the new solute and saved on file ',a)
1001  format(14i5)
1002  format(' +++++ The number of solvent molecules are reduced to',
     -  i6,' due to overlap with the new solute')
1323  format(' rectype 23  : ',14i5)
      end
      subroutine chstsv(ieqc,noslt,noslv,iop37o,coslt,orient,c,crm,
     -  filenameo,namleno)
c#    MMC routine  55 lstmod: 08/29/02
c*****Program to generate starting guess conf for your (new) system
      dimension orient(3,3,#MO),c(3,#NA),crm(3,#MO),
     -  coslt(3,#ST)
      character*80 filenameo
c     Originally written by P.K. Mehrotra.
c     from the coordinates of a conf obtained from another system.
c     The COM of new solute molec is placed at the COM of old
c     solute molec. Orient matrix derived for the old solute molec
c     is used to generate coordinates of new solute molec.
c     Same proc is used for the rest of molec - solvent molecs.
c     It is important that total no of molecs-nmolec are same for
c     both new and old system. no of atoms of the solute and no of
c     the atoms of the solvent however can differ in the two systems.
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /worksp/ l1(#NA),ioslt(#UV),l3(#UV),l4(#UV)
      character*80 line
      common /inpline/ line,lineno,icol
      dimension aa(3,3),b(3,3)
      dimension ioslv(#SV),coslv(3,#SV)
c     ieqc - unit no where old conf is stored
c     noslt - no of solute atoms in the old system
c     noslv - no of solvent atoms in the old system
      call checkdim(ifail,iout,inperr,'ST',noslt,0,0,0)
      call checkdim(ifail,iout,inperr,'SV',noslv,0,0,0)
      natso=noslt+(nmolec-1)*noslv
      call readcrd(c,ieqc,nmolec,nmol3,natso,numsolv,noslt,0,noslv,cplx,
     -  edgexyz,icplp,1,0,0,filenameo,namleno,0,iout,nwwarn,inperr)
      if (icplp .eq. 0) cplpar=cplx
      write (iout,1005) noslt,noslv
c     Read local coords of solute and solvent for the old system
      write (iout,1001)
      irectx=25
      do ia=1,noslt
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) ioslt(ia),(coslt(k,ia),k=1,3)
        write (iout,1000) ioslt(ia),(coslt(k,ia),k=1,3)
        if (ioslt(ia) .lt. 0 .or. ioslt(ia) .gt. 99) then
          write (iout,1007) 'solute',ia,ioslt(ia)
          inperr=inperr+1
        end if
      end do
      if (iop37o .eq. 0) then
        write (iout,1002)
        irectx=26
        do ia=1,noslv
          call getnextrec(inpt,iout,irectx,nwwarn)
          read (line,1000,err=999) ioslv(ia),(coslv(k,ia),k=1,3)
          write (iout,1000) ioslv(ia),(coslv(k,ia),k=1,3)
          if (ioslv(ia) .lt. 0 .or. ioslv(ia) .gt. 99) then
            write (iout,1007) 'solvent',ia,ioslv(ia)
            inperr=inperr+1
          end if
        end do
        call grelcd(coslt,rlcslt,ioslt,noslt,2)
      end if
c     Obtain solute orientation
      call cofms(c(1,1),crm(1,1),ioslt,1,noslt,2,wx)
      call trnsfr(aa,rlcslt,9)
      do i=1,3
        do j=1,3
          b(i,j)=c(i,j)-crm(i,1)
        end do
      end do
      call ormat(orient,aa,b,noslt,0,linear,ifail)
c     Obtain solvent orientation
      if (iop37o .eq. 0) then
        call grelcd(coslv,rlcslv,ioslv,noslv,1)
        call trnsfr(aa,rlcslv,9)
        do im=2,nmolec
          ifat=noslt+(im-2)*noslv+1
          call cofms(c(1,ifat),crm(1,im),ioslv,1,noslv,1,wx)
          do j=1,3
            call arrdiff(b(1,j),c(1,ifat-1+j),crm(1,im),3)
          end do
c         Prepare new solvents
          call ormat(orient(1,1,im),aa,b,noslv,(im-1),linear,ifail)
        end do
      else
c       Assume standard water
        do im=2,nmolec
          ifat=noslt+(im-2)*noslv+1
          call cofms(c(1,ifat),crm(1,im),ianslv,1,3,1,wx)
          call ortslv(c(1,ifat),orient(1,1,im),ifail)
        end do
      end if
c     Prepare new solute
      call trnsfi(l1,iclslt,nstta)
      if (iop(30) .ge. 7) call zeroiti(l1,nstfa1,nstfa)
      call grelcd(cslt,rlcslt,l1,nstta,0)
      do i=1,nstta
        do j=1,3
          rr=0.0
          do k=1,3
            rr=rr+orient(j,k,1)*rlcslt(k,i)
          end do
          c(j,i)=rr+crm(j,1)
        end do
      end do
      call grelcd(cslv,rlcslv,ianslv,nslv,1)
      do im=2,nmolec
        do i=1,nslv
          do j=1,3
            rr=0.0
            do k=1,3
              rr=rr+orient(j,k,im)*rlcslv(k,i)
            end do
            c(j,ic00+im*nslv+i)=rr+crm(j,im)
          end do
        end do
      end do
      if (iop(30) .ge. 7) call lincmb(c,crm,cplpar,0,qslt,nstfa0)
      call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -  iop(47),iop(41),iop(90),iop(30),iop(24),filenames(2),namlens(2),
     -  iop(98),0,c)
      return
999   call invalidform(iout,irectx)
1000  format(i5,3f15.6)
1001  format(/,10x,' Local coordinates of solute molecule')
1002  format(/,10x,' Local coordinates of solvent molecule')
1005  format(' Solute and solvent orientations are preserved',/,
     - 10x,'Number of atoms on the old solute=',i6,/,
     - 10x,'Number of atoms on the old solvent=',i6)
1007  format(' ***** ERROR: ',a,' atom',i5,' invalid atomic number:',i5)
      end
      subroutine rancnf(icoms,igce,orient,c,crm,filename,namlen,MYRANK)
c#    MMC routine  56 lstmod: 05/15/14
c*****Create inital configuration randomly, but avoiding slt-slv overlap
      dimension orient(3,3,#MO),c(3,#NA),crm(3,#MO)
      character*80 filename
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /pretrans/ preshift(3),prerot(3,3),ipretrans
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      dimension crmslt(3),crmloc(3),ortloc(3,3),csv(3,#SV)
      data volume /0.0/
      if (iop(30) .eq. 7) then
        call trnsfi(l2,iclslt,nstta)
        call zeroiti(l2,nstfa1,nstfa)
c       Create third solute copy at cplpar
        call cofms(cslt,crmslt,l2,1,nstta,0,wx)
        call lincmb(cslt,crmslt,cplpar,0,qslt,nstfa0)
        call cofms(rlcslt,crmslt,l2,1,nstta,0,wx)
        call lincmb(rlcslt,crmslt,cplpar,0,qslt,nstfa0)
      end if
      if (idebug(9) .gt. 0) write (iout,7511) nstta,nstta3,natoms,
     -    (ia,(cslt(k,ia),k=1,3),(rlcslt(k,ia),k=1,3),ia=1,nstta)
      if (icoms .eq. 0) then
        call trnsfr(c,rlcslt,nstta3)
        call arrdiff(crmloc,cslt,rlcslt,3)
        write (iout,2008) crmloc
        if (ipretrans .eq. 0) then
          ipretrans=2
          call trnsfr(preshift,crmloc,3)
          call unitmat(prerot,3)
        else if (ipretrans .eq. 1) then
          call arrsum(preshift,preshift,crmloc,3)
        else if (ipretrans .eq. 2) then
          write (iout,2007)
          nwwarn=nwwarn+1
        end if
        if (iop(61) .gt. 0) then
          write (iout,2009)
          call trnsfr(cslt,rlcslt,nstta_full*3)
        end if
      else
        call trnsfr(c,cslt,nstta3)
      end if
      if (iop(69) .gt. 0) then
        do im=1,nsttm
          if (icorig(ifirstm(im)) .lt. 0) then
c           Cloned molecule - shift and rotate
            call grelcd(cslt(1,ifirstm(im)),rlcslt(1,ifirstm(im)),
     -        iclslt,ilastm(im)-ifirstm(im)+1,0)
            ntry=0
            ioverlap=1
            do while (ntry .lt. 100 .and. ioverlap .eq. 1)
              call ranpos(iop(5),crmloc)
              ioverlap=0
              if (im .gt. 1) then
                do ia=1,ilastm(im-1)
                  if (arrdist(c(1,ia),crmloc) .lt. 7.0) ioverlap=1
                end do
              end if
            end do
            call putmol(ilastm(im)-ifirstm(im)+1,
     -        rlcslt(1,ifirstm(im)),crmloc,c(1,ifirstm(im)),ortloc)
          else
            if (icoms .eq. 0)
     -        call trnsfr(c(1,ifirstm(im)),rlcslt(1,ifirstm(im)),
     -          3*(ilastm(im)-ifirstm(im)+1))
            if (icoms .eq. 1)
     -        call trnsfr(c(1,ifirstm(im)),cslt(1,ifirstm(im)),
     -          3*(ilastm(im)-ifirstm(im)+1))
          end if
        end do
      end if
      iop5p1=mod(iop(5)+1,10)
      numsolv=nmolec-1
      edg2=0.0
      edg3=0.0
      if (iop(27) .gt. 0) then
c       Determine system size from p.m.vol. and, optionally, from no of shells
c       pmvslt, pmvslv: slt, slv p.m.v in ml/mol
c       rnshll: no of water shells needed
        if (pmvslt .eq. 0) then
          if (MYRANK .eq. 0) write (iout,2003)
          nwarn=nwarn+1
        end if
        pmvst=pmvslt*1.e+24/avogad
        pmvsv=pmvslv*1.e+24/avogad
        if (iop(27) .eq. 2) then
c         Use PMV and number of shells
          rmx=0.0
          do i=1,nstta
            rs=0.0
            do k=1,3
              rs=rs+rlcslt(k,i)**2
            end do
            rs=sqrt(rs)+vdw(ianslt(i))
            if (rs .gt. rmx) rmx=rs
          end do
c         Determine inscribed sphere radius, volume, nmolec
          rinsc=rmx+rnshll*2.85
c         First determine the number of waters from the inscribed sphere radius
          if (iop5p1 .eq. 1) then
c           Simple cubic
            volume=(2.0*rinsc)**3
          else if (iop5p1 .eq. 2) then
c           Face-centered cubic
            volume=2.0*(rinsc*sqrt(2.0))**3
          else if (iop5p1 .eq. 3) then
c           HCP
            volume=8.0*rinsc**3/sqrt(2.0)
          else if (iop5p1 .eq. 4) then
c           TOCT
            volume=32.0*rinsc**3/(5.0*sq5)
          else if (iop5p1 .eq. 5) then
c           Hexagonal prism - accept long dimension if possible
            if (edgexyz(1) .lt. 2.0*rinsc) edgexyz(1)=2.0*rinsc
            volume=edgexyz(1)*rinsc**2*3.0*sqrt(3.0)/2.0
          else if (iop5p1 .eq. 6) then
c           Input PBC - can't do it
            inperr=inperr+1
            if (MYRANK .eq. 0) write (iout,2006)
            volume=pmvst+100.0*pmvslv
          else if (iop5p1 .eq. 7) then
c           Sphere
            volume=pi43*rinsc**3
          end if
          numsolv=int((volume-pmvst)/pmvsv)+1
        else if (iop(27) .eq. 3) then
c         Calculate number of solvents from inputted volume and pmv's
          numsolv=int((vol-pmvst)/pmvsv)+1
          nmolec=numsolv+1
          natoms=nstta+nslv*numsolv
        end if
c       Obtain (again) the volume (to account for fractional changes)
        volume=pmvst+numsolv*pmvsv
c       Calculate cell parameters from the volume
        if (iop5p1 .eq. 1) then
c         Simple cubic
          edg1=volume**(1.0/3.0)
          edg2=edg1
          edg3=edg1
        else if (iop5p1 .eq. 2) then
c         Face-centered cubic
          edg1=(volume/2.0)**(1.0/3.0)
        else if (iop5p1 .eq. 3) then
c         HCP
          edg1=(volume*sqrt(2.0))**(1.0/3.0)
        else if (iop5p1 .eq. 4) then
c         TOCT
          edg1=(volume/4.0)**(1.0/3.0)
        else if (iop5p1 .eq. 5) then
c         Hexagonal prism
          edg1=edgexyz(1)
          edg2=sqrt(volume/(edg1*3.0*sq3p2))
          if (MYRANK .eq. 0) write (iout,2001) edg1
        else if (iop5p1 .eq. 6 .or. iop5p1 .eq. 7) then
c         Sphere or PHS
          edg1=(volume/pi43)**(1.0/3.0)
        end if
        call initbc(iop(5),edg1,edg2,edg3,iop(24),inpt,iout)
        call crorgn(edgexyz(1),edgexyz(2),edgexyz(3),iop(5),3)
        nmolec=numsolv+1
        if (nmolec .gt. #MO) then
          if (MYRANK .eq. 0) write (iout,2000) nmolec
          nmolec=#MO
          numsolv=nmolec-1
          inperr=inperr+1
          natoms=nstta+numsolv*nslv
        end if
      end if
      do im=2,nmolec
c       Generate solvent com that does not overlap with the solute
        rdmx2=-1.0
        do while (rdmx2 .lt. 0.0)
          call ranpos(iop(5),crmloc)
          rdmx2=+1.0
          do ia=1,nstta
            iatno=ianslt(ia)
            rd2=arrdist(c(1,ia),crmloc)-(vdw(iatno)+1.1)**2
            if (rd2 .lt. rdmx2) rdmx2=rd2
          end do
        end do
        call trnsfr(crm(1,im),crmloc,3)
        call putmol(nslv,rlcslv,crmloc,csv,ortloc)
        call trnsfr(orient(1,1,im),ortloc,9)
        call trnsfr(c(1,ic01+im*nslv),csv,3*nslv)
      end do
      if (iop(30) .eq. 7)
     -  call checkcpl(1,c,crm,nstfa0,iclslt,isltmv,cplpar,nerr,2,MYRANK)
      if (MYRANK .eq. 0) call savec(icord,iout,nwarn,c,natoms,nmolec,
     -  cplpar,edgexyz,iop(47),iop(41),iop(90),iop(30),iop(24),
     -  filename,namlen,iop(98),0,c)
      if (igce .eq. 0) then
        if (iop(6) .gt. 4) then
          iop6ol=iop(6)
c         Set sampling to Metropolis to avoid overflows
          iop(6)=0
          if (MYRANK .eq. 0) write (iout,2002)
          nchng=nchng+1
        end if
        if (iop(4) .gt. 1) then
c         Prevent distribution function calculation to avoid int overflows
          iop(4)=1
          if (MYRANK .eq. 0) write (iout,2005)
          nchng=nchng+1
        end if
        if (iop(46) .eq. 0 .and. nmolec .gt. 1)  then
          if (MYRANK .eq. 0) write (iout,2004)
          nwarn=nwarn+1
        end if
      end if
      nmol3=3*nmolec
      return
2000  format(' ***** ERROR: program can not handle the number of',
     -  ' waters required=',i5)
2001  format(' Hexagonal prism volume will be calculated using the',
     -  ' inputted prism length(if possible) = ',f8.3,' A')
2002  format(' >>>>> OVERRIDE: Sampling switched to Metropolis')
2003  format(' ----- WARNING: Partial molar volume of the solute',
     -  '  is given as zero')
2004  format(' ----- WARNING: solvent charges were not turned off',
     -  ' for a run started at a randomly generated configuration',/,
     -  6x,' solvents may get stuck to the solute - see keyword CHRG')
2005  format(' >>>>> OVERRIDE: Distribution function calculations have',
     -  ' been turned off')
2006  format(' ***** ERROR: can not figure out number of waters',
     -  '  for inputted PBC')
2007  format(' ===== STRONG WARNING: system was already shifted before',
     -  ' being rotated - can not add the COM shift to the ',
     -  ' pretransformation',/,7x,'Use CNFG RANI instead of CNFG RANC',
     -  ' or use an additional tracslation by the COM printed above')
2008  format(' The COM coordinates (',2(f10.5,','),f10.5,') will be ',
     -  'substracted from the solute coordinates read')
2009  format(' ///// NOTE: Input solute coordinates shifted to COM')
7511  format(' RANCNF: nstta,nstta3,natoms=',3i6,' cslt, rlcslt=',/,
     -  (i4,3f10.5,5x,3f10.5))
      end
      subroutine scrambletor(c,nsttm,iout)
c#    MMC routine  57 lstmod: 07/31/07
c*****Scramble the torsion angles
      dimension c(3,#NA)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 ran
      dimension ran(100)
      itt0=0
      do im=1,nsttm
        ntor=ilastt(im)-ifirstt(im)+1
        if (ntor .gt. 0) then
          nscr=0
          do it=ifirstt(im),ilastt(im)
            itt=it-ifirstt(im)
            if (mod(itt,100) .eq. 0) then
              itt0=itt
              call mmc_random(min0(100,ntor-itt0),ran)
            end if
            if (itorgrp(it) .gt. 1 .or. iop(18) .ne. 4) then
              nscr=nscr+1
              dihang(it)=-pi+ran(itt-itt0+1)*pi2
            end if
          end do
          if (nscr .gt. 0)
     -      call gentor(ifirstt(im),ilastt(im),dihang,c,itangindx,
     -        iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -        bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -        #TR,#ST)
        end if
      end do
      return
      end
      subroutine corscl(edgn,c,filename,namlen)
c#    MMC routine  58 lstmod: 07/18/03
c*****This subroutine modifies coordinates of solvent molecules
c     to accommodate changes in the volume of the unit cell
      dimension c(3,#NA),edgn(3)
      character*80 filename
c     The solvent distances relative to the center of the old
c     unit cell are scaled, without affecting the internal geometry
c     of the solvent molecule.
c     Scaling is done in x, y and z directions, and is dependent
c     on the edges (edgo1,edgo2,edgo3) of the old unit cell
c     and the edges (edge1,edge2, and edge3) of the present unit cell.
c     Note that the type of the unit cell - fcc, sc, etc , must
c     not change in going from old to new unit cell.
c     Originally written by P.K. Mehrotra.
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      dimension sca(3),dr(3)
c     edgn1,edgn2 and edgn3 specify the edg1, edg2, and edg3
c     for the new unit cell.
      do k=1,3
        sca(k)=edgn(k)/edgexyz(k)-1.0
      end do
      do im=2,nmolec
        do k=1,3
          dr(k)=c(k,ic01+im*nslv)*sca(k)
        end do
        do j=1,nslv
          do k=1,3
            c(k,ic00+im*nslv+j)=c(k,ic00+im*nslv+j)+dr(k)
          end do
        end do
      end do
      write (iout,1000) edgn(1),edgn(2),edgn(3)
      call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -  iop(47),iop(41),iop(90),iop(30),1,filename,namlen,iop(98),0,c)
      call datprt(1)
1000  format(' +++++ Solvent coordinates were scaled to '
     -      ,' accommodate the volume change in the unit cell',
     -      / ' to correspond to the new cell parameters ' ,3f15.10,/,
     -      ' Restart the program reading in the new coordinates')
      end
      subroutine crtpij(ieqc,cplpar,nstfa0new,cgs,c,crm,filename,namlen)
c#    MMC routine  59 lstmod: 09/03/98
c*****This subroutine modifies the initial coordinates of an input
c     file to insert a second solute conformation and leave room
c     for a linear combination of the two.
c     nst* is updated accordingly
      dimension c(3,#NA),crm(3,#MO),cgs(3,#HA)
      character*80 filename
      common /jrgdat/ sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),
     -  c12jrg(#AT)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      character*80 line
      common /inpline/ line,lineno,icol
      nsttaold=nstta
      nstfa0=nstfa0new
      nstta=nstta+2*nstfa0
      call checkdim(ifail,iout,inperr,'ST',nstta,0,0,0)
      if (ifail .eq. 1) nstta=#ST/3
      write (iout,2000) cplpar
      read (ieqc) ((cgs(k,i),k=1,3),i=1,natoms)
      irectx=31
      do ia=1,nstfa0
        l=nstfa0+ia
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1020,err=999) iclslt(l),(cslt(k,l),k=1,3),qslt(l),
     -    igrslt(l)
        if (iop(24) .gt. 0)
     -  write (iout,1331) iclslt(l),(cslt(k,l),k=1,3),qslt(l),igrslt(l)
        if (iclslt(i) .ne. iclslt(l)) then
          inperr=inperr+1
          write (iout,2003) iclslt(i),iclslt(l)
        end if
        iclslt(l)=iclslt(ia)
        iopslt(l)=iopslt(ia)
        ianslt(l)=ianslt(ia)
        iclslt(nstfa0+l)=iclslt(ia)
        iopslt(nstfa0+l)=iopslt(ia)
        ianslt(nstfa0+l)=ianslt(ia)
      end do
      call lincmb(c,crm,cplpar,0,qslt,nstfa1)
      call trnsfr(c(1,nstfa+1),cgs(1,nstfa0+1),3*(natoms-nstfa0))
      natoms=natoms+nstfa1
c     Create combined solute into c
      call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -  iop(47),iop(41),iop(90),iop(30),iop(24),filename,namlen,
     -  iop(98),0,c)
      write (iout,2004)
      call datprt(1)
999   call invalidform(iout,irectx)
1020  format(i5,4f15.0,i5)
1331  format(' rectype 31  : ',i5,4f15.6,i5)
2000  format(/,' Probability ratio file, Initial coupling parameter',
     - ' value=',f8.4,/,' Second solute conformation, charges=')
2003  format(' ***** ERROR: solute atom types are different',
     -  ' in the two conformations:',2i4)
2004  format(//,' Now start the program with CNFG READ')
      end
      subroutine findor(orient,orientsltm,c,crm,crm0,iconfread,
     -  iop47read)
c#    MMC routine  60 lstmod: 09/04/16
c*****Obtain the orientation matrix and COM local coordinates
      dimension c(3,#NA),orient(3,3,#MO),crm(3,#MO),
     -  crm0(3,#MO),orientsltm(3,3,#MM)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /ecell/ cic(3,27),ncell
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /rangen/ xyzlim(3),xlim2,ylim2,zlim2,ixpxo
      character*1 lxyz
      common /names/ lxyz(3)
      common /isoeng/ dimax,dijs,dijq,dijso,dijqo,eniemx,eniemo
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      dimension a(3,3),d(3),ct(3),keycol(2),crmslt(3),cmin(3),cmax(3),
     -  cm(3),ixrep3slt(3)
      character*80 filnam,filename1
      call settol(nstta,nstfa,nmolec,iout)
      nrep3slt=0
      ifilecrd=2
      if (iconfread .eq. 2) ifilecrd=3
c     Solute COM and orientation matrix
      if (iop(57) .gt. 0 .or. nstta .eq. 0) then
c       Solute can't be rotated due to partial solute moves
        call unitmat(orient,3)
      else
c       Obtain rotation matrix using fixed atoms only
        call getortslt(c,crm,rlcslt,orient,iclslt,nstfa,nstfa1,nstta,
     -    natoms,isltmv,0,nwarn,inperr,iout)
      end if
      if (iop(7) .eq. 2) then
c       For iso-energy cutoff, get intergroup distance square, cube
        dijs=arrdist(c(1,icent1),c(1,icent2))
        dijq=dijs**2
        eniemx=1.0/dijs - 1.0/(sqrt(dijs)+cutslt)**2
      end if
      if (iop(18) .eq. 3) then
c       Determine the center of the rotated part and its orient., Euler angs.
        do ia=1,nstfa0
          call arrdiff(rlcsec(1,ia),c(1,ia),crm2nd0,3)
        end do
        call getort(c(1,nstfa0+1),crm2nd1,iclslt(nstfa0+1),rlcsec,
     -    nstfa0,ort2nd,0,ixislt,0,linear,1,0,ixrep3slt,nrep3slt,ifail,
     -    idebug(29),iout,nstta)
        if (MYRANK .eq. 0)
     -    call ckortfail(ifail,'input configuration, FE copy #2',31,0,0,
     -    0,inperr,iout)
        call rottoeuler(ort2nd,euler2nd(1),euler2nd(2),euler2nd(3))
        do i=1,3
          euler(i)=euler2nd(i)*rdtodg
        end do
        if (MYRANK .eq. 0) write (iout,7711) ort2nd,euler
7711    format(' Orientation of change',3(3f8.4,3x),/,
     -    ' Euler angles:', 3f10.4,' deg')
        eulercos2=cos(euler2nd(2))-1.0
      else if (iop(18) .eq. 5) then
c       Determine the current shift and orientation of the PMF molecule
        call lincmb(c,crmslt,cplpar,0,qslt,nstfa0)
        call arrdiff(crmpmf,c(1,icent1),crmpmf0,3)
        do ia=nstfa1+1,nstfa
          call arrdiff(rlcslt(1,ia),cslt(1,ia),cslt(1,molcnt(3)),3)
        end do
        call getort(c(1,nstfa1+1),c(1,icent1),iclslt(nstfa1+1),rlcslt,
     -    nstfa0,ort2nd,0,ixislt,0,linear,1,0,ixrep3slt,nrep3slt,ifail,
     -    idebug(29),iout,nstta)
        if (MYRANK .eq. 0)
     -    call ckortfail(ifail,'input configuration, FE copy #3',31,0,0,
     -    0,inperr,iout)
        if (MYRANK .eq. 0) write (iout,1029) cplpar,crmpmf,ort2nd
      end if
c     Check solute and reset to cell if needed
      call trnsfr(cm,crm,3)
      call pbcnd(cm(1),cm(2),cm(3),iop(5),iopt,riijj)
      if (iopt .gt. 1) then
        if (MYRANK .eq. 0) write (iout,1000)
        if (MYRANK .eq. 0) write (iout,1034)
        nwwarn=nwwarn+1
        call pbc_shift(c,1,nstta,cic(1,iopt),iopt,iop(5),crm)
      end if
      if (nstta .gt. 0) then
c       Check if any solute atom is outside the cell
        nout=0
        noutt=0
        call trnsfr(cmin,c,3)
        call trnsfr(cmax,c,3)
        do ia=1,nstta
          call trnsfr(ct,c(1,ia),3)
          do k=1,3
            if (cmin(k) .gt. c(k,ia)) cmin(k)=c(k,ia)
            if (cmax(k) .lt. c(k,ia)) cmax(k)=c(k,ia)
          end do
          call pbcnd(ct(1),ct(2),ct(3),iop(5),iopt,riijj)
          if (iopt .gt. 1) then
            nout=nout+1
            if (((iop(175) .eq. 0 .and. nout .le. 25)
     -           .or .iop(24) .gt. 1) .and. MYRANK .eq. 0)
     -        write (iout,1024) ia,(c(k,ia),k=1,3)
            if (iop(2) .eq. 2) then
              call trnsfr(c(1,ia),ct,3)
              if ((nout .le. 25 .or. iop(24) .gt. 1).and. MYRANK .eq. 0)
     -          write (iout,1028) ia
            end if
            if (iop(5) .lt. 5) then
c             Check if solute is way out
              call pbcnd(ct(1),ct(2),ct(3),iop(5),ioptt,riijj)
              if (ioptt .gt. 1) then
                noutt=noutt+1
                if ((nout .le. 25 .or. iop(24) .gt. 0) .and.
     -               MYRANK .eq. 0) write (iout,1031) ia,(c(k,ia),k=1,3)
              end if
            end if
          end if
        end do
        if (noutt .gt. 0) then
          if (MYRANK .eq. 0) write (iout,1032) noutt
          inperr=inperr+1
        end if
        if (nout .gt. 0) then
          if ((iop(41) .eq. 1 .or. iop(41) .eq. 2 .or. iop(30) .eq. 1)
     -        .and. iop(83) .eq. 0) iop(83)=2
          if (iop(175) .eq. 0) then
            if (nmolec .gt. nsttm .or. iop(24) .gt. 1) then
              nwarn=nwarn+1
              if (MYRANK .eq. 0) write (iout,1027) nout,'solute atoms'
              if (MYRANK .eq. 0) write (iout,1015)
            end if
          else
            if (MYRANK .eq. 0) write (iout,1026) nout,'solute atoms'
          end if
        end if
        noff=0
        do k=1,3
          iperc=100.0*abs(cmax(k)+cmin(k))/(2.0*xyzlim(k))
          if (iperc .gt. 80) then
            noff=noff+1
            nwwarn=nwwarn+1
            if (MYRANK .eq. 0)
     -        write (iout,1035) " ===== STRONG WARNING",iperc,lxyz(k)
          else if (iperc .gt. 50) then
            noff=noff+1
            nwarn=nwarn+1
            if (MYRANK .eq. 0)
     -        write (iout,1035) " ----- WARNING",iperc,lxyz(k)
          end if
        end do
        if (noff .gt. 0 .and. MYRANK .eq. 0) write (iout,1034)
      end if
      igenpmf=0
      if (iop(30) .eq. 7 .and. iop(18) .ne. 4) then
c       Check if solute is really invariant
        dmax=0.0
        do ifl=impmf1,impmf2
          do i=ifirstm(ifl)+1,ilastm(ifl)
            i1=i-nstfa0
            i2=i-nstfa1
            do j=ifirstm(ifl),i-1
              j1=j-nstfa0
              j2=j-nstfa1
              r1=arrdist(cslt(1,i1),cslt(1,j1))
              r2=arrdist(cslt(1,i2),cslt(1,j2))
              dc=abs(sqrt(r1)-sqrt(r2))
              if (dc .gt. dmax) dmax=dc
              if (iop(18) .gt. 0) then
                if (dmax .gt. 0.1) then
                  if (MYRANK .eq. 0) write (iout,1012)
                  if (MYRANK .eq. 0) write (iout,1009) dmax
                  inperr=inperr+1
                else if (dmax .gt. 0.001) then
                  if (MYRANK .eq. 0) write (iout,1013)
                  nwarn=nwarn+1
                  if (MYRANK .eq. 0) write (iout,1009) dmax
                end if
              end if
            end do
          end do
          if (iop(18) .eq. 0 .and. dmax .gt. 0.1) igenpmf=1
        end do
      end if
      if (iop(18) .eq. 4) then
c       Check if solute on unit icord has not been rotated
        drmax=0.0
        do k=1,3
          drmax=amax1(drmax,abs(1.0-orient(k,k,1)))
        end do
        do k=2,3
          k1=k-1
          do l=1,k1
            drmax=amax1(drmax,abs(orient(k,l,1)))
            drmax=amax1(drmax,abs(orient(l,k,1)))
          end do
        end do
        if (MYRANK .eq. 0) write (iout,1005) drmax
        if (drmax .gt. 0.1) then
          if (iop(50) .eq. 1 .or. iop(50) .eq. 2) then
c           Rotate solute back to the input orientation
            call trnsfr(a,orient,9)
            call rot_trans(a,rlcslt,crm,c,nstta)
            call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -        iop(47),0,iop(90),iop(30),iop(24),filenames(2),namlens(2),
     -        iop(98),0,c)
            if (MYRANK .eq. 0)
     -        write (iout,1007) filenames(2)(1:namlens(2))
            call datprt(1)
          else
            if (MYRANK .eq. 0) write (iout,1006)
            if (MYRANK .eq. 0) write (iout,1011) icord,icord
            inperr=inperr+1
          end if
        end if
      end if
      if (iop(57) .gt. 0 .or. isltmove .eq. 0) then
c       Translate molecules in rlcslt to molecule centers
        do im=1,nsttm
          if (isltmv(molcnt(im)) .eq. 2 .and.
     -        (im .gt. nstfm .or. im .le. nstfm1)) then
            if (MYRANK .eq. 0) write (iout,1019) molcnt(im),im
            inperr=inperr+1
          end if
          call findifmolinc(iop,nstfm0,ifdummy,im,ifinc)
          do ia=ifirstm(im)-ifinc,ilastm(im)
            call arrdiff(rlcslt(1,ia),cslt(1,ia),cslt(1,molcnt(im)),3)
          end do
        end do
c       Reset solute molecules into the central cell
        nfout=0
        do im=1,nsttm
          call trnsfr(d,c(1,molcnt(im)),3)
          call pbcnd(d(1),d(2),d(3),iop(5),iopt,dist2)
          if (iopt .gt. 1) then
            if (im .le. nstfm) then
              if (MYRANK .eq. 0) write (iout,1030) im
              nwwarn=nwwarn+1
              nfout=nfout+1
            else if (idebug(115) .eq. 0) then
              if (MYRANK .eq. 0) write (iout,1022) im
              nwarn=nwarn+1
              call pbc_shift(c,ifirstm(im),ilastm(im),cic(1,iopt),iopt,
     -          iop(5),d)
            end if
          end if
        end do
        if (nfout .gt. 0 .and. MYRANK .eq. 0) write (iout,1034)
      end if
c     Initialize orientsltm
c     First set all values to no partial displ, rot
c     Additional part of different type will be an extra solute group
      do im=1,nsttm
        call unitmat(orientsltm(1,1,im),3)
      end do
      if ((iop(58) .gt. 0 .or. iop(18) .eq. 4) .and. ntang .eq. 0) then
        if (MYRANK .eq. 0) write (iout,1010)
        inperr=inperr+1
      end if
      imf=1
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) imf=nstfm+1
c???
      if (isltmove .eq. 0) then
c       Get the current value of orientsltm for each solute molecule
        do im=imf,nsttm
          im0=1
          if (im .gt. 1) im0=natfix(im-1)+1
          if (iop(58) .gt. 0 .and. moltused(im) .eq. 1) then
            call getort(c(1,ifirstm(im)),c(1,molcnt(im)),
     -        iclslt(ifirstm(im)),rlcslt(1,ifirstm(im)),
     -        natfix(im)-im0+1,orientsltm(1,1,im),0,iroots(im0),
     -        ifirstm(im)-1,linear,1,0,ixrep3slt,nrep3slt,ifail,
     -        idebug(33),iout,natoms)
            if (MYRANK .eq. 0)
     -        call ckortfail(ifail,'input configuration',19,im,0,
     -        0,inperr,iout)
          else
            call getort(c(1,ifirstm(im)),c(1,molcnt(im)),
     -        iclslt(ifirstm(im)),rlcslt(1,ifirstm(im)),
     -        ilastm(im)-ifirstm(im)+1,orientsltm(1,1,im),0,ixislt,
     -        0,linear,1,0,ixrep3slt,nrep3slt,ifail,idebug(33),
     -        iout,ilastm(im)-ifirstm(im)+1)
            if (MYRANK .eq. 0)
     -        call ckortfail(ifail,'input configuration',19,im,0,
     -        0,inperr,iout)
          end if
        end do
      end if
      if (iop(160) .eq. 0 .or. (iop(152).lt. 2 .and. iop(9) .le. 9))then
c       Check if slt on unit icord is the same as on unit 5
        if (idebug(8) .eq. 1 .and. MYRANK .eq. 0) write (iout,7712)
     -    nstta, (crm(k,1),k=1,3),(ia,(c(k,ia),k=1,3),(cslt(k,ia),
     -    k=1,3),(rlcslt(k,ia),k=1,3),ia=1,nstta)
        wlim=sqrt(cslttol)
        elim=10*wlim
        if (iop47read .eq. 3) then
c         PDB file has fewer digits
          elim=2.0*elim
          wlim=2.0*wlim
        end if
        dcmax=0.0
        nwarnp=0
        if (iop(57)+iop(58) .eq. 0) then
          if (isltmove .gt. 0) then
            call rot_trans(orient,rlcslt,crm,cslto,nstta)
          else
            call trnsfr(cslto,cslt,nstta*3)
            call arrdiff(ct,cslto,c,3)
            do ia=1,nstta
              do k=1,3
                cslto(k,ia)=cslto(k,ia)-ct(k)
              end do
            end do
          end if
        end if
        do im=imf,nsttm
          nfound=0
          if (im .gt. nstfm .or. iop(30) .lt. 5) then
c           Free-energy solutes will be checked separately
            if (iop(57)+iop(58) .gt. 0 .or. isltmove .eq. 0)
     -        call rot_trans(orientsltm(1,1,im),rlcslt(1,ifirstm(im)),
     -          c(1,molcnt(im)),cslto(1,ifirstm(im)),
     -         ilastm(im)-ifirstm(im)+1)
            do ia=ifirstm(im),ilastm(im)
              if (isltmv(ia) .lt. 2) then
                call arrdiff(ct,cslto(1,ia),c(1,ia),3)
                if (iop(2) .eq. 2)
     -            call pbcnd(ct(1),ct(2),ct(3),iop(5),iopt,riijj)
                dc=abs(ct(1))+abs(ct(2))+abs(ct(3))
                nfound=nfound+1
                if (dc .ge. wlim) then
                  nwarnp=nwarnp+1
                  if (nwarnp .lt. 25 .or. iop(24) .gt. 1 .and.
     -                MYRANK .eq. 0) write (iout,1003)
     -                  filenames(2)(1:namlens(2)),dc,ia
                end if
                if (dcmax .lt. dc) dcmax=dc
              end if
            end do
          end if
        end do
        if (iop(30) .eq. 6 .or. iop(30) .eq. 7) then
c         Compare the free-energy solutes
          do ia=1,2*nstfa0
            do ja=ia+1,2*nstfa0
              dc=abs(arrdist(c(1,ia),c(1,ja))-
     -          arrdist(cslt(1,ia),cslt(1,ja)))
              if (dcmax .lt. dc) dcmax=dc
          end do
        end do
        end if
        if (MYRANK .eq. 0) write (iout,1002)
     -    filenames(ifilecrd)(1:namlens(ifilecrd)),dcmax
        if (nwarnp .gt. 0) then
          if (MYRANK .eq. 0) write (iout,1021) nwarnp
          if (nwarnp .gt. 25 .and. iop(24) .le. 1 .and.
     -        MYRANK .eq. 0) write (iout,1020) 'ECHO'
        end if
        nwarn=nwarn+nwarnp
        if ((dcmax .ge. wlim .and. iop(50) .eq. 1) .or.
     -       dcmax .ge. elim .and. iop(50) .eq. 2) then
c         Replace unit icord solute with unit 5 solute
          if (nsltcp(iop(30)+1) .eq. 5) then
            call trnsfr(c,cslto,3*nstfa1)
            call lincmb(c,crm,cplpar,0,qslt,nstfa0)
            if (nstta .gt. nstfa)
     -      call trnsfr(c(1,nstfa+1),cslto(1,nstfa+1),3*(nstta-nstfa))
          else
            call trnsfr(c,cslto,nstta3)
          end if
          call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -      iop(47),iop(41),iop(90),iop(30),iop(24),filenames(2),
     -      namlens(2),iop(98),0,c)
          if (MYRANK .eq. 0) write (iout,1007)filenames(2)(1:namlens(2))
          call datprt(1)
        else if (dcmax .gt. wlim) then
          if (iop(50) .eq. 3) then
c           Replace unit 5 solute with unit icord solute
            if (iop(18) .eq. 3) then
              if (MYRANK .eq. 0) write (iout,1014)
              inperr=inperr+1
            end if
            if (iop(159) .gt. 0) then
              call trnsfr(d,cslt,3)
              do ia=1,nstta
                call arrdiff(rlslt1(1,ia),cslt(1,ia),d,3)
              end do
            end if
            call trnsfr(cslt,c,nstta3)
            call trnsfi(l1,iclslt,nstta)
            if (iop(30) .ge. 7) call zeroiti(l1,nstfa1,nstfa)
            call grelcd(cslt,rlcslt,l1,nstta,0)
            if (MYRANK .eq. 0)
     -        write (iout,1008) filenames(2)(1:namlens(2))
            if (MYRANK .eq. 0) write (iout,1033)
            nwwarn=nwwarn+1
            if (iop(58) .gt. 0) then
              call findtangles(0,ntang,itangindx,iprecursor,nrot,
     -          irotlist,irotlinc,iquata,rlcslt,dihang,tangd,sindela,
     -          cosdela,1,3,idebug(21),iout,nwarn,inperr,#TR,#ST)
              natfx0=0
              do im=imf,nsttm
                if (moltused(im) .eq. 1)
     -            call findbdag(ifirstm(im),ilastm(im),rlcslt,bond,
     -            bond2,angle,cangle,bond13,bond12,angle13,cangle13,
     -            iprecursor,natfix(im)-natfx0,iroots(natfx0+1),
     -            idebug(22),inperr,iout,#ST)
                natfx0=natfix(im)
              end do
              call trnsfr(cangle0,cangle,nstta)
              call inittor(1,ntang,rlcslt,itangindx,iprecursor,nrot,
     -          irotlist,irotlinc,bond,bond2,angle,cangle,bond13,bond12,
     -          cangle13,bondf,bondproj,xfac13,xfac12,
     -          cangle40,bond420,idebug(23),iout,#TR,#ST)
            end if
          else if (iop(50) .eq. 0 .and. dcmax .gt. elim) then
            if (MYRANK .eq. 0) write (iout,1004)
     -        filenames(ifilecrd)(1:namlens(ifilecrd))
            if (iop(160) .gt. 0 .and. MYRANK .eq. 0) write (iout,1025)
            if (MYRANK .eq. 0) write (iout,1011)
     -        filenames(ifilecrd)(1:namlens(ifilecrd)),
     -        filenames(ifilecrd)(1:namlens(ifilecrd))
            inperr=inperr+1
            if (idebug(97) .gt. 0) then
              lfilnam=11
              filnam(1:lfilnam)='DEBUG_F.pdb'
              call savepdb('PDB ',keycol,iupdb1,iout,1,nstta,3,c,
     -          -1,0,0,1,filename1,nfl,0,2,filnam,lfilnam,1,1,0,inperr,
     -          nwarn,nwwarn,9,0,nlwr,0,-1,#NA)
              end if
          else if ((iop(58) .gt. 0 .or. iop(18) .eq. 4)
     -              .and. iop(50) .eq. 4) then
            if (MYRANK .eq. 0) write (iout,1023)
            nwwarn=nwwarn+1
          end if
        end if
      end if
      call trnsfr(cslto,c,nstta3)
      do im=2,nmolec
        call cofms(c(1,ic01+im*nslv),crm(1,im),ianslv,1,nslv,1,wx)
      end do
c     Check/reset solvent molecules outside the cell
      nout=0
      do im=2,nmolec
        if (idebug(80) .gt. 0) call trnsfr(d,crm(1,im),3)
        call trnsfr(cm,crm(1,im),3)
        call pbcnd(cm(1),cm(2),cm(3),iop(5),iopt,riijj)
        if (idebug(80) .gt. 0) then
          call trnsfr(ct,d,3)
          call pbcnd(d(1),d(2),d(3),7,ioptcheck,riijj)
          if (iopt .ne. ioptcheck) then
            numdiscr=numdiscr+1
            write (iout,1038) iopt,ioptcheck,ct
          else if (idebug(80) .gt. 1) then
            write (iout,1039) im,iopt,ct
          end if
        end if
        if (iop(5) .ne. 5) then
          if (iopt .gt. 1) then
            if (iop(160) .eq. 0) then
              if (MYRANK .eq. 0)
     -          write (iout,1001) im-1,'was reset into',(cm(k),k=1,3)
                nwarn=nwarn+1
              call pbc_shift(c(1,ic01+im*nslv),1,nslv,cic(1,iopt),iopt,
     -          iop(5),crm(1,im))
            else
              nout=nout+1
              if (((iop(175) .eq. 0 .and. nout .le. 25)
     -             .or .iop(24) .gt. 1) .and. MYRANK .eq. 0)
     -            write (iout,1001) im,'is outside',(crm(k,im),k=1,3)
              nwarn=nwarn+1
            end if
          end if
        else
c         Sphere boundary conditions
          if (riijj .gt. rinscs) then
            if (iop(160) .eq. 0) then
c             Molecule is out of the sphere, pull it back
              fac=sqrt(rinscs/riijj)*0.99-1.0
              do k=1,3
                cd(k)=fac*crm(k,im)
                crm(k,im)=crm(k,im)+cd(k)
                do i=1,nslv
                  c(k,ic00+im*nslv+i)=c(k,ic00+im*nslv+i)+cd(k)
                end do
              end do
              if (MYRANK .eq. 0) write (iout,1017) im
              nwwarn=nwwarn+1
            else
              nout=nout+1
              if (((iop(175) .eq. 0 .and. nout . le. 25)
     -             .or .iop(24) .gt. 1) .and. MYRANK .eq. 0)
     -           write (iout,1018) im
              nwarn=nwarn+1
            end if
          end if
        end if
      end do
      if (nout .gt. 0) then
        percout=float(nout*100)/float(nmolec)
        if (MYRANK .eq. 0) then
         write (iout,1027) nout,'solvent molecules'
        if (iop(175) .eq. 0 .and. nout .gt. 25 .and. iop(24) .le. 1)
     -     write (iout,1020) 'DETL'
        if (iop(175) .gt. 0) write (iout,1026) nout,'solvent molecules'
        if (percout .gt. 0.02 .and. nmolec .gt. 100)
     -    write (iout,1036) percout
        end if
        if (percout .gt. 0.02 .and. nmolec .gt. 100) nwwarn=nwwarn+1
      end if
c     Save initial COM for diffusion calculation
c     crm0: COM array of initial configuration, continuously updated
c     for image changes as molecules move in and out of the box.
      call trnsfr(crm0,crm,nmol3)
c     Determine the solvent rotation matrices orient(3,3,is),is=2,nmolec
      if (iop(26) .lt. 4) then
c       Standard water solvent
        do im=2,nmolec
          call ortslv(c(1,ic01+im*nslv),orient(1,1,im),ifail)
        end do
      else
c       General solvent
        call indexit(l1,1,nslv,0)
        nrep3=min0(3,nslv)
        call get3repats(rlcslv,nslv,l1,nslv,0,ixrep3,nrep3)
        if (idebug(131) .gt. 0)
     -    write (iout,7713) nrep3,(ixrep3(i),i=1,nrep3)
        do im=2,nmolec
          call getort(c(1,ic01+im*nslv),crm(1,im),ianslv,rlcslv,nslv,
     -      orient(1,1,im),(im-2+1),ixislt,-1,linear,0,0,ixrep3,nrep3,
     -      ifail,idebug(29),iout,nslv)
C@DM          if (MYRANK .eq. 0) then
            call ckortfail(ifail,'input configuration',19,0,im,0,inperr,
     -        iout)
            if (ifail .gt. 0 .and. idebug(132) .gt. 0) write (iout,1037)
     -        im,((c(k,ic00+im*nslv+j),k=1,3),j=1,nslv)
C@DM          end if
        end do
      end if
c     clstup: com's of the position at the last nn table update.
C@NN      call trnsfr(clstup,crm,nmol3)
      return
1000  format(' ===== STRONG WARNING: the solute COM is outside the ',
     -  'periodic cell - it was reset into the cell')
1001  format(' ----- WARNING: Solvent',i8,1x,a,' the cell ',
     -  '(COM=',3f10.5,')')
1002  format(' Maximum difference between solute coordinates on file ',
     -  a,' and the input file (read by the SLTA key)=',f10.5,' A')
1003  format(' ----- WARNING: solute coordinates in file ',a,
     -  ' and the input file differ by',f12.7,' A for solute atom',i6)
1004  format(' ***** ERROR: run will be stopped due to the large ',
     -  'difference between the solute on the file ',a,
     -  ' and  the solute read with the SLTA key',/,7x,'Tolerance ',
     -  'can be loosened by increasing cslttol with the STOL key')
1005  format(' Maximum difference between solute orientation matrix',
     -  ' and the unit matrix=',f10.6)
1006  format(' ***** ERROR: run will be stopped due to the large ',
     -  'difference between the solute orientation matrix and the ',
     -  'unit matrix')
1007  format(' +++++ Solute copy on file ',a,' has been replaced',
     -  ' by the copy read with the SLTA key.',/,' Start ',
     -  ' the program again from the same coordinate file')
1008  format(' +++++ Solute coordinates read with the SLTA key have ',
     -  'been replaced by the copy read from file ',a)
1009  format(' First part of the solute has',
     -  ' different structures in the first and second copies',/,
     -  29x,'Largest deviation=',f10.5,' A')
1010  format(' ***** ERROR: No torsion angle information was read in ',
     -  '- key TORD is needed')
1011  format(6x,' Use CNFG **** **** FXCR to correct the solute',
     -  ' on file ',a, ' or',/,6x,
     -  ' CNFG **** **** FXIN to correct the SLTA input from file ',a)
1012  format(' ***** ERROR: free energy solute molecule is assumed',
     -  ' to be invariant but it is not')
1013  format(' ----- WARNING: free energy solute molecule is ',
     -  ' assumed to be invariant but it is somewhat changing')
1014  format(' ***** ERROR: can not replace input solute with ',
     -  ' this coupling option')
1015  format(' You may want to increase the cell',
     -  ' size or check the integrity of the solute with key FCGA or',
     -  ' on a graphics screen')
1017  format(' ===== STRONG WARNING: solvent',i5,' was reset into the',
     -  ' sphere')
1018  format(' ----- WARNING: COM of solvent',i5,
     -  ' is outside the sphere')
1019  format(' ***** ERROR: atom ',i5,' center of solute molecule',i4,
     -  ' is moved by torsions')
1020  format(' To see the full list, use PRNT ',a4,' or higher')
1021  format(' Number of above threshold deviations=',i6)
1022  format(' ----- WARNING: solute molecule',i5,' was reset into the',
     -  ' cell')
1023  format(' ===== STRONG WARNING: ignoring the difference between ',
     -  ' the two  coordinates is likely to lead to SERIOUS PROBLEMS',/,
     -  ' since there are active torsions')
1024  format(' ----- WARNING: solute atom ',i5,' is outside the ',
     -  'simulation cell:',3f10.5)
1025  format(7x,'Changing TRAJ **** RGFX to TRAJ **** FLEX eliminates ',
     -  'this check.',/,6x,' Make the change if the simulation moved ',
     -  'individual solute molecules or torsions (see keys PARD and ',
     -  'PART)',/,7x,'A safer solution is to repeat the PARD and/or ',
     -  'PART keys used in the original simulation')
1026  format(' ----- WARNING: without permuting the coordinates as ',
     -  'requested by the PXYZ key, ',i5,1x,a,' are outside cell')
1027  format(' ----- WARNING: ',i5,1x,a,' were found ',
     -  'outside the simulation cell/sphere')
1028  format(' Solute a has been reset to the cell')
1029  format(' The free energy solute at lambda=',f8.5,' is displaced ',
     -  'by ',3f10.5,' and rotated by ',/,(3f10.6))
1030  format(' ===== STRONG WARNING: free energy solute molecule',i5,
     -  ' is outside the cell and has not been reset')
1031  format(' ***** ERROR: solute atom ',i5,' is more than one cell ',
     -  'away from the simulation cell:',3f10.4)
1032  format(' ***** ERROR: ',i5,' solute atoms were found ',
     -  'more than one cell away from the simulation cell')
1033  format(' ===== STRONG WARNING: connectivity data from ',
     -  'coordinates read with the CNFG key will be kept')
1034  format(7x,'Consider recentering the system with TEST PBCT ',
     -  'followed by WCNF')
1035  format(a,': the center of the whole solute is',i6,'% away from ',
     -  'the cell center in the ',a,' direction')
1036  format(' ===== STRONG WARNING:',f6.1,'% of the solvent is ',
     -  'outside the simulation cell - check if the PBCN statement is ',
     -  'correct')
1037  format(' csv(',i5,')=',5(3f8.2,2x))
1038  format(' Discrepancy: regular PBC cell #=',i2,
     -  ' general PBC cell #=',i2,' c=',3f10.5)
1039  format(i5,' PBC cell #=',i2,' c=',3f10.5)
7712  format(' FINDOR: nstta=',i6,' crm=',3f10.4,/,(i4,' c=',3f10.4,
     -  ' cslt=',3f10.4,' rlcslt=',3f10.4))
7713  format(' FINDOR: nrep3=',i6,' ixrep3=',3i10)
      end
C@SPLIT1
      subroutine ckortfail(ifail,message,lmessage,islt,islv,nconf,
     -  inperr,iout)
c#    MMC routine  60/a lstmod: 11/27/06
c*****Report failed orientation matrix calculation
      character*(*) message
      character*80 explain
      if (ifail .gt. 0) then
        if (nconf .gt. 0) then
          write (explain(1:28),1000) nconf
          lexplain=28
        else
          explain(1:lmessage)=message(1:lmessage)
          lexplain=lmessage
        end if
        write (iout,1000) explain(1:lexplain)
        if (islt .gt. 0) then
          write (iout,1001) 'solute',islt
        else if (islv .gt. 0) then
          write (iout,1001) 'solvent',islv
        else
          write (iout,1001) 'solute'
        end if
      inperr=inperr+1
      end if
      return
1000  format(' ***** ERROR: orientation matrix calculation failed for ',
     -  a)
1001  format(7x,'Calculaton used ',a,' molecule ',i9)
      end
      subroutine findifmolinc(iop,nstfm0,ifdummy,im,ifinc)
c#    MMC routine  60/b lstmod: 10/05/06
c*****Finds out if molecule start should be decremented
      dimension iop(200),ifdummy(#MW)
      ifinc=0
      if ((iop(30) .eq. 1 .or. iop(30) .eq. 2) .and.
     -    im .le. nstfm0) then
        ifinc=ifdummy(im)
      end if
      return
      end
      subroutine grelcd(cs,csr,icl,natms,istsv)
c#    MMC routine  61 lstmod: 04/21/97
c*****Compute the COM centered coordinates from cs into csr
      dimension cs(3,natms),csr(3,natms),icl(natms),cmcrd(3)
      call cofms(cs,cmcrd,icl,1,natms,istsv,wx)
      do ia=1,natms
        call arrdiff(csr(1,ia),cs(1,ia),cmcrd,3)
      end do
      return
      end
      subroutine getort(c,crm,icl,rlc,n,orient,islv,indexx,ixinc,linear,
     -  icrm,iarep,ix,nliminp,ifail,LEVTEST,iout,mxat)
c#    MMC routine  62 lstmod: 05/29/17
c*****Obtain orientation of a molecule w.r.t. its local representation
      dimension c(3,mxat),crm(3),icl(mxat),rlc(3,mxat),indexx(mxat),
     -  orient(3,3),ix(3)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      dimension b(3,3),relcc(3,3),z(3)
      character*7 stsv
      nlim=nliminp
c      write (6,7691) n,islv,nlim,iout,mxat
c7691  format('GETORT n,islv,nlim,iout,mxat=',5i5)
      stsv=' solute'
      ifail=0
      if (islv .gt. 0) stsv='solvent'
c     ix(1-3) : atoms to use for orientation determination
      if (nlim .eq. 0) then
c       ix and nlim are not determined - do it now
        if (LEVTEST .gt. 1 .and. MYRANK .eq. 0)
     -    write (iout,1000) ixinc,(indexx(i),i=1,n)
        if (n .lt. 0) then
          if (MYRANK .eq. 0) write (iout,1002) n
          call datprt(2)
        end if
        nlim=min0(3,n)
        call get3repats(rlc,mxat,indexx,n,ixinc,ix,nlim)
      end if
      if (LEVTEST .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,1001) n,nlim,ix
      istsv=0
      if (islv .gt. 0) istsv=1
      if (icrm .eq. 0) call cofms(c,crm,icl,1,n,istsv,wx)
      if (iarep .eq. 0) then
        call trnsfr(z,crm,3)
      else
        call trnsfr(z,c(1,iarep),3)
      end if
      do ia=1,nlim
        do k=1,3
          relcc(k,ia)=rlc(k,ix(ia))
          b(k,ia)=c(k,ix(ia))-z(k)
        end do
      end do
      if (LEVTEST .gt. 1 .and. MYRANK .eq. 0) then
        write (iout,1003) 'relcc',((relcc(k,i),k=1,3),i=1,3)
        write (iout,1003) 'b',((b(k,i),k=1,3),i=1,3)
      end if
      call ormat(orient,relcc,b,n,islv,linear,ifail)
      return
1000  format(' GETORT ixinc=',i5,' indexx=',/,(20i6))
1001  format(' GETORT n,nlim=',2i6,' ix=',3i6)
1002  format(' ***** PROGRAM ERROR in GETORT: negative number ',
     -  'of atoms:',i9)
1003  format(' GETORT ',a,'=',3f10.4,2x,3f10.4,2x,3f10.4)
      end
      subroutine getortslt(c,crm,rlcslt,orient,iclslt,nstfa,nstfa1,
     -  nstta,natoms,isltmv,nconf,nwarn,inperr,iout)
c#    MMC routine  62/a lstmod: 08/01/12
c*****Obtain solute rotation matrix using fixed atoms only
      dimension c(3,#NA),crm(3,#MO),rlcslt(3,#ST),
     -  orient(3,3,#MO),iclslt(#ST),isltmv(#ST)
      common /option/ iop(200),idebug(200)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
c     Obtain rotation matrix using fixed atoms only
c     write (iout,*) 'GETORTSLT Start nstfa,nstfa1,nstta,natoms=',
c    -  nstfa,nstfa1,nstta,natoms
      incc=0
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) incc=nstfa
      call trnsfi(l1,iclslt,nstta)
      if (iop(30) .ge. 7) then
        call zeroiti(l1,nstfa1,nstfa)
        nstlook=nstfa1
      else
        nstlook=nstta
      end if
      nfix=0
      do ia=incc+1,nstlook
        if (isltmv(ia) .eq. 0) then
          nfix=nfix+1
          l2(nfix)=ia
        else
          l1(ia)=0
        end if
      end do
      if (nfix .ge. 3) then
        nrepslt3=0
        call getort(c,crm,l1,rlcslt,nfix,orient,0,l2,0,
     -    linear,1,0,l3,nrepslt3,ifail,idebug(29),iout,natoms)
        call ckortfail(ifail,'input configuration',19,0,0,
     -    nconf,inperr,iout)
      else
        call unitmat(orient,3)
      end if
      return
      end
      subroutine get3repats(c,n,indexx,nfix,incr,irepatort,nrepatort)
      dimension c(3,n),indexx(n),irepatort(3)
c#    MMC routine  62/b lstmod: 09/06/16
c      write (6,9891) n,nfix,incr,(indexx(i),i=1,nfix)
c9891  format(' GET3REPATS n,nfix,incr=',3i6,' indexx:',/,(20i6))
      if (nfix .le. 3) then
        do ia=1,nfix
          irepatort(ia)=indexx(ia)-incr
        end do
        nrepatort=nfix
        return
      end if
      rij2max=0.0
      ia1=0
      do ia=2,nfix
        rij2=arrdist(c(1,indexx(1)-incr),c(1,indexx(ia)-incr))
        if (rij2 .gt. rij2max) then
          rij2max=rij2
          ia1=ia
        end if
      end do
      irepatort(1)=indexx(ia1)-incr
      rij2max=0.0
      ia2=0
      do ia=1,nfix
        if (ia .ne. ia1) then
          rij2=arrdist(c(1,indexx(ia1)-incr),c(1,indexx(ia)-incr))
          if (rij2 .gt. rij2max) then
            rij2max=rij2
            ia2=ia
          end if
        end if
      end do
      irepatort(2)=indexx(ia2)-incr
c     atoms ia1 and ia2 form a sort of a diameter
      rij122max=0.0
      ia3=0
      do ia=1,nfix
        if (ia .ne. ia1 .and. ia .ne. ia2) then
          rij21=arrdist(c(1,indexx(ia1)-incr),c(1,indexx(ia)-incr))
          rij22=arrdist(c(1,indexx(ia2)-incr),c(1,indexx(ia)-incr))
          rij122=(rij21+rij22)/(abs(rij21-rij22)+0.1)
          if (rij122 .gt. rij122max) then
            rij122max=rij122
            ia3=ia
          end if
        end if
      end do
      irepatort(3)=indexx(ia3)-incr
      return
      end
      subroutine checkwayout(nmolec,nslv,islvrep,iop5,iout,iverb,
     -   nsltout,nslvout,nwwarn)
c#    MMC routine  63 lstmod: 12/14/15
c*****Check for molecules way out of the box
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /ecell/ cic(3,27),ncell
      dimension cm(3),cmorig(3)
      character*8 lab
      if (iop5 .ge. 5) return
      nsltout=0
      nsltreset=0
      do im=nstfm+1,nsttm
c       Check solute molecules
        iopt=99
        nreset=0
        call trnsfr(cm,c(1,molcnt(im)),3)
        do while (iopt .gt. 1 .and. nreset .lt. 3)
          call pbcnd(cm(1),cm(2),cm(3),iop5,iopt,riijj)
          if (iopt .gt. 1) then
            nreset=nreset+1
            nsltout=nsltout+1
          end if
        end do
        if (iopt .gt. 1) then
          write (iout,1002) 'solute',(c(k,molcnt(im)),k=1,3)
          nwwarn=nwwarn+1
        end if
        if (nreset .gt. 1) then
          nsltreset=nsltreset+1
          if (iverb .gt. 1)
     -      write (iout,1001) 'solute',im,
     -        (c(k,molcnt(im)),k=1,3),' ',molcnt(im)
          call arrdiff(cm,cm,c(1,molcnt(im)),3)
          do ia=ifirstm(im),ilastm(im)
            call arrsum(c(1,ia),cm,c(1,ia),3)
          end do
        end if
      end do
      nslvout=0
      nslvreset=0
      do iw=2,nmolec
c       Check solvent molecules
        iopt=99
        nreset=0
        call trnsfr(cm,c(1,ic00+iw*nslv+islvrep),3)
        call trnsfr(cmorig,cm,3)
        lab='     was'
        do while (iopt .gt. 1 .and. nreset .lt. 3)
          call pbcnd(cm(1),cm(2),cm(3),iop5,iopt,riijj)
          if (iopt .gt. 1) then
            nreset=nreset+1
            nslvout=nslvout+1
            if (iverb .gt. 1)
     -        write (iout,1003) iw,(c(k,ic00+iw*nslv+islvrep),k=1,3),
     -          cm,lab,iopt
            call pbc_shift(c(1,ic01+iw*nslv),1,nslv,cic(1,iopt),iopt,
     -        iop5,crm(1,iw))
            lab='is still'
          end if
        end do
        if (iopt .gt. 1) then
          write (iout,1002) 'solvent',cmorig
          nwwarn=nwwarn+1
        end if
        if (nreset .gt. 1) then
          nslvreset=nslvreset+1
          if (iverb .gt. 1) write (iout,1001) 'solvent',iw,cmorig
        end if
      end do
      if (nsltreset+nslvreset .gt. 0) then
        write (iout,1000) nsltreset,nslvreset
        nwwarn=nwwarn+1
      end if
      return
1000  format(' ===== STRONG WARNING:',i4,' solute and',i5,' solvent ',
     -  'molecules are more than one cell away from the periodic cell'/,
     -  '     They have been reset into the central cell since the PBC',
     -  ' routines treat only near neighbor cells')
1001  format(' ===== STRONG WARNING: ',a,' molecule',i5,' is more than',
     -  ' one cell away from the periodic cell',/,7x,'crep=',3e12.4,a,
     -  'molcnt=',i6)
1002  format(' ===== STRONG WARNING: ',a,' molecule could not be reset',
     -  ' to the simulation cell in 3 shifts - probable PROGRAM ERROR',
     -  /,7x,'crep=',3f10.5)
1003  format(' Solvent',i6,' crep(orig)=',3f8.2,' crep(shifted)=',
     -  3f8.2,1x,a,' outside the PBC cell iopt=',i2)
      end
      subroutine ranpos(iop5,rx)
c#    MMC routine  64 lstmod: 04/27/01
c*****Create a random location in the simulation cell
      real*8 drx
      dimension rx(3),drx(3)
      common /rangen/ xyzlim(3),xyzlm2(3),ixpxo
      iopt=2
      do while (iopt .gt. 1)
        call mmc_random(3,drx)
        do k=1,3
          drxk=drx(k)
          rx(k)=-xyzlim(k)+xyzlm2(k)*drxk
        end do
        iopt=1
        if (iop5 .gt. 0) call pbcnd(rx(1),rx(2),rx(3),iop5,iopt,dist2)
      end do
      return
      end
      subroutine ortslv(c,orient,ifail)
c#    MMC routine  65 lstmod: 01/13/07
c*****Compute the orientation matrix for one water molecule
c     This subroutine is specific for water
c     assumes the molecule in the x-z plane and the x is the HOH bisect.
      dimension c(3,3),orient(3,3)
      do k=1,3
        orient(k,1)=c(k,2)+c(k,3)-2.0*c(k,1)
        orient(k,3)=c(k,2)-c(k,3)
      end do
c     call vprd(orient(1,3),orient(1,1),orient(1,2))
      orient(1,2)=orient(2,3)*orient(3,1)-orient(3,3)*orient(2,1)
      orient(2,2)=orient(3,3)*orient(1,1)-orient(1,3)*orient(3,1)
      orient(3,2)=orient(1,3)*orient(2,1)-orient(2,3)*orient(1,1)
c     call vprd(orient(1,1),orient(1,2),orient(1,3))
      orient(1,3)=orient(2,1)*orient(3,2)-orient(3,1)*orient(2,2)
      orient(2,3)=orient(3,1)*orient(1,2)-orient(1,1)*orient(3,2)
      orient(3,3)=orient(1,1)*orient(2,2)-orient(2,1)*orient(1,2)
      call mnorm(orient,ifail)
      return
      end
      subroutine cofms(csa,rmass,iatno,iatm1,natm,istsv,wmol)
c#    MMC routine  66 lstmod: 07/20/99
c*****Compute center of mass from global atomic coordinates
c     istsv=0: solute; istsv=1: solvent; istsv=2: unknown atomtypes
      dimension csa(3,natm),rmass(3),iatno(natm)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /option/ iop(200),idebug(200)
      rmx=0.
      rmy=0.
      rmz=0.
      wmol=0.
      iatnoi=1
      do i=iatm1,natm
        if (iatno(i) .gt. 0) then
          if (istsv .eq. 0) iatnoi=iatnos(iatno(i),iopslt(i))
          if (istsv .eq. 1) iatnoi=iatno(i)
          wmol=wmol+aw(iatnoi)
          rmx=rmx+aw(iatnoi)*csa(1,i)
          rmy=rmy+aw(iatnoi)*csa(2,i)
          rmz=rmz+aw(iatnoi)*csa(3,i)
        end if
      end do
      if (wmol .eq. 0.0) wmol=1.0
      rmass(1)=rmx/wmol
      rmass(2)=rmy/wmol
      rmass(3)=rmz/wmol
      return
      end
      subroutine ormat(orm,u,v,natoms,islv,linear,ifail)
c#    MMC routine  67 lstmod: 05/13/05
c*****Compute the rotation matrix orm  by solving the following equation
c     3-atom part originally written by P.K. Mehrotra.
c     b=orm.a
c     ++++++++++++++++++++++++++++++++++++++
c     a - coordinates of the molecule before rotation (local system)
c     b - coordinates of the molecule after rotation (global syetm).
c         important - only rotation , no translation.
c     ++++++++++++++++++++++++++++++
c     It is assumed that the coordinates of the molecule are given
c     columnwise, i.e., the coordinates of the atom 1 constitute
c     the first column, coordinates of the atom 2 constitute the
c     the second column, etc.
c     The elements of a and b are preserved.
      dimension u(3,3),v(3,3),orm(3,3),d(3,3),e(3,3)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      character*7 stsv
      ifail=0
      stsv=' solute'
      if (islv .gt. 0) stsv='solvent'
      linear=0
c     Choose the first atom as the origin
      if (natoms .eq. 1) then
        call unitmat(orm,3)
        return
      end if
c     Generate three specific orthogonal vectors in lab frame
      if (natoms .gt. 2) then
        do i=2,3
          call arrdiff(d(1,i),u(1,i),u,3)
          call arrdiff(e(1,i),v(1,i),v,3)
          ds=sclprd(d(1,i),d(1,i))
          if (ds .le. 1.e-10) then
            if (MYRANK .eq. 0) write (iout,1001) stsv,i,stsv
            nwwarn=nwwarn+1
            go to 100
          end if
        end do
        call vprod(d,2,3,1)
        call vprod(d,1,2,3)
        call vprod(e,2,3,1)
        call vprod(e,1,2,3)
c       Check for colinearity of the atoms
        ds=sclprd(d(1,1),d(1,1))
      else
        ds=1.0
      end if
100   if (ds .le. 1.e-10 .or. natoms .lt. 3) then
c       Switch to two-atom algorithm
        if (natoms .gt. 2) then
          if (islv .lt. 2) then
            if (MYRANK .eq. 0) write (iout,1000) stsv
            nwarn=nwarn+1
          end if
          linear=1
        end if
c       Diatomic
        ds=0.0
        do k=1,3
          d(k,1)=u(k,2)-u(k,1)
          ds=ds+abs(d(k,1))
          e(k,1)=v(k,2)-v(k,1)
          d(k,2)=0.0
          e(k,2)=0.0
        end do
c       Create the second vector as perpendicular to the bond
c       If the two atoms coincide, generate unit matrix
        if (ds .le. 1.e-6) then
          if (MYRANK .eq. 0) write (iout,1002) stsv
          nwarn=nwarn+1
          call unitmat(orm,3)
          return
        else
          do k=1,3
            if (abs(d(k,1)) .lt. 1.e-7) then
c             Zero component found
              d(k,2)=1.0
              go to 23
            end if
          end do
c         No zero component
          d(2,2)=1.0
          d(3,2)=-d(2,1)/d(3,1)
23        call vprod(d,1,2,3)
          do k=1,3
            if (abs(e(k,1)) .lt. 1.e-7) then
c             Zero component found
              e(k,2)=1.0
              go to 26
            end if
          end do
c         No zero component
          e(2,2)=1.0
          e(3,2)=-e(2,1)/e(3,1)
26        call vprod(e,1,2,3)
        end if
      end if
      call mnorm(d,ifaild)
      call mnorm(e,ifaile)
      ifail=ifaild+ifaile
c     Now, d=orm*e, thus orm=d*inv(e) and
c     The inverse of an orthonormal matrix is its transpose
      do i=1,3
        do j=1,3
          sum=0.0
          do k=1,3
            sum=sum+e(i,k)*d(j,k)
          end do
          orm(i,j)=sum
        end do
      end do
      return
1000  format(' ----- WARNING: the first three ',a7,' atoms are on',
     -  ' the same line - two-atom algorithm will be used',/,
     -  22x,'Check if solute atoms should be rearranged')
1001  format(' ===== STRONG WARNING: ',a7,' atom ',i1,' is identical ',
     -  'with the first ',a,' atom - two-atom algorithm will be used')
1002  format(' ----- WARNING: the two atoms of a diatomic ',a7,
     -  ' coincide - unit matrix will be used as orientation matrix')
      end
      subroutine trnsfi(l,m,n)
c#    MMC routine  68 lstmod: 02/08/92
c*****Fast array transfer for integers
      dimension l(n),m(n)
      do i=1,n
        l(i)=m(i)
      end do
      return
      end
      subroutine trnsfrd(l,m,n)
c#    MMC routine  69 lstmod: 02/08/92
c*****Fast array transfer for real*8
      real*8 l,m
      dimension l(n),m(n)
      do i=1,n
        l(i)=m(i)
      end do
      return
      end
      subroutine trnsfrdr(d,r,n)
c#    MMC routine  69/b lstmod: 04/26/11
c*****Array transfer from real*4 to real*8
      real*8 d
      dimension r(n),d(n)
      do i=1,n
        d(i)=r(i)
      end do
      return
      end
      subroutine trnsfrrd(r,d,n)
c#    MMC routine  69/a lstmod: 08/07/06
c*****Array transfer from real*8 to real*4
      real*8 d
      dimension r(n),d(n)
      do i=1,n
        r(i)=d(i)
      end do
      return
      end
      subroutine dividedr(r,dnum,denom,n)
c#    MMC routine  70 lstmod: 08/10/99
c*****Ratio of two real*8 arrays into a real*4
      real*8 dnum,denom
      dimension dnum(n),denom(n),r(n)
      do i=1,n
        if (denom(i) .ne. 0.d0) r(i)=dnum(i)/denom(i)
        if (denom(i) .eq. 0.d0) r(i)=0.d0
      end do
      return
      end
      subroutine trnsfr(a,b,n)
c#    MMC routine  71 lstmod: 08/13/92
c*****Fast array transfer for reals
      dimension a(n),b(n)
      do i=1,n
        a(i)=b(i)
      end do
      return
      end
      function sclprd(a,b)
c#    MMC routine  72 lstmod: 03/29/00
c*****Computes the scalar product of two vectors
      dimension a(3),b(3)
      sclprd=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      return
      end
      function dsclprd(a,b)
c#    MMC routine  73 lstmod: 11/27/00
c*****Computes the scalar product of two vectors
      real*8 a,b,dsclprd
      dimension a(3),b(3)
      dsclprd=a(1)*b(1)+a(2)*b(2)+a(3)*b(3)
      return
      end
      subroutine vprd(a,b,c)
c#    MMC routine  74 lstmod: 02/06/86
c*****Computes the vector product a x b and saves it into c
      dimension a(3),b(3),c(3)
      c(1)=a(2)*b(3)-b(2)*a(3)
      c(2)=a(3)*b(1)-b(3)*a(1)
      c(3)=a(1)*b(2)-b(1)*a(2)
      return
      end
      subroutine dvprd(a,b,c)
c#    MMC routine  75  lstmod: 11/13/90
c*****Computes the vector product a x b and saves it into c
      real*8 a,b,c
      dimension a(3),b(3),c(3)
      c(1)=a(2)*b(3)-b(2)*a(3)
      c(2)=a(3)*b(1)-b(3)*a(1)
      c(3)=a(1)*b(2)-b(1)*a(2)
      return
      end
      subroutine vprod(r,ii,jj,kk)
c#    MMC routine  76 lstmod: 02/06/86
c*****Computes the vector product of the columns i and j into k
      dimension r(3,3)
      r(1,kk)=r(2,ii)*r(3,jj)-r(2,jj)*r(3,ii)
      r(2,kk)=r(3,ii)*r(1,jj)-r(3,jj)*r(1,ii)
      r(3,kk)=r(1,ii)*r(2,jj)-r(1,jj)*r(2,ii)
      return
      end
      subroutine dvprod(r,ii,jj,kk)
c#    MMC routine  77 lstmod: 08/27/95
c*****Computes the vector product of the columns i and j into k
      real*8 r
      dimension r(3,3)
      r(1,kk)=r(2,ii)*r(3,jj)-r(2,jj)*r(3,ii)
      r(2,kk)=r(3,ii)*r(1,jj)-r(3,jj)*r(1,ii)
      r(3,kk)=r(1,ii)*r(2,jj)-r(1,jj)*r(2,ii)
      return
      end
      subroutine mnorm(r,ifail)
c#    MMC routine  78 lstmod: 05/13/05
c*****Normalizes the matrix r
      dimension r(3,3)
      ifail=0
      do i=1,3
        rr=0.0
        do k=1,3
          rr=rr+r(k,i)**2
        end do
        rr=sqrt(rr)
        if (rr .eq. 0.0) then
          ifail=1
        else
          do k=1,3
            r(k,i)=r(k,i)/rr
          end do
        end if
      end do
      return
      end
      subroutine anorm(r,n)
c#    MMC routine  79 lstmod:  02/26/04
c*****Normalizes the array r
      dimension r(n)
      rr=0.0
      do k=1,n
        rr=rr+r(k)**2
      end do
      rr=sqrt(rr)
      do k=1,n
        r(k)=r(k)/rr
      end do
      return
      end
      subroutine dnorm(r,n)
c#    MMC routine  79/a lstmod:  03/27/12
c*****Normalizes the array r
      real*8 r(n),rr
      rr=0.d0
      do k=1,n
        rr=rr+r(k)**2
      end do
      rr=dsqrt(rr)
      do k=1,n
        r(k)=r(k)/rr
      end do
      return
      end
      subroutine matprod(a,b,c)
c#    MMC routine  79/a lstmod:  06/01/07
c*****C = A * B
      dimension a(3,3),b(3,3),c(3,3)
      do i=1,3
        do j=1,3
          rr=0.0
          do k=1,3
            rr=rr+a(i,k)*b(k,j)
          end do
          c(i,j)=rr
        end do
      end do
      return
      end
      subroutine drandm(dran)
c#    MMC routine  81 lstmod: 05/02/01
c*****64-bit integer arithmetic on 32-bit words.
c     Each integer is stored in 4 parts : ix=ix0+ix1*2**16+ix2*2**32+
c     ix3*2**48. ia and ib are analogous.
      real*8 rstack,rix0,rix1,rix2,rix3,ria0,ria1,ria2,ria3,
     -  rib0,rib1,rib2,rib3,dran
      common /seed/ rstack(64),rix0,rix1,rix2,rix3,ria0,ria1,ria2,ria3,
     -  rib0,rib1,rib2,rib3,ixo,ixmt,nseedread,irng
      real*8 d16,di16,di32,di48,di64
      common /rancon/ d16,di16,di32,di48,di64
      real*8 rs0,rs16,rs32,rs48
      rs0=rix0*ria0+rib0
      rs16=rix1*ria0+rix0*ria1+rib1
      rs32=rix2*ria0+rix0*ria2+rix1*ria1+rib2
      rs48=rix3*ria0+rix0*ria3+rix2*ria1+rix1*ria2+rib3
      iq=rs0/d16
      rs16=rs16+iq
      rix0=rs0-iq*d16
      iq=rs16/d16
      rs32=rs32+iq
      rix1=rs16-iq*d16
      iq=rs32/d16
      rs48=rs48+iq
      rix2=rs32-iq*d16
      iq=rs48/d16
      rix3=rs48-iq*d16
      dran=rix3*di16+rix2*di32+rix1*di48+rix0*di64
      return
      end
      subroutine mmc_random(n,drno)
c#    MMC routine  82 lstmod: 05/29/17
c*****Random number generator using scrambler technique to reduce
c     correlation. Indices are generated by randk of Forsityhe.
c     (iy=ixo*314159269+453806245)
c     Works for minimum 32-bit machine
      real*8 rstack,rix,rira,rirb,drno
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
      character*80 rngfile
      common /rnglist/ rnolist(#RN),nrand,irand,lrngfile,rngfile
      common /lcg_const/ lcg_fac,lcg_add,lcg_seed,lcg_modexp,lcg_mod,i31
      common /rangen/ xyzlim(3),xyzlm2(3),ixpxo
      dimension drno(n)
      integer grnd
      if (irng .eq. 0) then
c       Original RNG used in MMC
        do i=1,n
c         Use the mod 2^15 part of the  Forsythe constants for scrambling
          iy=ixo*12453+2213
          iy=mod(iy,32768)
          ind=iy/512+1
          drno(i)=rstack(ind)
          call drandm(rstack(ind))
          ixo=iy
        end do
      else if (irng .eq. 1) then
c       LCG
        do i=1,n
          iy=lcg_seed*lcg_fac+lcg_add
          if (iy .lt. 0) iy=-iy
          if (lcg_modexp .lt. 31) then
            iy=mod(iy,lcg_mod)
            drno(i)=float(iy)/float(lcg_mod)
          else
            drno(i)=-float(iy)/float(lcg_mod)
          end if
          lcg_seed=iy
        end do
      else if (irng .eq. 2) then
c       Mersenne twister
        do i=1,n
          iy=grnd()
          if (iy .lt. 0) iy=-iy
          drno(i)=-float(iy)/float(i31)
          if (drno(i) .ge. 1.d0) drno(i)=0.9999999
        end do
      else
c       Input list
        if (irand+n-1 .gt. nrand) then
c         List exhausted, reset pointer
          if (irng .eq. 3) then
c           Shuffle the random number list
            left=nrand
            is0=1
            do while (left .gt. 1)
              iy=ixpxo*314159269+453806245
c             Eliminate bits over 31
              iy=ibclr(iy,31)
              rno=float(iy)/2.1474836E+09
              ixpxo=iy
              is1=is0+rno*left
              if (is1 .gt. nrand) is1=nrand
c             Swap is0-th and is1-th elements of rnolist
              rnx=rnolist(is0)
              rnolist(is0)=rnolist(is1)
              rnolist(is1)=rnx
              is0=is0+1
              left=left-1
            end do
          end if
          irand=1
c         write (77,8791) (rnolist(i),i=1,nrand)
c8791     format(/,' RNOLIST:',/,(10f8.5))
        end if
        do i=1,n
          drno(i)=rnolist(irand)
          if (drno(i) .ge. 1.d0) drno(i)=0.9999999
          irand=irand+1
        end do
      end if
      return
      end
      subroutine ranini(iout,iparalleldiff,ireset,iverb)
c#    MMC routine  83 lstmod: 04/30/16
c*****Initialize random number generator
      real*8 rstack,rix,rira,rirb
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
      character*80 rngfile
      common /rnglist/ rnolist(#RN),nrand,irand,lrngfile,rngfile
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      real*8 rix0,rix1
      dimension rix0(4),rix1(4)
      data ixo0/1357/
      data rix0/3830.d0,30779.d0,55730.d0,639.d0/
      if (irng .eq. 0) then
c       Original MMC RNG
c       Fill up stack for scrambling
        if (ireset .eq. 1) then
c         (Re)Set the random number seeds to the built-in values
          ixo=ixo0
          call trnsfrd(rix,rix0,4)
        end if
        if (iparalleldiff .gt. 0) then
c         Set different seeds for each CPU
          do i=1,4
            rix(i)=rix(i)+(MYRANK)
          end do
        end if
        do i=1,64
          call drandm(rstack(i))
        end do
        if (iverb .gt. 0 .and. iverb .le. 2) then
          if (MYRANK+iparalleldiff .eq. 0) then
             write (iout,1000) rix,ixo
          else if (MYRANK .eq. 0) then
            do icpu=1,NUMNOD
              do i=1,4
                rix1(i)=rix0(i)+(icpu-1)
              end do
              write (iout,1000) rix1,ixo,' ',icpu-1
            end do
          end if
        end if
      else if (irng .eq. 2) then
c       Mersenne twister
        call sgrnd(ixmt)
      else
c       Reset random number stream
        irand=1
      end if
      return
1000  format(' Random seed set to ',f7.0,'*2^48 + ',f7.0,'*2^32 + ',
     -  f7.0,'*2^16 + ',f7.0,' Scrambler seed=',i10,a,'CPU#=',i3)
      end
C@DM      subroutine mpi_rangather_scatter(idir,iout,idbg,label)
C@DMc#    MMC routine  83/a lstmod: 08/13/08
C@DM      character*4 label
C@DMc*****Gather (idir=1) / scatter (idir=2) random number generator state
C@DM      real*8 rstack,rix,rira,rirb
C@DM      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
C@DM     -  nseedread,irng
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      real*8 rstack_mpi,rix_mpi
C@DM      common /MPI_RN/ rstack_mpi(64,64),rix_mpi(4,64),ixo_mpi(64)
C@DM      if (idbg .gt. 3) then
C@DM        if (MYRANK .eq. 0) then
C@DM          write (iout,1001) label,((rix_mpi(k,i),k=1,4),i=1,NUMNOD)
C@DM        else
C@DM          write (iout,1000) 'BEFORE',label,idir,MYRANK,rix
C@DM        end if
C@DM      end if
C@DM      if (idir .eq. 1) then
C@DMc       Gather
C@DM        call MPI_gather(rstack,64,MPI_DOUBLE_PRECISION,rstack_mpi,64,
C@DM     -    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr1)
C@DM        call MPI_gather(rix,4,MPI_DOUBLE_PRECISION,rix_mpi,4,
C@DM     -    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr2)
C@DM        call MPI_gather(ixo,1,MPI_INTEGER,ixo_mpi,1,
C@DM     -    MPI_INTEGER,0,MPI_COMM_WORLD,ierr3)
C@DM      else
C@DMc       Scatter
C@DM        call MPI_scatter(rstack_mpi,64,MPI_DOUBLE_PRECISION,rstack,64,
C@DM     -    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr1)
C@DM        call MPI_scatter(rix_mpi,4,MPI_DOUBLE_PRECISION,rix,4,
C@DM     -    MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,ierr2)
C@DM        call MPI_scatter(ixo_mpi,1,MPI_INTEGER,ixo,1,
C@DM     -    MPI_INTEGER,0,MPI_COMM_WORLD,ierr3)
C@DM      end if
C@DM      if (idbg .gt. 3) then
C@DM        if (MYRANK .eq. 0) then
C@DM          write (iout,1001) label,((rix_mpi(k,i),k=1,4),i=1,NUMNOD)
C@DM        else
C@DM          write (iout,1000) 'AFTER ',label,idir,MYRANK,rix
C@DM        end if
C@DM      end if
C@DM      call MPI_Allreduce(ierr1,ierr1sum,1,MPI_INTEGER,MPI_SUM,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      call MPI_Allreduce(ierr2,ierr2sum,1,MPI_INTEGER,MPI_SUM,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      call MPI_Allreduce(ierr3,ierr3sum,1,MPI_INTEGER,MPI_SUM,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      if (ierr1sum+ierr2sum+ierr3sum .gt. 0) then
C@DM        if (MYRANK .eq. 0) write (iout,2000) ierr1sum,ierr2sum,ierr3sum
C@DM        call datprt(2)
C@DM      end if
C@DM      return
C@DM1000  format(1x,a,1x,a,' mpi_rgs idir=',i1,' MYRANK=',i2,/,
C@DM     -  ' rix=',4f10.1)
C@DM1001  format(1x,a,/,(' rix_mpi=',4f10.1))
C@DM2000  format(' ***** ERROR in gather/scatter ierr1,2,3=',3i4)
C@DM      end
      subroutine sgrnd(seed)
      implicit integer(a-z)
* Period parameters
      parameter(N     =  624)
      dimension mt(0:N-1)
*                     the array for the state vector
      common /block/mti,mt
      save   /block/
*      setting initial seeds to mt[N] using
*      the generator Line 25 of Table 1 in
*      [KNUTH 1981, The Art of Computer Programming
*         Vol. 2 (2nd Ed.), pp102]
      mt(0)= iand(seed,-1)
      do 1000 mti=1,N-1
        mt(mti) = iand(69069 * mt(mti-1),-1)
 1000 continue
      return
      end
      integer function grnd()
      implicit integer(a-z)
* Period parameters
      parameter(N     =  624)
      parameter(N1    =  N+1)
      parameter(M     =  397)
      parameter(MATA  = -1727483681)
*                                    constant vector a
      parameter(UMASK = -2147483648)
*                                    most significant w-r bits
      parameter(LMASK =  2147483647)
*                                    least significant r bits
* Tempering parameters
      parameter(TMASKB= -1658038656)
      parameter(TMASKC= -272236544)
      dimension mt(0:N-1)
*                     the array for the state vector
      common /block/mti,mt
      save   /block/
      data   mti/N1/
*                     mti==N+1 means mt[N] is not initialized
      dimension mag01(0:1)
      data mag01/0, MATA/
      save mag01
*                        mag01(x) = x * MATA for x=0,1
      TSHFTU(y)=ishft(y,-11)
      TSHFTS(y)=ishft(y,7)
      TSHFTT(y)=ishft(y,15)
      TSHFTL(y)=ishft(y,-18)
      if(mti.ge.N) then
*                       generate N words at one time
        if(mti.eq.N+1) then
*                            if sgrnd() has not been called,
          call sgrnd(4357)
*                              a default initial seed is used
        endif
        do 1000 kk=0,N-M-1
            y=ior(iand(mt(kk),UMASK),iand(mt(kk+1),LMASK))
            mt(kk)=ieor(ieor(mt(kk+M),ishft(y,-1)),mag01(iand(y,1)))
 1000   continue
        do 1100 kk=N-M,N-2
            y=ior(iand(mt(kk),UMASK),iand(mt(kk+1),LMASK))
            mt(kk)=ieor(ieor(mt(kk+(M-N)),ishft(y,-1)),mag01(iand(y,1)))
 1100   continue
        y=ior(iand(mt(N-1),UMASK),iand(mt(0),LMASK))
        mt(N-1)=ieor(ieor(mt(M-1),ishft(y,-1)),mag01(iand(y,1)))
        mti = 0
      endif
      y=mt(mti)
      mti=mti+1
      y=ieor(y,TSHFTU(y))
      y=ieor(y,iand(TSHFTS(y),TMASKB))
      y=ieor(y,iand(TSHFTT(y),TMASKC))
      y=ieor(y,TSHFTL(y))
      grnd=y
      return
      end
      subroutine compoptcheck(mcpx,cmoddater,moddater,ncompoptr,
     -  icompoptr,nasizer,iasizer,ckpf,lckpf)
c#    MMC routine  84 lstmod: 03/13/09
c*****Check compilation options of a checkpoint file
      character*10 cmoddater,moddater
      character*80 ckpf
      dimension icompoptr(ncompoptr),iasizer(70)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate,cmoddateref
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      character*80 filename
      ifail=0
      if (moddater .ne. moddate) then
        write (iout,1005) moddater,ckpf(1:lckpf),moddate
        nwarn=nwarn+1
      end if
      cmoddateref=cmoddate
      if (mcpx .eq. 2) cmoddateref=cpxmoddate
      if (cmoddater .ne. cmoddateref) then
        write (iout,1000) cmoddater,ckpf(1:lckpf),cmoddate
        nwwarn=nwwarn+1
      end if
      if (nasizer .ne. nasize) then
        write (iout,1001) 'dimension parameters',
     -    ckpf(1:lckpf),nasizer,nasize
        nwwarn=nwwarn+1
      end if
      if (ncompoptr .ne. ncompopt) then
        write (iout,1001) 'compilation options',
     -    ckpf(1:lckpf),ncompoptr,ncompopt
        nwwarn=nwwarn+1
      end if
      do i=1,ncompopt
        if (icompoptr(i) .ne. icompopt(i)) then
          write (iout,1003) optname(i),ckpf(1:lckpf)
          ifail=1
         end if
      end do
      do i=1,nasize
        if (iasizer(i) .ne. iasize(i) .and. sizesym(i) .ne. 'W2') then
          write (iout,1004) sizename(i),iasizer(i),ckpf(1:lckpf),
     -      iasize(i)
          ifail=1
         end if
      end do
      if (ifail .gt. 0) then
        write (iout,1002)
        call savecompopt(filename,0,icompoptr,ncompopt,iasizer,nasize,
     -    nwarn,iout)
        if (idebug(47) .eq. 0) call datprt(2)
      end if
      return
1000  format(' ===== STRONG WARNING: Common block modification date ',
     -  a10,' on the checkpoint file ',a,/,7x,'disagrees with current',
     -  ' program versions date: ',a10)
1001  format(' ===== STRONG WARNING: Number of ',a,' on the ',a,
     -  ' checkpoint file=',i3,/,7x,'disagrees with the number ',
     -  'in the current program version=',i3)
1002  format(' A version corresponding to the checkpoint file can be ',
     -  'recreated using the data statements generated here in pre.f')
1003  format(' ***** ERROR: Compilation option C@',a2,' is set ',
     -  'differently on the checkpoint file ',a,/,
     -  7x,'and in the current program version')
1004  format(' ***** ERROR: Size parameter ',a,' is set to',i8,' on ',
     -  'the  checkpoint file ',a,/,
     -  7x,'and to',i8,' in the current program version')
1005  format(' ----- WARNING: Program version date ',a10,' on the ',
     -  'checkpoint file ',a,/,
     -  7x,'disagrees with current program versions date: ',a10)
      end
      subroutine crstr(iokslave)
c#    MMC routine  85 lstmod: 05/07/20
c*****Restore all the common blocks except the proximity analysis data
C@I2      integer*2 n47
      real*8 d2,d8,d9,d13,d14,d15,d17,d19,d23e,d23f,d23t,d24,d25,d26,
     -  d28,d47,d48,d51,d53,d54,d64,d71,d92,d101,d102,d103,d104,d105,
     -  d106,d107,d108,d109,d111,d113, d115,d116,d117,d118,d119,d120,
     -  d121,d122,d123,d130,d132,d133,d134,
C@FG     -  d137,d138,d139,d140,d141,
C@DM     -  d142,
     -  d143,d145,d146,d152,d154,d158,d161,d162,d163,d164,d165,d166,
     -  d170
      dimension icompoptr(40),iasizer(70)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*2 optname,sizesym
      character*4 c19,c100,c124,c126,c174
      character*6 c20,c127,c128
      character*8 c125
      character*10 cmoddater,moddater,sizename,moddate,cmoddate,
     -  cpxmoddate
      character*25 optlname
      character*38 sizelname
      character*80 c129,c163
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /slfttolerance/ x103(10,3)
      character*80 file,filenames,filename1,filenameh
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /ctotal/ x1(3,#NA),x4(9,#MO)
      common /mine/ d170(2),x171(2,3,#NE),n142(6)
      common /seed/ d25(76),n1(4)
      common /rangen/ x145(6),n125
      common /rnglist/ x185(#RN),n163(3),c163
      common /lcg_const/ n164(6)
      common /param/ x7(36),n2(10)
      character*80 ident
      common /title/ n160,ident(2)
      common /wadaptf/ x135(9),n115(9)
      common /isoeng/ x136(7)
      common /sreal/ d2(143),d92(8,#MM),d119(#GR),x81(#GR),x2(10)
      common /anneal/ d145(5),n145(6),x175(104)
      common /anneal_cp/ n165(505),x187(1002)
      common /inout/ d158(4)
      common /tdstate/ x52(5)
      common /svint/ n3(444)
      common /pmfinf/ x83(34),x84(3,#MA),n99(9)
      common /hstory/ x60(2750),n29(504),filenameh
      common /freeen/ d47(8),x47(33),n78(#GR),n39(5)
      common /solvnt/ x14(4,#SV),x44,n4(10),n103(2,#ND),n5(#SV)
      common /solute/ x5(3,#ST),x43(#GR),n22(2,#ST),n8(49),
     -  n9(#SV),n45(8,#ST),n32(3,#GR),n71(#ST),n95(6,#MM),
     -  n74(#UU)
      common /overlay/ x182(3,#ST),x183,n156(#ST),n157(4)
      common /solutelab/ c124(2,#ST),c126(#SV),c100,
     -  c127(#ST),c128(#SV),c125(#ST)
      common /clone/ n104,n105(4,10),n108(#TR),n106(2,#ST)
      common /dploy/ x6(3,#SV),x114(#TR),x82(3,#ST),
     -  x66(7,#MM),x20(75),n102(2,#MM),n6(43)
      common /shuffl/ n33(3),n7(#MO),n109(2,#MM)
      common /eftslvsum/ d23e(#MO),d23f(3,#MO),d23t(3,#MO),
     -  d24(3),x94(16,#MO)
      common /slvenergy/ d9,x9(8,#MO)
      common /fieldenergy/ d8,d113(#MM),x167(#MO),
     -  x93(2,#ST)
      common /parensts/ d106(#MM),d116(#TR)
      common /parenst/ d115(4,#ST),d117(2,#TR),d118
      common /polr/ x10(3,#MO),x56(9,#MM),x57(3,#MO),x58(4)
      common /distances/ n140,n15(6,#MO),x79(5,#MO),x153(2,#MS)
      common /stow/ x181(5),n154(2)
      common /rdial/ d13(2,500),d14,x11(2),n14(10)
      common /quasi/ d15(1170),x12(18),x172(#SV),n10(3,#MO),n11(2)
      common /ecell/ x13(81),n69
      common /option/ iop(200),idebug(200)
      common /relcd/ x15(3,#ST),x16(3,#SV)
      common /prefsmv/ d17,d121(#PS),x73(#PG),x18(#MO),x17(23),
     -  n16(2),n91(#PS),n87(#MO)
      common /prefsid/ d120(2),d122(2,#PS),x88(#PG),x89(#MO),
     -  x90(#PP),x87(22),n153(3),n92(2,#PS),n88(#MO),n89(#PP)
      common /fblam/ x74(#PG),x75(18),n46
      common /allpfdat/ x29(#AT,44)
      common /qljdat/ x45(33)
      common /epssig/ x85(2,#SV),x86(4,#ST),n162
      common /trqij/ x59(9),n72(5)
      common /force/ d19(15),x19(9),x30(6,#MO)
      common /cage/ x21(3,#MO),x22(3)
      common /cntrl/ d26(8,#MI),x26(2,#MI),n18(3)
      common /quantm/ d28(9),n24
      common /atmdat/ x31(99,2),c19(99),n19(2,99),
     -  n20(2,#AT,11),c20(#AT,11)
      common /cqpen/ x32(#TN,#VN),x33(#TN,#VE),x34(#TE,#VN),
     -  x35(4,#TE,#VE),n21(5)
      common /qpnabc/ x38(3,#TE),x39(3,#VE)
      common /cvdw/ x36(#TN,#VN),x37(2)
      common /dispar/ x40(8)
      common /caccpt/ d111(50),d107(#TR),d108(#LT),d109(#MM),
     -  x108(#TR),x156(#LT),n57(52),n23(2,#MO),n58(412),
     -  n63(8,#MM),n64(2,#TR),n136(2,#LT),n155(4,#ST)
      common /cpldst/ d48(4),d53(9,#WG),x53(6,#WG),
     -  n25(3,#WG),n31(#WI)
      common /wcpl/ d54(#WG),x49(6),n26(10)
      common /sweep/ n59(6),n60(2,#WI)
      common /nstopt/ n30(24),n27(6,#WI),x50(2,#WS),n28(#WS)
      common /esltcn/ n61(#SV),x61(7,#ST),x72(2)
      common /bitmaps/ n36(2,#UV),n37(3,64),n65(4)
C@NN      common /nneigtv/ n35(#VW,#MO),x62(3,#MO),x63(3),n38(3)
C@TN      common /nneigtu/ n66(#UW,#ST),n70(2)
      common /intslt/ n34(5),n80(#TL),n81(5,#GR),n82(#ST)
      common /ovlrat/ x65(3),n76(2,#OR)
      common /pbccns/ x67(33),n41(1)
      common /oldedge/ x177(3),n152
      common /cutinr/ x68(2)
      common /genslv/ x69(3,#GV,#GV),x70(3,#GT,#GV),n42(#GV)
      common /sltslt/ x112(4,#UU,#UU)
      common /psltdv/ d71(9,#DT,#SV),n43,n44(2,#DM)
      common /grid/ d123(3),x76(16),
     -  n47(#CV),n90(#PP),n48(#GX,#GY,#GZ),n49(17)
      common /outsideden/ x55(6),n17(2),n111(#MO)
      common /limgrid/ x137(9),n116(4),n117(#MO)
      common /cavdat/ x77(16),x110(#ST),n137
      common /cavprb/ n51(3,#MO),n50(7)
      common /cdhdan/ d64(5,#TR),d152(#TD,#TR),x78(9,#TR),x80(11),
     -  n52(12),n56(#ST),n53(14,#TR),n112(2,#TL),
     -  n54(#TA),n118(#TD,#TR)
      common /nrmfac/ d51(3,#WI),n55
      common /frind1/ d101(7)
      common /frind2/ x101(2)
      common /frind3/ x102(12,#MO)
      common /frind4/ d103(6)
      common /frind5/ d104(30)
      common /frind6/ x106(10)
      common /frind7/ x107(3,#MI),d105(3)
      common /sltnnl/ n62(#NL,#ST),n62a(5,#ST)
      common /pfuse/ n79(29),c129(9)
      common /newtor/ n93(4,#MM),n94(15,#ST),n98(4,#TR),
     -  x91(20,#ST),n73(1)
      common /toreng/ n96(19,#TR),x128(9,#TR),x129(3,#TA)
      common /fieldpot/ n100(24),x109(20)
      common /bondmod/ n107(1004)
      common /tpn/ x46(131),n133(4)
      common /virtvolcha/ d162(3),x163(11)
      common /tuneb/ d130(4),n113(9),x131(9)
      common /steptune/ d163(24),d164(20,#MM),d165(4,#TR),
     -  d166(4,#LT),x166(8),n141(20),n147(4,#MM)
      common /torauc/ n150(3),n151(#AU),x180(2),x179(2,#AU,#TR)
      common /stepscale/ x186(18)
      common /control/ d161(8)
      common /widom/ d132(2,#GX,#MW),d133(3,#GX),d134(4,#MW),x159(7),
     -  x160(2,#MW),x133(2,#GX,#MW),x134(#MW),n114(2,#MW),n120(334)
      common /hunginfo/ x149(9,#MH),x176(3,#MO),x150(2),n132(4)
      common /fieldgrad/
C@FG     -  d137(6,#MG,#GQ),d138(6,#MG,#GQ),
C@FG     -  d139(2,6,#MM,#GQ),d140(6,#MM),d141(6,#MG),n119(#MO),
     -  x95(8)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ n83a(6,64),n83c(64),n83d(64),n83c3(64),
C@DM     -  n83d3(64),n85(#MO),n86(2,#GR)
C@DM      common /MPI_RN/ d142(68,64),n84(64)
      common /reactionfield/ x142(2)
      common /loopmove/ d146(2),n121(2,#TR),n122(11,#LT),x144(8),
     -  n124(308)
      common /loopdat/ d143(28,#LT)
      common /primhydsh/ d154(3),x146(8),x147(2,#MS),x148(2000),
     -  n130(2000),n128(48),n129(#ST),n135(2,#MS)
      common /dijdiff/ n127(2,20)
      common /nonboltz/ d102(8),x151(7)
      common /fixdeverr/ n126(8)
      common /howfar/ x155(#MI,4),n134(2)
      common /liga/ n138(2)
      common /pretrans/ x157(12),n139
C@DD      common /mehler_ddd/ x168(309),n146
      common /desolv_hbond_arr/ x173(3,#ST),n143(4,#ST)
      common /desolv_hbond_const/ n144(250),x174(325),c174(20)
      common /constraint/ n148(2),n149(3,100),x178(3,100)
      common /rppxrad/ rppxrad2(#ST),n158(#ST),n159(201)
      common /grid_split/ n161(3,#ST),x184(18)
      if (MYRANK .gt. 0 .and. iokslave .eq. 0) then
        write (iout,*) 'CRSTR called from MYRANK=',MYRANK
        return
      end if
      iok=0
      filename1=filenames(1)
      lenfile1=namlens(1)
      ichkp0=ichkp
      rewind ichkp
      read (ichkp,end=111,err=111)
     -  ident,x1,d2,x2, x4,x5,x6,x7,d8,d9,x9,x10,x11,x12,x13,d13,d14,
     -  x14,x15,d15,x16,d17,x17,x18,d19,x19,x20,x21,x22,d23e,d23f,
     -  d23t,d24,d25,x26,d26, d28,x29,x30,x31,x32,x33,x34,x35,x36,
     -  x37,x38,x39,x40, x43,x44,x45,x46,d47,x47,d48,x49,x50,
     -  d51,x52,d53,x53,d54,x55,x56,x57,x58,x59,x60,x61,
C@NN     -  x62,x63,
     -  d64,x65,x66,x67,x68,x69,x70,d71,x72,x73,x74,x75,x76,x77,x78,
     -  x79,x80,x81,x82,x83,x84,x85,x86,x87,x88,x89,x90,x91,d92,x93,
     -  x94,x95,c100,d101,d102,d103,d104,d105,d106,d107,d108,d109,x101,
     -  x102,x103,x106,x107,x108,x109,x110,d111,x112,d113,x114,
     -  d115,d116,d117,d118,d119,d120,d121,d122,d123,c124,c125,c126,
     -  c127,c128,c129,x128,x129,d130,x131,d132,d133,d134,x133,x134,
     -  x135,x136,x137,
C@FG     -  d137,d138,d139,d140,d141,
C@DM     -  d142,
     -    x142,d143,x144,x145,d145,d146,x146,x147,x148,x149,x150,x151,
     -    d152,x153,d154,x155,x156,x157,d158,x159,x160,d161,d162,x163,
     -    d163,d164,d165,d166,x166,x167,
C@DD     -  x168,
     -  d170,x171,x172,x173,x174,x175,x176,x177,x178,
     -  x179,x180,x181,x182,x183,x184,x185,x186,x187
      iok=1
      go to 110
111   write (iout,1001) 'real',filename1(1:lenfile1)
110   read (ichkp,end=121,err=121)
     -  ncompoptr,icompoptr,nasizer,iasizer,cmoddater,moddater,
     -  filenames,namlens,iform
      call compoptcheck(1,cmoddater,moddater,ncompoptr,icompoptr,
     -  nasizer,iasizer,filename1,lenfile1)
      rewind ichkp
      read (ichkp)
      read (ichkp,end=121,err=121)
     -  ncompoptr,icompoptr,nasizer,iasizer,cmoddater,moddater,
     -  filenames,namlens,iform,numrecprev,numrec,numframe,
     -  n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,iop,n14,n15,n16,n17,n18,
     -  n19,n20,c19,c20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,
     -  n31,n32,n33,n34,
C@NN     -  n35,n36,n37,n38,
     -  n39, n41,n42,n43,n44,n45,n46,n47,n48,n49,n50,n51,n52,n53,
     -  n54,n55,n56,n57,n58,n59,n60,n61,n62,n62a,n63,n64,n65,
C@TN     -   n66, n69,n70,
     -  n71,n72,n73,n74, n76, n78,n79,n80,n81,n82,
C@DM     -   n83a,n83d,n83c,n83d3,n83c3,n84,n85,n86,NUMNOD_o,
     -  n87,n88,n89,n90,n91,n92,n93,n94,n95,n96, n98,n99,n100,
     -  n102,n103,n104,n105,n106,n107,n108,n109, n111,n112,
     -  n113,n114,n115,n116,n117,n118,
C@FG     -  n119,
     -  n120,n121,n122,n124,n125,n126,n127,n128,n129,n130,n132,n133,
     -  n134,n135,n136,n137,n138,n139,n140,n141,n142,n143,n144,n145,
C@DD     -  n146,
     -  c174,n147,n148,n149,n150,n151,n152,n153,n154,n155,n156,n157,
     -  n158,n159,n160,n161,n162,n163,c163,n164,n165,ichkp,icord,
     -  ihist,idstr,iindel,ichkpx,idistrpx,infopx,ifldgpx,ickpok
      iok=iok+1
      go to 120
121   write (iout,1001) 'integer',filename1(1:lenfile1)
120   if (iok .ne. 2) then
        ichkp=ichkp0
        write (iout,1000) filenames(1)(1:namlens(1))
C@DM        write (iout,*) 'MYRANK=',MYRANK
        call fileopen(file,namlenf,filename1,namlen1,27,0,
     -    99,1,0,0,1,iversout,iout,icord1,0)
        write (icord1,1004) x1
        write (iout,1003) filename1(1:namlen1)
        call echopr(0)
        call datprt(2)
      end if
c     Check filenumbers for consistency
      if (iop(9) .gt.  0 .and. ihist .le. 0 .or.
     -    iop(32) .gt. 0 .and. idstr .le. 0 .or.
     -    iop(42) .gt. 0 .and. iindel .le. 0 .or.
     -    (iop(159) .gt. 0 .or. iop(160) .gt. 0) .and. ichkpx .le. 0
     -    .or. iop(153) .gt. 0 .and. idistrpx .le. 0 .or.
     -    iop(163) .gt. 0 .and. infopx .le. 0) then
        write (iout,1002) ihist,idstr,iindel,ichkpx,idistrpx,infopx
        nwarn=nwarn+1
      end if
      return
1000  format(' ***** ERROR: checkpoint file ',a,' is too short')
1001  format(' ***** ERROR: ',a,' record on checkpoint file ',a,
     -  ' is incomplete')
1002  format(' ----- WARNING: file unitnumbers are incompatible with ',
     -  'the options ',/,6x,' ihist=',i5,' idstr=',i5,' iindel=',i5,
     -  ' ichkpx=',i5,' idistrpx=',i5,' infopx=',i5)
1003  format(' +++++ Coordinates are saved on file ',a,/,' =====',
     -  ' but file may be unusable due to the checkpoint file problem.',
     -  /,7x,'Use an editor to eliminate excess lines and add the last',
     -  ' three lines from a valid coordinate file')
1004  format(3f15.9)
      end
      subroutine csave(ifile,ibuff,iskipfail,itypf)
c#    MMC routine  86 lstmod: 05/07/20
c*****Save all the common blocks except the proximity analysis data
C@I2      integer*2 n47
      real*8 d2,d8,d9,d13,d14,d15,d17,d19,d23e,d23f,d23t,d24,d25,d26,
     -  d28,d47,d48,d51,d53,d54,d64,d71,d92,d101,d102,d103,d104,d105,
     -  d106,d107,d108,d109,d111,d113, d115,d116,d117,d118,d119,d120,
     -  d121,d122,d123,d130,d132,d133,d134,
C@FG     -  d137,d138,d139,d140,d141,
C@DM     -  d142,
     -  d143,d145,d146,d152,d154,d158,d161,d162,d163,d164,d165,d166,
     -  d170
      character*2 optname,sizesym
      character*4 c19,c100,c124,c126,c174
      character*6 c20,c127,c128
      character*8 c125
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      character*80 c129,c163
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /slfttolerance/ x103(10,3)
      character*80 file,filenames,filenameh
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /ctotal/ x1(3,#NA),x4(9,#MO)
      common /mine/ d170(2),x171(2,3,#NE),n142(6)
      common /seed/ d25(76),n1(4)
      common /rangen/ x145(6),n125
      common /rnglist/ x185(#RN),n163(3),c163
      common /lcg_const/ n164(6)
      common /param/ x7(36),n2(10)
      character*80 ident
      common /title/ n160,ident(2)
      common /wadaptf/ x135(9),n115(9)
      common /isoeng/ x136(7)
      common /sreal/ d2(143),d92(8,#MM),d119(#GR),x81(#GR),x2(10)
      common /anneal/ d145(5),n145(6),x175(104)
      common /anneal_cp/ n165(505),x187(1002)
      common /inout/ d158(4)
      common /tdstate/ x52(5)
      common /svint/ n3(444)
      common /pmfinf/ x83(34),x84(3,#MA),n99(9)
      common /hstory/ x60(2750),n29(504),filenameh
      common /freeen/ d47(8),x47(33),n78(#GR),n39(5)
      common /solvnt/ x14(4,#SV),x44,n4(10),n103(2,#ND),n5(#SV)
      common /solute/ x5(3,#ST),x43(#GR),n22(2,#ST),n8(49),
     -  n9(#SV),n45(8,#ST),n32(3,#GR),n71(#ST),n95(6,#MM),
     -  n74(#UU)
      common /overlay/ x182(3,#ST),x183,n156(#ST),n157(4)
      common /solutelab/ c124(2,#ST),c126(#SV),c100,
     -  c127(#ST),c128(#SV),c125(#ST)
      common /clone/ n104,n105(4,10),n108(#TR),n106(2,#ST)
      common /dploy/ x6(3,#SV),x114(#TR),x82(3,#ST),
     -  x66(7,#MM),x20(75),n102(2,#MM),n6(43)
      common /shuffl/ n33(3),n7(#MO),n109(2,#MM)
      common /eftslvsum/ d23e(#MO),d23f(3,#MO),d23t(3,#MO),
     -  d24(3),x94(16,#MO)
      common /slvenergy/ d9,x9(8,#MO)
      common /fieldenergy/ d8,d113(#MM),x167(#MO),
     -  x93(2,#ST)
      common /parensts/ d106(#MM),d116(#TR)
      common /parenst/ d115(4,#ST),d117(2,#TR),d118
      common /polr/ x10(3,#MO),x56(9,#MM),x57(3,#MO),x58(4)
      common /distances/ n140,n15(6,#MO),x79(5,#MO),x153(2,#MS)
      common /stow/ x181(5),n154(2)
      common /rdial/ d13(2,500),d14,x11(2),n14(10)
      common /quasi/ d15(1170),x12(18),x172(#SV),n10(3,#MO),n11(2)
      common /ecell/ x13(81),n69
      common /option/ iop(200),idebug(200)
      common /relcd/ x15(3,#ST),x16(3,#SV)
      common /prefsmv/ d17,d121(#PS),x73(#PG),x18(#MO),x17(23),
     -  n16(2),n91(#PS),n87(#MO)
      common /prefsid/ d120(2),d122(2,#PS),x88(#PG),x89(#MO),
     -  x90(#PP),x87(22),n153(3),n92(2,#PS),n88(#MO),n89(#PP)
      common /fblam/ x74(#PG),x75(18),n46
      common /allpfdat/ x29(#AT,44)
      common /qljdat/ x45(33)
      common /epssig/ x85(2,#SV),x86(4,#ST),n162
      common /trqij/ x59(9),n72(5)
      common /force/ d19(15),x19(9),x30(6,#MO)
      common /cage/ x21(3,#MO),x22(3)
      common /cntrl/ d26(8,#MI),x26(2,#MI),n18(3)
      common /quantm/ d28(9),n24
      common /atmdat/ x31(99,2),c19(99),n19(2,99),
     -  n20(2,#AT,11),c20(#AT,11)
      common /cqpen/ x32(#TN,#VN),x33(#TN,#VE),x34(#TE,#VN),
     -  x35(4,#TE,#VE),n21(5)
      common /qpnabc/ x38(3,#TE),x39(3,#VE)
      common /cvdw/ x36(#TN,#VN),x37(2)
      common /dispar/ x40(8)
      common /caccpt/ d111(50),d107(#TR),d108(#LT),d109(#MM),
     -  x108(#TR),x156(#LT),n57(52),n23(2,#MO),n58(412),
     -  n63(8,#MM),n64(2,#TR),n136(2,#LT),n155(4,#ST)
      common /cpldst/ d48(4),d53(9,#WG),x53(6,#WG),
     -  n25(3,#WG),n31(#WI)
      common /wcpl/ d54(#WG),x49(6),n26(10)
      common /sweep/ n59(6),n60(2,#WI)
      common /nstopt/ n30(24),n27(6,#WI),x50(2,#WS),n28(#WS)
      common /esltcn/ n61(#SV),x61(7,#ST),x72(2)
      common /bitmaps/ n36(2,#UV),n37(3,64),n65(4)
C@NN      common /nneigtv/ n35(#VW,#MO),x62(3,#MO),x63(3),n38(3)
C@TN      common /nneigtu/ n66(#UW,#ST),n70(2)
      common /intslt/ n34(5),n80(#TL),n81(5,#GR),n82(#ST)
      common /ovlrat/ x65(3),n76(2,#OR)
      common /pbccns/ x67(33),n41(1)
      common /oldedge/ x177(3),n152
      common /cutinr/ x68(2)
      common /genslv/ x69(3,#GV,#GV),x70(3,#GT,#GV),n42(#GV)
      common /sltslt/ x112(4,#UU,#UU)
      common /psltdv/ d71(9,#DT,#SV),n43,n44(2,#DM)
      common /grid/ d123(3),x76(16),
     -  n47(#CV),n90(#PP),n48(#GX,#GY,#GZ),n49(17)
      common /outsideden/ x55(6),n17(2),n111(#MO)
      common /limgrid/ x137(9),n116(4),n117(#MO)
      common /cavdat/ x77(16),x110(#ST),n137
      common /cavprb/ n51(3,#MO),n50(7)
      common /cdhdan/ d64(5,#TR),d152(#TD,#TR),x78(9,#TR),x80(11),
     -  n52(12),n56(#ST),n53(14,#TR),n112(2,#TL),
     -  n54(#TA),n118(#TD,#TR)
      common /nrmfac/ d51(3,#WI),n55
      common /frind1/ d101(7)
      common /frind2/ x101(2)
      common /frind3/ x102(12,#MO)
      common /frind4/ d103(6)
      common /frind5/ d104(30)
      common /frind6/ x106(10)
      common /frind7/ x107(3,#MI),d105(3)
      common /sltnnl/ n62(#NL,#ST),n62a(5,#ST)
      common /pfuse/ n79(29),c129(9)
      common /newtor/ n93(4,#MM),n94(15,#ST),n98(4,#TR),
     -  x91(20,#ST),n73(1)
      common /toreng/ n96(19,#TR),x128(9,#TR),x129(3,#TA)
      common /fieldpot/ n100(24),x109(20)
      common /bondmod/ n107(1004)
      common /tpn/ x46(131),n133(4)
      common /virtvolcha/ d162(3),x163(11)
      common /tuneb/ d130(4),n113(9),x131(9)
      common /steptune/ d163(24),d164(20,#MM),d165(4,#TR),
     -  d166(4,#LT),x166(8),n141(20),n147(4,#MM)
      common /torauc/ n150(3),n151(#AU),x180(2),x179(2,#AU,#TR)
      common /stepscale/ x186(18)
      common /control/ d161(8)
      common /widom/ d132(2,#GX,#MW),d133(3,#GX),d134(4,#MW),x159(7),
     -  x160(2,#MW),x133(2,#GX,#MW),x134(#MW),n114(2,#MW),n120(334)
      common /hunginfo/ x149(9,#MH),x176(3,#MO),x150(2),n132(4)
      common /fieldgrad/
C@FG     -  d137(6,#MG,#GQ),d138(6,#MG,#GQ),
C@FG     -  d139(2,6,#MM,#GQ),d140(6,#MM),d141(6,#MG),n119(#MO),
     -  x95(8)
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ n83a(6,64),n83c(64),n83d(64),n83c3(64),
C@DM     -  n83d3(64),n85(#MO),n86(2,#GR)
C@DM      common /MPI_RN/ d142(68,64),n84(64)
      common /reactionfield/ x142(2)
      common /loopmove/ d146(2),n121(2,#TR),n122(11,#LT),x144(8),
     -  n124(308)
      common /loopdat/ d143(28,#LT)
      common /primhydsh/ d154(3),x146(8),x147(2,#MS),x148(2000),
     -  n130(2000),n128(48),n129(#ST),n135(2,#MS)
      common /dijdiff/ n127(2,20)
      common /nonboltz/ d102(8),x151(7)
      common /fixdeverr/ n126(8)
      common /howfar/ x155(#MI,4),n134(2)
      common /liga/ n138(2)
      common /pretrans/ x157(12),n139
C@DD      common /mehler_ddd/ x168(309),n146
      common /desolv_hbond_arr/ x173(3,#ST),n143(4,#ST)
      common /desolv_hbond_const/ n144(250),x174(325),c174(20)
      common /constraint/ n148(2),n149(3,100),x178(3,100)
      common /rppxrad/ rppxrad2(#ST),n158(#ST),n159(201)
      common /grid_split/ n161(3,#ST),x184(18)
C@G9      character*80 filename
C@DMc     Collect all tesi, (frctot, trqtot) values
C@DM      if (MYRANK .gt. 0) then
C@DM        call MPI_send(d23e(n83d(myrank1)+1),n83c(myrank1),
C@DM     -    MPI_DOUBLE_PRECISION,0,myrank1*NUMNOD,
C@DM     -    MPI_COMM_WORLD,ierr)
C@DMC@FR        call MPI_send(d23f(1,n83d(myrank1)+1),n83c3(myrank1),
C@DMC@FR     -    MPI_DOUBLE_PRECISION,0,2*myrank1*NUMNOD,
C@DMC@FR     -    MPI_COMM_WORLD,ierr)
C@DMC@FR        call MPI_send(d23t(1,n83d(myrank1)+1),n83c3(myrank1),
C@DMC@FR     -    MPI_DOUBLE_PRECISION,0,3*myrank1*NUMNOD,
C@DMC@FR     -    MPI_COMM_WORLD,ierr)
C@DM      else
C@DM        do ip=2,NUMNOD
C@DM          call MPI_recv(d23e(n83d(ip)+1),n83c(ip),
C@DM     -      MPI_DOUBLE_PRECISION,ip-1,ip*NUMNOD,
C@DM     -      MPI_COMM_WORLD,MPI_stat,ierr)
C@DMC@FR          call MPI_recv(d23f(1,n83d(ip)+1),n83c3(ip),
C@DMC@FR     -      MPI_DOUBLE_PRECISION,ip-1,2*ip*NUMNOD,
C@DMC@FR     -      MPI_COMM_WORLD,MPI_stat,ierr)
C@DMC@FR          call MPI_recv(d23t(1,n83d(ip)+1),n83c3(ip),
C@DMC@FR     -      MPI_DOUBLE_PRECISION,ip-1,3*ip*NUMNOD,
C@DMC@FR     -      MPI_COMM_WORLD,MPI_stat,ierr)
C@DM        end do
C@DM      end if
      iskipfail=0
C@DM       if (MYRANK .gt. 0) return
      if (ifile .eq. 0) then
        nmc=n3(7)
        if (nmc .gt. 0) then
          write (iout,1000)
          inperr=inperr+1
        end if
      else
        rewind ifile
c       Workaround the rewind problem in G95
C@G9        call fileclose(ifile,1,iop(24),iout)
C@G9        if (ifile .eq. ifilstat(1)) then
C@G9          ifiltyp=1
C@G9          numrun=n3(1)
C@G9        else
C@G9          ifiltyp=14
C@G9          numrun=99
C@G9        end if
C@G9        call fileopen(file,namlenf,filename,namlen,
C@G9     -     ifiltyp,0,numrun,1,3,1,iop(24),iversout,iout,ifile,0)
        write (ifile)
     -    ident,x1,d2,x2, x4,x5,x6,x7,d8,d9,x9,x10,x11,x12,x13,d13,d14,
     -    x14,x15,d15,x16,d17,x17,x18,d19,x19,x20,x21,x22,d23e,d23f,
     -    d23t,d24,d25,x26,d26, d28,x29,x30,x31,x32,x33,x34,x35,x36,x37,
     -    x38,x39,x40, x43,x44,x45,x46,d47,x47,d48,x49,x50,
     -    d51,x52,d53,x53,d54,x55,x56,x57,x58,x59,x60,x61,
C@NN     -    x62,x63,
     -    d64,x65,x66,x67,x68,x69,x70,d71,x72,x73,x74,x75,x76,x77,x78,
     -    x79,x80,x81,x82,x83,x84,x85,x86,x87,x88,x89,x90,x91,d92,x93,
     -    x94,x95,c100,d101,d102,d103,d104,d105,d106,d107,d108,d109,
     -    x101,x102,x103,x106,x107,x108,x109,x110,d111,x112,d113,x114,
     -    d115,d116,d117,d118,d119,d120,d121,d122,d123,c124,c125,c126,
     -    c127,c128,c129,x128,x129,d130,x131,d132,d133,d134,x133,x134,
     -    x135,x136,x137,
C@FG     -    d137,d138,d139,d140,d141,
C@DM     -    d142,
     -    x142,d143,x144,x145,d145,d146,x146,x147,x148,x149,x150,x151,
     -    d152,x153,d154,x155,x156,x157,d158,x159,x160,d161,d162,x163,
     -    d163,d164,d165,d166,x166,x167,
C@DD     -    x168,
     -    d170,x171,x172,x173,x174,x175,x176,x177,x178,
     -    x179,x180,x181,x182,x183,x184,x185,x186,x187
        write (ifile)
     -    ncompopt,icompopt,nasize,iasize,cmoddate,moddate,
     -    filenames,namlens,iform,numrecprev,numrec,numframe,
     -    n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,iop,n14,n15,n16,n17,n18,
     -    n19,n20,c19,c20,n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,
     -    n31,n32,n33,n34,
C@NN     -    n35,n36,n37,n38,
     -    n39, n41,n42,n43,n44,n45,n46,n47,n48,n49,n50,n51,n52,n53,
     -    n54,n55,n56,n57,n58,n59,n60,n61,n62,n62a,n63,n64,n65,
C@TN     -     n66, n69,n70,
     -    n71,n72,n73,n74, n76, n78,n79,n80,n81,n82,
C@DM     -     n83a,n83d,n83c,n83d3,n83c3,n84,n85,n86,NUMNOD,
     -    n87,n88,n89,n90,n91,n92,n93,n94,n95,n96, n98,n99,n100,
     -    n102,n103,n104,n105,n106,n107,n108,n109, n111,n112,
     -    n113,n114,n115,n116,n117,n118,
C@FG     -    n119,
     -    n120,n121,n122,n124,n125,n126,n127,n128,n129,n130,n132,n133,
     -    n134,n135,n136,n137,n138,n139,n140,n141,n142,n143,n144,n145,
C@DD     -    n146,
     -    c174,n147,n148,n149,n150,n151,n152,n153,n154,n155,n156,n157,
     -    n158,n159,n160,n161,n162,n163,c163,n164,n165,ichkp,icord,
     -    ihist,idstr,iindel,ichkpx,idistrpx,infopx,ifldgpx,ickpok
        if (ibuff .gt. 0) then
          call skiptoend(itypf,ifile,1,0,iop(24)-1,iskipfail)
          if (iop(87) .gt. 0) then
            if (ihist .gt. 0 .and. iop(160) .eq. 0)
     -        call skiptoend(3,ihist,0,1,iop(24)-1,iskipfail)
            if (iindel .gt. 0)
     -         call skiptoend(5,iindel,0,1,iop(24)-1,iskipfail)
          end if
        end if
      end if
      return
1000  format(' ***** PROGRAM ERROR: checkpoint file is unopened')
      end
C@DM      subroutine crstr_mpi
C@DMc#    MMC routine  86/a lstmod: 07/15/10
C@DMc*****Restore from the checkpoint file all CPU's
C@DM      character*80 file,filenames
C@DM      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
C@DM     -  numrec(50),numframe,file,filenames(50)
C@DM      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
C@DM     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
C@DM     -  inperr,nwarn,nwwarn,nchng
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /option/ iop(200),idebug(200)
C@DM      if (MYRANK .eq. 0) call crstr(0)
C@DM      if (NUMNOD .eq. 1) return
C@DM      call MPI_Bcast(filenames(1),80,MPI_CHARACTER,0,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      call MPI_Bcast(ichkp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM      call MPI_Bcast(namlens(1),1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM      do icpu=1,NUMNOD-1
C@DM        call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM        if (icpu .eq. MYRANK) then
C@DM          open(unit=ichkp,status='old',file=filenames(1)(1:namlens(1)),
C@DM     -      form='UNFORMATTED',iostat=ios)
C@DM          if (ios .eq. 0) then
C@DM            call crstr(1)
C@DM          else
C@DM            write (iout,1000) MYRANK,filenames(1)(1:namlens(1))
C@DM          end if
C@DM        end if
C@DM      end do
C@DM      return
C@DM1000  format(' ***** ERROR: MYRANK=',i3,' - failed to open checkpoint',
C@DM     -  ' file ',a)
C@DM      end
      subroutine savcnfh(ihist,iout,noincr,idoit,isavoptp,isavslv,c,
     -  csave,filename,namlen,lmnst0,lmnst,nframes,uusfac,maxc,maxcs)
c#    MMC routine  87 lstmod: 04/27/22
c*****Save the history of the run (write trajectory file)
      dimension c(3,maxc),csave(3,maxcs)
      character*80 filename
      real*8 uusfac
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      Real*8 xtlabc
      common /charmm/ xtlabc(6),icntrlr(20),icntrlw(20),nfreatr,nfreatw,
     -  ichopen,ifree(#NA)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /trajhead/ etoth,eslth,bparh,modelnumh,ietoth,ibparh
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      dimension keycol(2)
      character*80 filenamen
      Real*8 uusfacd,etotod,tesi1d,tss12d,tss6d,tss1d
C@DM      if (MYRANK .gt. 0) return
      uusfacd=uusfac
      etotod=etoto
      tesi1d=tesi(1)
      tss12d=tss12
      tss6d=tss6
      tss1d=tss1
      isavopt=isavoptp
      if (lmnst .ge. 0) lmnst0=lmnst
      nsvp=3
      if (iop(26) .eq. 4) nsvp=nslv
      if (isavopt .eq. 0) isavopt=iop(9)
      ia0=1
      ia1=nstta
      nstta_save=nstta
      call trnsfr(csave,c,3*(nstta+(nmolec-1)*nslv))
      natoms_wr=natoms
      nmolecs=nmolec
      nframes=nframes+1
      if (iop(59) .eq. 1) then
c       Don't save fixed solute molecules
        if (iop(30) .eq. 7) then
          ia0=nstfa1+1
          if (iop(57) .gt. 0) ia1=ilastm(ngrdmx)
          if (iop(58) .gt. 0) ia1=ilastm(ngrtmx)
          if (iop(57)*iop(58) .gt. 0) ia1=ilastm(max0(ngrdmx,ngrtmx))
        else if (iop(57) .gt. 0) then
          ia0=ifirstm(ngrdmn)
        else if (iop(58) .gt. 0) then
          ia0=ifirstm(ngrtmn)
          ia1=ilastm(ngrtmx)
        else if (iop(57)*iop(58) .gt. 0) then
          ia0=ifirstm(min0(ngrdmn,ngrtmn))
          ia1=ilastm(max0(ngrdmx,ngrtmx))
        else
          ia0=nstta+1
        end if
      else if (iop(59) .eq. 2) then
c       Don't save any solute atom
        ia0=nstta+1
      end if
      if (iop(59) .eq. 3 .or. isavslv .eq. 0) then
c       Don't save any solvent
        nmolecs=1
        nsvp=0
      end if
      if (iop(59) .eq. 0 .and. iop(61) .gt. 0) then
c       Grid potential was used - reassemble the full solute
        call reassemble(nstta,nstta_full,csave,c,cslt,isplit_of_orig)
        natoms_wr=nstta_full
        nstta=nstta_full
        ia1=nstta_full
        iop(61)=2
      end if
      natomp=(ia1-ia0+1)+(nmolecs-1)*nsvp
      nwat=nmolecs-1
      nmcp=nmc+nmchinc
      if (idebug(85) .gt. 0 .and.
     -   (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
        write (iout,1007) nmcp,ia0,ia1,icntrlw(9),icntrlw(11),
     -    nfreatw,natoms,isavopt
        if (idebug(85) .gt. 1) then
          call savepdb('PDB ',keycol,ipdb,-iout,ia0,ia1,nsvp,csave,0,0,
     -      0,1,filenamen,namlenn,nmcp,2,'trajectory_test',15,numrun,
     -      nmcp/nmcrec,1,inperr,nwarn,nwwarn,0,0,nlwr,0,1,maxcs)
        end if
      end if
      if (isavopt .le. 2) then
c       Put current configuration in a stack and move it to a file
c       when stack is full
c       becpst, estac, istc: stack for the binding energy of the moved molec,
c       total energy, index of moved molec.
c       cst: stack of the coordinates of the 1st 3 atoms of the moved molec
c       nmcst: stack of the MC stepnumbers of the accepted moves
c       lstac: stack pointer, lmnst: history file record counter.
        lstac=lstac+1
        nmcst(lstac)=nmcp
        estac(lstac)=etotn
        if (iop(30) .eq. 7) then
c         If variable coupling parameter is used, save coupling parameter
          becpst(lstac)=cplpar
        else
c         Save solvent binding energy
          becpst(lstac)=tesi(isolv)
c         If isavopt=2 save virial sum instead of solvent binding energy
          if (isavopt .eq. 2)
     -      becpst(lstac)=virial(1)+virial(2)+virial(3)
        end if
        istc(lstac)=isolv
        call trnsfr(cst(1,lstac),csave(1,icsol1),9)
        if (lstac .ge. 250) then
          write (ihist) estac,cst,istc,nmcst,becpst
          lstac=0
          lmnst=lmnst+1
        end if
      else if (isavopt .eq. 3) then
c       Save the minimum energy configuration
        rewind ihist
        write (ihist) etotod,tesi1d,tss12d,tss6d,tss1d,
     -    ((csave(k,i),k=1,3),i=1,natoms_wr)
        lmnst=1
        if (iop(30) .gt. 3) then
          write (ihist) cplpar
          lmnst=lmnst+1
        end if
        if (iop(71) .gt. 0) then
          write (ihist) edgexyz
          lmnst=lmnst+1
        end if
      else if ((isavopt .eq. 4 .or .isavopt .eq. 5) .and.
     -         (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
c       Save ASCII configuration
        write (ihist,1000) natomp,nmolecs,natoms_wr,ia0,ia1,nmcp,cplpar
        if (isavopt .eq. 4) then
c         Only coordinates
          do i=ia0,ia1
            write (ihist,1004) (csave(k,i),k=1,3)
          end do
          do iw=2,nmolecs
            do j=1,nsvp
              write (ihist,1004) (csave(k,ic00+iw*nslv+j),k=1,3)
            end do
          end do
        else
c         Annotated with atomic symbols, group no and chrg
          do i=ia0,ia1
            write (ihist,1001) iatnam(ianprt(ianslt(i))),
     -       (csave(k,i),k=1,3),igrslt(i),qslt(i)
          end do
          do iw=2,nmolecs
            do j=1,nsvp
              write (ihist,1001) iatnam(ianprt(ianslv(j))),
     -          (csave(k,ic00+iw*nslv+j),k=1,3),(igrslt(nstta)+iw-1),
     -          qslv(j)
            end do
          end do
        end if
        write (ihist,1002) nidmc,etoto,
     -    niaccp,ndaccp,uusfac,tesi(1),tss12,tss6,tss1
        lmnst=lmnst+natomp+3
        if (iop(71) .gt. 0) then
          write (ihist,1005) edgexyz
          lmnst=lmnst+1
        end if
      else if (isavopt .eq. 6 .and.
     -         (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
c       MMC binary
        write (ihist) nwat,natomp,uusfacd,nmcp,nidmc,
     -    niaccp,ndaccp,ia0,ia1,etotod,tesi1d,tss12d,tss6d,tss1d,cplpar
        write (ihist) ((csave(k,j),k=1,3),j=ia0,ia1),
     -    (((csave(k,nstta+(i-1)*nslv+j),k=1,3),j=1,nsvp),i=1,nwat)
        lmnst=lmnst+2
        if (iop(71) .gt. 0) then
          write (ihist) edgexyz
          lmnst=lmnst+1
        end if
        if (iop(107) .gt. 0) then
          write (ihist) istune
          lmnst=lmnst+1
          if (istune(1)+istune(2) .gt. 0) then
            write (ihist) stepsumtrans,stepsumrot
            lmnst=lmnst+1
          end if
          if (istune(3) .gt. 0) then
            write (ihist) (stepsumtor(it),it=1,istune(3))
            lmnst=lmnst+1
          end if
          if (istune(4) .gt. 0) then
            write (ihist) (stepsumloop(it),it=1,istune(4))
            lmnst=lmnst+1
          end if
        end if
      else if ((isavopt .eq. 7 .or. isavopt .eq. 8) .and.
     -         (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
c       [MODEL/ENDMDL] LPDB format
        if (isavopt .eq. 8) modelnum=modelnum+1
        write (ihist,1003) 'REMARK',natomp,nmolecs,natoms_wr,ia0,ia1,
     -    nmcp,cplpar
        if (ietoth .eq. 0) write (ihist,1008) 'REMARK',etoto,tesi(1)
        call savepdb('PDB ',keycol,ihist,-iout,ia0,ia1,nsvp,csave,0,0,0,
     -    1,filenamen,namlenn,nmcp,0,filename,namlen,1,1,1,inperr,nwarn,
     -    nwwarn,0,0,nlwr,modelnum,1,maxcs)
        lmnst=lmnst+nlwr+2
        if (nmolecs .gt. 2) lmnst=lmnst+1
      else if (isavopt .eq. 9 .and.
     -         (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
c       Charmm CRD format
        write (ihist,1003) '*     ',natomp,nmolecs,natoms_wr,ia0,ia1,
     -    nmcp,cplpar
        write (ihist,1008) '*     ',etoto,tesi(1)
        call savepdb('CHRM',keycol,ihist,-iout,ia0,ia1,nsvp,csave,0,0,0,
     -    1,filename,namlen,nmcp,0,filename,namlen,1,1,1,inperr,nwarn,
     -    nwwarn,0,0,nlwr,0,1,maxcs)
        lmnst=lmnst+nlwr+2
      else if (isavopt .eq. 10 .and.
     -         (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
c       Write Amber trajectory file
c       Shift the center from (ex/2,ey/2,ez/2) to (0,0,0)
c       do ia=1,natoms_wr
c         call arrsum(csave(1,ia),csave(1,ia),edge2xyz,3)
c       end do
        write (ihist,1006) ((csave(k,ia),k=1,3),ia=1,natoms_wr)
        lmnst=lmnst+(3*natoms_wr-1)/10+1
        if (iop(71) .gt. 0 .or. iop(161) .eq. 1) then
c         Write new box size
          write (ihist,1006) edgexyz
          lmnst=lmnst+1
        end if
      else if (isavopt .eq. 11 .and.
     -         (idoit .eq. 1 .or. mod(nmcp,nmcrec) .eq. 0)) then
c       Write Charmm trajectory file
        if (icntrlw(11) .eq. 2 .and. lmnst .gt. 5) then
          xtlabc(1)=edgexyz(1)
          xtlabc(3)=edgexyz(2)
          xtlabc(6)=edgexyz(3)
          write (ihist) xtlabc
        end if
        if (icntrlw(9) .gt. 0 .and. lmnst .gt. 5) then
          write (ihist) (csave(1,ifree(j)),j=1,nfreatw)
          write (ihist) (csave(2,ifree(j)),j=1,nfreatw)
          write (ihist) (csave(3,ifree(j)),j=1,nfreatw)
        else
          write (ihist) (csave(1,j),j=1,natoms_wr)
          write (ihist) (csave(2,j),j=1,natoms_wr)
          write (ihist) (csave(3,j),j=1,natoms_wr)
        end if
        lmnst=lmnst+3
      end if
      if (noincr .eq. 1) lmnst=lmnst0
      if (iop(59) .eq. 0 .and. iop(61) .gt. 0) then
c       Grid potential was used - restore the moving solute atomnos
        nstta=nstta_save
c       call trnsfr(c,csave,3*nstta_full)
        iop(61)=1
      end if
      natomp=(ia1-ia0+1)+(nmolecs-1)*nsvp
      return
1000  format(i6,' (n) nml=',i6,' natoms=',i6,' ia0,1=',2i6,
     -  ' Nmc=',i9,' cp=',f8.6)
1001  format(a4,1x,3f15.5,i5,f10.5)
1002  format('!Nidmc=',i9,' E=',e16.8,' (kcal/mol)',
     -  ' niacc,ndacc=',2i9,/,'!uusfac=',e13.6,' Eslt=',4e13.6)
1003  format(a6,' n=',i6,' m=',i6,' nat=',i6,' ia0,1=',2i6,
     -  ' Nmc=',i9,' cp=',f8.5)
1004  format(3f15.5)
1005  format('!Edgexyz=',3f10.5)
1006  format(10f8.3)
1007  format(' SAVCNFH nmc=',i9,' ia0,ia1=',2i6,' icntrlw(9),(11)=',2i6,
     -  ' nfreatw,natoms=',2i9,' isavopt=',i2)
1008  format(a6,' E=',e16.8,' (kcal/mol) Eslt=',e13.6)
      end
      subroutine reassemble(nstta,nstta_full,cfull,c,cslt,
     -  isplit_of_orig)
c#    MMC routine  87 lstmod: 05/08/20
c*****Reassemble the full solute with the grid-contributing atoms
      dimension cfull(3,nstta_full),c(3,nstta_full),cslt(3,nstta_full),
     -  isplit_of_orig(nstta_full)
c     write (6,*) 'REASSEMBLE nstta=',nstta,' nstta_full=',nstta_full
      do iaa=1,nstta_full
        ia=isplit_of_orig(iaa)
        if (ia .le. nstta) then
c         Moving part
          call trnsfr(cfull(1,iaa),c(1,ia),3)
        else
c         Fixed part
          call trnsfr(cfull(1,iaa),cslt(1,ia),3)
        end if
      end do
      return
      end
      subroutine savepdb(key,keycol,iupdb,iout,nslt1,nslt,nsvp,
     -  c,nsolvent,iendmol,iusetab,iwend,filename,namlen,nmc,iopenclose,
     -  file,namlenf,numrun,numvers,modefile,inperr,nwarn,nwwarn,msgno,
     -  nocoldatw,nlinewrite,model,idb,maxat)
c#    MMC routine  88 lstmod: 06/21/20
c*****Save the configuration as a PDB file
      character*4 key,keyw
      character*(*) filename,file
      dimension c(3,maxat),keycol(2)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 ident
      common /title/ nlident,ident(2)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      character*4 labpr
      character*2 iaprt
      common /grplst/ ixprt(#ST),ilastg(#ST),labpr(2,#ST),
     -  iaprt(#ST)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /pxrdfdat/ gpxmx1(#GQ),gpxmn1(#GQ),gpxmx2(#GQ),
     -  gtmx1(#GQ),gtmn1(#GQ),rpxmx1(#GQ),rpxmn1(#GQ),
     -  rpxmx2(#GQ),rtmx1(#GQ),rtmn1(#GQ),gtmx2(#GQ),
     -  rtmx2(#GQ),volfs(#GQ),vol2fs(#GQ),rnvols(#GQ),
     -  rpxfar(#GQ),rtfar(#GQ),rkfrdf(#GQ),rksrdf(#GQ),
     -  vfrdf(#GQ),vsrdf(#GQ)
      common /rfsavg/ iwrfs(#GQ),rkpdbmin,rkgrmin,r2kgrmin,rtkgrmin
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  coldat(2,#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /warncount/ ichsegwarn,ipdbcherr(11)
      character*1 charlist
      common /characters/ charlist(52)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      character*4 segid,segidprev,slvsegid,atnam,resnam
      dimension qsvv(#SV)
      character*3 terend(2)
      character*36 datainfo(30)
      character*60 configs(26)
      common /confignames/ configs,lconfigs(26)
      common /pdbinfo/ ntabcol,npxcol,nothercol,terend,datainfo
      common /trajhead/ etoth,eslth,bparh,modelnumh,ietoth,ibparh
      dimension z(3)
      character*1 chainid
      character*3 resnam3
      data ifilstatsave /0/
      nlinewrite=0
      ioutp=iabs(iout)
c     write (ioutp,*) 'SAVEPDB nslt1,nslt=',nslt1,nslt
      if (idebug(66) .gt. 0) then
        write (ioutp,3004) key,keycol,nslt1,nslt,nsvp
        if (msgno .gt. 0)
     -     write (ioutp,3007) configs(msgno)(1:lconfigs(msgno))
      end if
      if (iop(90) .eq. 0 .and. key(1:3) .eq. 'CHR' .and.
     -    ichsegwarn .eq. 0) then
        ichsegwarn=1
        nwarn=nwarn+1
        write (ioutp,3003)
      end if
      pmvsv=pmvslv*1.e+24/avogad
      segid='    '
      segidprev=segid
      if (key(1:3) .eq. 'PDB') then
        ifiltyp=15
        ncols=2
        keyw(1:3)=key(1:3)
        keyw(4:4)=' '
        maxats=99999
        maxres=9999
        itinc=0
      else if (key(1:3) .eq. 'CHR') then
        ifiltyp=18
        ncols=1
        keyw='CHRM'
        maxats=99999
        maxres=99999
        itinc=2
        keycol(2)=keycol(1)
        if (namslv .eq. 'HOH ') then
          slvsegid='WATR'
        else
          slvsegid=namslv
        end if
      else
        write (ioutp,3002) key
        inperr=inperr+1
        return
      end if
      if (iopenclose .gt. 0) then
        ifilstatsave=ifilstat(ifiltyp)
        ifilstat(ifiltyp)=0
        ifileverb=iop(24)
        if (iout .lt. 0) ifileverb=0
        call fileopen(file,namlenf,filename,namlen,
     -    idb*ifiltyp,0,numrun,numvers,modefile,0,ifileverb,iversout,
     -    ioutp,iupdb,0)
      end if
      if (ibparh .eq. 1) write (iupdb,2023) bparh,nmolec-1
      if (model .gt. 0) write (iupdb,2020) model
      if (ietoth .eq. 1) write (iupdb,2024) etoth,eslth
      if (key .eq. 'PDBG') write (iupdb,2000) 2
      if (key .eq. 'PDBQ') write (iupdb,2000) 1
      if (key .eq. 'PDBQ' .or. key .eq. 'PDBQ') nlinewrite=nlinewrite+2
      if (key .eq. 'PDB ' .or. key .eq. 'PDBO' .or. key .eq. 'PDBQ')then
        keycol(1)=npxcol+nothercol+1
        keycol(2)=keycol(1)+1
      else if (key .eq. 'PDBC') then
        keycol(1)=npxcol+nothercol+5
        keycol(2)=keycol(1)+1
      else if (key .eq. 'CHRM') then
        keycol(1)=npxcol+nothercol+2
      end if
      nattot=nslt-nslt1+1
      if (nsolvent .lt. 0) then
        nsolv=0
      else if (nsolvent .eq. 0) then
        nsolv=nmolec-1
      else
        nsolv=nsolvent
      end if
      if ((key .eq. 'PDB ' .or. key .eq. 'PDBO' .or. key .eq. 'CHRM'.or.
     -     keycol(1) .eq. npxcol+1 .or. keycol(2) .eq. npxcol+1 .or.
     -     keycol(1) .eq. npxcol+2 .or. keycol(2) .eq. npxcol+2 .or.
     -     key .eq. 'PDBw' .or. key .eq. 'PDBC') .and. nsolv .ge. 0)then
             nattot=nattot+nsolv*nsvp
      else if (nsolv .ge. 0) then
        write (ioutp,*)
     -    '///// NOTE: This WCNF option does not write solvents'
        nsolv=0
      end if
      if (nlident .gt. 0) then
        if (key(1:3) .eq. 'PDB') then
          write (iupdb,2012)  ('REMARK',ident(ll)(1:72),ll=1,nlident)
        else
          write (iupdb,2012)  ('*',ident(ll)(1:72),ll=1,nlident)
        end if
      end if
      nlinewrite=nlinewrite+1
      if (nslt1 .le. nslt) then
        if (key .eq. 'PDB ' .or. key .eq. 'PDBw' .or.
     -    key .eq. 'PDBO') then
        write (iupdb,2013) 'solute'
          write (iupdb,2001)
     -      datainfo(npxcol+nothercol+1),datainfo(npxcol+nothercol+2)
        else if (key .eq. 'PDBC') then
          write (iupdb,2013) 'solute'
          write (iupdb,2001)
     -      'Closest deletion site','Number of proximal sites'
          write (iupdb,3008) ' solute ',
     -      'Closest deletion site','Number of proximal sites'
        else if (key .eq. 'PDBD') then
          write (iupdb,2013) 'solute'
          write (iupdb,2001) (datainfo(keycol(ic)),ic=1,2)
        end if
        nlinewrite=nlinewrite+3
      end if
      if (nocoldatw .eq. 0 .and. nsolv .gt. 0) then
        kc1=keycol(1)
        kc2=keycol(2)
        if (kc1 .eq. 0) kc1=npxcol+nothercol+1
        if (kc2 .eq. 0) kc2=npxcol+nothercol+2
        if (key(1:3) .eq. 'PDB') then
          write (iupdb,2013) 'solvent'
          write (iupdb,2001) datainfo(kc1),datainfo(kc2)
        else
          write (iupdb,2014) 'solvent'
          write (iupdb,2007)(ident(ll)(1:72),ll=1,nlident)
          write (iupdb,2016) datainfo(kc1)
        end if
        nlinewrite=nlinewrite+3
      end if
      if (iusetab .eq. 1) then
        write (iupdb,2005)
        nlinewrite=nlinewrite+1
      end if
      if (msgno .gt. 0) then
        if (key(1:3) .eq. 'PDB') then
          write (iupdb,2003) configs(msgno)(1:lconfigs(msgno))
          nlinewrite=nlinewrite+1
        end if
        if (key(1:3) .eq. 'CHR') then
          write (iupdb,2009) configs(msgno)(1:lconfigs(msgno))
          nlinewrite=nlinewrite+1
          if (nattot .gt. maxats) then
            write (ioutp,3006) nattot
            nwwarn=nwwarn+1
          end if
        end if
      end if
      if (key(1:3) .eq. 'CHR') then
        nattotw=min0(maxats,nattot)
        if (nattotw .lt. 100000) write (iupdb,2010) nattotw
        if (nattotw .ge. 100000) write (iupdb,2011) nattotw
        nlinewrite=nlinewrite+2
      end if
      ispread=0
      do ic=1,ncols
        if (keycol(ic) .eq. 0) keycol(ic)=npxcol+nothercol+ic
        if (keycol(ic) .gt. ntabcol .and. keycol(ic) .le. npxcol)
     -    ispread=1
      end do
      if (ispread .gt. 0) then
c       Spread out rdf data
        call zeroit(cv1,nsltpx2)
        call zeroit(cv2,nsltpx2)
        call zeroit(cv3,nsltpx2)
        do ig=1,nsltpxgr
          ifst=1
          if (ig .gt. 1) ifst=ilastg(ig-1)+1
          do ia=ifst,ilastg(ig)
            cv1(ixprt(ia))=rpxmn1(ig)
            cv2(ixprt(ia))=rkfrdf(ig)
            cv3(ixprt(ia))=vfrdf(ig)
          end do
        end do
      end if
      iainc=0
      igrinc=0
      igrseginc=0
      if ((key .eq. 'PDBG' .or. key .eq. 'PDBD' .or. key .eq. 'CHRD')
     -    .and. iusetab .eq. 0) then
        do ic=1,ncols
          do ia=nslt1,nslt
            coldat(ic,ia)=0.0
            rkfs=0.0
            if (ncnfpx .gt. 0) rkfs=float(nwfspx(ia))/float(ncnfpx)
            if (keycol(ic) .eq. 1) then
c             First shell volume
              if (nrans .gt. 0) coldat(ic,ia)=
     -          float(nrnfs(ia))/(float(nrans)*float(ndim2p))*vol
            else if (keycol(ic) .eq. 2) then
c             First two shell volume
              if (nrans .gt. 0) coldat(ic,ia)=
     -          float(nrn2fs(ia))/(float(nrans)*float(ndim2p))*vol
            else if (keycol(ic) .eq. 3) then
c             Coordination number (1 shell)
              coldat(ic,ia)=rkfs
            else if (keycol(ic) .eq. 4) then
c             Coordination number (2 shells)
              if (ncnfpx .gt. 0)
     -          coldat(ic,ia)=float(nw2fspx(ia))/float(ncnfpx)
            else if (keycol(ic) .eq. 5) then
c             First shell density
              if (nrnfs(ia) .gt. 0 .and. ncnfpx .gt. 0) coldat(ic,ia)=
     -          pmvsv*float(nwfspx(ia))* float(nrans)*float(ndim2p)/
     -          (vol*float(ncnfpx)*float(nrnfs(ia)))
            else if (keycol(ic) .eq. 6) then
c             First two shell density
              if (nrn2fs(ia) .gt. 0 .and. ncnfpx .gt. 0) coldat(ic,ia)=
     -          pmvsv*float(nw2fspx(ia))* float(nrans)*float(ndim2p)/
     -          (vol*float(ncnfpx)*float(nrn2fs(ia)))
            else if (keycol(ic) .eq. 7) then
c             First shell total solute-solvent energy
              if (ncnfpx .gt. 0) coldat(ic,ia)=befssm(ia)/float(ncnfpx)
            else if (keycol(ic) .eq. 8) then
c             First shell solute-solvent energy per solvent
              if (nwfspx(ia) .gt. 0)
     -          coldat(ic,ia)=befssm(ia)/float(nwfspx(ia))
            else if (keycol(ic) .eq. 9) then
c             Total solvent coordination number
              coldat(ic,ia)=float(nwfspx(ia))/float(ncnfpx)
            else if (keycol(ic) .eq. 10) then
c             Total solvent binding energy
              coldat(ic,ia)=besm(ia)/float(ncnfpx)
            else if (keycol(ic) .eq. 11) then
c             First shell solvent-solvent coordination number per solvent
              if (npxwws(ia) .gt. 0)
     -          coldat(ic,ia)=newwnn(ia)/float(npxwws(ia))
            else if (keycol(ic) .eq. 12) then
c             First shell solvent-solvent  pair energy per solvent
              if (newwnn(ia) .gt. 0)
     -          coldat(ic,ia)=ewwnn(ia)/float(newwnn(ia))
            else if (keycol(ic) .eq. 13) then
c             First shell total solvent-solvent energy per solvent
              if (npxwws(ia) .gt. 0)
     -          coldat(ic,ia)=ewwis(ia)/float(npxwws(ia))
            else if (keycol(ic) .eq. ntabcol+1) then
c             First minimum of the proximity rdf
              coldat(ic,ia)=cv1(ia)
            else if (keycol(ic) .eq. ntabcol+2) then
c             Coordination no, using the first minimum of the proximity rdf
              coldat(ic,ia)=cv2(ia)
            else if (keycol(ic) .eq. ntabcol+3) then
c             First shell vol, using the first minimum of the proximity rdf
              coldat(ic,ia)=cv3(ia)
            else if (keycol(ic) .eq. ntabcol+4) then
c             First shell density, using the first minimum of the proximity rdf
              coldat(ic,ia)=0.0
              if (cv3(ia) .ne. 0.0) coldat(ic,ia)=cv2(ia)/cv3(ia)
            else if (keycol(ic) .eq. npxcol+1 .or.
     -          keycol(ic) .eq. npxcol+2) then
c             Circular variance (with or w/o H)
              coldat(ic,ia)=abz(ia)
            else if (keycol(ic) .eq. npxcol+3) then
c             Insertion acceptance rate * 100
              coldat(ic,ia)=0.0
              if (idproxacc(2,ia) .gt. 0) coldat(ic,ia)=
     -          float(100*idproxacc(1,ia))/float(idproxacc(2,ia))
            else if (keycol(ic) .eq. npxcol+4) then
c             Deletion acceptance rate * 100
              coldat(ic,ia)=0.0
              if (idproxacc(4,ia) .gt. 0) coldat(ic,ia)=
     -          float(100*idproxacc(3,ia))/float(idproxacc(4,ia))
            end if
c           Set property to zero if coordination no is below threshold
            if (rkpdbmin .gt. 0.0 .and. rkfs .lt. rkpdbmin .and.
     -        keycol(ic) .gt. 3) coldat(ic,ia)=0.0
          end do
        end do
      else if ((key .eq. 'PDBG' .or. key .eq. 'PDBD' .or.
     -          key .eq. 'CHRD') .and. iusetab .eq. 0) then
        do ic=1,ncols
          do ia=nslt1,nslt
            coldat(ic,ia)=pxt1(keycol(ic),ia)
          end do
        end do
      else if (key .eq. 'PDBC') then
c       GCE I/D site file (called from the subroutine idaggregate)
        do ia=nslt1,nslt
          coldat(1,ia)=float(l3(ia))/10.0
          coldat(2,ia)=l4(ia)
        end do
      end if
      if ((iop(168) .eq. 1  .or. iop(168) .eq. 3) .and.
     -     key(3:4) .ne. ' ') then
c       Set data for hydrogens to its heavy atom value
        do ia=nsltpx1,nsltpx2
          if (ianslt(ia) .eq. 1) then
            do ic=1,ncols
              coldat(ic,ia)=coldat(ic,ineig(1,ia))
            end do
          end if
        end do
      end if
      newseg=1
      if (iop(61) .eq. 1 .and. key(1:3) .eq. 'PDB') write (iupdb,2018)
      if (iop(61) .eq. 2) then
        write (ioutp,2017)
        if (key(1:3) .eq. 'PDB') write (iupdb,2022) 'REMARK'
        if (key(1:3) .ne. 'PDB') write (iupdb,2022) '*'
      end if
      nats=0
      do ia=nslt1,nslt
        iaw=ia
        call trnsfr(z,c(1,ia),3)
        if (iop(61) .gt. 0) then
          chainid='A'
c         if (iop(61) .eq. 1) iaw=iorig_of_split(ia)
          iaw=ia
          if (iop(61) .eq. 2) iaw=isplit_of_orig(ia)
        else
          chainid=charlist(mod(iamolslt(ia)-1,22)+1)
        end if
        segid(1:1)=chainid
        nats=nats+1
        if (key(1:3) .eq. 'CHR' .and. iop(90) .gt. 0)
     -     segid=fcglab(iaw)(5:8)
        if (segid .ne. segidprev) then
          if (iendmol .eq. 1) then
            iainc=ia-1
            igrinc=igrslt(iaw)-1
          end if
          igrseginc=igrslt(iaw)-1
          if (key(1:3) .eq. 'PDB' .and. ia .gt. nslt1) then
            if (iendmol .eq. 0) then
              write (iupdb,2008) terend(iendmol+1)
            else if (iop(61) .eq. 0) then
              if (model .eq. 0) write (iupdb,2008) terend(iendmol+1)
              if (model .gt. 0) write (iupdb,2021)
            end if
          nlinewrite=nlinewrite+1
          end if
        end if
        if (iop(61) .lt. 2) iresnum=igrslt(iaw)
        if (iop(61) .eq. 2) iresnum=ir_split_orig(ia)
        iresnumseg=iresnum-igrseginc
        iresnum=iresnum-igrinc
        call pdblim(keyw,ia-iainc,natw,maxats,'atom',itinc+1,nwwarn,
     -    ioutp)
        call pdblim(keyw,iresnum,iresnumw,maxres,'residue',itinc+2,
     -    nwwarn,ioutp)
        resnam=labslt(1,iaw)
        if (resnam(1:1) .eq. ' ') then
          resnam3=resnam(2:4)
        else
          resnam3=resnam(1:3)
        end if
        if (key(1:3) .eq. 'CHR') then
          call pdblim(keyw,iresnumseg,iresnumsegw,9999,'residueid',5,
     -      nwwarn,ioutp)
          atnam=labslt(2,ia)
        else
          call adjustpdbname(labslt(2,iaw),atnam,iop(98))
        end if
        if (key .eq. 'PDB ' .or. key .eq. 'PDBw' .or.
     -      key .eq. 'PDBO') then
          write (iupdb,2004) natw,atnam,resnam3,chainid,iresnumw,
     -      z,vdw(ianslt(iaw)),qslt(iaw)
        else if (key .eq. 'PDBQ') then
          write (iupdb,2004) natw,atnam,resnam3,chainid,iresnumw,
     -      z,vdw(ianslt(iaw)),qslt(iaw)
        else if (key .eq. 'PDBD') then
          write (iupdb,2004) natw,atnam,resnam3,chainid,iresnumw,
     -      z,(coldat(ic,ia),ic=1,2)
        else if (key .eq. 'PDBC') then
          write (iupdb,2015) natw,atnam,resnam3,chainid,iresnumw,
     -      z,(coldat(ic,ia),ic=1,2)
        else if (key .eq. 'PDBG') then
          write (iupdb,2002) natw,atnam,resnam3,chainid,iresnumw,
     -      z,(coldat(ic,ia),ic=1,2)
        else if (key .eq. 'CHRM') then
          write (iupdb,2006) natw,iresnumw,resnam,atnam,
     -      z,segid,iresnumsegw,qslt(iaw)
        else if (key .eq. 'CHRD') then
          write (iupdb,2006) natw,iresnumw,resnam,atnam,
     -      z,segid,iresnumsegw,coldat(1,ia)
        end if
        segidprev=segid
      end do
      nlinewrite=nlinewrite+nats
      if (nslt .gt. 0) igrseginc=igrslt(nslt)
      if (idebug(66) .gt. 0) write (ioutp,3005) nmolec,nattot,nats
      if (nattot .gt. nats .and. iop(61) .eq. 0) then
        nats=nattot
        call trnsfr(qsvv,qslv,nslv)
        if (key(1:3) .eq. 'PDB' .and. nslt1 .le. nslt) then
          if (iendmol .eq. 0) then
            write (iupdb,2008) terend(iendmol+1)
          else
            if (model .eq. 0) write (iupdb,2008) terend(iendmol+1)
            if (model .gt. 0) write (iupdb,2021)
          end if
          nlinewrite=nlinewrite+1
        end if
        frocc=1.0
        igrslt0=0
        if (nstta .gt. 0) igrslt0=igrslt(nstta)
        if (key .eq. 'PDBO') then
          keycol(1)=npxcol+3
          keycol(2)=npxcol+4
        end if
        do im=2,nsolv+1
          iresnum=igrslt0+im-1
          do is=1,nsvp
            ia=nstta+(im-2)*nslv+is
            iaa=nstta+(im-2)*nsvp+is
            tfac=qsvv(is)
            if (keycol(1) .eq. npxcol+1 .or. keycol(2) .eq. npxcol+1
     -        .or. keycol(1) .eq. npxcol+1
     -        .or. keycol(2) .eq. npxcol+1) qsvv(is)=texng(im)
            if (keycol(1) .eq. npxcol+3 .or. keycol(1) .eq.  npxcol+5)
     -        frocc=frocc1(im-1)
            if (keycol(2) .eq. npxcol+4 .or.
     -          keycol(2) .eq. npxcol+5) qsvv(is)=bfac1(im-1)
            call pdblim(keyw,iaa,natw,maxats,'atom',itinc+1,nwwarn,
     -        ioutp)
            call pdblim(keyw,iresnum,iresnumw,maxres,'residue',itinc+2,
     -        nwwarn,ioutp)
            if (key(1:3) .eq. 'CHR') then
              call pdblim(keyw,iresnum-igrseginc,isegresnumw,9999,
     -          'residueid',5,nwwarn,ioutp)
              write (iupdb,2006) natw,iresnumw,namslv,labslv(is),
     -          (c(k,ia),k=1,3),slvsegid,isegresnumw,qsvv(is)
            else
              call adjustpdbname(labslv(is),atnam,iop(98))
              write (iupdb,2004) natw,atnam,namslv(1:3),
     -          'W',iresnumw,(c(k,ia),k=1,3),frocc,qsvv(is)
            end if
          end do
        end do
        nlinewrite=nlinewrite+nsolv*nsvp
      end if
      if (iop(117) .gt. 2) then
c       Generate bonds between constraint atom pairs
        do ip=1,nconstr_pair
          ipair1=iconstr_pair(1,ip)
          ipair2=iconstr_pair(2,ip)
          if (iop(61) .gt. 0) then
            ipair1=iorig_of_split(ipair1)
            ipair2=iorig_of_split(ipair2)
          end if
          write (iupdb,2019) ipair1,ipair2
        end do
      end if
      if (keyw(1:3) .eq. 'PDB') then
        if (iwend .eq. 0) then
          write (iupdb,2008) terend(iwend+1)
        else
          if (model .eq. 0) write (iupdb,2008) terend(iwend+1)
          if (model .gt. 0) write (iupdb,2021)
        end if
        nlinewrite=nlinewrite+1
      end if
      if (iout .gt. 0) then
        write (iout,3000) keyw,filename(1:namlen),nmc,nats,
     -    (iamolslt(nslt)-iamolslt(nslt)+1),nsolv
        if (nocoldatw .eq. 0 .and. key .ne. 'PDBC') write (iout,3008)
     -    ' ',(datainfo(keycol(ic)),ic=1,ncols)
        if (iusetab .eq. 1) write (iout,3001)
        if (keyw(1:3) .eq. 'PDB' .and. iop(98) .ne. 1) write (iout,3009)
      end if
      if (iopenclose .gt. 0) ifilstat(ifiltyp)=ifilstatsave
      if (iopenclose .gt. 1) call fileclose(iupdb,0,ifileverb,ioutp)
      return
2000  format('GRASP PDB FILE',/,'FORMAT NUMBER=',i1)
2001  format('REMARK First data column: ',a36,/,
     -  'REMARK Second data column: ',a36)
2002  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,f10.3,f10.3)
2003  format('REMARK ',a)
2004  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
2005  format('REMARK Quantities represent differences')
2006  format(i5,i5,1x,a4,1x,a4,3f10.5,1x,a4,1x,i4,f10.5)
2007  format('* = ',a)
2008  format(a3,3x)
2009  format('* ',a)
2010  format('* ',/,i5)
2011  format('* ',/,i6)
2012  format(a,1x,a72)
2013  format('REMARK Data after the ',a,' atoms:')
2014  format('* Data after the ',a,' atom:')
2015  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,f6.2,f6.0)
2016  format('* Data column: ',a36)
2017  format(' The whole reassembled system is saved as chain A',/,
     -  ' If there are more chains, TER records can be inserted ',
     -  'with a text editor and the chain IDs modified accordingly')
2018  format('REMARK The moving atoms are saved as chain A')
2019  format('CONECT',2i5)
2020  format('MODEL ',i5)
2021  format('ENDMDL')
2022  format(a,' Full configuration reassembled')
2023  format('REMARK SACP B=',f9.2,' N=',i8)
2024  format('REMARK E=',e16.8,' (kcal/mol)',' Eslt=',e13.6)
3000  format(' +++++ ',a,' configuration written on file ',a,' at Nmc=',
     -  i10,/,7x,'File contains',i6,' atoms,',i4,' solute molecule(s) ',
     -  'and ',i5,' solvents')
3001  format(' The data represent differences')
3002  format(' ***** ERROR: invalid file type key: ',a,
     -  ' only PDB* or CHR* are allowed')
3003  format(' ----- WARNING: without the CSEG key, only one-character',
     -  ' segment ids will be written')
3004  format(' SAVEPDB key=',a4,' keycol=',2i3,' nslt1,nslt,nsvp=',3i8)
3005  format(' SAVEPDB nmolec,nattot,nats=',3i8)
3006  format(' ===== STRONG WARNING: number of atoms in the CRD file ',
     -  'will be set to 99999 instead of ',i6)
3007  format(' SAVEPDB message=',a)
3008  format(7x,'Data after the',a,'coordinates:',5x,a36,2x,a36)
3009  format(7x,'Use PDBT REGU to make atomnames to PDB-compliant')
      end
      subroutine pdblim(key,natres,natresw,maxar,name,ityp,nwwarn,iout)
c#    MMC routine  89 lstmod: 09/14/01
c*****Check atom and residue numbers against PDB limits
      character*4 key
      character*(*) name
      common /warncount/ ichsegwarn,ipdbcherr(11)
      if (natres .gt. maxar) then
        if (natres .eq. maxar+1 .and. ipdbcherr(ityp) .eq. 0) then
          write (iout,3000) name,natres,maxar,key
          nwwarn=nwwarn+1
          ipdbcherr(ityp)=1
        end if
        natresw=mod(natres,maxar)
      else
        natresw=natres
      end if
      return
3000  format(' ===== STRONG WARNING: the number of ',a,'s (',i7,') ',
     -  'exceeds ',i6,' when writing a ',a,' file ',/,
     -  7x,'- leading digits will be dropped')
      end
      subroutine adjustpdbname(inp,out,itype)
c#    MMC routine  90 lstmod: 09/12/02
c*****Convert back/forth from PDB and Charmm conventions
      character*4 inp,out,regg,inpl
      if (itype .eq. 0) then
        out=inp
      else if (itype .eq. 2) then
        call leftadjust(inp,inpl,4)
      else
c       Regularize
        regg='    '
        call leftadjust(inp,inpl,4)
c       write (77,*) 'REGPDB inp=',inp,' inpl=',inpl,' itofrom=',itofrom
        if (inpl(1:1) .eq. 'C' .or. inpl(1:1) .eq. 'O' .or.
     -    inpl(1:1) .eq. 'N' .or. inpl(1:1) .eq. 'S' .or.
     -    inpl(1:1) .eq. 'P') then
          regg(2:4)=inpl(1:3)
        else if (inpl(1:1) .eq. 'H' .or. inpl(1:1) .eq. 'D') then
          if (inpl .eq. 'H   ') then
            regg=' H  '
          else if (inpl .eq. 'D   ') then
            regg=' D  '
          else if (inpl(3:4) .eq. '  ') then
c           Two-character H name
            regg(2:3)=inpl(1:2)
          else if (inpl(4:4) .eq. ' ') then
c           Three-character H name
            regg(1:1)=' '
            regg(2:4)=inpl(1:3)
          else
c           Four-character H name
            regg(1:1)=inpl(4:4)
            regg(2:4)=inpl(1:3)
          end if
        else if (isdigit(inpl(1:1)) .eq. 1 .and. inpl(4:4).eq. ' ') then
           regg(2:3)=inpl(2:3)
           if (inpl(3:4) .eq. '  ') then
             regg(3:3)=inpl(1:1)
           else
             regg(4:4)=inpl(1:1)
           end if
        else
          regg=inpl
        end if
        out=regg
      end if
      return
      end
      subroutine leftadjust(inp,out,n)
c#    MMC routine  91 lstmod: 10/21/05
c     Left-adjust a string
      character*(*) inp,out
      i=1
      do while (i .lt. n .and. inp(i:i) .eq. ' ')
        i=i+1
      end do
      if (i .eq. 1 .or. (i .eq. n .and. inp(i:i) .eq. ' ')) then
        out=inp
        return
      else
        do j=i,n
          out(j-i+1:j-i+1)=inp(j:j)
        end do
        do j=n-i+2,n
          out(j:j)=' '
        end do
      end if
      return
      end
      subroutine echopr(iprintall)
c#    MMC routine  92 lstmod: 03/16/22
c*****Print the run characteristics
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /slfttolerance/ tol(10),tolr(10),told(10)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*80 scratchpath
      common /localdisk/ lscratchpath,scratchpath
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /tpn/ edgexyz0(3),edge2xyz0(3),rinscr0(3),vol0,cic0(3,27),
     -  dex0(5),dey0(5),dez0(5),chexdx0(2),chexy0(2),dexhex0(5),vrange,
     -  volfac(3),vlam,vlamt,vvlmt,vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyy,
     -  vvlmtzz,vvlmtyz,complfac,sqcomplfac,ixyzfreeze(3),iscaletyplast
      real*8 ediffsm,ediffsm2,expediffsm
      common /virtvolcha/ ediffsm,ediffsm2,expediffsm,ediffmn,ediffmx,
     -  volchaperc,volchafac(3),volchadiff(3),delvvol,delvarea
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /pretrans/ preshift(3),prerot(3,3),ipretrans
      common /liga/ ligand_start_molecule,last_slt_mol_g
      character*80 ident
      common /title/ nlident,ident(2)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /isoeng/ dimax,dijs,dijq,dijso,dijqo,eniemx,eniemo
      common /wadaptf/ ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,rldvmx,
     -  diffmx,tolera,iopnrm,iopeql,iopenc,nitssk,nwtst,nsubmn,ngovmn,
     -  ngrcor,negitdel
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      real*8 ucsm_prev,u_prev,uslt_prev,uttnb_prev,uinnb_prev
      common /anneal/ ucsm_prev,u_prev,uslt_prev,uttnb_prev,
     -  uinnb_prev,nmctempstep,ntemplist,ntempstep,ntempsteptot,
     -  ntempstepcum,isannread,templist(100),temp0,tempstep,tempexp,
     -  tempfin
      common /anneal_cp/ nmcsacpstep,nmcsacpsteppnmol,maxbsave,
     -  nstep_ann,nmcav0,nligsave(500),avgligsave(500),bsave(500),
     -  bincr,cav_fract_lim
      real*8 ew0nb,teslt1,teslt1n,uwnb,uwnbn,uwnbmin,uwnbmax,
     -  etsincr
      common /nonboltz/ ew0nb,teslt1,teslt1n,
     -  uwnb,uwnbn,uwnbmin,uwnbmax,etsincr,tornbfac,repnbfac,slttmp,
     -  sltsltfac,signincfac,tsexp,tsfac
      common /tdstate/ press,pressv,ba,temp,beta
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      common /cplp358/ cpl358(8,3),cq358(8,3),ixcpl(8)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      common /fblam/ wfblam(#PG),rfblam(9),afblam(9),nfblam
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /energymap/ engmap(#GM,#GM,#GM,10),gridmapcent(3),
     -  nemap,ngridmap,gridmap,edgemap,edgemap2,scalemap,evdwlim,
     -  elstatmin,hbgrid,gridedgeinc(3),egridmin(3),egridmax(3),
     -  mapedone,nhbgrid,maxhbng,maxhbgrid,maptyph,
     -  nhbaccng(#GH,#GH,#GH),nhbdonng(#GH,#GH,#GH),
     -  ihbng(25,#GH,#GH,#GH)
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      character*10 mapname
      common /engmapnames/ mapname(10)
      common /atd_lj_par/ c6(10,10),c12(10,10)
CJJ   variables
      real*8 setpoint,gain_n,gain_den,integraltime,oldpv,controlerror,
     -  dbetadt,dpvdt
      common /control/ setpoint,gain_n,gain_den,integraltime,oldpv,
     -  controlerror,dbetadt,dpvdt
      real*8 rnsumprev,uavcorprev,delndelbsum
      common /tuneb/ rnsumprev(2),uavcorprev,delndelbsum,nitconv,
     -  nunphys,nmctunskip,nmctunave,nmclastch,ntune,nmccorprev,
     -  ndelndelbsum,inorout,targetden,targetn,tolden,toln,delndelb0,
     -  rnaviprev,baprev,chabmax,pv
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /stepscale/ scalefactors(8),
     -  cedslv0,rtxslv0,cedslt0,rtxslt0,cedpslt0(3),rtxpslt0(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /overlay/ covref(3,#ST),rangerad,ixovref(#ST),
     -  icrefok,ixrefok,irangetyp,novuse
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      character*4 namfcg
      character*20 nmlfcg
      common /fcgnam/ igrdup(100),namfcg(100,2),nmlfcg(100,2)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      character*1 lxyz
      common /names/ lxyz(3)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      common /fieldpot/ niparf,nrparf,niparm,nrparm,intf(10),intm(10),
     -  rf(10),rm(10)
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /cqpen/ qnn(#TN,#VN),qne(#TN,#VE),qen(#TE,#VN),
     -  qee(#TE,#VE),aee(#TE,#VE),bee(#TE,#VE),cee(#TE,#VE),
     -  iopict,nsltn,nslvn,nslte,nslve
      common /cutinr/ rwwina,rwwin2
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      real*8 fsmslt,fsmslv,tsmslt,tsmslv,wpsmvi
      common /quantm/ fsmslt,fsmslv,tsmslt(3),tsmslv(3),wpsmvi,nsslt
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /bondmod/ nmake,imake(2,250),nbreak,ibreak(2,250),nhhb,nhrb
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      real*8 rstack,rix,rira,rirb
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
      common /lcg_const/ lcg_fac,lcg_add,lcg_seed,lcg_modexp,lcg_mod,i31
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      character*27 movename
      common /move_name/ movename(8)
      character*4 ipf
      character*5 pbcyn(2)
      character*8 namh2o,nammcy
      character*32 namstp
      common /pfnames/ ipf(11),namstp(11),namh2o(9),nammcy(3)
      common /ljprint/ ipflibprint,iprtlibcomb
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      character*15 selectname
      character*23 movname
      character*36 exbiname
      common /stratnames/ selectname(4),movname(7),exbiname(5)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      dimension idbpr(200),cm(3),crmcop(3,4),wmscop(4),dipxyz(3,4),
     -  diptot(4),qtot(4),radgrp(4),xyz(3),rtx3(3),wsltdif(7),nacp(4),
     -  ihbcount(4,10),ialist(8)
      character*1 lgc,lmc,qsumint(4),aromlab
      character*2 hbdonacclab
      character*3 tunit
      character*4 mark
      character*5 slft(3),rsltlab
      character*6 cellname(2),pfl
      character*7 inoutlab
      common /inoutlabel/ inoutlab(2)
      character*4 widomlab(3)
      character*11 stunen
      common /tunelab/ stunen(4)
      character*8 torsnames(8),molgroup(4),carbontyp
      character*30 looptypname
      common /loopnames/ looptypname(9)
      character*80 rngfile
      common /rnglist/ rnolist(#RN),nrand,irand,lrngfile,rngfile
      character*10 split_lab
      character*132 line
      data cellname /'cube  ','shpere'/, pbcyn /' PBC ','NOPBC'/,
     -  molgroup /2*'molecule',2*'group'/,
     -  slft /'Basic','Full ','Full '/,widomlab /'WIDO','CHIM','ADDW'/
c-----Compilation information
      if (iop(24) .gt. 0) call printcomp(iout,icompopt,ncompopt,
     -  sizesym,sizename,sizelname,optname,optlname,iasize,nasize,
     -  cmoddate,cpxmoddate,moddate,file,namlenf,nbits,0,0,nwarn)
c-----Run information
      write (iout,9001)
      write (iout,9025) ident
      write (iout,9431) numrun
      write (iout,9460) (rnbytyckp+rnbytypxc+rnbytyadd)/1000000.0
      if (ichkp .ne. 0) then
        write (iout,9436) 'Checkpoint',filenames(1)(1:namlens(1)),ichkp
        write (iout,9438) rnbytyckp/1000000.0
      end if
      if (ichkpx .ne. 0) then
        write (iout,9436)
     -    'Proximity checkpoint',filenames(6)(1:namlens(6)),ichkpx
        write (iout,9438) rnbytypxc/1000000.0
      end if
      if (lscratchpath .gt. 0)
     -   write (iout,9441) scratchpath(1:lscratchpath)
      if (iop(40) .gt. 0) write (iout,9439) nsavckpf
      if (iop(160) .eq. 0) then
        if (iop(41) .gt. 0) then
          write (iout,7101) ba
        else if (iop(71) .gt. 0) then
          write (iout,7102) press,vrange
          if (iop(41) .gt. 0) then
            write (iout,9023) 'grand-canonical ensemble'
            inperr=inperr+1
          end if
        else
           write (iout,7100)
        end if
        if (iop(71) .gt. 0) then
          if (iop(72) .eq. 0) then
             write (iout,7200)
          else
             write (iout,7800) complfac
            if (iop(72) .eq. 1) then
              write (iout,7210)
              do k=1,3
                if (ixyzfreeze(k) .eq. 1) write (iout,7211) lxyz(k)
              end do
            end if
            if (iop(72) .eq. 2)
     -        write (iout,7200) ' only in the Y and Z directions'
          end if
          if (iop(30) .gt. 3) then
            write (iout,9023) 'do free-energy simulations'
            inperr=inperr+1
          end if
          if (iop(67)+iop(108) .gt. 0) then
            write (iout,9023) 'use external potentials'
            inperr=inperr+1
          end if
          if (iop(57) .gt. 0 .and.
     -      (movmolf .ne. 1 .or. movmoll .ne. nsttm)) then
            write (iout,9023) 'keep some of the solute molecules fixed'
            inperr=inperr+1
          end if
        end if
        write (iout,9360) nmcmax,nmcrep,nrecd,ncntin,nplt,nmcslftst
        if (iop(124) .eq. 0) write (iout,9361) rix,ixo
        if (iop(124) .eq. 1)
     -    write (iout,9364) lcg_fac,lcg_add,lcg_modexp,lcg_seed
        if (iop(124) .eq. 2) write (iout,9365) ixmt
        if (nmccd .gt. 0) write (iout,9359) 'energy and geometry',nmccd
        if (nmccd .ne. nmccgd) write (iout,9359) 'geometry only',nmccgd
        if (iop(58) .gt. 0) then
          do im=1,nsttm
            limbr=max0(100,idebug(116))
            if (maxbrlen(im) .gt. limbr)
     -        write (iout,9356) im,maxbrlen(im),max0(100,idebug(116))
          end do
        end if
        if (iop(87) .gt. 0) write (iout,8710)
        if (iop(9) .eq. 1 .or. iop(9) .eq. 2 .and.
     -    (iop(41)+iop(71) .gt. 0 .or. iop(57)+iop(58) .gt. 0)) then
            if (iop(41) .gt. 0) write (iout,9433) 'grand-canonical'
            if (iop(71) .gt. 0) write (iout,9433) 'isothermal-isobaric'
            if (iop(57)+iop(58) .gt. 0)
     -         write (iout,9433) 'non-rigid solute'
            inperr=inperr+1
        end if
        if (iop(30) .eq. 7 .or. iop(57)+iop(58) .gt. 0) then
          if (iop(127) .gt. 0) write (iout,9523)
          if (iop(127) .gt. 1) write (iout,9524)
        else if (iop(127) .gt. 0) then
          write (iout,9525)
          nchng=nchng+1
        end if
        if (iop(41) .gt. 0) then
          if (idrepf .eq. 0) idrepf=nmcrep
          write (iout,9392) idfreq,idrepf
          if (nmcransh .gt. 0) write (iout,9393) nmcransh
          if (iop(42) .gt. 0) write (iout,4210)
     -      filenames(5)(1:namlens(5)),iindel
          if (iop(42) .eq. 2) then
            write (iout,4212) rpxidlim
            if (iop(17) .ne. 1) then
              write (iout,4213)
              inperr=inperr+1
            end if
          end if
          if (iop(22) .eq. 1) write (iout,4214) rpxidlim
          if (npxkeep .gt. 0) write (iout,4215)
     -      ((ipxkeep(k,i),k=1,2),i=1,npxkeep)
          if (iop(9) .eq. 10 .or. iop(9) .eq. 11) then
            write (iout,9406) 'Charmm or Amber','grand-canonical'
            inperr=inperr+1
          end if
          if (iop(21) .eq. 3) then
c           Check for options not yet parallelized in indlgr
            if (iop(92) .gt. 0 .or. iop(30) .gt. 0) then
              write (iout,4190)
              inperr=inperr+1
            end if
          end if
          if (iop(67) .gt. 0) then
            write (iout,4191) 'SPST'
            inperr=inperr+1
          end if
          if (iop(108) .gt. 0) then
            write (iout,4191) 'SPPS'
            inperr=inperr+1
          end if
        end if
        if (iop(71) .gt. 0) write (iout,9396) nvchfreq
        if (iop(106) .gt. 0) then
          if (iop(106) .eq. 1) write (iout,9455) 'Pressure'
          if (iop(106) .gt. 1) then
            write (iout,9455) 'Surface tension',
     -      ' surface normal: ',lxyz(iop(106)-1)
            if (iop(5) .ne. 0) then
              write (iout,9457)
              inperr=inperr+1
            end if
          end if
          write (iout,9456) nvvchfreq,volchaperc
        end if
      end if
      if (iop(49) .eq. 1) write (iout,4910)
      if (idstr .gt. 0) write (iout,9014) 'Distribution',
     -  filenames(4)(1:namlens(4)),idstr
      if (icompopt(14)*icompopt(15) .eq. 1) then
        write (iout,9428) 'MPI-DM/noMPI-DM','DM','ND'
        inperr=inperr+1
      end if
      if (icompopt(15)+icompopt(31) .eq. 0) then
        write (iout,9429) 'MPI-DM/noMPI-DM','DM','ND'
        inperr=inperr+1
      else if (icompopt(15)+icompopt(31) .eq. 2) then
        write (iout,9430) 'MPI-DM/noMPI-DM','DM','ND'
        inperr=inperr+1
      end if
      if (icompopt(18)+icompopt(30) .eq. 0) then
        inperr=inperr+1
        write (iout,9429) 'vector/novector','VC','NV'
      else if (icompopt(18)+icompopt(30) .eq. 2) then
        inperr=inperr+1
        write (iout,9430) 'vector/novector','VC','NV'
      end if
      if (icompopt(26)+icompopt(33) .eq. 0) then
        inperr=inperr+1
        write (iout,9429) '1/r dielectric - normal dielectric','1R','NR'
      else if (icompopt(26)+icompopt(33) .eq. 2) then
        inperr=inperr+1
        write (iout,9430) '1/r dielectric - normal dielectric','1R','NR'
      end if
      if (icompopt(25)+icompopt(26) .eq. 2) then
        inperr=inperr+1
        write (iout,9458) '1R','DD'
      end if
      if (icompopt(10)+icompopt(4) .eq. 2) then
c       SGI requires arithmetic bitmap handling
        write (iout,9015)
        inperr=inperr+1
      end if
      if (iop(21) .eq. 3) write (iout,2130)
      if ((iop(5) .ge. 1 .and. iop(5) .le. 3)
     -     .and. iop(2) .gt. 0) then
        inperr=inperr+1
        write (iout,9030)
      end if
      if (ihist .gt. 0) write (iout,9014) 'History',
     -  filenames(3)(1:namlens(3)),ihist
      if (iop(9) .eq. 1) write (iout,0910)
     -  'moved solvent binding energy'
      if (iop(9) .eq. 2) write (iout,0910)
     -  'virial sum'
      if (iop(9) .eq. 3) write (iout,0930)
      if (iop(9) .eq. 4) write (iout,0940) 'MMC alphanumeric'
      if (iop(9) .eq. 5) write (iout,0940) 'MMC annotated alphanumeric'
      if (iop(9) .le. 5 .and. iop(9) .gt. 0) then
        if (iop(59) .eq. 0) write (iout,0951)
        if (iop(59) .eq. 1) write (iout,0952)
        if (iop(59) .eq. 2) write (iout,0953) 'solvent'
        if (iop(59) .eq. 2) write (iout,0953) 'solute'
      end if
      if (iop(9) .eq. 6) write (iout,0940) 'MMC binary'
      if (iop(9) .eq. 7) write (iout,0940) 'PDB'
      if (iop(9) .eq. 8) write (iout,0940) 'MODEL/ENDMDL PDB'
      if (iop(9) .eq. 9) write (iout,0940) 'Charmm CRD'
      if (iop(9) .eq. 10) write (iout,0940) 'Amber'
      if (iop(9) .eq. 11) write (iout,0940) 'Charmm DCD'
      if (iop(9) .gt. 3 .and. iop(160) .eq. 0) write (iout,0941) nmcrec
      if (iop(121) .gt. 0) then
        if (iop(121) .eq. 1)
     -    write (iout,1211) 'structure read with the CNFG key'
        if (iop(121) .eq. 2)
     -    write (iout,1211) 'first structure read from the trajectory'
        if (irangetyp .eq. 0) write (iout,1212)
        if (irangetyp .gt. 0)
     -    write (iout,1213) rangerad,irangetyp
        if (novuse .gt. 0) write (iout,1214) novuse
      end if
      if (iop(148) .gt. 0) write (iout,1480)filenames(46)(1:namlens(46))
      if (iop(109) .gt. 0) then
        if (natoms .gt. #NE) then
          write (iout,0944) 'NE',natoms
          inperr=inperr+1
        end if
        if (iop(9) .eq. 1) write (iout,0942) nmcrec
        if (iop(9) .eq. 2) write (iout,0943)
      end if
      if (iop(4) .eq. 1) write (iout,0410)
      if (iop(4) .eq. 0) then
        write (iout,0420)
      else
        if (iop(32) .eq. 0) write (iout,3210)
        if (iop(57) .gt. 0) then
          write (iout,0421) ' ===== STRONG','molecule moves (PARDD)'
          nwwarn=nwwarn+1
        end if
        if (iop(58) .gt. 0) then
          write (iout,0421) ' -----','torsions (PART)'
          nwarn=nwarn+1
        end if
      end if
      if (iop(111) .gt. 0) write (iout,0490)((exyzabc(k,i),k=1,3),i=1,3)
      if (iop(48) .eq. 0) write (iout,1320) 'stop','startup'
      if (iop(48) .eq. 1) write (iout,1320) 'continue to run',
     -  'startup'
      if (iop(48) .eq. 2) write (iout,1320) 'make an attempt to fix',
     -  'startup'
      if (iop(13) .gt. 0) then
        write (iout,1310) slft(iop(13)),nmcrep
        if (iop(94) .eq. 0 .or. iop(94) .eq. 3) write (iout,1320)
     -    'stop','SLFT-requested'
        if (iop(94) .eq. 1) write (iout,1320) 'continue to run',
     -    'SLFT-requested'
        if (iop(94) .eq. 2 .or.iop(94) .eq. 3) write (iout,1320)
     -    'make an attempt to fix','SLFT-requested'
        if (iop(94) .eq. 2) write (iout,9449) 'Stop'
        if (iop(94) .eq. 3) write (iout,9449) 'Continue'
        if (iop(94) .eq. 4)
     -    write (iout,9440) filenames(14)(1:namlens(14)),ickpok
      end if
      if (iop(98) .eq. 1) write (iout,9810) 'regular PDB'
      if (iop(98) .eq. 2) write (iout,9810) 'left-adjusted'
      if (iop(95) .eq. 0) write (iout,1320) 'stop','compulsory'
      if (iop(95) .eq. 1) write (iout,1320) 'continue to run',
     -  'compulsory'
      if (iop(95) .eq. 2) write (iout,1320) 'make an attempt to fix',
     -  'compulsory'
      write (iout,1300) tol
c-----Potential function information
      write (iout,9002)
      if (iop(21) .eq. 0) write (iout,2100)
      if (iop(21) .eq. 1) write (iout,2110)
      if (iop(21) .eq. 2) write (iout,2120)
      do ip=1,9
        if (npfused(ip) .gt. 0) write (iout,0300) npfused(ip),namstp(ip)
      end do
      if (iop(3) .eq. 8 .and. iop(31) .eq. 0) write (iout,3100)
      if (iop(3) .eq. 8 .and. iop(31) .eq. 1) write (iout,3110)
      if (iop(60) .eq. 1) write (iout,6010) c12prot
      if (dielcau .gt. 1.0) then
        write (iout,6011) dielcau
        if (nmolec .gt. 1) then
          write (iout,6012)
          nwwarn=nwwarn+1
        end if
      end if
      if (iop(67) .gt. 0 .and. iop(67) .le. 3) then
        write (iout,6712) ngridmap,gridmap,edgemap,gridmapcent,evdwlim,
     -    elstatmin,(iatnam(iatdatnos(i)),i=1,nemap)
        if (iop(67) .eq. 1) write (iout,6723) 'read from files'
        if (iop(67) .eq. 2 .or. iop(67) .eq. 3)
     -    write (iout,6723) 'calculated from scratch'
        if (iop(67) .eq. 3) write (iout,6723) 'also written to files'
        if (scalemap .ne. 1.0) write (iout,6726) scalemap
        if (iop(67) .eq. 2 .or. iop(67) .eq. 3) then
          if (iop(113) .gt. 0 .and. iop(113) .ne. 5) then
            write (iout,6728)
            nwwarn=nwwarn+1
          end if
          write (iout,6729) (mapname(i),i=1,7)
          do i=1,7
            write (iout,6730) mapname(i),' c6',(c6(i,j),j=1,7)
            write (iout,6730) mapname(i),'c12',(c6(i,j),j=1,7)
          end do
        end if
        write (iout,6732) 'Largest outside',
     -    ((lxyz(k),devmax_xyz(i,k),i=1,2),k=1,3)
        write (iout,6732) 'Smallest inside',
     -    ((lxyz(k),devmax_xyz(i,k),i=3,4),k=1,3)
      else if (iop(67) .eq. 4) then
        write (iout,6740) (lxyz(intf(1)),rf(i),i=1,2)
        if (rf(2) .gt. rf(1)) then
          write (iout,6741)
          inperr=inperr+1
        end if
      else if (iop(67) .gt. 4) then
        if (niparf .gt. 0) write (iout,6710) (intf(i),i=1,niparf)
        if (nrparf .gt. 0) write (iout,6711) (rf(i),i=1,nrparf)
      end if
      if (iop(67) .ge. 1 .and. iop(67) .le. 3 .or. iop(113) .gt. 0)
     -  write (iout,6714) 'AROM: Aromatic carbon types',
     -    (ipf((iaromc(i)-1)/#AT),pflab(mod(iaromc(i)-1,#AT)+1,
     -    (iaromc(i)-1)/#AT),i=1,naromc)
c     Remember: ict=icl+#AT*ioppf
      if (iop(112) .gt. 0) then
        if (iop(112) .eq. 2 .and. iop(30) .eq. 3) then
          write (iout,6787)
          inperr=inperr+1
        end if
        write (iout,6789) sqrt(rminhb2),rmaxhb
        call zeroiti(ihbcount,0,4*10)
        do ia=1,nstta
          if (ihbdonacc(ia) .gt. 0) then
            ihbcount(1,ihbdonacc(ia))=ihbcount(1,ihbdonacc(ia))+1
          else if (ihbdonacc(ia) .lt. 0) then
            ihbcount(2,-ihbdonacc(ia))=ihbcount(2,-ihbdonacc(ia))+1
          end if
        end do
        do ja=1,nhbdonaccp
          ia=indexhb(ja)
          if (ihbdonacc(ia) .gt. 0) then
            ihbcount(3,ihbdonacc(ia))=ihbcount(1,ihbdonacc(ia))+1
          else if (ihbdonacc(ia) .lt. 0) then
            ihbcount(4,-ihbdonacc(ia))=ihbcount(2,-ihbdonacc(ia))+1
          end if
        end do
        do i=1,nhbdontyp
          write (iout,6794) i,hbdonlab(i),ihbcount(1,i),ihbcount(3,i)
        end do
        write (iout,6793) 'donor',qsalthbdonmin,'>',hbdonlab(3),'donor'
        write (iout,6793)
     -    'acceptor',qsalthbaccmax,'<',hbacclab(3),'acceptor'
        do i=1,nhbacctyp
          write (iout,6795) i,hbacclab(i),ihbcount(2,i),ihbcount(4,i)
        end do
        do i=1,nhbdontyp
          do j=1,nhbacctyp
            ixhb=ixdonacc(i,j)
            if (ixhb .gt. 0) write (iout,6792)
     -        hbdonlab(i),hbacclab(j),cohhb12(ixhb),
     -        hbdonlab(i),hbacclab(j),cohhb10(ixhb),
     -        sqrt(rminhbheavy2(ixhb)),ixhb
          end do
        end do
       if (nhbexclude .gt. 0)  write (iout,6714)
     -  'HBEX: types excluded from hydrogen bonding',
     -    (ipf((ityphbexclude(i)-1)/#AT),
     -    pflab(mod(ityphbexclude(i)-1,#AT)+1,
     -    (ityphbexclude(i)-1)/#AT),i=1,nhbexclude)
        if (ihbtypsltslt .eq. 0)
     -    write (iout,6727) ' inter',' hydrogen-bond '
        if (ihbtypsltsltself .eq. 0)
     -    write (iout,6727) ' intra',' hydrogen-bond '
        if (ihbtypsltslt .eq. 0)
     -    write (iout,6727) ' map',' hydrogen-bond '
        if (ihbtypsltslt .eq. 1) write (iout,6786) 'solute','-'
        if (ihbtypsltslt .eq. 2) write (iout,6786) 'solute','-',
     -    '^',iexptheta,iexpomega,2.0*acos(ecocoef)*rdtodg
        if (ihbtypsltmap .eq. 1) write (iout,6786) 'map','-'
        if (ihbtypsltmap .eq. 2) write (iout,6786) 'map','-',
     -    '^',iexptheta,iexpomega,2.0*acos(ecocoef)*rdtodg
        if (ihbtypsltmap .gt. 0) write (iout,6731) hbgrid,nhbgrid
      end if
      if (iop(113) .gt. 0) then
        write (iout,6715) qk_par,sqrt(gaussdist2/2.0)
        do m=1,6
          carbontyp='        '
          if (m .eq. 2) carbontyp='aromatic'
          write (iout,6716)
     -      iatnam(iatdatnos(m)),carbontyp,a_solv_par(m),v_solv_par(m)
        end do
        gdfac=gaussdistlim/gaussdist2
        if (gdfac .lt. 20.0)
     -     write (iout,6717) sqrt(gaussdistlim),gdfac
        if (iop(113) .eq. 2) write (iout,6718)
        if (iop(113) .eq. 3) write (iout,6719)
        if (iop(113) .eq. 4) write (iout,6722)
        if (iop(113) .eq. 5) write (iout,6724)
        if (iop(113) .eq. 4 .or. iop(113) .eq. 5)
     -    write (iout,6725) qpolarcarbmin
        if (iopdesolv .eq. 0)
     -    write (iout,6727) 'Inter',' desolvation '
        if (iopdesolvself .eq. 0)
     -    write (iout,6727) 'Intra',' desolvation '
      end if
      if (iop(117) .gt. 0) then
        write (iout,9530) nconstr_pair
        if (iop(117) .eq. 2 .or. iop(117) .eq. 4) write (iout,9529)
        call echo_cnst(iorig_of_split,c,labslt,'start',5,1,iout,#ST)
        if (iop(117) .gt. 2) write (iout,9528)
      end if
      if (iop(108) .gt. 1) then
        write (iout,6720) (intm(i),i=1,niparm)
        write (iout,6721) (rm(i),i=1,nrparm)
      end if
      if (iop(46) .eq. 1) write (iout,4610)
      if (iop(52) .eq. 0) write (iout,5200)
      if (iop(52) .eq. 1) write (iout,5210)
      if (numsolv .gt. 0) then
        if (iop(26) .eq. 0) write (iout,2600)
        if (iop(26) .eq. 1) write (iout,2610)
        if (iop(26) .eq. 2) write (iout,2620)
        if (iop(26) .eq. 3) write (iout,2630)
        if (iop(26) .ge. 1 .and. iop(26) .le. 3)
     -    write (iout,2612) alj6,blj12,qh,namh2o(iop(37)+1)
        if (iop(26) .eq. 0) write (iout,2613) nammcy(iop(37)+1)
        if (iop(26) .eq. 4) write (iout,2640) namstp(iop(37))
        if (iop(125) .eq. 1) write (iout,2699)
        if (iop(39) .eq. 0) write (iout,3900)
        if (iop(39) .eq. 1) write (iout,3901)
        if (iop(7) .eq. 0) write (iout,0700) cutslt
        if (iop(7) .eq. 1) write (iout,0710)
        if (iop(7) .eq. 2) write (iout,0720) cutslt,dimax,eniemx
      end if
      if (iop(57)+iop(58)+iop(174) .gt. 0 .or.
     -    (nstta .gt. nstfa .and. nstfa .gt. 0)) then
        if (iop(65) .eq. 0) write (iout,6500)
        if (iop(65) .eq. 1 .or. iop(65) .eq. 3)
     -    write (iout,6510) molgroup(iop(65))
        if (iop(65) .eq. 2 .or. iop(65) .eq. 4)
     -    write (iout,6511) molgroup(iop(65)),cutuu
      end if
      if (iop(58)+iop(174) .gt. 0 .or. iop(18) .eq. 4 .or.
     -    iop(30) .eq. 3) then
        write (iout,5722) esf14,vdwf14
      else if (fcintra .ne. 1.0) then
        write (iout,5725)
        nwarn=nwarn+1
      end if
      if (fcintra .eq. 0.0) then
        write (iout,5723)
      else if (fcintra .lt. 1.0) then
        write (iout,5724) fcintra
      end if
      if (nmolec .gt. 2) then
        if (iop(119) .eq. 0) then
          if (iop(54) .eq. 0) write (iout,5400) cutslv
          if (iop(54) .eq. 1) write (iout,5410)
          if (iop(43) .eq. 0 .and. nstta .gt. 0) write (iout,4300)
     -      'center-of-mass of the whole solute'
          if (iop(43) .eq. 1 .and. nstta .gt. 0) write (iout,4300)
     -      'nearest solute group center'
          if (iop(26) .eq. 0) write (iout,5401) cutexp
          if (iop(33) .eq. 0) write (iout,3300)
          if (iop(33) .eq. 1) write (iout,3310) rwwina,rwwin2
        else
          write (iout,5490)
C@NN          write (iout,5491)
C@NN          nwarn=nwarn+1
        end if
      end if
      if (icompopt(2) .eq. 0) then
        if (iop(57)+iop(58) .gt. 0 .or. iop(30) .eq. 7) then
          write (iout,9437)
          write (iout,9447) 'TN'
          inperr=inperr+1
        else if ((iop(30) .gt. 0 .and. iop(30) .lt. 4 .and. nstta .gt.
     -            nstfa) .or.
     -    (nstta .gt. 0 .and. (iop(30) .eq. 0 .or. iop(30) .ge.4))) then
          write (iout,9435)
          nwarn=nwarn+1
        end if
      end if
      if (icompopt(1)+icompopt(2) .gt. 0) then
c       Near-neighbour bitmap is used
C@NL        write (iout,9414) 'NL','LOGICAL'
C@NA        write (iout,9414) 'NA','ARITHMETICAL'
        if (icompopt(3)+icompopt(4) .eq. 0) then
          inperr=inperr+1
          write (iout,9416)
        else if (icompopt(3)+icompopt(4) .eq. 2) then
          inperr=inperr+1
          write (iout,9417)
        end if
      end if
C@NN      if (nmolec .gt. 1 .or. iop(41) .gt. 0) write (iout,9092) rccomp
      if (rccon .gt. 0.0) then
        write (iout,9443) epsrf
        if (icompopt(6) .gt. 0) then
          write (iout,6013)
          nwwarn=nwwarn+1
        end if
        if (iop(7) .eq. 1 .or. iop(54) .eq. 1 .or. iop(65) .eq. 1 .or.
     -      iop(65) .eq. 3) then
          write (iout,9444)
          inperr=inperr+1
        end if
      end if
      if (rk_ddd .ne. 0.0) then
        write (iout,9931)
     -    a_ddd,eps0_ddd,a_ddd,rk_ddd,rlambda_ddd,eps0_ddd,a_ddd
        if (rmin_ddd .gt. 0.0) write (iout,9933) '<',rmin_ddd,epsmin_ddd
        if (nmolec .gt. 1 .and. iop(26) .ne. 4) then
          write (iout,6014)
          nwwarn=nwwarn+1
        end if
        call checkcompopt(icompopt(25),'SETC DDIE','DD',inperr,iout)
        if (dielcau .gt. 1.0) then
          write (iout,9930)
          inperr=inperr+1
        end if
      else
        if (icompopt(25) .gt. 0) then
          write (iout,9423)
          nwwarn=nwwarn+1
        end if
      end if
      if (icompopt(26) .gt. 0) write (iout,9424)
      if (icompopt(25)+icompopt(26) .gt. 0 .and. nmolec .gt. 1) then
        write (iout,9425)
        nwwarn=nwwarn+1
      end if
c-----Starting configuration info
      if (icord .gt. 0) then
        write (iout,9003)
        if (iop(50) .eq. 1) write (iout,5010) 0.01,'SLTA'
        if (iop(50) .eq. 2) write (iout,5010) 0.001,'SLTA'
        if (iop(50) .eq. 3) write (iout,5010) 0.01,'CNFG'
        if (iop(50) .eq. 4) write (iout,5040)
        if (iop(11) .eq. 0) write (iout,1100)
        if (iop(11) .eq. 1) write (iout,1110)
        if (iop(11) .eq. 6) write (iout,1160)
        if (iop(11) .eq. 7)
     -    write (iout,1170) filenames(3)(1:namlens(3))
        if (iop(11) .eq. 2) write (iout,1120)
        if (iop(11) .eq. 3) then
          write (iout,1130)
          if (iop(58) .gt. 0) write (iout,1131)
        end if
        if (iop(11) .eq. 4) write (iout,1140)
        if (iop(102) .gt. 0) write (iout,1021)
        if (iop(90) .gt. 0) write (iout,9010)
        if (iop(47) .eq. 0) write (iout,4700)
     -     filenames(2)(1:namlens(2)),'formatted',icord
        if (iop(47) .eq. 1) write (iout,4700)
     -     filenames(2)(1:namlens(2)),'binary',icord
        if (iop(47) .eq. 2) write (iout,4700)
     -     filenames(2)(1:namlens(2)),'formatted and annotated',icord
        if (iop(47) .eq. 3) write (iout,4700)
     -     filenames(2)(1:namlens(2)),'in PDB format',icord
        if (iop(47) .eq. 4) write (iout,4700)
     -     filenames(2)(1:namlens(2)),'in Charmm CRD format',icord
        if ((iop(11) .eq. 3 .or. iop(11) .eq. 4) .and. iop(27) .eq. 2)
     -    write (iout,2720) pmvslt,pmvslv,rnshll
        if ((iop(11) .eq. 3 .or. iop(11) .eq. 4) .and. iop(27) .eq. 1)
     -    write (iout,2710) pmvslt,pmvslv
        if (iop(45) .gt. 0) then
          write (iout,4510)
          if (iop(11) .ne. 3 .and. iop(11) .ne. 4) then
            write (iout,9410)
            inperr=inperr+1
          end if
          if (iop(30) .ge. 7) then
            write (iout,9411)
            inperr=inperr+1
          end if
        end if
      end if
c-----Free energy info
      if (iop(30)+iop(41) .gt. 0) write (iout,9004)
      iftg=1
      if (iop(30) .eq. 1) then
        write (iout,3010) diamslv,ngrid,nwitry,nwgtry
        do k=1,3
          if (ishifttp(k) .eq. 0) write (iout,3012) 'random',lxyz(k)
          if (ishifttp(k) .eq. 1) write (iout,3012) 'no',lxyz(k)
          if (ishifttp(k) .eq. 2) write (iout,3012) 'constant',lxyz(k)
        end do
        if (diamslv .eq. 0) write (iout,3011)
        if (iop(79) .gt. 0) write (iout,7900) (pbcyn(limgrl(k)+1),
     -    edgelgr(k),edgergr(k),pbcyn(limgru(k)+1),k=1,3)
      else if (iop(30) .eq. 2) then
        write (iout,3020) nwitry
        if (iop(28) .le. 3) write (iout,3021) lxyz(iop(28))
        if (iop(28) .eq. 4) write (iout,3022) rnearchim,pfarchim
      else if (iop(30) .eq. 3) then
        write (iout,3030)
        if (nwitry .gt. 1) write (iout,3033) 'main anchor atom',nwitry
        if (nwgtry .gt. 1) write (iout,3033) 'new group',nwitry
        if (nmcransh .gt. 0) write (iout,3034) nmcransh
        call checkcompopt(icompopt(2),'FREE ADDW','TN',inperr,iout)
      end if
      if (iop(30) .eq. 1 .or. iop(30) .eq. 2) then
        do im=1,nmolwid
          write (iout,3015) widomlab(iop(30)),im,fcglab(molcnt(im)),
     -      ew0(im)
          if (ifdummy(im) .gt. 0) then
            write (iout,3013)
            if (qslt(ifirstm(im)-1) .ne. 0.0) then
              write (iout,3014) qslt(ifirstm(im)-1)
              inperr=inperr+1
            end if
          end if
        end do
      else if (iop(30) .eq. 3) then
        if (iop(105) .eq. 0) write (iout,9950) 'fixed'
        if (iop(105) .eq. 1) write (iout,9950) 'changing'
        do im=1,nmolwid
          write (iout,3015) widomlab(iop(30)),im,fcglab(molcnt(im)),
     -      ew0(im)
          ntmust=0
          if (nwitry .gt. 1) ntmust=ntmust+1
          if (nwgtry .gt. 1) ntmust=ntmust+1
          if (ilastt(im)-ifirstt(im)+1 .ne. ntmust) then
            write (iout,3032) im,fcglab(molcnt(im)),ntmust,
     -        ifirstt(im),ilastt(im)
            inperr=inperr+1
          end if
        end do
c       Check if anchor atoms match
        igcentanchor=0
        do ia=1,nghanchor
          iaa=ighanchor(ia)
          if (iaa .gt. 0) then
            if (igrcnt(igrslt(iaa)) .eq. iaa) igcentanchor=ia
            if (molcnt(iamolslt(iaa)) .eq. iaa) imcentanchor=ia
            write (iout,9453) ia,iaa,(cslt(k,iaa),k=1,3),
     -       (labslt(k,iaa),k=1,2)
            do ja=1,ia-1
              rijr2=arrdist(cslt(1,ighanchor(ia)),cslt(1,ighanchor(ja)))
              do im=1,nmolwid
                rijw2=arrdist(cslt(1,ifirstm(im)+ia-1),
     -            cslt(1,ifirstm(im)+ja-1))
                rijdiff=abs(sqrt(rijr2)-sqrt(rijw2))
                if (rijdiff .gt. 0.01) then
                  write (line,3031) ia,ja,im,fcglab(molcnt(im)),
     -              sqrt(rijw2),sqrt(rijr2),rijdiff
c                 Only complain if ighanchor(ia) and ighanchor(ja) are bonded
c                 or ligand is assumed to be fixed
                  call checkifbond(iajabond,iaa,ighanchor(ja),nneig,
     -              ineig,#NL,#ST)
                  if (iajabond .eq. 1 .or. iop(105) .eq. 0) then
                    if (rijdiff .lt. 0.1) then
                      write (iout,9905) '----- WARNING',line(1:110)
                      nwarn=nwarn+1
                    else if (rijdiff .lt. 1.0) then
                      write (iout,9905)
     -                  '===== STRONG WARNING',line(1:110)
                      nwwarn=nwwarn+1
                    else
                      write (iout,9905) '***** ERROR',line(1:110)
                      inperr=inperr+1
                    end if
                  end if
                end if
              end do
            end do
          else
            write (iout,9454) -iaa,(labslt(k,-iaa),k=1,2)
          end if
        end do
c       Check if replacement atom is bonded to the last ghost atom's image
        call checkifbond(iajabond,ighanchor(nghanchor+1),
     -    ighanchor(nghanchor),nneig,ineig,#NL,#ST)
        if (iajabond .eq. 0) then
          write (iout,9908) ighanchor(nghanchor+1),ighanchor(nghanchor)
          inperr=inperr+1
        end if
c       Check if all Widom molecs have the same centers as the ligand
        if (igcentanchor .eq. 0) then
          write (iout,9906)
          inperr=inperr+1
        else
          do im=1,nmolwid
            if (iop(65) .eq. 1 .or. iop(65) .eq. 2) then
              imc=molcnt(iamolslt(ifirstm(im)))
              if (im .gt. 1) imc=imc-ilastm(im-1)
              if (imc .ne. imcentanchor) then
                write (iout,9907) 'molecule',im,imc,imcentanchor
                inperr=inperr+1
              end if
            else
              igc=igrcnt(igrslt(ifirstm(im)))
              if (im .gt. 1) igc=igc-ilastm(im-1)
              if (igc .ne. igcentanchor) then
                write (iout,9907) 'group',im,igc,igcentanchor
                inperr=inperr+1
              end if
            end if
          end do
        end if
      end if
      if (iop(41) .gt. 0) then
        if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
          write (iout,4110) diamslv,ngrid,grid
          if (amax1(grid(1),grid(2),grid(3)) .gt. 0.5) then
            write (iout,4114)
            nwarn=nwarn+1
          end if
          if (iop(79) .gt. 0) write (iout,7900) (pbcyn(limgrl(k)+1),
     -      edgelgr(k),edgergr(k),pbcyn(limgru(k)+1),k=1,3)
          if (iop(62) .eq. 0)
     -       write (iout,6200) 'standard Van der Waals radii'
          if (iop(62) .eq. 1) write (iout,6200) 'Lennard-Jones sigmas'
          if (iop(62) .eq. 2) write (iout,6200)
     -      'Lennard-Jones sigmas; hydrogen sigma <= 1.0'
          if (iop(63) .gt. 0) then
            write (iout,6301)
            if (iop(63) .eq. 1) write (iout,1240)
     -        ('r',rpfid(i),apfid(i),i=1,npfid)
            if (iop(63) .eq. 2) write (iout,1250) apfid(1),apfid(2),
     -        (apfid(i+1),(i-1),i=2,(npfid-1))
            if (iop(63) .eq. 3) then
              write (iout,1260) stiffid
            end if
            if (iop(8) .eq. 0) write (iout,1700)
            if (iop(8) .eq. 1) write (iout,1710)
            if (iop(8) .eq. 2) write (iout,1720) wpfidcen
            if (iop(8) .eq. 0 .and. nstfa0 .gt. 20) then
              write (iout,9409)
              nwarn=nwarn+1
            end if
            if (npfid .le. 1 .and. iop(63) .ne. 3) then
              inperr=inperr+1
              write (iout,9391)
            end if
          end if
          if (iop(88) .eq. 0) write (iout,8800) 'Alternating'
          if (iop(88) .eq. 1) write (iout,8800) 'Randomly chosen'
          if (iop(89) .eq. 0) write (iout,8900) 'total number of grids'
          if (iop(89) .eq. 1) write (iout,8900)
     -      'number of grids not covered by the solute'
        end if
        if (iop(41) .eq. 2) write (iout,4120)
        if (iop(41) .eq. 3) write (iout,4130)
        if (iop(53) .ge. 1)
     -     write (iout,4111) uscpma,(ba-beta*uscpma*usmixp)
        if (iop(15) .gt. 0) write (iout,4118) nslvxp
        if (nslvxp .gt. 0) then
          denxp=float(nslvxp)*wmslv*wmmltona3/(vol-vsltgr)
          write (iout,4115) nslvxp,denxp
          if (denxp .lt. 0.7 .or. denxp .gt. 1.3) then
             write (iout,4116)
             nwarn=nwarn+1
          else if (denxp .lt. 0.5 .or. denxp .gt. 1.5) then
             write (iout,4117)
             nwwarn=nwwarn+1
          end if
        end if
        if (iop(53) .eq. 1 .or. iop(53) .eq. 2) write (iout,4112) usmixp
        if (iop(53) .eq. 3) write (iout,4113) usmixp
        if (iop(76) .eq. 1) write (iout,7610) targetden,
     -    inoutlab(inorout),tolden,toln,
     -    'Tuning will be using an adaptive process',
     -    nmctunskip,nmctunave,chabmax
        if (iop(76) .eq. 2) write (iout,7610) targetden,
     -    inoutlab(inorout),tolden,toln,
     -    'Tuning will be based on fluctuations',
     -    nmctunskip,nmctunave,chabmax
        if (iop(76) .eq. 3) write (iout,7630) targetden,
     -    inoutlab(inorout),targetn,integraltime,gain_den,gain_n
      end if
      if (iop(80) .gt. 0) then
        write (iout,8010) (edgelinxyz(k),edgerinxyz(k),k=1,3),
     -    volin,volav-volin
        if (volin .eq. 0.0) then
          write (iout,8011)
          nwarn=nwarn+1
        end if
      end if
      if ((iop(41) .eq. 1 .or. iop(41) .eq. 2 .or. iop(30) .eq. 1)
     -  .and. nsttm .gt. nstfm) then
        if (iop(83) .eq. 0) write (iout,8300)
        if (iop(83) .eq. 1) write (iout,8310)
        if (iop(83) .eq. 2) write (iout,8320)
      end if
      if (iop(30) .eq. 5) then
        cp0=cplpar
        cp1=1.0-cp0
        write (iout,3050) cp0,cp1
        do npt=1,8
          if (ixcpl(npt) .ne. 0) then
            do ipt=1,npt
              if (abs(cplpar-cpl358(ipt,ixcpl(npt))) .lt. 0.0001)
     -          write (iout,3016) npt,ipt
            end do
          end if
        end do
      end if
      if (iop(30) .eq. 5 .and. ptiexp(1)*ptiexp(2)*ptiexp(3) .ne. 1.0)
     -  write (iout,3051) epstol,sigtol,qtol,xyztol2
      if (iop(30) .eq. 6) write (iout,3060) cplpar,cplpr1,
     -  uspar0,uspr01,uspar1,uspr11
      if (iop(35) .gt. 0) write (iout,3510) uspro0,uspro0,uspro1,uspro1
      if (iop(35) .eq. 2 .and. iop(11) .eq. 0)
     -  write (iout,3520) filenames(2)(1:namlens(2))
      if (iop(30) .eq. 5) then
        if (ptiexp(1)*ptiexp(2)*ptiexp(3) .ne. 1.0) then
          write (iout,9388) cplpar,ptiexp
        else
          write (iout,9418)
        end if
      end if
      if (iop(30) .eq. 7) then
        write (iout,5100)
        if (iop(18) .eq. 0 .and. igenpmf .eq. 0) write (iout,1800)
        if (iop(18) .eq. 0 .and. igenpmf .eq. 1) write (iout,1801)
        if (iop(18) .eq. 1) write (iout,1810)
        if (iop(18) .eq. 2 .or. iop(18) .eq. 3)
     -    write (iout,1820) imolcent2
        if (iop(18) .eq. 3) write (iout,1830)
        if (iop(18) .gt. 0 .and. iop(18) .lt. 4) then
          i2=impmf2
          if (impmf1 .eq. impmf2) i2=imolcent2
          write (iout,1811) impmf1,i2
        end if
        if (iop(18) .eq. 4) then
          iftg=2
          write (iout,1840)
        end if
        if (iop(18) .eq. 5) then
          write (iout,1850)
          if (notranpmf .eq. 0) write (iout,1851) cdpmf
          if (norotpmf .eq. 0) write (iout,1852)
     -      (rtpmf(k)*rdtodg,k=1,3)
        end if
        if (iop(38) .eq. 0) write (iout,3800)
        if (iop(38) .eq. 1) write (iout,3810)
        if (iop(38) .eq. 2) write (iout,3820)
        if (iop(51) .eq. 0) then
          write (iout,5101) cplmin,cplmax,c0cplh,p0cplh
        else
          if (iop(120) .gt. 0) then
            write (iout,3073)
            if (iterw .gt. 0) write (iout,5111) iterw,iterws
            if (iop(120) .eq. 2) write (iout,3074)
            if (iop(120) .eq. 3) write (iout,3075)
          end if
          call aus_params(iout,iop,cplmin,cplmax,nmcadp)
        end if
      end if
c-----Sampling info
      if (irng .eq. 3 .or. irng .eq. 4)
     -   write (iout,9148) rngfile(1:lrngfile),nrand
      if (irng .eq. 3) write (iout,9149)
      if (iop(160) .eq. 0) then
        write (iout,9005)
        if (iop(71) .gt. 0) then
c         Isobric ensemble info
          if (iop(71) .eq. 1) write (iout,7110) 'uniform',vrange
          if (iop(71) .eq. 2)
     -      write (iout,7110) 'isotropic virial biased',vrange
          if (iop(71) .eq. 3)
     -      write (iout,7110) 'anisotropic virial biased',vrange
          if (iop(71) .gt. 1) write (iout,7111) vlam
        end if
        if (iop(30) .eq. 8) write (iout,3080) cplpar,cplpr1,
     -    uspar0,uspr01,uspar1,uspr11
        if (iop(57) .gt. 0) then
          if (iop(104) .gt. 0) then
             write (iout,9920) ligand_start_molecule
c           Error check LIGA parameter
            if (ligand_start_molecule .ge. nsttm) then
              write (iout, 9924) ligand_start_molecule, nsttm
              inperr=inperr+1
            else if (ligand_start_molecule .le. 0) then
              write (iout, 9925) ligand_start_molecule
              inperr=inperr+1
            end if
            if (iop(69) .eq. 0) then
              if (ligand_start_molecule .gt. 1) then
                write (iout,9926)
                nwwarn=nwwarn+1
              end if
            else
c             Check if ligand copies are identical clones
              icp1=icorig(ifirstm(nsttm-ligand_start_molecule+1))
              if (icp1 .lt. 0) then
                write (iout,9927)
                nwarn=nwarn+1
              end if
              do imm=2,ligand_start_molecule
                im=nsttm-imm
                if (-icorig(ifirstm(im)) .ne. iabs(icp1)) then
                  write (iout,9928) im
                  nwwarn=nwwarn+1
                end if
              end do
            end if
          end if
          do k=1,3
            rtx3(k)=rtxpslt(k)*rdtodg
          end do
          write (iout,5710)
     -      movmolf,movmoll,ifirstm(movmolf),ilastm(movmoll)
          if (iop(57) .eq. 1)  then
            write (iout,5720) 'PARD','Solute rotation'
            write (iout,5711) cedpslt,rtx3
          else
            write (iout,5730) 'PARD','Solute rotation',
     -        exbiname(iop(57)-1)
            write (iout,5712) cedpslt,rtxpslt
          end if
          xyz(1)=waxis(2)
          xyz(2)=waxis(3)-waxis(2)
          xyz(3)=1.0-waxis(3)
          write (iout,5713) (xyz(k),k=1,3)
          if (iop(64)+iop(66) .gt. 0) then
            if (movmoll-movmolf .lt. 1) then
              write (iout,9434)
              inperr=inperr+1
            else
              if (iop(66) .gt. 0) then
                write (iout,6600) lxyz(iaxis2s)
                if (r2scut .gt. 0.0) write (iout,6601) r2scut
                if (r2scut .eq. 0.0) write (iout,6602)
                if (iop(66) .eq. 1) then
                  write (iout,5720) 'MV2S','Correlated 2-solute'
                  write (iout,6610) 'range',rtxcslt,'deg'
                else
                  write (iout,5730) 'MV2S','Correlated 2-solute',
     -              exbiname(iop(66)-1)
                  write (iout,6610) 'parameter',rtxcslt,' '
                end if
              end if
              if (iop(64) .gt. 0) then
                write (iout,6410)
                lmin=#ST
                lmax=0
                do im=movmolf,movmoll
                  na=ilastm(im)-ifirstm(im)
                  if (na .gt. lmax) lmax=na
                  if (na .lt. lmin) lmin=na
                end do
                if (lmax .gt. lmin) then
                  write (iout,6411) lmin,lmax
                  nwarn=nwarn+1
                  if (float(lmax-lmin)/float(lmax) .gt. 0.1 .and.
     -                lmax .gt. 100) then
                    write (iout,6412)
                    nwwarn=nwwarn+1
                  end if
                end if
              end if
            end if
          end if
        end if
        if (iop(107) .gt. 0) then
          nstune=0
          do i=1,4
            if (istune(i) .gt. 0) then
              if (istune(i) .gt. 0) then
                nstune=nstune+1
                if (i .eq. 1) then
                  tunstpmax=tunstpmx(1)
                  tunstpmin=tunstpmn(1)
                  tunit='A  '
                else
                  tunstpmax=tunstpmx(i)*rdtodg
                  tunstpmin=tunstpmn(i)*rdtodg
                  tunit='deg'
                end if
                write (iout,9511) stunen(i),100.0*targetacc(i),
     -            gain(i),timeint(i),tunstpmin,tunstpmax,tunit,
     -            wsum(i),wstepsum(i)
c!!!            Clone averaging not implemented yet for solute trans/rot moves
                if (iop(69) .gt. 0 .and. i .gt. 1)
     -            write (iout,9512) stunen(i)
                if (istunetyp(i) .eq. 2) write (iout,9514) stunen(i)
              end if
              if (nmc_zeroacc(i) .gt. 0) then
                write (iout,9522) stunen(i),nmc_zeroacc(i)
                if (mod(nmc_zeroacc(i),nplt) .gt. 0) then
                  write (iout,9520) nplt,stunen(i)
                  inperr=inperr+1
                end if
              end if
            else if (istunestep(i) .gt. 0) then
              if (istunestep(i) .eq. 3)
     -         write (iout,9459) stunen(i),'last tuned'
              if (istunestep(i) .eq. 4)
     -         write (iout,9459) stunen(i),'weight-averaged'
              if (istunestep(i) .eq. 5)
     -          write (iout,9459) stunen(i),'cumulative average'
            end if
          end do
          if (nstune .eq. 0) iop(107)=0
        end if
        if (iop(68) .gt. 0) write (iout,6800)
      end if
      if (iop(96) .eq. 1 .or. iop(96) .eq. 6)
     -  write (iout,9601) 'torsion',1.0-tornbfac
      if (iop(96) .eq. 2) then
        write (iout,9601) 'solute-solvent repulsion',1.0-repnbfac
      else if (iop(96) .eq. 3) then
        write (iout,9630) slttmp
      else if (iop(96) .eq. 4) then
        write (iout,9640) tsexp
      else if (iop(96) .eq. 5 .or. iop(96) .eq. 6) then
        write (iout,9601) 'solute-solute non-bonded',1.0-repnbfac
      end if
      if (iop(144)+iop(57)+iop(58)+iop(176) .gt. 0 .or.
     -    iop(18) .eq. 4 .or. iop(30) .eq. 3) then
        if (iop(57) .gt. 0)
     -    write (iout,7300) 'displacements',selectname(iop(73)+1)
        if (iop(58) .gt. 0) then
          write (iout,5810)
          if (#TD .eq. 1) then
            write (iout,9445) 'TD'
            nwarn=nwarn+1
          end if
          if (mod(iop(84),2) .eq. 1) write (iout,8400)
          if (mod(iop(84),2) .eq. 0) write (iout,8410)
          if (iop(84) .gt. 2) write (iout,8420)
          if (iop(58) .eq. 1) write (iout,5720) 'PART','Torsion angle'
          if (iop(58) .gt. 1) write (iout,5730) 'PART',
     -      'Torsion angle',exbiname(iop(58)-1)
          write (iout,7300) 'torsion moves',selectname(iop(74)+1)
          if (iop(91) .gt. 0) then
            if (iop(91) .eq. 1) then
              write (iout,9911)
              if (iop(103) .eq. 1) write (iout,9918) 'forward direction'
              if (iop(103) .eq. 2) write (iout,9918)
     -          'backward direction'
              if (iop(103) .eq. 3) write (iout,9918)
     -          'direction suggested by the triangle inequalities'
              if (iop(103) .eq. 4) write (iout,9918)
     -          'tried both ways, using the one with the smaller error'
            end if
            if (iop(91) .eq. 2) write (iout,9912) divr3
            if (iop(91) .eq. 3) write (iout,9913) divr3
            if (wloop .eq. 1.0) then
              write (iout,5819)
            else if (wloop .ge. 0.0 .and. wloop .lt. 1.0) then
              write (iout,5815) 100.*wloop
            else
              write (iout,5813) wloop
              inperr=inperr+1
            end if
            if (iop(91) .eq. 1.0 .and. wloop .eq. 1.0) write (iout,5814)
            write (iout,5817) (it,looptypname(it),it=1,nlooptyp)
            if (looptypcnt(1) .gt. 0) write (iout,9910) d3tol,d24tol
            if (looptypcnt(2) .gt. 0)
     -        write (iout,9917) '16',d3tol,dijtol,d24tol
            if (looptypcnt(3) .gt. 0)
     -        write (iout,9917) '27',d3tol,dijtol,d24tol
            write (iout,9914) dextol
            if (iop(91) .eq. 1 .or. idebug(81) .gt. 0)
     -        write (iout,9916) drevtol
            if (looptypcnt(1) .lt. ntotloop) then
              if (dihpmtol .lt. 90.0) write (iout,9929) dihpmtol
              if (dihpmtol .ge. 90.0) write (iout,9932) dihpmtol
            end if
            if (iop(115) .gt. 0) write (iout,9934)
            if (iop(116) .gt. 0) then
              write (iout,9935) 1.0/wskewinv
              if (wskewstepmin .gt. 0 .and. iop(107) .gt. 0)
     -          write (iout,9940) wskewstepmin*rdtodg,
     -            resumefac*wskewstepmin*rdtodg
              if (iskewdr .eq. 1) write (iout,9936)
              if (iskewlp .eq. 1) write (iout,9937)
              if (iskewpr .eq. 1) write (iout,9939)
            end if
          end if
          if (ntorlim .gt. 0) write (iout,8411) ntorlim
          write (iout,7500) selectname(iop(75)+1)
          if (ntorsinp .gt. 0) then
            if (nsltcop .eq. 1) then
              if (rngfac(1) .ne. 1.0)
     -          write (iout,5818) 'Torsion',' ',rngfac(1)
              if (rngfacl(1) .ne. 1.0 .and. iop(91) .gt. 0)
     -          write (iout,5818) 'Loop torsion',' ',rngfacl(1)
            else
              do ic=1,nsltcop
                if (rngfac(ic) .ne. 1.0)
     -            write (iout,5818) 'Torsion',' for solute copy ',
     -              ic,rngfac(ic)
                if (rngfacl(ic) .ne. 1.0 .and. iop(91) .gt. 0)
     -            write (iout,5818) 'Loop torsion',' for solute copy ',
     -              ic,rngfacl(ic)
              end do
            end if
          else
            write (iout,5812) 'simple',defrot
            write (iout,5812) 'loop',deflooprot
            write (iout,5816) maxtorchain
          end if
        end if
        if (ntang .gt. 0 .or. iop(18) .eq. 4) then
          npfu=0
          if (iop(3) .le. 8) then
            do ipft=1,9
              if (lprmfil(ipft) .gt. 0) then
                npfu=npfu+1
                write (iout,5811) prmfil(ipft)(1:lprmfil(ipft))
              end if
            end do
            if (npfu+iop(144) .eq. 0) then
              write (iout,1842)
              inperr=inperr+1
            end if
          end if
          maxcorot=0
          maxcorotl=0
          nloopfound=0
          call clonespread(ntang,itorig,cv1,torstep,#TR)
          if (iop(91) .gt. 0)
     -      call clonespread(ntang,itorig,cv2,steploop,#LT)
          call indexit(l1,1,nstta,0)
          if (iop(61) .gt. 0) call trnsfi(l1,iorig_of_split,nstta)
          do itg=1,ntorgrp
            if (icorig(iquata(ifdhgrlst(itg),2)) .ge. 0 .or.
     -          itg .lt. iftg .or. iop(24) .gt. 1) then
              do it=ifdhgrlst(itg),ildhgrlst(itg)
                call gettorsnames(it,4,torsnames,labslt,ianslt,iatnam,
     -            0,itorig,iquata)
                ncorot=nnexttormov(itangindx(it))
                if (itg .lt. iftg) then
c                 Coupled torsion group
                  if (it .eq. ifdhgrlst(itg)) write (iout,1853)
                  dh0=dih0(it)*rdtodg
                  dh1=dih1(it)*rdtodg
                  trange=deldih(it)*rdtodg
                  write (iout,1841) it,(l1(iquata(it,k)),
     -              torsnames(k),k=1,4),dh0,dh1,trange
                  wtor=1.0
                  trstp=1.0
                else
                  if (it .eq. ifdhgrlst(itg) .and. iop(58) .gt. 0) then
                    wtor=wtors(itg+1)-wtors(itg)
                    write (iout,1844) itg,wtor,dihang(it)*rdtodg
                  else  if (iop(144) .gt. 0 .or.
     -                      (iop(30) .ge. 1 .and. iop(30) .le. 3)) then
                    wtor=0.0
                  end if
                  if (iop(58) .le. 1) then
                    trstp=cv1(it)*rdtodg
                  else
                    trstp=cv1(it)
                  end if
                  dh0=dihang(it)*rdtodg
                  write (iout,1843) it,numtorix(it),(l1(iquata(it,k)),
     -              torsnames(k),k=1,4),ncorot,trstp
                  if (deldih(it) .gt. 0.0  .and.
     -                deldih(it) .lt. pi*0.999) then
                    write (iout,1847)
     -                it,dih0(it)*rdtodg,deldih(it)*rdtodg
                    call checktorlim(dihang(it),dih0(it),
     -                deldih(it),ptaccfac,irejtyp)
                    if (irejtyp .gt. 0) then
                      write (iout,1856) it,dihang(it)*rdtodg,
     -                  deldih(it)*rdtodg,dih0(it)*rdtodg
                      inperr=inperr+1
                    end if
                  end if
                  if (ncorot .gt. 100 .and. numsolv .gt. 0) then
                    write (iout,1855)
                    nwwarn=nwwarn+1
                  else if (ncorot .gt. 50) then
                    write (iout,1854)
                    nwarn=nwarn+1
                  end if
                end if
                if (looptyp(it) .gt. 0) then
                  nloopfound=nloopfound+1
                  do k=1,6
                    ialist(k)=iquata(looplist(k,it),3)
                  end do
                  call gettorsnames(it,6,torsnames,labslt,ianslt,iatnam,
     -              1,ialist,iquata)
                  write (iout,9915)
     -              (looplist(k,it),torsnames(k),k=1,6),
     -              cv2(it)*rdtodg,looptyp(it),looptypname(looptyp(it))
                  if (cv2(it) .eq. 0.0) then
                    write (iout,9446)
                    nwarn=nwarn+1
                  end if
                end if
                ncorot=nnexttormov(itangindx(it))
                if (wtor*trstp .gt. 0.0) then
                  if (looptyp(it) .eq. 0 .and. maxcorot .lt. ncorot)
     -              maxcorot=ncorot
                  if (looptyp(it) .gt. 0 .and. maxcorotl .lt. ncorot)
     -              maxcorotl=ncorot
                end if
                if (iop(24) .gt. 1) then
                  if (ncorot .eq. 0) then
                    write (iout,1848) dh0,'No corotated atoms'
                  else
                    incrcorot=irotlinc(it)
                    nlines=1+(ncorot-1)/7
                    ifp=1
                    ilp=min0(7,ncorot)
                    write (iout,1848) dh0,'Co-rotated atoms:'
                    do lines=1,nlines
                      do k=ifp,ilp
                        ialist(k-ifp+1)=irotlist(incrcorot+k)
                      end do
                      call gettorsnames(it,ilp-ifp+1,torsnames,labslt,
     -                  ianslt,iatnam,1,ialist,iquata)
                      write (iout,1849) ('(',l1(irotlist(incrcorot+k)),
     -                  torsnames(k-ifp+1),k=ifp,ilp)
                      ifp=ilp+1
                      ilp=min0(ncorot,ifp+6)
                    end do
                  end if
                end if
                if (iop(116) .gt. 0 .and. iskew(it) .gt. 0) then
                  write(iout,1839) it,targetang(it)*rdtodg
                  if (ifdhgrlst(itg) .ne. ildhgrlst(itg)) then
                    write(iout,1838) itg,it
                    inperr=inperr+1
                  end if
                end if
              end do
            end if
          end do
          if (iop(91) .gt. 0) then
            if (nloopfound .eq. 0) then
              iop(91)=0
              write (iout,9101) 'No loops were found'
              nchng=nchng+1
              write (iout,9102)
            else
              do lt=1,nlooptyp
                if (looptypcnt(lt) .gt. 0)
     -            write (iout,9100) looptypname(lt),looptypcnt(lt)
              end do
            end if
          else
            if (maxcorot .gt. 200) then
              write (iout,1845) ' ===== STRONG',maxcorot
              nwwarn=nwwarn+1
            else if (maxcorot .gt. 100) then
              write (iout,1845) ' -----',maxcorot
              nwarn=nwarn+1
            end if
          end if
          if (maxcorotl .gt. 200) then
            write (iout,1846) ' ===== STRONG',maxcorotl
            nwwarn=nwwarn+1
          else if (maxcorot .gt. 100) then
            write (iout,1846) ' -----',maxcorotl
            nwarn=nwarn+1
          end if
        end if
      end if
      if (iop(160) .eq. 0) then
        ntyp=0
        wsltdif(1)=wslttry(1)
        do i=1,ntrytyp
          if (i .gt. 1) wsltdif(i)=wslttry(i)-wslttry(i-1)
          if (wsltdif(i) .gt. 0.0) ntyp=ntyp+1
        end do
        if (ntyp .gt. 1) then
          do i=1,ntrytyp
            if (wsltdif(i) .ne. 0.0)
     -        write (iout,5790) movname(i),wsltdif(i)
          end do
        else if (ntyp .eq. 0 .and.
     -           numsolv .eq. 0 .and. nmcmax .gt. 0) then
          write (iout,5799)
          inperr=inperr+1
        end if
        if (iop(110)*iop(107) .gt. 0) then
          do ityp=1,4
            if (istune(ityp) .gt. 0 .and.
     -          scalefactors(ityp+4) .ne. 1) then
              write (iout,5798) movename(ityp+4)
              inperr=inperr+1
            end if
          end do
        end if
        call scalestep(iop(110),scalefac,0,0,0,1,iop(24),inperr,iout)
        if (nmolec .gt. 1 .or. iop(41) .gt. 0) then
          if (nsltfreq .ne. 0) write (iout,0811) nsltfreq
          if (nsltfreq .eq. 0 .and. isltsmpl .gt. 0) then
            inperr=inperr+1
            write (iout,9426)
          end if
          if (nstta .gt. 0) then
            if (isltmove .gt. 0) then
              rtx=rtxslt*rdtodg
              write (iout,9080) cedslt,rtx
            else
              write (iout,9081)
            end if
          end if
          rtx=rtxslv*rdtodg
          write (iout,9093) cedslv,rtx
          if (stpfac .ne. 1.0 .and. nmc .gt. 0) then
            write (iout,3410) stpfac
            nwarn=nwarn+1
          end if
          if (iop(44) .gt. 1)
     -      write (iout,4410) 'solvent',wslvdisp,wslvrot
          if (mod(iop(44),2) .eq. 1)
     -      write (iout,4410) ' solute',wsltdisp,wsltrot
          if (iop(41) .gt. 0) then
            if (iop(53) .eq. 0) write (iout,1191)
            if (iop(53) .eq. 1) write (iout,1192)
            if (iop(53) .eq. 2) write (iout,1193)
            if (iop(53) .eq. 3) write (iout,1194)
          end if
          if (iop(6) .le. 1) write (iout,0600) cellname(iop(6)+1)
          if (iop(6) .eq. 2) write (iout,0620) cedslt,cedslv
          if (iop(6) .eq. 3) write (iout,0630) sqrt(0.25/rsphm2)*
     -      cedslt,cedslt,sqrt(rsphm2/0.25)*cedslv,cedslv
          if (iop(6) .gt. 4) then
            write (iout,0650) fblamd
            if (icompopt(6) .eq. 0) then
              write (iout,9021) 'force/torque','FR'
              inperr=inperr+1
            end if
            if (iop(19) .ne. 0) write (iout,1910)
            write (iout,9119) frcmax,trqmax
C@FR            if (kuttyp .eq. 1) write (iout,9017)
            if (iop(6) .eq. 6) then
              write (iout,0660) (rfblam(i),afblam(i),i=1,nfblam)
            end if
          end if
          if (iop(99) .le. 1) write (iout,9900)
          if (iop(99) .eq. 2) write (iout,9902)
          if (iop(99) .eq. 3) write (iout,9903)
          itwo=2
          nacclim=100.0*accpmn+0.00001
          write (iout,4400) nacclim
          if (nsolvfix .gt. 0) write (iout,1420) nsolvfix
          if (iop(12) .le. 3) then
            write (iout,1200) selectname(iop(12)+1)
          else
            write (iout,1231)
            if (iop(12) .eq. 4) write (iout,1240)
     -        ('r',rpfmv(i),apfmv(i),i=1,npfmv)
            if (iop(12) .eq. 5) write (iout,1250) apfmv(1),apfmv(2),
     -        (apfmv(i+1),(i-1),i=2,(npfmv-1))
            if (iop(12) .eq. 6) then
              write (iout,1260) stiffmv
            end if
            if (nstta .gt. 0) then
              if (iop(17) .eq. 0) write (iout,1700)
              if (iop(17) .eq. 1) write (iout,1710)
              if (iop(17) .eq. 2) write (iout,1720) wpfmvcen
            end if
            if (iop(17) .eq. 0 .and. nstfa0 .gt. 20) write (iout,9409)
            if (npfmv .le. 1 .and. iop(12) .ne. 6) then
              inperr=inperr+1
              write (iout,9391)
            end if
          end if
        end if
        if (iop(30) .eq. 7) write (iout,9091) delcpl
        noldmx=100
        if (iop(34) .gt. 1) noldmx=10*iop(34)
        if (iop(34) .ne. 1) write (iout,3400) noldmx
C@TS        if ((iop(19) .eq. 0 .or. rtxslt .eq. 0.0 .or. iop(57)+iop(58)
C@TS     -    .gt. 0) .and. iop(160) .eq. 0 .and. iop(144) .eq. 0) then
C@TS          write (iout,9420)
C@TS          write (iout,9421)
C@TS          nwarn=nwarn+1
C@TS        end if
C@NN        if (iop(54) .eq. 1) then
C@NN          write (iout,9419)
C@NN          write (iout,9422)
C@NN          nwarn=nwarn+1
C@NN        end if
      end if
c-----System information
      write (iout,9006)
      if (iop(82) .gt. 0) write (iout,8210) iop(82)
      if (ipretrans .eq. 1)
     -   write (iout,9451) preshift,((prerot(i,k),k=1,3),i=1,3)
      if (ipretrans .eq. 2)
     -   write (iout,9452) ((prerot(i,k),k=1,3),i=1,3),preshift
      if (iop(5) .eq. 0) write (iout,0500) edgexa,edgeya,edgea
      if (iop(5) .eq. 1) write (iout,0510) edgea
      if (iop(5) .eq. 2) write (iout,0520) edgexa
      if (iop(5) .eq. 3) write (iout,0530) edgexa
      if (iop(5) .eq. 4) write (iout,0540) edgexa,edgea
      if (iop(5) .eq. 5) write (iout,0550) rinscr
      if (iop(5) .eq. 6) then
        if (numsolv .eq. 0) then
          write (iout,0565)
          inperr=inperr+1
        end if
        if (iop(93) .eq. 0) write (iout,0560) uphsref,' ',2.0*phsk
        if (iop(93) .ge. 1) write (iout,0560) uphsref,' per molecule ',
     -    2.0*phsk
        if (iop(93) .eq. 2) write (iout,0562) rphswid
        write (iout,0561) nmcphs,rphs,rphsmin,rphsmax
        if (iop(7) .eq. 1 .or. iop(54) .eq. 1 .or. iop(65) .eq. 1 .or.
     -      iop(65) .eq. 3) then
          inperr=inperr+1
          write (iout,0564)
        end if
        if (rphsmax .gt. cutslt) then
          write (iout,0563) cutslt,rphsmax
          inperr=inperr+1
        end if
        if (iop(92) .eq. 1) write (iout,9921) 'built in atom VdW radii'
        if (iop(92) .eq. 2) write (iout,9921) 'L-J sigmas'
        if (iop(92) .gt. 0 .and. naphsrange .gt. 0) then
          write (iout,9923)
     -      (' ',(iaphsrange(k,ir),k=1,2),ir=1,naphsrange)
        end if
        if (iop(4) .gt. 0) write (iout,9922) denphs
        if (iop(41)+iop(71) .gt. 0) then
          inperr=inperr+1
          write (iout,9448)
        end if
      end if
      if (iop(5) .eq. 7) write (iout,0570)
      if (iop(5) .ne. 5 .and. iop(5) .ne. 6)
     -  write (iout,9040) rinscr,rcirc
      densty=0.0
      if (vol .gt. 0.0) densty=(wmslt+(nmolec-1)*wmslv)/vol*wmmltona3
      if (iop(92) .eq. 0) write (iout,9050) vol,densty
      if (iop(5) .le. 5 .and. edgemap2 .gt. 0.0) then
        if (rinscr-edgemap2 .gt. 1.e-5) then
          write (iout,6713) 'inscribed',rinscr,'greater',edgemap2
        else if (edgemap2-rinscr .gt. 1.e-5) then
          write (iout,6713) 'inscribed',rinscr,'less',edgemap2
        end if
        edgemap3=edgemap2*sq3
        if (rcirc-edgemap3 .gt. 1.e-5) then
          write (iout,6713) 'circumscribed',rcirc,'greater',edgemap3
        else if (edgemap2-rcirc .gt. 1.e-5) then
          write (iout,6713) 'circumscribed',rcirc,'less',edgemap3
        end if
      end if
      if (iop(61) .gt. 0) write (iout,9062) (lxyz(k),xyzflmin(k),
     -  (xyzflmin(k)+xyzflmax(k))/2.0,xyzflmax(k),
     -  xyzflmax(k)-xyzflmin(k),k=1,3)
      if (kexp .eq. 0) then
        write (iout,9059) temp
      else
        write (iout,9058) temp*cplpar**kexp,cplpar,kexp,nquad,iquad,temp
      end if
      if (iop(114) .gt. 0) then
        write (iout,9515) nmctempstep,ntempsteptot,tempfin
        if (iop(114) .eq. 1) write (iout,9516) tempstep
        if (iop(114) .eq. 2) write (iout,9517) tempexp,exp(-tempexp)
        if (iop(114) .eq. 3) write (iout,9518) tempexp
        if (iop(114) .eq. 4)
     -    write (iout,9519) (templist(i),i=1,ntemplist)
      end if
      if (iop(129) .gt. 0) then
        write (iout,9919) bincr,cav_fract_lim
        if (iop(129) .eq. 1) write (iout,9941) nmcsacpstep
        if (iop(129) .eq. 2) write (iout,9941) nmcsacpsteppnmol,' * '
        if (iop(9) .eq. 0) write (iout,9938) filenames(3)(1:namlens(3))
      end if
      if (iop(97) .gt. 0) write (iout,9061)
      if (icompopt(2) .eq. 0 .and.
     -  (iop(57)+iop(58) .gt. 0 .or. iop(30) .eq. 7)) then
        inperr=inperr+1
        write (iout,9021) 'Intramolecular energy','TN'
      end if
      if (iop(57) .gt. 0 .and. nsttg .gt. nsttm .and.
     -    (iop(43) .eq. 0 .or. iop(65) .le. 2) .and.
     -    iop(5) .ne. 5) then
        inperr=inperr+1
        write (iout,9432)
      end if
      if (iop(2) .eq. 1) write (iout,0210)
      if (iop(2) .eq. 2) write (iout,0220)
      if (nmake .gt. 0) write (iout,6911)
     -  (imake(1,i),imake(2,i),i=1,nmake)
      if (nbreak .gt. 0) write (iout,6912)
     -  (ibreak(1,i),ibreak(2,i),i=1,nbreak)
      if (iop(85) .gt. 0) write (iout,8510)
      if (nhhb .gt. 0) write (iout,1001) nhhb
      if (nhrb .gt. 0) write (iout,1011) nhrb
      qsltt=0.0
c     Don't echo solute on longer run restarts
      nsltp=nsltpr
      if ((nmc .gt. 100000 .or. numrun .gt. numrunst) .and.
     -     iop(24) .lt. 1 .and. iprintall .eq. 0) nsltp=-1
      if (ihbtypsltmap .gt. 0 .and. nsltp .eq. nstta) then
        if (nhbdonaccp .gt. 0. and.
     -      iop(67) .ne. 2 .and. iop(67) .ne. 3) then
c         Print hydrogen-bond acceptor atoms
          write (iout,6791)
          do ja=1,nhbdonaccp
            ia=indexhb(ja)
            if (ihbdonacc(ia) .ne. 0) then
              if (ihbdonacc(ia) .lt. 0) hbdonacclab(1:1)='A'
              if (ihbdonacc(ia) .gt. 0) hbdonacclab(1:1)='D'
              write (hbdonacclab(2:2),9513) iabs(ihbdonacc(ia))
            else
              hbdonacclab='  '
            end if
            write (iout,9141) ia,hbdonacclab,pflabslt(ia),
     -        (cslt(k,ia),k=1,3),qslt(ia),(labslt(k,ia),k=1,2)
          end do
        end if
      end if
      if (nstta .gt. 0) then
        write (iout,9120) nstta,nsttm
        if (nstfm .gt. 0) write (iout,9121) nstfa,nstfm
        write (iout,9123) ntypused
        if (iop(69) .gt. 0) then
          write (iout,6910) (iaclnf(ic),iaclnl(ic),ncopcln(ic),
     -      ic=1,nclone)
          write (iout,6920)
        end if
        if (namlens(9) .ne. 0)
     -    write (iout,9122) filenames(9)(1:namlens(9))
        if (nsltp .ne. -1) then
          rsltlab='RppxR'
          if (iop(162) .eq. 0) then
c           Replace proximity radius with solute atom radius (just for print)
            call sltrad(rppxrad2,ianslt,nstta,0.0,1,iop(62),1.0, 1.0,2)
            rsltlab='rsltg'
          end if
          split_lab='          '
          if (iop(61) .gt. 0) split_lab=' ia_o ir_o'
          if (iop(113) .gt. 0 .and. iop(162) .eq. 0) then
            write (iout,9130) 'V_solv','  S_solv ',split_lab
          else
            write (iout,9130) rsltlab,'  ixgr  grp '
          end if
        end if
      else
        write (iout,9132)
      end if
      dipx=0.0
      dipy=0.0
      dipz=0.0
      ncop=0
      iop25=min0(2,iop(25)+1)
      line(121:132)='           '
      rmaxslt=0.0
      imaxslt=0
      call zeroiti(idbpr,0,100)
      ifslta=1
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) ifslta=nstfa+1
      call cofms(cslt,cm,iclslt,ifslta,nstta,0,wmsx)
      nstta_tot=nstta
      if (iop(61) .gt. 0) nstta_tot=nstta_full
      if (nsltp .eq. nstta) nsltp=nstta_tot
      do ia=1,nstta_tot
        call blankout(line,1,132)
        iam=iclslt(ia)
        pfl=pflabslt(ia)
        iatno=ianslt(ia)
        idbpr(iatno)=idbpr(iatno)+1
        lgc=' '
        lmc=' '
        qsltt=qsltt+qslt(ia)
        dipx=dipx+cslt(1,ia)*qslt(ia)
        dipy=dipy+cslt(2,ia)*qslt(ia)
        dipz=dipz+cslt(3,ia)*qslt(ia)
        if (ia .ge. ifslta) then
          rst2=(cslt(1,ia)-cm(1))**2+(cslt(2,ia)-cm(2))**2+
     -      (cslt(3,ia)-cm(3))**2
          if (rst2 .ge. rmaxslt) then
            rmaxslt=rst2
            imaxslt=ia
          end if
        end if
        if (nsltp .ne. -1 .and. ia .le. nsltp .and.
     -    (icorig(ia) .ge. 0 .or. iop(24) .gt. 1)) then
          mark='    '
          if (iop(30) .eq. 5) then
            if (noppti(igrpf(ia)) .eq. 1) mark=' SIM'
            if (noppti(igrpf(ia)) .eq. 2) mark=' INV'
          end if
          if (iop(57)+iop(58) .gt. 0 .and. mark .eq. '    ') then
            if (isltmv(ia) .eq. 0) mark=' FIX'
            if (isltmv(ia) .eq. 1) mark=' MOV'
            if (isltmv(ia) .eq. 2) then
              mark=' TOR'
              if (loopmemat(ia) .gt. 0) mark=' LPT'
            end if
          end if
          aromlab=' '
          hbdonacclab='  '
c         Aromatic carbon map is #2
          if (iatdtypslt(ia) .eq. 2) aromlab='a'
          if (iatno .eq. 1 .and. nneig(ia) .gt. 0) then
            if (ianslt(ineig(1,ia)) .ne. 6) aromlab='p'
          end if
          if (iatno .eq. 6 .and. iop(113) .eq. 4) then
            if (ipolarslt(ia) .eq. 1) then
              aromlab='p'
              if (iatdtypslt(ia) .eq. 2)
     -          write (iout,9129) ia,(labslt(k,ia),k=1,2)
            end if
          end if
          if (iop(112) .gt. 0) then
            if (ihbdonacc(ia) .lt. 0) hbdonacclab(1:1)='A'
            if (ihbdonacc(ia) .gt. 0) hbdonacclab(1:1)='D'
            if (ihbdonacc(ia) .ne. 0)
     -        write (hbdonacclab(2:2),9513) iabs(ihbdonacc(ia))
          end if
          if (igrcnt(igrslt(ia)) .eq. ia) lgc='G'
          if (ia .le. nstta) then
            im=iamolslt(ia)
            if (molcnt(im) .eq. ia) lmc='M'
            write (line,9140) ia,iatnam(iatno)(1:2),hbdonacclab,
     -        ipf(iopslt(ia)),aromlab,pfl,
     -        namfcg(ifcnos(iclslt(ia),iopslt(ia)),iop25),lgc,lmc,
     -        (cslt(k,ia),k=1,3),qslt(ia),epsslt(ia),sigslt(ia),im,
     -        igrslt(ia),mark,(labslt(k,ia),k=1,2)
          else
            write (line,9140) ia,iatnam(iatno)(1:2),hbdonacclab,
     -        'ATD4',aromlab,pfl,'    ',lgc,' ',
     -        (cslt(k,ia),k=1,3),qslt(ia),0.0,0.0,0,igrslt(ia),' MAP',
     -        (labslt(k,ia),k=1,2)
          end if
          if (iop(113) .gt. 0 .and. iop(162) .eq. 0) then
c           Print solvation parameters
            call setdesolvparams(iop(113),keep,ia,ianslt,qslt,
     -        ipolarslt,iatdtypslt,qpolarcarbmin,v_solv_slt,
     -        s_solv_slt,v_solv_par,a_solv_par,qk_par,nstta_full,iout,
     -        inperr,max_atdtyp)
            if (keep .eq. 1) write (line(107:121),1000)
     -        v_solv_slt(ia),s_solv_slt(ia)
          else
            write (line(107:112),9024) sqrt(rppxrad2(ia))
            if (iop(159)+iop(160) .gt. 0 .and. iop(162) .gt. 0 .and.
     -        indxrdf(ia) .ne. #GQ)
     -          write (line(113:117),9009) indxrdf(ia)
            if (iop(25) .gt. 0) then
              line(26:29)='    '
              line(119:122)=namfcg(itypfg(ia),2)
            end if
            line(123:130)=fcglab(ia)
          end if
          if (iop(61) .gt. 0) write (line(123:132),9009)
     -      iorig_of_split(ia),ir_split_orig(iorig_of_split(ia))
          call lastchar(line,lc,132)
          write (iout,9008) line(1:lc)
        end if
        if (ia .eq. nstfa0 .or. ia .eq. nstfa1 .or.
     -    ia .eq. nstfa .or. ia .eq. nstta) then
          if (nsltp .ne. -1 .and. ia .le. nsltp .and. ia .lt. nstta)
     -      write (iout,9142)
          ncop=ncop+1
          dipxyz(1,ncop)=dipx
          dipxyz(2,ncop)=dipy
          dipxyz(3,ncop)=dipz
          qtot(ncop)=qsltt
          nacp(ncop)=ia
        end if
        if (ia .eq. nsltp .and. ia .lt. nstta) write (iout,9401)
        if (ia .eq. nstta .and. nstta_tot .gt. nstta) write (iout,9461)
      end do
      if (nsltp .ne. -1 .and. nstta .gt. 0) then
        do i=2,ncop
          j=ncop-i+2
          qtot(j)=qtot(j)-qtot(j-1)
          do k=1,3
            dipxyz(k,j)=dipxyz(k,j)-dipxyz(k,j-1)
          end do
        end do
        ia0=1
        do i=1,ncop
          call cofms(cslt,crmcop(1,i),iclslt,ia0,nacp(i),0,wmscop(i))
          ia0=nacp(i)+1
          diptot(i)=0.0
          do k=1,3
            diptot(i)=diptot(i)+dipxyz(k,i)**2
          end do
          diptot(i)=sqrt(diptot(i))
        end do
        if (ncop .gt. 1) write (iout,9183)
        write (iout,9145)
     -    ((crmcop(k,i),k=1,3),wmscop(i),i=1,ncop)
        if (ncop .gt. 1) write (iout,9182)
        write (iout,9181)
     -    ((dipxyz(k,i),k=1,3),diptot(i),qtot(i),i=1,ncop)
      end if
      rad2max=0.0
      ngmpercol=3
      if (nsltp .gt. 0) then
        write (iout,9402)
        is0=1
        ncol=0
        nsttgp=igrslt(min0(nsltp,nstta))
        do icg=1,nsttgp
          qsm=0.0
          rad2=0.0
          do ia=ifgrslt(icg),ilgrslt(icg)
            qsm=qsm+qslt(ia)
            if (igrcnt(icg) .gt. 0) then
              r2=arrdist(cslt(1,ia),cslt(1,igrcnt(icg)))
              if (r2 .gt. rad2) rad2=r2
            end if
          end do
          if (rad2max .lt. rad2) rad2max=rad2
          if (rccon .gt. 0 .and. abs(qsm) .gt. 0.001) then
            write (iout,9296) icg,qsm
            nwwarn=nwwarn+1
          end if
          ncol=ncol+1
          qtot(ncol)=qsm
          qsumint(ncol)=' '
          qsm10000=qsm*10000.0
          if (qsm10000 .gt. 0.0) qsm10000=qsm10000+0.1
          if (qsm10000 .lt. 0.0) qsm10000=qsm10000-0.1
          iqsm10000=int(qsm10000)
          if (mod(iqsm10000,10000) .ne. 0) qsumint(ncol)='*'
          radgrp(ncol)=sqrt(rad2)
          if (ifgrslt(icg) .le. nsltp .and. ncol .eq. ngmpercol .or.
     -        ilgrslt(icg) .ge. nsltp) then
            icg0=icg-ncol
            write (iout,9295) (ic,labslt(1,ifgrslt(ic)),ifgrslt(ic),
     -        ilgrslt(ic),qtot(ic-icg0),qsumint(ic-icg0),
     -        radgrp(ic-icg0),ic=icg0+1,icg0+ncol)
          end if
          if (ncol .eq. ngmpercol) ncol=0
        end do
        if (iop(65) .eq. 4) then
c         Check maximum group radius vs the cutoff
          radmax=sqrt(rad2max)
          if (2.0*radmax .gt. cutuu) then
            write (iout,9297) 'molecules'
            nwwarn=nwwarn+1
          else if (cutuu-2.0*radmax .lt. 4.0) then
            write (iout,9298) 'molecules'
            nwarn=nwarn+1
          end if
        end if
      end if
      rad2max=0.0
      do im=1,nsttm
        nn=0
        qsm=0.0
        call findifmolinc(iop,nstfm0,ifdummy,im,ifinc)
        rad2=0.0
        do ia=ifirstm(im)-ifinc,ilastm(im)
          nn=nn+nneig(ia)
          qsm=qsm+qslt(ia)
          r2=arrdist(cslt(1,ia),cslt(1,molcnt(im)))
          if (r2 .gt. rad2) rad2=r2
        end do
        if (rad2max .lt. rad2) rad2max=rad2
        if (mod(nn,2) .ne. 0) then
          write (iout,9399) im,nn
          call checknnlist(ifirstm(im),ilastm(im),nneig,ineig,
     -      iout,inperr,nwwarrn,nerr,0,1,0,#NL,#ST)
          inperr=inperr+1
          if (nsttm .eq. 1 .or. ntopwwarn .eq. 0) write (iout,9521)
        end if
        nring=nn/2-(ilastm(im)-ifirstm(im))
        if (nsttm .eq. 1) write (iout,9415) nring
        qsm10000=qsm*10000.0
        if (qsm10000 .gt. 0.0) qsm10000=qsm10000+0.1
        if (qsm10000 .lt. 0.0) qsm10000=qsm10000-0.1
        l1(im)=nring
        l2(im)=qsm10000
      end do
      if (nsttm .gt. 1) then
        write (iout,9397)
        ncol=0
        do im=1,nsttm
          ncol=ncol+1
          rad2=0.0
          do ia=ifirstm(im)-ifinc,ilastm(im)
            r2=arrdist(cslt(1,ia),cslt(1,molcnt(im)))
            if (r2 .gt. rad2) rad2=r2
          end do
          if (rad2max .lt. rad2) rad2max=rad2
          radgrp(ncol)=sqrt(rad2)
          qsumint(ncol)=' '
          qtot(ncol)=float(l2(im))/10000.0
          if (mod(l2(im),10000) .ne. 0) qsumint(ncol)='*'
          if (im .le. nsttm .and. ncol .eq. ngmpercol .or.
     -        im .ge. nsttm) then
            im0=im-ncol
            write (iout,9398) (ifirstm(ic),ilastm(ic),qtot(ic-im0),
     -        qsumint(ic-im0),l1(ic),radgrp(ncol),ic=im0+1,im0+ncol)
          end if
          if (ncol .eq. ngmpercol) ncol=0
        end do
        if (iop(65) .eq. 2) then
c         Check maximum solute molecule radius vs the cutoff
          radmax=sqrt(rad2max)
          if (2.0*radmax .gt. cutuu) then
            write (iout,9297) 'molecules'
            nwwarn=nwwarn+1
          else if (cutuu-2.0*radmax .lt. 4.0) then
            write (iout,9298) 'molecules'
            nwarn=nwarn+1
          end if
        end if
      end if
      call bondtypestat(nneig,ineig,nstta,ianslt,iout,#NL)
      if (nstta .gt. 0) then
        do ia=1,99
          if (idbpr(ia) .ne. 0) write (iout,9400) iatnam(ia),idbpr(ia)
        end do
      end if
      if (nmolec .gt. 1) then
        write (iout,9060) nmolec-1,natoms
        if (nsltp .ne. -1) then
          if (iop(39) .gt. 0) write (iout,9170) nslv
          if (iop(26) .eq. 4) write (iout,9131) 'type'
          if (iop(26) .ne. 4) write (iout,9131) 'atno'
        end if
        qslvt=0.0
        dipx=0.0
        dipy=0.0
        dipz=0.0
        pfl='      '
        do ia=1,nslv
          iatno=ianslv(ia)
          if (iatno .le. 0 .or. iatno .gt. 93 .and. iatno .ne. 99) then
            write (iout,9144) iatno
            inperr=inperr+1
            iatno=99
          end if
          iatnop=iatno
          if (iop(26) .eq. 4) iatnop=iclslv(ia)
          lgc=' '
          if (ia .eq. islvrep) lgc='C'
          qslvt=qslvt+qslv(ia)
          dipx=dipx+cslv(1,ia)*qslv(ia)
          dipy=dipy+cslv(2,ia)*qslv(ia)
          dipz=dipz+cslv(3,ia)*qslv(ia)
          if (iop(26) .eq. 4) pfl=pflabslv(ia)
          if (nsltp .ge. 0) write (iout,9143) ia,iatnam(iatno),pfl,
     -      iatnop,lgc,(cslv(k,ia),k=1,3),qslv(ia),epsslv(ia),
     -      sigslv(ia),namslv,labslv(ia)
        end do
        rmaxslt=sqrt(rmaxslt)
        if (iop(43) .eq. 0 .and. rmaxslt .gt. 0.0) then
          if (cutslt .lt. rmaxslt .and. cutslt .lt. rinscr) then
            if (nmc .eq. 0) then
              write (iout,9146) '***** ERROR',cutslt,rmaxslt
              inperr=inperr+1
            else
              write (iout,9146) '----- STRONG WARNING',cutslt,rmaxslt
              nwwarn=nwwarn+1
            end if
          else if (cutslt-rmaxslt .lt. 5.0) then
            write (iout,9147) cutslt,rmaxslt
            nwwarn=nwwarn+1
          end if
        end if
        if (nsltp .gt. 0) then
          call arrdiff(cm,cslv,rlcslv,3)
          write (iout,9145) cm,wmslv
          dip=sqrt(dipx*dipx+dipy*dipy+dipz*dipz)
          write (iout,9181) dipx,dipy,dipz,dip,qslvt
          if (imaxslt .gt. 0) write (iout,9180) rmaxslt,imaxslt
        end if
        if (abs(qslvt) .gt. 0.01) then
          write (iout,9450)
          nwwarn=nwwarn+1
        end if
        if (rccon .gt. 0 .and. abs(qslvt) .gt. 0.001) then
          write (iout,9299) qslvt
          nwwarn=nwwarn+1
        end if
      end if
      if ((iop(30) .eq. 7).and. iop(38) .lt. 2) then
c       Compare types on the three solute copies - they should agree
        n3=nstfa/3
        do i=1,n3
          if (iclslt(i) .ne. iclslt(n3+i) .or. iclslt(i) .ne.
     -        iclslt(2*n3+i)) then
            inperr=inperr+1
            write (iout,9405) i,iclslt(i),iclslt(n3+i),iclslt(2*n3+i)
          end if
        end do
      end if
      if (iop(20) .gt. 0) then
c       Check if all modified pf's are used
        do ip=1,9
          if (ipfmod(ip) .gt. 0) then
            do ia=1,nstta
              if (iopslt(ia) .eq. ip) go to 8116
            end do
c           Check if remaining pftype is the general solvent
            if (iop(26) .ne. 4 .or. ip .ne. iop(37)) then
              write (iout,9016) ipf(ip),ip
              nwarn=nwarn+1
            end if
8116        continue
          end if
        end do
      end if
      if (ipflibprint .gt. 0 .or. iop(3) .eq. 2) then
        call printljconst(0,nmolec,nstta,nslv,
     -    ipflibprint,iprtlibcomb,0,nwarn,iout)
        ipflibprint=0
      end if
c     Check run parameters against program limits
      if (nslv .lt. nsvtmx) then
        write (iout,9352) nslv,nslvst(iop(3))
        inperr=inperr+1
      end if
      if (iop(30) .ge. 7 .and. iop(38) .gt. 0) then
c       Check if the first two solute copies have matching atomtypes
        do i=1,nstfa0
          if (iclslt(i) .ne. iclslt(nstfa0+i)) then
            write (iout,9403) i,iclslt(nstfa0+i),iclslt(i)
            inperr=inperr+1
          end if
        end do
      end if
      if (nslv .lt. nslvsv) then
        write (iout,9351) nslv,nslvsv
        inperr=inperr+1
      end if
      if (iop(30) .eq. 7 .and. cplmax .lt. cplmin) then
        write (iout,9357)
        inperr=inperr+1
      end if
      if (iop(30) .eq. 6 .and. ptiexpmax .gt. 1.0) then
        inperr=inperr+1
        write (iout,9358)
      end if
      if (iop(30) .eq. 6) then
c       Check initial and final state coupling parameter for order
        if (uspar1 .le. uspar0) then
          inperr=inperr+1
          write (iout,9362) uspar0,uspar1
        end if
        if (iop(35) .gt. 0 .and. uspro1 .le. uspro0) then
          inperr=inperr+1
          write (iout,9362) uspro0,uspro1
        end if
      end if
      if (iop(51) .ge. 1) then
c       Check adaptive US manipulating factors for magnitude
        if (faclim .gt. 1.0) then
          inperr=inperr+1
          write (iout,9370)
        end if
        if (fcenc1 .lt. 1.0) then
          inperr=inperr+1
          write (iout,9371)
        end if
        if (fcenc2 .lt. 1.0) then
          inperr=inperr+1
          write (iout,9372)
        end if
        if (encexp .ge. 1.0 .and. iopenc .gt. 0) then
          inperr=inperr+1
          write (iout,9373)
        end if
        if (ratmax .lt. 1.0) then
          inperr=inperr+1
          write (iout,9374)
        end if
      end if
      if (iop(38) .eq. 2 .and. (iop(3) .eq. 2 .or. iop(29) .eq. 2)) then
        inperr=inperr+1
        write (iout,9363)
      end if
      if (icompopt(5) .eq. 0) then
c       Slt torque calculations are disabled - check if slt is immobilized
        if (rtxslt .gt. 0.0 .and. iop(19) .eq. 0 .and.
     -    iop(6) .gt. 4) then
          inperr=inperr+1
          write (iout,9021) 'solute torque','TS'
        end if
      end if
      if (iop(21) .gt. 0) then
        if (iop(26) .eq. 0) then
          inperr=inperr+1
          write (iout,9375) 'MCY'
        end if
        if (iop(26) .eq. 3) then
          inperr=inperr+1
          write (iout,9375) 'TIP5P'
        end if
        if (iop(3) .eq. 2) then
          inperr=inperr+1
          write (iout,9376)
        end if
      end if
      if (isize .ge. 64) then
        if (iop(21) .lt. 2) then
          write (iout,9383)
          nwarn=nwarn+1
          if (iop(13) .eq. 0 .and. nmcmax .gt. 100000) then
            iop(21)=2
            write (iout,9384)
          end if
        end if
      else
        if (iop(21) .eq. 2) then
          write (iout,9407)
          nwarn=nwarn+1
          if (iop(13) .eq. 0 .and. nmcmax .gt. 100000) then
            iop(21)=1
            write (iout,9408)
          end if
        end if
      end if
      if (nsolvfix .ge. numsolv .and. nmcmax .gt. 0 .and.
     -    numsolv .gt. 0 .and.
     -    .not. (nsolvfix .eq. numsolv .and. iop(41) .gt. 0)) then
        inperr=inperr+1
        write (iout,9380) nsolvfix,numsolv
      end if
      if (iop(92) .gt. 0 .and. iop(17) .ne. 1 .and. iop(12) .gt. 3) then
        write (iout,9377)
        inperr=inperr+1
      end if
      if (iop(3) .eq. 2) then
        if (iop(12) .gt. 3 .and. iop(17) .eq. 1 .or.
     -      iop(63) .gt. 0 .and. iop(8) .eq. 1) then
          write (iout,9390)
          inperr=inperr+1
        end if
      end if
      if (iop(5) .eq. 2) then
        if (iop(26) .ne. 4) then
          inperr=inperr+1
          write (iout,2631) 'general solvent'
        end if
        if (nsltfreq .gt. 0) then
          inperr=inperr+1
          write (iout,2631) 'fixed solute'
        end if
      end if
      if (iop(41) .gt. 0) then
        if (iop(63) .gt. 0) then
          if (iop(41) .eq. 3) then
            write (iout,9395) ngfree
            inperr=inperr+1
          end if
        end if
        if (iop(30) .gt. 0) then
          if (iop(30) .ne. 7) then
            inperr=inperr+1
            write (iout,9394)
          end if
        end if
        if (max0(ngrid(1),ngrid(2),ngrid(3)) .ge. 512) then
          inperr=inperr+1
          write (iout,9404)
        end if
        if (iop(5) .gt. 2 .and. iop(5) .ne. 4) then
c         Forbid HCP and TOCT in the GCE for now
          inperr=inperr+1
          write (iout,9413) iop(5)
        end if
        if (densty .lt. 0.2 .and. ba .lt. 0.0) then
          write (iout,9412)
          nwwarn=nwwarn+1
        end if
      end if
C@NN      if (nupdat .lt. 0) then
C@NN        inperr=inperr+1
C@NN        write (iout,9389) filenames(1)(1:namlens(1))
C@NN      end if
      if (iop(43) .gt. 0) then
c       Check for solute group order when used
        icg0=0
        do ia=1,nstta
          if (igrslt(ia)-icg0 .lt. 0) then
            write (iout,9291) ia
            inperr=inperr+1
          end if
          icg0=igrslt(ia)
        end do
      end if
      if (iop(90) .gt. 0) then
c       Check if all Charmm segment id's are present
        nblank=0
        do ia=1,nstta
          if (fcglab(ia)(5:8) .eq. '    ') then
            nblank=nblank+1
            iblank=1
          end if
        end do
        if (nblank .gt. 0) then
          write (iout,9292) nblank,iblank
          inperr=inperr+1
        end if
      end if
      return
1000  format(f6.2,f9.6)
0210  format(' SLTA: Solute is periodic along the x axis')
0220  format(' SLTA: Solute is periodic along all three axes')
0300  format(' SUPT: There are',i6,' solute atoms using the potential',
     -  ' library ',a32)
0410  format(' DSTC: Pair energy and dipole correlation distributions',
     -  ' are not calculated')
0420  format(' DSTC: Bulk solute and solvent distribution functions ',
     -  'are not calculated at all')
0421  format(a,' WARNING: solute ',a,' are active - distributions ',
     -  'calculated with the DSTC are of questionable meaning',/,
     -  7x,'You may want to use the Proximity analysis options')
0490  format(' SVDP: Solvent dipole moment distribution will be ',
     -  'calculated w.r.t. the axes',/,
     -  7x,'exa=',3f10.5,/,7x,'eyb=',3f10.5,/,7x,'ezc=',3f10.5)
0500  format(' PBCN: Boundary conditions: rectangular',/,
     -  7x,'Unit cell edge in the x direction=',f17.5,' A',/,
     -  7x,'Unit cell edge in the y direction=',f17.5,' A',/,
     -  7x,'Unit cell edge in the z direction=',f17.5,' A')
0510  format(' PBCN: Boundary conditions: face-centered cubic',/,
     -  7x,'Unit cell parameter=',19x,f12.5,' A')
0520  format(' PBCN: Boundary conditions: hexagonal close packed',/,
     -  7x,'Diameter of the inscribed sphere=',f12.5,' A')
0530  format(' PBCN: Boundary conditions: truncated octahedron',/,
     -  7x,'Distace from center to square face=',f12.5,' A')
0540  format(' PBCN: Boundary conditions: hexagonal prism (axis of the',
     -  ' prism is along the X axis, vertex of the hexagon is on the',
     -  'Z axis)',/,7x,'Length of the hexagonal prism=',f19.5,' A',
     -  7x,'Edge of the hexagon=',f12.5,' A')
0550  format(' PBCN: Sphere boundary conditions - sphere radius=',
     -  f8.4,' A')
0560  format(' PBCN PHS : Primary hydration shell model calculation, ',
     -  'target shell energy=',e12.5,a,' force constant=',e12.5)
0561  format(' PBCN PHS : Frequency of shell radius adjustment=',i6,
     -  ' initial shell radius=',f6.2,
     -  ' A minimum and maximum radii=',2f7.2,' A')
0562  format(' PBCN PHS : Solvents farther than ca ',f6.2,' A will be ',
     -  'ignored in the per molecule restraining energy calculation')
0563  format(' ***** ERROR: solute-solvent cutoff set by the program (',
     -  f10.5,' A) is smaller than the maximum shell radius (',f10.5,
     -  ')',/,13x,'- this may result in incorrect shell radius ',
     -  'calculation')
0564  format(' ***** ERROR: PHS boundary conditions are incompatible ',
     -  'with the minimum image option change all S**C **MI keys')
0565  format(' ***** ERROR: PHS boundary conditions are requires ',
     -  'solvents - change the PBCN key')
0570  format(' PBCN: Input boundary conditions')
0600  format(' SAMP: Regular Metropolis Monte Carlo moves are ',
     -  'performed inside a ',a6)
0620  format(' SAMP: Regular Metropolis Monte Carlo moves are ',
     -  'performed step lengths kept fixed at',f6.2,' (solute)',f6.2,
     -  ' (solvent) A')
0630  format(' SAMP: Regular Metropolis moves are performed, step',
     -  ' lengths kept in the range',f6.2,' - ',f6.2,' (solute)',f6.2,
     -  ' - ',f6.2,' (solvent) A')
0650  format(' SAMP: Force-biased Metropolis Monte Carlo  lambda=',f8.3)
0660  format(' SAMP: Force bias is scaled down as a function of the ',
     -  'solute-solvent distance.',/,7x,'The scaling function is given',
     -  ' as ',(4(' r=',f8.2,' A  sc=',f8.4)))
0700  format(' SUVC: Solute-solvent  interactions use a',f9.4,' A',
     -  ' spherical cutoff')
0710  format(' SUVC: Solute-solvent  interactions use the minimum ',
     -  'image convention')
0720  format(' SUVC: Solute-solvent  interactions use iso-energy ',
     -  'cutoff based on a',f5.2,' A spherical cutoff',/,11x,
     -  'this suggests a maximum group distance of ',f6.2,' A',
     -  '    Emax/(charge*dipole)=',e12.5)
0811  format(' STEP: Solute is perturbed at every',i5,'-th step')
0910  format(' TRAJ: History file contains coordinates, total energy ',
     -  'and ',a,', saved at each step')
0930  format(' TRAJ: History file contains the mimum energy ',
     -  'configuration')
0940  format(' TRAJ: History file contains full configurations in ',a,
     -  ' form')
0941  format(' RUNS: Frequency of writing the configuration to the ',
     -  'history file=',i9)
0942  format(' MINE: Structures written to the history file are the ',
     -  'minimum energy structures over the last ',i9,' steps',/
     -  'Minimum energy structure over the saved ones will be ',
     -  'saved in a PDB file at the end of the run')
0943  format(' MINE: Minimum energy stucture over the run will be ',
     -  'saved in a PDB file at the end of the run')
0944  format(' ***** ERROR: program is not dimensioned for energy ',
     -  'saving - change #',a,' to at least ',i8,' and recompile')
0951  format(11x,'All atoms are written out')
0952  format(11x,'Non-moving solute atoms are not written out')
0953  format(11x,'Only the ',a,' atoms are written out')
1001  format(' BDHH: ',i4,' bonds between two hydrogens were broken ',
     -  '- use the BDHH key to allow such bond.')
1011  format(' BDHR: ',i4,' bonds between a hydrogen and a heavy atom ',
     -  ' on a different group/residue were broken - use the BDRH key ',
     -  'to allow such bond.')
1021  format(' SCRM: Torsion angles were scrambled at start')
1100  format(' CNFG: Initial configuration: read from configuration ',
     -  'file')
1110  format(' CNFG: Initial configuration: through solute replacement',
     -  ' - solvents overlapping with new solute are discarded')
1120  format(' CNFG: Initial configuration through orientation-',
     -  'preserving  solute and solvent replacement')
1130  format(' CNFG: Initial configuration: random, solute COM is at',
     -  ' the center of the cell')
1131  format(' CNFG: Random angles have been assigned to torsions')
1140  format(' CNFG: Initial configuration: random, (unchanged) solute',
     -  ' local origin is at the center of the cell')
1160  format(' CNFG: Initial configuration: through solute ',
     -  'replacement - no solvents are discarded')
1170  format(' CNFG: Initial configuration: gathered from trajectory',
     -  ' file',a)
1191  format(' GCEN: GCE insertion/deletion acceptance criteria is',
     -  ' calculated by using the full interaction potential')
1192  format(' GCEN: GCE insertion/deletion acceptance criteria is',
     -  ' calculated by omitting the fluctuations in Coulomb term',/,
     -  ' and using only the short-range part of the interaction',
     -  ' potential. ',/,
     -  ' Ensemble averages are NOT corrected for the approx')
1193  format(' GCEN: GCE insertion/deletion acceptance criteria is',
     -  ' calculated by using the fluctuations in Coulomb term',/,
     -  7x,'as the umbrella sampling potential.',/,
     -  7x,'Ensemble averages are corrected correspondingly')
1194  format(' GCEN: Both the regular moves and GCE insertion/deletion',
     -  ' acceptance criteria are calculated by using the',
     -  ' fluctuations',/,
     -  7x,'in Coulomb term as the umbrella sampling potential.',/,
     -  7x,'Ensemble averages are corrected correspondingly')
1200  format(' MOVE: Selection strategy for molecules to be moved: ',
     -  a15)
1211  format(' SUPI: Structure read from the trajectory will be ',
     -  'superimposed on the ',a)
1212  format(' SUPI: Superimposition will be based on atoms',
     -  ' selected by range')
1213  format(' SUPI: Superimposition will be based on atoms ',
     -  'that are ',f6.2,' A from atom #',i6)
1214  format(' SUPI: Number of atoms used for superimposition=',i7)
1231  format(' MOVE: Preferential sampling selection of molecules to ',
     -  'be moved')
1240  format(7x,'The weight function is piecewise linear defined ',
     -  'by points',/,(6x,4(1x,a1,'=',f8.2,' A  w=',f10.4)))
1250  format(7x,'The weight function=constant if r<R=',f8.2,
     -  ' otherwise =',f8.2,'+',8(f8.2,'1/r**',i1))
1260  format(7x,'The weight function is exponential: W = exp (',
     -  f10.5,' * R^2 (A) )')
1300  format(29x,'Energy  Virial   Torsion angle   COM   Rot matrix ',
     -  ' solute pos   D12     D13  wsums cos/sin',/,' SLFT: Self test',
     -  ' tolerances:',2e8.1,5x,f6.3,5x,e7.1,e9.1,e12.1,2x,3e8.1,f7.3)
1310  format(' SLFT: ',a,' self test will be performed at every ',i8,
     -  '-th MC step')
1320  format(' SLFT: The program will ',a,' after a failed ',a,
     -  ' self test')
1420  format(' NSLV: First',i7,' solvent molecules are not moved')
1480  format(' Bond list is read from file ',a,' instead of ',
     -  'generating it')
1700  format(7x,'Preferential sampling function uses distance from ',
     -  'the solute COM')
1710  format(1x,'Preferential sampling function uses the distance',
     -  ' between the first solvent atom and the nearest solute heavy',
     -  ' atom')
1720  format(7x,'Preferential sampling function uses the distance',
     -  ' between the first solvent atom and (',3f8.3,') A')
1800  format(' FREE PMF1: Linear coupling, simple translation')
1801  format(' FREE PMF1: Linear coupling, general change')
1810  format(' FREE PMF1: Two rigid parts, both move')
1820  format(' FREE PMF1: Two rigid parts, only the first part moves',/,
     -  12x,'Molecule ',i3,' is considered the second part')
1830  format(' FREE PMF1: Second part of the solute is rotated too by ',
     -  'the coupling parameter')
1811  format(' FREE PMF1: The PMF calculations are performed between ',
     -  'molecules ',i4,' and',i4)
1838  format(' ***** ERROR: torsion group',i4,' of torsion',i5,' has ',
     -  'more than one member - incompatible with skewed sampling')
1839  format(' Sampling of torsion',i5,' will be biased toward',f7.1,
     -  ' deg')
1840  format(' FREE PMF1: Coupling is in the torsion space. The ',
     -  'coupling affects the first torsion group listed below')
1841  format(' TORD: Torsion',i5,': ',3(i4,1x,a8,'-'),i4,1x,a8,
     -  ' initial and final angles=',2f8.3,' Range=',f8.3)
1842  format(' ***** ERROR: No potential file information has been ',
     -  'read for torsion change')
1843  format(' TORD: Torsion',i5,' (',i5,'): ',3(i5,1x,a8,'-'),i5,1x,a8,
     -  ',',i5,' co-rotated atoms; stepsize=',f6.2,' deg')
1844  format(' TORD: Torsion group ',i5,' (selection weight=',f8.5,
     -  '; (1st) initial value=',f8.3,' deg) :')
1845  format(a,' WARNING: the maximum number of atoms affected by a ',
     -  'simple torsion (',i5,') is high - consider using the LOOP ',
     -  'key')
1846  format(a,' WARNING: the maximum number of atoms affected by a ',
     -  'LOOP torsion (',i5,') is high - set the simple torsion ',
     -  'step to 0')
1847  format(' TORD: Torsion',i5,' is limited to changes around ',
     -  f8.3,' deg by at most ',f8.3,' deg')
1848  format(7x,'Current angle=',f7.2,1x,a)
1849  format(6x,7(a1,i6,1x,a8,') '))
1850  format(' FREE PMF1: Linear coupling, followed by translation ',
     -  'and/or rotation:')
1851  format(12x,'Displacement range (stepsize) in the x, y, and z ',
     -  'directions:',3f7.4,' A')
1852  format(12x,'Rotation range (stepsize) around the x, y, and z ',
     -  'axes:',3f8.3,' deg')
1853  format(' FREE: Torsion group 1 is controlled by the coupling ',
     -  'parameter')
1854  format(' ----- WARNING: there are too many co-rotated atoms')
1855  format(' ===== STRONG WARNING: there are way too many ',
     -  'co-rotated atoms - consider disabling the simple rotation')
1856  format(' ***** ERROR: torsion',i5,' (',f8.2,' deg) is more than ',
     -  f8.2,' degrees from the reference ',f8.2,' deg')
1910  format(' NFBU: Force-bias is not applied to solute moves')
2100  format(' HRDW: Energy calculation uses scalar routines')
2110  format(' HRDW: Energy calculation uses 32-bit vector routines ')
2120  format(' HRDW: Energy calculation uses Cray vector routines ')
2130  format('       Energy calculation uses MPI distributed memory ',
     -  ' parallel routines ')
2600  format(' SVPT: Water-water potential: MCY-CI type')
2610  format(' SVPT: Solvent: 3 point charges + LJ on oxygen ',
     -  '(TIP3P, etc.) water')
2612  format(15x,' Parameter values: c6(LJ)=',f8.1,' kcal-A**6/mol',
     -  ' c12(LJ)=',f9.1,' kcal-A**12/mol hydrogen charge=',
     -  f7.4,' electron',/,15x,' Source of parameters: ',a8)
2613  format(15x,' Source of parameters: ',a8)
2620  format(' SVPT: Solvent: 3 point charges + LJ on oxygen ',
     -  '(TIP4P, etc.) water - negative charge offset from oxygen')
2630  format(' SVPT: Solvent: 4 point charges (2H and 2 tetrahedral ',
     -  ' lone pairs) + LJ on oxygen (TIP5P water)')
2640  format(' SVPT: Solvent: general 1-6-12 type, parameters obtained',
     -  ' from ',a)
2631  format(' ***** ERROR: Hexagonal close packing (HCP) PBC only ',
     -  'works with ',a,' for now')
2699  format(' VVNE: Solvent-solvent electrostatics is turned off')
2710  format(' CNFG: Simulation cell size is determined from solute ',
     -  'p.m.v=',f8.3,' ml/mol, solvent p.m.v=',f8.3,' ml/mol',/,
     -  7x,'by placing the required number of waters in the cell')
2720  format(' CNFG: Simulation cell size is determined from solute ',
     -  'p.m.v=',f8.3,' ml/mol, solvent p.m.v=',f8.3,' ml/mol',/,
     -  7x,'Preparing ', f8.3,' solvent shells around the solute')
3010  format(' FREE WIDO: Excess free energy will be calculated by the',
     -  ' Widom insertion method',/,
     -  12x,'Cavity radius=',f8.4,' A  Number of x,y,z grids=',3i5,/,
     -  12x,'Number of insertions per cavity=',i3,/,
     -  12x,'Number of grids per configuration=',i2)
3011  format(' FREE WIDO: All gridpoints will be used for insertion of',
     -  ' ghost molecules')
3012  format(' FREE WIDO: ',a,' shift of the grid will be applied ',
     -  'in the ',a1,' direction')
3013  format(12x,'First atom is assumed to be a dummy atom')
3014  format(' ***** ERROR: Dummy Widom atom has non-zero charge:',f9.4)
3015  format(' FREE ',a4,': Ghost molecule ',i2,' (',a8,') global ',
     -  'energy increment=',e12.5,' kcal/mol (to help avoid overflow)')
3016  format(11x,i2,'-point Gaussian quadrature - quadrature point #',
     -  i2)
3020  format(' FREE CHIM: Chimera method to calculate free energy ',/,
     -  12x,'Number of trys to change each solvent=',i3)
3021  format(12x,'Grid along the ',a,' axis')
3022  format(12x,'Grid based on residue proximity',/,
     -  12x,'Maximum solute-water distance for proximity=',f6.2,' A',/,
     -  12x,'Probability of using a non-proximal solvent=',f8.5)
3030  format(' FREE ADDW: Widom method to calculate the excess free ',
     -  'energy of adding a new group to a (for now) rigid ligand')
3033   format(' FREE ADDW: Number of grids to use on the ',a,
     -  ' torsion angle=',i4)
3034   format(' FREE ADDW: Torsion angle increments will be changed ',
     -  'at every',i10,' step')
3031  format(' distance between atoms',i3,' and',i3,' for ghost ',
     -  'molecule',i3,' (',a,') is ',f8.5,' instead of',f8.3,
     -  ' d=',f6.2,' A')
3032  format(' ***** ERROR: the number of torsions on ghost molecule',
     -  i3,' (',a,') is not exactly ',i1,' Torsion range:',i3,' - ',i3)
3050  format(' FREE TICA: Energy coupling parameter integration at E =',
     -  ' P(',f7.5,')*E1 +  P(',f7.5,')*E0')
3051  format(' FREE TICA: TI exponents are set to 1.0 for similar ',
     -  'groups with tolerance for epsilon=',f7.5,' sigma=',f7.5,
     -  ' q=',f7.5,' xyz^2=',f7.5)
3060  format(' FREE PMLI: Perturbation method calculation with U=',
     -  f5.3,' E1 + ',f5.3,' * E0',/,
     -  12x,'Initial state: ',f5.3,' E1 + ',f5.3,' E0 ',
     -  ' final state: ',f5.3,' * E1 + ',f5.3,' E0')
3073  format(12x,'AUS sampling parameters have been changed')
3074  format(12x,'AUS sampling frequency accumulator has been ',
     -  'reinitialized')
3075  format(12x,'All AUS sampling accumulators have been ',
     -  'reinitialized')
3080  format(' FREE PMNL: Calculation of energy difference ',
     -  'distribution for overlap ratio method',/,
     -  12x,'Calculation is combined with',
     - ' perturbation method calculation using U=',f5.3,' E1 + ',
     -  f5.3,' * E0',/,22x,'Initial state: ',f5.3,' E1 + ',f5.3,' E0 ',
     -  ' final state: ',f5.3,' * E1 + ',f5.3,' E0')
3100  format(' CHRG:        Internally stored OPLS charges were used')
3110  format(' CHRG:        OPLS charges from input were used')
3210  format(' DSTC: No distribution function file (.dst) is written')
3300  format(' INCT: No inner-core modification will be done on the ',
     -  'solvent-solvent potential')
3310  format(' INCT: Solvent pairs closer than',f7.4,' A will be given',
     -  ' an interaction energy of 1000.0 + 10.0*exp(',f7.4,
     -  '**2-rww**2) kcal/mol')
3400  format(' STPS: Stepsizes will be scaled down when a molecule is ',
     -  'found unmoved after',i5,' cycles')
3410  format(' ----- WARNING: stepsizes were scaled down by',f8.3)
3510  format(' +++++ TICA PMNL: Input solute coordinates c0,c1 were ',
     -  'modified to (1-',f6.4,') * c0 + ',f6.4,' * c1  and (1-',
     -  f6.4,') * c0 + ',f6.4,' * c1',/,18x,'to define a window for ',
     -      ' perturbation calculation',/,18x,'Similar modifications',
     -      ' have been performed on the potential coefficients')
3520  format(18x,'Solute coordinates on file ',a,
     -  ' have also been modified')
3800  format(' FREE PMF1: Coupling changes only the solute geometry',
     -  ' - charges, LJ coefficients remain unchanged')
3810  format(' FREE PMF1: Coupling changes solute geometry and charges',
     -  ' - the LJ parameters remain unchanged')
3820  format(' FREE PMF1: Coupling changes the solute geometry, ',
     -  'charges and LJ parameters')
3900  format(' SLVA:          Built-in solvent description is used')
3901  format(' SLVA:          Solvent description was read')
4110  format(' GCEN: Cavity-biased grand-canonical ensemble simulation',
     -  ' using the grid insertion technique',/,
     -  7x,'Cavity radius=',f10.4,' A',/,
     -  7x,'Number of x, y and z gridpoints=',3i4,/,
     -  7x,'Grid intervals in the x, y and z directions=',3f5.2,' A')
4111  format(' GCEN: Chosen average solute-solvent Coulomb energy/',
     -  'solvent molecule=',f12.5,' kcal/mole. This corresponds to',
     -  ' bp=ba-uscav=',f12.5)
4112  format(' GCEN: Umbrella sampling correction wrt solute-solvent',
     -  ' Coulomb interaction is applied to insertion/deletion moves',
     -  /,7x,'US is proportional to Ucoul with a mixing parameter',
     -  ' of',f12.5)
4113  format(' GCEN: Umbrella sampling correction wrt solute-solvent',
     -  ' Coulomb interaction is applied both to insertion/deletion',
     -  /,7x,'and to regular moves. US is proportional to Ucoul with a',
     -  ' mixing parameter of',f12.5)
4114  format(' ----- WARNING: largest grid interval is not less than ',
     -  ' 0.5 A - this may affect the quality of sampling',/,
     -  7x,'- increase the number of gridpoints.')
4115  format(' Density at the target number of solvents (',i6,')=',
     -  f8.4,' g/ml')
4116  format(' ----- WARNING: target density is suspiciously low/high')
4117  format(' ===== STONG WARNING: target density is very low/high')
4118  format(' STPX: Calculation will be stopped and configuration ',
     -  'saved when the number of solvent molecules reaches',i7)
4120  format(' GCEN: Insertion is into a cube around the grid')
4130  format(' GCEN: Grand-canonical ensemble simulation using random ',
     -  'insertions')
4190  format(' ***** ERROR: GCEN run with MPI is currently ',
     -  'incompatible with the following keys: PBCN PHS and FREE')
4191  format(' ***** ERROR: GCEN run is currentli incompatible with ',
     -  'the ',a,' key')
4210  format(' IDLG: Insertion and deletion log will be written on ',
     -  'file ',a,' unit number=',i6)
4212  format(7x,'Proximal solute atoms will also be specified; i/d ',
     -  'sites within',f6.2,' A from the solute are listed')
4213  format(' ***** ERROR: IDLG ASPX requires MOVE PRF* NRST')
4214  format(' IDAC: Proximity insertion/deletion acceptance rates ',
     -  'will be calculated for i/d within',f6.2,' A of the solute')
4215   format(' IDAC: Solute atoms to be used for acceptance rate ',
     -  'statistics are limited to the ranges ',5(i6,' -',i5),
     -  (/,10(i6,' -',i5)))
4300  format(' SUVC: Solute-solvent interactions are calculated using ',
     -  'PBC-based distances from the ',a)
4400  format(' NMVP: Solvents with acceptance rate less than ',i2,'% ',
     -  'will be listed with their distance to the nearest solute atom')
4410  format(' MVRT: Translations and rotations will alternate for ',a,
     -  ' moves - fraction of displacements=',f6.3,
     -  ' fraction of rotations=',f6.3)
4510  format(' OVST:Second copy of the solute was changed to improve',
     -  ' overlap with the first')
4610  format(' CHRG: The charges on the solute and on the solvent ',
     -  'have been set to zero')
4700  format(' CNFG: Configuration file ',a,' is ',a,' - unit number=',
     -  i6)
4910  format(' RCKP:History file pointer will be modified if file is ',
     -  'short')
5010  format(' CNFG: In case of discrepancy between coordinates read',
     -  ' with the SLTA key and coordinates read with the CNFG key',/,
     -  7x,'(threshold=',f6.4,' A) the ones read with the ',a4,' key ',
     -  'will be used for both')
5040  format(' CNFG: Difference between input solute coordinates and ',
     -  'coordinates stored on the .crd file wil be ignored')
5100  format(' FREE PMF1: Probability ratio method')
5101  format(' FREE PMF1: Harmonic umbrella sampling',/,
     -  12x,'Coupling parameter limits=',2f8.4,/,
     -  12x,'US potential=',f10.4,' * (cplpar - ',f6.4,')**2')
5111  format(12x,'Number of iteration used so far=',i4,' Number of ',
     -  'iterations stored=',i4)
5200  format(' MIXR: Lennard-Jones epsilon and sigma parameters ',
     -  'combine with geometric mean rule')
5210  format(' MIXR: Lennard-Jones epsilon and sigma parameters ',
     -  'combine with geometric and arithmetic mean rule, respectively')
5400  format(' SVVC: Solvent-solvent interactions use a',f9.4,' A',
     -  ' spherical cutoff')
5401  format(30x,'Cutoff on the exponential term:',f12.4,' A')
5410  format(' SVVC: Solvent-solvent interactions use the minimum ',
     -  'image convention')
5490  format(' IGSV: Solvent-solvent interactions are ignored')
C@NN5491  format(' ----- WARNING: when the IGSV key is present, the ',
C@NN     -  'solvent-solvent bitmap option (NN) can be turned off to save',
C@NN     -  ' space')
5710  format(' PART: Partial solute moves performed on the molecules ',
     -  i4,' - ',i4,' (atoms ',i6,' - ',i6,')')
5711  format(' PARD: Solute group shift sizes= ',3f9.4,' A',4x,
     -  ' Solute group rotation angles= ',3f9.4,' degrees')
5712  format(' PARD: Solute group shift sizes= ',3f8.4,' A',4x,
     -  ' Solute group rotation size parameters= ',3f9.4,' A')
5713  format(' PART: Solute axis selection weights=',3f8.4)
5720  format(1x,a,': ',a,' sampling is uniform')
5730  format(1x,a,': ',a,' sampling is extension biased, inversely ',
     -  'proportional to the ',a)
5722  format(' SETC FC14: The 1-4 interactions are included with a ',
     -  'factor of',f5.2,' for electrostatic and  of',f5.2,
     -  ' for VdW terms')
5723  format(' FCIN: Solute intramolecular energy will not be added ',
     -  'to the total energy')
5724  format(' FCIN: Solute intramolecular energy will be added to ',
     -  'the total energy with a factor of ',f8.5)
5725  format(' ----- WARNING: no torsions are active, but the ',
     -  'intramolecular energy is not used fully')
5790  format(' PARD: The relative frequencies of ',a,'=',f6.3)
5798  format(' ***** ERROR: stepsize scaling and stepsize tuning are',
     -  ' incompatible for ',a,' moves')
5799  format(' ***** ERROR: there is no solvent and no solute moves ',
     -  'are specified')
5810  format(' PART: Solute torsion space is also sampled')
5811  format(' PRMF: Parameter file used for torsion potential: ',a)
5812  format(' TORD: Default stepsize for ',a,' torsions=',f10.5)
5813  format(' ***** ERROR: Invalid LOOP weight war read: ',f10.5)
5814  format(' LOOP: No simple torsions will be performed on loop ',
     -  'driver torsions')
5815  format(' LOOP: When possible, loop moves will be executed in ',
     -  f6.1,'% of attempts, in random order.')
5816  format(' TORD: Simple torsions farther than ',i4,' atoms from ',
     -  'the end of its chain will be disabled')
5817  format(7x,'The following loop types are implemented: ',/,
     -  (14x,3('LP',i1,1x,a30,2x)))
5818  format(' TORD: ',a,' step range values',a,'were multiplied by ',
     -  f8.4)
5819  format(' LOOP: Regular torsions will not be sampled for driver ',
     -  'torsions of loop moves')
6010  format(' PROT: Bare electrostatic interactions are protected ',
     -  'with a repulsion term of ',f10.4,'/r**12 kcal/A**12')
6011  format(' SETC DIEL: Dielectric constant=',f8.3)
6012  format(' ===== STRONG WARNING: dielectric constant > 1 in the ',
     -  'presence of solvent is a questionable model')
6013  format(' ===== STRONG WARNING: force calculation code does not ',
     -  'include the reaction field contribution for now')
6014  format(' ===== STRONG WARNING: distance-dependent dielectic is ',
     -  'only applied to solvent-solvent interactions with general ',
     -  'solvent')
6200  format(7x,'Solute atom radii are based on ',a)
6301  format(' PRFI: Preferential sampling selection of molecules to ',
     -  'be inserted or deleted')
6410  format(' SWAP:Solute group swaps will also be attempted')
6411  format(' ----- WARNING: swapped solute groups are not of the ',
     -  'same size - swap attempts questionable. Range of sizes: ',
     -  '[',i6,',',i6,']')
6412  format(' ===== STRONG WARNING: swapped solute group size ',
     -  'difference exceeds 10% - swaps are unlikely to be accepted')
6500  format(' SUUC: Solute-solute interactions are calculated ',
     -  'without PBC')
6510  format(' SUUC: Solute-solute interactions are calculated using ',
     -  'minimum image convention based on ',a,' center distances')
6511  format(' SUUC: Solute-solute interactions are limited to ',a,
     -  ' center distances of ',f6.2,' A')
6600  format(' MV2S: Correlated 2-solute molecule moves performed ',
     -  'around the ',a1,' axis')
6601  format(' MV2S: Correlated 2-solute molecule moves will be ',
     -  'limited to pairs at most ',f5.2,' A apart')
6602  format(' MV2S: Correlated 2-solute molecule moves will always ',
     -  'be done on nearest neihbors')
6610  format(7x,'Rotation stepsize ',a,'=',f10.5,1x,a)
6710  format(' SPST: Field-dependent solute potential integer ',
     -  'parameters=',10i5)
6711  format(' SPST: Field-dependent solute potential real ',
     -  'parameters=',10f10.5)
6712  format(' SPST: Map-based field-dependent potential. ',/,
     -  7x,'Number of grids in the map=',i4,' Grid spacing=',f5.3,
     -  ' Edge of the map=',f8.5,' A',/
     -  7x,'Grid center=',3f8.2,' vdW energy maximum=',e10.3,
     -  ' Electrostatic energy minimum=',e10.3,/,
     -  7x,'VdW maps are provided for atoms ',13a5)
6713  format(' PBCN: The ',a,' sphere of the periodic cell (r=',f8.3,
     -  ')',' is ',a,' than that of the grid (r=',f8.3,')')
6714  format(1x,a,': ',10(a4,'/',a4,1x))
6715  format(' SVIN: intramolecular desolvation terms are also ',
     -  'calculated with the Autodock-4 parametrization',/,
     -  7x,'k=',f8.5,' Gaussian distance=',f5.2,' A')
6716  format(7x,'Atom type: ',a,1x,a,' Asp=',f8.5,' V=',f9.5)
6717  format(' SVIN: desolvation term cutoff=',f10.4,' A',
     -  ' (',f6.2,'* 2*sigma**2)')
6718  format(' SVIN: desolvation term only applied to carbons')
6719  format(' SVIN: desolvation term is not applied to hydrogens')
6720  format(' SPST: Molecule-dependent solute potential integer ',
     -  'parameters=',10i5)
6721  format(' SPST: Molecule-dependent solute potential real ',
     -  'parameters=',10f10.5)
6722  format(' SVIN: Desolvation term is not applied to polar-polar',
     -  ' interactions')
6723  format(' SPST: Energy maps were ',a)
6724  format(' SVIN: Desolvation term is applied only to nonpolar ',
     -  'carbons')
6725  format(7x,'Carbons (UA) are considered polar when q(sum) >',f6.3)
6726  format(' SPST: All energy maps have been multiplied by',f8.4)
6727  format(' ENHB: ',a,'-molecular',a,'terms are not calculated')
6728  format(' ===== STRONG WARNING: Desolvation map calculation ',
     -  '(nonpolar carbons only) is incompatible with the SVIN ',
     -  'option')
6729  format(' L-J parameters used for VdW map generation:',/,18x,10a12)
6730  format(1x,a10,1x,a3,':',10f12.2)
6731  format(7x,'Hydrogen-bond donor/acceptor map gridsize=',f6.4,
     -  ' Number of grids=',i4)
6732  format(1x,a,' distance from the box:',/,(8x,'in the -',a1,
     -  ' direction=',f5.2,' in the +',a1,' direction=',f5.2))
6740  format(' SPST: Solvents are excluded from the region ',a,' < ',
     -  f6.2,' & ',a,' > ',f6.2)
6741  format(' ***** ERROR: Lower bound exceeds the opper bound')
6786  format(' ENHB: Hydrogen-bond potential for solute - ',a,
     -  ' interactions is of the form ',/,25x,'e(HB)=',a,
     -  '(A/r**12 - B/r**10) * cos(O-H_N)',a,i1,' * cos(LP-O_H)^',i1,/,
     -  25x,'LP-O-LP angle for >C=O lone pairs=',f7.2,' deg')
6787  format(' ***** ERROR: FREE ADDW is incompatible with ENHB 2ANG ',
     -  '- use EBHB SMPL')
 
6789  format(' ENHB: Hydrogen-bond potential will be used for',
     -  f5.2,' < O-H distances <',f5.2,' A & O...H-N angle > 90 deg')
6791  format(' ENHB: Hydrogen-bond donor hydrogens and ',
     -  'acceptor oxygens:')
6792  format(7x,'A(',a,'...',a,')=',f8.1,' B(',a,'...',a,')=',f8.1,
     -  ' Rmin(heavy)=',f6.2,' A (',i2,')')
6793  format(' ENHB: Hydrogen-bond ',a,' with charge ',f6.3,1x,a,
     -  ' will be considered ',a,' type ',a)
6794  format(' ENHB/HBMO: Hydrogen-bond donor type #',i2,': ',a4,4x,
     -  'Number of explicit donors=',i5,4x,'Number of map donors=',i5)
6795  format(' ENHB/HBMO: Hydrogen-bond acceptor type #',i2,': ',a4,
     -  ' Number of explicit acceptors=',i5,
     -  ' Number of map acceptors=',i5)
6800  format(' SPSM: Special sampling technique will be used - NOT YET')
6910  format(' CLON: Solute atoms ',i5,' - ',i5,' were expanded into',
     -  i5,' copies')
6920  format(7x,'Cloned solute atoms are omitted from the list below ',
     -  'unless PRNT DETL or higher is set')
6911  format((' MAKB: Additional bonds: ',8(i5,' -',i6),','))
6912  format((' BRKB: Broken bonds: ',8(i5,' -',i6),','))
7100  format(7x,'Canonical ensemble')
7101  format(' GCEN: Grand-canonical ensemble with B parameter=',f10.2)
7102  format(' IBEN: Isobaric-isothermal ensemble with pressure=',f9.2,
     -  ' atm Volume change range=',f8.1,' A**3')
7110  format(' IBEN: Isobaric ensemble volume change strategy: ',a,/,
     -  7x,'Volume change range=',f8.2,' A^3')
7111  format(' IBEN: Virial biasing lambda factor=',f6.3)
7200  format(' IBEN: Isotropic volume changes',a)
7210  format(' IBEN: Volume changes involve one axis at a time')
7211  format(' IBEN: No changes will be done along the ',a1,' axis')
7300  format(' PAR*: Selection strategy of solute molecules for ',a,
     -  ': ',a15)
7500  format(' PART: Selection strategy of torsion angles: ',a15)
7610  format(' BTUN: GCE B parameter is tuned to bulk density of ',
     -  f7.4,' g/ml ',a,' the inner rectangle',/,
     -  7x,'Tolerance: +/-',f6.4,' g/ml (',f6.2,' molecules)',/,7x,a,/,
     -  7x,'Number of steps to discard=',i9,' Number',
     -  ' of steps to use for averaging=',i8,' Maximum change in B=',
     -  f5.2)
7630  format(' BTUN: GCE B parameter will be tuned to bulk density of ',
     -  f7.4,' g/ml, ',a,' the inner rectangle requiring',f10.1,
     -  ' solvent molecules',/,
     -  7x,'Tuning will be using the process control procedure',/,
     -  7x,'Integraltime=',e13.6,' Gain(density)=',e13.6,
     -  ' Gain(N molec)=',e13.6)
7800  format(' LCMP: Compression bias for volume change attemts will ',
     -  'be scaled by a factor of ',f5.3)
7900  format(' LIMG: The cavity grid will only cover the rectangle (',
     -  2(a5,f7.2,' - ',f6.2,1x,a5,','),a5,f7.2,' - ',f6.2,1x,a5,')')
8010  format(' MOND: External (bulk) solvent density will be ',
     -  'calculated outside the rectangle (',2(f7.2,' - ',f6.2,','),
     -  f7.2,' - ',f6.2,')',/,12x,'Volume of the inner rectangle=',
     -  f10.1,' A^3 region outside the inner rectangle=',f10.1,' A^3')
8011  format(' ----- WARNING: the whole box is considered outside ',
     -  'region')
8210  format(' SNES: Boltzmann averages of derivatives with respect to',
     -  ' solute parameters are computed at every 10^(',i2,'-1)-th ',
     -  'cycle')
8300  format(' PBGR: Solute atoms will not be reset to PBC cell for ',
     -  'grid cover calculations')
8310  format(' PBGR: Solute atoms are requested to be reset to PBC ',
     -  'cell for grid cover calculations')
8320  format(' PBGR: Since solute atoms were found outside the PBC ',
     -  'cell they will be reset for grid cover calculations')
8400  format(' TORD: Torsion list is specified by the user')
8410  format(' TORD: All rotatable bonds will be sampled')
8420  format(' TORD: Peptide center(s) will be set to the first BB N ',
     -  'atom and all BB torsions will avoid involving non-BB atoms')
8411  format(' TORD: Torsion angle change will be limited for',i6,
     -  ' torsions')
8510  format(' MOLD: Solute molecules were defined from input')
8710  format(' BUFF: All history file buffers will be emptied when a ',
     -  'checkpoint file is written')
8800  format(' GCEN: ',a,' insertion/deletion order will be used')
8900  format(' GCEN: Pcav is defined as the (number of free grids) /',
     -  ' (',a,')')
9100  format(' The number of ',a,' loops=',i3)
9101  format(' >>>>> OVERRIDE: ',a,' - key LOOP is ignored')
9102  format(' ----- WARNING: failure to find any loop may be due to ',
     -  'missing torsion definition',/,7x,'///// NOTE: by explicitly ',
     -  'setting the topological center of the molecule to the start ',
     -  'of the chain ',/,7x,'(by putting the symbol M in column 52 of',
     -  ' that atom in the .slt file) you may have a longer stretch of',
     -  ' torsions')
9601  format(' NONB: Non-Boltzmann sampling: ',a,' terms are ',
     -  'scaled down by ',f6.4,' for sampling')
9630  format(' NONB: Non-Boltzmann sampling: solute is sampled at T=',
     -  f8.2,' K')
9640  format(' NONB: Non-Boltzmann sampling: solute energies used with',
     -  ' Tsallis statistics (exponent=',f8.5,') for sampling')
9910  format(7x,'r3 position tolerance=',e10.3,' |r2-r4|^2 tolerance=',
     -  f8.6)
9911  format(' LOOP: Nearest solution is picked up step-by step')
9912  format(' LOOP: Nearest solution is picked up by scanning the r3 ',
     -  'circle with',f9.5,' A steps')
9913  format(' LOOP: Solution is picked up by Jacobian weighting after',
     -  ' scanning the r3 circle with',f9.5,' A steps')
9914  format(' LOOP: Tolerance for extended conformation estimates=',
     -  f8.6)
9915  format(' LOOP: Loop root of torsions',1x,6(i6,' (',a8,')'),/,
     -  ' LOOP: Loop move stepsize=',f8.2,' deg  Loop type: LP',i1,1x,a)
9916  format(7x,'Reverse proximity criterion tolerance=',e12.5,' A^2')
9917  format(7x,'d',a,'^2 tolerance=',f12.10,' 1-2 and 1-3 ',
     -  'tolerances for loop integrity=',2f10.7)
9918  format(' LOOP: Loop-closing iteration will be done in the ',a)
9919  format(' SACP: Simulated annealing of the chemical potential - ',
     -  'B-parameter step:',f9.2,/,7x,'Cavity biasing is turned off ',
     -  'when the fraction of free grids exceeds',f6.3)
9920  format(' LIGA: Multi-copy ligand simulation.  -  Last',i4,
     -  ' ligand molecules are non-interacting copies')
9921  format(' PBCN PHS : Solute atom radii are obtained from ',a)
9922  format(' PBCN PHS : Radial distribution function calculations ',
     -  'will assume solvent density=',f8.5,' g/ml')
9923  format(' PBCN PHS : Primary hydration shell will be limited to ',
     -  'solute atoms in the ranges ',5(a,'[',i5,'-',i5,']'))
9924  format(' ***** ERROR: LIGA parameter (',i5,') is not less than',
     -  ' the number of solvent molecules (',i5,')')
9925  format(' ***** ERROR: LIGA parameter (',i5,') is less than zero')
9926  format(' ===== STRONG WARNING: multi-copy ligands are not clones')
9927  format(' ----- WARNING: first multi-copy ligand is a clone')
9928  format(' ===== STRONG WARNING: multi-copy ligands molecule',i4,
     -  ' is not a clone of the first multi-copy ligand')
9929  format(' LOOP: Frozen bond torsion angle signs are enforced for',
     -  ' bonds differing from planarity by less than',f7.2,' deg')
9930  format(' ***** ERROR: distance-dependent dielectric (SETC DDIE)',
     -  ' is incompatible with constant dielectric (SETC DIEL)')
9931  format(' SETC DDIE: Mehler-Solmayer distance-dependent ',
     -  'dielectric:',/,
     -  ' SETC DDIE: eps(r)=',f8.4,' + (',f6.2,' - ',f8.4,
     -  ')/[1 + ',f8.4,' * exp(-',f9.6,' * (',f6.2,' - ',f8.4,') * r)]')
9932  format(' LOOP: frozen bond sign is allowed to flip for all bonds')
9933  format(' SETC DDIE: For distances ',a,f5.2,' A the dielectric ',
     -  'constant is set to',f6.2)
9934  format(' IGJA: Local moves will ignore the Jacobian - sampling ',
     -  'will NOT be Boltzmann-distributed')
9935  format(' SKWT: Selected torsions will be skewed toward a target',
     -  'angle with weight',f6.1,
     -  ' - sampling will NOT be Boltzmann-distributed')
9936  format(' SKWT: Sign of change for selected torsions will be ',
     -  'skewed')
9937  format(' SKWT: Loop solution selection will be skewed')
9938  format(' Solvent coordinates will be written to file ',a,' at ',
     -  'every B parameter change as PDB MODELs')
9939  format(' SKWT: Loop move acceptance will be skewed')
9940  format(' SKWT: Skewed sampling will be suspended when the ',
     -  'stepsize falls below ',f6.2,' deg',/,7x,'and resumed when ',
     -  'the stepsize is raised above ',f6.2,' deg')
9941  format(7x,'Runlength for each step=',i9,a,'number of solvent ',
     -  'molecules')
9950  format(' FREE ADDW: Ligand conformation is assumed to be ',a,
     -  ' during the simulation')
9001  format(/,' R U N   I N F O R M A T I O N:')
9002  format(/,' P O T E N T I A L   F U N C T I O N   ',
     -  'I N F O R M A T I O N:')
9003  format(/,' S T A R T I N G   C O N F I G U R A T I O N  ',
     -  'I N F O R M A T I O N:')
9004  format(/,' F R E E   E N E R G Y   I N F O R M A T I O N:')
9005  format(/,' S A M P L I N G   I N F O R M A T I O N:')
9006  format(/,' S Y S T E M   I N F O R M A T I O N:')
9008  format(a)
9009  format(2i5)
9010  format(' CSEG: Last four character of the solute record is ',
     -  'assumed to  be the Charmm segment id')
 
9014  format(7x,a,' file=',a, ' - unit number=',i4)
9015  format(' ***** ERROR: SGI requires arithmetic bit handling')
9016  format(' ----- WARNING: modified potential library ',a4,
     -  ' (',i1,') is not being used')
C@FR9017  format(' SAMP: Metropolis sampling will be used when force ',
C@FR     -  'or torque cut is applied')
9021  format(' ***** ERROR: ',a,' calculations have been disabled',/,
     -  ' - recompile with the preprocessor variable ',a2,' set ',
     -  'to "T"')
9023  format(' ***** ERROR: Can not ',a,' in the isobaric ensemble')
9024  format(f6.3)
9025  format(' TITL: ',a80)
9030  format(' ***** ERROR: FCC, HCP and TOCT PBC are incompatible',
     -  ' with periodic solute')
9040  format(7x,'Radius of the cells inscribed sphere=',f14.5,' A',/,
     -  7x,'Radius of the cells circumscribed sphere=',f10.5,' A')
9050  format(7x,'The volume of the simulation cell=',f17.5,' A**3',/,
     -  7x,'Density=',10x,f10.6,' g/ml')
9058  format(' FETK: Temperature=',f16.4,' Kelvin',/,
     -  ' Free-energy calculation with TI, coupling parameter=',f8.5,
     -  ' Exponent=',i1,' (',i1,'-point quadrature, ',i1,'-th point)',
     -  ' T used=',f12.2,' K')
9059  format(' TEMP: Temperature=',f16.4,' Kelvin')
9060  format(/,' NSLV: Number of solvents=',i6,7x,'Number of atoms=',i8)
9061  format(' The number of molecules is determined from the ',
     -  'configuration last read')
9062  format(' FLXR: The range of the flexible atoms:',/,
     -  (' FLXR: ',a,'min, center,max,range=',4f10.5))
9080  format(' STEP: Solute shift size= ',f9.4,' A',4x,
     -  ' Solute rotation angle= ',f9.4,' degrees')
9081  format(' STEP: Solute as a whole is not translated/rotated')
9091  format(' FREE PMF1: Coupling parameter stepsize=',f8.4)
C@NN9092  format(' SVVC: Cutoff for near-neighbour table inclusion=',
C@NN     -  f8.2,' A')
9093  format(' STEP: Solvent shift size=',f9.4,' A',4x,
     -  ' Solvent rotation angle=',f9.4,' degrees')
9119  format(7x,'The maximum allowed magnitude of a force',
     -  ' component=',f16.4, ' kcal/mol/A',/,
     -  7x,'The maximum allowed magnitude of a torque',
     -  ' component=',f15.4, ' kcal/mol/radian')
9120  format(/,' SLTA: Solute: number of atoms=',i6,' consisting of ',
     -  i6,' molecules',
     -  '(see mmc.html for the explanation of the items below)')
9121  format(15x,'number of free energy atoms=',i6,
     -  ' free energy molecules=',i6)
9122  format(' SLTA: Solute description was read from the file ',a)
9123  format(' SLTA: Number of different atom types found in the ',
     -  'solute=',i3)
9129  format(' ///// NOTE: aromatic carbon (atom # ',i6,'(',a4,1x,a4,
     -  ') is labeled polar for desolvation calculation')
9130  format(' SLTA: atnm lib   label  fcg',10x,'x',8x,'y',8x,'z',
     -  '   charge  eps  sigma molec  grp  mov res atom   ',a,a,a)
9131  format(' SLVA:','  at  PF    ',a4,16x,'x',10x,'y',10x,'z',9x,
     -  'charge', '    epsilon    sigma',/)
9132  format(' SLTA: Neat liquid run - no solute')
9140  format(i6,1x,a2,a2,1x,a4,1x,a1,a6,1x,a4,1x,2a1,3f9.3,f7.3,
     -  2f6.3,i5,1x,i5,1x,a4,1x,2a4,i5)
9141  format(i6,1x,a2,1x,a,1x,3f9.3,f7.3,1x,2a4,i5)
9142  format(1x,96('.'))
9143  format(1x,i4,1x,a6,1x,a4,i4,10x,a1,1x,4f11.6,2f10.5,2x,a4,1x,a4)
9144  format(' ***** ERROR: solvent atomic number (',i4,') is out of ',
     -  'range [1,100]')
9145  format(' Center of mass:',10x,3f11.5,'  Mass=',f12.5,' a.m.u.')
9146  format(1x,a,' solute-solvent cutoff (',f6.1,' A) is less',
     -  ' than the maximum radius of the solute (',f6.1,' A)',/,
     -  7x,'- solvent may overlap the solute. Increase cutoff or ',
     -  'replace SUVC SPCC with SUVC SPGC')
9147  format(' ===== STRONG WARNING: solute solvent cutoff (',f6.1,
     -  ' A) is too small for COM-based cutoff (SUVC SPCC);',/,
     -  7x,'it should significantly exceed the solute radius (',f6.1,
     -  ' A) to avoid losing interactions - replace SUVC SPCC with ',
     -  'SUVC SPGC')
9148  format(' RNDG: Random number stream was read from file ',a,';',
     -  ' Number of random numbers read=',i9)
9149  format(' RNDG: Random number stream read will be shuffled ',
     -  'before reusing')
9170  format(/,' SLVA: Solvent: number of atoms=',i3)
9180  format(' Maximum radius of the solute=',f8.3,' A for atom',i5)
9181  format(' Dipole moment components:',3f11.4,' absolute value=',
     -  f11.4,' A*electron  Total charge=',f9.4,' electron')
9182  format(' Dipole moments and charges for the solute copies:')
9183  format(' Centers of mass and total masses for the solute ',
     -  'copies:')
9291  format(' ***** ERROR: group index of solute atom ',i4,
     -  ' is out of order')
9292  format(' ***** ERROR: Charmm segment id field is blank for ',i6,
     -  ' solute atoms - last blank at atom ',i6,' - omit the key CSEG')
9295  format((1x,3(i5,1x,a4,i5,' -',i5,f9.5,a1,1x,f5.2,1x)))
9296  format(' ===== STRONG WARNING: solute group ',i5,' is not ',
     -  'neutral (q=',f7.4,') - reaction-field correction (key RFCR) ',
     -  'is invalid')
9297  format(' ===== STRONG WARNING: solute-solute cutoff may allow ',
     -  'solute ',a,' to overlap - increase the SUUC cutoff')
9298  format(' ----- WARNING: solute-solute cutoff may allow solute ',
     -  a,' to approach within 4 A - increase the SUUC cutoff')
9299  format(' ===== STRONG WARNING: solvent is not neutral (q=',
     -  f7.4,') - reaction-field correction (key RFCR) is invalid')
9351  format(' ***** ERROR: number of solvent centers given',
     -  '(',i3,')',/,' is less than that needed for solvent-solvent',
     -  ' interactions (',i3,')')
9352  format(' ***** ERROR: number of solvent centers given',
     -  '(',i3,')',/,' is less than that needed for solute-solvent',
     -  ' interactions (',i3,')')
9356  format(7x,'The longest branch of solute molecule ',i4,' (',i4,')',
     -  ' exceeds',i4,' atoms - will not be regenerated from scratch')
9357  format(' ***** ERROR: coupling parameter limits',
     -  ' are in the wrong order')
9358  format(' ***** ERROR: perturbation method calculation',
     -  ' does not allow coupling parameter exponent')
9359  format(' FIXD: Accumulated round-off errors in ',a,' are ',
     -  'eliminated at every ',i7,' steps')
9360  format(' RUNS: Number of Monte Carlo steps to run=',i10,/,
     -  7x,'Result summary printed at every ',i12,' steps',/,
     -  7x,'Checkpoint file saved at every ',i13,' steps',/,
     -  7x,'Control function block size=',i16,' steps',/,7x,
     -  'Full results printed and bulk distributions saved at every',
     -  i10,' steps',/,
     -  7x,'Compulsory self tests are performed at every',i10,' steps')
9361  format(' SEED: Random number seed=',f6.0,'*2^48 + ',f6.0,'*2^32',
     -  ' + ',f6.0,'*2^16 + ',f6.0,' Scrambler seed=',i10)
9362  format(' ***** ERROR: initial and final state coupling',
     -  ' parameters (',2f10.6,') are in the wrong order')
9363  format(' ***** ERROR: LJ coefficients can not be changed ',
     -  ' during the run for QPEN/EPEN')
9364  format(' RNDG: Linear congruential generator IXn=mod(',i10,
     -  '*IX+',i10,',2^',i2,')  seed=',i10)
9365  format(' RNDG: Mersenne twister random number generator with ',
     -  'seed=',i10)
9370  format(' ***** ERROR: adaptive US limiting factor (faclim) ',
     -  'must be less than one or one')
9371  format(' ***** ERROR: adaptive US encouraging factor',
     -  '(fcenc1) ',/,59x,'must be greater than one or one')
9372  format(' ***** ERROR: adaptive US encouraging factor',
     -  ' (fcenc2)',/,59x,'must be greater than one or one')
9373  format(' ***** ERROR: adaptive US reducing exponent',
     -  ' (encexp)',/,59x,'must be less than one or one')
9374  format(' ***** ERROR: adaptive US limiting ratio (ratmax)',
     -  /,59x,'must be greater than one or one')
9375  format(' ***** ERROR: ',a,' water calculation is not',
     -  ' vectorized')
9376  format(' ***** ERROR: QPEN calculation is not vectorized')
9377  format(' ***** ERROR: primary hydration shell is compatible only',
     -  ' with nearest heavy atom based preferential sampling ',
     -  '(MOVE PRS* NRST)')
9380  format(' ***** ERROR: number of solvent molecules to be kept ',
     -  'fixed (',i6,') is too high - number of solvents=',i6)
9383  format(' ----- WARNING: 64-bit machine is used for the',
     -  ' scalar energy routines')
9384  format(30x,' HRDW VC32 is changed to HRDW VC64 since the ',
     -  'machine word length is 64 bits.',/,
     -  30x,' use SLFT or nmcmax <= 100000 to circumvent it')
9388  format(' FREE: Coupling parameter value=',f8.6,
     -  ' Exponents=',f5.2,' (1/r**12)',f5.2,' (1/r**6)',f5.2,' (1/r)')
C@NN9389  format(' ***** ERROR: bitmap was not initialized',
C@NN     -  ' (file ',a,' was written with bitmap disbled')
9390  format(' ***** ERROR: nearest solute atom preferential',
     -  ' sampling can not be used with QPEN')
9391  format(' ***** ERROR: preferential sampling weight function',
     -  /, 7x,' contains only one term - this would be no weighting')
9392  format(' GCEN: Insertion or deletion attempt is performed after ',
     -  'every',i4,' Monte Carlo displacement steps',/,
     -  7x,'Grand-canonical results are printed at every',i8,
     -  ' insertion/deletion steps')
9393  format(' GCEN: The position of the cavity grid is randomly ',
     -  'shifted after every ',i8,'-th MC step')
9394  format(' ***** ERROR: grand-canonical ensemble is',
     -  ' incompatible with this free energy option')
9395  format(' ***** ERROR: preferential insertion/deletion is ',
     -  ' only implemented for grid-based insertions')
9396  format(' IBEN: Frequency of volume change attempts:',i6,' steps')
9397  format(/,' Solute molecules:',/,
     -  (3(5x,'from     to   charge  nring radius')))
9398  format(3(3x,i5,' - ',i5,f9.5,a1,i5,f7.2,1x))
9399  format(' ***** ERROR: solute molecule',i5,' has odd ',
     -  'neighbour sum:',i6)
9400  format(' The number of ',a4,' atoms in the solute=',i6)
9401  format(' +++++ Solute listing was truncated as requested')
9402  format(/,' Solute groups (residues):',/,
     -  1x,3(11x,'from     to   charge  radius'))
9403  format(' ***** ERROR: second copy of solute atom ',i4,
     -  ' has wrong type: ',i3,' instead of ',i3)
9404  format(' ***** ERROR: number of grid points in at least',
     -  ' one direction is not under 512')
9405  format(' ***** ERROR: atomtypes for solute atom ',i4,' are ',
     -  'not identical in the three solute copies:', 3i4)
9406  format(' ***** ERROR: ',a,' trajectory can not be ',
     -  'written the the ',a,' ensemble')
9407  format(' ----- WARNING: 32-bit machine is used for the',
     -  ' Cray-type energy routines')
9408  format(30x,' HRDW VC64 is changed to HRDW VC32 since the ',
     -  'machine word length is only 32 bits.',/,
     -  30x,' use SLFT or nmcmax <= 100000 to circumvent it')
9409  format(' ----- WARNING: COM-based distance is used for',
     -  ' large solute (instead of nearest heavy atom distance)',
     -  ' check key MOVE PRS*')
9410  format(' ***** ERROR: overlapping two solute copies is only ',
     -  'effective with random initial configuration(CNFG RAN*)')
9411  format(' ***** ERROR: overlapping two solute copies is only ',
     -  'valid for two-copy free energy calculations (FREE TICA or',
     -  ' FREE PMLI)')
9412  format(' ===== STRONG WARNING:  density is too low for negative ',
     -  'B parameter - box is likely to become empty')
9413  format(' ***** ERROR: boundary condition option ',i2,' is',
     -  ' incompatible with grand-canonical ensemble ')
9414  format(' C@',a2,': Bitmap is handled with ',a,' operations')
9415  format(' Number of rings in the solute molecule=',i4)
9416  format(' ***** ERROR: Neither LOGICAL nor arithmetical',
     -  ' bitmap handling is turned on')
9417  format(' ***** ERROR: Both LOGICAL and ARITHMETICAL',
     -  ' bitmap handlings are turned on')
9418  format(' FREE TICA: Linear TI')
C@NN9419  format(' ----- WARNING: solvent-solvent interactions are treated',
C@NN     -  ' under minimum image PBC')
C@TS9420  format(' ----- WARNING: solute is not torque biased')
C@TS9421  format(7x,'- Setting the preprocessor variable TS to "F"',
C@TS     -  ' would make the program faster')
C@NN9422  format(7x,'- Setting the preprocessor variable NN to "F"',
C@NN     -  ' would make the program faster')
9423  format(' ===== STRONG WARNING: distance-dependent dielectric ',
     -  'code is active but is set to produce a constant',/,
     -  7x,'- either ste the constants (SETC DDIE) or do not actvate ',
     -  'the code (DD)')
9424  format(' C@1R: Distance-dependent dielectric of the form eps=r ',
     -  'will be used for the solute-solute interactions')
9425  format(' ----- WARNING: distance-dependent dielectric in the ',
     -  'presence of solvent is of questionable validity')
9426  format(' ***** ERROR: Solute move frequency has to be given',
     -  ' with the key MOVE when the solute is moved')
9428  format(' ***** ERROR: Quadruple precision is incompatible with ',
     -  'the use of MPI for now')
9429  format(' ***** ERROR: invalid activation of ',a,'option. ',
     -  'One of C@',a2,' and C@',a2,' comments have to be removed')
9430  format(' ***** ERROR: invalid activation of ',a,'option. ',
     -  'Only one of C@',a2,' and C@',a2,' comments can be removed')
9431  format(' FILE: Run number=',i2)
9432  format(' ***** ERROR: partial solute moves require group-based',
     -  ' boundary conditions (SUVC **GC) and (SUUC **GC)')
9433  format(' ***** ERROR: TRAJ ALLE or TRAJ ALLV is invalid for ',
     -  a,' ensemble runs')
9434  format(' ***** ERROR: there are not enough solute molecules for ',
     - 'the SWAP or MV2S option')
9435  format(' ----- WARNING: Solute bitmap option is turned off -',
     -  'intrasolute energies will not be calculated')
9436  format(7x,a,' file=',a,' - unit number=',i6)
9437  format(' ***** ERROR: options to change the solute require ',
     -  'solute-solute bitmap')
9438  format(12x,'Estimated size: over ',f6.1,' Mb')
9439  format(12x,'SCKP: Checkpoint files will be saved with ',
     -  'consecutive versionnumbers at each ',i8,'-th MC step')
9440  format(' SLFT: Chekpoint files after passing a self test will be',
     -  ' saved on file ',a,' unit number=',i6)
9441  format(' LPAT: Checkpoint files and temporary files will be ',
     -  ' written in the directory ',a,/,7x,'- checkpoint files will ',
     -  'be copied to the directory the run originated from at the ',
     -  'end of the run')
9443  format(' RFCR: Reaction field correction will be added using a ',
     -  'dielectric constant of ',f12.1)
9444  format(' ***** ERROR: reaction field correction is incompatible',
     -  ' with minimum image convention (change SUUC, SUVC or SVVC ',
     -  'lines)')
9445  format(' ----- WARNING: torsion angle distribution calculation ',
     -  'is inactive - to activate, increase maxtagrid (#',a2,') and ',
     -  'recompile')
9446  format(' ----- WARNING: stepsize for loop torsion',i6,
     -  ' is zero - no loop moves will be attempted with it')
9447  format(' Recompile with the preprocessor variable ',a2,' set ',
     -  'to "T"')
9448  format(' ***** ERROR: primary hydration shell model is ',
     -  'incompatible with non-canonical ensembles')
9449  format(1x,a,' if fix unsuccesful')
9450  format(' ===== STRONG WARNING:  solvent is not neutral')
9451  format(' Original system can be recovered with a shift by ',
     -  3f10.5,' followed by a rotation with the matrix',/,(5x,3f10.5))
9452  format(' Original system can be recovered with a rotation ',
     -  'using the matrix',3(/,5x,3f10.5),/,' followed with a shift by',
     -  3f10.5)
9453  format(i4,' anchor index=',i6,' c=',3f10.5,2x,2a4)
9454  format(' Ligand atom',i6,' (',2a4,') will be dropped')
9455  format(' VCHA: ',a,' calculation with virtual volume change',a,a)
9456  format(7x,'Frequency of virtual volume changes:',i9,' steps',/,
     -  7x,'Volume change (|dx|*|dy|*|dz|) = ',f8.3,' %')
9457  format(' ERROR: Surface tension calculation is only',
     -  ' implemented for rectangular cell (PBCN RECT)')
9458  format(' ERROR: 1/r dielectric is incompatible with the Mehler-',
     -  'Solmayer dielectric - only one of ',a,' and ',a,' options can',
     -  ' be active')
9459  format(' STUN: ',a,' stepsizes from tuned ',a,' values')
9460  format(7x,'Estimated memory use: over ',f8.1,' Mb')
9461  format(' +++++ Atoms listed below were only used to prepare ',
     -  'the energy maps and H-bond donor/acceptor list')
c9510  format(' >>>>> OVERRIDE: solute ',a,' is not sampled - stepsize ',
c     -  'tuning is turned off')
9511  format(' STUN: Solute ',a,' stepsize will be tuned to ',f6.2,'% ',
     -  'acceptance rate',/,7x,'Gain=',e12.5,' integraltime=',e12.5,
     -  ' range: [',f8.2,',',f8.2,']',1x,a,
     -  ' acc avg weight=',f8.5,' stepsize avg weight=',f8.5)
9512  format(' STUN: ',a,' moves will be tuned on clone averages')
9513  format(i1)
9514  format(' STUN: ',a,' stepsizes will be tuned on logarithmic ',
     -  'scale')
9515  format(' SANN: Simulated annealing run. Temperature will be ',
     -  'changed at every ',i8,' MC step',/,7x,'Number of annealing ',
     -  'steps= ',i5,' Final temperature=',f6.1,' K')
9516  format(7x,'Linear schedule. Temperature increment at each step=',
     -  f8.4)
9517  format(7x,'Geometric (exponential) schedule. Temperature is ',
     -  'calculated at each step as T(next) = T * exp(-',f6.3,
     -  ')= T * ',f9.5)
9518  format(7x,'Logarithmic schedule. Temperature is calculated at ',
     -  'each step i as T(next) = ',e12.5,' / ln(i+2)')
9519  format(7x,'User specified schedule. Temperatures at successive ',
     -  'stages are',/,(10f10.4))
9520  format(' ***** ERROR: the stepnumber to reinitialize the ',
     -  'accumuators for ',a,' (',i8,') has to be a multiple of the ',
     -  /,' frequency of result printing (',i8,') - modify the ',
     -  'corresponding TAC0 key or the RUNS key')
9521  format(7x,'This may be a PROGRAM ERROR')
9522  format(' TAC0: ',a,' stepsize accumulators will be reinitialized',
     - ' at MC step',i10)
9523  format(' IGTT: Solute-solute energies ignored for acceptance ',
     -  'decision')
9524  format(' IGTT: Solute-solute energies will not even be ',
     -  'calculateed')
9525  format(' >>>>> OVERRIDE: No solute move is used - IGTT key is ',
     -  'ignored')
9528  format(' CNST: PDB files (if written) will include CONECT ',
     -  'records connecting the constrained atom pairs')
9529  format(' CNST: Target distance, tolerance and/or force constant ',
     -  'values have been updated')
9530  format(' CNST: There are',i4,' constraints. The form of the ',
     -  'constraint is: 0 if |d(i,j)-d_target(i,j)|<=tol_target(i,j);',
     -  /,65x,'otherwise force_target(i,j)*(d(i,j)-d_target(i,j))^2')
9810  format(' PDBT: Atomnames in PDB files written (if any) will be ',
     -  'converted to ',a,' format')
9900  format(' TDIS: Rotations and torsion magnitudes are uniformly ',
     -  'distributed')
9902  format(' TDIS: Rotations and torsion magnitudes are uniformly ',
     -  'distributed in a square')
9903  format(' TDIS: Rotations and torsion magnitudes are uniformly ',
     -  'distributed in a cube')
9905  format(1x,a,': ',a)
9906  format(' ***** ERROR: ligand group center is not among the ',
     -  'anchor atoms')
9907  format(' ***** ERROR: ',a,'center of ghost group',i3,' (',i3,')',
     -  ' differs from the corresponding ligand center (',i6,')')
9908  format(' ***** ERROR: replacement atom',i6,' is not bonded to ',
     -  'the last ghost atom counterpart')
      end
      subroutine printopt(iopkeylist,iout)
c*****Print all option values
c#    MMC routine  92/a lstmod: 05/05/15
      character*4 iopkeylist(4,200)
      common /option/ iop(200),idebug(200)
      dimension idbpr(200)
      imax=200
      do while (iop(imax) .eq. 0 .and. imax .gt. 1)
        imax=imax-1
      end do
      ismax=(imax-1)/25+1
      write (iout,9010)
      write (iout,9011) ((i,i=(is-1)*25+1,is*25),(iop(i),
     -  i=(is-1)*25+1,is*25),is=1,ismax)
      ndebug=0
      do i=1,200
        if (idebug(i) .gt. 0) then
          ndebug=ndebug+1
          idbpr(ndebug)=i
         end if
      end do
      if (ndebug .gt. 0)
     -  write (iout,9012) (idbpr(i),idebug(idbpr(i)),i=1,ndebug)
      if (iop(24) .gt. 1) then
        do i=1,200
          j=0
          iopread=0
          do while(j .lt. 200 .and. iopread .ne. i)
            j=j+1
            read (iopkeylist(2,j),9001) iopread
          end do
          if (j .lt. 200) write (iout,9000) i,iopkeylist(1,j)
        end do
      end if
      return
9000  format(' iop(',i3,') is set with key ',a4)
9001  format(i4)
9010  format(' OPTN: Options:')
9011  format(25i4,/,25i4)
9012  format(' DBUG: Debug options set: ',25(i4,':',i1))
      end
      subroutine echo_cnst(iorig_of_split,c,labslt,lab,llab,idetl,iout,
     -  maxslt)
c*****Print all constraints
c#    MMC routine  92/b lstmod: 07/05/15
      dimension iorig_of_split(#ST),c(3,maxslt)
      character*4 labslt(2,#ST)
      character*(*) lab
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      common /option/ iop(200),idebug(200)
      character*6 diff
      character*52 names
c     Echo constraints
      do i=1,nconstr_pair
        ipair1w=iconstr_pair(1,i)
        ipair2w=iconstr_pair(2,i)
        dist0=sqrt(arrdist(c(1,ipair1w),c(1,ipair2w)))
        if (iop(61) .gt. 0) then
          ipair1w=iorig_of_split(ipair1w)
          ipair2w=iorig_of_split(ipair2w)
        end if
        write (names,2000)
     -    ipair1w,(labslt(kk,iconstr_pair(1,i)),kk=1,2),
     -    ipair2w,(labslt(kk,iconstr_pair(2,i)),kk=1,2)
        if (idetl .eq. 1) write (iout,2001) names,d_target(i),
     -    force_target(i),tol_target(i),lab(1:llab),dist0
        if (idetl .eq. 0)then
          diff(1:1)=' '
          ldiff=1
          bound_l=d_target(i)-tol_target(i)
          bound_r=d_target(i)+tol_target(i)
          if (dist0 .lt. bound_l) then
            write (diff,2003) bound_l-dist0
            ldiff=6
          else if (dist0 .gt. bound_r) then
            write (diff,2004) dist0-bound_r
            ldiff=6
          else
            if (dist0 .lt. bound_l+0.02) diff(1:1)='['
            if (dist0 .gt. bound_r-0.02) diff(1:1)=']'
          end if
          write (iout,2002) names,bound_l,bound_r,lab(1:llab),dist0,
     -      diff(1:ldiff)
        end if
      end do
      return
2000  format(' Atom1:',i6,' (',a4,1x,a4,')  Atom2:',i6,' (',a4,1x,a4,
     -  ') ')
2001  format(' CNST:',a,'d_target=',f8.5,' force_target=',e12.5,
     -  ' tol_target=',f5.3,' d(',a,')=',f5.1)
2002  format(a,' Constraint range: [',f6.2,',',f6.2,'] d(',a,')=',f6.2,
     -  1x,a,a1)
2003  format('-',f4.2,'[')
2004  format(']+',f4.2)
      end
      subroutine aus_params(iout,iop,cplmin,cplmax,nmcadp)
c*****Print AUS sampling information
c#    MMC routine  92/c lstmod: 08/17/12
      dimension iop(200)
      common /wadaptf/ ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,rldvmx,
     -  diffmx,tolera,iopnrm,iopeql,iopenc,nitssk,nwtst,nsubmn,ngovmn,
     -  ngrcor,negitdel
      if (cplmax .gt. cplmin) write (iout,5110) cplmin,cplmax
      write (iout,5111) tolera,faclim,nitssk,nmcadp
      if (iopnrm .eq. -1) write (iout,3066)
      if (iopnrm .eq. -2) write (iout,3069)
      if (iopnrm .eq. -3) write (iout,3071)
      if (iopnrm .eq. 0) write (iout,3067)
      if (iopnrm .gt. 0) write (iout,3068) iopnrm
      if (iop(55) .gt. 0) write (iout,5510) iop(55)
      if (iopenc .eq. 1 .or. iopenc .eq. 3)
     -  write (iout,3064) fcenc2,encexp
      if (iopenc .eq. 2 .or. iopenc .eq. 3)
     -  write (iout,3063) 'abandoned',ngrcor,fcenc1
      if (iopenc .lt. 0) then
        write (iout,3062)
        write (iout,3072) encexp
        write (iout,3063) 'unsampled',ngrcor,fcenc1
      end if
      if (smplmx .ne. 0.0) write (iout,3061) ratmax,smplmx
      if (iopeql .gt. 0) write (iout,3065) ngovmn,diffmx,nsubmn
      if (iop(51) .eq. 1)  write (iout,5120) 'Linear'
      if (iop(51) .eq. 2)  write (iout,5120) 'Exponential'
      return
3065  format(12x,'Self-tests for equilibration will be applied on',
     -  ' adaptive umbrella sampling iterations',/,
     -  12x,'Minimum number of grids to overlap for condsideration=',i2,
     -  /,12x,'Overlap criterion threshold value=',f8.3,/,
     -  12x,'Rejection occurs if one in every',i3,' overlapping',
     -  ' iterations exceeds the threshold')
5110  format(' FREE PMF1: Adaptive umbrella sampling',/,
     -  12x,'Coupling parameter range is from',f8.4,' to',f8.4)
5111  format(' AUS parameters:'/,12x,'Coupling parameter will be kept ',
     -  'within ',f8.4,' of the [0,1] range',/,
     - 12x,'Ratio of neighbouring grids for constraining=',f10.5,/,
     - 12x,'Number of iterations to skip when  equilibrating=',i3,/,
     - 12x,'Frequency of umbrella sampling weight updates=',i9,' steps')
5120  format(12x,a,' interpolation will be used for AUS weights')
5510  format(12x,'Adaptive umbrella sampling iteration will continue ',
     -  'if  the target interval was covered at least ',i4,' times')
3061  format(12x,'Maximum allowed ratio in smoothing=',f10.5,/,
     -  12x,'Maximum relative sampling for ratio smoothing=',f8.4)
3062  format(12x,'US weights will be computed from actual sampling ',
     -  'rate (not from Boltzmann probabilities)')
3063  format(12x,'Sampling of ',a,' regions will be encouraged ',
     -  'over',i3,' gridpoints by a factor of',f10.5)
3064  format(12x,'Weight of unsampled regions will be multiplied by ',
     -  f10.5,' in each iteration to encourage sampling extensions',/,
     -  12x,'The weightmodifier factor will be reduced to its',f10.5,
     -  '-th power for sampled grids in each iteration')
3066  format(12x,'Linear n-step optimization will be used for',
     -  ' probability space matching')
3067  format(12x,'Non-linear n-step optimization will be used without',
     -  ' regenerating initial guess')
3068  format(12x,'Non-linear n-step optimization will be used with',
     -  ' regenerating initial guess at every',i4,'-th iteration')
3069  format(12x,'Linear n-step optimization will be used for',
     -  ' potential of mean force space matching')
3071  format(12x,'Grid-by-grid matching will be used in the',
     -  ' potential of mean force space')
3072  format(12x,'Sampling rates will be raised to the ',f6.2,'th ',
     -  'power for the calculation of US weights')
      end
      subroutine gettorsnames(it,nt,torsnames,labslt,ianslt,iatnam,
     -  iuselist,list,iquata)
c*****Get the names of torsion angle atoms
c#    MMC routine  92/d lstmod: 01/28/09
      character*8 torsnames(8)
      character*4 labslt(2,#ST),iatnam(99)
      dimension ianslt(#ST),iquata(#TR,4),list(nt)
      do k=1,nt
        torsnames(k)='        '
        if (iuselist .eq. 0) then
          ia=iquata(it,k)
        else
          ia=list(k)
        end if
        if (labslt(1,ia) .ne. '    ' .or.
     -      labslt(2,ia) .ne. '    ') then
          torsnames(k)(1:4)=labslt(1,ia)
          torsnames(k)(5:8)=labslt(2,ia)
        else
          torsnames(k)(1:4)=iatnam(ianslt(ia))
        end if
      end do
      return
      end
      subroutine checksizes(iop,ifail,inperr,iout,nmolec,nslvn,nsltn,
     -  nslte,nsttg,nstta,ngfree,nstfa0)
c#    MMC routine  93 lstmod: 11/24/04
c*****Checks variable sizes agains dimensions (MPI code needs it outside echopr
      dimension iop(200)
      if (iop(5) .eq. 6)
     -  call checkdim(ifail,iout,inperr,'MS',nmolec,1,0,0)
      if (iop(3) .eq. 2) then
        call checkdim(ifail,iout,inperr,'VN',nslvn,0,0,0)
        call checkdim(ifail,iout,inperr,'TN',nsltn,0,0,0)
        call checkdim(ifail,iout,inperr,'TE',nslte,0,0,0)
      end if
      call checkdim(ifail,iout,inperr,'GR',nsttg,0,0,0)
      if (iop(30) .eq. 8) call checkdim(ifail,iout,inperr,'OR',1,0,0,0)
      if (iop(30) .eq. 7) then
        call checkdim(ifail,iout,inperr,'WG',10,0,0,0)
        call checkdim(ifail,iout,inperr,'WI',10,0,0,0)
      end if
      if (iop(82) .gt. 0 ) then
        call checkdim(ifail,iout,inperr,'DT',nstta,0,0,0)
        call checkdim(ifail,iout,inperr,'DM',nmolec,0,0,0)
      end if
      ifail0=ifail
      if (iop(41)*iop(63) .gt. 0)
     -  call checkdim(ifail,iout,inperr,'PP',ngfree,0,0,0)
      if (ifail .gt. ifail0) write (iout,1000)
      if (iop(18) .eq. 4)
     -  call checkdim(ifail,iout,inperr,'TA',nstfa0,0,0,0)
      if (iop(43) .gt. 0)
     -  call checkdim(ifail,iout,inperr,'GR',nsttg,0,0,0)
      return
1000  format(7x,'or turn on PRFI only after the simulation box is full')
      end
      subroutine printcomp(iout,icompopt,ncompopt,sizesym,sizename,
     -  sizelname,optname,optlname,iasize,nasize,cmoddate,cpxmoddate,
     -  moddate,filename,namelen,nbits,iwopt,iwcsh,nwarn)
c#    MMC routine  94 lstmod: 03/16/09
c*****Prints compilation options, array sizes
      character*2 sizesym(nasize),optname(ncompopt)
      character*8 able(2)
      character*10 sizename(nasize),cmoddate,cpxmoddate,moddate
      character*25 optlname(ncompopt)
      character*38 sizelname(nasize)
      character*80 filename
      dimension icompopt(ncompopt),iasize(nasize),indexo(40),indexs(70)
      data able /'DISABLED','ENABLED '/
      nopt=0
      do i=1,ncompopt
        if (optname(i) .ne. '  ') then
          nopt=nopt+1
          indexo(nopt)=i
        end if
      end do
      nsiz=0
      do i=1,nasize
        if (sizesym(i) .ne. '  ') then
          nsiz=nsiz+1
          indexs(nsiz)=i
          if (iasize(i) .le. 0) then
            write (iout,1003) iasize(i),sizelname(i),sizename(i),
     -        sizesym(i)
            iasize(i)=1
          end if
        end if
      end do
      if (iwopt .ge. 1)
     -   write (iout,1000) moddate,cmoddate,cpxmoddate
      if (mod(iwopt,2) .eq. 0) then
        iasize(55)=iasize(55)*nbits
        write (iout,1001) (optlname(indexo(i)),optname(indexo(i)),
     -    able(icompopt(indexo(i))+1),i=1,nopt)
        write (iout,1002) (sizesym(indexs(i)),iasize(indexs(i)),
     -    sizename(indexs(i)),sizelname(indexs(i)),i=1,nsiz)
        iasize(55)=iasize(55)/nbits
      end if
      if (iwcsh .gt. 0) call savecompopt(filename,namelen,
     -  icompopt,ncompopt,iasize,nasize,nwarn,iout)
      return
1000  format(' Program was last modified on ',a10,', simulation and ',
     -  'proximity common blocks were last modified on ',
     -  a10,' and ',a10,', resp.')
1001  format(/,' COMPILATION OPTIONS (C@XX):',/,
     -  (3(1x,a25,' (',a2,'): ',a10)))
1002  format(/,' VALUES OF THE DIMENSION PARAMETERS (#XX):',/,
     -  (2(1x,a2,'=',i9,' (',a10,': ',a38,')')))
1003  format(' ***** (PROGRAM) ERROR: invalid dimension (',i9,') for ',
     -  a,1x,a,' (',a,')')
      end
      subroutine savecompopt(filename,namelen,icompopt,ncompopt,
     -  iasize,nasize,nwarn,iout)
c#    MMC routine  95 lstmod: 07/17/04
      dimension icompopt(ncompopt),iasize(nasize)
      character*80 filename,prefilename,line
c*****Generate data statements for recreating the source code
c     Generate complementary option values
      if (namelen .eq. 0) then
        prefilename='pre_x.f'
        namelenp=7
      else
        prefilename='pre_'//filename(1:namelen)//'.f'
        namelenp=namelen+6
      end if
      open(unit=8,status='old',form='formatted',
     -  file='pre.f',iostat=iosr)
      open(unit=9,status='new',form='formatted',
     -  file=prefilename(1:namelenp),iostat=iosw)
      if (iosr .ne. 0) then
c       pre.f is not present, just write the new data statements
        if (iosw .eq. 0) then
          iw=9
          write (iout,1005) prefilename(1:namelenp)
        else
          write (iout,1006) prefilename(1:namelenp)
          nwarn=nwarn+1
          iw=iout
          write (iw,1002)
        end if
      else
        if (iosw .eq. 0) then
c         Replace the data statements in pre.f
          iw=9
          write (iout,1001) prefilename(1:namelenp)
          do while (.true.)
            call blankout(line,1,80)
            read (8,1000,end=999) line
            if (line(1:16) .eq. '      data isize') then
              write (iw,1004) (iasize(i),i=1,nasize)
              write (iw,1003) (icompopt(i),i=1,ncompopt)
              write (iw,1007)
              go to 888
            else
              ic=80
              do while (ic .gt. 1 .and. line(ic:ic) .eq. ' ')
                ic=ic-1
              end do
              write (iw,1000) line(1:ic)
            end if
          end do
        else
          write (iout,1006) prefilename(1:namelenp)
          nwarn=nwarn+1
          iw=iout
          write (iw,1002)
        end if
      end if
777   write (iw,1004) (iasize(i),i=1,nasize)
      write (iw,1003) (icompopt(i),i=1,ncompopt)
888   if (iosr .eq. 0) close (8)
      if (iw .eq. 9) close (9)
      if (iw .eq. iout) write (iw,*)
      return
999   write (iout,1008) prefilename(1:namelenp)
      go to 777
1000  format(a)
1001  format(' The file pre.f has been modified to create a source ',
     -  'file with the same size and options as this one.',/,
     -  5x,'The modified pre.f is saved as ',a)
1002  format(' Data statements to use in pre.f are printed below',/)
1003  format(6x,'data iopt /',/,5x,'-  ',29(i1,','),i1,'/')
1004  format(6x,'data isize /',/,11(5x,'-',6(i10,','),/),
     -  5x,'-',3(i10,','),i10,'/')
1005  format(' Data statements for the preprocessor was written to ',
     -  'file ',a,/,5x,'- copy the file pre.f here if you want it to ',
     -  'be modified my MMC directly')
1006  format(' ----- WARNING: file ',a,' exists, not written over')
1007  format('      end')
1008  format(' ----- WARNING: data statements were not found in pre.f',
     -  ' - only the new data statements are written to ',a)
      end
      subroutine spreadslt(xyzmax,numrun,numrunw,ifirstm,ilastm,molcnt,
     -  c,center,cgs,nsttm,nstta)
c#    MMC routine  95/a lstmod: 07/28/12
      dimension xyzmax(3),ifirstm(nsttm),ilastm(nsttm),molcnt(nsttm),
     -  c(3,nstta),center(3),cgs(3,nstta)
      call getreal(xyzmax(1),0,0.0)
      call getreal(xyzmax(2),0,0.0)
      call getint(numrunw,0,1,numrun)
c     Find the maximum extension of the molecules if needed
      do k=1,2
        if (xyzmax(k) .eq. 0.0) then
          do im=1,nsttm
            do ia=ifirstm(im),ilastm(im)
              xx=abs(c(k,ia)-c(k,molcnt(im)))
              if (xx .gt. xyzmax(k)) xyzmax(k)=xx
            end do
          end do
        end if
      end do
c     Find nx, ny, the number of columns and rows needed
c     nx*xyzmax(1)=ny*xyzmax(2) (square); nx*ny=nsttm
      do k=1,2
        xyzmax(k)=2.0*xyzmax(k)+1.0
      end do
      nx=sqrt(nsttm*xyzmax(2)/xyzmax(1))+1
      ny=(nsttm-1)/nx+1
      do im=1,nsttm
        ixc=mod(im-1,nx)
        iyc=(im-1)/nx
        center(1)=(ixc+0.5)*xyzmax(1)
        center(2)=(iyc+0.5)*xyzmax(2)
        center(3)=0.0
        do ia=ifirstm(im),ilastm(im)
          do k=1,3
            cgs(k,ia)=center(k)+c(k,ia)-c(k,molcnt(im))
          end do
        end do
      end do
      return
      end
      subroutine compmin(nmolec,nbits,nstta,nstfa0,nsttg,nsttm,ifirstm,
     -  ilastm,iltorgrp,iltormovgrgr,nslv,ngrid,ntang,ntorsinp,ntordrop,
     -  ntorgrp,nptd,iclsltt,nsltpx1,nsltpx2,nijgvv,ngridmap,indxrdf,
     -  rk_ddd,rpxdivi,rpxwwdivi,rgpxsltmax,rgpxwwmax)
c#    MMC routine  96 lstmod: 02/27/24
c*****Generate preprocessor tailored to the current system
      dimension ngrid(3),ifirstm(#MM),ilastm(#MM),iltorgrp(#TR),
     -  iltormovgrgr(#TR),iclsltt(#ST),indxrdf(#ST)
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /toreng/ npft(#TR),ifpftd(9,#TR),ilpftd(9,#TR),
     -  torsinc(9,#TR),torcoef(#TA),phase(#TA),period(#TA)
      common /option/ iop(200),idebug(200)
c     maxmol
      if (iop(41) .eq. 0) then
        maxmol=max0(2,nmolec)
        if (mod(maxmol,2) .eq. 1) maxmol=maxmol+1
        iasize(1)=maxmol
      else
        maxmol=iasize(1)
      end if
c     maxatmol
      maxatmol=1
      do im=1,nsttm
        if (ilastm(im)-ifirstm(im)+1 .gt. maxatmol)
     -     maxatmol=ilastm(im)-ifirstm(im)+1
      end do
      iasize(2)=maxatmol
c     mxpxslt
      mxpxslt=1
      if (iop(162) .gt. 0) mxpxslt=nstta
      iasize(3)=mxpxslt
c     maxsltmol
      iasize(4)=max0(3,nsttm)
c     maxwnnu
      iasize(5)=1
C@TN      iasize(5)=(maxatmol-1)/nbits+1
c     maxnst
c     maxnsv, maxest, maxesv - leave
c     maxloopslt
      maxloopslt=1
      if (iop(91) .gt. 0) maxloopslt=nstta
      iasize(10)=maxloopslt
c     maxwnnv
      maxwnnv=1
C@NN      maxwnnv=(maxmol-1)/nbits+1
      iasize(11)=maxwnnv
c     maxslt
      iasize(12)=nstta
c     maxgslt
      iasize(13)=nsttg
c     maxtslt
      maxtslt=1
c     if (ntorgrp .gt. 0) then
      if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        ntordat=max0(nptd,iltorgrp(ntorgrp))
        if (iop(18) .eq. 4) ntordat=max0(ntordat,nstfa0)
        iasize(14)=ntordat
      end if
      if (mod(iasize(14),2) .eq. 1) iasize(14)=iasize(14)+1
c     maxslv
      iasize(15)=max0(4,nslv)
c     maxss
      iasize(16)=max0(nslv,nstta)
c     maxat
      iasize(17)=nstta+(maxmol-1)*nslv+1
c     maxtrgrgr
      if (iop(58) .eq. 0) iasize(18)=1
      if (iop(58) .gt. 0) iasize(18)=iltormovgrgr(ntorgrp)
c     maxstg
      maxstg=1
      if (iop(26) .gt. 0) maxstg=nstta
      iasize(19)=maxstg
c     maxsvg
      maxsvg=1
      if (iop(26) .gt. 0) maxsvg=nslv
      iasize(20)=maxsvg
c     maxsst
      maxsst=1
      if (iop(174) .gt. 0) maxsst=nstta
      iasize(21)=maxsst
c     maxmst
      maxmst=1
      if (iop(174) .gt. 0) maxmst=maxmol
      iasize(22)=maxmst
c     maxgrid
      maxgrid=1
      if (rgpxsltmax .ne. 0.0 .or. rgpxwwmax .ne. 0.0) then
        rgpxmax=amax1(rgpxsltmax,rgpxwwmax)
        rpxdiv=amax1(rpxdivi,rpxwwdivi)
        maxgrid=amin1(#RG.0,rgpxmax/rpxdiv+1)
      end if
      if (maxgrid .gt. #TG .and. iop(143) .gt. 0) maxgrid=#TG
      iasize(23)=maxgrid
c     maxpfgr
      if (iop(8) .eq. 0 .and. iop(12) .lt. 3 .and.
     -  iop(6) .ne. 6) iasize(24)=2
c     maxcggr
      if (iop(30) .ne. 7) iasize(25)=2
c     maxorgr
      if (iop(30) .ne. 8) iasize(26)=1
      if (iop(41) .eq. 1 .or. iop(41) .eq. 2 .or. iop(30) .eq. 1) then
c       maxxgr, maxygr, maxzgr
        iasize(27)=ngrid(1)
        iasize(28)=ngrid(2)
        iasize(29)=ngrid(3)
      else
        iasize(27)=1
        iasize(28)=1
        iasize(29)=1
      end if
c     maxcav
      iasize(30)=max0(2,iasize(27)*iasize(28)*iasize(29))
      if (iop(30) .ne. 7) then
c       maxlin, maxausp, maxauit
        iasize(31)=1
        iasize(32)=1
        iasize(33)=1
      end if
c     maxavit
c     maxtors
      if (iop(58) .eq. 0 .and. iop(18) .ne. 4) then
        iasize(35)=1
      else
        if (iop(84) .eq. 1) iasize(35)=ntorsinp+ntordrop+1
        if (iop(84) .eq. 2) iasize(35)=min0(iasize(35),nstta)
      end if
c     maxatyp
c     maxatypu
      maxatypu=1
      do ia=1,nstta
        if (iclsltt(ia) .gt. maxatypu) maxatypu=iclsltt(ia)
      end do
      iasize(37)=maxatypu
c     maxstmol
      iasize(38)=max0(iasize(1),iasize(12),32,iasize(51))
c     maxtgrid
      if (iop(143) .eq. 0) iasize(39)=1
c      maxwrgrid, maxgvv
      if (iop(147) .eq. 0) then
        iasize(40)=1
        iasize(41)=1
      else
        iasize(41)=nijgvv
      end if
c     maxdrgrid, maxdagrid
      if (iop(145) .eq. 0) then
        iasize(42)=1
        iasize(43)=1
      end if
c     maxpegrid
      if (iop(146) .eq. 0) iasize(44)=1
c     mxpxgslt
      if (iop(162) .eq. 0) then
        mxpxgslt=1
      else
        mxpxgslt=0
        do ia=nsltpx1,nsltpx2
          if (indxrdf(ia) .gt. mxpxgslt) mxpxgslt=indxrdf(ia)
        end do
        if (mxpxgslt .eq. 0) mxpxgslt=nsltpx2-nsltpx1+2
      end if
      iasize(45)=mxpxgslt
c     maxcavps
      if (iop(63) .eq. 0) iasize(46)=1
c     maxpfsum
      if (iop(12) .lt. 4) iasize(47)=1
c     maxmatch
      if (iop(30) .ne. 1) iasize(48)=2
c     maxtagrid
      if (iop(58) .eq. 0) iasize(49)=1
c     mxfeslt
      if (iop(30) .eq. 0) iasize(50)=1
c     maxhunsite
c     mxlooptor
      if (iop(91) .eq. 0) iasize(52)=1
      if (iop(91) .gt. 0) iasize(52)=ntang+1
c     mxdiffmol
      if (iop(177)+iop(171) .eq. 0) iasize(53)=1
c     mxdiffcr
      if (iop(177) .eq. 0) iasize(54)=1
c     mxrescr
      if (iop(171) .eq. 0) iasize(55)=1
c     maxwidslt
      if (iop(30) .ne. 1) iasize(56)=1
c     maxphsmol
      if (iop(92) .eq. 0) iasize(57)=1
c     maxhmneig
c     maxmolfg
      iasize(59)=1
C@FG      iasize(59)=#MG
c     maxath
      iasize(60)=max0(iasize(17),iasize(12)+iasize(15)*iasize(51))
c     maxmapgrid
      iasize(61)=ngridmap
c     C@NN
      if (nmolec .eq. 1) icompopt(1)=0
c     C@TN
      if (nstta .eq. 0 .or.
     -  (iop(57)+iop(58) .eq. 0 .and. iop(30) .eq. 0)) icompopt(2)=0
c     C@IB
      if (iop(71)+iop(106) .eq. 0) icompopt(19)=0
c     C@DD
      if (rk_ddd .eq. 0.0) icompopt(25)=0
      return
      end
      subroutine printljconst(nsltpr,nmolec,nstta,nslv,iprtlib,
     -  iprtlibcomb,iprtatoms,nwarn,iout)
c#    MMC routine  97 lstmod: 12/03/15
c*****Prints potential parameter info
      character*80 prmfil
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      character*4 namfcg
      character*20 nmlfcg
      common /fcgnam/ igrdup(100),namfcg(100,2),nmlfcg(100,2)
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      common /frslvr/ fsrad(#AT,11)
      common /cqpen/ qnn(#TN,#VN),qne(#TN,#VE),qen(#TE,#VN),
     -  qee(#TE,#VE),aee(#TE,#VE),bee(#TE,#VE),cee(#TE,#VE),
     -  iopict,nsltn,nslvn,nslte,nslve
      common /cvdw/ vdm2(#TN,#VN),cutin,escale
      common /qpnabc/ aslt(#TE),bslt(#TE),dslt(#TE),aslv(#VE),
     -  bslv(#VE),dslv(#VE)
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      character*8 namh2o,nammcy
      character*32 namstp
      common /pfnames/ ipf(11),namstp(11),namh2o(9),nammcy(3)
      common /option/ iop(200),idebug(200)
      dimension iopsltpr(11)
      character*4 iox,ihyd
      data iox/'oxyg'/,ihyd/'hydr'/
      if (iprtatoms .gt. 0) then
        write (iout,8400)
        do i=1,99
          if (aw(i) .ne. 0.0) write (iout,8401)
     -      i,iatnam(i),aw(i),vdw(i),ramax(i),nval(i),namfcg(ianfg(i),1)
        end do
      end if
c     Set up solute libraries to print
      if (iprtlib .gt. 1) then
c       Print all libraries
        call indexit(iopsltpr,1,9,0)
        if (iop(3) .ne. 2) iopsltpr(2)=0
      else
        call zeroiti(iopsltpr,0,9)
        if (iprtlib .gt. 0) then
c         Print libraries used
          call trnsfi(iopsltpr,npfused,9)
          if (iop(20) .gt. 0 .and. iop(24) .gt. 0) then
c           Print (also) libraries modified
            do ip=1,9
              if (ipfmod(ip) .gt. 0) iopsltpr(ip)=1
            end do
          end if
        else if (iprtlib .lt. 0) then
c         Negative iprtlib is the library number selected to print
          iopsltpr(-iprtlib)=1
        end if
      end if
      if (iopsltpr(1) .gt. 0) then
c.......Echo Clementi types
        write (iout,9215) namstp(1)
        write (iout,9190)
        do i=1,maxtyp(1)
          if (iatnos(i,1) .ne. 0) then
            c1o=c1clm(i,1)
            c1h=c1clm(i,2)
            write (iout,9200) i,iatnam(iatnos(i,1)),
     -        namfcg(ifcnos(i,1),1),c6clm(i,1),c12clm(i,1),
     -        c1o,iox,c6clm(i,2),c12clm(i,2),c1h,ihyd,fsrad(i,1)
          end if
        end  do
        write (iout,*)
      end if
      if (iopsltpr(2) .gt. 0) then
c.......Echo inputted QPEN parameters
        write (iout,9210)
        write (iout,9190)
        do i=1,nslte
          if (nsltpr .eq. 0 .or. i .le. nsltpr)
     -      write (iout,9230) i,aslt(i),bslt(i),dslt(i)
        end do
        write (iout,9235)
        write (iout,9190)
        do i=1,nslve
          if (nsltpr .eq. 0 .or. i .le. nsltpr)
     -      write (iout,9230) i,aslv(i),bslv(i),dslv(i)
        end do
        if (escale .ne. 1.0) write (iout,9330) escale
        if (iopict .eq. 0) write (iout,0310)
        if (iopict .eq. 1) write (iout,0311)
        if (iopict .eq. 2) write (iout,0312)
      end if
      if (iopsltpr(3) .gt. 0) then
c.......Echo Kollman et al. parameters (old)
        write (iout,9215) namstp(3)
        write (iout,9243)
        do i=1,maxtyp(3)
          if (iatnos(i,3) .ne. 0) then
            call estoc6c12(epsamb(i),sigamb02(i),c6,c12)
            write (iout,9245) i,pflab(i,3),
     -        iatnam(iatnos(i,3)),namfcg(ifcnos(i,3),1),
     -        rminamb02(i),c6,c12,sigamb02(i),epsamb(i),fsrad(i,3)
          end if
        end do
      end if
      if (iopsltpr(4) .gt. 0) then
c.......Echo Kollman et al. parameters (DB94)
        write (iout,9215) namstp(4)
        write (iout,9243)
        do i=1,maxtyp(4)
          if (iatnos(i,4) .ne. 0) then
            call estoc6c12(epskol94(i),sigkol94(i),c6,c12)
            write (iout,9245) i,pflab(i,4),
     -        iatnam(iatnos(i,4)),namfcg(ifcnos(i,4),1),
     -        rmin94(i),c6,c12,sigkol94(i),epskol94(i),fsrad(i,4)
          end if
        end do
      end if
      if (iopsltpr(5) .gt. 0) then
c.......Echo Charmm parameters (Parm 22)
        write (iout,9215) namstp(5)
        write (iout,9244)
        do i=1,maxtyp(5)
          if (iatnos(i,5) .ne. 0) then
            call estoc6c12(epscha(i),sigcha(i),c6,c12)
            write (iout,9245) i,pflab(i,5),
     -        iatnam(iatnos(i,5)),namfcg(ifcnos(i,5),1),
     -        rmincha(i),c6,c12,sigcha(i),epscha(i),fsrad(i,5),
     -        rmincha14(i),epscha14(i)
          end if
        end do
      end if
      if (iopsltpr(6) .gt. 0) then
c.......Echo BVG Gromos87 parameters
        write (iout,9215) namstp(6)
        write (iout,9297)
        do i=1,maxtyp(6)
          if (iatnos(i,6) .ne. 0) then
            sqc6=c6bvg(i)
            sqc12=c12bvg(i)
            c6=sqc6**2
            c12=sqc12**2
            write (iout,9298) i,pflab(i,6),iatnam(iatnos(i,6)),
     -        namfcg(ifcnos(i,6),1),
     -        sqc6,sqc12,c6,c12,sigbvg(i),epsbvg(i),fsrad(i,6)
          end if
        end do
      end if
      if (iopsltpr(7) .gt. 0) then
c.......Echo BVG Gromos96 parameters
        write (iout,9215) namstp(7)
        write (iout,9297)
        do i=1,maxtyp(7)
          if (iatnos(i,7) .ne. 0) then
            sqc6=c6gro(i)
            sqc12=c12gro(i)
            c6=sqc6**2
            c12=sqc12**2
            write (iout,9298) i,pflab(i,7),iatnam(iatnos(i,7)),
     -        namfcg(ifcnos(i,7),1),
     -        sqc6,sqc12,c6,c12,siggro(i),epsgro(i),fsrad(i,7)
          end if
        end do
      end if
      if (iopsltpr(8) .gt. 0) then
c.......Echo OPLS - Jorgensen et al. parameters
        write (iout,9215) namstp(8)
        write (iout,9310)
        do i=1,maxtyp(8)
          if (iatnos(i,8) .ne. 0) then
            call estoc6c12(epsjrg(i),sigjrg(i),c6,c12)
            write (iout,9311) i,iatnam(iatnos(i,8)),pflab(i,8),
     -        namfcg(ifcnos(i,8),1),
     -        c6,c12,sigjrg(i),epsjrg(i),qjrg(i),fsrad(i,8)
          end if
        end do
      end if
      if (iopsltpr(9) .gt. 0) then
c.......Echo hard sphere parameters
        write (iout,9215) namstp(9)
        write (iout,9312)
        do i=1,maxtyp(9)
          if (iatnos(i,9) .ne. 0) then
            write (iout,9313) i,iatnam(iatnos(i,9)),pflab(i,9),sighs(i)
          end if
        end do
      end if
      if (iop(26) .eq. 4 .and. nmolec .gt. 1) then
        if (iop(37) .ne. iop(3)) then
          write (iout,9350) namstp(iop(3)),namstp(iop(37))
          nwarn=nwarn+1
        end if
        if (iprtlibcomb .gt. 0) then
c         For general solvent, print pf params generated from the libraries
          do i=1,nstta
            do j=1,nslv
              write (iout,9018) i,j,c6tv(i,j),c12tv(i,j),qtv(i,j)
            end do
          end do
          do i=1,nslv
            do j=1,nslv
              write (iout,9019) i,j,c6vv(i,j),c12vv(i,j),qvv(i,j)
            end do
          end do
        end if
      end if
      return
0310  format(/' QPEN potential without any inner cutoffs will be used'/)
0311  format(/' A hard sphere of radius ',f10.5,' A is placed at',
     -  ' the COM of solute ')
0312  format(/' Van der Waals radii are used to define inner cutoff ',
     -  'envelopes for solute and solvent molecules'/)
8400  format(/,30x,' === Atomic constants built in: ===',/,21x,'at. ',
     -  'weight VdW radius Max bondlength Max valence Functional group')
8401  format(i5,6x,a4,f15.5,f10.2,f12.2,i10,5x,a5)
9018  format(' PLBP: Potential parameters for solute atom ',i4,
     -  ' solvent atom ',i3,' c6=',f10.4,' c12=',f14.4,' qq=',f8.5)
9019  format(' PLBP: Potential parameters for solvent atoms ',
     -  2i4,' c6=',f10.4,' c12=',f14.4,' qq=',f8.5)
9190  format(25x,'c6',20x,'c12',17x,'c1',10x,'fs rad')
9200  format(i5,1x,a4,1x,a4,3f20.6,4x,a4,/,15x,3f20.6,4x,a4,f6.2)
9210  format(/' ===  Solute  electron QPEN parameters  === ')
9215  format(/,20x,'=== Parameters for ',a,' ===')
9230  format(i4,5x,3f20.6)
9235  format(/' ===  Solvent electron QPEN parameters  === ')
9243  format(5x,'pfl atnam fcg     rmin',9x,'c6',14x,'c12',9x,
     -  'sigma epsilon fs rad')
9244  format(7x,'pfl atnam',9x,'rmin',9x,'c6',14x,'c12',9x,'sigma ',
     -  'epsilon fs rad    rmin14  eps14')
9245  format(i4,1x,a,1x,a4,1x,a4,f8.4,2f17.6,f8.4,f8.5,f6.2,2x,2f8.4)
9297  format('        pfl atnam  fcg    sqrt(c6)   sqrt(c12)',13x,
     -  'c6',14x,'c12',7x,'sigma   epsilon    fs rad')
9298  format(i4,1x,a,3x,a4,1x,a4,1x,f9.2,3x,f9.2,5x,f15.5,f15.5,
     -  f10.3,f10.5,f10.2)
9310  format(5x,'atno  pll  fcg',11x,'c6',12x,'c12',8x,'sigma',4x,
     -  'epsilon',6x,'q',3x,'fs rad')
9311  format(i5,3(1x,a4),2f15.6,3f10.3,f7.3)
9312  format('   Atom   PF  HS radius')
9313  format(i4,2x,a2,2x,a,f10.3,' A')
9330  format(/,' QPEN energy scale factor=',f10.5)
9350  format(' ----- WARNING: solute and general solvent pf libraries',
     -  ' differ:',/,1x,a32,' and ',a32)
      end
      subroutine estoc6c12(eps,sig,c6lj,c12lj)
c#    MMC routine  98 lstmod: 12/23/03
c*****Covert epsilon-sigma to c6-c12
      c6lj=4.0*eps*sig**6
      c12lj=4.0*eps*sig**12
      return
      end
      subroutine bondtypestat(nneig,ineig,n,ian,iout,maxneig)
c#    MMC routine  98/a lstmod: 08/22/08
c*****Generate statistics over bonds
      dimension nneig(n),ineig(maxneig,n),ian(n),nbonds(17,17)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      do i=1,17
        call zeroiti(nbonds(1,i),0,17)
      end do
      if (n .eq. 0) return
      do ia=1,n
        iani=ian(ia)
        if (iani .le. 17) then
          do iaa=1,nneig(ia)
            ianj=ian(ineig(iaa,ia))
            if (ianj .le. 17) nbonds(iani,ianj)=nbonds(iani,ianj)+1
          end do
        end if
      end do
      nb=0
      do i=1,17
        do j=1,i
          nbij=nbonds(i,j)
          if (i .gt. j) nbij=nbij+nbonds(j,i)
          if (nbij .gt. 0) then
            if (nb .eq. 1) write (iout,*)
            nbij=nbij/2
            nb=nb+nbij
            write (iout,1000) iatnam(i)(1:2),iatnam(j)(1:2),nbij
          end if
        end do
      end do
      write (iout,1001) nb
      return
1000  format(' Number of ',a2,' - ',a2,' bonds=',i10)
1001  format(' Total number of bonds=',i10)
      end
      subroutine printbondlist(key,n1,n2,nstta,cslt,nneig,ineig,labslt,
     -  cv1,maxneig,rdtodg,nwarn,iverb,iout)
c#    MMC routine  98/b lstmod: 09/05/19
c*****List bonds, angles, torsions are requested
      character*4 key,labslt
      dimension cslt(3,nstta),nneig(nstta),ineig(maxneig,nstta),
     -  labslt(2,nstta),cv1(nstta)
      dimension ang(28),iang(2,28)
      do ia=n1,n2
        if (nneig(ia) .ne. 1) then
          do in=1,nneig(ia)
            cv1(in)=sqrt(arrdist(cslt(1,ia),cslt(1,ineig(in,ia))))
            if (cv1(in) .lt. 0.1) then
              write (iout,2265) ineig(in,ia)
              nwarn=nwarn+1
            end if
          end do
          if (key .eq. 'CNCT') then
            nnw=0
            do while (nnw .lt. nneig(ia))
              write (iout,2000)
     -          ia,(ineig(in,ia),in=nnw+1,min0(nnw+3,nneig(ia)))
              nnw=nnw+3
            end do
          else
            write (iout,2148) ia,(labslt(k,ia),k=1,2),nneig(ia),
     -        (ineig(in,ia),(labslt(k,ineig(in,ia)),k=1,2),cv1(in),
     -        in=1,nneig(ia))
          end if
        end if
        if (key(1:2) .eq. 'AN' .and. nneig(ia) .ge. 2) then
c         Generate angle list
          nnlim=min0(8,nneig(ia))
          nang=0
          do in1=1,nnlim
            do in2=in1+1,nnlim
              nang=nang+1
              ang(nang)=rdtodg*angleijk(cslt,nstta,ineig(in1,ia),ia,
     -          ineig(in2,ia),iout)
              iang(1,nang)=ineig(in1,ia)
              iang(2,nang)=ineig(in2,ia)
            end do
          end do
          write (iout,2142) (iang(1,i),ia,iang(2,i),ang(i),i=1,nang)
        end if
        if (key(3:4) .eq. 'RS') then
c         Generate torsion angle list
          do in=1,nneig(ia)
            inj=ineig(in,ia)
            if (inj .gt. in) then
              nnlim1=min0(8,nneig(ia)+1)
              nnlim2=min0(8,nneig(inj)+1)
              nang=0
              do in1=1,nnlim1
                inn1=ineig(in1,ia)
                if (inn1 .ne. inj) then
                  do in2=in1+1,nnlim2
                    inn2=ineig(in2,inj)
                    if (inn2 .ne. ia) then
                      nang=nang+1
                      ang(nang)=dihangl(cslt(1,inn1),cslt(1,ia),
     -                  cslt(1,inj),cslt(1,inn2),iverb,iout)
                      iang(1,nang)=inn1
                      iang(2,nang)=inn2
                    end if
                  end do
                end if
              end do
              write (iout,2182) (' ',iang(1,i),ia,inj,iang(2,i),
     -          rdtodg*ang(i),i=1,nang)
            end if
          end do
        end if
      end do
      return
2000  format('CONECT',4i5)
2142  format(3('  Angle(',i5,'-',i5,'-',i5,')=',f8.3,' deg'))
2148  format(i6,' (',a4,1x,a4,') -',i3,' neighbours:',/,
     -  (13x,4(i5,' (',a4,1x,a4,') r=',f7.4,' A')))
2182  format(3(a,' Torsion(',i5,'-',i5,'-',i5,'-',i5,')=',f7.2,' deg'))
2265  format(' ----- WARNING: unphysically short bond with atom',i7)
      end
      subroutine selftest(iop13,iopcont,nfail,imolck,justsaved,norest)
c#    MMC routine  99 lstmod: 02/27/24
c*****Internal consistency check on energies, forces and torques
c     If imolck > 0 then the check is performed with isolv=imolck as well
c     If imolck < 0 then check is done for molecs 1,2,...,(-imolck)
C@D1      common /eijtest/ eij(216,216)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /rangen/ xyzlim(3),xyzlm2(3),ixpxo
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /ecell/ cic(3,27),ncell
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      real*8 efieldst0,efieldmst
      common /fieldenergy/ efieldst0,efieldmst(#MM),
     -  efieldsv(#MO),esltfldo(#ST),esltfldn(#ST)
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      character*80 rngfile
      common /rnglist/ rnolist(#RN),nrand,irand,lrngfile,rngfile
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      real*8 texngd
      common /gatherd/ texngd(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      dimension z(3),z0(3),keycol(2)
      real*8 et,etst,etxo,tesi1o,tsis,estsc0,tss12n,tss6n,tss1n,
     -  x5a,x5b,gbuupto,gbuupdo,ettnb01o,es1401o,em14o,eintrao,
     -  t0ss12,t0ss6,t0ss1,t1ss12,t1ss6,t1ss1,esmslv,avg,edevmax,tesio,
     -  efldtst
C@DM      real*8 tsissum
C@FR      real*8 virsum,virold,virslt,virsltold
      dimension gbuupto(#TR),gbuupdo(#MM),ettnb01o(3,3),
     -  es1401o(3,3),em14o(#MM),eintrao(#MM),tesio(#MO),
     -  texslto(#MO)
      real*8 c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,dv1,dv2
      dimension c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),
     -  c9(3)
      character*5 slft(3)
      character*6 passfail
      character*80 filnam
      character*80 file
      character*132 line
      data slft /'Basic','Full ','Full '/
      call testconst(0,1,2,0.0,1.0,2.0,iout,nfail,1)
      if (nfail .gt. 0) call datprt(2)
C@DM      if (MYRANK .gt. 0) idebug(16)=0
      nfail12=0
      engtol0=engtol
      edevmax=0.d0
      itfirstck=1
      molstfck=molstf
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
        molstfck=nstfm+1
        itfirstck=nwidta+1
      end if
      if (justsaved .eq. 0) call csave(ichkp,1,iskipfail,1)
c     For equilibration run, limit discrepancy messages
      if (emax .gt. 0.0) then
        norddif=1
        if (emin .ne. 0) norddif=abs(alog(abs(emax/emin)))
        if (norddif .gt. 10) then
          if (idebug(16) .eq. 0 .and. idebug(125) .eq. 0) then
            write (iout,1021) emin,emax
            return
          end if
        end if
        if ((iop(11) .eq. 3 .or. iop(11) .eq. 4) .and.
     -       nmolec .gt. 100) engtol=realmx
      end if
      nmolecdo=nmolec
      nrepck=1
      if (imolck .gt. 0 .and. isolv .gt. 1) nrepck=2
      if (imolck .lt. 0) nrepck=-imolck
      call trnsfrd(tesio,tesi,nmolec)
      do irepck=1,nrepck
      passfail='passed'
      nfail=0
      if (imolck .lt. 0) then
        isolv=irepck
      else if (imolck .gt. 0 .and. irepck .eq. 2) then
        isolv=imolck
      end if
      if (isolv .gt. nmolec) isolv=nmolec
      if (irepck .eq. 1) then
        et=0.d0
C@ND        do i=1,nmolec
C@ND          et=et+tesi(i)
C@ND        end do
C@DM        do i=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM          et=et+tesi(i)
C@DM        end do
C@DM        call MPI_Allreduce(et,etst,1,MPI_DOUBLE_PRECISION,
C@DM     -        MPI_SUM,MPI_COMM_WORLD,ierr)
C@DM        et=etst+tesi(1)
        et=et/2.0
        et=et+ettnbo+fcintra*(einnbo+es14o+eslttoro)+ephso+
     -    efieldo+esmolo
C@FR        virold=virial(1)+virial(2)+virial(3)
C@FR        virsltold=vsltsm(1)+vsltsm(2)+vsltsm(3)
        edevmax=dabs(etoto-et)
        if (iop(117) .gt. 0) et=et+econstro
        call compcheck2(etoto,et,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nf0 .eq. 1 .or. idebug(16) .gt. 0)
     -    write (iout,1004) nmc,etoto,et
        etst=0.d0
        estsc0=0.d0
        do is=2,nmolec
          if (rcomiso(is) .lt. rinscs) estsc0=estsc0+texslt(is)
          etst=etst+texslt(is)
        end do
        tesi1o=tesi(1)
      end if
c-----Check tesi,frctot,trqtot
      call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolecdo)
C@D1      if (movtyp .eq. 1 .or.
C@D1     -    (movtyp .eq. 2 .and. iop(18) .le. 2)) then
C@D1        call eijtst(eij,216,nmolec,isolv,texn,tesi,2)
C@D1        call eijtst(eij,216,nmolec,isolv,texn,tesi,3)
C@D1      end if
c     Check solute energy components
      if (isolv .eq. 1) then
        call e123sum(tss12n,tss6n,tss1n,tsindn,nmolec)
        call esignck(tsindn,nmolec,'solute-solvent en.',iout,nfail)
      else
        call e123sum(tss12n,tss6n,tss1n,tsind,nmolec)
        call esignck(tsind,nmolec,'solute-solvent en.',iout,nfail)
      end if
      tsis=0.d0
      texn(isolv)=0.0
      if (nmolec .gt. 1) then
C@ND        do i=1,nmolec
C@ND          tsis=tsis+texn(i)
C@ND        end do
C@DM        do i=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM          tsis=tsis+texn(i)
C@DM        end do
C@DM        call MPI_Allreduce(tsis,tsissum,1,MPI_DOUBLE_PRECISION,
C@DM     -        MPI_SUM,MPI_COMM_WORLD,ierr)
C@DM        tsis=tsissum+texn(1)
      end if
c     Check solute intra terms
c     if (ntorgrp .gt. 0) then
      if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        eslttorn=0.d0
        do it=itfirstck,ntang
          eslttorn=eslttorn+torsen(it)
        end do
        call compcheck2(eslttoro,eslttorn,sv1,sv2,1,engtol,nfail,nf0,
     -    iout)
        if (nf0 .eq. 1 .or. idebug(16) .gt. 0)
     -    write (iout,1034) eslttoro,eslttorn
      end if
      nfail0=nfail
      call compcheck2(tesi1o,etst,sv1,sv2,1,engtol,nfail,nf0,iout)
      call compcheck2(tesi(isolv),tsis,sv1,sv2,1,engtol,nfail,nf0,iout)
      call compcheck2(estsco,estsc0,sv1,sv2,1,engtol,nfail,nf0,iout)
      if (nfail .gt. nfail0 .or. idebug(16) .gt. 0)
     -  write (iout,1006) isolv,tesi1o,estsco,tesi(isolv),
     -  etst,estsc0,tsis
      if (isolv .eq. 1) then
        x5a=tss12-tss6+tss1
        x5b=tss12n-tss6n+tss1n
        nfail0=nfail
        call compcheck2(x5a,tesi(1),sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(x5b,tesi(1),sv1,sc2,1,engtol,nfail,nf0,iout)
        if (nfail .gt. nfail0 .or. idebug(16) .gt. 0)
     -    write (iout,1032) x5a,x5b,tesi(1)
        if (deviat(x5a,tesi(1)) .gt. engtol .or. idebug(16) .gt. 2) then
          do is=2,nmolec
            et=tsindn(1,is)-tsindn(2,is)+tsindn(3,is)
            if (deviat(et,dble(texslt(is))) .gt. engtol .or.
     -          idebug(16) .gt. 2) write (iout,1041) is,et,texslt(is)
          end do
        end if
      end if
C@DM        icpuisolv=0
C@DM        do icpu=1,NUMNOD
C@DM          if (isolv .ge. iflslv(1,icpu) .and.
C@DM     -        isolv .le. iflslv(2,icpu)) icpuisolv=icpu
C@DM        end do
C@FR      if (nmolec .gt. 1) then
C@FRC@DM        if (myrank1 .eq. icpuisolv .or. isolv .eq. 1) then
C@FR        fmax=0.0
C@FR        tmax=0.0
C@FR        do k=1,3
C@FR          if (fmax .lt. dabs(frci(k))) fmax=dabs(frci(k))
C@FR          if (tmax .lt. dabs(trqi(k))) tmax=dabs(trqi(k))
C@FR        end do
C@FR        dvmxf=0.0
C@FR        dvmxt=0.0
C@FR        do k=1,3
C@FR          dv=deviat(frctot(k,isolv),frci(k))
C@FR          if (fmax .gt. 0.0) dv=dv*dabs(frci(k))/fmax
C@FR          if (dv .gt. dvmxf) dvmxf=dv
C@FR          dv=deviat(trqtot(k,isolv),trqi(k))
C@FR          if (tmax .gt. 0.0) dv=dv*dabs(trqi(k))/tmax
C@FR          if (dv .gt. dvmxt) dvmxt=dv
C@FR        end do
C@FR        call compcheck2(dv1,dv2,dvmxf,sv2,6,engtol,nfail,nf0,iout)
C@FR        call compcheck2(dv1,dv2,dvmxt,sv2,6,10.0*engtol,nfail,nf1,iout)
C@FR        if (nf0+nf1 .gt. 0 .or. idebug(16) .gt. 0) then
C@FR          write (iout,1001) isolv,(frctot(k,isolv),k=1,3),
C@FR     -      (trqtot(k,isolv),k=1,3),frci,trqi
C@FR        end if
C@FRC@DM        end if
C@FRC@DM        if (icpuisolv .gt. 0) call MPI_Bcast(nfail,1,MPI_INTEGER,
C@FRC@DM     -    icpuisolv-1,MPI_COMM_WORLD,ierr)
C@FR      end if
      if ((iop(30) .eq. 5 .or. iop(30) .eq. 6 .or. iop(30) .eq. 8)
     -    .and. irepck .eq. 1) then
        call e12sum(et,etxo,e01st,nmolec)
        nfail0=nfail
        call compcheck2(e0o,et,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(e1o,etxo,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nfail-nfail0 .gt. 0 .or. idebug(16) .gt. 0)
     -    write (iout,1012) e0o,e1o,et,etxo
        call e123sum(t0ss12,t0ss6,t0ss1,eone,nmolec)
        call esignck(eone,nmolec,'first copy slt eng',iout,nfail)
        nfail0=nfail
        call compcheck2(e0o12,t0ss12,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(e0o6,t0ss6,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(e0o1,t0ss1,sv1,sv2,1,engtol,nfail,nf0,iout)
        call e123sum(t1ss12,t1ss6,t1ss1,etwo,nmolec)
        call esignck(etwo,nmolec,'secnd copy slt eng',iout,nfail)
        call compcheck2(e1o12,t1ss12,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(e1o6,t1ss6,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(e1o1,t1ss1,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nfail .gt. nfail0 .or. idebug(16) .gt. 0)
     -    write (iout,1039) 'slv',e0o12,e0o6,e0o1,e1o12,e1o6,e1o1,
     -      'slv',t0ss12,t0ss6,t0ss1,t1ss12,t1ss6,t1ss1
        if (nstta .eq. nstfa .and. iop(30) .eq. 5) then
c         Regenerate sums with the lambda factor and compare
          nn=0
          do ig=1,npfgr(1)
            if (noppti(ig) .gt. 0) nn=nn+1
          end do
          if (nn .eq. 0) then
c           Compare only when lambda exponents were not changed for groups
            t0ss12=cpl1tix(1)*t0ss12+cpl0tix(1)*t1ss12
            t0ss6=cpl1tix(2)*t0ss6+cpl0tix(2)*t1ss6
            t0ss1=cpl1tix(3)*t0ss1+cpl0tix(3)*t1ss1
            nfail0=nfail
            call compcheck2(tss12n,t0ss12,sv1,sv2,1,engtol,nfail,nf0,
     -        iout)
            call compcheck2(tss6n,t0ss6,sv1,sv2,1,engtol,nfail,nf0,iout)
            call compcheck2(tss1n,t0ss1,sv1,sv2,1,engtol,nfail,nf0,iout)
            if (nf0 .eq. 1 .or. idebug(16) .gt. 0)
     -        write (iout,1045) tss12n,tss6n,tss1n,t0ss12,t0ss6,t0ss1
          end if
        end if
      end if
c     Check if bitmap would not prevent calculating this contribution
C@NN      if (iop(119) .eq. 0) then
C@NN        call mapcheck(mapbitv,crm,isolv,nmolec,ctslvs,nmaperr,iout,
C@NN     -    #VW,#MO,nbits)
C@NN        if (isolv .gt. 0 .and. (nmaperr .gt. 0 .or. idebug(16) .gt. 0))
C@NN     -    write (iout,1016) nmaperr,nupdat
C@NN        if (nmaperr .gt. 0) nfail=nfail+1
C@NN      end if
c     The tests below are independent of isolv, don't repeat them
      if (irepck .gt. 1) go to 90
c-----Check the preferential sampling weight sums
      if (iop(12) .gt. 3) call pfpsumck('Move',wpsmv,wpfpsmv,wpsmvsum,
     -  limpsmv,npfsmv,wsumtol,mvfst,nmolec,nfail,iout,idebug(16))
      if (iop(63) .gt. 0) then
        call pfpsumck('I/D ',wpsid,wpfpsid,wpsidsum,
     -    limpsid,npfsid,wsumtol,idsvfst,nmolec,nfail,iout,idebug(16))
        call pfpsumck('Grid',wpsgd,wpfpsgd,wpsgdsum,
     -    limpsgd,npfsgd,wsumtol,1,ngfree,nfail,iout,idebug(16))
      end if
C@FR      if (idebug(119) .gt. 0 .and. iop(21) .ne. 3) then
C@FRc-------Check force, torque by numerical differentiation
C@FR        do ndl=1,3
C@FR          del=0.1**(ndl+1)
C@FR          do k=1,3
C@FR            call crstr(0)
C@FR            call engold(iop(21),iop(119),isolv,texslt,vrcslt,
C@FR     -        frcslt,trtslt,trvslt,c,crm)
C@FR            phi=0.0
C@FR            call zeroit(ch,3)
C@FR            ch(k)=del
C@FR            if (isolv .eq. 1) then
C@FR              natm3=3*nstta
C@FR              icsol1=1
C@FR            else
C@FR              natm3=3*nslv
C@FR              icsol1=ic01+isolv*nslv
C@FR            end if
C@FR            call deploy(orient,c,crm,ch,phi,k)
C@FR            call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolecdo)
C@FR            fk=-(etotn-etoto)/del
C@FR            call crstr(0)
C@FR            call engold(iop(21),iop(119),isolv,texslt,vrcslt,
C@FR     -        frcslt,trtslt,trvslt,c,crm)
C@FR            call zeroit(ch,3)
C@FR            phi=del
C@FR            if (isolv .eq. 1) then
C@FR              natm3=3*nstta
C@FR              icsol1=1
C@FR            else
C@FR              natm3=3*nslv
C@FR              icsol1=ic01+isolv*nslv
C@FR            end if
C@FR            call deploy(orient,c,crm,ch,phi,k)
C@FR            call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolecdo)
C@FR            tk=-(etotn-etoto)/del
C@FR            write (iout,1000) del,k,fk,tk
C@FR          end do
C@FR        end do
C@FR        call crstr(0)
C@FR      end if
      if (iop13 .lt. 2) go to 50
c-----Check the near-neighbour bit map for symmetry
C@NN      call bitsymck(mapbitv,#VW,#MO,nmolec,2,nbits,
C@NN     -  ibit1,ibit2,iout,nmaperr)
C@NN      if (nmaperr .gt. 0) nfail=nfail+1
c-----Check etotn, virial and coord nos by recomputing it from scratch
      if (ngrdmx .gt. ngrdmn) then
        do im=ngrdmn,ngrdmx
          gbuupdo(im)=gbuupd(im)
        end do
      end if
      if (imolpt .gt. 0) call trnsfrd(gbuupto,gbuupt,ntorgrp)
      if (ntang .gt. 0) call trnsfrd(torsennew,torsen,ntang)
      do k=1,3
        ettnb01o(k,1)=ettnb01(k,1)
        ettnb01o(k,2)=ettnb01(k,2)
        ettnb01o(k,3)=ettnb01(k,3)
        es1401o(k,1)=es1401(k,1)
      end do
      call trnsfr(rijpsn,rijpso,nmolec)
      call trnsfi(ipxn,ipxo,nmolec)
      if (iop(92) .gt. 0) then
        ephsn=ephso
        call trnsfr(rphs0isn,rphs0iso,nmolec)
        nphsoutn=nphsout
      end if
      if (ncor1ok+ipsdist .gt. 0) call rvsitest(rphs0iso,rijpso,nslvds,
     -  2,nmolec,rri,iop(92),nfail0,nfail,iout,idebug(16),
     -  'rphs0o-nslvds')
      if (iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        do im=molstf,nsttm
          em14o(im)=em14(im)
          eintrao(im)=eintranb(im)
        end do
      end if
      call trnsfi(l4,nslvds,nmolec)
      if (iop(63) .gt. 0) call trnsfi(l3,nslvdsid,nmolec)
      if (iop(67) .gt. 0) call trnsfr(esltfldn,esltfldo,nstta)
      call trnsfr(texslto,texslt,nmolec)
      call eism0(0,0,noverl,nfsslt,nfslww,ksltmn,npckd,
     -  tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -  tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -  nslvdsid,gbuupd,gbuupt,esmslv,c,crm,nmc)
      if (noverl .gt. 0)  then
        write (iout,1013) noverl
        nwarn=nwarn+1
      end if
      edevmax=dmax1(edevmax,dabs(etoto-etotn))
      nfail0=nfail
      call compcheck2(etoto,etotn,sv1,sv2,1,engtol,nfail,nf0,iout)
      call compcheck2(tesi1o,tesi(1),sv1,sv2,1,engtol,nfail,nf0,iout)
      call compcheck2(estsco,estscn,sv1,sv2,1,engtol,nfail,nf0,iout)
      if (nfail .gt. nfail0 .or. idebug(16) .gt. 0) write (iout,1005)
     -    '              ',etoto,tesi1o,estsco,etotn,tesi(1),estsc0
      if (iop(67) .gt. 0) then
        call compcheck2(efieldo,efieldn,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1042)
     -    '              ',efieldo,efieldn
        if (iop(57) .gt. 0) then
          do im=1,nsttm
            call ixsum(esltfldo,ixislt,ifirstm(im),ilastm(im),
     -        nstta,efldtst)
            call compcheck2(efldtst,efieldmst(im),sv1,sv2,1,engtol,
     -        nfail,nf0,iout)
            if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1061)
     -        im,efieldmst(im),efldtst
          end do
        end if
      end if
      if (iop(119) .eq. 0) then
c       For now, virial sums are not calculated correctly under MPI
C@NDC@FR        virsum=virial(1)+virial(2)+virial(3)
C@NDC@FR        call compcheck2(virold,virsum,sv1,sv2,1,virtol,nfail,nf0,iout)
C@NDC@FR        if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1002)
C@NDC@FR     -    '              ','      ',virold,virsum
C@NDC@FR        virslt=vsltsm(1)+vsltsm(2)+vsltsm(3)
C@NDC@FR        call compcheck2(virsltold,virslt,sv1,sv2,1,virtol,nfail,
C@NDC@FR     -    nf0,iout)
C@NDC@FR        if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1002)
C@NDC@FR     -    '              ','Solute',virsltold,virslt
      end if
C@ND      do is=2,nmolec
C@ND        call compcheck2(dv1,dv2,texslt(is),texslto(is),4,engtol,
C@ND     -    nfail,nf0,iout)
C@ND        if (nf0 .eq. 1 .or. idebug(16) .gt. 1)
C@ND     -    write (iout,1065) is,texslto(is),texslt(is)
C@ND        call compcheck2(tesi(is),tesio(is),sv1,sv2,1,engtol,nfail,nf0,
C@ND     -    iout)
C@ND        if (nf0 .eq. 1 .or. idebug(16) .gt. 1)
C@ND     -    write (iout,1060) is,tesio(is),tesi(is)
C@ND      end do
C@DM      do is=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM        call compcheck2(dv1,dv2,texslt(is),texslto(is),4,engtol,
C@DM     -    nfail,nf0,iout)
C@DM        if (nf0 .eq. 1 .or. idebug(16) .gt. 1)
C@DM     -    write (iout,1065) is,texslto(is),texslt(is)
C@DM        call compcheck2(tesi(is),tesio(is),sv1,sv2,1,engtol,nfail,nf0,
C@DM     -    iout)
C@DM        if (nf0 .eq. 1 .or. idebug(16) .gt. 1)
C@DM     -    write (iout,1060) is,tesio(is),tesi(is)
C@DM      end do
      if (iop(57)+iop(58) .gt. 0 .or. iop(30) .eq. 7) then
        nfail0=nfail
        call compcheck2(ettnbo,ettnbn,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(einnbo,einnbn,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nfail .gt. nfail0.or. idebug(16) .gt. 0)
     -    write (iout,1033) ettnbo,einnbo,ettnbn,einnbn
        if (ngrdmx .gt. ngrdmn) then
          avg=0.d0
          do im=ngrdmn,ngrdmx
            avg=avg+dabs(gbuupdo(im))
          end do
          avg=avg/(ngrdmx-ngrdmn+1)
          do im=ngrdmn,ngrdmx
            devfac=1.0
            if (dabs(gbuupdo(im)) .lt. avg .and. gbuupdo(im) .ne. 0.d0
     -          .and. engtol .ne. realmx) devfac=avg/dabs(gbuupdo(im))
            call compcheck2(gbuupdo(im),gbuupd(im),sv1,sv2,1,
     -        engtol*devfac,nfail,nf0,iout)
            if (nf0 .gt. 0 .or. idebug(16) .gt. 1)
     -        write (iout,1009) im,gbuupdo(im),gbuupd(im)
C@D4              call checkeijmol(4,nstta,ifirstm(im),ilastm(im),
C@D4     -           ixislt)
          end do
        end if
        if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
          avg=0.d0
          do it=itfirstck,ntorgrp
            avg=avg+dabs(gbuupto(it))
          end do
          avg=avg/(ntorgrp-itfirstck+1)
          do it=itfirstck,ntorgrp
            devfac=1.0
            if (dabs(gbuupto(it)) .lt. avg .and. gbuupto(it) .ne. 0.d0
     -        .and. engtol .ne. realmx) devfac=avg/dabs(gbuupto(it))
            call compcheck2(gbuupto(it),gbuupt(it),sv1,sv2,1,
     -        engtol*devfac,nfail,nf0,iout)
            if (nf0 .gt. 0 .or. idebug(16) .gt. 1) write (iout,1017)
     -        it,gbuupto(it),gbuupt(it),gbuupt(it)-gbuupto(it)
          end do
        end if
      end if
      if ((iop(30) .eq. 5 .or. iop(30) .eq. 6) .and.
     -     nsttm .gt. nstfm) then
        nfail0=nfail
        do i=1,2
          do k=1,3
            call compcheck2(ettnb01(i,k),ettnb01o(i,k),sv1,sv2,1,engtol,
     -        nfail,nf0,iout)
          end do
        end do
        if (nfail .gt. nfail0 .or. idebug(16) .gt. 0)
     -     write (iout,1039) 'slt',((ettnb01(i,k),k=1,3),i=1,2),
     -       'slt',((ettnb01o(i,k),k=1,3),i=1,2)
      end if
      if (ntang .gt. 0) then
        nfail0=nfail
        call compcheck2(es14o,es14n,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(eslttoro,eslttorn,sv1,sv2,1,engtol,
     -    nfail,nf0,iout)
        if (nfail .gt. nfail0 .or. idebug(16) .gt. 0)
     -    write (iout,1036) es14o,eslttoro,es14n,eslttorn
        do it=itfirstck,ntang
          call compcheck2(torsen(it),torsennew(it),sv1,sv2,1,
     -      engtol,nfail,nf0,iout)
            if (nf0 .gt. 0 .or. idebug(16) .gt. 1)
     -        write (iout,1047) it,torsen(it),torsennew(it),
     -          torsennew(it)-torsen(it)
        end do
      end if
      if ((iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4) .and.
     -    (einnbo .ne. 0.d0 .or. es14o .ne. 0.d0)) then
        do im=molstfck,nsttm
          nfail0=nfail
          call compcheck2(em14o(im),em14(im),sv1,sv2,1,engtol,
     -      nfail,nf0,iout)
          call compcheck2(eintrao(im),eintranb(im),sv1,sv2,1,engtol,
     -      nfail,nf0,iout)
          if (nfail .gt. nfail0 .or. idebug(16) .gt. 1)
     -      write (iout,1035) im,eintrao(im),em14o(im),
     -        eintranb(im),em14(im)
        end do
      end if
      if (iop(92) .gt. 0) then
        call compcheck2(ephsn,ephso,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nf0 .gt. 0 .or. idebug(16) .gt. 0)
     -    write (iout,1056) ephsn,ephso
        if (nphsoutn .ne. nphsout) then
          write (iout,1049) nphsoutn,nphsout
          nfail=nfail+1
        end if
      end if
      if (nmolec .gt. 1) then
        if (iop(92) .gt. 0) then
          do is=mvfst,nmolec
            call compcheck2(dv1,dv2,rphs0isn(is),rphs0iso(is),5,comtol,
     -        nfail,nf0,iout)
            if (nf0 .gt. 0 .or. idebug(16) .gt. 1)
     -        write (iout,1057) is,rphs0isn(is),rphs0iso(is)
            if (nf0 .gt. 0) nfail=nfail+1
          end do
        end if
        if ((iop(12) .gt. 3 .and. iop(17) .eq. 0) .or.
     -      iop(92) .gt. 0) then
          do is=mvfst,nmolec
            call compcheck2(dv1,dv2,rijpsn(is),rijpso(is),5,comtol,
     -        nfail,nf0,iout)
            if (nf0 .gt. 0 .or. idebug(16) .gt. 1) write (iout,1052)
     -        is,rijpsn(is),rijpso(is)
            if (iop(17) .gt. 0) then
              if (ipxo(is) .ne. ipxn(is) .or. idebug(16) .gt. 1)
     -          write (iout,1059) is,ipxn(is),ipxo(is)
              if (ipxo(is) .ne. ipxn(is)) nf0=nf0+1
            end if
            if (nslvds(is) .ne. l4(is) .or. idebug(16) .gt. 1)
     -        write (iout,1058) is,' ',l4(is),nslvds(is)
            if (nslvds(is) .ne. l4(is)) nf0=nf0+1
            if (nf0 .gt. 0) then
              write (iout,1099)
              nfail=nfail+1
            end if
          end do
        end if
        if (iop(63) .gt. 0 .and.
     -     (iop(8) .eq. 0 .or. iop(8) .eq. 2)) then
          nfail0=nfail
          do is=2,nmolec
            if (nslvdsid(is) .ne. l3(is) .or. idebug(16) .gt. 1)
     -        write (iout,1058) is,'for PS insertion',l3(is),
     -          nslvdsid(is)
            if (nslvdsid(is) .ne. l3(is)) nfail=nfail+1
          end do
          if (nfail .gt. nfail0) write (iout,1099)
        end if
      end if
      if (iop(21).gt. 0 .and. idebug(120).gt. 0 .and. nmolec.gt. 1 .and.
     -    iop(21) .ne. 3) then
c       Check again with the scalar routines when vector routines were used
        iop21o=iop(21)
        iop(21)=0
        call eism0(0,0,noverl,nfsslt,nfslww,ksltmn,npckd,
     -    tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -    tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -    nslvdsid,gbuupd,gbuupt,esmslv,c,crm,nmc)
        if (noverl .gt. 0) write (iout,1013) noverl
C@FR        virsum=virial(1)+virial(2)+virial(3)
        nfail0=nfail
        call compcheck2(etoto,etotn,sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(tesi1o,tesi(1),sv1,sv2,1,engtol,nfail,nf0,iout)
        call compcheck2(estsco,estscn,sv1,sv2,1,engtol,nfail,nf0,iout)
        if (nfail .gt. nfail0 .or. idebug(16) .gt. 0) write (iout,1005)
     -    ' (HRDW SCLR)  ',etoto,tesi1o,estsco,etotn,tesi(1),estscn
        if (iop(67) .gt. 0) then
          call compcheck2(efieldo,efieldn,sv1,sv2,1,engtol,nfail,nf0,
     -      iout)
          if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1042)
     -      ' (HRDW SCLR)  ',efieldo,efieldn
        end if
        if (iop(119) .eq. 0) then
C@FR          call compcheck2(virold,virsum,sv1,sv2,1,virtol,nfail,nf0,iout)
C@FR          if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1002)
C@FR     -    ' (HRDW SCLR)  ','      ',virold,virsum
C@FR        virslt=vsltsm(1)+vsltsm(2)+vsltsm(3)
C@FR        call compcheck2(virsltold,virslt,sv1,sv2,1,virtol,nfail,
C@FR     -    nf0,iout)
C@FR        if (nf0 .eq. 1 .or. idebug(16) .gt. 0) write (iout,1002)
C@FR     -    '              ','Solute',virsltold,virslt
        end if
        do is=2,nmolec
          call compcheck2(dv1,dv2,texslt(is),texslto(is),4,engtol,
     -      nfail,nf0,iout)
          if (nf0 .eq. 1 .or. idebug(16) .gt. 1)
     -      write (iout,1065) is,texslto(is),texslt(is)
          call compcheck2(tesi(is),tesio(is),sv1,sv2,1,engtol,nfail,nf0,
     -      iout)
          if (nf0 .eq. 1 .or. idebug(16) .gt. 1)
     -      write (iout,1060) is,tesio(is),tesi(is)
        end do
        iop(21)=iop21o
      end if
c-----Check coordination numbers
      if (iop(4) .ge. 1) then
        nerr=0
        do im=1,nmolec
          if (ncor(im) .ne. npckd(im)) then
            write (iout,1014) im-1,ncor(im),npckd(im)
            nerr=nerr+1
          end if
        end do
        if (nerr .gt. 0) write (iout,1099)
        if (idebug(16) .gt. 0) write (iout,1015) nerr
        if (nerr .gt. 0) nfail=nfail+1
      end if
c-----Check neighbor list for consistency
      if (nstta .gt. 1) then
        call checknnlist(1,nstta,nneig,ineig,iout,inperr,nwwarn,nerr,0,
     -    1,0,#NL,#ST)
        if (nerr .gt. 0) write (iout,1099)
        if (idebug(16) .gt. 0) write (iout,1024) nerr
      end if
      if (iop(41) .ne. 1 .and. iop(41) .ne. 2) go to 50
c-----Check cover list for consistency  for cavity grid
      nferr=0
      do ind=1,ngfree
        indx=igfree(ind)
        call unpackijk(indx,ng1,ix,iy,iz)
        if (ncover(ix,iy,iz) .ne. -ind) then
          nferr=nferr+1
          write (iout,1023) ind,igfree(ind),ix,iy,iz,ncover(ix,iy,iz)
        end if
      end do
      if (nferr .gt. 0) nfail=nfail+1
      ncerr=0
      do ic=1,ngrid(1)
        do jc=1,ngrid(2)
          do kc=1,ngrid(3)
            if (ncover(ic,jc,kc) .le. 0) then
              indx=igfree(-ncover(ic,jc,kc))
              call unpackijk(indx,ng1,ix,iy,iz)
              if (ic .ne. ix .or. jc .ne. iy .or. kc .ne. iz) then
                ncerr=ncerr+1
                write (iout,1025) ic,jc,kc,ncover(ic,jc,kc),ix,iy,iz
              end if
            end if
          end do
        end do
      end do
      if (nferr+ncerr .gt. 0) then
        nfail=nfail+1
        write (iout,1099)
      end if
      if (idebug(16) .gt. 0 .or. nferr+ncerr .gt. 0)
     -   write (iout,1026) nmolec,nferr,ncerr
      nfail1=nfail
      if (#CV .ge. ng3) then
        ngf0=ngfree
        do im=2,nmolec
          call remcov(iout,crm(1,im),rsphs,rspvpe2,rspvme2,1)
        end do
        if (iop(57)+iop(58) .eq. 0 .and. iop(30) .ne. 7 .and.
     -      nmvd(1) .eq. 0) then
          if (nsltfr .ne. ngfree) then
            write (iout,1099) ':'
            nfail=nfail+1
          end if
          if (nsltfr .ne. ngfree .or. idebug(16) .gt. 0)
     -      write (iout,1037) ngfree,nsltfr
        end if
        ngf1=ngfree
        call rmcslt(iout,c,nstfa1+1,nstta,ixislt,ianslt,istop)
        if (istop .eq. 1 .and. iopcont .ne. 0) call datprt(-1)
        if (ngfree+ngdrop .ne. ng3) then
          write (iout,1099) ':'
          nfail=nfail+1
        end if
        if (ngfree+ngdrop .ne. ng3 .or. idebug(16) .gt. 0)
     -    write (iout,1038) ngfree,ng3
        call adcslt(c,nstfa1+1,nstta,ixislt,ianslt)
        if (ngf1 .ne. ngfree) then
          write (iout,1099) ':'
          nfail=nfail+1
        end if
        if (ngf1 .ne. ngfree .or. idebug(16) .gt. 0)
     -    write (iout,1040) ngfree,ngf1
        do is=2,nmolec
          call addcov(crm(1,is),rsphs,rspvpe2,rspvme2,1)
        end do
        if (ngf0 .ne. ngfree) then
          write (iout,1099) ':'
          nfail=nfail+1
        end if
        if (ngf0 .ne. ngfree .or. idebug(16) .gt. 0)
     -    write (iout,1027) ngf0,ngfree
        if (nfail1 .eq. nfail .and. idebug(16) .gt. 0)
     -     write (iout,1043)
      else if (idebug(16) .gt. 0) then
        write (iout,1044) ng3
      end if
c-----Check the PBC routine
50    if (iop(5) .le. 4 .and. idebug(80) .gt. 0) then
c       See if any solvent is outside the cell
        nerr=0
        do is=2,nmolec
          call trnsfr(z,crm(1,is),3)
          call pbcnd(z(1),z(2),z(3),iop(5),iopt0,d2)
          if (iopt0 .ne. 1) then
            nerr=nerr+1
            write (iout,1010) is,iopt0,(crm(k,is),k=1,3)
          end if
        end do
        if (idebug(16) .gt. 0) write (iout,1011) nerr
        if (nerr .gt. 0) write (iout,1099)
        if (nerr .gt. 0) nfail=nfail+1
        z0(1)=0.0
        nerr=0
        ntest=min0(100,#UV)
        if (iop13 .gt. 1)  ntest=min0(1000,#UV)
        do ir=1,ntest
          call mmc_random(3,texngd)
          do k=1,3
            z0(k)=1.1*(-xyzlim(k)+ texngd(k)*xyzlm2(k))
            zv(k,ir)=z0(k)
            frcng(k,ir)=z0(k)
          end do
          call trnsfr(z,z0,3)
          call pbcnd(z(1),z(2),z(3),iop(5),iopt0,d2)
          call trnsfr(z,z0,3)
          call pbcnd(z(1),z(2),z(3),7,iopt4,d2)
          indexx(ir)=iopt4
          if (iopt0 .ne. iopt4) then
            write (iout,1008) 'scalar',ir,iopt0,iopt4,z0
            nerr=nerr+1
          end if
        end do
        if (idebug(16) .gt. 0 .or .nerr .gt. 0)
     -     write (iout,1007) 'scalar',iop(5),ntest,nerr
        if (nerr .gt. 0) write (iout,1099)
        if (nerr .gt. 0) nfail=nfail+1
        call pbcvec(iop(5),1,ntest)
        nerr=0
        do ir=1,ntest
          if (indexx(ir) .ne. ivopt(ir)) then
            write (iout,1008)
     -        'vector',ir,ivopt(ir),indexx(ir),(frcng(k,ir),k=1,3)
            nerr=nerr+1
          end if
        end do
        if (idebug(16) .gt. 0 .or .nerr .gt. 0)
     -     write (iout,1007) 'vector',iop(5),ntest,nerr
        if (nerr .gt. 0) write (iout,1099)
        if (nerr .gt. 0) nfail=nfail+1
      end if
c-----Check the random number generator
      ncheck=#UV
      if (iop(124) .eq. 3 .and. nrand .lt. #UV) ncheck=nrand
      call mmc_random(ncheck,texngd)
      nout=0
      nhead=0
      ntail=0
      et=0.d0
      do i=1,ncheck
        if (texngd(i) .lt. 0.d0 .or. texngd(i) .gt. 1.d0) then
          write (iout,1018) texngd(i)
          nout=nout+1
        end if
        if (texngd(i) .lt. 0.5d0) ntail=ntail+1
        if (texngd(i) .ge. 0.5d0) nhead=nhead+1
        et=et+texngd(i)
        if (idebug(16) .gt. 1) write (iout,*) i,' rno=',texngd(i)
      end do
      if (idebug(16) .gt. 0)
     -  write (iout,1019) et/dfloat(ncheck),nhead,ntail,nout
      if (nout .gt. 0) write (iout,1099)
      if (nout .gt. 0) nfail=nfail+1
      nfail0=nfail
      if (iop(91) .gt. 0) then
c       Test distances only, don't regenerate
        call torcontest(ntang,iquata,c,idebug(16)-1,nfail0,iout,
     -    #ST,#TR)
        nfail=nfail+nfail0
        call checkgeom(1,nstta,c,rlcslt,nneig,ineig,iout,idebug(16)-1,
     -    d12tol,d13tol,nerr12,nerr13,devmax12,devmax13,devav12,
     -    devav13,#NL,imx12,jmx12,'in SELFTEST',11,#ST)
        if (nerr12+nerr13 .gt. 0) nfail=nfail+1
        if (idebug(70) .gt. 0)
     -    call regenerate(c,0,2,iout,nerr0,devmax)
        if (idebug(70) .gt. 1)
     -    call checkgeom(1,nstta,c,rlcslt,nneig,ineig,iout,idebug(16)-1,
     -      d12tol,d13tol,nerr12,nerr13,devmax12,devmax13,devav12,
     -      devav13,#NL,imx12,jmx12,'in selftest after REGENERATE',
     -      29,#ST)
        devmax14=0.0
        do it=itfirstck,ntang
c         Check loop distance info
          if (looptyp(it) .gt. 0) then
            call getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,i6,
     -        ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,looptyp(it),
     -        idebug(79),iout,'SELFTEST  ',#TR,#LT)
            do k=1,3
              c0(k)=c(k,ii0)
              c1(k)=c(k,ii1)
              c2(k)=c(k,ii2)
              c3(k)=c(k,ii3)
              c4(k)=c(k,ii4)
              c5(k)=c(k,ii5)
              c6(k)=c(k,ii6)
              c7(k)=c(k,ii7)
              c8(k)=c(k,ii8)
              c9(k)=c(k,ii9)
            end do
            call loopmemtest(it,looptyp(it),c0,c1,c2,c3,c4,c5,c6,c7,c8,
     -        c9,d14max,d12tol,d13tol,'SELFTEST',ifail,
     -        max0(idebug(16),idebug(71)),iout)
            if (d14max .gt. devmax14) devmax14=d14max
            if (ifail .gt. 0) then
              nfail=nfail+1
              write (iout,1099)
            end if
          end if
        end do
      else if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        call regenerate(c,0,2,iout,nerr,devmax)
        if (idebug(97) .gt. 0) then
          lfilnam=11
          filnam(1:lfilnam)='DEBUG_T.pdb'
          call savepdb('PDB ',keycol,iupdb1,iout,1,nstta,3,c,
     -      -1,0,0,1,file,nfl,nmc,2,filnam,lfilnam,1,1,0,inperr,
     -      nwarn,nwwarn,9,0,nlwr,0,-1,#NA)
        end if
        if (nerr .gt. 0) then
          nfail=nfail+1
          write (iout,1020) nerr,sqrt(devmax)
        else if (idebug(16) .gt. 0) then
          write (iout,1051) sqrt(devmax)
        end if
      end if
      if (nmc .eq. 0 .and. nfail .gt. nfail0) write (iout,1062)
c     Check solvents
      nxerr=0
      noerr=0
      if (nmolec .gt. 1) then
c       Check center of mass vs coordinates
        ncerr=0
        do im=2,nmolec
          call cofms(c(1,ic01+im*nslv),z,ianslv,1,nslv,1,wx)
          devs=0.0
          do k=1,3
            devs=devs+abs(z(k)-crm(k,im))
          end do
          if (devs .gt. comtol) then
            ncerr=ncerr+1
            write (iout,1028) im-1,devs
          end if
        end do
        if (nslv .gt. 2) then
          call checksolvents(iout,nmolec,orient,c,crm,ixislt,rlcslv,
     -      cslvo,ianslv,nslv,ixrep3,nrep3,ic00,ic01,nmc,zmattol,nxerr,
     -      noerr,#NA,#ST)
        end if
        nioerr=0
        if (iop(80) .gt. 0) then
          do im=2,nmolec
            call solvinout(molio,crm(1,im),edgelinxyz,edgerinxyz)
            if (molio .ne. molinout(im)) then
              nioerr=nioerr+1
              write (iout,1046) im,'MOND',molio,molinout(im)
            end if
          end do
        end if
        if (idebug(16) .gt. 0)
     -    write (iout,1030) ncerr,noerr,nxerr,nioerr
        if (ncerr+noerr+nxerr+nioerr .gt. 0) then
          nfail=nfail+1
          write (iout,1099)
        end if
      end if
      if (iop(57)+iop(79) .gt. 0 .or. iop(30) .ge. 7 .or.
     -    ntang .gt. 0) then
        noerr=0
        if (iop(57) .gt. 0) then
          do im=1,nsttm
            call chkort(orientsltm(1,1,im),im,noerr,iout,'solute  ',
     -        zmattol)
          end do
        end if
        nterr=0
        if (iop(30) .ge. 7) then
c         Check coupling parameter vs 3rd solute copy if applicable
          call checkcpl(1,c,crm,nstfa0,iclslt,isltmv,cplpar,nterr,1,
     -      MYRANK)
          if (nterr .gt. 0) then
            nfail=nfail+1
            write (iout,1099)
          end if
        end if
        tdevmax=0.0
        do it=itfirstck,ntang
          dihango(it)=dihangl(c(1,iquata(it,1)),c(1,iquata(it,2)),
     -      c(1,iquata(it,3)),c(1,iquata(it,4)),idebug(24)-1,iout)
          d=amin1(abs(dihang(it)-dihango(it)),
     -      abs(dihang(it)+pi2-dihango(it)),
     -      abs(dihang(it)-pi2-dihango(it)))*rdtodg
          if (d .gt. tdevmax) tdevmax=d
          call compcheck2(dv1,dv2,d,sv2,6,tortol,nfail,nf0,0)
          if (nf0 .gt. 0 .or. idebug(16) .gt. 1) write (iout,1031) it,
     -      (iquata(it,k),k=2,3),iamolslt(iquata(it,2)),
     -      dihang(it)*rdtodg,dihango(it)*rdtodg,d
          if (nf0 .gt. 0) nterr=nterr+1
        end do
        if (nterr .gt. 0) write (iout,1098) tortol,nterr
        if (idebug(16) .gt. 0 .or. nterr .gt. 0)
     -    write (iout,1050) tdevmax
        nioerr=0
        if (iop(79) .gt. 0) then
          do im=idsvfst,nmolec
            call solvinout(moliogr,crm(1,im),edgelgr,edgergr)
            if (moliogr .ne. molinoutgr(im)) then
              nioerr=nioerr+1
              write (iout,1046) im-1,'LIMG',moliogr,molinoutgr(im)
            end if
          end do
        end if
        if (idebug(16) .gt. 0) write (iout,1048) noerr,nterr,nioerr
        if (noerr+nterr+nioerr .gt. 0) then
          nfail=nfail+1
          write (iout,1099)
        end if
      end if
90    continue
      if (nfail .gt. 0) passfail='failed'
      nfail12=nfail12+nfail
      lline=65
      write (line,1003) slft(iop13),passfail,isolv,nmc,edevmax
C@DM      if (nfail .gt. 0) write (iout,1064)
      if (isolv .eq. 1 .and. iop(91) .gt. 0) then
        write (line(lline+1:lline+17),1053) tdevmax
        lline=lline+17
        write (line(lline+1:lline+49),1054)
     -    devmax12,devmax13,devmax14,imx12,jmx12
        lline=lline+49
      end if
      if (MYRANK .eq. 0) write (iout,1055) line(1:lline)
      engtol=engtol0
C@ND      if (norest .eq. 0) call crstr(0)
C@DM      if (norest .eq. 0) call crstr_mpi
c     End full loop
      end do
      nfail=nfail12
c     Save the last good checkpoint file on file ickpok
      if (nfail .eq. 0 .and. iopcont .eq. 4)
     -   call csave(ickpok,1,iskipfail,14)
      if (nfail .gt. 0) then
        numdiscr=numdiscr+1
        if (numdiscr .eq. 1) call echo_tol(iout)
      end if
C@DM      call MPI_Allreduce(nfail,nfailsum,1,MPI_INTEGER,MPI_SUM,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      nfail=nfailsum
      return
C@FR1000  format(' Del=',f8.5,' k=',i3,' fk=',e15.6,' tk=',e15.6)
C@FR1001  format(' isv=',i9,'   Original force=',3e15.6,' Torque=',
C@FR     -  3e15.6,/,15x,'Recomputed force=',3e15.6,' Torque=',3e15.6)
C@FR1002  format(a14,a6,' Original virial sum=',e16.9,/,
C@FR     -  19x,'Recomputed virial sum=',e16.9)
1003  format(1x,a5,' self test ',a,' (is=',i5,' Nmc=',i10,') Edev=',
     -  e10.3)
1004  format(' Self test at Nmc=',i10,
     -  ' Total energy and binding energy sum =',2e20.9)
1005  format (a14,'Original total energy, solute energies=',3e16.9,/,
     -  ' Completely recomputed total energy, solute energies=',3e16.9)
1006  format(' isv=',i9,'   Original solute and solvent binding energy='
     -       ,3e18.9,/,14x,' Recomputed solute and solvent ',
     -       'binding energy=',3e18.9)
1007  format(/,' Checking the ',a,' PBC routine -  PBC option assumed=',
     -  i2,' Number of points tested=',i5,' Number of errors=',i4)
1008  format(1x,a,' PBC error for random point',i6,' image=',i2,
     -  ' primitive alg image=',i2,' z=',3f10.6)
1009  format(' Moving solute molecule',i5,' old inter energy=', e20.9,/,
     -  22x,'Recomputed inter energy=',e20.9)
1010  format(' Solvent',i4,' is in cell number',i3,' : ',3f10.5)
1011  format(' Number of solvents outside the central cell=',i4)
1012  format('   Original E0,E1=',2e20.9,/,' Recomputed E0,E1=',2e20.9)
1013  format(' ----- WARNING:',i5,' solvent pairs overlap')
1014  format(' Coordination number error for solvent molecule',i5,
     -  ' stored value=',i5,' recomputed value=',i5)
1015  format(' The number of coordination number errors=',i5)
C@NN1016  format(' Number of bit-map errors=',i8,' Number of updates=',i8)
1017  format(' Torsion group',i5,' old inter energy=',
     -  e20.9,/,13x,'Recomputed inter energy=',e20.9,
     -  ' difference=',f20.10)
1018  format(' Random number ERROR:',e12.5,' is out of range')
1019  format(' Random number test - avg=',f6.3,' number of heads=',i6,
     -  ' number of tails=',i6,' number of errors=',i6)
1020  format(' ***** Discrepancy: regenerated coordinates differ for',
     -  i6,' solute atoms, maximum deviation:',f6.2,' A')
1021  format(' Self test skipped during presumed equilibration ',
     -  '(emin,emax=',2e14.5,')')
1023  format(' ***** Discrepancy: igfree(',i8,')=',i8,' points to ',
     -  'ncover(',i3,',',i3,',',i3,')=',i8)
1024  format(' Neighbor list test completed with ',i5,' errors')
1025  format(' ***** Discrepancy: ncover(',i3,',',i3,',',i3,')=',i8,
     -  ' points back to ',3i4)
1026  format(' Nmolec=',i6, ' The number of igfree and ncover errors=',
     -  2i6)
1027  format(' Number of free grids before removing',
     -  ' the system=',i9,' and after replacing the system=',i9)
1028  format(' ***** Discrepancy: the center of mass of solvent ',
     -  'molecule ',i4,' is inconsistent with the coordinates, max ',
     -  'deviation=',f9.4,' A')
1030  format(' The number of solvent center of mass, orientation',
     -  ' matrix and coordinate errors=',3i6,' in/out errors=',i9)
1031  format(' Torsion ',i5,' (',i5,'-',i5,') mol ',i5,' original ',
     -  'angle=',f10.5,' recomputed angle=',f10.5,' diff=',f10.5,' deg')
1032  format(22x,'Old and new solute energy 12-6-1 sums=',3e18.9)
1033  format(' Original   solute inter and intra NB energies=',2e20.9,/,
     -  ' Recomputed solute inter and intra NB energies=',2e20.9)
1034  format(' Solute old torsion energy=',e19.9,/,
     -  8x,' recomputed energy=',e19.9)
1035  format(' Molecule',i4,' original intra NB and 1-4 energies=',
     -  2e20.9,/,12x,'recomputed intra NB and 1-4 energies=',2e20.9)
1036  format(' Original   solute torsion group 1-4, torsion energies=',
     -  2e20.9,/, ' Recomputed solute torsion group 1-4,',
     -  ' torsion energies=',2e20.9)
1037  format(' Number of free grids after removing all solvents=',i9,
     - ' original number of free grids without the solvent=',i9)
1038  format(' Number of free grids after removing all solvents and',
     - ' the solute=',i9,' and the total number of free grids=',i9)
1039  format(' Original   ',a3,' TI terms l0:',3e16.9,' l1:',3e16.9,/,
     -       ' Recomputed ',a3,' TI terms l0:',3e16.9,' l1:',3e16.9)
1040  format(' Number of free grids before removing the solute=',
     -  i9,' and after replacing the solute=',i9)
1041  format(' Molecule',i5,' tsind sum=',e12.5,' texslt=',e12.5)
1042  format (a14,'Original field energy=',e16.9,/,
     -  12x,'Recomputed field energy=',e16.9)
1043  format(' Grid cover removal test OK')
1044  format(' Grid cover removal test not done since # CV < ',i10)
1045  format(' Original   FE solute energy contributions=',3e20.9,/,
     -       ' Recomputed FE solute energy contributions=',3e20.9)
1046  format(' Discrepancy : solvent molecule ',i6,1x,a4,
     -  ' inside/outside status calculated=',i1,' recorded=',i1)
1047  format(' Torsion ',i5,' Original energy=',e20.9,/,12x,
     -  ' Recomputed energy=',e20.9,' difference=',f20.10)
1048  format(' The number of solute orientation matrix errors=',i6,
     -  ' torsion errors=',i6,' in/out errors=',i9)
1049  format(' ***** Discrepancy: original number of solvents in the ',
     -  ' restraining shell=',i5,' recomputed number=',i5)
1050  format(' Maximum torsion angle deviation=',f19.5,' deg')
1051  format(' Maximum distance between original and regenerated ',
     -  'atoms=',f8.5,' A')
1052  format(' Solvent ',i6,' original proximity distance=',f10.5,/,13x,
     -  ' recomputed proximity distance=',f10.5)
1053  format(' Tdevmx=',f5.1,' deg')
1054  format(' D12,13,14devmx=',3f7.4,' A',2i5)
1055  format(a)
1056  format(' Original restraining energy=',e20.9,
     -  ' recomputed restraining energy=',e20.9)
1057  format(' Solvent ',i6,' original unmodified proximity distance=',
     -  f10.5,13x,' recomputed unmodified proximity distance=',f10.5)
1058  format(' Solvent ',i6,' original integer distance ',a,
     -  ' from solute=',i4,' recomputed distance=',i4)
1059  format(' Solvent ',i6,' proximal solute=',i6,' recomputed ',
     -  'proximal solute=',i6)
1060  format(' Solvent',i6,' Original binding energy=',e20.9,/,
     -  13x,'Recomputed binding energy=',e20.9)
1061  format(' Solute molecule',i5,' Original field energy=',e20.9,/,
     -  20x,'Recomputed field energy=',e20.9)
1062  format(7x,'Such disrepancies at the start of the run are ',
     -  'usually the result of mismatch between the .slt and the input',
     -  ' coordinate file')
C@DM1063  format(' Self tests are disabled when MPI is used')
C@DM1064  format(' Self tests failure')
1065  format(' Solvent',i6,' Original solute  energy=',e20.9,/,
     -  13x,'Recomputed solute  energy=',e20.9)
1098  format(' ***** Discrepancy found: tolerance (',e10.2,') exceeded',
     -  ' for ',i5,' torsions')
1099  format(' ***** Discrepancy found',a)
      end
      subroutine echo_tol(iout)
c#    MMC routine 99a lstmod: 10/15/20
c*****Echo self-test tolerances
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      write (iout,1000) engtol,virtol,tortol,comtol,zmattol,cslttol,
     -  d12tol,d13tol,wsumtol,costol
1000  format(' Self test tolerances used:',/,
     -  ' Energy:',f8.5,' Virial sum:',f8.5,' Torsion angle:',f8.3,
     -  ' Center of mass coordinates:',f8.5,
     -  ' Matrix orthogonality:',f8.5/,' Solute atom coordinates:',f8.5,
     -  ' Bond length:',f6.3,' 1-3 distance:',f6.3,
     -  ' Pref sampling weight sum:',f8.5,' sin/cos:',f6.3)
      end
      subroutine chkort(o,im,noerr,iout,label,devlim)
c#    MMC routine 100 lstmod: 01/24/02
c*****Check a matrix for orthonormality
      dimension o(3,3),scpr(3,3)
      character*8 label
      do i=1,3
        do j=i,3
          sum=0.0
          scpr(i,j)=o(i,1)*o(j,1)+o(i,2)*o(j,2)+o(i,3)*o(j,3)
        end do
      end do
      do k=1,3
        if (abs(scpr(k,k)-1.0) .gt. devlim) then
          write (iout,1000) k,k,im,label,1.0,scpr(k,k),devlim
          noerr=noerr+1
        end if
        do j=i+1,3
          if (abs(scpr(i,j)) .gt. devlim) then
            write (iout,1000) i,j,im,label,0.0,scpr(i,j),devlim
            noerr=noerr+1
          end if
        end do
      end do
      return
1000  format(' ***** ERROR: M(',i1,',*).M(',i1,',*) of the',i5,'-th ',a,
     -  ' orientation matrix is not',f4.1,':',f9.5,
     -  ' tolerance (zmattol)=',f8.6)
      end
      subroutine pfpsumck(type,wpf,wpfps,wpfsum,limps,nps,devlim,
     -  ifirst,n,nfail,iout,idebugst)
c#    MMC routine 101 lstmod: 03/03/96
c*****Check preferential weight sums
      character*4 type
      dimension wpf(n),wpfps(nps),limps(nps)
      real*8 sum,wpfps,wpfsum
C@DB      write (iout,7210) type,(limps(i),i=1,nps)
C@DB7210  format(a4,16x,' limps=',10i8)
C@DB      write (iout,7211) type,wpfsum,(wpfps(i),i=1,nps)
C@DB7211  format(a4,' wpfsum=',f8.4,' wpfps=',10f8.4)
C@DB      write (iout,7212) type,(wpf(i),i=1,n)
C@DB7212  format(a4,' wpf=',15f8.4,/,(4x,' wpf=',15f8.4))
      devmax=0.0
      sum=0.d0
      j0=ifirst
      do ips=1,nps
        do j=j0,limps(ips)
          sum=sum+wpf(j)
        end do
        dev=deviat(sum,wpfps(ips))
        if (dev .gt. devmax) devmax=dev
        if (dev/wpfsum .gt. devlim) then
          nfail=nfail+1
          write (iout,1099)
          write (iout,1000) type,ips,wpfps(ips),sum
        end if
        j0=limps(ips)+1
      end do
      ie0=nfail
      if (deviat(wpfsum,sum) .gt. devlim) then
        write (iout,1099)
        nfail=nfail+1
      end if
      if (nfail .gt. ie0 .or. idebugst .gt. 0)
     -  write (iout,1001) type,wpfsum,sum,devmax
      return
1000  format(1x,a4,' preferential sampling weight ',i2,'-th partial',
     -  ' sum discrepancy: original sum=',e15.8,' recomputed sum=',
     -  e15.8)
1001  format(1x,a4,' preferential sampling weight original sum=',e15.8,
     -  ' Recomputed sum=',e15.8,' Max dev for partial sums=',e12.5)
1099  format(' ***** Discrepancy found:')
      end
      subroutine esignck(e,n,name,iout,nfail)
c#    MMC routine 102 lstmod: 07/03/96
c*****Check energy contributins for sign
      dimension e(3,#MO)
      character*18 name
      do i=2,n
        if (e(1,n) .lt. 0.0) then
          write (iout,1000) i,e(1,n),name
          nfail=nfail+1
        end if
        if (e(2,n) .lt. 0.0) then
          write (iout,1001) i,-e(2,n),name
          nfail=nfail+1
        end if
      end do
      return
1000  format(' ***** ERROR: Negative repulsion   contribution from ',
     -  'solvent ',i6,':',e12.5,' to ',a18)
1001  format(' ***** ERROR: Positive dispersion contribution from ',
     -  'solvent ',i6,':',e12.5,' to ',a18)
      end
      subroutine bitsymck(mapbit,nbitmx,nmx,n,n0,nbits,ix1,ix2,
     -  iout,nmaperr)
c#    MMC routine 103 lstmod: 08/23/00
c*****Check bitmap for symmetry
      dimension mapbit(nbitmx,nmx),ix1(nmx),ix2(nmx)
c-----Check the near-neighbour bit map for symmetry
      nmaperr=0
      do ir=n0,n
        call readbitc(mapbit,ir,ix1,1,n,nbitmx,nmx,nbits)
        call readbitr(mapbit,ir,ix2,1,n,nbitmx,nmx,nbits)
        do ic=n0,n
          if (ix1(ic) .ne. ix2(ic)) then
            if (nmaperr .le. 100) write (iout,1009) ir,ic
            nmaperr=nmaperr+1
          end if
        end do
      end do
      return
1009  format(' Bit-map ERROR: no symmetry for indices',2i6)
      end
C@NN      subroutine mapcheck(mapbit,crm,islv,nmolec,ctslvs,nmaperr,
C@NN     -   iout,nbitmx,nmx,nbits)
C@NNc#    MMC routine 104 lstmod: 12/01/97
C@NNc*****Check bitmap for distance consistency
C@NN      dimension crm(3,#MO),mapbit(nbitmx,nmx)
C@NN      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
C@NN     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
C@NN     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
C@NN     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
C@NN      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
C@NN     -  cci(3,#UV)
C@NN      common /option/ iop(200),idebug(200)
C@NN      nmaperr=0
C@NN      if (islv .eq. 1) return
C@NN      isf=islv
C@NN      isl=islv
C@NN      if (idebug(37) .gt. 1) then
C@NN        isf=2
C@NN        isl=nmolec
C@NN      end if
C@NN      do isolv=isf,isl
C@NN        do is=2,nmolec
C@NN          call arrdiff(zv(1,is),crm(1,is),crm(1,isolv),3)
C@NN        end do
C@NN        if (iop(21) .gt. 0) then
C@NN          call pbcvec(iop(5),2,nmolec)
C@NN        else
C@NN          do is=2,nmolec
C@NN            call pbcnd(zv(1,is),zv(2,is),zv(3,is),iop(5),iopt,
C@NN     -        riijjv(is))
C@NN          end do
C@NN        end if
C@NN        call readbitc(mapbit,isolv,indexx,1,nmolec,#VW,#MO,nbits)
C@NN        if (idebug(37) .gt. 0) then
C@NN          do is=2,nmolec
C@NN            texng(is)=sqrt(riijjv(is))
C@NN          end do
C@NN          write (iout,1000) isolv,(indexx(is),is=2,nmolec)
C@NN          write (iout,1001) isolv,(texng(is),is=2,nmolec)
C@NN        end if
C@NN        do is=2,nmolec
C@NN          if (is .ne. isolv .and. riijjv(is) .le. ctslvs) then
C@NN            if (indexx(is) .eq. 0) then
C@NN              nmaperr=nmaperr+1
C@NN              if (nmaperr .le. 100) write (iout,1002) is,isolv
C@NN            end if
C@NN          end if
C@NN        end do
C@NN      end do
C@NN      return
C@NN1000  format(i5,' map=',24i5)
C@NN1001  format(i5,' rij=',24f5.1)
C@NN1002  format(' ***** Molecules',2i6,' are closer than the cutoff',
C@NN     -  ' distance but bitmap is off')
C@NN      end
      subroutine testconst(izero,ione,itwo,fzero,fone,ftwo,iout,nfail,
     -  initfail)
c#    MMC routine 105 lstmod: 01/18/07
c*****Check the integrity of stored constants
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      real*8 dpmx,dpsqmx,dd
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      if (initfail .gt. 0) nfail=0
      if (itwo+itwo .ne. itwo*itwo .or. itwo+itwo .eq. itwo) then
        nfail=nfail+1
        write (iout,1000) 'integer two'
      end if
      if (ftwo+ftwo .ne. ftwo*ftwo .or. ftwo+ftwo .eq. ftwo) then
        nfail=nfail+1
        write (iout,1000) 'float two'
      end if
      if (ione+ione .eq. ione .or. ione*ione .ne. ione) then
        nfail=nfail+1
        write (iout,1000) 'integer one'
      end if
      if (fone+fone .eq. ione .or. fone*fone .ne. fone) then
        nfail=nfail+1
        write (iout,1000) 'float one'
      end if
      if (izero+izero .ne. izero .or. izero*izero .ne. izero) then
        nfail=nfail+1
        write (iout,1000) 'integer zero'
      end if
      if (fzero+fzero .ne. fzero .or. fzero*fzero .ne. fzero) then
        nfail=nfail+1
        write (iout,1000) 'float zero'
      end if
      if (ichar(tab) .ne. 9) then
        write (iout,1000) 'TAB character'
        nfail=nfail+1
      end if
      call testconlim(dpmx,'dpmx',4,1.d100,iout,nfail)
      call testconlim(dpsqmx,'dpsqmx',6,1.d50,iout,nfail)
      dd=realmx
      call testconlim(dd,'realmx',6,1.d30,iout,nfail)
      dd=rlsqmx
      call testconlim(dd,'rlsqmx',6,1.d15,iout,nfail)
      dd=rllnmx
      call testconlim(dd,'rllnmx',6,60.d0,iout,nfail)
      dd=dblnmx
      call testconlim(dd,'dblnmx',6,230.d0,iout,nfail)
      return
1000  format(' ***** PROGRAM ERROR: Internal constant ',a,
     -  ' is corrupted')
      end
      subroutine testconlim(dcon,name,lname,dmax,iout,nfail)
c#    MMC routine 105/a lstmod: 09/14/12
      real*8 dcon,dmax
      character*(*) name
      if (dcon .eq. 0.d0) then
        write (iout,1000) name(1:lname)
        nfail=nfail+1
      else if (dcon .lt. dmax) then
        write (iout,1001) name(1:lname),dcon,dmax
      end if
      return
1000  format(' ***** PROGRAM ERROR: word size parameter ',a,
     -  ' is zero')
1001  format(' ===== LIKELY PROGRAM ERROR: word size parameter ',a,
     -  '=',d12.5,' is below ',d12.5)
      end
      subroutine checkgeom(n1,n,c,cref,nneig,ineig,iout,LEVTEST,
     -  d12tol,d13tol,nerr12,nerr13,devmax12,devmax13,devav12,devav13,
     -  maxneig,imx12,jmx12,label,lablen,maxat)
c#    MMC routine 106 lstmod: 06/28/04
c*****Compare the bond lengths and angles between two conformations
      dimension c(3,maxat),cref(3,maxat),nneig(maxat),
     -  ineig(maxneig,maxat)
      character*(*) label
      if (n-n1 .lt. 2) return
      if (LEVTEST .gt. 0)
     -  write (iout,*) '1-2 distance check called ',label(1:lablen)
      nerr12=0
      nerr13=0
      n12=0
      n13=0
      devav12=0.0
      devav13=0.0
      devmax12=0.0
      devmax13=0.0
      imx12=0
      jmx12=0
      imx13=0
      jmx13=0
      do i2=n1,n
        do ii1=1,nneig(i2)
          i1=ineig(ii1,i2)
          if (i1 .lt. i2) then
            d12=sqrt(arrdist(c(1,i1),c(1,i2)))
            d12ref=sqrt(arrdist(cref(1,i1),cref(1,i2)))
            d12dev=abs(d12-d12ref)
            devav12=devav12+d12dev
            n12=n12+1
            if (d12dev .gt. devmax12) then
              devmax12=d12dev
              imx12=i1
              jmx12=i2
            end if
            if (d12dev .gt. d12tol) then
              nerr12=nerr12+1
              if (LEVTEST .ge. -2)
     -          write (iout,1001) 2,i1,i2,d12,d12ref,d12dev,d12tol
            else if (LEVTEST .gt. 0) then
              write (iout,1000) 2,i1,i2,d12,d12ref,d12dev
            end if
          end if
        end do
      end do
      if (LEVTEST .gt. 0)
     -  write (iout,*) '1-3 distance check called ',label(1:lablen)
      do i2=n1,n
        do ii1=1,nneig(i2)
          i1=ineig(ii1,i2)
          do ii3=1,nneig(i2)
            i3=ineig(ii3,i2)
            if (i1 .lt. i3) then
              d13=sqrt(arrdist(c(1,i1),c(1,i3)))
              d13ref=sqrt(arrdist(cref(1,i1),cref(1,i3)))
              d13dev=abs(d13-d13ref)
              devav13=devav13+d13dev
              n13=n13+1
              if (d13dev .gt. devmax13) then
                devmax13=d13dev
                imx13=i1
                jmx13=i3
              end if
              if (d13dev .gt. d13tol) then
                nerr13=nerr13+1
                if (LEVTEST .ge. -2)
     -            write (iout,1001) 3,i1,i3,d13,d13ref,d13dev,d13tol
              else if (LEVTEST .gt. 0) then
                write (iout,1000) 3,i1,i3,d13,d13ref,d13dev
              end if
            end if
          end do
        end do
      end do
      devav12=devav12/n12
      devav13=devav13/n13
      if (nerr12+nerr13 .gt. 0 .and. LEVTEST .ge. -1)
     -   write (iout,1003) label(1:lablen),nerr12,nerr13
      if (nerr12+nerr13 .gt. 0 .or. LEVTEST .ge. 0)
     -  write (iout,1004) label(1:lablen),devmax12,imx12,jmx12,
     -  devmax13,imx13,jmx13,devav12,devav13
      if (devmax13*d12tol/d13tol .gt. devmax12) then
        imx12=imx13
        jmx12=jmx13
      end if
      return
1000  format(' CHECKGEOM i1,i',i1,'=',i5,i6,' d=',f10.5,
     -  ' dref=',f10.5,' diff=',f10.5)
1001  format(' 1-',i1,' bond length deviation between atoms',i5,i6,
     -  ': d=',f10.5,' dref=',f10.5,' diff=',f10.5,
     -  ' tolerance=',f8.5,' A')
1003  format(' ***** Discrepancy (',a,'): 1-2 or 1-3 distances differ',
     -  ' from their reference value for',i5,' and',i5,' bonds, resp.')
1004  format(' CHECKGEOM ',a,' Max(dij): d12=',f10.6,' A (',
     -  2i5,') d13=',f10.6,' A (',2i5,') <dij>=',2f9.6,' A')
      end
      subroutine bondcheck(iout,nfirst,n,iatnum,nneig,ineig,c,
     -  labslt,nmake,nwarn,nwwarn,inperr,maxng)
c#    MMC routine 106/a lstmod: 10/18/20
      dimension nneig(n),ineig(maxng,n),c(3,n),iatnum(n)
      character*4 labslt(2,n)
      dimension lewl(3)
      character*22 ewl(3)
      data ewl /' ----- WARNING:',' ===== STRONG WARNING:',
     -  ' ***** ERROR:'/,lewl /15,22,13/
c     Check for bonded atoms outside their bond range
      nmsg=0
      do i=nfirst,n
        do jj=1,nneig(i)
          j=ineig(jj,i)
          if (i .lt. j) then
            rlim2=bondthresh2(iatnum(i),iatnum(j))
            d2=arrdist(c(1,i),c(1,j))
            if (d2 .gt. rlim2) then
              dd=sqrt(d2)
              rl=sqrt(rlim2)
              if (dd .lt. 1.2*rl) then
                iewl=1
                nwarn=nwarn+1
              else if (dd .lt. 2.0*rl .or. nmake .gt. 0) then
                iewl=2
                nwwarn=nwwarn+1
              else
                iewl=3
                inperr=inperr+1
              end if
              write (iout,1000) ewl(iewl)(1:lewl(iewl)),i,
     -          labslt(2,i),labslt(1,i),j,labslt(2,j),
     -          labslt(1,j),dd,rl
              nmsg=nmsg+1
            end if
          end if
        end do
      end do
      if (nmsg .eq. 0) then
        write (iout,*) 'All bonds in the input ',
     -    'structure are within threshold'
      else if (nmake .gt. 0) then
        write (iout,*) ' NOTE: additional bonds formed with the MAKB ',
     -    'key may have introduced these warnings'
      end if
      return
1000  format(a,' distance between atom ',i6,'(',a,',',a,') and atom',
     -  i6,'(',a,',',a,')=',f8.3,' (threshold=',f6.3,')')
      end
      subroutine checknnlist(n1,n,nneig,ineig,iout,inperr,nwwarn,ne,
     -  list,ierrwarn,ifix,maxneig,maxat)
c#    MMC routine 107 lstmod: 03/30/19
      dimension nneig(maxat),ineig(maxneig,maxat)
c*****Check the neighbor list for consistency and validity
      dimension lerrwarn(2),mask(36)
      character*21 errwarn(2)
      data errwarn /' ***** ERROR',' ===== STRONG WARNING'/,
     -  lerrwarn /12,21/
      if (list .gt. 0) write (iout,1003) n1,n
c     Check neighbor list for symmetry
      ne=0
      nfix_tot=0
      do ia=n1,n
        neprev=ne
        nfix=0
        if (ifix .gt. 0) then
          if (nneig(ia) .gt. 36) then
            write (iout,1005) nneig(ia)
            stop
          end if
          call zeroiti(mask,0,nneig(ia))
        end if
        do in=1,nneig(ia)
          inn=ineig(in,ia)
          ifound=0
          do jn=1,nneig(inn)
            if (ineig(jn,inn) .eq. ia) ifound=1
          end do
          if (ifound .eq. 0) then
            if (ifix .lt. 2) then
              write (iout,1001) errwarn(ierrwarn)(1:lerrwarn(ierrwarn)),
     -          inn,ia
              write (iout,1002) inn,(ineig(i,inn),i=1,nneig(inn))
            end if
            if (ifix .gt. 0) then
              nfix=nfix+1
              mask(in)=1
            else
              ne=ne+1
            end if
          end if
        end do
        if (nfix .gt. 0) then
c         Remove the violators from ia's neighbour list
          ndel=0
          do jn=1,nneig(ia)
            if (mask(jn) .eq. 1) then
              ndel=ndel+1
            else
              ineig(jn-ndel,ia)=ineig(jn,ia)
            end if
          end do
          nneig(ia)=nneig(ia)-nfix
          nfix_tot=nfix_tot+nfix
        end if
        if ((ne .gt. neprev .or. list .gt. 0) .and. ifix .lt. 2)
     -    write (iout,1002) ia,(ineig(i,ia),i=1,nneig(ia))
      end do
c     Check neighbor index range
      do ia=n1,n
        do in=1,nneig(ia)
          inn=ineig(in,ia)
          if (inn .lt. n1 .or. inn .gt. n) then
            ne=ne+1
            write (iout,1000) errwarn(ierrwarn)(1:lerrwarn(ierrwarn)),
     -        in,ia,inn,n1,n
          end if
        end do
      end do
      if (ierrwarn .eq. 1) inperr=inperr+ne
      if (ierrwarn .eq. 2) nwwarn=nwwarn+ne
      if (nfix_tot .gt. 0) write (iout,1004) nfix_tot
      return
1000  format(a,': index of the',i3,'-th neighbor of ',
     -  'atom',i9,':',i9,' - it is outside the [',i9,',',i9,'] range')
1001  format(a,': atom',i9,' is a neighbor of atom',i9,' but',
     -  ' the neighborhood is not reciprocal')
1002  format(i9,' N: ',(10i9))
1003  format(' Checking neighbor list for atom range [',i9,',',i9,']')
1004  format(' Number of grid neighbor list asymmetry fixes=',i9)
1005  format(' Redimension mask in checknnlist to ',i4,' or more and ',
     -  'recompile')
      end
      subroutine checkfixedats(isltmv,c,nslt,isave,dmax,istop,lab,iout)
c#    MMC routine 107/a lastmod: 11/15/05
      dimension  isltmv(#ST),c(3,#NA)
      character*(*) lab
      common /ianndata/ cia0(3,#NA)
      common /option/ iop(200),idebug(200)
      real*8 din,din2
      if (idebug(126) .eq. 0) return
      nerr=0
      if (isave .eq. 1) then
        do ia=1,nslt
          call trnsfr(cia0(1,ia),c(1,ia),3)
        end do
      else
        do ia=1,nslt
          if (isltmv(ia) .eq. 0) then
            call arrdistsd(cia0(1,ia),c(1,ia),din,din2)
            if (din .gt. dmax) then
              if (din .gt. dmax .and. dmax .gt. 0.0) nerr=nerr+1
              write (iout,1000)
     -          lab,ia,(cia0(k,ia),k=1,3),(c(k,ia),k=1,3),din
            end if
          end if
        end do
      end if
      if (nerr .gt. 0) write (iout,*) 'checkfixat nerr=',nerr
      if (nerr .gt. 0 .and. istop .gt. 0 .and. dmax .gt. 0.0) then
        write (iout,*) 'nerr,istop=',nerr,istop,' dmax=',dmax
        call datprt(-1)
      end if
      return
1000  format(1x,a,' itest=',i5,' c0=',3f10.5,' c=',3f10.5,' dev=',f9.3)
      end
      subroutine checksolvents(iout,nmolec,orient,c,crm,ixislt,rlcslv,
     -  cslvo,ianslv,nslv,ixrep3,nrep3,ic00,ic01,nmc,zmattol,nxerr,
     -  noerr,maxat,maxslt)
c#    MMC routine 107/b lstmod: 08/16/17
c*****Check orientation matrix vs coordinates
      dimension orient(3,3,nmolec),c(3,maxat),crm(3,nmolec),ixrep3(3),
     -  ixislt(maxslt),rlcslv(3,nslv),cslvo(3,nslv),ianslv(nslv)
      dimension ortt(3,3)
      common /option/ iop(200),idebug(200)
      noerr=0
      nxerr=0
      nxwrn=0
      linear=0
      if (idebug(130) .gt. 1)
     -  call distmatprint(rlcslv,nslv,iout,'SOLV(LOCL)',10)
      do im=2,nmolec
        call chkort(orient(1,1,im),im,noerr,iout,'solvent ',zmattol)
        call rot_trans(orient(1,1,im),rlcslv,crm(1,im),cslvo,nslv)
        devs=0.0
        devmax=0.0
        do ia=1,nslv
          dev=arrdist(cslvo(1,ia),c(1,ic00+im*nslv+ia))
          devs=devs+dev
          if (devmax .lt. dev) devmax=dev
          if (idebug(130) .gt. 0) write (iout,1000) im,ia,
     -      (c(k,ic00+im*nslv+ia),k=1,3),(cslvo(k,ia),k=1,3)
        end do
        if (idebug(130) .gt. 0) write (iout,1001) (crm(k,im),k=1,3)
        devs=devs/nslv
        if (devmax .gt. 0.1) then
          nxerr=nxerr+1
          write (iout,1061) ' ***** Discrepancy',' ',im,nmc,devmax,devs
        else if (devmax .gt. 0.01) then
          nxwrn=nxwrn+1
          if (nxwrn .le. 10 .or. iop(16) .gt. 1)
     -      write (iout,1061) ' ----- WARNING',' ',im,nmc,devmax,devs
        end if
        if (idebug(130) .gt. 1)
     -    call distmatprint(c(1,ic01+im*nslv),nslv,iout,'SOLV(GLOB)',10)
        devs=0.0
        devmax=0.0
        do ia=1,nslv
          do ja=ia+1,nslv
            devo=arrdist(rlcslv(1,ia),rlcslv(1,ja))
            devn=arrdist(c(1,ic00+im*nslv+ia),c(1,ic00+im*nslv+ja))
            ddev=abs(devo-devn)
            devs=devs+ddev
            if (devmax .lt. ddev) devmax=ddev
          end do
        end do
        devs=devs/(((nslv-1)*nslv)/2)
        if (devmax .gt. 0.1) then
          nxerr=nxerr+1
          write (iout,1061)
     -      ' ***** ERROR',' internal ',im,nmc,devmax,devs
          if (iop(26) .lt. 4) write (iout,1062)
        else if (devmax .gt. 0.01) then
          nxwrn=nxwrn+1
          if (nxwrn .le. 10 .or. iop(16) .gt. 1)
     -      write (iout,1061)
     -        ' ----- WARNING',' internal ',im,nmc,devmax,devs
        end if
        if (iop(26) .lt. 4) then
c         Standard water solvent
          call ortslv(c(1,ic01+im*nslv),ortt,ifail)
        else
c         General solvent
          call getort(c(1,ic01+im*nslv),crm(1,im),ianslv,rlcslv,
     -      nslv,ortt,(im-2+1),ixislt,-1,linear,0,0,ixrep3,nrep3,ifail,
     -      idebug(29),iout,nslv)
        end if
        if (linear .eq. 0) then
          devs=0.0
          do k=1,3
            do l=1,3
              devs=devs+abs(ortt(k,l)-orient(k,l,im))
            end do
          end do
          if (devs .gt. 0.001) then
            noerr=noerr+1
            write (iout,1029) im-1,nmc,devs
            write (iout,1042) ortt,((orient(k,l,im),k=1,3),l=1,3)
          end if
        end if
      end do
      return
1000  format(' CHECKSOLV im,ia=',2i4,' c=',3f10.5,' ctransf=',3f10.5)
1001  format(' CHECKSOLV crm=',3f10.5)
1061  format(1x,a,': the',a,'coordinates of solvent ',
     -  'molecule ',i4,' are inconsistent with the solvent definition,',
     -  /,7x,'Nmc=',i10,' maximum, average deviations=',2f9.3,' A')
1062  format(' You can use Simulaid to fix distorted waters via the ',
     -  'Edit menu')
1029  format(' ***** ERROR: the orientation matrix of solvent ',
     -  'molecule ',i6,' is inconsistent with the coordinate array,',
     -  /,7x,'Nmc=',i10,' deviation sum=',f9.4)
1042  format(' ortt=',9f10.5,/,' orie=',9f10.5)
      end
      subroutine checkhdist(c,n1,n2,iout,lab,llab,nostop,n)
c#    MMC routine 107/c lstmod: 10/19/20
      dimension c(3,n)
      character*(*) lab
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      nerr=0
      do ia=n1,n2
        if (nneigh(ia) .gt. 0) then
          do in=1,nneig(ia)
            ja=ineig(in,ia)
            if (ianslt(ja) .eq. 1) then
              d2=arrdist(c(1,ia),c(1,ja))
              if (d2 .gt. 2.0) then
                nerr=nerr+1
                write (iout,2000) lab(1:llab),ia,ja,sqrt(d2)
              end if
            end if
          end do
        end if
      end do
      if (nostop .eq. 0 .and. nerr .eq. 0) write (iout,*)
     -  lab(1:llab),' CHECKHDIST passed'
      if (nerr .gt. 0 .and. nostop .eq. 0) call datprt(-1)
      return
2000  format(' ***** ERROR: ',a,' D(',i6,' - ',i6,' (H)=',f9.4,
     -  ' > sqrt(2)')
      end
      subroutine distmatprint(c,n,iout,lab,llab)
c#    MMC routine 107/d lstmod: 09/01/06
      dimension c(3,n)
      character*(*) lab
      do ia=1,n
        write (iout,1000) lab(1:llab),ia,
     -    (sqrt(arrdist(c(1,ia),c(1,ja))),ja=1,n)
      end do
      return
1000  format(1x,a,' ia=',i4,' rij=',100f10.6)
      end
      subroutine rvsitest(r,rps,ns,n1,n,rri,iopphs,nfail0,nfail,iout,
     -  iverb,lab)
c#    MMC routine 108 lastmod: 01/23/07
      dimension r(n),rps(n),ns(n)
      character*(*) lab
c*****Check if the integerized distance array corresponds to the distance
c     (square) array
      if (iverb .gt. 0) write (iout,1001) lab
      nfail0=0
      do i=n1,n
        if (iopphs .eq. 0) then
          rpr=sqrt(rps(i))
          nn=int(sqrt(rps(i))*rri)+1
        else
          rpr=r(i)
          nn=int(r(i)*rri)+1
        end if
        if (nn .ne. ns(i)) then
          if (iabs(nn-ns(i)) .gt. 1) then
            write (iout,1000) ' ***** Discrepancy: ',
     -        lab,i,ns(i),' not',rpr,nn
            nfail0=nfail0+1
          else
            write (iout,1000) ' ----- WARNING: ',
     -        lab,i,ns(i),' not',rpr,nn
          end if
        else if (iverb .gt. 2) then
          write (iout,1000) ' ',lab,i,ns(i),' ',rpr,nn
        end if
      end do
      if (nfail0 .gt. 0) nfail=nfail+1
      return
1000  format(a,a,' Integer distance for is=',i6,' (',i4,') does',a,
     -  ' correspond to the distance (',f10.5,'), right value=',i4)
1001  format(' R vs integer dist test for ',a)
      end
      subroutine fixdev(iout,iopfix,noeng,noverl,nfsslt,nfslww,
     -  ksltmn,vsltgrx,nwwarn,nfail,ncor,tesi,frctot,trqtot,texslt,
     -  vrcslt,frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind,rcomiso,
     -  rijpso,rphs0iso,diamslv,ipxo,nslvds,nslvdsid,mvfst,ri,rri,
     -  gbuupd,gbuupt,etoto,cslto,nmc,devmax)
c#    MMC routine 109 lstmod: 11/14/21
c*****Try to restore the self-consistency of the data or stop
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1,gbuupd,gbuupt,etoto
      dimension ncor(#MO),tesi(#MO),frctot(3,#MO),
     -  trqtot(3,#MO),frcslt(3,#MO),trtslt(3,#MO),
     -  trvslt(3,#MO),texslt(#MO),vrcslt(3,#MO),
     -  tsind(3,#MO),rcomiso(#MO),rijpso(#MO),
     -  rphs0iso(#MS),ipxo(#MO),nslvds(#MO),nslvdsid(#MO),
     -  gbuupd(#MM),gbuupt(#TR),cslto(3,#ST)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /option/ iop(200),idebug(200)
      dimension rgd(3)
      real*8 esmslv,etoto_start
      etoto_start=etoto
      nx=nmc
      nfixatt=0
      devmax=0.0
      tortol0=tortol
      if ((iopfix .eq. 0 .or. iopfix .eq. 4) .and. nfail .gt. 0) then
        write (iout,1002)
        if (nmc .gt. 0) call disfin(nx,c,orient,crm,orientsltm,crm0)
        call datprt(1)
      else if (iopfix .eq. 2 .or. iopfix .eq. 3 .or. nfail .eq. 0) then
        if (nfail .gt. 0) nfixtry=nfixtry+1
100     nfixatt=nfixatt+1
        if (iop(58) .gt. 0) then
          if (iop(91) .gt. 0) then
            natfx0=0
            imf=1
            if (iop(30) .eq. 1 .or. iop(30) .eq. 2) imf=nstfm0+1
            do im=imf,nsttm
              if (moltused(im) .eq. 1)
     -          call findbdag(ifirstm(im),ilastm(im),rlcslt,bond,bond2,
     -            angle,cangle,bond13,bond12,angle13,cangle13,
     -            iprecursor,natfix(im)-natfx0,iroots(natfx0+1),
     -            idebug(22),inperr,iout,#ST)
              natfx0=natfix(im)
            end do
            call trnsfr(cangle0,cangle,nstta)
            call inittor(1,ntang,rlcslt,itangindx,iprecursor,nrot,
     -        irotlist,irotlinc,bond,bond2,angle,cangle,bond13,bond12,
     -        cangle13,bondf,bondproj,xfac13,xfac12,
     -        cangle40,bond420,idebug(23),iout,#TR,#ST)
          end if
          if (nfail .gt. 0) then
            tortol=180.0
          end if
          call regenerate(c,0,0,iout,nerr,devmax)
          if (nfail .gt. 0) tortol=tortol0
          call trnsfr(cslto,c,3*nstta)
        end if
        if (noeng .eq. 0) then
          call eism0(1,0,noverl,nfsslt,nfslww,ksltmn,ncor,
     -      tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -      tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -      nslvdsid,gbuupd,gbuupt,esmslv,c,crm,nmc)
          if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
            call initgrid(nmolec,1.,diamslv/2.0,1,vsltgrx,vol,
     -        c,crm,nmc,0,0,' ',1,0)
            if (iop(63) .gt. 0) then
              call iniprftab(iop(63),npfid,rpfid,apfid,stiffid,wpsidn,
     -          ri,inperr,iout)
              call iniprflim(idsvfst,nmolec,ipsid,#MO,'MO',limpsid,
     -          npfsid,iout,inperr)
              call iniprf(idsvfst,nmolec,wpsidn,nslvdsid,wpsid,wpsidsum,
     -          wpfpsid,wpsidmax,limpsid,npfsid,iop(79))
              call iniprflim(1,ngfree,ipsgd,#PP,'PP',limpsgd,
     -          npfsgd,iout,inperr)
c             Calculate integer distances for new grids
              do ig=1,ngfree
                indx=igfree(ig)
                call unpackijk(indx,ng1,ic,jc,kc)
                rgd(1)=e2gm(1)+ic*grid(1)
                rgd(2)=e2gm(2)+jc*grid(2)
                rgd(3)=e2gm(3)+kc*grid(3)
c               Obtain integer distance of this grid from PS center
                igfn(ig)=intgpsdis(iop(8),rgd,wpfidcen,rri,c,crm)
              end do
              call iniprf(1,ngfree,wpsidn,igfn,wpsgd,wpsgdsum,
     -          wpfpsgd,wpsidnmax,limpsgd,npfsgd,iop(79))
            end if
            if (iop(76) .gt. 0) call initinout(molinout,nmolinout,
     -        edgelinxyz,edgerinxyz,crm,2,nmolec)
          end if
        end if
        if (iop(79)  .gt. 0) call initinout(molinoutgr,nmolinoutgr,
     -    edgelgr,edgergr,crm,mvfst,nmolec)
        if (nfail .gt. 0) then
          write (iout,1000)
          if (noeng .eq. 0) then
            efac=0.0
            if (etoto_start*etoto .gt. 0.d0)
     -        efac=dmax1(etoto_start/etoto,etoto/etoto_start)
            write (iout,1005) etoto_start,etoto,efac
            if (efac .gt. 10.0) then
              nwwarn=nwwarn+1
              write (iout,1006)
            end if
          end if
          call selftest(2,iopfix,nfail,1,0,0)
          if (nfail .gt. 0) then
            if (nfixatt .eq. 1) then
              write (iout,1004)
              go to 100
            else if (iopfix .eq. 2 .or. idebug(176) .eq. 0) then
              write (iout,1001)
              nfixtry=nfixtry-1
              if (nmc .gt. 0)
     -          call disfin(nx,c,orient,crm,orientsltm,crm0)
              call datprt(-1)
            else
              write (iout,1007)
              nwwarn=nwwarn+1
            end if
          end if
        end if
      else if (iopfix .eq. 1 .and. nfail .gt. 0) then
        ndiffign=ndiffign+1
        nwwarn=nwwarn+1
        write (iout,1003)
      end if
      return
1000  format(' An attempt to fix was made by reinitializing calls')
1001  format(' ***** Run is stopped since attempt to fix failed')
1002  format(' ***** Run is stopped - use RCKP FIXD to fix',
     -  ' or RCKP IGND to continue anyway')
1003  format(' ===== STRONG WARNING: Discrepancy was ignored')
1004  format(' First pass at fixing failed - fix attempt is repeated')
1005  format(' Total energy before and after the fix=',2e15.6,' ratio=',
     -  e10.2)
1006  format(' ===== STRONG WARNING: discrepancy fix resulted in large',
     -  ' change in the total energy')
1007  format(' ===== STRONG WARNING: run is continuing despite failed ',
     -  'fix attempt')
      end
      subroutine testcode(key,cpl,iconfread,file,namlenf,filenames,
     -  namlens,dihang,ifirstm,ilastm,c,crm,crm0,orient,orientsltm,cic,
     -  nmc,ncnfpx,nslv,nsttm,nstta,ntang,nmolec,natoms,ic00,ic01,g0cpl,
     -  wcplus,molcnt,rlcslv,ianslv,icompopt,iout,ichkp,ichkpx,inperr,
     -  nwwarn)
c#    MMC routine 109/a lstmod: 01/08/09
      character*4 key
      dimension cpl(#WG),namlens(30),icompopt(40),
     -  dihang(#TR),ifirstm(#MM),ilastm(#MM),c(3,#NA),
     -  orient(3,3,#MO),crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),cic(3,27),molcnt(#MM),ianslv(#SV),rlcslv(3,#SV)
      real*8 wcplus(#WG)
      character*80 filenames(30)
      character*80 file
      real*8 dwcp,etotn,etoto,estscn
      common /option/ iop(200),idebug(200)
      dimension cc(3),orj(3,3),d(3),ct(3)
c-----Place to put extra calls (developpers' option)
      if (key .eq. 'CPLW') then
c       Check the coupling parameter weights
        call getint(ioptest,0,1,0)
        do k=1,#WG-1
          call cplweight(cpl(k),dwcp,iop(51))
          write (iout,9511) k,cpl(k),dwcp,wcplus(k)
          cpl1=cpl(k)+g0cpl/2.0
          call cplweight(cpl1,dwcp,iop(51))
          write (iout,9511) k,cpl1,dwcp
        end do
      else if (iconfread .eq. 0) then
        write (iout,2211) key
        inperr=inperr+1
      else
        ichkp0=ichkp
        if (ichkp .eq. 0) call fileopen(file,namlenf,filenames(14),
     -        namlens(14),14,0,99,1,0,1,iop(24),iversout,iout,ichkp,0)
        if (key .eq. 'FSLT' .or. key .eq. 'FSTT') then
c         Check the solute forces
          if (icompopt(5)*icompopt(6) .eq. 0) then
            write (iout,2208) 'FR','TS'
            inperr=inperr+1
          else
            call getint(nfrq,0,0,1)
            call getreal(dx,0,0.1)
          end if
          if (key .eq. 'FSTT' .and. ntang .eq. 0) then
            write (iout,2212)
            inperr=inperr+1
          else
            call checkfslt(c,crm,crm0,orient,orientsltm,dihang,
     -       iconfread,iop47read,iout,ichkp,ichkpx,ncnfpx,ntang,
C@TS     -        nstta,nmolec,nfrq,dx,
     -        key)
          end if
        else if (key .eq. 'FSLV') then
c         Check the solute forces
          call checkcompopt(icompopt(6),'TEST FSLV','FR',inperr,iout)
          if (iop(94) .eq. 4) then
            write (iout,2210)
          else
            call fileopen(file,namlenf,filenames(14),
     -        namlens(14),14,0,99,1,0,1,iop(24),iversout,iout,ichkp,0)
            call getint(nfrq,0,0,1)
            call getreal(dx,0,0.1)
            call getreal(dphi,0,0.1)
            call checkfslv(c,crm,crm0,orient,orientsltm,etotn,etoto,
     -        estscn,iconfread,iop47read,iout,ichkp,nmc,nslv,nstta,
     -        nmolec,nfrq,dx,dphi)
          end if
        else if (key .eq. 'PBCT') then
c         Do a PBC shift for test
          write (iout,*)' ic00,ic01,nslv=',ic00,ic01,nslv
          write (iout,*)' natoms,nmolec =',natoms,nmolec
          do k=1,3
            call getreal(cc(k),0,float(10*k))
          end do
c         Shift the system away from (0,0,0)
          do ia=1,natoms
            call arrsum(c(1,ia),c(1,ia),cc,3)
          end do
          write (iout,2118) cc
c         Now center the system back via the PBC routine
          nout=0
          do im=1,nsttm
            call trnsfr(cc,c(1,molcnt(im)),3)
            call pbcnd(cc(1),cc(2),cc(3),iop(5),iopt,riijj)
            if (iopt .ne. 1) then
              nout=nout+1
              if (iop(5) .ne. 2) then
                do ia=ifirstm(im),ilastm(im)
                  call arrsum(c(1,ia),c(1,ia),cic(1,iopt),3)
                end do
              end if
            end if
          end do
          write (iout,2119) nout,'solute',nsttm
          nout=0
          do is=2,nmolec
            call cofms(c(1,ic01+is*nslv),cc,ianslv,1,nslv,1,wx)
            call trnsfr(ct,cc,3)
            call trnsfr(d,cc,3)
            call pbcnd(cc(1),cc(2),cc(3),iop(5),iopt,riijj)
            if (iopt .ne. 1) then
              nout=nout+1
              if (iop(5) .ne. 2) then
                do ia=1,nslv
                  call arrsum(c(1,ic00+is*nslv+ia),
     -             c(1,ic00+is*nslv+ia),cic(1,iopt),3)
                end do
              else if (idebug(80) .gt. 2) then
c               This test is not applicable to HCP PBC
                call pbcnd(d(1),d(2),d(3),7,ioptcheck,riijj)
                if (iopt .ne. ioptcheck)
     -            write (iout,2222) is,iopt,ioptcheck,ct
                call pbcnd(cc(1),cc(2),cc(3),iop(5),ioptcheck,riijj)
                if (ioptcheck .gt. 1) write (iout,2223) is,ioptcheck,ct
                call hcp_trnsor(orient(1,1,is),orj,1,0.0,iopt)
                call rot_trans(orj,rlcslv,cc,c(1,ic01+is*nslv),nslv)
              end if
            end if
          end do
          write (iout,2119) nout,'solvent',(nmolec-1)
        else if (key .eq. 'EIJT') then
          diffmax=0.0
          do is=2,nmolec
            do js=2,is-1
              z1=crm(1,js)-crm(1,is)
              z2=crm(2,js)-crm(2,is)
              z3=crm(3,js)-crm(3,is)
              call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
              eij=eww(is,js,iopt,ccx,ccy,ccz,riijj,c,crm)
              z1=crm(1,is)-crm(1,js)
              z2=crm(2,is)-crm(2,js)
              z3=crm(3,is)-crm(3,js)
              call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
              eji=eww(js,is,iopt,ccx,ccy,ccz,riijj,c,crm)
              eij_eji=abs(eij-eji)
              eij_eji_sum=abs(eij+eji)
              if (eij_eji .gt. diffmax) diffmax=eij_eji
              if (eij_eji_sum .gt. 0.0) then
                reldev=eij_eji/eij_eji_sum
                if (reldev .gt. 0.01) then
                  write (iout,2220) 'ERROR',is,js,eij,eji
                  inperr=inperr+1
                else if (reldev .gt. 0.0001) then
                  write (iout,2220) 'WARNING',is,js,eij,eji
                end if
              end if
            end do
          end do
          write (iout,2221) diffmax
        end if
        if (ichkp0 .eq. 0) call fileclose(ichkp,1,iop(24),iout)
      end if
      write (iout,2140)
      nwwarn=nwwarn+1
      return
2118  format(' The system has been shifted by ',3f10.5,
     -  ' A before recentering')
2119  format(i6,1x,a,' molecules were reset (out of ',i5,')')
2140  format(' ===== STRONG WARNING: system after TEST calculations ',
     -  'may be corrupted - it is better to do a fresh start')
2208  format(' ***** ERROR: solute force check requires both the lines',
     -  ' with C@',a2,' and C@',a2)
2210  format(' ***** ERROR: TEST FSLV is incompatible with SLFT STWD')
2211  format(' ***** ERROR: TEST ',a4,' requires a configuration to ',
     -  'have been read')
2212  format(' ***** ERROR: TEST FSTT requires torsion angle ',
     -  'definition (key TORD)')
2220  format(1x,a,' E(i,j)=',e15.8,' E(j,i)=',e15.8,' i,j=',2i7)
2221  format(' Maximum difference between E(i,j) and E(j,i)=',e10.3)
2222  format(' PBC error cell #:',i3,' geneneral algorithm cell #:',i3,
     -  ' c=',3f10.5)
2223  format(' PBC error - After reset, atom is still outside (cell #:',
     -  i3,' original position:',3f10.5)
9511  format(i4,' cpl=',f7.3,' ausw=',e12.5,' wcpl=',e12.5)
      end
      subroutine eism0(iold,ivch,noverl,nfsslt,nfslww,ksltmn,ncor,
     -  tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -  tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -  nslvdsid,gbuupd,gbuupt,esmslv,c,crm,nmc)
c#    MMC routine 110 lstmod: 07/09/09
c*****Compute the energy and forces of a configuration from scratch
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1,gbuupd,gbuupt,
     -  esmslv
      dimension ncor(#MO),tesi(#MO),frctot(3,#MO),
     -  trqtot(3,#MO),frcslt(3,#MO),trtslt(3,#MO),
     -  trvslt(3,#MO),texslt(#MO),vrcslt(3,#MO),
     -  tsind(3,#MO),rcomiso(#MO),rijpso(#MO),rphs0iso(#MS),
     -  ipxo(#MO),nslvds(#MO),nslvdsid(#MO),gbuupd(#MM),
     -  gbuupt(#TR),c(3,#NA),crm(3,#MO)
C@D1      common /eijtest/ eij(216,216)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 efieldst0,efieldmst
      common /fieldenergy/ efieldst0,efieldmst(#MM),
     -  efieldsv(#MO),esltfldo(#ST),esltfldn(#ST)
      real*8 emolstsm,emolsvsm,emolim
      common /specenergy/ emolsvsm(#MO),emolstsm(#MM),emolim
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
CJJ   variables
      real*8 setpoint,gain_n,gain_den,integraltime,oldpv,controlerror,
     -  dbetadt,dpvdt
      common /control/ setpoint,gain_n,gain_den,integraltime,oldpv,
     -  controlerror,dbetadt,dpvdt
      real*8 rnsumprev,uavcorprev,delndelbsum
      common /tuneb/ rnsumprev(2),uavcorprev,delndelbsum,nitconv,
     -  nunphys,nmctunskip,nmctunave,nmclastch,ntune,nmccorprev,
     -  ndelndelbsum,inorout,targetden,targetn,tolden,toln,delndelb0,
     -  rnaviprev,baprev,chabmax,pv
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      real*8 esm,esmg,esmgi,esltsc,esmx,epmf,es14,estor,efield,
     -  esmol,econstr,ex,x
      data econstr /0.d0/
c     texn(i) is e(isolv,i) after the move of the isolv-th molec.
c     texo(i) is e(isolv,i) before the move of the isolv-th molec.
c     tesi(i) is the total binding eng of the i-th molec before the move
c     frcn(k,i),frco(k,i),frctot(k,i) are the analogous
c     for the k-th component of the force on molec i by isolv,
c     trqn(k,i),trqo(k,i),trqtot(k,i) are analogous.
c     esm: total energy; esltsc: slt energy with inscribed sph sc
c     the computation of the virial sum is analogous to that of the engy
c     virc: (i,j) contribution <--> eww(i,j)
c     virial: sum(i<j) virc    <--> etoto
c     virscn: sum(i.ne.is) virc<--> tesiis
c     virsco: sum(i.ne.is) virc<--> tesi(isolv) (that is, before move)
c     vsltsm: slt virial sum accum.  <--> uslt (not exact ensemble avg)
c     vircsm: accumulator for virial <--> usum
c     to avoid recalculating solute-solvent energies, further arrays usd
c     texslt(i) is e(1,i) for the last accepted conf.
c     frcslt holds the force contributions on the solvent by the solute
c     trtslt holds the torque contributions on the solute
c     trvslt holds the torque contributions of solute on the solvents
c     trqnis holds the newly computed torque contributions on mol. isolv
c     vrcslt: solute contributions to virial sum  <--> texslt
c     vrsltn: newly computed solute virial contributions <--> texn
c     it is assumed that the pair-energy functions put the forces
c     exerted by molecule j on the atoms of molecule i into fcisl*.
c     fcjsl* should contain the analogous forces on the atoms of j.
c     the value of virc also has to be computed in the pair-energy
c     functions.
c     fcisl* and fcjsl* are also used to compute the torque exerted on
c     molecule i by molecule j, stored in trixyz, and the analogous
c     quantity trjxyz.
c     rijnis is the COM-COM solute-solvent distance for the solvent moved
c     (after the move), rcomiso(i) is the same distance for solvent i and
c     rcomisn contains all the new distances (when the solute was moved)
c     rijpsis is the solute-solvent dist. of the solvent moved, used for p.s.
c     rijpso, rijpsn are the solute-solvent distances used for pref. sampl.
c     nis(i) is the (integerized) distance of molecule i from the molec moved
c     after the move
c     niso(i) is the same as nis(i), but before the move
c     nslvds(i) is the distance of molecule i from the solute, before the move
      esmslv=0.d0
      esltsc=0.d0
      epmf=0.d0
      do i=1,nmolec
        ncor(i)=1
        texslt(i)=0.0
        do k=1,3
          tsindn(k,i)=0.0
        end do
        tesi(i)=0.d0
      end do
      tss12=0.d0
      tss6=0.d0
      tss1=0.d0
      ncor(1)=ncor(1)-ksltmn
      do k=1,3
        virial(k)=0.d0
        vsltsm(k)=0.d0
        do i=1,nmolec
          frcslt(k,i)=0.0
          trtslt(k,i)=0.0
          trvslt(k,i)=0.0
          frctot(k,i)=0.d0
          trqtot(k,i)=0.d0
        end do
      end do
C@DMC@FR        call zeroit(vrsltn,nmolec*3)
C@DMC@FR        call zeroit(frcn,nmolec*3)
C@DMC@FR        call zeroit(trqn,nmolec*3)
c     mapbitv(#VW,i) : neighbourhood bits of molec i: on=potential neighbour,
c                     off = not neighbour for sure
C@NN      do j=1,nmolmp
C@NN        do i=1,nmolec
C@NN          mapbitv(j,i)=iallon
C@NN        end do
C@NN      end do
      efield=0.d0
      if (iop(67) .gt. 0) then
c       efieldmst(im), efieldsv(im): the field-energy contribution of
c       solute and solvent molecules im, resp.
        do ia=1,nstta
          if (isltmv(ia) .gt. 0) then
            call esltfield(c,ixislt,ia,ia,x,esltfldo,iop(67),inperr,
     -        iout,#ST)
            efield=efield+x
          end if
        end do
        if (iop(57) .gt. 0) then
          do im=1,nsttm
            call ixsum(esltfldo,ixislt,ifirstm(im),ilastm(im),
     -        nstta,efieldmst(im))
          end do
        end if
        efieldst0=efield
        do im=2,nmolec
          call eslvfield(c(1,ic01+im*nslv),nslv,efieldsv(im))
          efield=efield+efieldsv(im)
        end do
        if (iold .eq. 1) then
          efieldo=efield
        else
          efieldn=efield
        end if
      end if
      esmol=0.d0
      if (iop(108) .gt. 0) then
c       Solute-solute molec-dependent terms, emolstsm is the analog of tesi
        do im=1,nsttm
          emolstsm(im)=0.d0
        end do
        do im=2,nsttm
          do jm=1,im-1
            call esltmolec(c,im,jm,ex)
            emolstsm(im)=emolstsm(im)+ex
            emolstsm(jm)=emolstsm(jm)+ex
            esmol=esmol+ex
          end do
        end do
        if (iold .eq. 1) then
          esmolo=esmol
        else
          esmoln=esmol
        end if
c       Solvent-other molec dependent terms
        do im=1,nmolec
          emolsvsm(im)=0.d0
        end do
      end if
      if (iop(80) .gt. 0) then
        call initinout(molinout,nmolinout,edgelinxyz,edgerinxyz,crm,
     -    2,nmolec)
        if (nmc .eq. 0) then
          rnsumprev(1)=0.d0
          rnsumprev(2)=0.d0
          nmccorprev=0
          nmclastch=0
        end if
      end if
      if (iop(79)  .gt. 0) call initinout(molinoutgr,nmolinoutgr,
     -  edgelgr,edgergr,crm,mvfst,nmolec)
      rcomiso(1)=0.0
      noverl=0
C@DM      nmolecdo=nmolec
      do is=2,nmolec
C@ND        nmolecdo=is
        call engcha(esmx,esmslv,estscn,is,tesi,c,crm,nmolecdo)
C@D1        call eijtst(eij,216,nmolec,is,texn,tesi,1)
        rcomiso(is)=rijnis
        rijpso(is)=rijpsis
        ipxo(is)=ipxis
        if (iop(92) .gt. 0) rphs0iso(is)=rphs0is
        if (rijnis .lt. rinscs) esltsc=esltsc+texn(1)
        esmslv=esmx
        tesi(is)=tesiis
C@FR        do k=1,3
C@FR          frctot(k,1)=frctot(k,1)+frcn(k,1)
C@FR          trqtot(k,1)=trqtot(k,1)+trqn(k,1)
C@FR          frctot(k,is)=frci(k)
C@FR          trqtot(k,is)=trqi(k)
C@FR          frcslt(k,is)=-frcn(k,1)
C@FR          trvslt(k,is)=trqnis(k,1)
C@FRC@TS           trtslt(k,is)=trqn(k,1)
C@FR          vrcslt(k,is)=vrsltn(k,is)
C@FR          virial(k)=virial(k)+virscn(k)
C@FR          vsltsm(k)=vsltsm(k)+vrcslt(k,is)
C@FR        end do
C@NDc       Add the contributions of the second half
C@ND        do im=2,is-1
C@ND          tesi(im)=tesi(im)+texn(im)
C@NDC@FR          do k=1,3
C@NDC@FR            frctot(k,im)=frctot(k,im)+frcn(k,im)
C@NDC@FR            trqtot(k,im)=trqtot(k,im)+trqn(k,im)
C@NDC@FR            vrcslt(k,im)=vrcslt(k,im)+vrsltn(k,im)
C@NDC@FR          end do
C@ND        end do
        tesi(1)=tesi(1)+texn(1)
        texslt(is)=texn(1)
        nslvds(is)=nis(1)
        nslvdsid(is)=idistid
        if (nis(1) .lt. nfsslt) ncor(1)=ncor(1)+1
        irdel=0
        if (iop(21) .eq. 1 .or. iop(21) .eq. 2) irdel=1
c       C@TE lines are code for an earlier parallelization - most of it
c       could be reused for MPI - to be done later
C@NNC@TE        isw=(is-1)/nbits+1
C@NNC@TE        isb=is-(isw-1)*nbits
C@DM        do i=iflslv(1,myrank1),iflslv(2,myrank1)
C@ND        do i=2,nmolecdo
C@DM          if (i .eq. is) then
C@DM           if (iop(21) .eq. 1 .or. iop(21) .eq. 2) irdel=2
C@DM          else
C@NNc           Update neighbour table
C@NN            if (riijjv(i-irdel) .gt. rccmp2) then
C@NNC@NLC@TE              mapbitv(isw,i)=mapbitv(isw,i) .and. ibitof(isb)
C@NNC@NAC@TE              mapbitv(isw,i)=ibclr(mapbitv(isw,i),isb-1)
C@NNC@ND              isw=(i-1)/nbits+1
C@NNC@ND              isb=i-(isw-1)*nbits
C@NNC@NLC@ND              mapbitv(isw,is)=mapbitv(isw,is) .and. ibitof(isb)
C@NNC@NAC@ND              mapbitv(isw,is)=ibclr(mapbitv(isw,is),isb-1)
C@NNC@ND              jsw=(is-1)/nbits+1
C@NNC@ND              jsb=is-(jsw-1)*nbits
C@NNC@NLC@ND              mapbitv(jsw,i)=mapbitv(jsw,i) .and. ibitof(jsb)
C@NNC@NAC@ND              mapbitv(jsw,i)=ibclr(mapbitv(jsw,i),jsb-1)
C@NN            end if
            if (nis(i) .lt. nfslww) then
              ncor(is)=ncor(is)+1
              ncor(i)=ncor(i)+1
            end if
            if (riijjv(i-irdel) .le. ctslvs .and. i .le. is .and.
     -          texn(i) .ge. 1000.0) then
              noverl=noverl+1
              rr=sqrt(riijjv(i-irdel))
              if (iop(24) .gt. 1 .and. noverl .le. 50)
     -          write (iout,1000) i,is,rr,texn(i)
            end if
C@DM          end if
        end do
C@DMc        if (iop(21) .eq. 3) then
C@DMc          call MPI_Allreduce(ncor(is),ncoris,1,
C@DMc     -      MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DMc            ncor(is)=ncoris-NUMNOD+1
C@DMc          if (iostat1 .gt. 0) write (iout,*)
C@DMc     -       'EISM0 Reduce ncor ERRORcode=',iostat1,' MYRANK=',MYRANK
C@DMc        end if
      end do
C@DMc      if (iop(21) .eq. 3) then
C@DMc        call MPI_Allreduce(noverl,noverlsum,1,
C@DMc     -    MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,iostat2)
C@DMc        noverl=noverlsum
C@DMc        if (MYRANK .eq. 0 .and. noverl .gt. 0) write (iout,1001) noverl
C@DMc        if (iostat2 .gt. 0) write (iout,*)
C@DMc     -       'EISM0 Reduce noverl ERRORcode=',iostat2,' MYRANK=',MYRANK
C@DMc      end if
C@DM      esmslv=tesi(1)+(esmslv-tesi(1))/2.0d0
C@DMC@FRc      do k=1,3
C@DMC@FRc        virial(k)=vsltsm(k)+(virial(k)-vsltsm(k))/2.0d0
C@DMC@FRc      end do
      ephso=0.d0
      if (iop(92) .gt. 0) then
        call initphs(mvfst,nmolec,nmc,ephso,rijpso,rijmax)
        if (nphsout .eq. 0 .and. nmc .eq. 0) then
          rphsn=rijmax-0.01
          write (iout,1002) rphs,rphsn
          rphs=rphsn
          if (rphs .le. rphsmin) then
            write (iout,1004)
            inperr=inperr+1
          end if
          nchng=nchng+1
          call initphs(mvfst,nmolec,nmc,ephso,rijpso,rijmax)
        end if
        igphsmax=(rijmax-rphsmin)/gphs+1
        if (rijmax .gt. rphsmax) then
          write (iout,1003) rijmax,rphsmax
          nwwarn=nwwarn+1
        end if
        if (igphsmax .gt. maxphsgrid) igphsmax=maxphsgrid
      end if
      if (ivch .eq. 0) then
        call eintra0(c,epmf,esmg,esmgi,es14,estor,ettnb01,einnb01,
     -    es1401,eslttor01,eintranb,em14,gbuupd,gbuupt)
      else
c       Volume change - intramolecular terms don't change
        call eintra0v(c,esmg,gbuupd,gbuupt)
        esmgi=einnbo
        es14=es14o
        estor=eslttoro
        efield=0.d0
        esmol=0.d0
      end if
      esm=esmslv+esmg+fcintra*(esmgi+es14+estor)+efield+esmol+ephso
      if (iop(117) .gt. 0) then
        call eslt_constraint(c,econstr)
        esm=esm+econstr
      end if
      call e123sum(tss12,tss6,tss1,tsindn,nmolec)
      call trnsfr(tsind,tsindn,nmol3)
      if (iop(30) .eq. 5 .or. iop(30) .eq. 6 .or. iop(30) .eq. 8) then
        call trnsfr(e01st,e01stn,2*nmolec)
        call e12sum(e0o,e1o,e01st,nmolec)
        call trnsfr(eone,eonen,nmol3)
        call trnsfr(etwo,etwon,nmol3)
        call e123sum(e0o12,e0o6,e0o1,eonen,nmolec)
        call e123sum(e1o12,e1o6,e1o1,etwon,nmolec)
      end if
      if (iold .eq. 1) then
        etoto=esm
        estsco=esltsc
        ettnbo=esmg
        einnbo=esmgi
        epmfo=epmf
        es14o=es14
        eslttoro=estor
        econstro=econstr
      else
        etotn=esm
        estscn=esltsc
        ettnbn=esmg
        einnbn=esmgi
        epmfn=epmf
        es14n=es14
        eslttorn=estor
        econstrn=econstr
      end if
      return
1000  format(' Overlap between solvent molecules',2i5,' : ',f6.3,' A',
     -  ' E=',e12.4,' kcal/mol')
C@DM1001  format(' Number of overlaps between solvent molecules',i9)
1002  format(' >>>>> OVERRIDE: initial primary shell radius (',f8.3,
     -  ') resulted in an empty hydration shell. ',/,
     -  '      Shell radius was reduced to ',f8.3,' A')
1003  format(' ===== STRONG WARNING: largest solute-solvent distance',
     -  f10.4,' exceeds shell radius limit (',f10.4,' A)')
1004  format(' ***** PROGRAM ERROR: shell radius was reduced below the',
     -  'minimum')
      end
      subroutine eintra0(c,epmf,gttnbe,etintranb,tor14e,tore,ettnb01,
     -  einnb01,es1401,eslttor01,eintranb,em14,gbuupd,gbuupt)
c#    MMC routine 111 lstmod: 06/18/12
c*****Initialize solute-solute and partial solute-solvent binding energy arrays
      real*8 gbuupd,gbuupt
      dimension gbuupd(#MM),gbuupt(#TR)
      real*8 epmf,gttnbe,etintranb,tor14e,tore,ettnb01,einnb01,
     -  es1401,eslttor01,eintranb,em14
      dimension c(3,#NA),ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),eintranb(#MM),em14(#MM),crmx(3)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /liga/ ligand_start_molecule,last_slt_mol_g
      real*8 gbegei,gbegei14,beggd(#MM),beggt(#TR),
     -  grsum12,gsuml0n,gsuml1n,gsumself,torsensumn,torsensumo
      dimension gsuml0n(3),gsuml1n(3)
c     Initialize solute-solute binding energy arrays
c     <-------- moved molecules ---------->
c                        <-- torsion molec range --->
c     Mol: 1         2        3       4          5
c     Tors:                   1                  2
c     At:                 k  i          j
c     |--------|---------|-------|---------|---------|
c     |        |aaaaaaaaa|aaaaaaa|aaaaaaaaa|         |
c     |    0   |aaaaaaaaa|aaaaaaa|aaaaaaaaa|         |
c     |        |aaaaaaaaa|aaaaaaa|aaaaaaaaa|         |
c     |        |aaaaaaaaa|aaaaaaa|aaaaaaaaa|         |
c     |--------|---------|-------|---------|---------|
c     |bbbbbbbb|         |   c   |         |         |
c     |bbbbbbbb|         |   c   |         |         |
c     |bbbbbbbb|    0    |   c   |         |         |
c     |bbbbbbbb|         |   c   |         |         |
c     |bbbbbbbb|         |   c   |         |         |
c     |--------|---------|-------|---------|---------|
c    k|ffffffff|fffffffff|       |fffffffff|fffffffff|
c     |        |         |       |      d  |         | t
c     |        |         |   0   |         |         |
c     |        |         |       |      d  |         | t
c     |        |         |       |      d  |         | t
c     |--------|---------|-------|---------|---------|
c     |eeeeeeee|eeeeeeeee|eeeeeee|         |eeeeeeeee|
c     |eeeeeeee|eeeeeeeee|eeeeeee|         |eeeeeeeee|
c     |eeeeeeee|eeeeeeeee|eeeeeee|    0    |eeeeeeeee|
c     |eeeeeeee|eeeeeeeee|eeeeeee|         |eeeeeeeee|
c     |eeeeeeee|eeeeeeeee|eeeeeee|         |eeeeeeeee|
c     |--------|---------|-------|---------|---------|
c     |        |         |       |         | gggggggg| t
c     |        |         |       |         |  ggggggg| t
c     |        |         |       |         |         |
c     |        |         |       |         |     gggg| t
c     |        |         |       |         |         |
c     |--------|---------|-------|---------|---------|
c
c     a: gsumd(1)
c     b: beggd(1) when mol 2 is moved --> gsumd(1,2)
c     c: beg(i) when mol 2 is moved   --> beg(i,2)
c     d: beg(j) when torsion group 1 is changed --> beg(j,1)
c     e: gbuupd(4)  gsumtot when mol 4 is moved --> gsumtot(4)
c     f: begr(k)
c     g: gsumself when torsion group 2 is changed --> gsumself(2)
c
      epmf=0.d0
      gttnbe=0.d0
      tor14e=0.d0
      tore=0.d0
      etintranb=0.d0
      do ig=1,#MM
        gbuupd(ig)=0.d0
        em14(ig)=0.d0
      end do
      do it=1,#TR
        gbuupt(it)=0.d0
        torsen(it)=0.d0
      end do
      do i=1,3
        eslttor01(i)=0.d0
        do k=1,3
          einnb01(i,k)=0.d0
          es1401(i,k)=0.d0
          ettnb01(i,k)=0.d0
        end do
      end do
      if (iuuon .eq. 0) return
c     Calculate all intermolecular energies first
      if (iop(30) .eq. 5 .or. iop(30) .eq. 6 .or.
     -    (iop(30) .ge. 1 .and. iop(30) .le. 3)) then
        im0=nstfm+1
        do im=1,2
c         Collect intramolecular sums without duplicates
          call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,
     -      nbits,#NL,ifirstm(im),ilastm(im),iclsltt,qslteps,esf14,
     -      vdwf14,gbegei,gbegei14,indexx,iuuon)
          if (idebug(11) .gt. 0) write (iout,7732) im,gbegei,gbegei14
          eintranb(im)=gbegei
          em14(im)=gbegei14
          etintranb=etintranb+gbegei
          icopy=im
          if (nsltcp(iop(30)+1) .eq. 2 .and. im .le. nstfm) icopy=im
          einnb01(icopy,1)=einnb01(icopy,1)+gbegei
          es1401(icopy,1)=es1401(icopy,1)+gbegei14
        end do
      else
        im0=molstf
      end if
      do im=im0,nsttm
c       TI solute will be taken care of by summing the non-TI contributions
c      Tom: Modified to exclude ligands
        call esltsltg(c,molstf,nsttm,ifirstm,ilastm,ifgrmolslt,
     -    ilgrmolslt,ifgrslt,ilgrslt,gbeold,gberold,1,istf,nstta,
     -    iclsltt,qslteps,im,0,0,grsum12,nsttia0,nsttia1,cpl1tix,
     -    cpl0tix,gsuml0n,gsuml1n,igrcnt,molcnt,crmx,iop(5),iop(65),
     -    indexx,ivopt,riijjv,cgs,cutuus,iop(127))
C@D4        if (idebug(110) .eq. 0)
C@D4     -    call checkeijmol(1,nstta,ifirstm(im),ilastm(im),ixislt)
        call grpsum(gbeold,imolpd,imolpt,ifirstm,ilastm,
     -    ngrdmn,ngrdmx,iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,
     -    istf,nstta,beggd,beggt,gbeg)
        if (iop(57) .gt. 0) then
          nover=0
          do imm=ngrdmn,ngrdmx
            if (beggd(imm) .gt. 1000.0) then
              d=sqrt(arrdist(c(1,molcnt(im)),c(1,molcnt(imm))))
              write (iout,1000) im,imm,beggd(imm),
     -          (c(k,molcnt(im)),k=1,3),(c(k,molcnt(imm)),k=1,3),d
              nover=nover+1
            end if
          end do
        end if
        if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
          do k=1,3
            ettnb01(1,k)=ettnb01(1,k)+gsuml0n(k)
            ettnb01(2,k)=ettnb01(2,k)+gsuml1n(k)
          end do
        end if
        if (im .eq. impmf1 .and. imolcent2 .ne. 0)
     -    epmf=beggd(imolcent2)
        if (idebug(11) .gt. 0) write (iout,7730) im,gbeg
        if (idebug(11) .gt. 1) write (iout,7731) (gbeold(i),i=1,nstta)
        gbuupd(im)=gbeg
        ettnb01(3,1)=ettnb01(3,1)+gbeg
c       Collect intramolecular sums without duplicates
        call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,nbits,
     -    #NL,ifirstm(im),ilastm(im),iclsltt,qslteps,esf14,vdwf14,
     -    gbegei,gbegei14,indexx,iuuon)
        if (idebug(11) .gt. 0) write (iout,7732) im,gbegei,gbegei14
        eintranb(im)=gbegei
        em14(im)=gbegei14
        etintranb=etintranb+gbegei
        icopy=3
        if (nsltcp(iop(30)+1) .eq. 2 .and. im .le. nstfm) icopy=im
        einnb01(icopy,1)=einnb01(icopy,1)+gbegei
        es1401(icopy,1)=es1401(icopy,1)+gbegei14
      end do
      if (nsltcp(iop(30)+1) .eq. 2) then
        gttnbe=ettnb01(3,1)/2.d0
        do k=1,3
          gttnbe=gttnbe+
     -      (cpl1tix(k)*ettnb01(1,k)+cpl0tix(k)*ettnb01(2,k))/2.d0
        end do
      else
        gttnbe=ettnb01(3,1)/2.d0
        ettnb01(3,1)=ettnb01(3,1)/2.d0
      end if
      tor14e=es1401(1,1)+es1401(2,1)+es1401(3,1)
      if (idebug(11) .gt. 0) write (iout,5711)
     -  tor14e,ngrdmn,ngrdmx,(gbuupd(im),im=ngrdmn,ngrdmx)
      if (imolpt .gt. 0) then
c       Partial solute torsion - get the group contribution sums
        do itg=itgfrst,ntorgrp
          molmov=iamolslt(iquata(ifdhgrlst(itg),4))
          icopy=3
          if (nsltcp(iop(30)+1) .eq. 2 .and. molmov .le. nstfm)
     -      icopy=molmov
          molstftt=molstf
          if (iamolslt(iquata(ifdhgrlst(itg),2)) .lt. molstfti)
     -      molstftt=molstfti
          if (iftorgrp(itg) .le. iltorgrp(itg))
     -      call esltsltt(c,lsttorgrp,molstftt,nsttm,ifirstm,ilastm,
     -        ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,iftormovgrgr(itg),
     -        iltormovgrgr(itg),iftormovgra,iltormovgra,
     -        iftorgrp(itg),iltorgrp(itg),ilhbtorgrp(itg),mapbitu,
     -        #UW,#ST,nbits,istf,nstta,iclsltt,qslteps,molmov,
     -        nsttia0,nsttia1,cpl1tix,cpl0tix,gsuml0n,gsuml1n,igrslt,
     -        igrcnt,molcnt,crmpmf,gbeold,gberold,gsumself,iop(5),
     -        iop(65),0,indexx,ivopt,riijjv,cgs,cutuus,iop(127),#TA,
     -        #TL)
          call dsum(gbeold,istf,nstta,gbeg)
          if (idebug(11) .gt. 1)
     -      write (iout,7750) itg,(gbeold(i),i=1,nstta)
          gbuupt(itg)=gbeg
          call diheng(torsensumn,itg,torsensumo,torsen,torsen,iop(127))
          do it=ifdhgrlst(itg),ildhgrlst(itg)
            eslttor01(icopy)=eslttor01(icopy)+torsen(it)
          end do
        end do
        tore=eslttor01(1)+eslttor01(2)+eslttor01(3)
        if (idebug(11) .gt. 0) then
          write (iout,5811) tore,(gbuupt(itg),itg=1,ntorgrp)
        end if
      end if
      return
1000  format(' Overlap between mobile solute molecules',2i5,' E=',e10.3,
     -  ' kcal/mol cent1=',3f10.4,' cent2=',3f10.4,' d=',f10.4)
7730  format(' EINTRA0 im=',i4,' gbeg=',f12.5)
7731  format(' EINTRA0 gbeold=  ',/,(2x,10f13.5))
7732  format(' EINTRA0 im=',i4,' gbegei=',f12.5,' gbegei14=',f12.5)
5711  format(' EINTRA0 tor14e=',f11.5,' ngrdmn,x=',2i3,' gbuupd=',/,
     -  (10f13.5))
7750  format(' EINTRA0 itg=',i5,' gbe=',(10f13.5))
5811  format(' EINTRA0 tore=',f10.4,' gbuupt=',(10f11.5))
      end
      subroutine eintra0v(c,gttnbe,gbuupd,gbuupt)
c#    MMC routine 112 lstmod: 04/16/99
c*****Initialize solute-solute and partial solute-solvent binding energy arrays
c     for volume change moves
      real*8 gbuupd,gbuupt,gttnbe
      dimension gbuupd(#MM),gbuupt(#TR)
      dimension c(3,#NA),crmx(3)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      real*8 beggd(#MM),beggt(#TR),
     -  grsum12,gsuml0n,gsuml1n
      dimension gsuml0n(3),gsuml1n(3)
c     Initialize solute-solute binding energy arrays
      gttnbe=0.d0
      do ig=1,#MM
        gbuupd(ig)=0.d0
      end do
      do it=1,#TR
        gbuupt(it)=0.d0
      end do
      if (iuuon .eq. 0) return
c     Calculate all intermolecular energies
      do im=molstf,nsttm
        call esltsltg(c,molstf,nsttm,ifirstm,ilastm,ifgrmolslt,
     -    ilgrmolslt,ifgrslt,ilgrslt,gbeold,gberold,1,istf,nstta,
     -    iclsltt,qslteps,im,0,0,grsum12,nsttia0,nsttia1,cpl1tix,
     -    cpl0tix,gsuml0n,gsuml1n,igrcnt,molcnt,crmx,iop(5),iop(65),
     -    indexx,ivopt,riijjv,cgs,cutuus,iop(127))
        call grpsum(gbeold,imolpd,imolpt,ifirstm,ilastm,
     -    ngrdmn,ngrdmx,iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,
     -    istf,nstta,beggd,beggt,gbeg)
        if (idebug(11) .gt. 0) write (iout,7730) im,gbeg
        if (idebug(11) .gt. 1) write (iout,7731) (gbeold(i),i=1,nstta)
        gbuupd(im)=gbeg
        gttnbe=gttnbe+gbeg
        if (iop(58) .gt. 0) then
c         Sum differently gbeold to obtain gbuupt(it)
          do imm=molstf,nsttm
            do itg=nmtmn(imm),nmtmx(imm)
              do ia=iftorgrp(itg),iltorgrp(itg)
                gbuupt(itg)=gbuupt(itg)+gbeold(lsttorgrp(ia))
              end do
            end do
          end do
        end if
      end do
      gttnbe=gttnbe/2.d0
      if (idebug(11) .gt. 0) write (iout,5711)
     -  ngrdmn,ngrdmx,(gbuupd(im),im=ngrdmn,ngrdmx)
      if (imolpt .gt. 0) then
        if (idebug(11) .gt. 0) then
          write (iout,5811) (gbuupt(itg),itg=1,ntorgrp)
        end if
      end if
      return
7730  format(' EINTRA0V im=',i2,' gbeg=',f12.5)
7731  format(' EINTRA0V gbeold:',(10f11.5))
5711  format(' EINTRA0V ngrdmn,x=',2i3,' gbuupd=',(10f11.5))
5811  format(' EINTRA0V gbuupt=',(10f11.5))
      end
      subroutine stir(c,crmpmf,eijmin,disp,dispa,iout)
c#    MMC routine 113 lstmod: 04/21/04
c*****Check intermolecular and intramolecular energies of the solute and
c     add a random change if they exceed the threshold given
      dimension c(3,#NA),crmpmf(3)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 beggd(#MM),beggt(#TR),gsuml0n(3),gsuml1n(3),
     -  grsum12,gsumself
      dimension z(3),d(3),crmx(3)
c     Skip free energy solutes
      if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
        im0=nstfm+1
      else
        im0=molstf
      end if
      do im=im0,nsttm
c       Check intramolecular energies
        call esltsltg(c,molstf,nsttm,ifirstm,ilastm,ifgrmolslt,
     -    ilgrmolslt,ifgrslt,ilgrslt,gbeold,gberold,1,istf,nstta,
     -    iclsltt,qslteps,im,0,0,grsum12,nsttia0,nsttia1,cpl1tix,
     -    cpl0tix,gsuml0n,gsuml1n,igrcnt,molcnt,crmx,iop(5),iop(65),
     -    indexx,ivopt,riijjv,cgs,cutuus,iop(127))
        call grpsum(gbeold,imolpd,imolpt,ifirstm,ilastm,
     -    ngrdmn,ngrdmx,iftorgrp,iltorgrp,1,ntorgrp,lsttorgrp,
     -    istf,nstta,beggd,beggt,gbeg)
        do imm=molstf,im-1
          if (beggd(imm) .gt. eijmin) then
            dist=0.0
            do k=1,3
              z(k)=(c(k,molcnt(im))+c(k,molcnt(imm)))/2.0
              d(k)=c(k,molcnt(im))-c(k,molcnt(imm))
              dist=dist+d(k)**2
            end do
            if (dist .lt. 1.e-4) then
              call randpx(3,d)
              dist=d(1)**2+d(2)**2+d(3)**2
            end if
            dist=sqrt(dist)
            do k=1,3
              d(k)=0.5*disp*d(k)/dist
            end do
            do ia=ifirstm(im),ilastm(im)
              call arrsum(c(1,ia),c(1,ia),d,3)
            end do
            do ia=ifirstm(imm),ilastm(imm)
              call arrdiff(c(1,ia),c(1,ia),d,3)
            end do
            write (iout,1000) im,imm,beggd(imm),disp,
     -        (c(k,molcnt(im)),k=1,3),(c(k,molcnt(imm)),k=1,3)
          end if
        end do
      end do
      if (iop(58) .gt. 0) then
        do im=im0,nsttm
          itgf=itorgrp(ifirstt(im))
          itgl=itorgrp(ilastt(im))
          do itg=itgf,itgl
            call esltsltt(c,lsttorgrp,molstftt,nsttm,ifirstm,ilastm,
     -        ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,iftormovgrgr(itg),
     -        iltorgrgr,iftormovgra,iltormovgra,iftorgrp(itg),
     -        iltorgrp(itg),ilhbtorgrp(itg),mapbitu,#UW,#ST,
     -        nbits,istf,nstta,iclsltt,qslteps,im,nsttia0,nsttia1,
     -        cpl1tix,cpl0tix,gsuml0n,gsuml1n,igrslt,igrcnt,molcnt,
     -        crmpmf,gbenew,gbernew,gsumself,iop(5),iop(65),2,indexx,
     -        ivopt,riijjv,cgs,cutuus,iop(127),#TA,#TL)
            if (gsumself .gt. eijmin) then
              do it=ifdhgrlst(itg),ildhgrlst(itg)
                dihang(it)=dihang(it)+dispa
                if (dihang(it) .gt. pi) dihang(it)=dihang(it)-pi2
              end do
              call gentor(ifdhgrlst(itg),ildhgrlst(itg),dihang,c,
     -          itangindx,iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -          cosdela,bondf,bondproj,xfac13,xfac12,bond,idebug(25),
     -          iout,#TR,#ST)
              write (iout,1001) itg,gsumself,dispa*rdtodg
            end if
          end do
        end do
      end if
      return
1000  format(' Solute molecules ',2i6,' energy=',e12.5,' pulled apart',
     -  ' by ',f5.2,' A',/,' New molecule centers:',3f10.4,5x,3f10.4)
1001  format(' Torsion group ',i5,' energy=',e12.5,' has its angles',
     -  ' incremented by ',f6.2,' deg')
      end
      subroutine eism1(is,nmolecdo,c,crm)
c#    MMC routine 114 lstmod: 01/28/96
c*****Scalar version - calculate the energy of one molec.
      dimension c(3,#NA),crm(3,#MO)
      common /ecell/ cic(3,27),ncell
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      dimension crmis(3)
      isc0=ic01+is*nslv
      call trnsfr(crmis,crm(1,is),3)
C@NN      call readbitc(mapbitv,is,ivtm,1,nmolecdo,#VW,#MO,nbits)
      do im=2,nmolecdo
        if (im .lt. is) then
c         im<is loop
          riijjv(im)=rccmp2+1.0
          nis(im)=mxcslv
C@NN          if (ivtm(im) .gt. 0) then
            z1=crmis(1)-crm(1,im)
            z2=crmis(2)-crm(2,im)
            z3=crmis(3)-crm(3,im)
            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
            riijjv(im)=riijj
            nis(im)=int(sqrt(riijj)*rri)+1
            if (riijj .le. ctslvs) then
              x=eww(im,is,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
     -          riijj,c,crm)
              tesiis=tesiis+dble(x)
              texn(im)=x
C@FR              virc(1)=frixyz(1)*z1
C@FR              virc(2)=frixyz(2)*z2
C@FR              virc(3)=frixyz(3)*z3
C@FR              ic0=ic01+im*nslv
C@FR              if (iop(39) .gt. 1) then
C@FR                call torque(c(1,ic0),crm(1,im),fcislv,1,nslvsv,
C@FR     -            trixyz,im)
C@FR                call torque(c(1,isc0),crm(1,is),fcjslv,1,nslvsv,
C@FR     -            trjxyz,is)
C@FR              else
C@FR                call trqwij(c(1,ic0),c(1,isc0),crm(1,im),crm(1,is),
C@FR     -            nslvsv)
C@FR              end if
C@FR              do k=1,3
C@FR                trqn(k,im)=trixyz(k)
C@FR                trqnis(k,im)=trjxyz(k)
C@FR                frcn(k,im)=frixyz(k)
C@FR                frci(k)=frci(k)+frjxyz(k)
C@FR                trqi(k)=trqi(k)+trjxyz(k)
C@FR                virscn(k)=virscn(k)+virc(k)
C@FR              end do
            end if
C@NN          end if
        else if (im .gt. is) then
c         im>is loop
          riijjv(im)=rccmp2+1.0
          nis(im)=mxcslv
C@NN          if (ivtm(im) .gt. 0) then
            z1=crm(1,im)-crmis(1)
            z2=crm(2,im)-crmis(2)
            z3=crm(3,im)-crmis(3)
            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
            riijjv(im)=riijj
            nis(im)=int(sqrt(riijj)*rri)+1
            if (riijj .le. ctslvs) then
              x=eww(is,im,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
     -          riijj,c,crm)
              tesiis=tesiis+dble(x)
              texn(im)=x
C@FR              virc(1)=frixyz(1)*z1
C@FR              virc(2)=frixyz(2)*z2
C@FR              virc(3)=frixyz(3)*z3
C@FR              ic0=ic01+im*nslv
C@FR              if (iop(39) .gt. 1) then
C@FR                call torque(c(1,isc0),crm(1,is),fcislv,1,nslvsv,
C@FR     -            trixyz,is)
C@FR                call torque(c(1,ic0),crm(1,im),fcjslv,1,nslvsv,
C@FR     -            trjxyz,im)
C@FR              else
C@FR                call trqwij(c(1,isc0),c(1,ic0),crm(1,is),crm(1,im),
C@FR     -            nslvsv)
C@FR              end if
C@FR              do k=1,3
C@FR                trqn(k,im)=trjxyz(k)
C@FR                trqnis(k,im)=trixyz(k)
C@FR                frcn(k,im)=frjxyz(k)
C@FR                frci(k)=frci(k)+frixyz(k)
C@FR                trqi(k)=trqi(k)+trixyz(k)
C@FR                virscn(k)=virscn(k)+virc(k)
C@FR              end do
            end if
          end if
C@NN        end if
      end do
      return
      end
C@DM      subroutine mpi_eism1(is,c,crm)
C@DMc#    MMC routine 115 lstmod: 07/24/11
C@DMc*****MPI (parallel) version - calculate the energy of one molec.
C@DM      dimension c(3,#NA),crm(3,#MO)
C@DM      common /ecell/ cic(3,27),ncell
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
C@DM      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
C@DM     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
C@DM     -  islvjrep(#ND),ianslv(#SV)
C@DM      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
C@DM     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
C@DM     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
C@DM     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
C@DM     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
C@DM     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
C@DM     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
C@DM     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
C@DM     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
C@DM     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
C@DM     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
C@DM      real*8 dnrww,dnrslt,dngwws
C@DM      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
C@DM     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
C@DM      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
C@DM      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
C@DM      real*8 tesiis
C@DM      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
C@DM     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
C@DM      real*8 frci,trqi,frcipo,trqipo
C@DM      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
C@DM     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
C@DM     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
C@DM      real*8 virial,virscn,virsco,vsltsm,vircsm
C@DM      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
C@DM     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
C@DM      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
C@DM      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
C@DM     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
C@DM     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
C@DM     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
C@DM     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
C@DM     -  numsolv,nsolvfix,nmolec,nmol3,natoms
C@DM      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
C@DM     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
C@DM     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
C@DM     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
C@DM      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
C@DMC@NL      logical ibiton,ibitof
C@DM      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
C@DM     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@DMC@NNC@NL      logical mapbitv
C@DMC@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@DMC@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
C@DMC@NN      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
C@DMC@NN     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
C@DMC@NN     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
C@DMC@NN     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
C@DM      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
C@DM     -  cci(3,#UV)
C@DM      common /option/ iop(200),idebug(200)
C@DM      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
C@DM     -  ntorcop
C@DM      dimension crmis(3)
C@DM      isc0=ic01+is*nslv
C@DM      tesiis=0.d0
C@DM      call trnsfr(crmis,crm(1,is),3)
C@DMC@NN      call readbitr(mapbitv,is,ivtm,iflslv(1,myrank1),
C@DMC@NN     - iflslv(2,myrank1),#VW,#MO,nbits)
C@DM      do im=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM        if (im .lt. is) then
C@DMc         im<is loop
C@DMC@NN          if (ivtm(im) .gt. 0) then
C@DM            z1=crmis(1)-crm(1,im)
C@DM            z2=crmis(2)-crm(2,im)
C@DM            z3=crmis(3)-crm(3,im)
C@DM            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
C@DM            riijjv(im)=riijj
C@DM            nis(im)=int(sqrt(riijj)*rri)+1
C@DM            if (riijj .le. ctslvs) then
C@DM              x=eww(im,is,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
C@DM     -          riijj,c,crm)
C@DM              tesiis=tesiis+dble(x)
C@DM              texn(im)=x
C@DMC@FRc              virc(1)=frixyz(1)*z1
C@DMC@FRc              virc(2)=frixyz(2)*z2
C@DMC@FRc              virc(3)=frixyz(3)*z3
C@DMC@FR              ic0=ic01+im*nslv
C@DMC@FR              if (iop(39) .gt. 1) then
C@DMC@FR                call torque(c(1,ic0),crm(1,im),fcislv,1,nslvsv,
C@DMC@FR     -            trixyz,im)
C@DMC@FR                call torque(c(1,isc0),crm(1,is),fcjslv,1,nslvsv,
C@DMC@FR     -            trjxyz,is)
C@DMC@FR              else
C@DMC@FR                call trqwij(c(1,ic0),c(1,isc0),crm(1,im),crm(1,is),
C@DMC@FR     -            nslvsv)
C@DMC@FR              end if
C@DMC@FR              do k=1,3
C@DMC@FR                trqn(k,im)=trixyz(k)
C@DMC@FR                trqnis(k,im)=trjxyz(k)
C@DMC@FR                frcn(k,im)=frixyz(k)
C@DMC@FR                frci(k)=frci(k)+frjxyz(k)
C@DMC@FR                trqi(k)=trqi(k)+trjxyz(k)
C@DMC@FRc                virscn(k)=virscn(k)+virc(k)
C@DMC@FR              end do
C@DM            else
C@DM              texn(im)=0.0
C@DMC@FR              do k=1,3
C@DMC@FR                frcn(k,im)=0.0
C@DMC@FR                trqn(k,im)=0.0
C@DMC@FR              end do
C@DM            end if
C@DMC@NN          else
C@DMC@NN            texn(im)=0.0
C@DMC@NN                do k=1,3
C@DMC@NN                  frcn(k,im)=0.0
C@DMC@NN                  trqn(k,im)=0.0
C@DMC@NN                end do
C@DMC@NN            nis(im)=mxcslv
C@DMC@NN            riijjv(im)=rccmp2+1.0
C@DMC@NN          end if
C@DM        else if (im .gt. is) then
C@DMc         im>is loop
C@DMC@NN          if (ivtm(im) .gt. 0) then
C@DM            z1=crm(1,im)-crmis(1)
C@DM            z2=crm(2,im)-crmis(2)
C@DM            z3=crm(3,im)-crmis(3)
C@DM            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
C@DM            riijjv(im)=riijj
C@DM            nis(im)=int(sqrt(riijj)*rri)+1
C@DM            if (riijj .le. ctslvs) then
C@DM              x=eww(is,im,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
C@DM     -          riijj,c,crm)
C@DM              tesiis=tesiis+dble(x)
C@DM              texn(im)=x
C@DMC@FRc              virc(1)=frixyz(1)*z1
C@DMC@FRc              virc(2)=frixyz(2)*z2
C@DMC@FRc              virc(3)=frixyz(3)*z3
C@DMC@FR              ic0=ic01+im*nslv
C@DMC@FR              if (iop(39) .gt. 1) then
C@DMC@FR                call torque(c(1,isc0),crm(1,is),fcislv,1,nslvsv,
C@DMC@FR     -            trixyz,is)
C@DMC@FR                call torque(c(1,ic0),crm(1,im),fcjslv,1,nslvsv,
C@DMC@FR     -            trjxyz,im)
C@DMC@FR              else
C@DMC@FR                call trqwij(c(1,isc0),c(1,ic0),crm(1,is),crm(1,im),
C@DMC@FR     -            nslvsv)
C@DMC@FR              end if
C@DMC@FR              do k=1,3
C@DMC@FR                trqn(k,im)=trjxyz(k)
C@DMC@FR                trqnis(k,im)=trixyz(k)
C@DMC@FR                frcn(k,im)=frjxyz(k)
C@DMC@FR                frci(k)=frci(k)+frixyz(k)
C@DMC@FR                trqi(k)=trqi(k)+trixyz(k)
C@DMC@FRc                virscn(k)=virscn(k)+virc(k)
C@DMC@FR              end do
C@DM            else
C@DM              texn(im)=0.0
C@DMC@FR              do k=1,3
C@DMC@FR                frcn(k,im)=0.0
C@DMC@FR                trqn(k,im)=0.0
C@DMC@FR              end do
C@DM            end if
C@DMC@NN          else
C@DMC@NN            texn(im)=0.0
C@DMC@NN              do k=1,3
C@DMC@NN                frcn(k,im)=0.0
C@DMC@NN                trqn(k,im)=0.0
C@DMC@NN              end do
C@DMC@NN            nis(im)=mxcslv
C@DMC@NN            riijjv(im)=rccmp2+1.0
C@DMC@NN          end if
C@DM        end if
C@DM      end do
C@DM      return
C@DM      end
      subroutine eisv1x(is,nmolecdo,c,crm)
c#    MMC routine 116 lstmod: 05/26/21
c*****32-bit vectorized version of eism1
c     Vectorized versions of eism1 and getegy were written by
c     B. Jayaram and M. Mezei
      dimension c(3,#NA),crm(3,#MO)
      common /ecell/ cic(3,27),ncell
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 uind12a,uind6a,uind1a
      common /sltaten/ uind12a(#ST),uind6a(#ST),uind1a(#ST)
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      real*8 texngd
      common /gatherd/ texngd(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /cutinr/ rwwina,rwwin2
C@FR      common /fciis/ fcii(3,#NA),fcis(3,#NA)
C@FR      real*8 frci1,trqi1,virscn1,frci2,trqi2,virscn2,frci3,trqi3,
C@FR     -  virscn3
      dimension crmis(3),cij(3,#SV)
c     function eww(ii,jj,iopt,riijj) MMC routine 051 is absorbed into
c     the loop over water molecules
c*****Calculates the interaction energy between two waters
c     the atomic locations in the article correspond to
c     H1=i+1, H2=i+2, H3=j+1, H4=j+2, O5=i, O6=j.
c     The assumed order of atomic centers is O,H,H,LP.
c     the distance convention used in this routine is
c     r13-(H1,H1), r14-(H1,H2), r23-(H2,H1), r24-(H2,H2),
c     r18-(H1,LP), r28-(H2,LP), r37-(LP,H1), r47-(LP,H2),
c     r16-(H1,Ox), r26-(H2,Ox), r35-(Ox,H1), r45-(Ox,H2),
c     r56-(Ox,Ox), r78-(LP,LP)
!*$* ASSERT PERMUTATION(indexx)
      isc0=ic01+is*nslv
      isv1=is-1
      isv2=is+1
      do k=1,3
        crmis(k)=crm(k,is)
      end do
C@FR      frci1=frci(1)
C@FR      frci2=frci(2)
C@FR      frci3=frci(3)
C@FR      trqi1=trqi(1)
C@FR      trqi2=trqi(2)
C@FR      trqi3=trqi(3)
C@FR      virscn1=virscn(1)
C@FR      virscn2=virscn(2)
C@FR      virscn3=virscn(3)
      cis1=c(1,isc0)
      cis2=c(2,isc0)
      cis3=c(3,isc0)
      cis4=c(1,isc0+1)
      cis5=c(2,isc0+1)
      cis6=c(3,isc0+1)
      cis7=c(1,isc0+2)
      cis8=c(2,isc0+2)
      cis9=c(3,isc0+2)
      cis10=c(1,isc0+iaq)
      cis11=c(2,isc0+iaq)
      cis12=c(3,isc0+iaq)
c     Expand the bitmap of molecule is into an integer array
C@NN      call readbitc(mapbitv,is,ivtm,1,nmolecdo,#VW,#MO,nbits)
c     Get the PBC calculations first
      ic=0
      il1=0
      if2=3
      if (isv1 .ge. 2) then
c       i<is loop
        do i=2,isv1
C@NN          if (ivtm(i) .gt. 0) then
            ic=ic+1
            indexx(ic)=i
C@NN          end if
        end do
        do im=1,ic
          i=indexx(im)
          zv(1,im)=crmis(1)-crm(1,i)
          zv(2,im)=crmis(2)-crm(2,i)
          zv(3,im)=crmis(3)-crm(3,i)
        end do
        il1=ic
        if2=ic+1
      end if
      if (isv2 .le. nmolec) then
c       Skip solvent moved in the bitmap array
        im0=ic+1
c       i>is loop
        do i=isv2,nmolecdo
C@NN          if (ivtm(i) .gt. 0) then
            ic=ic+1
            indexx(ic)=i
C@NN          end if
        end do
        do im=im0,ic
          i=indexx(im)
          zv(1,im)=crm(1,i)-crmis(1)
          zv(2,im)=crm(2,i)-crmis(2)
          zv(3,im)=crm(3,i)-crmis(3)
        end do
      end if
      il2=ic
      nvmolg=ic
      if (nvmolg .eq. 0) return
      call pbcvec(iop(5),1,nvmolg)
c     Now gather the ones within cutoff distance
      ic=0
      nnear=0
      isetlm=0
      do i=1,nvmolg
        ivtm(i)=int(sqrt(riijjv(i))*rri)+1
      end do
      do i=1,nvmolg
        inxi=indexx(i)
        nis(inxi)=ivtm(i)
        if (riijjv(i) .le. ctslvs) then
          if (riijjv(i) .le. rwwin2) then
c           Close contact found
            nnear=nnear+1
            ixnear(nnear)=inxi
          else
            ic=ic+1
            if (isetlm .eq. 0 .and. i .gt. il1) then
c             Set the new loop limits
              il1=ic-1
              if2=ic
              isetlm=1
            end if
            indexx(ic)=inxi
            indexn(ic)=i
          end if
        end if
      end do
      nvmolg=ic
      if (nvmolg .eq. 0) then
        if (nnear .gt. 0) go to 9100
        return
      end if
      do im=1,nvmolg
        i=indexn(im)
        ccii(1,im)=cci(1,i)
        ccii(2,im)=cci(2,i)
        ccii(3,im)=cci(3,i)
        zvv(1,im)=zv(1,i)
        zvv(2,im)=zv(2,i)
        zvv(3,im)=zv(3,i)
        ivopt(im)=ivopt(i)
      end do
      do im=1,nvmolg
        i=indexx(im)
        crmgs(1,im)=crm(1,i)
        crmgs(2,im)=crm(2,i)
        crmgs(3,im)=crm(3,i)
      end do
      do im=1,nvmolg
        do k=1,nslvsv
          i=ic00+indexx(im)*nslv+k
          ii=(im-1)*nslvsv+k
          cgs(1,ii)=c(1,i)
          cgs(2,ii)=c(2,i)
          cgs(3,ii)=c(3,i)
        end do
      end do
      if (isetlm .eq. 1) then
        il2=ic
      else
c       No second loop to set up
        il1=ic
        if2=il2+1
      end if
      if (iop(26) .lt. 4) then
c       i<is loop
        do i=1,il1
c---------TIP3P or TIP4P water (or variants)
          b1=cis1+ccii(1,i)
          b2=cis2+ccii(2,i)
          b3=cis3+ccii(3,i)
          b4=cis4+ccii(1,i)
          b5=cis5+ccii(2,i)
          b6=cis6+ccii(3,i)
          b7=cis7+ccii(1,i)
          b8=cis8+ccii(2,i)
          b9=cis9+ccii(3,i)
          b10=cis10+ccii(1,i)
          b11=cis11+ccii(2,i)
          b12=cis12+ccii(3,i)
          ic0=(i-1)*nslvsv+1
          a1=cgs(1,ic0)
          a2=cgs(2,ic0)
          a3=cgs(3,ic0)
          a4=cgs(1,ic0+1)
          a5=cgs(2,ic0+1)
          a6=cgs(3,ic0+1)
          a7=cgs(1,ic0+2)
          a8=cgs(2,ic0+2)
          a9=cgs(3,ic0+2)
          a10=cgs(1,ic0+iaq)
          a11=cgs(2,ic0+iaq)
          a12=cgs(3,ic0+iaq)
          rab2x=a1-b1
          rab2y=a2-b2
          rab2z=a3-b3
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@FR          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fcj11=rab2x*rab3
C@FR          fcj21=rab2y*rab3
C@FR          fcj31=rab2z*rab3
C@FR          fci11=-fcj11
C@FR          fci21=-fcj21
C@FR          fci31=-fcj31
          rabx=a10-b10
          raby=a11-b11
          rabz=a12-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          fci14=-rabx*rab3
C@FR          fci24=-raby*rab3
C@FR          fci34=-rabz*rab3
C@FR          fcj14=-fci14
C@FR          fcj24=-fci24
C@FR          fcj34=-fci34
          rabx=a4-b4
          raby=a5-b5
          rabz=a6-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fci12=-rabx*rab3
C@FR          fci22=-raby*rab3
C@FR          fci32=-rabz*rab3
C@FR          fcj12=-fci12
C@FR          fcj22=-fci22
C@FR          fcj32=-fci32
          rabx=a4-b7
          raby=a5-b8
          rabz=a6-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj13=+rabx*rab3
C@FR          fcj23=+raby*rab3
C@FR          fcj33=+rabz*rab3
          rabx=a7-b4
          raby=a8-b5
          rabz=a9-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fci13=-rabx*rab3
C@FR          fci23=-raby*rab3
C@FR          fci33=-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=a7-b7
          raby=a8-b8
          rabz=a9-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
          rabx=a4-b10
          raby=a5-b11
          rabz=a6-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=a7-b10
          raby=a8-b11
          rabz=a9-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=a10-b4
          raby=a11-b5
          rabz=a12-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=a10-b7
          raby=a11-b8
          rabz=a12-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
c         Calculate interaction energy.
          deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -      qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          texng(i)=deww
          tesiis=tesiis+dble(texng(i))
c         Extra parenthese added on advice of convex tech. support
C@FR          fi1v=((fci11+fci12)+fci13)+fci14
C@FR          fi2v=((fci21+fci22)+fci23)+fci24
C@FR          fi3v=((fci31+fci32)+fci33)+fci34
C@FR          fj1v=((fcj11+fcj12)+fcj13)+fcj14
C@FR          fj2v=((fcj21+fcj22)+fcj23)+fcj24
C@FR          fj3v=((fcj31+fcj32)+fcj33)+fcj34
c         End of eww subroutine
C@FR          vircv1=fi1v*zvv(1,i)
C@FR          vircv2=fi2v*zvv(2,i)
C@FR          vircv3=fi3v*zvv(3,i)
c         The following lines are in lieu of a call to trqwij
C@FR          crmx1=crmgs(1,i)
C@FR          crmy1=crmgs(2,i)
C@FR          crmz1=crmgs(3,i)
C@FR          crmx2=crmis(1)
C@FR          crmy2=crmis(2)
C@FR          crmz2=crmis(3)
C@FRc         Oxygen atom contribution
C@FR          drx1=a1-crmx1
C@FR          dry1=a2-crmy1
C@FR          drz1=a3-crmz1
C@FR          drx2=cis1-crmx2
C@FR          dry2=cis2-crmy2
C@FR          drz2=cis3-crmz2
C@FR          tixyz1=dry1*fci31-drz1*fci21
C@FR          tixyz2=drz1*fci11-drx1*fci31
C@FR          tixyz3=drx1*fci21-dry1*fci11
C@FR          tjxyz1=dry2*fcj31-drz2*fcj21
C@FR          tjxyz2=drz2*fcj11-drx2*fcj31
C@FR          tjxyz3=drx2*fcj21-dry2*fcj11
C@FRc         First hydrogen atom contribution
C@FR          drx1=a4-crmx1
C@FR          dry1=a5-crmy1
C@FR          drz1=a6-crmz1
C@FR          drx2=cis4-crmx2
C@FR          dry2=cis5-crmy2
C@FR          drz2=cis6-crmz2
C@FR          tixyz1=tixyz1+dry1*fci32-drz1*fci22
C@FR          tixyz2=tixyz2+drz1*fci12-drx1*fci32
C@FR          tixyz3=tixyz3+drx1*fci22-dry1*fci12
C@FR          tjxyz1=tjxyz1+dry2*fcj32-drz2*fcj22
C@FR          tjxyz2=tjxyz2+drz2*fcj12-drx2*fcj32
C@FR          tjxyz3=tjxyz3+drx2*fcj22-dry2*fcj12
C@FRc         Second hydrogen atom
C@FR          drx1=a7-crmx1
C@FR          dry1=a8-crmy1
C@FR          drz1=a9-crmz1
C@FR          drx2=cis7-crmx2
C@FR          dry2=cis8-crmy2
C@FR          drz2=cis9-crmz2
C@FR          tixyz1=tixyz1+dry1*fci33-drz1*fci23
C@FR          tixyz2=tixyz2+drz1*fci13-drx1*fci33
C@FR          tixyz3=tixyz3+drx1*fci23-dry1*fci13
C@FR          tjxyz1=tjxyz1+dry2*fcj33-drz2*fcj23
C@FR          tjxyz2=tjxyz2+drz2*fcj13-drx2*fcj33
C@FR          tjxyz3=tjxyz3+drx2*fcj23-dry2*fcj13
C@FRc         "Lone pair"
C@FR          drx1=a10-crmx1
C@FR          dry1=a11-crmy1
C@FR          drz1=a12-crmz1
C@FR          drx2=cis10-crmx2
C@FR          dry2=cis11-crmy2
C@FR          drz2=cis12-crmz2
C@FR          tixyz1=tixyz1+dry1*fci34-drz1*fci24
C@FR          tixyz2=tixyz2+drz1*fci14-drx1*fci34
C@FR          tixyz3=tixyz3+drx1*fci24-dry1*fci14
C@FR          tjxyz1=tjxyz1+dry2*fcj34-drz2*fcj24
C@FR          tjxyz2=tjxyz2+drz2*fcj14-drx2*fcj34
C@FR          tjxyz3=tjxyz3+drx2*fcj24-dry2*fcj14
C@FRc         End of trqwij routine
C@FR          trqng(1,i)=tixyz1
C@FR          trqng(2,i)=tixyz2
C@FR          trqng(3,i)=tixyz3
C@FR          trnisg(1,i)=tjxyz1
C@FR          trnisg(2,i)=tjxyz2
C@FR          trnisg(3,i)=tjxyz3
C@FR          frcng(1,i)=fi1v
C@FR          frcng(2,i)=fi2v
C@FR          frcng(3,i)=fi3v
C@FR          frci1=frci1+fj1v
C@FR          frci2=frci2+fj2v
C@FR          frci3=frci3+fj3v
C@FR          trqi1=trqi1+tjxyz1
C@FR          trqi2=trqi2+tjxyz2
C@FR          trqi3=trqi3+tjxyz3
C@FR          virscn1=virscn1+vircv1
C@FR          virscn2=virscn2+vircv2
C@FR          virscn3=virscn3+vircv3
        end do
c       i>is loop
        do i=if2,il2
c---------TIPS2/TIP4P/BF water
          ic0=(i-1)*nslvsv+1
          b1=cgs(1,ic0)+ccii(1,i)
          b2=cgs(2,ic0)+ccii(2,i)
          b3=cgs(3,ic0)+ccii(3,i)
          b4=cgs(1,ic0+1)+ccii(1,i)
          b5=cgs(2,ic0+1)+ccii(2,i)
          b6=cgs(3,ic0+1)+ccii(3,i)
          b7=cgs(1,ic0+2)+ccii(1,i)
          b8=cgs(2,ic0+2)+ccii(2,i)
          b9=cgs(3,ic0+2)+ccii(3,i)
          b10=cgs(1,ic0+iaq)+ccii(1,i)
          b11=cgs(2,ic0+iaq)+ccii(2,i)
          b12=cgs(3,ic0+iaq)+ccii(3,i)
          rab2x=cis1-b1
          rab2y=cis2-b2
          rab2z=cis3-b3
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@FR          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fcj11=rab2x*rab3
C@FR          fcj21=rab2y*rab3
C@FR          fcj31=rab2z*rab3
C@FR          fci11=-fcj11
C@FR          fci21=-fcj21
C@FR          fci31=-fcj31
          rabx=cis10-b10
          raby=cis11-b11
          rabz=cis12-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          fci14=-rabx*rab3
C@FR          fci24=-raby*rab3
C@FR          fci34=-rabz*rab3
C@FR          fcj14=-fci14
C@FR          fcj24=-fci24
C@FR          fcj34=-fci34
          rabx=cis4-b4
          raby=cis5-b5
          rabz=cis6-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fci12=-rabx*rab3
C@FR          fci22=-raby*rab3
C@FR          fci32=-rabz*rab3
C@FR          fcj12=-fci12
C@FR          fcj22=-fci22
C@FR          fcj32=-fci32
          rabx=cis4-b7
          raby=cis5-b8
          rabz=cis6-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj13=+rabx*rab3
C@FR          fcj23=+raby*rab3
C@FR          fcj33=+rabz*rab3
          rabx=cis7-b4
          raby=cis8-b5
          rabz=cis9-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fci13=-rabx*rab3
C@FR          fci23=-raby*rab3
C@FR          fci33=-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=cis7-b7
          raby=cis8-b8
          rabz=cis9-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
          rabx=cis4-b10
          raby=cis5-b11
          rabz=cis6-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=cis7-b10
          raby=cis8-b11
          rabz=cis9-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=cis10-b4
          raby=cis11-b5
          rabz=cis12-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=cis10-b7
          raby=cis11-b8
          rabz=cis12-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
c         Calculate interaction energy.
          deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -      qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          texng(i)=deww
          tesiis=tesiis+dble(texng(i))
C@FR          fi1v=((fci11+fci12)+fci13)+fci14
C@FR          fi2v=((fci21+fci22)+fci23)+fci24
C@FR          fi3v=((fci31+fci32)+fci33)+fci34
C@FR          fj1v=((fcj11+fcj12)+fcj13)+fcj14
C@FR          fj2v=((fcj21+fcj22)+fcj23)+fcj24
C@FR          fj3v=((fcj31+fcj32)+fcj33)+fcj34
c         End of eww routine
C@FR          vircv1=fi1v*zvv(1,i)
C@FR          vircv2=fi2v*zvv(2,i)
C@FR          vircv3=fi3v*zvv(3,i)
C@FRc         The following lines are in lieu of a call to trqwij
C@FR          b1=cgs(1,ic0)
C@FR          b2=cgs(2,ic0)
C@FR          b3=cgs(3,ic0)
C@FR          b4=cgs(1,ic0+1)
C@FR          b5=cgs(2,ic0+1)
C@FR          b6=cgs(3,ic0+1)
C@FR          b7=cgs(1,ic0+2)
C@FR          b8=cgs(2,ic0+2)
C@FR          b9=cgs(3,ic0+2)
C@FR          b10=cgs(1,ic0+iaq)
C@FR          b11=cgs(2,ic0+iaq)
C@FR          b12=cgs(3,ic0+iaq)
C@FR          crmx1=crmis(1)
C@FR          crmy1=crmis(2)
C@FR          crmz1=crmis(3)
C@FR          crmx2=crmgs(1,i)
C@FR          crmy2=crmgs(2,i)
C@FR          crmz2=crmgs(3,i)
C@FRc         Oxygen atom contribution
C@FR          drx1=cis1-crmx1
C@FR          dry1=cis2-crmy1
C@FR          drz1=cis3-crmz1
C@FR          drx2=b1-crmx2
C@FR          dry2=b2-crmy2
C@FR          drz2=b3-crmz2
C@FR          tixyz1=dry1*fci31-drz1*fci21
C@FR          tixyz2=drz1*fci11-drx1*fci31
C@FR          tixyz3=drx1*fci21-dry1*fci11
C@FR          tjxyz1=dry2*fcj31-drz2*fcj21
C@FR          tjxyz2=drz2*fcj11-drx2*fcj31
C@FR          tjxyz3=drx2*fcj21-dry2*fcj11
C@FRc         First hydrogen atom contribution
C@FR          drx1=cis4-crmx1
C@FR          dry1=cis5-crmy1
C@FR          drz1=cis6-crmz1
C@FR          drx2=b4-crmx2
C@FR          dry2=b5-crmy2
C@FR          drz2=b6-crmz2
C@FR          tixyz1=tixyz1+dry1*fci32-drz1*fci22
C@FR          tixyz2=tixyz2+drz1*fci12-drx1*fci32
C@FR          tixyz3=tixyz3+drx1*fci22-dry1*fci12
C@FR          tjxyz1=tjxyz1+dry2*fcj32-drz2*fcj22
C@FR          tjxyz2=tjxyz2+drz2*fcj12-drx2*fcj32
C@FR          tjxyz3=tjxyz3+drx2*fcj22-dry2*fcj12
C@FRc         Second hydrogen atom
C@FR          drx1=cis7-crmx1
C@FR          dry1=cis8-crmy1
C@FR          drz1=cis9-crmz1
C@FR          drx2=b7-crmx2
C@FR          dry2=b8-crmy2
C@FR          drz2=b9-crmz2
C@FR          tixyz1=tixyz1+dry1*fci33-drz1*fci23
C@FR          tixyz2=tixyz2+drz1*fci13-drx1*fci33
C@FR          tixyz3=tixyz3+drx1*fci23-dry1*fci13
C@FR          tjxyz1=tjxyz1+dry2*fcj33-drz2*fcj23
C@FR          tjxyz2=tjxyz2+drz2*fcj13-drx2*fcj33
C@FR          tjxyz3=tjxyz3+drx2*fcj23-dry2*fcj13
C@FRc         "Lone pair"
C@FR          drx1=cis10-crmx1
C@FR          dry1=cis11-crmy1
C@FR          drz1=cis12-crmz1
C@FR          drx2=b10-crmx2
C@FR          dry2=b11-crmy2
C@FR          drz2=b12-crmz2
C@FR          tixyz1=tixyz1+dry1*fci34-drz1*fci24
C@FR          tixyz2=tixyz2+drz1*fci14-drx1*fci34
C@FR          tixyz3=tixyz3+drx1*fci24-dry1*fci14
C@FR          tjxyz1=tjxyz1+dry2*fcj34-drz2*fcj24
C@FR          tjxyz2=tjxyz2+drz2*fcj14-drx2*fcj34
C@FR          tjxyz3=tjxyz3+drx2*fcj24-dry2*fcj14
C@FRc         End of trqwij routine
C@FR          trqng(1,i)=tjxyz1
C@FR          trqng(2,i)=tjxyz2
C@FR          trqng(3,i)=tjxyz3
C@FR          trnisg(1,i)=tixyz1
C@FR          trnisg(2,i)=tixyz2
C@FR          trnisg(3,i)=tixyz3
C@FR          frcng(1,i)=fj1v
C@FR          frcng(2,i)=fj2v
C@FR          frcng(3,i)=fj3v
C@FR          frci1=frci1+fi1v
C@FR          frci2=frci2+fi2v
C@FR          frci3=frci3+fi3v
C@FR          trqi1=trqi1+tixyz1
C@FR          trqi2=trqi2+tixyz2
C@FR          trqi3=trqi3+tixyz3
C@FR          virscn1=virscn1+vircv1
C@FR          virscn2=virscn2+vircv2
C@FR          virscn3=virscn3+vircv3
        end do
      else
c       General solvent
        do i=1,nvmolg
          texngd(i)=0.d0
C@FR          frcng(1,i)=0.0
C@FR          frcng(2,i)=0.0
C@FR          frcng(3,i)=0.0
C@FR          trqng(1,i)=0.0
C@FR          trqng(2,i)=0.0
C@FR          trqng(3,i)=0.0
C@FR          trnisg(1,i)=0.0
C@FR          trnisg(2,i)=0.0
C@FR          trnisg(3,i)=0.0
        end do
C@FR        call zeroit(fcii,3*nslv*nvmolg)
C@FR        call zeroit(fcis,3*nslv*nvmolg)
        jc0=ic00+is*nslv
c       i<is loop
        do i=1,il1
          ic0=(i-1)*nslv
          if (iop(5) .ne. 2) then
            do ja=1,nslv
              cij(1,ja)=c(1,jc0+ja)+ccii(1,i)
              cij(2,ja)=c(2,jc0+ja)+ccii(2,i)
              cij(3,ja)=c(3,jc0+ja)+ccii(3,i)
            end do
          else
            call hcp_rot_trans(crm(1,is),c(1,jc0+1),cij,1,nslv,
     -        ccii(1,i),ivopt(i),1)
          end if
          do ia=1,nslv
            do ja=1,nslv
              rxyz1v=cgs(1,ic0+ia)-cij(1,ja)
              rxyz2v=cgs(2,ic0+ia)-cij(2,ja)
              rxyz3v=cgs(3,ic0+ia)-cij(3,ja)
              rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
              rij=sqrt(rij2)
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
              er6=c6vv(ja,ia)/rij6
              er12=c12vv(ja,ia)/rij12
              qr=(qvv(ja,ia)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
              texngd(i)=texngd(i)+(dble(er12)-dble(er6)+dble(qr))
C@FR              abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR              fci1=-abcf*rxyz1v
C@FR              fci2=-abcf*rxyz2v
C@FR              fci3=-abcf*rxyz3v
C@FR              virscn1=virscn1+fci1*zvv(1,i)
C@FR              virscn2=virscn2+fci2*zvv(2,i)
C@FR              virscn3=virscn3+fci3*zvv(3,i)
C@FR              fcii(1,ic0+ia)=fcii(1,ic0+ia)+fci1
C@FR              fcii(2,ic0+ia)=fcii(2,ic0+ia)+fci2
C@FR              fcii(3,ic0+ia)=fcii(3,ic0+ia)+fci3
C@FR              fcis(1,ic0+ja)=fcis(1,ic0+ja)-fci1
C@FR              fcis(2,ic0+ja)=fcis(2,ic0+ja)-fci2
C@FR              fcis(3,ic0+ja)=fcis(3,ic0+ja)-fci3
C@FR              frcng(1,i)=frcng(1,i)+fci1
C@FR              frcng(2,i)=frcng(2,i)+fci2
C@FR              frcng(3,i)=frcng(3,i)+fci3
C@FR              frci1=frci1-fci1
C@FR              frci2=frci2-fci2
C@FR              frci3=frci3-fci3
            end do
          end do
        end do
c       i>is loop
        do i=if2,il2
          ic0=(i-1)*nslv
          if (iop(5) .ne. 2) then
            do ia=1,nslv
              cij(1,ia)=cgs(1,ic0+ia)+ccii(1,i)
              cij(2,ia)=cgs(2,ic0+ia)+ccii(2,i)
              cij(3,ia)=cgs(3,ic0+ia)+ccii(3,i)
            end do
          else
            call hcp_rot_trans(crmgs(1,i),cgs(1,ic0+1),cij,1,nslv,
     -        ccii(1,i),ivopt(i),1)
          end if
          do ia=1,nslv
            do ja=1,nslv
              rxyz1v=c(1,jc0+ja)-cij(1,ia)
              rxyz2v=c(2,jc0+ja)-cij(2,ia)
              rxyz3v=c(3,jc0+ja)-cij(3,ia)
              rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
              rij=sqrt(rij2)
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
              er6=c6vv(ja,ia)/rij6
              er12=c12vv(ja,ia)/rij12
              qr=qvv(ja,ia)/rij
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
              texngd(i)=texngd(i)+(dble(er12)-dble(er6)+dble(qr))
C@FR              abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR              fci1=-abcf*rxyz1v
C@FR              fci2=-abcf*rxyz2v
C@FR              fci3=-abcf*rxyz3v
C@FR              virscn1=virscn1+fci1*zvv(1,i)
C@FR              virscn2=virscn2+fci2*zvv(2,i)
C@FR              virscn3=virscn3+fci3*zvv(3,i)
C@FR              fcii(1,ic0+ia)=fcii(1,ic0+ia)-fci1
C@FR              fcii(2,ic0+ia)=fcii(2,ic0+ia)-fci2
C@FR              fcii(3,ic0+ia)=fcii(3,ic0+ia)-fci3
C@FR              fcis(1,ic0+ja)=fcis(1,ic0+ja)+fci1
C@FR              fcis(2,ic0+ja)=fcis(2,ic0+ja)+fci2
C@FR              fcis(3,ic0+ja)=fcis(3,ic0+ja)+fci3
C@FR              frcng(1,i)=frcng(1,i)-fci1
C@FR              frcng(2,i)=frcng(2,i)-fci2
C@FR              frcng(3,i)=frcng(3,i)-fci3
C@FR              frci1=frci1+fci1
C@FR              frci2=frci2+fci2
C@FR              frci3=frci3+fci3
            end do
          end do
        end do
        do i=1,nvmolg
          tesiis=tesiis+texngd(i)
          texng(i)=texngd(i)
C@FRc         Now calculate torques
C@FR          trqii1=0.0
C@FR          trqii2=0.0
C@FR          trqii3=0.0
C@FR          trqis1=0.0
C@FR          trqis2=0.0
C@FR          trqis3=0.0
C@FR          ic0=(i-1)*nslv
C@FR          do ia=1,nslv
C@FR            trqii1=trqii1+(cgs(2,ic0+ia)-crmgs(2,i))*fcii(3,ic0+ia)-
C@FR     -             (cgs(3,ic0+ia)-crmgs(3,i))*fcii(2,ic0+ia)
C@FR            trqii2=trqii2+(cgs(3,ic0+ia)-crmgs(3,i))*fcii(1,ic0+ia)-
C@FR     -             (cgs(1,ic0+ia)-crmgs(1,i))*fcii(3,ic0+ia)
C@FR            trqii3=trqii3+(cgs(1,ic0+ia)-crmgs(1,i))*fcii(2,ic0+ia)-
C@FR     -             (cgs(2,ic0+ia)-crmgs(2,i))*fcii(1,ic0+ia)
C@FR            trqis1=trqis1+(c(2,jc0+ia)-crmis(2))*fcis(3,ic0+ia)-
C@FR     -             (c(3,jc0+ia)-crmis(3))*fcis(2,ic0+ia)
C@FR            trqis2=trqis2+(c(3,jc0+ia)-crmis(3))*fcis(1,ic0+ia)-
C@FR     -             (c(1,jc0+ia)-crmis(1))*fcis(3,ic0+ia)
C@FR            trqis3=trqis3+(c(1,jc0+ia)-crmis(1))*fcis(2,ic0+ia)-
C@FR     -             (c(2,jc0+ia)-crmis(2))*fcis(1,ic0+ia)
C@FR          end do
C@FR          trqng(1,i)=trqii1
C@FR          trqng(2,i)=trqii2
C@FR          trqng(3,i)=trqii3
C@FR          trnisg(1,i)=trqis1
C@FR          trnisg(2,i)=trqis2
C@FR          trnisg(3,i)=trqis3
C@FR          trqi1=trqi1+trqis1
C@FR          trqi2=trqi2+trqis2
C@FR          trqi3=trqi3+trqis3
        end do
      end if
c     Scatter the results back to their proper place
      do i=1,nvmolg
        inxi=indexx(i)
        texn(inxi)=texng(i)
C@FR        frcn(1,inxi)=frcng(1,i)
C@FR        frcn(2,inxi)=frcng(2,i)
C@FR        frcn(3,inxi)=frcng(3,i)
C@FR        trqnis(1,inxi)=trnisg(1,i)
C@FR        trqnis(2,inxi)=trnisg(2,i)
C@FR        trqnis(3,inxi)=trnisg(3,i)
C@FR        trqn(1,inxi)=trqng(1,i)
C@FR        trqn(2,inxi)=trqng(2,i)
C@FR        trqn(3,inxi)=trqng(3,i)
      end do
9100  if (nnear .gt. 0) then
c       Take care of close contacts by calling the unvectorized routines
        do ii=1,nnear
          i=ixnear(ii)
          z1=crmis(1)-crm(1,i)
          z2=crmis(2)-crm(2,i)
          z3=crmis(3)-crm(3,i)
          call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
          x=eww(i,is,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
     -      riijj,c,crm)
          tesiis=tesiis+dble(x)
          texn(i)=x
C@FRc          virc(1)=frixyz(1)*z1
C@FRc          virc(2)=frixyz(2)*z2
C@FRc          virc(3)=frixyz(3)*z3
C@FR          ic0=ic01+i*nslv
C@FR          if (iop(39) .lt. 2) then
C@FR            call trqwij(c(1,ic0),c(1,isc0),crm(1,i),crm(1,is),nslvsv)
C@FR          else
C@FR            call torque(c(1,ic0),crm(1,i),fcislv,1,nslvsv,trixyz,i)
C@FR            call torque(c(1,isc0),crm(1,is),fcjslv,1,nslvsv,trjxyz,is)
C@FR          end if
C@FR          trqn(1,i)=trixyz(1)
C@FR          trqn(2,i)=trixyz(2)
C@FR          trqn(3,i)=trixyz(3)
C@FR          trqnis(1,i)=trjxyz(1)
C@FR          trqnis(2,i)=trjxyz(2)
C@FR          trqnis(3,i)=trjxyz(3)
C@FR          frcn(1,i)=frixyz(1)
C@FR          frcn(2,i)=frixyz(2)
C@FR          frcn(3,i)=frixyz(3)
C@FR          frci1=frci1+frjxyz(1)
C@FR          frci2=frci2+frjxyz(2)
C@FR          frci3=frci3+frjxyz(3)
C@FR          trqi1=trqi1+trjxyz(1)
C@FR          trqi2=trqi2+trjxyz(2)
C@FR          trqi3=trqi3+trjxyz(3)
C@FR          virscn1=virscn1+virc(1)
C@FR          virscn2=virscn2+virc(2)
C@FR          virscn3=virscn3+virc(3)
        end do
      end if
C@FR      frci(1)=frci1
C@FR      frci(2)=frci2
C@FR      frci(3)=frci3
C@FR      trqi(1)=trqi1
C@FR      trqi(2)=trqi2
C@FR      trqi(3)=trqi3
C@FR      virscn(1)=virscn1
C@FR      virscn(2)=virscn2
C@FR      virscn(3)=virscn3
      return
      end
      subroutine eisv1y(is,nmolecdo,c,crm)
c#    MMC routine 117 lstmod: 05/23/21
c*****Cray vectorized version of eism1
      dimension c(3,#NA),crm(3,#MO)
c     Vectorized versions of eism1 and getegy were written by
c     B. Jayaram and M. Mezei
c*****Update the energy and forces after the move of the is-th molecule
c     old value: esmx, new value:esm.
      common /ecell/ cic(3,27),ncell
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      real*8 texngd
      common /gatherd/ texngd(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
C@FR      common /fciis/ fcii(3,#NA),fcis(3,#NA)
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /cutinr/ rwwina,rwwin2
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      dimension crmis(3),cij(3,#SV)
      inclnn=0
C@NN      inclnn=1
c     function eww(ii,jj,iopt,riijj) MMC routine 051 is absorbed into
c     the loop over water molecules to calculate the interaction energy
c     between two waters. The atomic locations in the article correspond to
c     H1=i+1, H2=i+2, H3=j+1, H4=j+2, O5=i, O6=j.
c     The assumed order of atomic centers is O,H,H,LP.
c     the distance convention used in this routine is
c     r13-(H1,H1), r14-(H1,H2), r23-(H2,H1), r24-(H2,H2),
c     r18-(H1,LP), r28-(H2,LP), r37-(LP,H1), r47-(LP,H2),
c     r16-(H1,Ox), r26-(H2,Ox), r35-(Ox,H1), r45-(Ox,H2),
c     r56-(Ox,Ox), r78-(LP,LP)
      isc0=ic01+is*nslv
      do k=1,3
        crmis(k)=crm(k,is)
      end do
      cis1=c(1,isc0)
      cis2=c(2,isc0)
      cis3=c(3,isc0)
      cis4=c(1,isc0+1)
      cis5=c(2,isc0+1)
      cis6=c(3,isc0+1)
      cis7=c(1,isc0+2)
      cis8=c(2,isc0+2)
      cis9=c(3,isc0+2)
      cis10=c(1,isc0+iaq)
      cis11=c(2,isc0+iaq)
      cis12=c(3,isc0+iaq)
c     Expand the bitmap of molecule is into an integer array
C@NN      call readbitc(mapbitv,is,ivtm,1,nmolecdo,#VW,#MO,nbits)
C@NN      ivtm(is)=0
C@NNc     Get the PBC calculations first
C@NN      ic=0
C@NN      do i=2,nmolecdo
C@NN        if (ivtm(i) .gt. 0) then
C@NN          ic=ic+1
C@NN          indexx(ic)=i
C@NN        end if
C@NN      end do
C@NN      nvmolg=ic
C@NN      if (nvmolg .eq. 0) return
      if (inclnn .eq. 0) then
        nvmolg=nmolecdo-2
c       Set up indexx when nn alg is not used
        if (is .gt. 2) then
          is1=is-1
          do i=2,is1
            indexx(i-1)=i
          end do
        end if
        if (is .lt. nmolecdo) then
          is1=is+1
          do i=is1,nmolecdo
            indexx(i-2)=i
          end do
        end if
      end if
      do ic=1,nvmolg
        i=indexx(ic)
        zv(1,ic)=crmis(1)-crm(1,i)
        zv(2,ic)=crmis(2)-crm(2,i)
        zv(3,ic)=crmis(3)-crm(3,i)
      end do
      call pbcvec(iop(5),1,nvmolg)
c     Now collect the indices for the ones within cutoff distance
      ic=0
      do i=1,nvmolg
        ivtm(i)=int(sqrt(riijjv(i))*rri)+1
      end do
      nnear=0
      do i=1,nvmolg
        inxi=indexx(i)
        nis(inxi)=ivtm(i)
        if (riijjv(i) .le. ctslvs) then
          if (riijjv(i) .le. rwwin2) then
c           Close contact found
            nnear=nnear+1
            ixnear(nnear)=inxi
          else
            ic=ic+1
            indexx(ic)=inxi
            indexn(ic)=i
          end if
        end if
      end do
      nvmolg=ic
      if (nvmolg .eq. 0) then
        if (nnear .gt. 0) go to 9100
        return
      end if
c     Perform the actual gathering of the molecular info
      do im=1,nvmolg
        i=indexn(im)
        ccii(1,im)=cci(1,i)
        ccii(2,im)=cci(2,i)
        ccii(3,im)=cci(3,i)
        ivopt(im)=ivopt(i)
        zvv(1,im)=zv(1,i)
        zvv(2,im)=zv(2,i)
        zvv(3,im)=zv(3,i)
      end do
      do im=1,nvmolg
        i=indexx(im)
        crmgs(1,im)=crm(1,i)
        crmgs(2,im)=crm(2,i)
        crmgs(3,im)=crm(3,i)
      end do
      do k=1,nslvsv
        do im=1,nvmolg
          i=ic00+indexx(im)*nslv+k
          ii=(im-1)*nslvsv+k
          cgs(1,ii)=c(1,i)
          cgs(2,ii)=c(2,i)
          cgs(3,ii)=c(3,i)
        end do
      end do
      if (iop(26) .lt. 4) then
        do i=1,nvmolg
c---------TIP3P OR TIP4P water (or variants)
          b1=cis1+ccii(1,i)
          b2=cis2+ccii(2,i)
          b3=cis3+ccii(3,i)
          b4=cis4+ccii(1,i)
          b5=cis5+ccii(2,i)
          b6=cis6+ccii(3,i)
          b7=cis7+ccii(1,i)
          b8=cis8+ccii(2,i)
          b9=cis9+ccii(3,i)
          b10=cis10+ccii(1,i)
          b11=cis11+ccii(2,i)
          b12=cis12+ccii(3,i)
          ic0=(i-1)*nslvsv+1
          a1=cgs(1,ic0)
          a2=cgs(2,ic0)
          a3=cgs(3,ic0)
          a4=cgs(1,ic0+1)
          a5=cgs(2,ic0+1)
          a6=cgs(3,ic0+1)
          a7=cgs(1,ic0+2)
          a8=cgs(2,ic0+2)
          a9=cgs(3,ic0+2)
          a10=cgs(1,ic0+iaq)
          a11=cgs(2,ic0+iaq)
          a12=cgs(3,ic0+iaq)
          rab2x=a1-b1
          rab2y=a2-b2
          rab2z=a3-b3
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@FR          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fcj11=rab2x*rab3
C@FR          fcj21=rab2y*rab3
C@FR          fcj31=rab2z*rab3
C@FR          fci11=-fcj11
C@FR          fci21=-fcj21
C@FR          fci31=-fcj31
          rabx=a10-b10
          raby=a11-b11
          rabz=a12-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          fci14=-rabx*rab3
C@FR          fci24=-raby*rab3
C@FR          fci34=-rabz*rab3
C@FR          fcj14=-fci14
C@FR          fcj24=-fci24
C@FR          fcj34=-fci34
          rabx=a4-b4
          raby=a5-b5
          rabz=a6-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fci12=-rabx*rab3
C@FR          fci22=-raby*rab3
C@FR          fci32=-rabz*rab3
C@FR          fcj12=-fci12
C@FR          fcj22=-fci22
C@FR          fcj32=-fci32
          rabx=a4-b7
          raby=a5-b8
          rabz=a6-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj13=+rabx*rab3
C@FR          fcj23=+raby*rab3
C@FR          fcj33=+rabz*rab3
          rabx=a7-b4
          raby=a8-b5
          rabz=a9-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fci13=-rabx*rab3
C@FR          fci23=-raby*rab3
C@FR          fci33=-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=a7-b7
          raby=a8-b8
          rabz=a9-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
          rabx=a4-b10
          raby=a5-b11
          rabz=a6-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=a7-b10
          raby=a8-b11
          rabz=a9-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=a10-b4
          raby=a11-b5
          rabz=a12-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=a10-b7
          raby=a11-b8
          rabz=a12-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
c         Calculate interaction energy.
        deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -      qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          texng(i)=deww
          tesiis=tesiis+dble(texng(i))
C@FR          fi1v=fci11+fci12+fci13+fci14
C@FR          fi2v=fci21+fci22+fci23+fci24
C@FR          fi3v=fci31+fci32+fci33+fci34
C@FR          fj1v=fcj11+fcj12+fcj13+fcj14
C@FR          fj2v=fcj21+fcj22+fcj23+fcj24
C@FR          fj3v=fcj31+fcj32+fcj33+fcj34
c         End of eww subroutine
C@FR          vircv1=fi1v*zvv(1,i)
C@FR          vircv2=fi2v*zvv(2,i)
C@FR          vircv3=fi3v*zvv(3,i)
C@FRc         The following lines are in lieu of a call to trqwij
C@FR          crmx1=crmgs(1,i)
C@FR          crmy1=crmgs(2,i)
C@FR          crmz1=crmgs(3,i)
C@FR          crmx2=crmis(1)
C@FR          crmy2=crmis(2)
C@FR          crmz2=crmis(3)
C@FRc         Oxygen atom contribution
C@FR          drx1=a1-crmx1
C@FR          dry1=a2-crmy1
C@FR          drz1=a3-crmz1
C@FR          drx2=cis1-crmx2
C@FR          dry2=cis2-crmy2
C@FR          drz2=cis3-crmz2
C@FR          tixyz1=dry1*fci31-drz1*fci21
C@FR          tixyz2=drz1*fci11-drx1*fci31
C@FR          tixyz3=drx1*fci21-dry1*fci11
C@FR          tjxyz1=dry2*fcj31-drz2*fcj21
C@FR          tjxyz2=drz2*fcj11-drx2*fcj31
C@FR          tjxyz3=drx2*fcj21-dry2*fcj11
C@FRc         First hydrogen atom contribution
C@FR          drx1=a4-crmx1
C@FR          dry1=a5-crmy1
C@FR          drz1=a6-crmz1
C@FR          drx2=cis4-crmx2
C@FR          dry2=cis5-crmy2
C@FR          drz2=cis6-crmz2
C@FR          tixyz1=tixyz1+dry1*fci32-drz1*fci22
C@FR          tixyz2=tixyz2+drz1*fci12-drx1*fci32
C@FR          tixyz3=tixyz3+drx1*fci22-dry1*fci12
C@FR          tjxyz1=tjxyz1+dry2*fcj32-drz2*fcj22
C@FR          tjxyz2=tjxyz2+drz2*fcj12-drx2*fcj32
C@FR          tjxyz3=tjxyz3+drx2*fcj22-dry2*fcj12
C@FRc         Second hydrogen atom
C@FR          drx1=a7-crmx1
C@FR          dry1=a8-crmy1
C@FR          drz1=a9-crmz1
C@FR          drx2=cis7-crmx2
C@FR          dry2=cis8-crmy2
C@FR          drz2=cis9-crmz2
C@FR          tixyz1=tixyz1+dry1*fci33-drz1*fci23
C@FR          tixyz2=tixyz2+drz1*fci13-drx1*fci33
C@FR          tixyz3=tixyz3+drx1*fci23-dry1*fci13
C@FR          tjxyz1=tjxyz1+dry2*fcj33-drz2*fcj23
C@FR          tjxyz2=tjxyz2+drz2*fcj13-drx2*fcj33
C@FR          tjxyz3=tjxyz3+drx2*fcj23-dry2*fcj13
C@FRc         "Lone pair"
C@FR          drx1=a10-crmx1
C@FR          dry1=a11-crmy1
C@FR          drz1=a12-crmz1
C@FR          drx2=cis10-crmx2
C@FR          dry2=cis11-crmy2
C@FR          drz2=cis12-crmz2
C@FR          tixyz1=tixyz1+dry1*fci34-drz1*fci24
C@FR          tixyz2=tixyz2+drz1*fci14-drx1*fci34
C@FR          tixyz3=tixyz3+drx1*fci24-dry1*fci14
C@FR          tjxyz1=tjxyz1+dry2*fcj34-drz2*fcj24
C@FR          tjxyz2=tjxyz2+drz2*fcj14-drx2*fcj34
C@FR          tjxyz3=tjxyz3+drx2*fcj24-dry2*fcj14
C@FRc         End of trqwij routine
C@FR          trqng(1,i)=tixyz1
C@FR          trqng(2,i)=tixyz2
C@FR          trqng(3,i)=tixyz3
C@FR          trnisg(1,i)=tjxyz1
C@FR          trnisg(2,i)=tjxyz2
C@FR          trnisg(3,i)=tjxyz3
C@FR          frcng(1,i)=fi1v
C@FR          frcng(2,i)=fi2v
C@FR          frcng(3,i)=fi3v
C@FR          frci(1)=frci(1)+fj1v
C@FR          frci(2)=frci(2)+fj2v
C@FR          frci(3)=frci(3)+fj3v
C@FR          trqi(1)=trqi(1)+tjxyz1
C@FR          trqi(2)=trqi(2)+tjxyz2
C@FR          trqi(3)=trqi(3)+tjxyz3
C@FR          virscn(1)=virscn(1)+vircv1
C@FR          virscn(2)=virscn(2)+vircv2
C@FR          virscn(3)=virscn(3)+vircv3
        end do
      else
c       General solvent
        do i=1,nvmolg
          texngd(i)=0.d0
C@FR          frcng(1,i)=0.0
C@FR          frcng(2,i)=0.0
C@FR          frcng(3,i)=0.0
C@FR          trqng(1,i)=0.0
C@FR          trqng(2,i)=0.0
C@FR          trqng(3,i)=0.0
C@FR          trnisg(1,i)=0.0
C@FR          trnisg(2,i)=0.0
C@FR          trnisg(3,i)=0.0
        end do
C@FR        call zeroit(fcii,3*nslv*nvmolg)
C@FR        call zeroit(fcis,3*nslv*nvmolg)
        jc0=ic00+is*nslv
        do i=1,nvmolg
          ic0=(i-1)*nslv
          if (iop(5) .ne. 2) then
            do ja=1,nslv
              cij(1,ja)=c(1,jc0+ja)+ccii(1,i)
              cij(2,ja)=c(2,jc0+ja)+ccii(2,i)
              cij(3,ja)=c(3,jc0+ja)+ccii(3,i)
            end do
          else
            call hcp_rot_trans(crm(1,is),c(1,jc0+1),cij,1,nslv,
     -        ccii(1,i),ivopt(i),1)
          end if
          do ia=1,nslv
            do ja=1,nslv
              rxyz1v=cgs(1,ic0+ia)-cij(1,ja)
              rxyz2v=cgs(2,ic0+ia)-cij(2,ja)
              rxyz3v=cgs(3,ic0+ia)-cij(3,ja)
              rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
              rij=sqrt(rij2)
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
              er6=c6vv(ja,ia)/rij6
              er12=c12vv(ja,ia)/rij12
              qr=(qvv(ja,ia)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
              texngd(i)=texngd(i)+(dble(er12)-dble(er6)+dble(qr))
C@FR              abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR              fci1=-abcf*rxyz1v
C@FR              fci2=-abcf*rxyz2v
C@FR              fci3=-abcf*rxyz3v
C@FR              virscn(1)=virscn(1)+fci1*zvv(1,i)
C@FR              virscn(2)=virscn(2)+fci2*zvv(2,i)
C@FR              virscn(3)=virscn(3)+fci3*zvv(3,i)
C@FR              fcii(1,ic0+ia)=fcii(1,ic0+ia)+fci1
C@FR              fcii(2,ic0+ia)=fcii(2,ic0+ia)+fci2
C@FR              fcii(3,ic0+ia)=fcii(3,ic0+ia)+fci3
C@FR              fcis(1,ic0+ja)=fcis(1,ic0+ja)-fci1
C@FR              fcis(2,ic0+ja)=fcis(2,ic0+ja)-fci2
C@FR              fcis(3,ic0+ja)=fcis(3,ic0+ja)-fci3
C@FR              frcng(1,i)=frcng(1,i)+fci1
C@FR              frcng(2,i)=frcng(2,i)+fci2
C@FR              frcng(3,i)=frcng(3,i)+fci3
C@FR              frci(1)=frci(1)-fci1
C@FR              frci(2)=frci(2)-fci2
C@FR              frci(3)=frci(3)-fci3
            end do
          end do
        end do
        do i=1,nvmolg
          tesiis=tesiis+texngd(i)
          texng(i)=texngd(i)
C@FRc         Now calculate torques
C@FR          trqii1=0.0
C@FR          trqii2=0.0
C@FR          trqii3=0.0
C@FR          trqis1=0.0
C@FR          trqis2=0.0
C@FR          trqis3=0.0
C@FR          ic0=(i-1)*nslv
C@FR          do ia=1,nslv
C@FR            trqii1=trqii1+(cgs(2,ic0+ia)-crmgs(2,i))*fcii(3,ic0+ia)-
C@FR     -             (cgs(3,ic0+ia)-crmgs(3,i))*fcii(2,ic0+ia)
C@FR            trqii2=trqii2+(cgs(3,ic0+ia)-crmgs(3,i))*fcii(1,ic0+ia)-
C@FR     -             (cgs(1,ic0+ia)-crmgs(1,i))*fcii(3,ic0+ia)
C@FR            trqii3=trqii3+(cgs(1,ic0+ia)-crmgs(1,i))*fcii(2,ic0+ia)-
C@FR     -             (cgs(2,ic0+ia)-crmgs(2,i))*fcii(1,ic0+ia)
C@FR            trqis1=trqis1+(c(2,jc0+ia)-crmis(2))*fcis(3,ic0+ia)-
C@FR     -             (c(3,jc0+ia)-crmis(3))*fcis(2,ic0+ia)
C@FR            trqis2=trqis2+(c(3,jc0+ia)-crmis(3))*fcis(1,ic0+ia)-
C@FR     -             (c(1,jc0+ia)-crmis(1))*fcis(3,ic0+ia)
C@FR            trqis3=trqis3+(c(1,jc0+ia)-crmis(1))*fcis(2,ic0+ia)-
C@FR     -             (c(2,jc0+ia)-crmis(2))*fcis(1,ic0+ia)
C@FR          end do
C@FR          trqng(1,i)=trqii1
C@FR          trqng(2,i)=trqii2
C@FR          trqng(3,i)=trqii3
C@FR          trnisg(1,i)=trqis1
C@FR          trnisg(2,i)=trqis2
C@FR          trnisg(3,i)=trqis3
C@FR          trqi(1)=trqi(1)+trqis1
C@FR          trqi(2)=trqi(2)+trqis2
C@FR          trqi(3)=trqi(3)+trqis3
        end do
      end if
c     Scatter the results back to their proper place
      do i=1,nvmolg
        inxi=indexx(i)
        texn(inxi)=texng(i)
C@FR        frcn(1,inxi)=frcng(1,i)
C@FR        frcn(2,inxi)=frcng(2,i)
C@FR        frcn(3,inxi)=frcng(3,i)
C@FR        trqnis(1,inxi)=trnisg(1,i)
C@FR        trqnis(2,inxi)=trnisg(2,i)
C@FR        trqnis(3,inxi)=trnisg(3,i)
C@FR        trqn(1,inxi)=trqng(1,i)
C@FR        trqn(2,inxi)=trqng(2,i)
C@FR        trqn(3,inxi)=trqng(3,i)
      end do
9100  if (nnear .gt. 0) then
c         Take care of close contacts by calling the unvectorized routines
        do ii=1,nnear
          i=ixnear(ii)
          z1=crmis(1)-crm(1,i)
          z2=crmis(2)-crm(2,i)
          z3=crmis(3)-crm(3,i)
          call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
          x=eww(i,is,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
     -      riijj,c,crm)
C@FR          virc(1)=frixyz(1)*z1
C@FR          virc(2)=frixyz(2)*z2
C@FR          virc(3)=frixyz(3)*z3
          tesiis=tesiis+dble(x)
          texn(i)=x
C@FR          ic0=ic01+i*nslv
C@FR          if (iop(39) .lt. 2) then
C@FR            call trqwij(c(1,ic0),c(1,isc0),crm(1,i),crm(1,is),nslvsv)
C@FR          else
C@FR            call torque(c(1,ic0),crm(1,i),fcislv,1,nslvsv,trixyz,i)
C@FR            call torque(c(1,isc0),crm(1,is),fcjslv,1,nslvsv,trjxyz,is)
C@FR          end if
C@FR          trqn(1,i)=trixyz(1)
C@FR          trqn(2,i)=trixyz(2)
C@FR          trqn(3,i)=trixyz(3)
C@FR          trqnis(1,i)=trjxyz(1)
C@FR          trqnis(2,i)=trjxyz(2)
C@FR          trqnis(3,i)=trjxyz(3)
C@FR          frcn(1,i)=frixyz(1)
C@FR          frcn(2,i)=frixyz(2)
C@FR          frcn(3,i)=frixyz(3)
C@FR          frci(1)=frci(1)+frjxyz(1)
C@FR          frci(2)=frci(2)+frjxyz(2)
C@FR          frci(3)=frci(3)+frjxyz(3)
C@FR          trqi(1)=trqi(1)+trjxyz(1)
C@FR          trqi(2)=trqi(2)+trjxyz(2)
C@FR          trqi(3)=trqi(3)+trjxyz(3)
C@FR          virscn(1)=virscn(1)+virc(1)
C@FR          virscn(2)=virscn(2)+virc(2)
C@FR          virscn(3)=virscn(3)+virc(3)
        end do
      end if
      return
      end
      subroutine torque(c,crm,fc,ifrst,natm,torqs,is)
c#    MMC routine 118 lstmod: 01/25/95
c*****Computes the torque on molecule is with atoms at coordinates
c     in c, COM at crm, forces on the atoms in fc.
      dimension c(3,natm),fc(3,natm),crm(3),torqs(3)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      torqs1=0.0
      torqs2=0.0
      torqs3=0.0
      if (is .gt. 1) then
c       Solvent
        do i=ifrst,natm
          dr1=c(1,indats(i))-crm(1)
          dr2=c(2,indats(i))-crm(2)
          dr3=c(3,indats(i))-crm(3)
          torqs1=torqs1+(dr2*fc(3,i)-fc(2,i)*dr3)
          torqs2=torqs2+(dr3*fc(1,i)-fc(3,i)*dr1)
          torqs3=torqs3+(dr1*fc(2,i)-fc(1,i)*dr2)
        end do
      else
c       Solute
        do i=ifrst,natm
          dr1=c(1,i)-crm(1)
          dr2=c(2,i)-crm(2)
          dr3=c(3,i)-crm(3)
C@DB          trq1=(dr2*fc(3,i)-fc(2,i)*dr3)
C@DB          trq2=(dr3*fc(1,i)-fc(3,i)*dr1)
C@DB          trq3=(dr1*fc(2,i)-fc(1,i)*dr2)
C@DB              write (6,7724) ia,(fc(k,i),k=1,3),dr1,dr2,dr3,
C@DB     -          trq1,trq2,trq3
C@DB7724          format(' TORQUE ia=',i3,' fi=',3e13.6,' dr=',3f10.6,
C@DB     -          ' trqi=',3e13.6)
          torqs1=torqs1+(dr2*fc(3,i)-fc(2,i)*dr3)
          torqs2=torqs2+(dr3*fc(1,i)-fc(3,i)*dr1)
          torqs3=torqs3+(dr1*fc(2,i)-fc(1,i)*dr2)
        end do
      end if
      torqs(1)=torqs1
      torqs(2)=torqs2
      torqs(3)=torqs3
      return
      end
      subroutine torquebond(c,it,fc,abstorque,natm)
c#    MMC routine 119 lstmod: 11/04/03
c*****Computes the torque on a torsion bond
c     Solute atom coordinates in c, forces on the atoms in fc.
      real*8 fc
      dimension c(3,natm),fc(3,natm)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 torqs1,torqs2,torqs3
      torqs1=0.0
      torqs2=0.0
      torqs3=0.0
      do ia=1,nnexttormov(itangindx(it))
        i=irotlist(irotlinc(it)+ia)
        dr1=c(1,i)-c(1,iquata(it,2))
        dr2=c(2,i)-c(2,iquata(it,2))
        dr3=c(3,i)-c(3,iquata(it,2))
C@DB          trq1=(dr2*fc(3,i)-fc(2,i)*dr3)
C@DB          trq2=(dr3*fc(1,i)-fc(3,i)*dr1)
C@DB          trq3=(dr1*fc(2,i)-fc(1,i)*dr2)
C@DB              write (6,7724) ia,(fc(k,i),k=1,3),dr1,dr2,dr3,
C@DB     -          trq1,trq2,trq3
C@DB7724          format(' TORQUEBOND ia=',i3,' fi=',3e13.6,' dr=',3f10.6,
C@DB     -          ' trqi=',3e13.6)
        torqs1=torqs1+(dr2*fc(3,i)-fc(2,i)*dr3)
        torqs2=torqs2+(dr3*fc(1,i)-fc(3,i)*dr1)
        torqs3=torqs3+(dr1*fc(2,i)-fc(1,i)*dr2)
      end do
      dr1=c(1,iquata(it,3))-c(1,iquata(it,2))
      dr2=c(2,iquata(it,3))-c(2,iquata(it,2))
      dr3=c(3,iquata(it,3))-c(3,iquata(it,2))
      dr=sqrt(dr1**2+dr2**2+dr3**2)
      abstorque=(dr1*torqs1+dr2*torqs2+dr3*torqs3)/dr
      return
      end
      subroutine trqwij(c1,c2,crm1,crm2,nslvsv)
c#    MMC routine 120 lstmod: 06/02/06
c*****Fully scalar version for slv-slv case to calculate torque
      dimension c1(12),c2(12),crm1(3),crm2(3)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /trqij/ trqx1,trqy1,trqz1,trqx2,trqy2,trqz2,cplcoef(3),
     -  nslttf(2),nslttl(2),ntorcop
      equivalence (fcislv(1,1),fiox),(fcislv(2,1),fioy),
     -  (fcislv(3,1),fioz),(fcislv(1,2),fih1x),(fcislv(2,2),fih1y),
     -  (fcislv(3,2),fih1z),(fcislv(1,3),fih2x),(fcislv(2,3),fih2y),
     -  (fcislv(3,3),fih2z),(fcislv(1,4),filx),(fcislv(2,4),fily),
     -  (fcislv(3,4),filz)
      equivalence (fcjslv(1,1),fjox),(fcjslv(2,1),fjoy),
     -  (fcjslv(3,1),fjoz),(fcjslv(1,2),fjh1x),(fcjslv(2,2),fjh1y),
     -  (fcjslv(3,2),fjh1z),(fcjslv(1,3),fjh2x),(fcjslv(2,3),fjh2y),
     -  (fcjslv(3,3),fjh2z),(fcjslv(1,4),fjlx),(fcjslv(2,4),fjly),
     -  (fcjslv(3,4),fjlz)
      trqx1=0.0
      trqy1=0.0
      trqz1=0.0
      trqx2=0.0
      trqy2=0.0
      trqz2=0.0
      crmx1=crm1(1)
      crmy1=crm1(2)
      crmz1=crm1(3)
      crmx2=crm2(1)
      crmy2=crm2(2)
      crmz2=crm2(3)
c     Oxygen atom contribution
      drx1=c1(1)-crmx1
      dry1=c1(2)-crmy1
      drz1=c1(3)-crmz1
      drx2=c2(1)-crmx2
      dry2=c2(2)-crmy2
      drz2=c2(3)-crmz2
      trqx1=trqx1+dry1*fioz-drz1*fioy
      trqy1=trqy1+drz1*fiox-drx1*fioz
      trqz1=trqz1+drx1*fioy-dry1*fiox
      trqx2=trqx2+dry2*fjoz-drz2*fjoy
      trqy2=trqy2+drz2*fjox-drx2*fjoz
      trqz2=trqz2+drx2*fjoy-dry2*fjox
c     First hydrogen atom contribution
      drx1=c1(4)-crmx1
      dry1=c1(5)-crmy1
      drz1=c1(6)-crmz1
      drx2=c2(4)-crmx2
      dry2=c2(5)-crmy2
      drz2=c2(6)-crmz2
      trqx1=trqx1+dry1*fih1z-drz1*fih1y
      trqy1=trqy1+drz1*fih1x-drx1*fih1z
      trqz1=trqz1+drx1*fih1y-dry1*fih1x
      trqx2=trqx2+dry2*fjh1z-drz2*fjh1y
      trqy2=trqy2+drz2*fjh1x-drx2*fjh1z
      trqz2=trqz2+drx2*fjh1y-dry2*fjh1x
c     Second hydrogen atom
      drx1=c1(7)-crmx1
      dry1=c1(8)-crmy1
      drz1=c1(9)-crmz1
      drx2=c2(7)-crmx2
      dry2=c2(8)-crmy2
      drz2=c2(9)-crmz2
      trqx1=trqx1+dry1*fih2z-drz1*fih2y
      trqy1=trqy1+drz1*fih2x-drx1*fih2z
      trqz1=trqz1+drx1*fih2y-dry1*fih2x
      trqx2=trqx2+dry2*fjh2z-drz2*fjh2y
      trqy2=trqy2+drz2*fjh2x-drx2*fjh2z
      trqz2=trqz2+drx2*fjh2y-dry2*fjh2x
      if (nslvsv .eq. 3) return
c     "Lone pair"
      drx1=c1(10)-crmx1
      dry1=c1(11)-crmy1
      drz1=c1(12)-crmz1
      drx2=c2(10)-crmx2
      dry2=c2(11)-crmy2
      drz2=c2(12)-crmz2
      trqx1=trqx1+dry1*filz-drz1*fily
      trqy1=trqy1+drz1*filx-drx1*filz
      trqz1=trqz1+drx1*fily-dry1*filx
      trqx2=trqx2+dry2*fjlz-drz2*fjly
      trqy2=trqy2+drz2*fjlx-drx2*fjlz
      trqz2=trqz2+drx2*fjly-dry2*fjlx
      return
      end
      subroutine trqwi(c,crm,nslvsv)
c#    MMC routine 121 lstmod: 06/02/06
c*****Calculate torque on solvent using fci - scalar version for speed
      dimension c(12),crm(3)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /trqij/ trqx,trqy,trqz,trjxyz(3),cplcoef(3),
     -  nslttf(2),nslttl(2),ntorcop
      equivalence (fcislv(1,1),fiox),(fcislv(2,1),fioy),
     -  (fcislv(3,1),fioz),(fcislv(1,2),fih1x),(fcislv(2,2),fih1y),
     -  (fcislv(3,2),fih1z),(fcislv(1,3),fih2x),(fcislv(2,3),fih2y),
     -  (fcislv(3,3),fih2z),(fcislv(1,4),filx),(fcislv(2,4),fily),
     -  (fcislv(3,4),filz)
      trqx=0.0
      trqy=0.0
      trqz=0.0
      crmx=crm(1)
      crmy=crm(2)
      crmz=crm(3)
c     Oxygen atom contribution
      drx=c(1)-crmx
      dry=c(2)-crmy
      drz=c(3)-crmz
      trqx=trqx+dry*fioz-drz*fioy
      trqy=trqy+drz*fiox-drx*fioz
      trqz=trqz+drx*fioy-dry*fiox
c     First hydrogen atom contribution
      drx=c(4)-crmx
      dry=c(5)-crmy
      drz=c(6)-crmz
      trqx=trqx+dry*fih1z-drz*fih1y
      trqy=trqy+drz*fih1x-drx*fih1z
      trqz=trqz+drx*fih1y-dry*fih1x
c     Second hydrogen atom
      drx=c(7)-crmx
      dry=c(8)-crmy
      drz=c(9)-crmz
      trqx=trqx+dry*fih2z-drz*fih2y
      trqy=trqy+drz*fih2x-drx*fih2z
      trqz=trqz+drx*fih2y-dry*fih2x
      if (nslvsv .eq. 3) return
c     "Lone pair"
      drx=c(10)-crmx
      dry=c(11)-crmy
      drz=c(12)-crmz
      trqx=trqx+dry*filz-drz*fily
      trqy=trqy+drz*filx-drx*filz
      trqz=trqz+drx*fily-dry*filx
      return
      end
      subroutine trqwj(c,crm,nslvsv)
c#    MMC routine 122 lstmod: 12/08/86
c*****Calculate torque on solvent using fcj - scalar version for speed
      dimension c(12),crm(3)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /trqij/ trixyz(3),trqx,trqy,trqz,cplcoef(3),
     -  nslttf(2),nslttl(2),ntorcop
      equivalence (fcjslv(1,1),fjox),(fcjslv(2,1),fjoy),
     -  (fcjslv(3,1),fjoz),(fcjslv(1,2),fjh1x),(fcjslv(2,2),fjh1y),
     -  (fcjslv(3,2),fjh1z),(fcjslv(1,3),fjh2x),(fcjslv(2,3),fjh2y),
     -  (fcjslv(3,3),fjh2z),(fcjslv(1,4),fjlx),(fcjslv(2,4),fjly),
     -  (fcjslv(3,4),fjlz)
      trqx=0.0
      trqy=0.0
      trqz=0.0
      crmx=crm(1)
      crmy=crm(2)
      crmz=crm(3)
c     Oxygen atom contribution
      drx=c(1)-crmx
      dry=c(2)-crmy
      drz=c(3)-crmz
      trqx=trqx+dry*fjoz-drz*fjoy
      trqy=trqy+drz*fjox-drx*fjoz
      trqz=trqz+drx*fjoy-dry*fjox
c     First hydrogen atom contribution
      drx=c(4)-crmx
      dry=c(5)-crmy
      drz=c(6)-crmz
      trqx=trqx+dry*fjh1z-drz*fjh1y
      trqy=trqy+drz*fjh1x-drx*fjh1z
      trqz=trqz+drx*fjh1y-dry*fjh1x
c     Second hydrogen atom
      drx=c(7)-crmx
      dry=c(8)-crmy
      drz=c(9)-crmz
      trqx=trqx+dry*fjh2z-drz*fjh2y
      trqy=trqy+drz*fjh2x-drx*fjh2z
      trqz=trqz+drx*fjh2y-dry*fjh2x
      if (nslvsv .eq. 3) return
c     "Lone pair"
      drx=c(10)-crmx
      dry=c(11)-crmy
      drz=c(12)-crmz
      trqx=trqx+dry*fjlz-drz*fjly
      trqy=trqy+drz*fjlx-drx*fjlz
      trqz=trqz+drx*fjly-dry*fjlx
      return
      end
      subroutine e12sum(e0,e1,e01st,nmolec)
c#    MMC routine 123 lstmod: 02/06/86
c*****Computes sum of slt contributions to the two slt-slv energy terms
      real*8 e0,e1
      dimension e01st(2,#MO)
      e0=0.d0
      e1=0.d0
      do is=2,nmolec
        e0=e0+e01st(1,is)
        e1=e1+e01st(2,is)
      end do
      return
      end
      subroutine e123sum(a0,a1,a2,b,nmolec)
c#    MMC routine 124 lstmod: 02/06/86
c*****Computes sum of slt contributions to the two slt-slv energy terms
      real*8 a0,a1,a2
      dimension b(3,#MO)
      a0=0.d0
      a1=0.d0
      a2=0.d0
      do i=2,nmolec
        a0=a0+b(1,i)
        a1=a1+b(2,i)
        a2=a2+b(3,i)
      end do
      return
      end
      subroutine parsum(isolv,nmolec,movtyp,ix,nstfm,iop18,tss,tsind,
     -  tsindn,tsindo)
c#    MMC routine 125 lstmod: 01/24/02
c*****Calculate  part of the solute energy (for accept/reject)
      real*8 tss
      dimension tsind(3,#MO),tsindo(3,#MO),tsindn(3,#MO)
      if (isolv .eq. 1) then
        if (movtyp .eq. 1 .or. (movtyp .eq. 2 .and.
     -      nstfm .eq. 3 .and. iop18 .ne. 4)) then
          tss=0.d0
          do is=2,nmolec
            tss=tss+tsindn(ix,is)
          end do
        else
c         Partial solute move
          tss=0.d0
          do is=2,nmolec
            tss=tss+tsindn(ix,is)-tsindo(ix,is)
          end do
        end if
      else
        tss=tss+tsindn(ix,isolv)-tsind(ix,isolv)
      end if
      return
      end
      subroutine dsum(array,if,il,sum)
c#    MMC routine 126 lstmod: 06/17/86
c*****Computes sum of the terms in array from if to il
      real*8 sum,array
      dimension array(il)
      sum=0.d0
      do i=if,il
        sum=sum+array(i)
      end do
      return
      end
      subroutine ixsum(array,ix,if,il,max,dsum)
c#    MMC routine 126/a lstmod: 12/19/06
c*****Computes sum of the terms in array from if to il
      real*8 dsum
      dimension array(max),ix(il)
      dsum=0.d0
      do i=if,il
        dsum=dsum+array(ix(i))
      end do
      return
      end
      subroutine updsum(tot,aold,anew,n,cplfac)
c#    MMC routine 127 lstmod: 03/16/95
c*****Simplified savegy - update the total binding energy array and analogues
      real*8 tot
      dimension tot(n),aold(n),anew(n)
      if (cplfac .eq. 1.0) then
        do i=1,n
          tot(i)=tot(i)+dble(anew(i))-dble(aold(i))
        end do
      else
        do i=1,n
          tot(i)=tot(i)+dble(cplfac)*(dble(anew(i))-dble(aold(i)))
        end do
      end if
      return
      end
      subroutine savsusvfull(isolv,nmolec,texslt,vrcslt,frcslt,
     -  trtslt,trvslt,tss12,tss6,tss1,tsind)
c#    MMC routine 128 lstmod: 11/01/05
c*****Save the solute contributions of molec isolv to eng, forces, torques
      real*8 tss12,tss6,tss1
      dimension frcslt(3,#MO),trtslt(3,#MO),trvslt(3,#MO),
     -  texslt(#MO),vrcslt(3,#MO),tsind(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      common /option/ iop(200),idebug(200)
      if (isolv .gt. 1) then
c       Solvent moved
        texslt(isolv)=texn(1)
        nslvds(isolv)=nis(1)
        nslvdsid(isolv)=idistid
        rijpso(isolv)=rijpsis
        ipxo(isolv)=ipxis
        tss12=tss12+tsindn(1,isolv)-tsind(1,isolv)
        tss6=tss6+tsindn(2,isolv)-tsind(2,isolv)
        tss1=tss1+tsindn(3,isolv)-tsind(3,isolv)
        do k=1,3
          tsind(k,isolv)=tsindn(k,isolv)
C@FR          vrcslt(k,isolv)=vrsltn(k,isolv)
C@FR          frcslt(k,isolv)=-frcn(k,1)
C@FRC@TS          trtslt(k,isolv)=trqn(k,1)
C@FR          trvslt(k,isolv)=trqnis(k,1)
        end do
        if (iop(30) .gt. 3) then
          if (iop(30) .ne. 7) then
c           e01st(1,is),e01st(2,is): pair eng of slt is after an accpted move
c           with the 1st and 2nd part of the solute.
            e0o=e0o-e01st(1,isolv)+e01stn(1,isolv)
            e1o=e1o-e01st(2,isolv)+e01stn(2,isolv)
            e0o12=e0o12+eonen(1,isolv)-eone(1,isolv)
            e0o6=e0o6+eonen(2,isolv)-eone(2,isolv)
            e0o1=e0o1+eonen(3,isolv)-eone(3,isolv)
            e1o12=e1o12+etwon(1,isolv)-etwo(1,isolv)
            e1o6=e1o6+etwon(2,isolv)-etwo(2,isolv)
            e1o1=e1o1+etwon(3,isolv)-etwo(3,isolv)
            e01st(1,isolv)=e01stn(1,isolv)
            e01st(2,isolv)=e01stn(2,isolv)
            do k=1,3
              eone(k,isolv)=eonen(k,isolv)
              etwo(k,isolv)=etwon(k,isolv)
            end do
          end if
        end if
      else
c       Solute moved
        call trnsfr(texslt,texn,nmolec)
        if (ipsdist .eq. 1) then
          do i=2,nmolec
            rijpso(i)=rijpsn(i)
            ipxo(i)=ipxn(i)
            nslvds(i)=nis(i)
          end do
        end if
        if (iop(63) .gt. 0) call trnsfi(nslvdsid,nslvdsidn,nmolec)
        do k=1,3
          do i=2,nmolec
            tsind(k,i)=tsindn(k,i)
C@FR           vrcslt(k,i)=vrsltn(k,i)
C@FR            frcslt(k,i)=frcn(k,i)
C@FRC@TS            trtslt(k,i)=trqnis(k,i)
C@FR            trvslt(k,i)=trqn(k,i)
          end do
        end do
        if (iop(30) .gt. 3) then
          if (iop(30) .ne. 7) then
            do is=2,nmolec
              e01st(1,is)=e01stn(1,is)
              e01st(2,is)=e01stn(2,is)
            end do
            do k=1,3
              do is=2,nmolec
                eone(k,is)=eonen(k,is)
                etwo(k,is)=etwon(k,is)
              end do
            end do
            call e12sum(e0o,e1o,e01st,nmolec)
            call e123sum(e0o12,e0o6,e0o1,eonen,nmolec)
            call e123sum(e1o12,e1o6,e1o1,etwon,nmolec)
          end if
        end if
        call e123sum(tss12,tss6,tss1,tsind,nmolec)
      end if
      return
      end
      subroutine savsusvpar(nmolec,icopy,cplfac,texslt,vrcslt,
     -  frcslt,trtslt,trvslt,tss12,tss6,tss1,tsind)
c#    MMC routine 129 lstmod: 11/01/03
c*****Update the solute contributions to eng, forces, torques
      real*8 tss12,tss6,tss1
      dimension frcslt(3,#MO),trtslt(3,#MO),trvslt(3,#MO),
     -  texslt(#MO),vrcslt(3,#MO),tsind(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /frind2/ crat6,crat1
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /frind3/ eonetwo(3,#MO,2),eonen(3,#MO),
     -  etwon(3,#MO)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslT,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /option/ iop(200),idebug(200)
      real*8 e01sum
      if (ipsdist .eq. 1) call trnsfr(rijpso,rijpsn,nmolec)
      if (cplfac .eq. 1.0) then
        do i=2,nmolec
          texslt(i)=texslt(i)+texn(i)-texo(i)
          ipxo(i)=ipxn(i)
          do k=1,3
            tsind(k,i)=tsind(k,i)+tsindn(k,i)-tsindo(k,i)
C@FR            vrcslt(k,i)=vrcslt(k,i)+vrsltn(k,i)-vrslto(k,i)
C@FR            frcslt(k,i)=frcslt(k,i)+frcn(k,i)-frco(k,i)
C@FRC@TS            trtslt(k,i)=trtslt(k,i)+trqnis(k,i)-trqois(k,i)
C@FR            trvslt(k,i)=trvslt(k,i)+trqn(k,i)-trqo(k,i)
          end do
        end do
      else
        do i=2,nmolec
          texslt(i)=texslt(i)+cplfac*(texn(i)-texo(i))
          do k=1,3
            tsind(k,i)=tsind(k,i)+cplfac*(tsindn(k,i)-tsindo(k,i))
C@FR            vrcslt(k,i)=vrcslt(k,i)+cplfac*(vrsltn(k,i)-vrslto(k,i))
C@FR            frcslt(k,i)=frcslt(k,i)+cplfac*(frcn(k,i)-frco(k,i))
C@FRC@TS            trtslt(k,i)=trtslt(k,i)+cplfac*(trqnis(k,i)-trqois(k,i))
C@FR            trvslt(k,i)=trvslt(k,i)+cplfac*(trqn(k,i)-trqo(k,i))
          end do
        end do
      end if
      if (ipsdist .eq. 1) then
        if (iop(92) .eq. 0) then
          do i=2,nmolec
            niso(i)=nslvds(i)
            rijpsn(i)=sqrt(rijpso(i))
            nslvds(i)=int(rijpsn(i)*rri)+1
            nis(i)=nslvds(i)
          end do
        else
          do i=2,nmolec
            niso(i)=nslvds(i)
            nslvds(i)=int(rphs0isn(i)*rri)+1
            nis(i)=nslvds(i)
          end do
        end if
      end if
      if (iop(63) .gt. 0) then
        if (iop(56) .eq. 0 .or. iop(8) .eq. 1) then
         call trnsfi(nslvdsid,nslvds,nmolec)
        end if
      end if
      if (iop(30) .gt. 3) then
        if (iop(30) .ne. 7 .and. icopy .le. 2) then
          e01sum=0.d0
          do is=2,nmolec
            e01st(icopy,is)=e01st(icopy,is)+
     -        (e01stn(icopy,is)-e01sto(icopy,is))
            e01sum=e01sum+e01st(icopy,is)
            eonetwo(1,is,icopy)=eonetwo(1,is,icopy)+
     -        (tsindn(1,is)-tsindo(1,is))
            eonetwo(2,is,icopy)=eonetwo(2,is,icopy)+
     -        (tsindn(2,is)-tsindo(2,is))/crat6
            eonetwo(3,is,icopy)=eonetwo(3,is,icopy)+
     -        (tsindn(3,is)-tsindo(3,is))/crat1
          end do
          if (icopy .eq. 1) then
            e0o=e01sum
            call e123sum(e0o12,e0o6,e0o1,eonetwo(1,1,icopy),nmolec)
          else if (icopy .eq. 2) then
            e1o=e01sum
            call e123sum(e1o12,e1o6,e1o1,eonetwo(1,1,icopy),nmolec)
          end if
        end if
      end if
      call e123sum(tss12,tss6,tss1,tsind,nmolec)
      return
      end
      subroutine getegy(islv,c,crm)
c#    MMC routine 130 lstmod: 02/07/02
c*****TERRA (parallel) version of getegy
      dimension c(3,#NA),crm(3,#MO)
      common /ecell/ cic(3,27),ncell
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      dimension crmis(3)
      do k=1,3
        crmis(k)=crm(k,islv)
      end do
      do im=2,nmolec
        if (im .lt. islv) then
          if (nis(im) .lt. mxcslv) then
            z1=crmis(1)-crm(1,im)
            z2=crmis(2)-crm(2,im)
            z3=crmis(3)-crm(3,im)
            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
            if (riijj .le. ctslvs) then
              texo(im)=eww(im,islv,iopt,cic(1,iopt),cic(2,iopt),
     -          cic(3,iopt),riijj,c,crm)
              niso(im)=int(sqrt(riijj)*rri)+1
C@FR              virc(1)=frixyz(1)*z1
C@FR              virc(2)=frixyz(2)*z2
C@FR              virc(3)=frixyz(3)*z3
C@FR              ic0=ic01+im*nslv
C@FR              if (iop(39) .gt. 1) then
C@FR                call torque(c(1,ic0),crm(1,im),fcislv,1,nslvsv,
C@FR     -            trixyz,im)
C@FR              else
C@FR                call trqwi(c(1,ic0),crm(1,im),nslvsv)
C@FR              end if
C@FR              do k=1,3
C@FR                trqo(k,im)=trixyz(k)
C@FR                frco(k,im)=frixyz(k)
C@FR                virsco(k)=virsco(k)+virc(k)
C@FR              end do
            end if
          end if
        else if (im .gt. islv) then
          if (nis(im) .lt. mxcslv) then
            z1=crm(1,im)-crmis(1)
            z2=crm(2,im)-crmis(2)
            z3=crm(3,im)-crmis(3)
            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
            if (riijj .le. ctslvs) then
              texo(im)=eww(islv,im,iopt,cic(1,iopt),cic(2,iopt),
     -          cic(3,iopt),riijj,c,crm)
              niso(im)=int(sqrt(riijj)*rri)+1
C@FR              virc(1)=frixyz(1)*z1
C@FR              virc(2)=frixyz(2)*z2
C@FR              virc(3)=frixyz(3)*z3
C@FR              ic0=ic01+im*nslv
C@FR              if (iop(39) .gt. 1) then
C@FR                call torque(c(1,ic0),crm(1,im),fcjslv,1,nslvsv,
C@FR     -            trjxyz,im)
C@FR              else
C@FR                call trqwj(c(1,ic0),crm(1,im),nslvsv)
C@FR              end if
C@FR              do k=1,3
C@FR                trqo(k,im)=trjxyz(k)
C@FR                frco(k,im)=frjxyz(k)
C@FR                virsco(k)=virsco(k)+virc(k)
C@FR              end do
            end if
          end if
        end if
      end do
      return
      end
C@DM      subroutine mpi_getegy(islv,c,crm)
C@DMc#    MMC routine 131 lstmod: 02/08/11
C@DMc*****MPI (parallel) version of getegy
C@DM      dimension c(3,#NA),crm(3,#MO)
C@DM      common /ecell/ cic(3,27),ncell
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
C@DM      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
C@DM     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
C@DM     -  islvjrep(#ND),ianslv(#SV)
C@DM      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
C@DM     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
C@DM     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
C@DM     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
C@DM     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
C@DM     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
C@DM     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
C@DM     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
C@DM     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
C@DM     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
C@DM     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
C@DM      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
C@DM     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
C@DM     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
C@DM     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
C@DM     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
C@DM     -  numsolv,nsolvfix,nmolec,nmol3,natoms
C@DM      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
C@DM     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
C@DM     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
C@DM     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
C@DM      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
C@DM      real*8 dnrww,dnrslt,dngwws
C@DM      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
C@DM     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
C@DM      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
C@DM      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
C@DM     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
C@DM     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
C@DM     -  vrcslt(3,#MO)
C@DM      real*8 tesiis
C@DM      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
C@DM     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
C@DM      real*8 frci,trqi,frcipo,trqipo
C@DM      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
C@DM     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
C@DM     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
C@DM      real*8 virial,virscn,virsco,vsltsm,vircsm
C@DM      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
C@DM     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
C@DM      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
C@DM      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
C@DM     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
C@DM     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
C@DM     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
C@DM     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
C@DM     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
C@DM     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
C@DM     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
C@DM     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
C@DM     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
C@DM     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
C@DM     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
C@DM     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
C@DM     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
C@DM      common /option/ iop(200),idebug(200)
C@DM      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
C@DM     -  ntorcop
C@DM      dimension crmis(3)
C@DM      do k=1,3
C@DM        crmis(k)=crm(k,islv)
C@DM      end do
C@DM      do im=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM        if (im .lt. islv) then
C@DM          if (nis(im) .lt. mxcslv) then
C@DM            z1=crmis(1)-crm(1,im)
C@DM            z2=crmis(2)-crm(2,im)
C@DM            z3=crmis(3)-crm(3,im)
C@DM            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
C@DM            if (riijj .le. ctslvs) then
C@DM              texo(im)=eww(im,islv,iopt,cic(1,iopt),cic(2,iopt),
C@DM     -          cic(3,iopt),riijj,c,crm)
C@DM              niso(im)=int(sqrt(riijj)*rri)+1
C@DMC@FRc              virc(1)=frixyz(1)*z1
C@DMC@FRc              virc(2)=frixyz(2)*z2
C@DMC@FRc              virc(3)=frixyz(3)*z3
C@DMC@FR              ic0=ic01+im*nslv
C@DMC@FR              if (iop(39) .gt. 1) then
C@DMC@FR                call torque(c(1,ic0),crm(1,im),fcislv,1,nslvsv,
C@DMC@FR     -            trixyz,im)
C@DMC@FR              else
C@DMC@FR                call trqwi(c(1,ic0),crm(1,im),nslvsv)
C@DMC@FR              end if
C@DMC@FR              do k=1,3
C@DMC@FR                trqo(k,im)=trixyz(k)
C@DMC@FR                frco(k,im)=frixyz(k)
C@DMC@FRc                virsco(k)=virsco(k)+virc(k)
C@DMC@FR              end do
C@DM            else
C@DM              texo(im)=0.0
C@DMC@FR              do k=1,3
C@DMC@FR                trqo(k,im)=0.0
C@DMC@FR                frco(k,im)=0.0
C@DMC@FR              end do
C@DM            end if
C@DM          else
C@DM            niso(im)=mxcslv
C@DM            texo(im)=0.0
C@DMC@FR            do k=1,3
C@DMC@FR              trqo(k,im)=0.0
C@DMC@FR              frco(k,im)=0.0
C@DMC@FR            end do
C@DM          end if
C@DM        else if (im .gt. islv) then
C@DM          if (nis(im) .lt. mxcslv) then
C@DM            z1=crm(1,im)-crmis(1)
C@DM            z2=crm(2,im)-crmis(2)
C@DM            z3=crm(3,im)-crmis(3)
C@DM            call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
C@DM            if (riijj .le. ctslvs) then
C@DM              texo(im)=eww(islv,im,iopt,cic(1,iopt),cic(2,iopt),
C@DM     -          cic(3,iopt),riijj,c,crm)
C@DM              niso(im)=int(sqrt(riijj)*rri)+1
C@DMC@FR              virc(1)=frixyz(1)*z1
C@DMC@FR              virc(2)=frixyz(2)*z2
C@DMC@FR              virc(3)=frixyz(3)*z3
C@DMC@FR              ic0=ic01+im*nslv
C@DMC@FR              if (iop(39) .gt. 1) then
C@DMC@FR                call torque(c(1,ic0),crm(1,im),fcjslv,1,nslvsv,
C@DMC@FR     -            trjxyz,im)
C@DMC@FR              else
C@DMC@FR                call trqwj(c(1,ic0),crm(1,im),nslvsv)
C@DMC@FR              end if
C@DMC@FR              do k=1,3
C@DMC@FR                trqo(k,im)=trjxyz(k)
C@DMC@FR                frco(k,im)=frjxyz(k)
C@DMC@FR                virsco(k)=virsco(k)+virc(k)
C@DMC@FR              end do
C@DM            else
C@DM              texo(im)=0.0
C@DMC@FR              do k=1,3
C@DMC@FR                trqo(k,im)=0.0
C@DMC@FR                frco(k,im)=0.0
C@DMC@FR              end do
C@DM            end if
C@DM          else
C@DM            niso(im)=mxcslv
C@DM            texo(im)=0.0
C@DMC@FR            do k=1,3
C@DMC@FR              trqo(k,im)=0.0
C@DMC@FR              frco(k,im)=0.0
C@DMC@FR            end do
C@DM          end if
C@DM        end if
C@DM      end do
C@DM      return
C@DM      end
      subroutine getevx(islv,c,crm)
c#    MMC routine 132 lstmod: 05/23/21
c*****32-bit vectorized version of getegy
      dimension c(3,#NA),crm(3,#MO)
      common /ecell/ cic(3,27),ncell
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      real*8 texngd
      common /gatherd/ texngd(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
C@FR      common /fciis/ fcii(3,#NA),fcis(3,#NA)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /cutinr/ rwwina,rwwin2
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      dimension crmis(3),cij(3,#SV)
      do k=1,3
        crmis(k)=crm(k,islv)
      end do
      isc0=ic01+islv*nslv
      cis1=c(1,isc0)
      cis2=c(2,isc0)
      cis3=c(3,isc0)
      cis4=c(1,isc0+1)
      cis5=c(2,isc0+1)
      cis6=c(3,isc0+1)
      cis7=c(1,isc0+2)
      cis8=c(2,isc0+2)
      cis9=c(3,isc0+2)
      cis10=c(1,isc0+iaq)
      cis11=c(2,isc0+iaq)
      cis12=c(3,isc0+iaq)
      isv1=islv-1
      isv2=islv+1
c     Get the PBC calculations first
      ic=0
      il1=0
      if2=3
      if (isv1 .ge. 2) then
c       i<is loop
        do i=2,isv1
          if (nis(i) .lt. mxcslv) then
            ic=ic+1
            indexx(ic)=i
          end if
        end do
        do im=1,ic
          i=indexx(im)
          zv(1,im)=crmis(1)-crm(1,i)
          zv(2,im)=crmis(2)-crm(2,i)
          zv(3,im)=crmis(3)-crm(3,i)
        end do
        il1=ic
        if2=ic+1
      end if
      if (isv2 .le. nmolec) then
c       i>is loop
        im0=ic+1
        do i=isv2,nmolec
          if (nis(i) .lt. mxcslv) then
            ic=ic+1
            indexx(ic)=i
          end if
        end do
        do im=im0,ic
          i=indexx(im)
          zv(1,im)=crm(1,i)-crmis(1)
          zv(2,im)=crm(2,i)-crmis(2)
          zv(3,im)=crm(3,i)-crmis(3)
        end do
      end if
      il2=ic
      nvmolg=ic
      if (nvmolg .eq. 0) return
      call pbcvec(iop(5),1,nvmolg)
c     Now gather the ones within cutoff distance
      ic=0
      nnear=0
      isetlm=0
      do i=1,nvmolg
        if (riijjv(i) .le. ctslvs) then
          if (riijjv(i) .le. rwwin2) then
c           Close contact found
            nnear=nnear+1
            ixnear(nnear)=indexx(i)
          else
            ic=ic+1
            if (isetlm .eq. 0 .and. i .gt. il1) then
c             set the new loop limits
              il1=ic-1
              if2=ic
              isetlm=1
            end if
            inxi=indexx(i)
            indexx(ic)=inxi
            indexn(ic)=i
          end if
        end if
      end do
      nvmolg=ic
      if (nvmolg .eq. 0) then
        if (nnear .gt. 0) go to 9100
        return
      end if
c     Perform the actual gathering of the molecular info
      do im=1,nvmolg
        i=indexn(im)
        ccii(1,im)=cci(1,i)
        ccii(2,im)=cci(2,i)
        ccii(3,im)=cci(3,i)
        zvv(1,im)=zv(1,i)
        zvv(2,im)=zv(2,i)
        zvv(3,im)=zv(3,i)
        nisoo(im)=int(sqrt(riijjv(i))*rri)+1
        ivopt(im)=ivopt(i)
      end do
      do im=1,nvmolg
        i=indexx(im)
        crmgs(1,im)=crm(1,i)
        crmgs(2,im)=crm(2,i)
        crmgs(3,im)=crm(3,i)
      end do
      do k=1,nslvsv
        do im=1,nvmolg
          i=ic00+indexx(im)*nslv+k
          cgs(1,(im-1)*nslvsv+k)=c(1,i)
          cgs(2,(im-1)*nslvsv+k)=c(2,i)
          cgs(3,(im-1)*nslvsv+k)=c(3,i)
        end do
      end do
      if (isetlm .eq. 0) then
c       No second loop to set up
        il1=ic
        if2=il2+1
      else
        il2=ic
      end if
      if (iop(26) .lt. 4) then
c       i<is loop
        do i=1,il1
c---------TIP3P or TIP4P water (or variants)
          b1=cis1+ccii(1,i)
          b2=cis2+ccii(2,i)
          b3=cis3+ccii(3,i)
          b4=cis4+ccii(1,i)
          b5=cis5+ccii(2,i)
          b6=cis6+ccii(3,i)
          b7=cis7+ccii(1,i)
          b8=cis8+ccii(2,i)
          b9=cis9+ccii(3,i)
          b10=cis10+ccii(1,i)
          b11=cis11+ccii(2,i)
          b12=cis12+ccii(3,i)
          ic0=(i-1)*nslvsv+1
          a1=cgs(1,ic0)
          a2=cgs(2,ic0)
          a3=cgs(3,ic0)
          a4=cgs(1,ic0+1)
          a5=cgs(2,ic0+1)
          a6=cgs(3,ic0+1)
          a7=cgs(1,ic0+2)
          a8=cgs(2,ic0+2)
          a9=cgs(3,ic0+2)
          a10=cgs(1,ic0+iaq)
          a11=cgs(2,ic0+iaq)
          a12=cgs(3,ic0+iaq)
          rab2x=a1-b1
          rab2y=a2-b2
          rab2z=a3-b3
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@FR          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fcj11=rab2x*rab3
C@FR          fcj21=rab2y*rab3
C@FR          fcj31=rab2z*rab3
C@FR          fci11=-fcj11
C@FR          fci21=-fcj21
C@FR          fci31=-fcj31
          rabx=a10-b10
          raby=a11-b11
          rabz=a12-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          fci14=-rabx*rab3
C@FR          fci24=-raby*rab3
C@FR          fci34=-rabz*rab3
          rabx=a4-b4
          raby=a5-b5
          rabz=a6-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fci12=-rabx*rab3
C@FR          fci22=-raby*rab3
C@FR          fci32=-rabz*rab3
          rabx=a4-b7
          raby=a5-b8
          rabz=a6-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
          rabx=a7-b4
          raby=a8-b5
          rabz=a9-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fci13=-rabx*rab3
C@FR          fci23=-raby*rab3
C@FR          fci33=-rabz*rab3
          rabx=a7-b7
          raby=a8-b8
          rabz=a9-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
          rabx=a4-b10
          raby=a5-b11
          rabz=a6-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
          rabx=a7-b10
          raby=a8-b11
          rabz=a9-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
          rabx=a10-b4
          raby=a11-b5
          rabz=a12-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
          rabx=a10-b7
          raby=a11-b8
          rabz=a12-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
c         Calculate interaction energy.
          deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -    qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          texng(i)=deww
C@FR          fi1v=((fci11+fci12)+fci13)+fci14
C@FR          fi2v=((fci21+fci22)+fci23)+fci24
C@FR          fi3v=((fci31+fci32)+fci33)+fci34
c         End of eww subroutine
C@FR          vircv1=fi1v*zvv(1,i)
C@FR          vircv2=fi2v*zvv(2,i)
C@FR          vircv3=fi3v*zvv(3,i)
C@FRc         The following lines are in lieu of a call to trqwij
C@FR          crmx1=crmgs(1,i)
C@FR          crmy1=crmgs(2,i)
C@FR          crmz1=crmgs(3,i)
C@FRc         Oxygen atom contribution
C@FR          drx1=a1-crmx1
C@FR          dry1=a2-crmy1
C@FR          drz1=a3-crmz1
C@FR          tixyz1=dry1*fci31-drz1*fci21
C@FR          tixyz2=drz1*fci11-drx1*fci31
C@FR          tixyz3=drx1*fci21-dry1*fci11
C@FRc         First hydrogen atom contribution
C@FR          drx1=a4-crmx1
C@FR          dry1=a5-crmy1
C@FR          drz1=a6-crmz1
C@FR          tixyz1=tixyz1+dry1*fci32-drz1*fci22
C@FR          tixyz2=tixyz2+drz1*fci12-drx1*fci32
C@FR          tixyz3=tixyz3+drx1*fci22-dry1*fci12
C@FRc         Second hydrogen atom
C@FR          drx1=a7-crmx1
C@FR          dry1=a8-crmy1
C@FR          drz1=a9-crmz1
C@FR          tixyz1=tixyz1+dry1*fci33-drz1*fci23
C@FR          tixyz2=tixyz2+drz1*fci13-drx1*fci33
C@FR          tixyz3=tixyz3+drx1*fci23-dry1*fci13
C@FRc         "Lone pair"
C@FR          drx1=a10-crmx1
C@FR          dry1=a11-crmy1
C@FR          drz1=a12-crmz1
C@FR          tixyz1=tixyz1+dry1*fci34-drz1*fci24
C@FR          tixyz2=tixyz2+drz1*fci14-drx1*fci34
C@FR          tixyz3=tixyz3+drx1*fci24-dry1*fci14
C@FRc         End of trqwij routine
C@FR          trqng(1,i)=tixyz1
C@FR          trqng(2,i)=tixyz2
C@FR          trqng(3,i)=tixyz3
C@FR          frcng(1,i)=fi1v
C@FR          frcng(2,i)=fi2v
C@FR          frcng(3,i)=fi3v
C@FR          virsco(1)=virsco(1)+vircv1
C@FR          virsco(2)=virsco(2)+vircv2
C@FR          virsco(3)=virsco(3)+vircv3
        end do
c       i>is loop
        do i=if2,il2
c---------TIPS2/TIP4P/BF water
          ic0=(i-1)*nslvsv+1
          b1=cgs(1,ic0)+ccii(1,i)
          b2=cgs(2,ic0)+ccii(2,i)
          b3=cgs(3,ic0)+ccii(3,i)
          b4=cgs(1,ic0+1)+ccii(1,i)
          b5=cgs(2,ic0+1)+ccii(2,i)
          b6=cgs(3,ic0+1)+ccii(3,i)
          b7=cgs(1,ic0+2)+ccii(1,i)
          b8=cgs(2,ic0+2)+ccii(2,i)
          b9=cgs(3,ic0+2)+ccii(3,i)
          b10=cgs(1,ic0+iaq)+ccii(1,i)
          b11=cgs(2,ic0+iaq)+ccii(2,i)
          b12=cgs(3,ic0+iaq)+ccii(3,i)
          rab2x=cis1-b1
          rab2y=cis2-b2
          rab2z=cis3-b3
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@FR          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fcj11=rab2x*rab3
C@FR          fcj21=rab2y*rab3
C@FR          fcj31=rab2z*rab3
C@FR          fci11=-fcj11
C@FR          fci21=-fcj21
C@FR          fci31=-fcj31
          rabx=cis10-b10
          raby=cis11-b11
          rabz=cis12-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          fci14=-rabx*rab3
C@FR          fci24=-raby*rab3
C@FR          fci34=-rabz*rab3
C@FR          fcj14=-fci14
C@FR          fcj24=-fci24
C@FR          fcj34=-fci34
          rabx=cis4-b4
          raby=cis5-b5
          rabz=cis6-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fci12=-rabx*rab3
C@FR          fci22=-raby*rab3
C@FR          fci32=-rabz*rab3
C@FR          fcj12=-fci12
C@FR          fcj22=-fci22
C@FR          fcj32=-fci32
          rabx=cis4-b7
          raby=cis5-b8
          rabz=cis6-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj13=+rabx*rab3
C@FR          fcj23=+raby*rab3
C@FR          fcj33=+rabz*rab3
          rabx=cis7-b4
          raby=cis8-b5
          rabz=cis9-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fci13=-rabx*rab3
C@FR          fci23=-raby*rab3
C@FR          fci33=-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=cis7-b7
          raby=cis8-b8
          rabz=cis9-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
          rabx=cis4-b10
          raby=cis5-b11
          rabz=cis6-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=cis7-b10
          raby=cis8-b11
          rabz=cis9-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
C@FR          fcj14=fcj14+rabx*rab3
C@FR          fcj24=fcj24+raby*rab3
C@FR          fcj34=fcj34+rabz*rab3
          rabx=cis10-b4
          raby=cis11-b5
          rabz=cis12-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj12=fcj12+rabx*rab3
C@FR          fcj22=fcj22+raby*rab3
C@FR          fcj32=fcj32+rabz*rab3
          rabx=cis10-b7
          raby=cis11-b8
          rabz=cis12-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
C@FR          fcj13=fcj13+rabx*rab3
C@FR          fcj23=fcj23+raby*rab3
C@FR          fcj33=fcj33+rabz*rab3
c         Calculate interaction energy.
          deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -      qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          texng(i)=deww
C@FRc         2nd loop needs both forces for the virial
C@FR          fi1v=((fci11+fci12)+fci13)+fci14
C@FR          fi2v=((fci21+fci22)+fci23)+fci24
C@FR          fi3v=((fci31+fci32)+fci33)+fci34
C@FR          fj1v=((fcj11+fcj12)+fcj13)+fcj14
C@FR          fj2v=((fcj21+fcj22)+fcj23)+fcj24
C@FR          fj3v=((fcj31+fcj32)+fcj33)+fcj34
c         End of eww routine
C@FR          vircv1=fi1v*zvv(1,i)
C@FR          vircv2=fi2v*zvv(2,i)
C@FR          vircv3=fi3v*zvv(3,i)
C@FRc         The following lines are in lieu of a call to trqwij
C@FR          b1=cgs(1,ic0)
C@FR          b2=cgs(2,ic0)
C@FR          b3=cgs(3,ic0)
C@FR          b4=cgs(1,ic0+1)
C@FR          b5=cgs(2,ic0+1)
C@FR          b6=cgs(3,ic0+1)
C@FR          b7=cgs(1,ic0+2)
C@FR          b8=cgs(2,ic0+2)
C@FR          b9=cgs(3,ic0+2)
C@FR          b10=cgs(1,ic0+iaq)
C@FR          b11=cgs(2,ic0+iaq)
C@FR          b12=cgs(3,ic0+iaq)
C@FR          crmx2=crmgs(1,i)
C@FR          crmy2=crmgs(2,i)
C@FR          crmz2=crmgs(3,i)
C@FRc         Oxygen atom contribution
C@FR          drx2=b1-crmx2
C@FR          dry2=b2-crmy2
C@FR          drz2=b3-crmz2
C@FR          tjxyz1=dry2*fcj31-drz2*fcj21
C@FR          tjxyz2=drz2*fcj11-drx2*fcj31
C@FR          tjxyz3=drx2*fcj21-dry2*fcj11
C@FRc         First hydrogen atom contribution
C@FR          drx2=b4-crmx2
C@FR          dry2=b5-crmy2
C@FR          drz2=b6-crmz2
C@FR          tjxyz1=tjxyz1+dry2*fcj32-drz2*fcj22
C@FR          tjxyz2=tjxyz2+drz2*fcj12-drx2*fcj32
C@FR          tjxyz3=tjxyz3+drx2*fcj22-dry2*fcj12
C@FRc         Second hydrogen atom
C@FR          drx2=b7-crmx2
C@FR          dry2=b8-crmy2
C@FR          drz2=b9-crmz2
C@FR          tjxyz1=tjxyz1+dry2*fcj33-drz2*fcj23
C@FR          tjxyz2=tjxyz2+drz2*fcj13-drx2*fcj33
C@FR          tjxyz3=tjxyz3+drx2*fcj23-dry2*fcj13
C@FRc         "Lone pair"
C@FR          drx2=b10-crmx2
C@FR          dry2=b11-crmy2
C@FR          drz2=b12-crmz2
C@FR          tjxyz1=tjxyz1+dry2*fcj34-drz2*fcj24
C@FR          tjxyz2=tjxyz2+drz2*fcj14-drx2*fcj34
C@FR          tjxyz3=tjxyz3+drx2*fcj24-dry2*fcj14
C@FRc         End of trqwij routine
C@FR          trqng(1,i)=tjxyz1
C@FR          trqng(2,i)=tjxyz2
C@FR          trqng(3,i)=tjxyz3
C@FR          frcng(1,i)=fj1v
C@FR          frcng(2,i)=fj2v
C@FR          frcng(3,i)=fj3v
C@FR          virsco(1)=virsco(1)+vircv1
C@FR          virsco(2)=virsco(2)+vircv2
C@FR          virsco(3)=virsco(3)+vircv3
        end do
      else
c     General solvent
        do i=1,nvmolg
          texngd(i)=0.d0
C@FR          frcng(1,i)=0.0
C@FR          frcng(2,i)=0.0
C@FR          frcng(3,i)=0.0
C@FR          trqng(1,i)=0.0
C@FR          trqng(2,i)=0.0
C@FR          trqng(3,i)=0.0
        end do
C@FR          call zeroit(fcii,3*nslv*nvmolg)
        jc0=ic00+islv*nslv
c       i>is loop
        do i=1,il1
          ic0=(i-1)*nslv
          if (iop(5) .ne. 2) then
            do ja=1,nslv
              cij(1,ja)=c(1,jc0+ja)+ccii(1,i)
              cij(2,ja)=c(2,jc0+ja)+ccii(2,i)
              cij(3,ja)=c(3,jc0+ja)+ccii(3,i)
            end do
          else
            call hcp_rot_trans(crm(1,islv),c(1,jc0+1),cij,1,nslv,
     -        ccii(1,i),ivopt(i),1)
          end if
          do ia=1,nslv
            do ja=1,nslv
              ic0=(i-1)*nslv
              rxyz1v=cgs(1,ic0+ia)-cij(1,ja)
              rxyz2v=cgs(2,ic0+ia)-cij(2,ja)
              rxyz3v=cgs(3,ic0+ia)-cij(3,ja)
              rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
              rij=sqrt(rij2)
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
              er6=c6vv(ja,ia)/rij6
              er12=c12vv(ja,ia)/rij12
              qr=(qvv(ja,ia)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
              texngd(i)=texngd(i)+(dble(er12)-dble(er6)+dble(qr))
C@FR              abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR              fci1=-abcf*rxyz1v
C@FR              fci2=-abcf*rxyz2v
C@FR              fci3=-abcf*rxyz3v
C@FR              virsco(1)=virsco(1)+fci1*zvv(1,i)
C@FR              virsco(2)=virsco(2)+fci2*zvv(2,i)
C@FR              virsco(3)=virsco(3)+fci3*zvv(3,i)
C@FR              fcii(1,ic0+ia)=fcii(1,ic0+ia)+fci1
C@FR              fcii(2,ic0+ia)=fcii(2,ic0+ia)+fci2
C@FR              fcii(3,ic0+ia)=fcii(3,ic0+ia)+fci3
C@FR              frcng(1,i)=frcng(1,i)+fci1
C@FR              frcng(2,i)=frcng(2,i)+fci2
C@FR              frcng(3,i)=frcng(3,i)+fci3
            end do
          end do
        end do
c       i>is loop
        do i=if2,il2
          ic0=(i-1)*nslv
          if (iop(5) .ne. 2) then
            do ia=1,nslv
              cij(1,ia)=cgs(1,ic0+ia)+ccii(1,i)
              cij(2,ia)=cgs(2,ic0+ia)+ccii(2,i)
              cij(3,ia)=cgs(3,ic0+ia)+ccii(3,i)
            end do
          else
            call hcp_rot_trans(crmgs(1,i),cgs(1,ic0+1),cij,1,nslv,
     -        ccii(1,i),ivopt(i),1)
          end if
          do ia=1,nslv
            do ja=1,nslv
              rxyz1v=c(1,jc0+ja)-cij(1,ia)
              rxyz2v=c(2,jc0+ja)-cij(2,ia)
              rxyz3v=c(3,jc0+ja)-cij(3,ia)
              rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
              rij=sqrt(rij2)
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
              er6=c6vv(ja,ia)/rij6
              er12=c12vv(ja,ia)/rij12
              qr=qvv(ja,ia)/rij
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
              texngd(i)=texngd(i)+(dble(er12)-dble(er6)+dble(qr))
C@FR              abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR              fci1=-abcf*rxyz1v
C@FR              fci2=-abcf*rxyz2v
C@FR              fci3=-abcf*rxyz3v
C@FR              virsco(1)=virsco(1)+fci1*zvv(1,i)
C@FR              virsco(2)=virsco(2)+fci2*zvv(2,i)
C@FR              virsco(3)=virsco(3)+fci3*zvv(3,i)
C@FR              fcii(1,ic0+ia)=fcii(1,ic0+ia)-fci1
C@FR              fcii(2,ic0+ia)=fcii(2,ic0+ia)-fci2
C@FR              fcii(3,ic0+ia)=fcii(3,ic0+ia)-fci3
C@FR              frcng(1,i)=frcng(1,i)-fci1
C@FR              frcng(2,i)=frcng(2,i)-fci2
C@FR              frcng(3,i)=frcng(3,i)-fci3
            end do
          end do
        end do
        do i=1,nvmolg
          texng(i)=texngd(i)
C@FRc         Now calculate torques
C@FR          trqii1=0.0
C@FR          trqii2=0.0
C@FR          trqii3=0.0
C@FR          ic0=(i-1)*nslv
C@FR          do ia=1,nslv
C@FR            trqii1=trqii1+(cgs(2,ic0+ia)-crmgs(2,i))*fcii(3,ic0+ia)-
C@FR     -             (cgs(3,ic0+ia)-crmgs(3,i))*fcii(2,ic0+ia)
C@FR            trqii2=trqii2+(cgs(3,ic0+ia)-crmgs(3,i))*fcii(1,ic0+ia)-
C@FR     -             (cgs(1,ic0+ia)-crmgs(1,i))*fcii(3,ic0+ia)
C@FR            trqii3=trqii3+(cgs(1,ic0+ia)-crmgs(1,i))*fcii(2,ic0+ia)-
C@FR     -             (cgs(2,ic0+ia)-crmgs(2,i))*fcii(1,ic0+ia)
C@FR          end do
C@FR          trqng(1,i)=trqii1
C@FR          trqng(2,i)=trqii2
C@FR          trqng(3,i)=trqii3
        end do
      end if
c     Scatter the results back to their proper place
      do i=1,nvmolg
        inxi=indexx(i)
        texo(inxi)=texng(i)
        niso(inxi)=nisoo(i)
C@FR        do k=1,3
C@FR          frco(k,inxi)=frcng(k,i)
C@FR          trqo(k,inxi)=trqng(k,i)
C@FR        end do
      end do
9100  if (nnear .eq. 0) return
c     Take care of close contacts by calling the unvectorized routines
      do ii=1,nnear
        i=ixnear(ii)
        z1=crmis(1)-crm(1,i)
        z2=crmis(2)-crm(2,i)
        z3=crmis(3)-crm(3,i)
        call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
        x=eww(i,islv,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
     -    riijj,c,crm)
        texo(i)=x
C@FR        virc(1)=frixyz(1)*z1
C@FR        virc(2)=frixyz(2)*z2
C@FR        virc(3)=frixyz(3)*z3
C@FR        ic0=ic01+i*nslv
C@FR        if (iop(39) .gt. 1) then
C@FR          call torque(c(1,ic0),crm(1,i),fcislv,1,nslvsv,trixyz,i)
C@FR          call torque(c(1,isc0),crm(1,islv),fcjslv,1,nslvsv,trjxyz,islv)
C@FR        else
C@FR          call trqwij(c(1,ic0),c(1,isc0),crm(1,i),crm(1,islv),nslvsv)
C@FR        end if
C@FR        do k=1,3
C@FR          trqo(k,i)=trixyz(k)
C@FR          frco(k,i)=frixyz(k)
C@FR          virsco(k)=virsco(k)+virc(k)
C@FR        end do
      end do
      return
      end
      subroutine getevy(islv,c,crm)
c#    MMC routine 133 lstmod: 05/23/21
c*****Cray vectorized version of getegy
      dimension c(3,#NA),crm(3,#MO)
      common /ecell/ cic(3,27),ncell
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /option/ iop(200),idebug(200)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      real*8 texngd
      common /gatherd/ texngd(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
C@FR      common /fciis/ fcii(3,#NA),fcis(3,#NA)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /cutinr/ rwwina,rwwin2
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      dimension crmis(3),cij(3,#SV)
      texo(1)=texslt(islv)
      do k=1,3
        crmis(k)=crm(k,islv)
      end do
      isc0=ic01+islv*nslv
      cis1=c(1,isc0)
      cis2=c(2,isc0)
      cis3=c(3,isc0)
      cis4=c(1,isc0+1)
      cis5=c(2,isc0+1)
      cis6=c(3,isc0+1)
      cis7=c(1,isc0+2)
      cis8=c(2,isc0+2)
      cis9=c(3,isc0+2)
      cis10=c(1,isc0+iaq)
      cis11=c(2,isc0+iaq)
      cis12=c(3,isc0+iaq)
c     Get the PBC calculations first
c     Collect indices for solvents close enough
      ic=0
      do i=2,islv-1
        if (nis(i) .lt. mxcslv) then
          ic=ic+1
          indexx(ic)=i
        end if
      end do
      do i=islv+1,nmolec
        if (nis(i) .lt. mxcslv) then
          ic=ic+1
          indexx(ic)=i
        end if
      end do
      nvmolg=ic
      if (nvmolg .eq. 0) return
c     Collect the COM's belonging to the indices
      do ic=1,nvmolg
        i=indexx(ic)
        zv(1,ic)=crmis(1)-crm(1,i)
        zv(2,ic)=crmis(2)-crm(2,i)
        zv(3,ic)=crmis(3)-crm(3,i)
      end do
      call pbcvec(iop(5),1,nvmolg)
c     Now collect the indices for the ones within cutoff distance
      ic=0
      nnear=0
      do i=1,nvmolg
        if (riijjv(i) .le. ctslvs) then
          if (riijjv(i) .le. rwwin2) then
c           Close contact found
            nnear=nnear+1
            ixnear(nnear)=indexx(i)
          else
            ic=ic+1
            inxi=indexx(i)
            indexx(ic)=inxi
            indexn(ic)=i
          end if
        end if
      end do
      nvmolg=ic
      if (nvmolg .eq. 0) then
        if (nnear .gt. 0) go to 9100
        return
      end if
c     Perform the actual gathering of the molecular info
      do ic=1,nvmolg
        i=indexn(ic)
        ccii(1,ic)=cci(1,i)
        ccii(2,ic)=cci(2,i)
        ccii(3,ic)=cci(3,i)
        zvv(1,ic)=zv(1,i)
        zvv(2,ic)=zv(2,i)
        zvv(3,ic)=zv(3,i)
        nisoo(ic)=int(sqrt(riijjv(i))*rri)+1
        ivopt(ic)=ivopt(i)
      end do
      do ic=1,nvmolg
        i=indexx(ic)
        crmgs(1,ic)=crm(1,i)
        crmgs(2,ic)=crm(2,i)
        crmgs(3,ic)=crm(3,i)
      end do
      do k=1,nslvsv
        do ic=1,nvmolg
          i=ic00+indexx(ic)*nslv+k
          cgs(1,(ic-1)*nslvsv+k)=c(1,i)
          cgs(2,(ic-1)*nslvsv+k)=c(2,i)
          cgs(3,(ic-1)*nslvsv+k)=c(3,i)
        end do
      end do
      if (iop(26) .lt. 4) then
        do i=1,nvmolg
c---------TIP3P or TIP4P water (or variants)
          b1=cis1+ccii(1,i)
          b2=cis2+ccii(2,i)
          b3=cis3+ccii(3,i)
          b4=cis4+ccii(1,i)
          b5=cis5+ccii(2,i)
          b6=cis6+ccii(3,i)
          b7=cis7+ccii(1,i)
          b8=cis8+ccii(2,i)
          b9=cis9+ccii(3,i)
          b10=cis10+ccii(1,i)
          b11=cis11+ccii(2,i)
          b12=cis12+ccii(3,i)
          ic0=(i-1)*nslvsv+1
          a1=cgs(1,ic0)
          a2=cgs(2,ic0)
          a3=cgs(3,ic0)
          a4=cgs(1,ic0+1)
          a5=cgs(2,ic0+1)
          a6=cgs(3,ic0+1)
          a7=cgs(1,ic0+2)
          a8=cgs(2,ic0+2)
          a9=cgs(3,ic0+2)
          a10=cgs(1,ic0+iaq)
          a11=cgs(2,ic0+iaq)
          a12=cgs(3,ic0+iaq)
          rab2x=a1-b1
          rab2y=a2-b2
          rab2z=a3-b3
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
          fcj11=rab2x*rab3
          fcj21=rab2y*rab3
          fcj31=rab2z*rab3
          fci11=-fcj11
          fci21=-fcj21
          fci31=-fcj31
          rabx=a10-b10
          raby=a11-b11
          rabz=a12-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          fci14=-rabx*rab3
C@FR          fci24=-raby*rab3
C@FR          fci34=-rabz*rab3
          rabx=a4-b4
          raby=a5-b5
          rabz=a6-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fci12=-rabx*rab3
C@FR          fci22=-raby*rab3
C@FR          fci32=-rabz*rab3
          rabx=a4-b7
          raby=a5-b8
          rabz=a6-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
          rabx=a7-b4
          raby=a8-b5
          rabz=a9-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fci13=-rabx*rab3
C@FR          fci23=-raby*rab3
C@FR          fci33=-rabz*rab3
          rabx=a7-b7
          raby=a8-b8
          rabz=a9-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
          rabx=a4-b10
          raby=a5-b11
          rabz=a6-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fci12=fci12-rabx*rab3
C@FR          fci22=fci22-raby*rab3
C@FR          fci32=fci32-rabz*rab3
          rabx=a7-b10
          raby=a8-b11
          rabz=a9-b12
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fci13=fci13-rabx*rab3
C@FR          fci23=fci23-raby*rab3
C@FR          fci33=fci33-rabz*rab3
          rabx=a10-b4
          raby=a11-b5
          rabz=a12-b6
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
          rabx=a10-b7
          raby=a11-b8
          rabz=a12-b9
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fci14=fci14-rabx*rab3
C@FR          fci24=fci24-raby*rab3
C@FR          fci34=fci34-rabz*rab3
c         Calculate interaction energy.
          deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -      qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          texng(i)=deww
C@FR          fi1v=fci11+fci12+fci13+fci14
C@FR          fi2v=fci21+fci22+fci23+fci24
C@FR          fi3v=fci31+fci32+fci33+fci34
c         End of eww subroutine
C@FR          vircv1=fi1v*zvv(1,i)
C@FR          vircv2=fi2v*zvv(2,i)
C@FR          vircv3=fi3v*zvv(3,i)
c         The following lines are in lieu of a call to trqwij
C@FR          crmx1=crmgs(1,i)
C@FR          crmy1=crmgs(2,i)
C@FR          crmz1=crmgs(3,i)
C@FRc         Oxygen atom contribution
C@FR          drx1=a1-crmx1
C@FR          dry1=a2-crmy1
C@FR          drz1=a3-crmz1
C@FR          tixyz1=dry1*fci31-drz1*fci21
C@FR          tixyz2=drz1*fci11-drx1*fci31
C@FR          tixyz3=drx1*fci21-dry1*fci11
C@FRc         First hydrogen atom contribution
C@FR          drx1=a4-crmx1
C@FR          dry1=a5-crmy1
C@FR          drz1=a6-crmz1
C@FR          tixyz1=tixyz1+dry1*fci32-drz1*fci22
C@FR          tixyz2=tixyz2+drz1*fci12-drx1*fci32
C@FR          tixyz3=tixyz3+drx1*fci22-dry1*fci12
C@FRc         Second hydrogen atom
C@FR          drx1=a7-crmx1
C@FR          dry1=a8-crmy1
C@FR          drz1=a9-crmz1
C@FR          tixyz1=tixyz1+dry1*fci33-drz1*fci23
C@FR          tixyz2=tixyz2+drz1*fci13-drx1*fci33
C@FR          tixyz3=tixyz3+drx1*fci23-dry1*fci13
C@FRc         "Lone pair"
C@FR          drx1=a10-crmx1
C@FR          dry1=a11-crmy1
C@FR          drz1=a12-crmz1
C@FR          tixyz1=tixyz1+dry1*fci34-drz1*fci24
C@FR          tixyz2=tixyz2+drz1*fci14-drx1*fci34
C@FR          tixyz3=tixyz3+drx1*fci24-dry1*fci14
C@FRc         End of trqwij routine
C@FR          trqng(1,i)=tixyz1
C@FR          trqng(2,i)=tixyz2
C@FR          trqng(3,i)=tixyz3
C@FR          frcng(1,i)=fi1v
C@FR          frcng(2,i)=fi2v
C@FR          frcng(3,i)=fi3v
C@FR          virsco(1)=virsco(1)+vircv1
C@FR          virsco(2)=virsco(2)+vircv2
C@FR          virsco(3)=virsco(3)+vircv3
        end do
       else
c       General solvent
        do i=1,nvmolg
          texngd(i)=0.d0
C@FR          frcng(1,i)=0.0
C@FR          frcng(2,i)=0.0
C@FR          frcng(3,i)=0.0
C@FR          trqng(1,i)=0.0
C@FR          trqng(2,i)=0.0
C@FR          trqng(3,i)=0.0
        end do
C@FR        call zeroit(fcii,3*nslv*nvmolg)
        jc0=ic00+islv*nslv
        do i=1,nvmolg
          ic0=(i-1)*nslv
          if (iop(5) .ne. 2) then
            do ja=1,nslv
              cij(1,ja)=c(1,jc0+ja)+ccii(1,i)
              cij(2,ja)=c(2,jc0+ja)+ccii(2,i)
              cij(3,ja)=c(3,jc0+ja)+ccii(3,i)
            end do
          else
            call hcp_rot_trans(crm(1,islv),c(1,jc0+1),cij,1,nslv,
     -        ccii(1,i),ivopt(i),1)
          end if
          do ia=1,nslv
            do ja=1,nslv
              ic0=(i-1)*nslv
              rxyz1v=cgs(1,ic0+ia)-cij(1,ja)
              rxyz2v=cgs(2,ic0+ia)-cij(2,ja)
              rxyz3v=cgs(3,ic0+ia)-cij(3,ja)
              rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
              rij=sqrt(rij2)
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
              er6=c6vv(ja,ia)/rij6
              er12=c12vv(ja,ia)/rij12
              qr=(qvv(ja,ia)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
              texngd(i)=texngd(i)+(dble(er12)-dble(er6)+dble(qr))
C@FR              abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR              fci1=-abcf*rxyz1v
C@FR              fci2=-abcf*rxyz2v
C@FR              fci3=-abcf*rxyz3v
C@FR              virsco(1)=virsco(1)+fci1*zvv(1,i)
C@FR              virsco(2)=virsco(2)+fci2*zvv(2,i)
C@FR              virsco(3)=virsco(3)+fci3*zvv(3,i)
C@FR              fcii(1,ic0+ia)=fcii(1,ic0+ia)+fci1
C@FR              fcii(2,ic0+ia)=fcii(2,ic0+ia)+fci2
C@FR              fcii(3,ic0+ia)=fcii(3,ic0+ia)+fci3
C@FR              frcng(1,i)=frcng(1,i)+fci1
C@FR              frcng(2,i)=frcng(2,i)+fci2
C@FR              frcng(3,i)=frcng(3,i)+fci3
            end do
          end do
        end do
        do i=1,nvmolg
          texng(i)=texngd(i)
C@FRc         Now calculate torques
C@FR          trqii1=0.0
C@FR          trqii2=0.0
C@FR          trqii3=0.0
C@FR          ic0=(i-1)*nslv
C@FR          do ia=1,nslv
C@FR            trqii1=trqii1+(cgs(2,ic0+ia)-crmgs(2,i))*fcii(3,ic0+ia)-
C@FR     -             (cgs(3,ic0+ia)-crmgs(3,i))*fcii(2,ic0+ia)
C@FR            trqii2=trqii2+(cgs(3,ic0+ia)-crmgs(3,i))*fcii(1,ic0+ia)-
C@FR     -             (cgs(1,ic0+ia)-crmgs(1,i))*fcii(3,ic0+ia)
C@FR            trqii3=trqii3+(cgs(1,ic0+ia)-crmgs(1,i))*fcii(2,ic0+ia)-
C@FR     -             (cgs(2,ic0+ia)-crmgs(2,i))*fcii(1,ic0+ia)
C@FR          end do
C@FR          trqng(1,i)=trqii1
C@FR          trqng(2,i)=trqii2
C@FR          trqng(3,i)=trqii3
        end do
      end if
c     Scatter the results back to their proper place
      do i=1,nvmolg
        inxi=indexx(i)
        texo(inxi)=texng(i)
        niso(inxi)=nisoo(i)
C@FR        do k=1,3
C@FR          frco(k,inxi)=frcng(k,i)
C@FR          trqo(k,inxi)=trqng(k,i)
C@FR        end do
      end do
      if (nnear .eq. 0) return
c     Take care of close contacts by calling the unvectorized routines
9100  do ii=1,nnear
        i=ixnear(ii)
        z1=crmis(1)-crm(1,i)
        z2=crmis(2)-crm(2,i)
        z3=crmis(3)-crm(3,i)
        call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
        x=eww(i,islv,iopt,cic(1,iopt),cic(2,iopt),cic(3,iopt),
     -    riijj,c,crm)
        texo(i)=x
C@FR        virc(1)=frixyz(1)*z1
C@FR        virc(2)=frixyz(2)*z2
C@FR        virc(3)=frixyz(3)*z3
C@FR        ic0=ic01+i*nslv
C@FR        if (iop(39) .gt. 1) then
C@FR          call torque(c(1,ic0),crm(1,i),fcislv,1,nslvsv,trixyz,i)
C@FR          call torque(c(1,isc0),crm(1,islv),fcjslv,1,nslvsv,trjxyz,islv)
C@FR        else
C@FR          call trqwij(c(1,ic0),c(1,isc0),crm(1,i),crm(1,islv),nslvsv)
C@FR        end if
C@FR        do k=1,3
C@FR          trqo(k,i)=trixyz(k)
C@FR          frco(k,i)=frixyz(k)
C@FR          virsco(k)=virsco(k)+virc(k)
C@FR        end do
      end do
      return
      end
      subroutine selectmol
c#    MMC routine 134 lstmod: 11/08/00
c*****Select the molecule to be moved
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /shuffl/ isser,isserpd,isserpt,itry(#MO),
     -  itrypd(#MM),itrypt(#MM)
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      common /option/ iop(200),idebug(200)
      real*8 drno
      dimension drno(1)
      movtyp=1
      if (nsltfreq .ne. 0) then
c       See if solute is to be moved
        if (mod(nmc,min0(nmolec,nsltfreq)) .eq. 0) then
c         Save isolv into isolvc for cyclic selection
          isolvc=isolv
          isolv=1
c         icsol1: index in c of the first atom of the molecule perturbed.
c         natm3: number of coordinates describing the molecule perturbed.
          icsol1=1
          natm3=nstta3
c         Solute move type selection
          call mmc_random(1,drno)
          if (drno(1) .le. wslttry(1)) then
            movtyp=1
          else if (drno(1) .le. wslttry(2)) then
            movtyp=2
          else if (drno(1) .le. wslttry(3)) then
            movtyp=3
          else if (drno(1) .le. wslttry(4)) then
            movtyp=4
          else if (drno(1) .le. wslttry(5)) then
            movtyp=5
          else if (drno(1) .le. wslttry(6)) then
            movtyp=6
          else
            movtyp=7
          end if
          return
        end if
      end if
c     Move a molecule
      if (iop(12) .eq. 0) then
c       Random selection
        call mmc_random(1,drno)
        isolv=drno(1)*(nmolec-mvfst+1)+mvfst
      else if (iop(12) .eq. 1 .or. iop(12) .eq. 3) then
c       Cyclic selections
        if (isolvc .ne. 0) then
c         Cycle was interrupted by a solute move
          isolv=isolvc
          isolvc=0
        else
          if (iop(12) .eq. 1) then
            isolv=isolv+1
            if (isolv .gt. nmolec) isolv=mvfst
          else
            isolv=isolv-1
            if (isolv .lt. mvfst) isolv=nmolec
          end if
        end if
      else if (iop(12) .eq. 2) then
        call shuffle(itry,mvfst,nmolec,isser,isolv)
      else
c       Preferential sampling
        call pfsel(isolv,wpsmvsum,wpsmv,wpfpsmv,limpsmv,
     -    mvfst,nmolec,npfsmv)
      end if
      if (isolv .eq. 1) then
        natm3=nstta3
        icsol1=1
      else
        natm3=3*nslv
        icsol1=ic01+isolv*nslv
      end if
      return
      end
      subroutine shuffle(indexlist,ifirst,max,left,ix)
c#    MMC routine 135 lstmod: 12/07/97
      dimension indexlist(max)
c*****Shuffled cyclic selection
c     indexlist is the array of available indices
c     left is the number of indices still available in indexlist
      real*8 drno
      dimension drno(1)
      if (left .eq. 0) then
        call indexit(indexlist,ifirst,max,0)
        left=max-ifirst+1
      end if
      is0=max-left+1
c     is0 is the first available index in indexlist
      call mmc_random(1,drno)
      is1=is0+drno(1)*left
c     is1 is the index chosen
      ix=indexlist(is1)
c     Replace the index used with the first one available
      indexlist(is1)=indexlist(is0)
      left=left-1
      return
      end
      subroutine pfsel(is,wpsmax,wpf,wpfps,limps,ifirst,n,nps)
c#    MMC routine 136 lstmod: 04/13/97
c*****Make a selection from a tabulated distribution (normalized to 1)
c     Selected item: is; its weight: wpf(is)
      dimension wpf(n),wpfps(nps),limps(nps)
      real*8 wpfps,wpsmax,drno
      dimension drno(1)
      call mmc_random(1,drno)
      rno=drno(1)*wpsmax
      do i=1,nps
        if (rno .le. wpfps(i)) then
c         Find selection in this segment
          if (i .eq. 1) then
            j0=ifirst
            sum=0.d0
          else
            j0=limps(i-1)+1
            sum=wpfps(i-1)
          end if
          do j=j0,limps(i)
            sum=sum+wpf(j)
            if (sum .ge. rno) then
              is=j
              return
            end if
          end do
        end if
      end do
      is=n
C@DB      if (dabs((sum-wpfps(nps))/(sum+wpfps(nps)) .gt. 1.e-5) then
C@DB         print *,'***** ERROR in pfsel  psw sum=',sum,' wpsps sum=',
C@DB     -   wpfps(nps)
C@DB      end if
      return
      end
      subroutine pfpsumup(wpsnew,is,wpf,wpfps,wpssum,ips,nps)
c#    MMC routine 137 lstmod: 02/27/96
c*****Update the values of the partial weight sums and the weight sum
      dimension wpf(#MO),wpfps(nps),ips(#MO)
      real*8 wpfps,wpssum,diff
      diff=wpsnew-wpf(is)
      wpssum=wpssum+diff
      i0=ips(is)
      do i=i0,nps
        wpfps(i)=wpfps(i)+diff
      end do
      wpf(is)=wpsnew
      return
      end
      function torcha(dr,step,ndim)
c#    MMC routine 138 lstmod: 09/01/03
c*****Generate angle change with different distributions
      real*8 dr,d,drno(3)
      if (ndim .eq. 1) then
c       Generate step uniformly within [-step/2,step/2]
        torcha=(dr-0.5d0)*step
      else
c       Generate step biased toward larger magnitudes
        call mmc_random(ndim,drno)
        d=0.d0
        do k=1,ndim
          d=d+drno(k)**2
        end do
        dfac=dsqrt(d)
        torcha=step*dfac/2.0
        if (dr .gt. 0.5d0) torcha=-torcha
      end if
      return
      end
      subroutine skewtors(torch,targetang,dihang,w,it,LEVTEST)
c#    MMC routine 138/a lstmod: 08/26/08
c*****Bias the change in the direction to targetang with weight w
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      dimension rno(1)
      call randpx(1,rno)
      torch0=torch
      if (rno(1) .gt. w) then
c       Move toward target
        itoward=1
      else
c       Move away from target
        itoward=0
      end if
      if (targetang .ge. 0.0 .and. dihang .ge. 0.0) then
        if (itoward .eq. 1) then
          if (torch*(targetang-dihang) .lt. 0.0) torch=-torch
        else
          if (torch*(targetang-dihang) .gt. 0.0) torch=-torch
        end if
      else if (targetang .le. 0.0 .and. dihang .le. 0.0) then
        if (itoward .eq. 1) then
          if (torch*(targetang-dihang) .lt. 0.0) torch=-torch
        else
          if (torch*(targetang-dihang) .gt. 0.0) torch=-torch
        end if
      else if (targetang .ge. 0.0 .and. dihang .le. 0.0) then
        if (pi-targetang+dihang .lt. 0.0) then
          if ((itoward .eq. 1 .and. torch .lt. 0.0) .or.
     -        (itoward .eq. 0 .and. torch .gt. 0.0)) torch=-torch
        else
          if ((itoward .eq. 1 .and. torch .gt. 0.0) .or.
     -        (itoward .eq. 0 .and. torch .lt. 0.0)) torch=-torch
        end if
      else if (targetang .le. 0.0 .and. dihang .ge. 0.0) then
        if (pi+targetang-dihang .lt. 0.0) then
          if ((itoward .eq. 1 .and. torch .lt. 0.0) .or.
     -        (itoward .eq. 0 .and. torch .gt. 0.0)) torch=-torch
        else
          if ((itoward .eq. 1 .and. torch .gt. 0.0) .or.
     -        (itoward .eq. 0 .and. torch .lt. 0.0)) torch=-torch
        end if
      end if
      if (LEVTEST .gt. 0) write (6,1000) it,w,itoward,dihang*rdtodg,
     -  targetang*rdtodg,torch*rdtodg,torch0*rdtodg
      return
1000  format(' it=',i5,' 1/w=',f8.5,' itoward=',i2,' dihang=',f12.2,
     -  ' targetang=',f8.2,' torch(final,original)=',2f12.2,' deg')
      end
      subroutine skewloop(c,r234,nsol,looplist,targetang,
     -  iskew,iquata,it,i0,i1,i5,i6,ispicked,LEVTEST,iout,maxtors)
c#    MMC routine 138/b lstmod: 08/10/08
c*****Bias the solution selection in the direction to targetang with weight w
      real*8 r234
      dimension c(3,#NA),r234(3,4,32),targetang(maxtors),
     -  looplist(6),iquata(#TR,4),iskew(maxtors)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dd(3,9)
      if (levtest .gt. 0) write (iout,1000) it,looplist
      tdistmin=10000.0
      do k=1,3
        dd(k,1)=c(k,iquata(it,2))
        dd(k,2)=c(k,i0)
        dd(k,3)=c(k,i1)
        dd(k,7)=c(k,i5)
        dd(k,8)=c(k,i6)
        dd(k,9)=c(k,iquata(looplist(6),4))
      end do
      do is=1,nsol
        do k=1,3
          dd(k,4)=r234(k,2,is)
          dd(k,5)=r234(k,3,is)
          dd(k,6)=r234(k,4,is)
        end do
c       Calculate the new torsion angles from d*
        tdist=0.0
        do itl=1,6
          if (iskew(looplist(itl)) .eq. 1) then
            dihl=dihangld(dd(1,itl),dd(1,itl+1),dd(1,itl+2),dd(1,itl+3),
     -       LEVTEST,iout)
            tdist=tdist+amin1((dihl-targetang(looplist(itl)))**2,
     -        (dihl-targetang(looplist(itl))+pi2)**2,
     -        (dihl-targetang(looplist(itl))-pi2)**2)
            if (LEVTEST .gt. 0) write (iout,1002) is,itl,looplist(itl),
     -        targetang(looplist(itl))*rdtodg,dihl*rdtodg,
     -        tdist*rdtodg**2
          end if
        end do
        if (tdist .lt. tdistmin) then
          tdistmin=tdist
          ispicked=is
        end if
      end do
      if (LEVTEST .gt. 0) write (iout,1001) tdistmin*rdtodg**2,ispicked
      return
1000  format(' SKEWLOOP it=',i5,' looplist=',6i6)
1001  format(' min dev=',e12.5,' ispicked=',i2)
1002  format(' Solution #',i2,' Looplist(',i1,')=',i5,' target=',f8.2,
     -  ' dih=',f8.2,'tdist=',e12.5)
      end
      subroutine checkskewtors(iskew,step,wskewstepmin,resumefac,dihang,
     -  it,LEVTEST,iout)
c#    MMC routine 138/c lstmod: 09/15/08
c*****Suspend or reinstate the bias depending on the stepsize
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      if (iskew .gt. 0) then
        if (iskew .eq. 1) then
c         Suspend skewing
          if (step .lt. wskewstepmin) iskew=2
          if (LEVTEST .gt. 0 .and. iskew .eq. 2)
     -      write (iout,1000) it,'suspended',dihang*rdtodg
        else
c         Resume skewing
          if (step .gt. resumefac*wskewstepmin) iskew=1
          if (LEVTEST .gt. 0 .and. iskew .eq. 1)
     -      write (iout,1000) it,'resumed',dihang*rdtodg
        end if
      end if
      return
1000  format(' Skewed sampling for torsion',i6,' has been ',a,
     - ', current torsion angle=',f8.2,' deg')
      end
      subroutine checktorlim(ta,ta0,tadevmax,ptaccfac,irejtyp)
c#    MMC routine 138/b lstmod: 03/22/07
c*****Check if torsion angle stayed within its limits (if any)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      irejtyp=0
      if (tadevmax .gt. 0.0) then
        dev=abs(ta-ta0)
        dev0=dev
        dev1=abs(dev-pi2)
        if (dev1 .lt. dev) dev=dev1
        if (dev .gt. tadevmax) then
          irejtyp=4
          ptaccfac=0.0
        end if
      end if
      return
      end
      subroutine deploy(orient,c,crm,ch,phi,iax0)
c#    MMC routine 139 lstmod: 02/04/11
c*****Generate the trial displacement and rotation of the isolv-th molec.
      dimension c(3,#NA),orient(3,3,#MO),crm(3,#MO),ch(3)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /ecell/ cic(3,27),ncell
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /fblam/ wfblam(#PG),rfblam(9),afblam(9),nfblam
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /cage/ delc(3,#MO),deln(3)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /option/ iop(200),idebug(200)
      real*8 drno,cdf,cio,cr,caf,cio4
      dimension drno(5)
      real*8 cisod,frcito,trqito
      common /dptobs/ frcito(3),trqito(3),cisod,beta2l,iop6,kminis
      common /cellshift/ ncross(27)
      dimension rot(3,3)
C@DMC@FR      real*8 ft_inp(6)
C@NN      dimension crmis(3)
C@NNC@NL      logical mapbis
CFPP$ EXPAND(PBCND,COFMS)
      itormov=0
      iop6=iop(6)
      ialt=0
      if (iop(44) .gt. 0) then
        if (isolv .eq. 1) then
          if ((iop(44) .eq. 1 .or. iop(44) .eq. 3)
     -        .and. rtxslt .gt. 0.0) ialt=1
        else
          if (iop(44) .gt. 1) ialt=1
        end if
      end if
      if (ialt .gt. 0) then
c       if (mod(npckd(isolv),2) .eq. 1) then
        call mmc_random(1,drno)
        if (drno(1) .lt. wslvdisp) then
          norot=1
          notrans=0
        else
          notrans=1
          norot=0
        end if
      else
        norot=0
        notrans=0
      end if
      if (idebug(91) .gt. 0)
     -  write (iout,1000) 'sta',isolv,(crm(k,isolv),k=1,3),ch,
     -    phi*rdtodg,notrans,norot,0
      call mmc_random(5,drno)
      if (isolv .gt. 1) then
c       Solvent moved
        rtax=rtxslv
        cdgs=cedslv
        cdbt2=cd1bt2
        rabt2=ra1bt2
        kminis=1
        call trnsfr(cslvo,c(1,icsol1),natm3)
        if (idebug(91) .gt. 1) write (iout,1001) (ia,(c(k,ia),
     -    k=1,3),ia=nstta+(isolv-2)*nslv+1,nstta+(isolv-1)*nslv)
      else
c       Solute moved
        if (iop(2) .eq. 1) iaxis=1
c       Periodic solute can b rotated only along the x axis
        rtax=rtxslt
        cdgs=cedslt
        cdbt2=cd0bt2
        rabt2=ra0bt2
        kminis=kxmn
        if (rtxslt .eq. 0.0) norot=1
        ch(1)=0.0
        if (iop(19) .eq. 1 .and. iop6 .ge. 5) iop6=0
        if (iop6 .eq. 6) iop6=5
c       crmi,cslto/cslvo: before perturbation coordinates of the
c       molecular COM and atoms.
        call trnsfr(cslto,c(1,icsol1),natm3)
      end if
      call trnsfr(crmi,crm(1,isolv),3)
c     iaxis: rotation axis chosen.
      if (iax0 .gt. 0) then
c-------ch and phi determined before deploy call
        iaxis=iax0
      else
        iaxis=drno(5)*3+1
        phi=0.0
        if (iop6 .eq. 5 .or. iop6 .eq. 6) then
c         Force biased
c         Truncate forces, torques, if necessary
C@ND          do k=1,3
C@ND            frcito(k)=frctot(k,isolv)
C@ND            trqito(k)=trqtot(k,isolv)
C@ND          end do
C@DMC@FR          call trnsfrd(ft_inp,frctot(1,isolv),3)
C@DMC@FR          call trnsfrd(ft_inp(4),trqtot(1,isolv),3)
C@DMC@FR          call MPI_Bcast(ft_inp,6,MPI_DOUBLE_PRECISION,icpuslv(isolv)-1,
C@DMC@FR     -      MPI_COMM_WORLD,ierr)
C@DMC@FR          call trnsfrd(frcito,ft_inp,3)
C@DMC@FR          call trnsfrd(trqito,ft_inp(4),3)
c         kut: counter of force/torque cuts for this move.
          kut=0
          if (notrans .eq. 0) call ftcut(frcito,frcmax,kut)
          if (norot .eq. 0) call ftcut(trqito,trqmax,kut)
c         Switch to Metropolis if cut was needed (can be enhanced later!)
          if (kut*kuttyp .gt. 0) then
            iop6=0
          else
c           cisod: FB distribution normalization const before the perturbation
            cisod=1.d0
            if (iop6 .eq. 5) then
c-------------Force biased (with inversion technique)
              if (notrans .eq. 0) then
                do k=kminis,3
                  cdf=cdbt2*frcito(k)
                  cio=beta4*frcito(k)/dsinh(cdf)
                  cisod=cisod*cio
                  cr=drno(k)*beta2*frcito(k)/cio
                  ch(k)=dlog(dexp(-cdf)+cr)/(beta2*frcito(k))
                end do
              end if
              if (norot .eq. 0) then
                caf=rabt2*trqito(iaxis)
                cio4=beta4*trqito(iaxis)/dsinh(caf)
                cisod=cisod*cio4
                cr=drno(4)*beta2*trqito(iaxis)/cio4
                phi=dlog(dexp(-caf)+cr)/(beta2*trqito(iaxis))
              end if
            else
c-------------Force biased with (inversion technique), scaled with slt-slv dist
c             Scale with FB intensity
              rlamfc=prfwgt(nslvds(isolv),wfblam,0)
              beta2l=beta2*rlamfc
              beta4l=beta4*rlamfc
              if (notrans .eq. 0) then
                cdbt2l=cdbt2*rlamfc
                do k=kminis,3
                  cdf=cdbt2l*frcito(k)
                  cio=beta4l*frcito(k)/dsinh(cdf)
                  cisod=cisod*cio
                  cr=drno(k)*beta2l*frcito(k)/cio
                  ch(k)=dlog(dexp(-cdf)+cr)/(beta2l*frcito(k))
                end do
              end if
              if (norot .eq. 0) then
                rabt2l=rabt2*rlamfc
                caf=rabt2l*trqito(iaxis)
                cio4=beta4l*trqito(iaxis)/dsinh(caf)
                cisod=cisod*cio4
                cr=drno(4)*beta2l*trqito(iaxis)/cio4
                phi=dlog(dexp(-caf)+cr)/(beta2l*trqito(iaxis))
              end if
            end if
          end if
        end if
        if (iop6 .lt. 5) then
c---------Regular Metropolis
          if (notrans .eq. 0) then
            if (iop6 .eq. 0) then
              do k=kminis,3
                ch(k)=(drno(k)-0.5)*cdgs
              end do
            else if (iop6 .eq. 1) then
c             Accept only if the move is inside the sphere
              do while ((drno(1)-0.5)**2+(drno(2)-0.5)**2+
     -                  (drno(3)-0.5)**2 .gt. 0.25)
                call mmc_random(3,drno)
              end do
              do k=1,3
                ch(k)=(drno(k)-0.5)*cdgs
              end do
            else if (iop6 .eq. 2) then
c             Use fixed-length move
              rr=dsqrt((drno(1)-0.5)**2+(drno(2)-0.5)**2+
     -                 (drno(3)-0.5)**2)
              do k=1,3
                ch(k)=cdgs*(drno(k)-0.5)/rr
              end do
            else
c             Use magnitude range move
              rr=(drno(1)-0.5)**2+(drno(2)-0.5)**2+(drno(3)-0.5)**2
              do while (rr .gt. 0.25 .or. rr .lt. rsphm2)
                call mmc_random(3,drno)
                rr=(drno(1)-0.5)**2+(drno(2)-0.5)**2+(drno(3)-0.5)**2
              end do
              do k=1,3
                ch(k)=cdgs*(drno(k)-0.5)
              end do
            end if
          end if
          if (norot .eq. 0) phi=torcha(drno(4),rtax,iop(99))
        end if
      end if
      phiabs=abs(phi)
      chsq=0.0
      if (notrans .eq. 0) then
        do k=1,3
          chsq=chsq+ch(k)*ch(k)
          deln(k)=ch(k)
          crm(k,isolv)=crm(k,isolv)+ch(k)
        end do
c       Check if neighbour table is to be updated
C@NN        if (isolv .eq. 1 .or. arrdist(crm(1,isolv),clstup(1,isolv))
C@NN     -      .le. drmx22) go to 65
C@NN        nupdat=nupdat+1
C@NN        do k=1,3
C@NN          crmis(k)=crm(k,isolv)
C@NN          clstup(k,isolv)=crmis(k)
C@NN          zv(k,isolv)=0.0
C@NN        end do
C@NNc       First collect the distances for the PBC calculations
C@TEC@NN        if (iop(21) .eq. 3) then
C@TEC@NN          do i=iflslv(1,my_pe),iflslv(2,my_pe)
C@TEC@NN            if (i .lt. isolv) then
C@TEC@NN              zv(1,i)=crmis(1)-clstup(1,i)
C@TEC@NN              zv(2,i)=crmis(2)-clstup(2,i)
C@TEC@NN              zv(3,i)=crmis(3)-clstup(3,i)
C@TEC@NN            else if (i .gt. isolv) then
C@TEC@NN              zv(1,i)=clstup(1,i)-crmis(1)
C@TEC@NN              zv(2,i)=clstup(2,i)-crmis(2)
C@TEC@NN              zv(3,i)=clstup(3,i)-crmis(3)
C@TEC@NN            end if
C@TEC@NN          end do
C@TEC@NN        else
C@NN          isv1=isolv-1
C@NN          if (iop(21) .eq. 2) isv1=nmolec
C@NN          isv2=isv1+2
C@NN          do i=2,isv1
C@NN            zv(1,i)=crmis(1)-clstup(1,i)
C@NN            zv(2,i)=crmis(2)-clstup(2,i)
C@NN            zv(3,i)=crmis(3)-clstup(3,i)
C@NN          end do
C@NN          if (isv2 .le. nmolec) then
C@NN            do i=isv2,nmolec
C@NN              zv(1,i)=clstup(1,i)-crmis(1)
C@NN              zv(2,i)=clstup(2,i)-crmis(2)
C@NN              zv(3,i)=clstup(3,i)-crmis(3)
C@NN            end do
C@NN          end if
C@TEC@NN        end if
C@NNc       Now perform the PBC calculations
C@NN        if (iop(21) .eq. 0) then
C@NN          do i=2,nmolec
C@NN            call pbcnd(zv(1,i),zv(2,i),zv(3,i),iop(5),iopt,riijjv(i))
C@NN          end do
C@NN        else if (iop(21) .lt. 3) then
C@NN          call pbcvec(iop(5),2,nmolec)
C@NN        else
C@TEC@NN        call pbcvec(iop(5),iflslv(1,my_pe),iflslv(2,my_pe))
C@NDC@NN        call pbcvec(iop(5),2,nmolec)
C@TEC@NN        call TcommlibGAtherV(icpuslv(isolv)-1,riijjv(iflslv(1,my_pe)),
C@TEC@NN     -    riijjv,4,ndisplslv,ncountslv,iostat)
C@TEC@NN        if (iostat .gt. 0) print *,'DEPLOY Gather ERROR code=',iostat
C@NN        end if
C@NNc       Update bitmap based on the distances in riijjv
C@NN        isw=(isolv-1)/nbits+1
C@NN        isb=isolv-(isw-1)*nbits
C@TEC@NN        if (iop(21) .lt. 3) then
C@NN          iw=1
C@NN          ib=1
C@NN          mapbis=mapbitv(iw,isolv)
C@NN          do i=2,nmolec
C@NN            ib=ib+1
C@NN            if (ib .gt. nbits) then
C@NN              mapbitv(iw,isolv)=mapbis
C@NN              iw=iw+1
C@NN              mapbis=mapbitv(iw,isolv)
C@NN              ib=1
C@NN            end if
C@NN            if (riijjv(i) .le. rccmp2) then
C@NNC@NL              mapbis=mapbis .or. ibiton(ib)
C@NNC@NL              mapbitv(isw,i)=mapbitv(isw,i) .or. ibiton(isb)
C@NNC@NA              mapbis=ibset(mapbis,ib-1)
C@NNC@NA              mapbitv(isw,i)=ibset(mapbitv(isw,i),isb-1)
C@NN            else
C@NNC@NL              mapbis=mapbis .and. ibitof(ib)
C@NNC@NL              mapbitv(isw,i)=mapbitv(isw,i) .and. ibitof(isb)
C@NNC@NA              mapbis=ibclr(mapbis,ib-1)
C@NNC@NA              mapbitv(isw,i)=ibclr(mapbitv(isw,i),isb-1)
C@NN            end if
C@NN          end do
C@NN          mapbitv(iw,isolv)=mapbis
C@TEC@NN        else
C@TEC@NN          do i=iflslv(1,my_pe),iflslv(2,my_pe)
C@TEC@NN            if (riijjv(i) .le. rccmp2) then
C@TEC@NNC@NL              mapbitv(isw,i)=mapbitv(isw,i) .or. ibiton(isb)
C@TEC@NNC@NA              mapbitv(isw,i)=ibset(mapbitv(isw,i),isb-1)
C@TEC@NN            else
C@TEC@NNC@NL              mapbitv(isw,i)=mapbitv(isw,i) .and. ibitof(isb)
C@TEC@NNC@NA              mapbitv(isw,i)=ibclr(mapbitv(isw,i),isb-1)
C@TEC@NN            end if
C@TEC@NN          end do
C@TEC@NN          i=0
C@TEC@NN          do iw=1,nmolmp
C@TEC@NN            mapbis=0
C@TEC@NN            do ib=1,nbits
C@TEC@NN              i=i+1
C@TEC@NNC@NL          if (riijjv(i) .le. rccmp2) mapbis=mapbis .or. ibiton(ib)
C@TEC@NNC@NA          if (riijjv(i) .le. rccmp2) mapbis=ibset(mapbis,ib-1)
C@TEC@NN            end do
C@TEC@NN            mapbitv(iw,isolv)=mapbis
C@TEC@NN          end do
C@TEC@NN        end if
C@NN65      continue
c       See if molecule isolv did move out of the cell
        call pbcnd(crm(1,isolv),crm(2,isolv),crm(3,isolv),iop(5),
     -    iopt,dist2)
        if (iopt .gt. 1) then
          if (iop(5) .ne. 5) then
            do k=1,3
              cd(k)=cic(k,iopt)
            end do
          else
c           Sphere boundary conditions
c           Molecule moved out of the sphere, pull it back
            fac=sqrt(dist2/rinscs)*0.99-1.0
            do k=1,3
              cd(k)=fac*crm(k,isolv)
            end do
          end if
          do k=1,3
            ch(k)=ch(k)+cd(k)
          end do
        else
          do k=1,3
            cd(k)=0.0
          end do
        end if
      else
        call zeroit(ch,3)
        call zeroit(cd,3)
        iopt=1
      end if
c     Generate new coordinates for isolv into c(1,icsol1)
      if (isolv .eq. 1) then
        if (idebug(124) .gt. 0) write (iout,1000) 'slt',isolv,
     -    (crm(k,isolv),k=1,3),ch,phi*rdtodg,notrans,norot,0
        if (norot .eq. 0) then
          call trnsor(orient,orj,iaxis,phi,rot)
          call rot_trans(orj,rlcslt,crm,c,nstta)
        else
          call trnsfr(orj,orient,9)
          do i=1,nstta
            do k=1,3
              c(k,i)=c(k,i)+ch(k)
            end do
          end do
        end if
      else
        if (iop(5) .eq. 2) then
          call hcp_trnsor(orient(1,1,isolv),orj,iaxis,phi,iopt)
        else
          call trnsor(orient(1,1,isolv),orj,iaxis,phi,rot)
        end if
        call rot_trans(orj,rlcslv,crm(1,isolv),c(1,icsol1),nslv)
        if (iopt .gt. 1) ncross(iopt)=ncross(iopt)+1
      end if
      if (idebug(91) .gt. 0) then
        write (iout,1000) 'ret',isolv,(crm(k,isolv),k=1,3),ch,
     -    phi*rdtodg,notrans,norot,iopt
        if (idebug(91) .gt. 1) then
          if (isolv .eq. 1) then
            write (iout,1001) (ia,(c(k,ia),k=1,3),ia=1,nstta)
          else
            ia0=nstta+(isolv-2)*nslv
            write (iout,1001) (ia,(c(k,ia),k=1,3),ia=ia0+1,ia0+nslv)
          end if
        end if
      end if
      return
1000  format(' DEPLOY ',a,' isolv=',i6,' crm=',3f10.5,' ch=',3f10.5,
     -  ' angle=',f10.5,' notrans,norot=',2i3,' iopt=',i2)
1001  format(' DEPLOY c(',i6,')=',3f10.5)
      end
      subroutine deploycpl(c,crm)
c#    MMC routine 140 lstmod: 07/05/02
c*****Generate the trial displacement and rotation of the isolv-th molec.
      dimension c(3,#NA),crm(3,#MO)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /isoeng/ dimax,dijs,dijq,dijso,dijqo,eniemx,eniemo
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      common /option/ iop(200),idebug(200)
      real*8 drno
      dimension drno(3),ort(3,3),crmpmfnew(3),rot(3,3)
c     Variable solute conformation
c     Perturb coupling parameter, compute new slt coordinates
c     cplprn, cp1prn: cpl par after perturbation and its complement
      itormov=0
      molmov=impmf1
      if (impmf2 .ne. impmf1) molmovs=impmf2
      if (iop(18) .eq. 4) then
        itormov=1
        molmov=impmf
        ifagr=iftorgrp(1)
        ilagr=iltorgrp(1)
        iltorgrgr=iltormovgrgr(1)
      else
        ifagr=ifirstm(molmov)
        ilagr=ilastm(molmov)
        if (impmf2 .ne. impmf1) then
          ifagrs=ifirstm(molmovs)
          ilagrs=ilastm(molmovs)
        end if
      end if
      call mmc_random(1,drno)
      drno1=drno(1)
      cplprn=cplpar+(drno1-0.5)*delcpl
      cp1prn=1.0-cplprn
c     Prevent the coupling parameter to go out of the grid range
      if (cplprn .le. d0cpl .or. cp1prn .le. d0cpl) then
        if (cplprn .ge. cp1prn) then
          cp1prn=d0cpl
          cplprn=1.0-cp1prn
        else
          cplprn=d0cpl
          cp1prn=1.0-cplprn
        end if
      end if
c     Save the atoms affected by the rotation
      if (iop(18) .eq. 4) then
        do ia=ifagr,ilagr
          do k=1,3
            cslto(k,lsttorgrp(ia))=c(k,lsttorgrp(ia))
          end do
        end do
        do it=ifdhgrlst(1),ildhgrlst(1)
          dihango(it)=dihang(it)
        end do
      else
        if (iop(38) .eq. 0) then
c         For iop(38)>0 lincmb will be used for restore
          call trnsfr(cslto(1,nstfa1+1),c(1,nstfa1+1),3*nstfa0)
        end if
        if (iop(18) .eq. 5) then
c         Save displ/rot info
          call trnsfr(crmi,crmpmf,3)
          call trnsfr(orj,ort2nd,9)
        end if
      end if
      call lincmb(c,crm,cplprn,0,qslt,nstfa0)
      if (iop(18) .eq. 5) then
c       Add translate/rotate
        if (notranpmf .eq. 0) then
          call mmc_random(3,drno)
          do k=1,3
            crmpmf(k)=crmpmf(k)+(drno(k)-0.5)*cdpmf(k)
          end do
          call pbcnd(crmpmf(1),crmpmf(2),crmpmf(3),iop(5),iopt,riijj)
          call arrsum(crmpmfnew,crmpmf,crmpmf0,3)
          call pbcnd(crmpmfnew(1),crmpmfnew(2),crmpmfnew(3),iop(5),
     -      iopt,riijj)
        else
          call trnsfr(crmpmfnew,crmpmf0,3)
        end if
        if (norotpmf .eq. 0) then
          call mmc_random(2,drno)
          iaxis=drno(1)*3+1
          do while (rtpmf(iaxis) .eq. 0.0)
            call mmc_random(1,drno)
            iaxis=drno(1)*3+1
          end do
          phi=(drno(2)-0.5)*rtpmf(iaxis)
          call trnsor(ort2nd,ort,iaxis,phi,rot)
          call rot_trans(ort,rlcslt(1,nstfa1+1),crmpmfnew,c(1,nstfa1+1),
     -      nstfa0)
        else if (notranpmf .eq. 0) then
          do ia=nstfa1+1,nstfa
            call arrsum(c(1,ia),crmpmfnew,rlcslt(1,ia),3)
          end do
        end if
        if (idebug(55) .gt. 0) write (iout,1000) notranpmf,norotpmf,
     -    crmpmf0,crmpmf,crmpmfnew,(c(k,icent1),k=1,3)
        if (idebug(55) .gt. 1) write (iout,1001)
     -    'rlcslt',((rlcslt(k,nstfa1+i),k=1,3),i=1,nstfa0)
        if (idebug(55) .gt. 1) write (iout,1001)
     -    'c',((c(k,nstfa1+i),k=1,3),i=1,nstfa0)
      end if
      if (iop(7) .eq. 2) then
c       For iso-energy cutoff, save intergroup distance square, cube
        dijso=dijs
        dijqo=dijq
        eniemo=eniemx
        dijs=arrdist(c(1,icent1),c(1,icent2))
        dijq=dijs**2
        eniemx=1.0/dijs - 1.0/(sqrt(dijs)+cutslt)**2
      end if
      return
1000  format(' DEPLOYCPL notram,rot=',2i2,' crmpmf0=',3f9.4,' crmpmf=',
     -  3f9.4,' crmpmfnew=',3f9.4,/,' c(icent1)=',3f9.4)
1001  format(' DEPLOYCPL ',a,'=',(3(2x,3f12.5)))
      end
      subroutine deploypd(c,orientsltm,ch,dihang)
c#    MMC routine 141 lstmod: 04/20/08
c*****Generate trial partial solute displ. and rot. on the icopy-th slt copy
      dimension c(3,#NA),orientsltm(3,3,#MM),ch(3),dihang(#TR)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /ecell/ cic(3,27),ncell
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /shuffl/ isser,isserpd,isserpt,itry(#MO),
     -  itrypd(#MM),itrypt(#MM)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /liga/ ligand_start_molecule,last_slt_mol_g
      real*8 drno,drno1
      dimension drno(6),drno1(1),z(3)
      data bf/0.0/,rtxp /0.0/,phi /0.0/
      if (idebug(30) .gt. 1) write (iout,7000) iop(73),movmolf,movmoll
      itormov=0
      call mmc_random(6,drno)
c     Tom: Only choose ligand molecules to move (hold everything else fixed)
c      movmolf=ligand_start_molecule
      if (iop(73) .eq. 0) then
c       Select solute molecule to be moved (randomly)
        molmov=drno(6)*(movmoll-movmolf+1)+movmolf
      else if (iop(73) .eq. 1) then
c       Cyclic moves - forward
        isserpd=isserpd+1
        if (isserpd .gt. movmoll) isserpd=movmolf
        molmov=isserpd
      else if (iop(73) .eq. 2) then
        call shuffle(itrypd,movmolf,movmoll,isserpd,molmov)
      else if (iop(73) .eq. 3) then
c       Cyclic moves - reverse
        isserpd=isserpd-1
        if (isserpd .lt. movmolf) isserpd=movmoll
        molmov=isserpd
      end if
      if (iop(44) .eq. 1 .or. iop(44) .eq. 3) then
        call mmc_random(1,drno1)
        if (drno1(1) .lt. wsltdisp) then
          norot=1
          notrans=0
        else
          notrans=1
          norot=0
        end if
      else
        norot=0
        notrans=0
        if (waxis(3) .eq. 0.0) norot=1
      end if
      icopy=3
      ifagr=ifirstm(molmov)
      ilagr=ilastm(molmov)
      absstep=0.0
      call zeroit(cd,3)
      if (notrans .eq. 0) then
c       Determine random displacement, rotation
        if (istune(1) .gt. 0) then
          do k=1,3
            call picltune(targetacc(1),accsumtrans(molmov),
     -        accsumtransprev(molmov),gain(1),timeint(1),
     -        cedpsltim(k,molmov),tunstpmn(1),tunstpmx(1),1,k,
     -        istunetyp(1),idebug(40),iout)
          end do
          ntrantune(molmov)=ntrantune(molmov)+1
        end if
        do k=1,3
          ch(k)=(drno(k)-0.5)*cedpsltim(k,molmov)
          z(k)=c(k,molcnt(molmov))+ch(k)
        end do
        absstep=sclprd(ch,ch)
c       See if the group did move out of the cell
        call pbcnd(z(1),z(2),z(3),iop(5),iopt,dist2)
        if (iopt .gt. 1) then
          if (iop(5) .ne. 5) then
            do k=1,3
              cd(k)=cic(k,iopt)
            end do
          else
c           Sphere boundary conditions
c           If molecule moved out of the sphere, pull it back
            fac=sqrt(dist2/rinscs)*0.99-1.0
            do k=1,3
              cd(k)=fac*z(k)
              z(k)=z(k)+cd(k)
            end do
          end if
          do k=1,3
            ch(k)=ch(k)+cd(k)
          end do
        end if
      else
        call zeroit(ch,3)
        call trnsfr(z,c(1,molcnt(molmov)),3)
      end if
      iaxis=0
      if (norot .eq. 0) then
c       Selecting the axis of rotation
        do while (drno(5) .gt. waxis(iaxis+1))
          iaxis=iaxis+1
        end do
        if (istune(2) .gt. 0) then
          call picltune(targetacc(2),accsumrot(iaxis,molmov),
     -      accsumrotprev(iaxis,molmov),gain(2),timeint(2),
     -      rtxpsltim(iaxis,molmov),tunstpmn(2),tunstpmx(2),2,iaxis,
     -      istunetyp(2),idebug(40),iout)
          nrottune(iaxis,molmov)=nrottune(iaxis,molmov)+1
        end if
        rtxp=rtxpsltim(iaxis,molmov)
        if (rtxp .gt. 0.0) then
c         Rotate/displace selected solute group
          if (iop(57) .eq. 1) then
c           Uniform scaling
            phi=torcha(drno(4),rtxp,iop(99))
            phiabs=abs(phi)
            displace=phiabs
          else if (iop(57) .ge. 2) then
c           Modulate step with the molecular extension
            i1=mod(iaxis,3)+1
            i2=mod(iaxis+1,3)+1
            do ia=ifagr,ilagr
              cv1(ia-ifagr+1)=(c(i1,ia)-c(i1,molcnt(molmov)))**2+
     -           (c(i2,ia)-c(i2,molcnt(molmov)))**2
            end do
            displace=extbias(cv1,iop(57),rtxp,ilagr-ifagr+1,bf)
            phi=torcha(drno(4),displace,iop(99))
            phiabs=abs(phi)
          end if
        end if
      end if
      call transrotslt(iaxis,notrans,phi,ch,molmov,z,
     -  orientsltm,orj,ifagr,ilagr,rlcslt,c,dihang,iout)
      if (idebug(30) .gt. 0) then
        dev=sqrt(abs(sclprd(ch,ch)))
        write (iout,7001) molmov,ch,dev,iaxis,rtxp,bf,phi
      end if
7000  format(' DEPLOYPD iop(73)=',i2,' molmovf,molmovl=',2i6)
7001  format(' DEPLOYPD im=',i5,' ch=',3f10.6,' chabs=',f10.6,
     -  ' iax=',i1,' rtxp=',f8.4,' bf,phi=',2f10.5)
      end
      subroutine transrotslt(iaxis,notrans,phi,ch,molmov,cent,
     -  orientsltm,orj,ifagr,ilagr,rlcslt,c,dihang,iout)
c#    MMC routine 142 lstmod: 04/05/13
c*****Translate/rotate a solute molecule
      dimension orj(3,3),c(3,#NA),ch(3),orientsltm(3,3,#MM),
     -  cent(3),rlcslt(3,#ST),dihang(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /option/ iop(200),idebug(200)
      dimension rot(3,3)
      if (iaxis .gt. 0) then
        call trnsor(orientsltm(1,1,molmov),orj,iaxis,phi,rot)
        if (ifirstt(molmov) .gt. ilastt(molmov)) then
c         No torsions on this molecule
          call rot_trans(orj,rlcslt(1,ifagr),cent,c(1,ifagr),
     -      ilagr-ifagr+1)
        else
          if (idebug(160) .eq. 0) then
c           Just rotate/translate the current configuration
            cm1=cent(1)
            cm2=cent(2)
            cm3=cent(3)
            cm1b=cent(1)+ch(1)
            cm2b=cent(2)+ch(2)
            cm3b=cent(3)+ch(3)
            do i=ifagr,ilagr
              c1=c(1,i)-cm1
              c2=c(2,i)-cm2
              c3=c(3,i)-cm3
              cl1=rot(1,1)*c1+rot(1,2)*c2+rot(1,3)*c3
              cl2=rot(2,1)*c1+rot(2,2)*c2+rot(2,3)*c3
              cl3=rot(3,1)*c1+rot(3,2)*c2+rot(3,3)*c3
              c(1,i)=cl1+cm1b
              c(2,i)=cl2+cm2b
              c(3,i)=cl3+cm3b
            end do
          else
            n0=1
            if (molmov .gt. 1) n0=natfix(molmov-1)+1
            if (idebug(25) .gt. 0) write (iout,7000) n0,natfix(molmov),
     -        (iroots(i),i=n0,natfix(molmov))
            call rot_trans_list(rlcslt,c,n0,natfix(molmov),iroots,orj,
     -        cent,#ST,idebug(52),iout)
            call gentor(ifirstt(molmov),ilastt(molmov),dihang,c,
     -        itangindx,iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -        cosdela,bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -        #TR,#ST)
          end if
        end if
      else if (notrans .eq. 0) then
c       Just displace selected solute group
        do i=ifagr,ilagr
          do k=1,3
            c(k,i)=c(k,i)+ch(k)
          end do
        end do
        call trnsfr(orj,orientsltm(1,1,molmov),9)
      end if
      return
7000  format(' TRANSROTSLT n0,natfix=',2i5,' list=',(20i5))
      end
      function extbias(e2,iopexbi,rtx,n,bf)
c#    MMC routine 143 lstmod: 11/15/97
c*****Calculate the extension bias
c     e2: extension square for atom i (i=1,..,n)
c     rtx: stepsize parameter
c     bf: actual extension used in obtaining the range
c     extbias: angle range to use in generating random step
      dimension e2(#ST)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      extmax2=0.0
      if (iopexbi .eq. 2) then
        do i=1,n
          if (extmax2 .lt. e2(i)) extmax2=e2(i)
        end do
        bf=sqrt(extmax2)
      else if (iopexbi .eq. 3) then
        do i=1,n
          if (extmax2 .lt. e2(i)) extmax2=e2(i)
        end do
        bf=extmax2**0.25
      else if (iopexbi .eq. 4) then
        extav2=0.0
        do i=1,n
          extav2=extav2+e2(i)
        end do
        bf=sqrt(extav2/n)
      else if (iopexbi .eq. 5) then
        extav=0.0
        do i=1,n
          extav=extav+sqrt(e2(i))
        end do
        bf=extav/n
      else if (iopexbi .eq. 6) then
        extav=0.0
        do i=1,n
          extav=extav+sqrt(e2(i))
        end do
        bf=sqrt(extav/n)
      end if
      extbias=amin1(pi2,rtx/(2.0*bf))
      return
      end
      subroutine deploy2slt(c,orientsltm,dihang,iswapor2s)
c#    MMC routine 144 lstmod: 01/15/03
c*****Generate swap or corrlated 2-slt move
      dimension c(3,#NA),orientsltm(3,3,#MM),dihang(#TR)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /ecell/ cic(3,27),ncell
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 drno
      dimension drno(6),ch(3)
      itormov=0
      icopy=3
      call mmc_random(2,drno)
c     Select the two solute molecules
      molmov=drno(1)*(movmoll-movmolf+1)+movmolf
      if (iswapor2s .eq. 1) then
c       Select 2nd molec to be swapped (randomly)
        molmovs=drno(2)*(movmoll-movmolf)+movmolf
        if (molmovs .ge. molmov) then
c         Skip molmov
          molmovs=molmovs+1
        end if
      else
c       Select correlated 2nd solute molec
        do im=movmolf,movmoll
          call arrdiff(zv(1,im),c(1,molcnt(molmov)),c(1,molcnt(im)),3)
        end do
        call pbcvec(iop(5),movmolf,movmoll)
        if (r2scut .gt. 0.0) then
c         Select molmovs from neighbor within r2scut
          nn=0
          do im=movmolf,movmoll
            if (im .ne. molmov) then
              if (riijjv(im) .lt. r2scut**2) then
                nn=nn+1
                ixnear(nn)=im
              end if
            end if
          end do
          if (nn .eq. 0) then
            write (iout,1000) r2scut,molmov
            call datprt(2)
          else
            if (nn .lt. nn2min) nn2min=nn
            if (nn .gt. nn2max) nn2max=nn
            ixnn=drno(2)*nn+1
            molmovs=ixnear(ixnn)
          end if
        else
c         Select the nearest
          r2near=1.e+6
          do im=movmolf,movmoll
            if (im .ne. molmov) then
              if (r2near .gt. riijjv(im)) then
                molmovs=im
                r2near=riijjv(im)
              end if
            end if
          end do
        end if
      end if
      if (molmovs .lt. molmov) then
c       Ensure molmov<molmovs
        i=molmov
        molmov=molmovs
        molmovs=i
      end if
      ifagr=ifirstm(molmov)
      ilagr=ilastm(molmov)
      ifagrs=ifirstm(molmovs)
      ilagrs=ilastm(molmovs)
      if (iswapor2s .eq. 1) then
c       Calculate overall swap displacement vector
        call arrdiff(ch,c(1,molcnt(molmov)),c(1,molcnt(molmovs)),3)
        do i=ifagr,ilagr
          do k=1,3
            c(k,i)=c(k,i)-ch(k)
          end do
        end do
        do i=ifagrs,ilagrs
          do k=1,3
            c(k,i)=c(k,i)+ch(k)
          end do
        end do
      else
c       Determine rotation angle
        call mmc_random(1,drno)
        if (iop(66) .eq. 1) then
c         Uniform scaling
          phi=(drno(1)-0.5)*rtxcslt
          phiabs=abs(phi)
          displace=phiabs
        else if (iop(66) .ge. 2) then
c         Modulate step with the molecular extension
          i1=mod(iaxis2s,3)+1
          i2=mod(iaxis2s+1,3)+1
          do ia=ifagr,ilagr
            cv1(ia-ifagr+1)=(c(i1,ia)-c(i1,molcnt(molmov)))**2+
     -         (c(i2,ia)-c(i2,molcnt(molmov)))**2
          end do
          do ia=ifagrs,ilagrs
            cv1(ia-ifagrs+(ilagr-ifagr+1)+1)=
     -        (c(i1,ia)-c(i1,molcnt(molmovs)))**2+
     -        (c(i2,ia)-c(i2,molcnt(molmovs)))**2
          end do
          displace=extbias(cv1,iop(66),rtxcslt,
     -     ilagr-ifagr+1+ilagrs-ifagrs+1,bf)
          phi=(drno(1)-0.5)*displace
          phiabs=abs(phi)
        end if
        call zeroit(ch,3)
        call transrotslt(iaxis2s,0,phi,ch,molmov,c(1,molcnt(molmov)),
     -    orientsltm,orj,ifagr,ilagr,rlcslt,c,dihang,iout)
        call transrotslt(iaxis2s,0,-phi,ch,molmovs,c(1,molcnt(molmovs)),
     -    orientsltm,orj,ifagrs,ilagrs,rlcslt,c,dihang,iout)
      end if
      return
1000  format(' ***** ERROR: No solute neighbors were found within ',
     -  f5.2,' A from solute molecule',i4,' for correlated move',/,
     -  7x,'- increase r2scut in the MV2S line')
      end
      subroutine deploypt(c,nmc,ptaccfac,nsol,nsolo,lasttorgen,looptry,
     -  nochange)
c#    MMC routine 145 lstmod: 10/26/20
c*****Generate the trial displacement and rotation of the isolv-th molec.
      dimension c(3,#NA),looptry(#TR)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /shuffl/ isser,isserpd,isserpt,itry(#MO),
     -  itrypd(#MM),itrypt(#MM)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),
     -  d02(#LT),d03(#LT),d12(#LT),d13(#LT),
     -  d14(#LT),d23(#LT),d24(#LT),d25(#LT),d34(#LT),d35(#LT),
     -  d36(#LT),d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),d79(#LT)
      common /solchoice/ isol17(7),isol17alt(7,2)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /coptor/ ncoptoract,ncoptorfact
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 drno,darrdists,deldij,dijf,dijl,dijfr,dijlr,dijrev,dijsol,
     -  dijrevr,dijsolr,dsafelimfacdivr3
      dimension drno(#TR),r2(3),r3(3),r4(3),r5(3),r6(3),r7(3),
     -  r234s(3,4,32),r2o(3),r3o(3),r4o(3),r5o(3),r6o(3),r7o(3),
     -  r234os(3,4,32),r234(3,4,32),r234o(3,4,32),wjac(32),wjaco(32)
      real*8 d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,dr0,dr1,dr2,dr3,dr4,dr5,dr6,
     -  dr7,dr8,dr9,r234,r234o
      dimension d0(3),d1(3),d2(3),d3(3),d4(3),d5(3),d6(3),d7(3),d8(3),
     -  d9(3),dr0(3),dr1(3),dr2(3),dr3(3),dr4(3),dr5(3),dr6(3),dr7(3),
     -  dr8(3),dr9(3),rand(3)
      dimension keycol(2)
      character*80 filnam
      character*4 movnam
      data dijrevr /0.d0/,dijsolr /0.d0/,isolnear /0/
c     Select molecule for torsion sampling
      if (idebug(25) .gt. 1) write (iout,*) 'DEPLOYPT start'
      ilow=itmfrst
      ihigh=ntorgrp+1
      imfound=0
      iranmol=0
      incrot=1
      ptaccfac=1.0
      nochange=0
      if (nsttm .gt. 1) then
        ntry=0
        do while (imfound.eq. 0)
          ntry=ntry+1
          if (ntry .gt. 5*nsttm) then
            write (iout,2000) ntry
            inperr=inperr+1
            iranmol=1
            imfound=1
          end if
          if (iop(74) .eq. 0) then
c           Random - just select random molecule
            imfound=1
            iranmol=1
          else if (iop(74) .eq. 1) then
c           Cyclic move - forward
            isserpt=isserpt+1
            if (isserpt .gt. ngrtmx) isserpt=ngrtmn
            molmov=isserpt
            imfound=nmtmx(molmov)
          else if (iop(74) .eq. 2) then
            call shuffle(itrypt,ngrtmn,ngrtmx,isserpt,molmov)
            imfound=nmtmx(molmov)
          else if (iop(74) .eq. 3) then
c           Cyclic move - reverse
            isserpt=isserpt-1
            if (isserpt .lt. ngrtmn) isserpt=ngrtmx
            molmov=isserpt
            imfound=nmtmx(molmov)
          end if
        end do
        if (iranmol .eq. 1) then
c         Select random molecule, proportional to the total weights
          ilow=itmfrst
          ihigh=ntorgrp+1
          call mmc_random(1,drno)
          do while (ihigh-ilow .gt. 1)
            mid=ilow+(ihigh-ilow)/2
            if (drno(1) .gt. wtors(mid)) then
              ilow=mid
            else
              ihigh=mid
            end if
          end do
          molmov=iamolslt(lsttorgrp(iftorgrp(ilow)))
        end if
        ilow=nmtmn(molmov)
        ihigh=nmtmx(molmov)+1
        w0=wtors(ilow)
        if (molmov .eq. nsttm) then
          wdiff=1.0-wtors(ilow)
        else
          wdiff=wtors(ihigh)-wtors(ilow)
        end if
      else
        molmov=1
        w0=0.0
        wdiff=1.0
      end if
      call mmc_random(1,drno)
      if (iop(75) .eq. 0) then
c       Random torsion selection
        drno(1)=w0+drno(1)*wdiff
      else if (iop(75) .eq. 1) then
c       Cyclic selection - forward
        wtlast(molmov)=wtlast(molmov)+
     -    drno(1)*wdiff/float(ihigh-ilow)
        if (wtlast(molmov) .gt. wdiff)
     -    wtlast(molmov)=wtlast(molmov)-wdiff
        drno(1)=w0+wtlast(molmov)
c     else if (iop(75) .eq. 2) then
c       Shuffled cyclic is not implemented (would need new arrays)
      else if (iop(75) .eq. 3) then
c       Cyclic selection - reverse
        wtlast(molmov)=wtlast(molmov)-
     -    drno(1)*wdiff/float(ihigh-ilow)
        if (wtlast(molmov) .le. 0.0)
     -    wtlast(molmov)=wdiff+wtlast(molmov)
        drno(1)=w0+wtlast(molmov)
      end if
c     Select the torsion group to be rotated by binary search
      do while (ihigh-ilow .gt. 1)
        mid=ilow+(ihigh-ilow)/2
        if (drno(1) .gt. wtors(mid)) then
          ilow=mid
        else
          ihigh=mid
        end if
      end do
      itormov=ilow
      ifagr=iftorgrp(itormov)
      ilagr=iltorgrp(itormov)
      molmov=iamolslt(lsttorgrp(ifagr))
      if (iop(75) .eq. 1) then
        wtlast(molmov)=wtors(itormov+1)-w0
      else if (iop(75) .eq. 3) then
        wtlast(molmov)=wtors(itormov)-w0
      end if
      if (lsttorgrp(ifagr) .le. nstfa0) then
        icopy=1
      else if (lsttorgrp(ifagr) .le. nstfa) then
        icopy=2
      else
        icopy=3
      end if
      if (molmov .le. nstfm) then
        ncoptorfact=ncoptorf
        ncoptoract=ncoptor
      else
        ncoptorfact=1
        ncoptoract=1
      end if
c     Determine random torsion for the angles in this group, apply torsion
      numtors=ildhgrlst(itormov)-ifdhgrlst(itormov)+1
      call mmc_random(numtors,drno)
      lasttorgen=iftmovtg(itormov)
      iltorgrgr=iftormovgrgr(itormov)
      if (idebug(175) .gt. 1) then
        write (iout,1000) 'REMARK before trial move'
        write (iout,7013) (i,labslt(2,i),labslt(1,i)(1:3),'S',1,
     -    (c(k,i),k=1,3),1.0,1.0,i=1,nstta)
      end if
      do it=ifdhgrlst(itormov),ildhgrlst(itormov)
        call origtor(it,itorig,iop(69),itn)
        itr=it-ifdhgrlst(itormov)+1
        dihango(it)=dihang(it)
        looptry(it)=0
        lasttorgenit=iltmovtg(itormov)
        iltorgrgrit=iltormovgrgr(itormov)
        if (looptyp(it) .gt. 0) then
          if (wloop .lt. 1.0 .and. torstep(itn) .gt. 0.0) then
c           Decide if loop move or regular move is executed
            call randpx(1,r2)
            if (r2(1) .lt. wloop) looptry(it)=1
          else
            looptry(it)=1
          end if
        end if
        if (looptry(it) .gt. 0) then
c         Set up loop move
          movnam='LOOP'
          nloopmtry=nloopmtry+1
          if (idebug(74) .gt. 1 .or. idebug(71) .gt. 2) then
            im=iamolslt(lsttorgrp(ifagr))
            call checkgeom(ifirstm(im),ilastm(im),c,rlcslt,nneig,ineig,
     -        iout,1,d12tol,d13tol,nerr12,nerr13,devmax12,devmax13,
     -        devav12,devav13,#NL,imx12,jmx12,'before loop move',16,
     -        #ST)
            call torcontest(ntang,iquata,c,2,nfail0,iout,
     -        #ST,#TR)
          end if
c         Save affected torsion angles
          do k=1,6
            itl=looplist(k,it)
            dihango(itl)=dihang(itl)
          end do
c         Change root torsion with uniform random move
          call origtor(it,itorig,iop(69),itn)
          if (istune(4) .gt. 0) then
            call picltune(targetacc(4),accsumloop(itn),
     -        accsumloopprev(itn),gain(4),timeint(4),steploop(itn),
     -        tunstpmn(4),tunstpmx(4),4,itn,istunetyp(4),idebug(40),
     -        iout)
            if (iskewdr .gt. 0)
     -        call checkskewtors(iskew(it),steploop(itn),wskewstepmin,
     -          resumefac,dihang(it),it,idebug(146),iout)
          end if
          torch=torcha(drno(itr),steploop(itn),iop(99))
          if (iskew(it) .eq. 1 .and. iskewdr .eq. 1)
     -      call skewtors(torch,targetang(it),dihang(it),wskewinv,it,
     -        idebug(144))
          if (torch .eq. 0.0) then
c           No change - accept unconditionally
            nochange=1
            return
          end if
          if (idebug(74) .eq. 0) then
            dihang(it)=dihang(it)+torch
c           Calculate the rotated position of iquata(it,3)
            if (dihang(it) .gt. pi) dihang(it)=dihang(it)-pi2
            if (dihang(it) .le. -pi) dihang(it)=dihang(it)+pi2
            if (ntorlim .gt. 0) then
              call checktorlim(dihang(it),dih0(it),
     -          deldih(it),ptaccfac,irejtyp)
c             Reject when angle went out of limit
              if (irejtyp .eq. 4) return
            end if
c           Generate trial coordinates of the first atom of the chain
            nrotit=nrot(it)
c           For [=--] and =----- loops, two bonds need to be moved with driver
            if (looptyp(it) .eq. 3 .or. looptyp(it) .eq. 4) then
              nrot(it)=2
            else
              nrot(it)=1
            end if
          if (idebug(175) .gt. 1) write (iout,*) 'GENTOR call T1 it=',it
            call gentor(it,it,dihang,c,itangindx,iprecursor,nrot,iri,
     -        irotlist,irotlinc,sindela,cosdela,bondf,bondproj,xfac13,
     -        xfac12,bond,idebug(25),iout,#TR,#ST)
            nrot(it)=nrotit
          end if
          call getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,i6,
     -      ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,looptyp(it),
     -      idebug(71),iout,'DEPLOYPT  ',#TR,#LT)
          unrelfac=100.0
          nloopctry(1,looptyp(it))=nloopctry(1,looptyp(it))+1
          ibf=0
          call closeloop(r234,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -      dflsmin(it),dflsmax(it),dflsminr(it),dflsmaxr(it),deldij,
     -      it,c,cslto,cslt,r2,r3,r4,r5,r6,r7,
     -      i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,
     -      ii9,'DIRECT MOV',0,1,ibf,nsol,isol,nosoltyp,neval,inperr,
     -      iout)
          if (idebug(71) .gt. 1 .or. idebug(175) .gt. 1) then
            write (iout,1000) 'REMARK New loop backbone'
            write (iout,7013) i0,labslt(2,i0),labslt(1,i0)(1:3),'B',1,
     -        (c(k,i0),k=1,3),1.0,1.0
            write (iout,7013) i1,labslt(2,i1),labslt(1,i1)(1:3),'B',1,
     -        (c(k,i1),k=1,3),1.0,1.0
            write (iout,7013) i2,labslt(2,i2),labslt(1,i2)(1:3),'B',1,
     -        (c(k,i2),k=1,3),1.0,1.0
            write (iout,7013) i3,labslt(2,i3),labslt(1,i3)(1:3),'B',1,
     -        (c(k,i3),k=1,3),1.0,1.0
            write (iout,7013) i4,labslt(2,i4),labslt(1,i4)(1:3),'B',1,
     -        (c(k,i4),k=1,3),1.0,1.0
            write (iout,7013) i5,labslt(2,i5),labslt(1,i5)(1:3),'B',1,
     -        (c(k,i5),k=1,3),1.0,1.0
            write (iout,7013) i6,labslt(2,i6),labslt(1,i6)(1:3),'B',1,
     -        (c(k,i6),k=1,3),1.0,1.0
          end if
          evalnum=evalnum+neval
          solnum=solnum+nsol
          if (nsol .eq. 0) then
c           Reject for sure (no solution for loop closing)
            nosoltyps(nosoltyp,looptyp(it),1)=
     -        nosoltyps(nosoltyp,looptyp(it),1)+1
            numrej0=numrej0+1
            numnosol=numnosol+1
            ptaccfac=0.0
            irejtyp=1
            nsolo=0
            return
          else if (iop(115) .gt. 0) then
c           Ignore the Jacobian - don't calculate reverse move loop
            ptaccfac=1.0
            nsolo=0
            if (looptyp(it) .eq. 1) then
c             Chose solution
              iskewit=0
              if (iskewlp .eq. 1) then
c               See if loop has to be skewed
                do itt=1,6
                  if (iskew(looplist(itt,it)) .eq. 1) iskewit=iskewit+1
                end do
                if (iskewit .gt. 0) then
c                 Decide if random or skewed solution selection to be used
                  call randpx(1,rand)
                  if (rand(1) .gt. wskewinv) then
c                   Select solution nearest to a target
                    call skewloop(c,r234,nsol,looplist(1,it),targetang,
     -                iskew,iquata,it,i0,i1,i5,i6,ispicked,
     -                idebug(145),iout,maxtors)
                  else
                    iskewit=0
                  end if
                end if
              end if
              if (iskewit .eq. 0) then
c               No skewed selection
                if (iop(91) .eq. 2) then
c                 Select the nearest solution
                  cdevmin=1000000.0
                  do is=1,nsol
                    cdev=0.0
                    do k=1,3
                      cdev=cdev+(c(k,i2)-sngl(r234(k,2,is)))**2+
     -                          (c(k,i3)-sngl(r234(k,3,is)))**2+
     -                          (c(k,i4)-sngl(r234(k,4,is)))**2
                    end do
                    if (cdev .lt. cdevmin) then
                      cdevmin=cdev
                      ispicked=is
                    end if
                  end do
                else
c                 Select randomly a solution
                  call randpx(1,rand)
                  ispicked=rand(1)*nsol+1
                end if
              end if
c             Now extract solution
              do k=1,3
                d2(k)=r234(k,2,ispicked)
                d3(k)=r234(k,3,ispicked)
                d4(k)=r234(k,4,ispicked)
                r2(k)=d2(k)
                r3(k)=d3(k)
                r4(k)=d4(k)
              end do
            end if
            if (iskewpr .eq. 1) then
c             Bias acceptance
              iskewit=0
              if (iskew(it) .ne. 2) then
c               See if loop has to be skewed
                do itt=1,6
                  if (iskew(looplist(itt,it)) .eq. 1) iskewit=iskewit+1
                end do
              end if
              if (iskewit .gt. 0) then
                call savelooptemp(crmgs,c,looptyp(it),r2,r3,r4,r5,r6,r7,
     -            i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,
     -            ii8,ii9,idebug(63),iout,#UV,#NA)
                if (idebug(145) .gt. 1) then
                  write (iout,7011) i0,i1,i2,i3,i4,i5,i6,
     -              ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9
                  write (iout,7012) it,
     -             (iquata(it,ita),(c(k,iquata(it,ita)),k=1,3),ita=1,4),
     -             (iquata(it,ita),(cslto(k,iquata(it,ita)),k=1,3),
     -             ita=1,4)
                end if
                targetdevold=0.0
                targetdevnew=0.0
                do itt=1,6
                  itl=looplist(itt,it)
                  if (iskew(itl) .gt. 0) then
                    diho=dihangl(cslto(1,iquata(itl,1)),
     -                cslto(1,iquata(itl,2)),cslto(1,iquata(itl,3)),
     -                cslto(1,iquata(itl,4)),idebug(145),iout)
                    if (itt .lt. 6) then
                      dihn=dihangl(crmgs(1,iquata(itl,1)),
     -                  crmgs(1,iquata(itl,2)),crmgs(1,iquata(itl,3)),
     -                  crmgs(1,iquata(itl,4)),idebug(145),iout)
                    else
                      dihn=dihangl(crmgs(1,iquata(itl,1)),
     -                  crmgs(1,iquata(itl,2)),crmgs(1,iquata(itl,3)),
     -                  c(1,iquata(itl,4)),idebug(145),iout)
                    endif
                    targetdevold=targetdevold+
     -                amin1((diho-targetang(itl))**2,
     -                (diho-targetang(itl)+pi2)**2,
     -                (diho-targetang(itl)-pi2)**2)
                    targetdevnew=targetdevnew+
     -                amin1((dihn-targetang(itl))**2,
     -                (dihn-targetang(itl)+pi2)**2,
     -                (dihn-targetang(itl)-pi2)**2)
                    if (idebug(145) .gt. 0) write (iout,7005) it,itl,
     -                targetang(itl)*rdtodg,diho*rdtodg,dihn*rdtodg,
     -                targetdevold*rdtodg**2,targetdevnew*rdtodg**2
                    if (idebug(145) .gt. 1) write (iout,7009) itl,
     -                (iquata(itl,ita),(crmgs(k,iquata(itl,ita)),k=1,3),
     -                ita=1,4)
                  end if
                end do
                if (targetdevnew .gt. targetdevold) then
c                 Moved away from target
                  call randpx(1,rand)
                  if (rand(1) .gt. wskewinv) then
c                   Reject
                    ptaccfac=0.0
                    irejtyp=5
                    nsolo=0
                    return
                  end if
                end if
                 if (idebug(145) .gt. 0) write (iout,7006) it
              end if
            end if
            call saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -        it,looplist,iquata,c,looptyp,dihang,r2,r3,r4,r5,r6,r7,
     -        i0,i1,i2,i3,i4,i5,i6,ii2,ii3,ii4,ii5,ii6,ii7,
     -        idebug(63),iout)
            if (ntorlim .gt. 0) then
c             Check loop members for limit
              do itt=1,6
                itc=looplist(itt,it)
                call checktorlim(dihang(itc),dih0(itc),deldih(itc),
     -            ptaccfac,irejtyp)
c               Reject when angle went out of limit
                if (irejtyp .eq. 4) return
              end do
            end if
c           Reduce the range of atom regeneration and energy calculation
            lasttorgenit=looplist(6,it)-1
            call modloopinc(it,looptyp(it),iri,looplist,#ST,#LT,1)
            if (lasttorgenit .gt. lasttorgen) lasttorgen=lasttorgenit
            if (iltorgrgrit .gt. iltorgrgr) iltorgrgr=iltorgrgrit
            if (idebug(60) .gt. 0)
     -        write (iout,7007) movnam,it,lasttorgen,iltorgrgr
            if (dihang(it) .gt. pi) dihang(it)=dihang(it)-pi2
            if (dihang(it) .le. -pi) dihang(it)=dihang(it)+pi2
            go to 8000
          else
            nloopctry(2,looptyp(it))=nloopctry(2,looptyp(it))+1
c           Limit the search to the range where closer solution might be found
            dijf=dflsmin(it)
            dijl=dflsmax(it)
            dijfr=dflsminr(it)
            dijlr=dflsmaxr(it)
            safelimfac=9.0
            if (looptyp(it) .gt. 1) then
              if (looptyp(it) .eq. 2) then
                dijrev=darrdists(cslto(1,ii1),cslto(1,ii6))
                dijsol=darrdists(c(1,ii1),r6)
              else if (looptyp(it) .eq. 3) then
                dijrev=darrdists(cslto(1,ii2),cslto(1,ii7))
                dijsol=darrdists(c(1,ii2),r7)
              else if (looptyp(it) .eq. 4) then
                dijrev=darrdists(cslto(1,ii2),cslto(1,ii5))
                dijsol=darrdists(c(1,ii2),r5)
              else if (looptyp(it) .eq. 9) then
                dijrev=darrdists(cslto(1,ii1),cslto(1,ii4))
                dijsol=darrdists(c(1,ii1),r4)
              else
                dijrev=darrdists(cslto(1,ii1),cslto(1,ii5))
                dijsol=darrdists(c(1,ii1),r5)
              end if
              if (dijrev .lt. dijsol) then
                dijf=dijrev-(safelimfac+0.1)*divr3
                dsafelimfacdivr3=safelimfac*divr3
                dijl=dmin1(dijl,
     -            dijsol+dmax1(dsafelimfacdivr3,
     -              safelimfac*(dijsol-dijrev)))
              else
                dijl=dijrev+(safelimfac+0.1)*divr3
                dsafelimfacdivr3=(safelimfac+0.1)*divr3
                dijf=dmax1(dijf,
     -            dijsol-dmax1(dsafelimfacdivr3,
     -              safelimfac*(dijrev-dijsol)))
              end if
              if (iop(103) .ne. 1) then
                if (looptyp(it) .eq. 2) then
                  dijrevr=darrdists(cslto(1,ii3),cslto(1,ii8))
                  dijsolr=darrdists(c(1,ii3),c(1,ii8))
                else if (looptyp(it) .eq. 3) then
                  dijrevr=darrdists(cslto(1,ii3),cslto(1,ii8))
                  dijsolr=darrdists(c(1,ii3),c(1,ii8))
                else if (looptyp(it) .eq. 4) then
                  dijrevr=darrdists(cslto(1,ii4),cslto(1,ii7))
                  dijsolr=darrdists(c(1,ii4),cslto(1,ii7))
                else if (looptyp(it) .eq. 5) then
                  dijrevr=darrdists(cslto(1,ii3),cslto(1,ii6))
                  dijsolr=darrdists(c(1,ii3),cslto(1,ii6))
                else if (looptyp(it) .gt. 4)then
                  dijrevr=darrdists(cslto(1,ii2),cslto(1,ii6))
                  dijsolr=darrdists(c(1,ii2),cslto(1,ii6))
                else
                  write (iout,*) '***** PROGRAM ERROR: reverse order ',
     -              'is not implemented for loop type', looptyp(it)
                  call datprt(2)
                end if
                if (dijrevr .lt. dijsolr) then
                  dijfr=dijrevr-(safelimfac+0.1)*divr3
                  dsafelimfacdivr3=safelimfac*divr3
                  dijlr=dmin1(dijlr,
     -              dijsolr+dmax1(dsafelimfacdivr3,
     -                safelimfac*(dijsolr-dijrevr)))
                else
                  dijlr=dijrevr+(safelimfac+0.1)*divr3
                  dsafelimfacdivr3=(safelimfac+0.1)*divr3
                  dijfr=dmax1(dijfr,
     -              dijsolr-dmax1(dsafelimfacdivr3,
     -                safelimfac*(dijrevr-dijsolr)))
                end if
              end if
            end if
            if (idebug(86) .gt. 0) write (iout,7010)
     -        it,dflsmin(it),dflsmax(it),dijf,dijl,dijrev,dijsol,divr3
c           Check reverse move
            call savelooptemp(cgs,c,looptyp(it),r2,r3,r4,r5,r6,r7,i0,i1,
     -        i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,
     -        idebug(63),iout,#HA,#NA)
            call closeloop(r234o,dr0,dr1,dr2,dr3,dr4,dr5,dr6,dr7,dr8,
     -        dr9,dijf,dijl,dijfr,dijlr,deldij,it,cslto,cgs,
     -        cslt,r2o,r3o,r4o,r5o,r6o,r7o,
     -        i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,
     -        ii9,'REVERSEMOV',0,2,ibf,nsolo,isol,nosoltyp,neval,inperr,
     -        iout)
            evalnum=evalnum+neval
            solnum=solnum+nsolo
            idiff=0
            if (nsolo .eq. 0) then
              nosoltyps(nosoltyp,looptyp(it),2)=
     -          nosoltyps(nosoltyp,looptyp(it),2)+1
              if (idebug(73) .eq. 0) then
                ptaccfac=0.0
                irejtyp=2
                numrevrej=numrevrej+1
                return
              else
                idiff=-1
              end if
            end if
            if (looptyp(it) .eq. 1) then
              if (iop(91) .gt. 1) then
c               Find the solution nearest to the original
                devmin=100000.0
                do is=1,nsol
                  do k=1,3
                    r234s(k,2,is)=r234(k,2,is)
                    r234s(k,3,is)=r234(k,3,is)
                    r234s(k,4,is)=r234(k,4,is)
                  end do
                  dev=arrdist(r234s(1,2,is),cslto(1,i2))+
     -                arrdist(r234s(1,3,is),cslto(1,i3))+
     -              arrdist(r234s(1,4,is),cslto(1,i4))
                  if (dev .lt. devmin) then
                    devmin=dev
                    isolnear=is
                  end if
                end do
              end if
              if (iop(91) .eq. 3) then
c               Calculate the Jacobian weights
                wjacsum=0.0
                do is=1,nsol
                  do k=1,3
                    r234s(k,2,is)=r234(k,2,is)
                    r234s(k,3,is)=r234(k,3,is)
                    r234s(k,4,is)=r234(k,4,is)
                  end do
                  call jacobian(c(1,i0),c(1,i1),r234s(1,2,is),
     -              r234s(1,3,is),r234s(1,4,is),c(1,i5),c(1,i6),
     -              wjac(is),iout,njacsing,idebug(72))
                  wjacsum=wjacsum+wjac(is)
                end do
                wjacsumo=0.0
                do is=1,nsolo
                  do k=1,3
                    r234os(k,2,is)=r234o(k,2,is)
                    r234os(k,3,is)=r234o(k,3,is)
                    r234os(k,4,is)=r234o(k,4,is)
                  end do
                  call jacobian(c(1,i0),c(1,i1),r234os(1,2,is),
     -              r234os(1,3,is),r234os(1,4,is),c(1,i5),c(1,i6),
     -              wjaco(is),iout,njacsing,idebug(72))
                  wjacsumo=wjacsumo+wjaco(is)
                end do
c               Now pick solution
                call randpx(1,rand)
                is=1
                wjsum=0
                do while (is .le. nsol .and. rand(1)*wjacsum .gt. wjsum)
                  wjsum=wjsum+wjac(is)
                  is=is+1
                end do
                ispicked=is-1
                nearpicked=0
                if (ispicked .eq. isolnear) nearpicked=1
                numnearpicked=numnearpicked+nearpicked
                do k=1,3
                  r2(k)=r234s(k,2,ispicked)
                  r3(k)=r234s(k,3,ispicked)
                  r4(k)=r234s(k,4,ispicked)
                  d2(k)=r234(k,2,ispicked)
                  d3(k)=r234(k,3,ispicked)
                  d4(k)=r234(k,4,ispicked)
                end do
c               Now calculate ptaccfac
                call jacobian(c(1,i0),cslto(1,i1),cslto(1,i2),
     -            cslto(1,i3),cslto(1,i4),c(1,i5),c(1,i6),detjacold,
     -            iout,njacsing,idebug(72))
c               pij/pji factor
c               ptaccfac=(detjacold/wjacsumo)/(wjac(ispicked)/wjacsum)
c               Volume element correction factor
c               ptaccfac=ptaccfac*wjac(ispicked)/detjacold
c               Combined factor:
                ptaccfac=ptaccfac*wjacsum/wjacsumo
              else if (idiff .ne. -1) then
c               The reverse problem must have had a solution)
                if (iop(91) .eq. 1 .or. idebug(81) .gt. 0) then
c                 Only one solution was sought to begin with
                  call revprox(idebug(69),c(1,i1),r2,r3,r4,c(1,i5),
     -              cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -              cslt(1,i5),r2o,r3o,r4o,cslto(1,i2),cslto(1,i3),
     -              cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
                  do k=1,3
                    d2(k)=r234(k,2,1)
                    d3(k)=r234(k,3,1)
                    d4(k)=r234(k,4,1)
                  end do
                else
                  if (isolnear .ne. isol) idiff=1
                end if
              end if
            else if (looptyp(it) .eq. 2) then
c             See if the solution nearest to the original is the solution found
              if (idiff .ne. -1) then
                call revprox(idebug(69),c(1,i1),r3,r4,r6,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r3o,r4o,r6o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 3) then
              if (idiff .ne. -1) then
c               See if the solution nearest to the original is the one found
                call revprox(idebug(69),c(1,i1),r3,r5,r6,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r3o,r5o,r6o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 4) then
              if (idiff .ne. -1) then
                call revprox(idebug(69),c(1,i1),r3,r4,r5,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r3o,r4o,r5o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 5) then
              if (idiff .ne. -1) then
c               See if the solution nearest to the original is the one found
                call revprox(idebug(69),c(1,i1),r3,r4,r5,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r3o,r4o,r5o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 6) then
              if (idiff .ne. -1) then
c               See if the solution nearest to the original is the one found
                call revprox(idebug(69),c(1,i1),r2,r4,r5,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r2o,r4o,r5o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 7) then
              if (idiff .ne. -1) then
c               See if the solution nearest to the original is the one found
                call revprox(idebug(69),c(1,i1),r2,r3,r5,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r2o,r3o,r5o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 8) then
              if (idiff .ne. -1) then
c               See if the solution nearest to the original is the one found
                call revprox(idebug(69),c(1,i1),r2,r3,r4,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r2o,r3o,r4o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            else if (looptyp(it) .eq. 9) then
              if (idiff .ne. -1) then
c               See if the solution nearest to the original is the one found
                call revprox(idebug(69),c(1,i1),r2,r3,r4,c(1,i5),
     -            cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -            cslt(1,i5),r2o,r3o,r4o,cslto(1,i2),cslto(1,i3),
     -            cslto(1,i4),drevtol,idiff,iout,idebug(71)-1)
              end if
            end if
          end if
          if (idiff .eq. 1) then
            ptaccfac=0.0
            numrevrej=numrevrej+1
            irejtyp=3
            return
          else
            call saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -        it,looplist,iquata,c,looptyp,dihang,r2,r3,r4,r5,r6,r7,
     -        i0,i1,i2,i3,i4,i5,i6,ii2,ii3,ii4,ii5,ii6,ii7,
     -        idebug(63),iout)
            if (idebug(63) .gt. 1
     -        .and. (idiff .ne. -1 .or. looptyp(it) .eq. 1))
     -        write (iout,7008) (ii,(cslto(k,iquata(looplist(ii,it),3)),
     -        k=1,3),(c(k,iquata(looplist(ii,it),3)),k=1,3),ii=1,6)
            if (ntorlim .gt. 0) then
c             Check loop members for limit
              do itt=1,6
                itc=looplist(itt,it)
                call checktorlim(dihang(itc),dih0(itc),deldih(itc),
     -            ptaccfac,irejtyp)
c               Reject when angle went out of limit
                if (irejtyp .eq. 4) return
              end do
            end if
          end if
          if (iop(91) .gt. 0) then
c           Calculate Jacobian ratio (unless done earlier)
            if (iop(91) .lt. 3) then
c             Calculate the Jacobians for the initial and final states
c             to account for the volume-element changes
              call jacobian(c(1,i0),c(1,i1),c(1,i2),c(1,i3),c(1,i4),
     -          c(1,i5),c(1,i6),detjacnew,iout,njacsing,idebug(72))
              call jacobian(c(1,i0),cslto(1,i1),cslto(1,i2),
     -          cslto(1,i3),cslto(1,i4),c(1,i5),c(1,i6),detjacold,
     -          iout,njacsing,idebug(72))
              ptaccfac=ptaccfac*detjacnew/detjacold
            end if
c           Reduce the range of atom regeneration and energy calculation
            lasttorgenit=looplist(6,it)-1
            call modloopinc(it,looptyp(it),iri,looplist,#ST,#LT,1)
          end if
        else
c         Torsion move
          if (istune(3) .gt. 0) then
            call picltune(targetacc(3),accsumtor(itn),
     -        accsumtorprev(itn),gain(3),timeint(3),torstep(itn),
     -        tunstpmn(3),tunstpmx(3),3,itn,istunetyp(3),idebug(40),
     -        iout)
            if (iskewdr .gt. 0)
     -        call checkskewtors(iskew(it),torstep(itn),wskewstepmin,
     -          resumefac,dihang(it),it,idebug(146),iout)
          end if
          if (torstep(itn) .eq. 0.0) then
c           No change - accept unconditionally
            nochange=1
            return
          end if
          if (iop(58) .eq. 1) then
            movnam='UNIF'
            torch=torcha(drno(itr),torstep(itn),iop(99))
            if (iskew(it) .eq. 1 .and. iskewdr .eq. 1)
     -        call skewtors(torch,targetang(it),dihang(it),wskewinv,it,
     -          idebug(144))
            dihang(it)=dihang(it)+torch
            if (idebug(31) .gt. 0) write (iout,7001)
     -              itormov,it,torstep(itn),0.0,dihang(it)
          else if (iop(58). ge. 2) then
            movnam='EXBI'
            dx=c(1,iquata(it,3))-c(1,iquata(it,2))
            dy=c(2,iquata(it,3))-c(2,iquata(it,2))
            dz=c(3,iquata(it,3))-c(3,iquata(it,2))
            dxyz=sqrt(dx**2+dy**2+dz**2)
            dx=dx/dxyz
            dy=dy/dxyz
            dz=dz/dxyz
            do iaa=1,nnexttorat(itangindx(it))
              dxsx=c(1,irotlist(irotlinc(it)+iaa))-c(1,iquata(it,2))
              dxsy=c(2,irotlist(irotlinc(it)+iaa))-c(2,iquata(it,2))
              dxsz=c(3,irotlist(irotlinc(it)+iaa))-c(3,iquata(it,2))
              dxsxyz2=dxsx**2+dxsy**2+dxsz**2
              rr=(dxsxyz2-(dxsx*dx+dxsy*dy+dxsz*dz)**2)
              cv3(iaa)=rr
              iaaa=irotlist(irotlinc(it)+iaa)
              cv1(iaaa)=rr
              if (idebug(34) .gt. 1) write (iout,7781) it,iaa,iaaa,
     -          sqrt(rr),sqrt(dxsxyz2)
              abx(iaaa)=dxsxyz2
            end do
            cv2(itr)=extbias(cv3,iop(58),torstep(itn),
     -        nnexttorat(itangindx(it)),bf)
            torch=torcha(drno(itr),cv2(itr),iop(99))
            if (iskew(it) .eq. 1 .and. iskewdr .eq. 1)
     -        call skewtors(torch,targetang(it),dihang(it),wskewinv,it,
     -          idebug(144))
            dihang(it)=dihang(it)+torch
            if (idebug(31) .gt. 0) write (iout,7001) itormov,it,
     -        torstep(itn),bf,cv2(itr)*rdtodg,dihang(it)*rdtodg,
     -        dihango(it)*rdtodg
          end if
          if (ntorlim .gt. 0) then
            if (it .gt. ntorpmf) then
              call checktorlim(dihang(it),dih0(it),
     -          deldih(it),ptaccfac,irejtyp)
c             Reject when angle went out of limit
              if (irejtyp .eq. 4) return
            end if
          end if
        end if
        if (lasttorgenit .gt. lasttorgen) lasttorgen=lasttorgenit
        if (iltorgrgrit .gt. iltorgrgr) iltorgrgr=iltorgrgrit
        if (idebug(60) .gt. 0)
     -     write (iout,7007) movnam,it,lasttorgen,iltorgrgr
        if (dihang(it) .gt. pi) dihang(it)=dihang(it)-pi2
        if (dihang(it) .le. -pi) dihang(it)=dihang(it)+pi2
      end do
8000  do icoptor=ncoptorfact,ncoptoract
c       Generate the new coordinates of the atoms affected with the torsion(s)
        do it=ifdhgrlst(itormov),ildhgrlst(itormov)
          call origtor(it,itorig,iop(69),itn)
          if (looptry(it) .gt. 0) then
c           Recalculate last torsion angle
            it6=looplist(6,it)
            if (looptyp(it) .eq. 1) then
              dihang(it6)=dihangl(r4,cslto(1,i5),cslto(1,i6),
     -          cslto(1,iquata(it6,4)),idebug(63),iout)
            else if (looptyp(it) .eq. 2) then
              dihang(it6)=dihangl(r7,cslto(1,ii8),cslto(1,ii9),
     -          cslto(1,iquata(it6,4)),idebug(63),iout)
            else if (looptyp(it) .eq. 3) then
              dihang(it6)=dihangl(r7,cslto(1,ii8),cslto(1,ii9),
     -          cslto(1,iquata(it6,4)),idebug(63),iout)
            else if (looptyp(it) .lt. 10) then
c             Proline loops
              dihang(it6)=dihangl(r5,cslto(1,ii6),cslto(1,ii7),
     -          cslto(1,iquata(it6,4)),idebug(63),iout)
            end if
c           Recalculate bond length of torsion bonds
c           and torsion generating constants
            call updateloop(it,iquata,looplist,c,iprecursor,nrot,
     -        irotlist,irotlinc,bond,bond2,angle,cangle,bond13,bond12,
     -        angle13,cangle13,bondf,bondproj,xfac13,xfac12,cangle40,
     -        bond420,idebug(67),iout,#ST,#TR)
          end if
        end do
        im=iamolslt(lsttorgrp(ifagr)+(icoptor-ncoptorf)*nstfa0)
        if (movnam .eq. 'LOOP') then
          itor=ifdhgrlst(itormov)
c         Generate atoms moved by the backbone loop
          if (idebug(175) .gt. 1) write (iout,*) 'GENTOR cl itor=',itor
          call gentor(itor,itor,dihang,c,itangindx,iprecursor,nrot,iri,
     -      irotlist,irotlinc,sindela,cosdela,bondf,bondproj,xfac13,
     -      xfac12,bond,idebug(25),iout,#TR,#ST)
          do itt=1,5
            it=looplist(itt,itor)
            call gentor(it,it,dihang,c,itangindx,iprecursor,nrot,iri,
     -        irotlist,irotlinc,sindela,cosdela,bondf,bondproj,xfac13,
     -        xfac12,bond,idebug(25),iout,#TR,#ST)
c           Restore nrot list increments
          end do
c         Generate side chains too
          it=ifdhgrlst(itormov)
          do ii=ifsctlist(it),ilsctlist(it)
            iit=isctlist(ii)
            call gentor(iit,iltmovtg(itorgrp(iit)),dihang,c,itangindx,
     -        iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -        bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -        #TR,#ST)
          end do
          if (idebug(175) .gt. 1) then
            write (iout,1000) 'REMARK LEU loop after trial move'
            write (iout,7013) (i,labslt(2,i),labslt(1,i)(1:3),'S',1,
     -        (c(k,i),k=1,3),1.0,1.0,i=1,nstta)
          end if
c         Restore nrot list increments
c         iri(ifdhgrlst(itormov))=1
          call modloopinc(it,looptyp(it),iri,looplist,#ST,#LT,-1)
          if (idebug(74) .gt. 1 .or. idebug(71) .gt. 2) then
            im=iamolslt(lsttorgrp(ifagr))
            call checkgeom(ifirstm(im),ilastm(im),c,rlcslt,nneig,ineig,
     -        iout,1,d12tol,d13tol,nerr12,nerr13,devmax12,devmax13,
     -        devav12,devav13,#NL,imx12,jmx12,'after GENTOR',12,#ST)
            call torcontest(ntang,iquata,c,2,nfail0,iout,
     -        #ST,#TR)
            if (idebug(71) .gt. 2) then
              lfilnam=11
              filnam(1:lfilnam)='DEBUG_O.pdb'
              call savepdb('PDB ',keycol,iupdb1,iout,1,nstta,3,cslto,
     -          -1,0,0,1,filnam,lenfilnam,nmc,2,filnam,lfilnam,1,1,0,
     -          inperr,nwarn,nwwarn,11,0,nlwr,0,-1,#ST)
              lfilnam=11
              filnam(1:lfilnam)='DEBUG_N.pdb'
              call savepdb('PDB ',keycol,iupdb2,iout,1,nstta,3,c,
     -          -1,0,0,1,filnam,lenfilnam,nmc,2,filnam,lfilnam,1,1,0,
     -          inperr,nwarn,nwwarn,10,0,nlwr,0,-1,#NA)
            end if
          end if
        else
          if (idebug(175) .gt. 1) write (iout,*) 'GENTOR call noloop',
     -      ' it=',iftmovtg(itormov)
          call gentor(iftmovtg(itormov),lasttorgen,dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,bondf,
     -      bondproj,xfac13,xfac12,bond,idebug(25),iout,#TR,#ST)
          if (idebug(175) .gt. 1) then
            write (iout,1000) 'REMARK config after simple torsion move'
            write (iout,7013) (i,labslt(2,i),labslt(1,i)(1:3),'S',1,
     -        (c(k,i),k=1,3),1.0,1.0,i=1,nstta)
          end if
        end if
        if (iop(91) .gt. 0) then
          do it=ifdhgrlst(itormov),ildhgrlst(itormov)
            if (looptry(it) .gt. 0)
     -        call modloopinc(it,looptyp(it),iri,looplist,#ST,#LT,-1)
          end do
        end if
        if (looptyp(it) .eq. 0 .and. iop(58) .ge. 2 .and.
     -    (numtors .gt. 1 .or. idebug(34) .gt. 0)) then
          do it=ifdhgrlst(itormov),ildhgrlst(itormov)
            call origtor(it,itorig,iop(69),itn)
C@DB        ndiszno=0
            dx=c(1,iquata(it,3))-c(1,iquata(it,2))
            dy=c(2,iquata(it,3))-c(2,iquata(it,2))
            dz=c(3,iquata(it,3))-c(3,iquata(it,2))
            dxyz=sqrt(dx**2+dy**2+dz**2)
            dx=dx/dxyz
            dy=dy/dxyz
            dz=dz/dxyz
            extmax2=0.0
            extav2=0.0
            do iaa=1,nnexttorat(itangindx(it))
              dxsx=c(1,irotlist(irotlinc(it)+iaa))-c(1,iquata(it,2))
              dxsy=c(2,irotlist(irotlinc(it)+iaa))-c(2,iquata(it,2))
              dxsz=c(3,irotlist(irotlinc(it)+iaa))-c(3,iquata(it,2))
              dxsxyz2=dxsx**2+dxsy**2+dxsz**2
              rr=(dxsxyz2-(dxsx*dx+dxsy*dy+dxsz*dz)**2)
              cv3(iaa)=rr
              if (rr .gt. extmax2) extmax2=rr
                extav2=extav2+rr
              iaaa=irotlist(irotlinc(it)+iaa)
              abx(iaaa)=dxsxyz2
              if (idebug(34) .gt. 1) write (iout,7782) it,iaa,iaaa,
     -            sqrt(rr),sqrt(dxsxyz2)
              if (it .eq. ildhgrlst(itormov)) then
                if (abs(rr-cv1(iaaa)) .gt. 0.1) then
                  write (iout,7651) it,iaaa,cv1(iaaa),rr,
     -              sqrt(abx(iaaa)),sqrt(dxsxyz2)
C@DB              ndiszno=ndiszno+1
                end if
              end if
            end do
            if (numtors .gt. 1) then
c             Acceptance modification for detailed balance
              revrange=extbias(cv3,iop(58),torstep(itn),
     -          nnexttorat(itangindx(it)),bf)
              if (abs(dihang(it)-dihango(it))*2.0 .gt. revrange) then
c               If reverse move becomes inaccessible, reject for sure
                ptaccfac=0.0
                return
              end if
c             Pacc=>Pacc*P(j->i)/P(i->j):
              ptaccfac=ptaccfac*revrange/cv2(it-ifdhgrlst(itormov)+1)
            end if
          end do
C@DB      if (ndiszno .gt. 0 .and. idebug(34) .gt. 2) then
C@DB        lfilnam=11
C@DB        filnam(1:lfilnam)='DEBUG_O.pdb'
C@DB        call savepdb('PDB ',keycol,iupdb1,iout,1,nstta,3,cslto,
C@DB     -    -1,0,0,1,filnam,lfilnam,nmc,2,filnam,lenfilnam,1,1,0,inperr,
C@DB     -    nwarn,nwwarn,10,0,0,-1,#ST)
C@DB        lfilnam=11
C@DB        filnam(1:lfilnam)='DEBUG_N.pdb'
C@DB        call savepdb('PDB ',keycol,iupdb2,iout,1,nstta,3,c,
C@DB     -    -1,0,0,1,filnam,lfilnam,nmc,2,filnam,lenfilnam,1,1,0,inperr,
C@DB     -    nwarn,nwwarn,11,0,nlwr,0,-1,#NA)
C@DB        call datprt(2)
C@DB      end if
        end if
      end do
      if (idebug(63) .gt. 0) then
        do it=ifdhgrlst(itormov),ildhgrlst(itormov)
          if (looptry(it) .gt. 0) then
            write (iout,7002) 'OLD',it,dihango(it)*rdtodg,
     -        (looplist(ii,it),dihango(looplist(ii,it))*rdtodg,ii=1,6)
            write (iout,7002) 'NEW',it,dihang(it)*rdtodg,
     -        (looplist(ii,it),dihang(looplist(ii,it))*rdtodg,ii=1,6)
            write (iout,7004) it,(iquata(it,kk),kk=1,4),
     -        (looplist(ii,it),(iquata(looplist(ii,it),kk),kk=1,4),
     -        ii=1,6)
            do ia=ifagr,ilagr
              iia=lsttorgrp(ia)+(icoptor-ncoptorf)*nstfa0
              write (iout,7003) iia,(cslto(k,iia),k=1,3),
     -          (c(k,iia),k=1,3),sqrt(arrdist(c(1,iia),cslto(1,iia)))
            end do
          end if
        end do
      end if
      return
7001  format (' DEPLOYPT',/,' t.gr.,tors.:',2i5,' step: ',
     -  f8.4,'  extmax,range: ',2f10.5,' angle(n,o)=',2f10.5)
7002  format (' DEPLOYPT dihang loop: ',a3,7(i5,f10.3))
7003  format (' DEPLOYPT ia=',i5,' cold=',3f10.5,' cnew=',3f10.5,
     -  ' d=',f8.5)
7004  format (' DEPLOYPT ',(' loop root,iqua:',i4,4i5),/,
     -  10x,3(' it,iqua:',i4,4i5),/,10x,3(' it,iqua:',i4,4i5))
7005  format(' DEPLOYPT driver',i5,' loop member',i5,' target=',f8.2,
     -  ' old=',f8.2,' new=',f8.2,' devsum(o,n)=',2e13.5)
7006  format(' DEPLOYPT driver torsion: ',i5,' loop move kept')
7007  format (' DEPLOYPT ',a,' torsion try it=',i5,' lasttorgen=',i5,
     -  ' iltorgrgr=',i5)
7008  format (' DEPLOYPT ia=',i5,' cslto:',3f10.5,' c:',3f10.5)
7009  format(' it=',i4,4(' c(',i4,')=',3f9.4))
7010  format(' DEPLOYPT it=',i5,' dflsmin,max=',2f10.5,' dijf,l=',
     -  2f10.5,' dijrev,sol=',2f10.5,' divr3=',f8.5)
7011  format(' DEPLOYPT i0,i1,i2,i3,i4,i5,i6=',7i5,
     -  ' ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9=',10i5)
7012  format(' DEPLOYPT  it=',i4,4('     c(',i4,')=',3f9.4),/,
     -  18x,4(' cslto(',i4,')=',3f9.4))
7013  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,f10.3,f10.3)
7781  format(' EXT-B it,iaa,iaaa=',3i5,' r=',f10.5,' r(x-rit2)=',f10.5)
7782  format(' EXT-A it,iaa,iaaa=',3i5,' r=',f10.5,' r(x-rit2)=',f10.5)
7651  format(' ***** Discrepancy: extension has changed it,iaa=',2i5,
     -  ' r2o,n=',2f10.5,' r(x-rit2)o,n=',2f10.5)
1000  format(a)
2000  format(' ERROR: no molecule was found for torsion selection ',
     -  'after ',i5,' trys - random torsion selection was done')
      end
      subroutine picltune(setpoint,current,previous,gain,integraltime,
     -  variable,vmin,vmax,ityp,iax,istunetyp,idebug,iout)
c#    MMC routine 145/a lstmod: 01/22/15
c*****Perform a process-control tuning step
      real*8 current,previous,gain,integraltime
      real*8 change,controlerror
      character*3 typlab(4)
      character*4 typname(4)
      data typlab /'iax','iax','itn','itn'/
      data typname /'TRAN','ROTA','TORS','LOOP'/
      if (istunetyp .eq. 1) then
        controlerror=current-dble(setpoint)
        change=current-previous
      else
c       Tune on logarithms
        controlerror=dlog(current)-dble(alog(setpoint))
        change=dlog(current)-dlog(previous)
      end if
      variableprev=variable
c      write (iout,2003)
c     -  variableprev,gain,change,integraltime,controlerror
c2003  format(' variableprev=',e13.6,' gain=',f8.2,' change=',e13.6,
c     -  ' integraltime=',e12.5,' controlerror=',e13.6)
      variable=variable+gain*change+(gain/integraltime)*controlerror
      if (variable .lt. vmin) variable=vmin
      if (variable .gt. vmax) variable=vmax
      if (idebug .gt. 1) then
        if (istunetyp .eq. 1) then
          write (iout,1000) 'PICL',typname(ityp),current,
     -      previous,variableprev,variable,typlab(ityp),iax
          if (idebug .gt. 2) write (iout,1002) setpoint,vmin,vmax
        else if (istunetyp .eq. 2) then
          write (iout,1000) 'PCLG',typname(ityp),dlog(current),
     -      dlog(previous),variableprev,variable,typlab(ityp),iax
          if (idebug .gt. 2) write (iout,1002) alog(setpoint),vmin,vmax
        else
          write (iout,1001) istunetyp
          call datprt(2)
        end if
      end if
      return
1000  format(1x,a,1x,a,' current=',e13.6,' previous=',e13.6,
     -  ' variableprev=',e13.6,' variable=',e13.6,1x,a,'=',i5)
1002  format(' setpoint=',f10.5,' vmin,mx=',2f8.3)
1001  format(' ***** PROGRAM ERROR: invalid tuning code:',i2)
      end
      subroutine getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,i6,
     -  ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,looptyp,LEVTEST,iout,
     -  label,maxtor,maxloop)
c#    MMC routine 146 lstmod: 03/01/04
c*****Establish the list of loop atom indices
      dimension iquata(maxtor,4),looplist(6,maxloop),ix(8),itl(8)
      character*10 label
      i0=iquata(it,3)
      i1=iquata(looplist(1,it),3)
      i2=iquata(looplist(2,it),3)
      i3=iquata(looplist(3,it),3)
      i4=iquata(looplist(4,it),3)
      i5=iquata(looplist(5,it),3)
      i6=iquata(looplist(6,it),3)
      if (looptyp .eq. 1) then
        ii0=i0
        ii1=i1
        ii2=i2
        ii3=i3
        ii4=i4
        ii5=i5
        ii6=i6
        ii7=1
        ii8=1
        ii9=1
      else if (looptyp .eq. 2) then
c       Peptide bonds, 3[-=-]
        ii0=i0
        ii1=i1
        ii2=iquata(looplist(1,it),4)
        ii3=i2
        ii4=i3
        ii5=iquata(looplist(3,it),4)
        ii6=i4
        ii7=i5
        ii8=iquata(looplist(5,it),4)
        ii9=i6
      else if (looptyp .eq. 3) then
c       Peptide bonds, 3[=--]
        ii0=i0
        ii1=iquata(it,4)
        ii2=i1
        ii3=i2
        ii4=iquata(looplist(2,it),4)
        ii5=i3
        ii6=i4
        ii7=iquata(looplist(4,it),4)
        ii8=i5
        ii9=i6
      else if (looptyp .gt. 3) then
c       Consecutive bonds with one break
        iptyp=looptyp-3
        ii0=i0
        itl(1)=it
        ix(1)=iquata(it,3)
        do i=2,7
          itl(i)=looplist(i-1,it)
          ix(i)=iquata(itl(i),3)
        end do
        do i=iptyp+1,7
          j=iptyp+9-i
          ix(j)=ix(j-1)
        end do
        ix(iptyp+1)=iquata(itl(iptyp),4)
        ii1=ix(2)
        ii2=ix(3)
        ii3=ix(4)
        ii4=ix(5)
        ii5=ix(6)
        ii6=ix(7)
        ii7=ix(8)
        ii8=1
        ii9=1
      end if
      if (LEVTEST .gt. 0) then
        write (iout,1000) label,it,looptyp,i0,i1,i2,i3,i4,i5,i6
        if (looptyp .gt. 1) write (iout,1001)
     -    label,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9
      end if
      return
1000  format(' GETLOOPATOMS (',a,') it=',i4,' ltyp=',i2,' i0-6=',7i5)
1001  format(' GETLOOPATOMS (',a,') ii0-9=',10i6)
      end
      subroutine saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -  it,looplist,iquata,c,looptyp,dihang,r2,r3,r4,r5,r6,r7,
     -  i0,i1,i2,i3,i4,i5,i6,ii2,ii3,ii4,ii5,ii6,ii7,
     -  LEVTEST,iout)
c#    MMC routine 147 lstmod: 04/27/04
      dimension looplist(6,#LT),iquata(#TR,4),c(3,#NA),
     -  looptyp(#TR),dihang(#TR),r2(3),r3(3),r4(3),r5(3),r6(3),
     -  r7(3),d0(3),d1(3),d2(3),d3(3),d4(3),d5(3),d6(3),d7(3),
     -  d8(3),d9(3)
      real*8 d0,d1,d2,d3,d4,d5,d6,d7,d8,d9
      real*8 dd1,dd2
      dimension dd1(3),dd2(3)
      it1=looplist(1,it)
      it2=looplist(2,it)
      it3=looplist(3,it)
      it4=looplist(4,it)
      it5=looplist(5,it)
      it6=looplist(6,it)
      if (looptyp(it) .eq. 1) then
        call trnsfr(c(1,i2),r2,3)
        call trnsfr(c(1,i3),r3,3)
        call trnsfr(c(1,i4),r4,3)
        if (LEVTEST .gt. 0) write (iout,1000) 1,i2,i3,i4
c       Calculate the new torsion angles from d*
        do k=1,3
          dd1(k)=c(k,iquata(it,2))
          d0(k)=c(k,i0)
          d1(k)=c(k,i1)
          d5(k)=c(k,i5)
          d6(k)=c(k,i6)
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d0,d1,d2,d3,LEVTEST,iout)
        dihang(it3)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it4)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it5)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it6)=dihangld(d4,d5,d6,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 2) then
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        call trnsfr(c(1,ii6),r6,3)
        call trnsfr(c(1,ii7),r7,3)
        if (LEVTEST .gt. 0) write (iout,1000) 2,ii2,ii3,ii4,ii5,ii6,ii7
c       Calculate the new torsion angles from d2-d7
        do k=1,3
          dd1(k)=c(k,iquata(it,2))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it3)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it4)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it5)=dihangld(d5,d6,d7,d8,LEVTEST,iout)
        dihang(it6)=dihangld(d7,d8,d9,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 3) then
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        call trnsfr(c(1,ii6),r6,3)
        call trnsfr(c(1,ii7),r7,3)
        if (LEVTEST .gt. 0) write (iout,1000) 3,ii3,ii4,ii5,ii6,ii7
c       Calculate the new torsion angles from d2-d7
        do k=1,3
          dd1(k)=c(k,iquata(it1,1))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d1,d2,d3,LEVTEST,iout)
        dihang(it2)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it3)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it4)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it5)=dihangld(d6,d7,d8,d9,LEVTEST,iout)
        dihang(it6)=dihangld(d7,d8,d9,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 4) then
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (LEVTEST .gt. 0) write (iout,1000) 4,ii3,ii4,ii5
c       Calculate the new torsion angles from d3,d4,d5
        do k=1,3
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(d0,d1,d2,d3,LEVTEST,iout)
        dihang(it2)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it3)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it4)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it5)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it6)=dihangld(d5,d6,d7,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 5) then
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (LEVTEST .gt. 0) write (iout,1000) 5,ii2,ii3,ii4,ii5
c       Calculate the new torsion angles from d2-d6
        do k=1,3
          dd1(k)=c(k,iquata(it1,1))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it3)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it4)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it5)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it6)=dihangld(d5,d6,d7,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 6) then
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (LEVTEST .gt. 0) write (iout,1000) 6,ii2,ii3,ii4,ii5
c       Calculate the new torsion angles from d2-d6
        do k=1,3
          dd1(k)=c(k,iquata(it1,1))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d0,d1,d2,d3,LEVTEST,iout)
        dihang(it3)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it4)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it5)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it6)=dihangld(d5,d6,d7,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 7) then
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (LEVTEST .gt. 0) write (iout,1000) 7,ii2,ii3,ii4,ii5
c       Calculate the new torsion angles from d2-d6
        do k=1,3
          dd1(k)=c(k,iquata(it1,1))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d0,d1,d2,d3,LEVTEST,iout)
        dihang(it3)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it4)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it5)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it6)=dihangld(d5,d6,d7,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 8) then
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (LEVTEST .gt. 0) write (iout,1000) 8,ii2,ii3,ii4,ii5
c       Calculate the new torsion angles from d2-d6
        do k=1,3
          dd1(k)=c(k,iquata(it1,1))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d0,d1,d2,d3,LEVTEST,iout)
        dihang(it3)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it4)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it5)=dihangld(d4,d5,d6,d7,LEVTEST,iout)
        dihang(it6)=dihangld(d5,d6,d7,dd2,LEVTEST,iout)
      else if (looptyp(it) .eq. 9) then
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (LEVTEST .gt. 0) write (iout,1000) 9,ii2,ii3,ii4,ii5
c       Calculate the new torsion angles from d2-r6
        do k=1,3
          dd1(k)=c(k,iquata(it1,1))
          dd2(k)=c(k,iquata(it6,4))
        end do
        dihang(it1)=dihangld(dd1,d0,d1,d2,LEVTEST,iout)
        dihang(it2)=dihangld(d0,d1,d2,d3,LEVTEST,iout)
        dihang(it3)=dihangld(d1,d2,d3,d4,LEVTEST,iout)
        dihang(it4)=dihangld(d2,d3,d4,d5,LEVTEST,iout)
        dihang(it5)=dihangld(d3,d4,d5,d6,LEVTEST,iout)
        dihang(it6)=dihangld(d5,d6,d7,dd2,LEVTEST,iout)
      end if
      if (LEVTEST .gt. 0) write (iout,1001) it,it1,dihang(it1),it2,
     -  dihang(it2),it3,dihang(it3),it4,dihang(it4),it5,dihang(it5),
     -  it6,dihang(it6)
      return
1000  format(' Loop type=',i2,' saving loop atoms ',10i7)
1001  format(' Loop torsion=',i5,' members=',6(i6,f8.2))
      end
      subroutine savelooptemp(c,corig,looptyp,r2,r3,r4,r5,r6,r7,
     -  i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,
     -  LEVTEST,iout,maxc,maxcorig)
c#    MMC routine 148 lstmod: 07/31/07
      dimension c(3,maxc),corig(3,maxcorig),
     -  r2(3),r3(3),r4(3),r5(3),r6(3),r7(3)
      if (LEVTEST .gt. 0) write (iout,1000) looptyp,
     -  ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9
      if (looptyp .eq. 1) then
        call trnsfr(c(1,i0),corig(1,i0),3)
        call trnsfr(c(1,i1),corig(1,i1),3)
        call trnsfr(c(1,i2),r2,3)
        call trnsfr(c(1,i3),r3,3)
        call trnsfr(c(1,i4),r4,3)
        call trnsfr(c(1,i5),corig(1,i5),3)
        call trnsfr(c(1,i6),corig(1,i6),3)
        if (LEVTEST .gt. 0) write (iout,1001) looptyp,
     -      0,(c(k,ii0),k=1,3),
     -      1,(c(k,ii1),k=1,3), 2,(c(k,ii2),k=1,3),
     -      3,(c(k,ii3),k=1,3), 4,(c(k,ii4),k=1,3),
     -      5,(c(k,ii5),k=1,3), 6,(c(k,ii6),k=1,3)
      else if (looptyp .le. 3) then
        call trnsfr(c(1,ii0),corig(1,ii0),3)
        call trnsfr(c(1,ii1),corig(1,ii1),3)
        call trnsfr(c(1,ii2),r2,3)
        if (looptyp .eq. 3) call trnsfr(c(1,ii2),corig(1,ii2),3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        call trnsfr(c(1,ii6),r6,3)
        call trnsfr(c(1,ii7),r7,3)
        call trnsfr(c(1,ii8),corig(1,ii8),3)
        call trnsfr(c(1,ii9),corig(1,ii9),3)
        if (LEVTEST .gt. 0) write (iout,1001) looptyp,
     -      0,(c(k,ii0),k=1,3),1,(c(k,ii1),k=1,3),
     -    2,(c(k,ii2),k=1,3),3,(c(k,ii3),k=1,3),
     -    4,(c(k,ii4),k=1,3),5,(c(k,ii5),k=1,3),
     -    6,(c(k,ii6),k=1,3),7,(c(k,ii7),k=1,3),
     -    8,(c(k,ii6),k=1,3),9,(c(k,ii7),k=1,3)
      else if (looptyp .le. 9) then
        call trnsfr(c(1,ii1),corig(1,ii1),3)
        call trnsfr(c(1,ii2),r2,3)
        call trnsfr(c(1,ii3),r3,3)
        call trnsfr(c(1,ii4),r4,3)
        call trnsfr(c(1,ii5),r5,3)
        if (looptyp .eq. 4) then
          call trnsfr(c(1,ii7),corig(1,ii7),3)
        else
          call trnsfr(c(1,ii6),corig(1,ii6),3)
        end if
        if (LEVTEST .gt. 0) then
           if (looptyp .eq. 4) then
             ii67=ii7
           else
             ii67=ii6
           end if
           write (iout,1001) looptyp,
     -      1,(c(k,ii1),k=1,3), 2,(c(k,ii2),k=1,3),
     -      3,(c(k,ii3),k=1,3), 4,(c(k,ii4),k=1,3),
     -      5,(c(k,ii5),k=1,3), 6,(c(k,ii67),k=1,3)
        end if
      end if
      return
1000  format(' Loop type=',i2,' temporary save indices:',10i6)
1001  format(' Loop type=',i2,' temporary save coordinates:',/,
     -  (2(' c(ii',i1,')=',3f10.5)))
      end
      subroutine revprox(loose,c1,c2,c3,c4,c5,cr1,cr2,cr3,cr4,cr5,
     -  cs2,cs3,cs4,cso2,cso3,cso4,drevtol,idiff,iout,LEVTEST)
c#    MMC routine 149 lstmod: 03/25/02
c*****Check reverse proximity criterion
      dimension c1(3),c2(3),c3(3),c4(3),c5(3),cr1(3),cr2(3),cr3(3),
     -  cr4(3),cr5(3),cs2(3),cs3(3),cs4(3),cso2(3),cso3(3),cso4(3)
c     c*: solution found; cr*: reference configuration
c     cs*: reverse solution found; cso*: original initial configuration
      if (loose .gt. 0) then
c       Get tolerance loosening values
        dev12=abs(arrdist(cr1,cr2)-arrdist(c1,c2))
        dev23=abs(arrdist(cr2,cr3)-arrdist(c2,c3))
        dev34=abs(arrdist(cr3,cr4)-arrdist(c3,c4))
        dev45=abs(arrdist(cr4,cr5)-arrdist(c4,c5))
        tolinc2=amax1(dev12,dev23)
        tolinc3=amax1(dev23,dev34)
        tolinc4=amax1(dev34,dev45)
      else
        tolinc2=0.0
        tolinc3=0.0
        tolinc4=0.0
      end if
      if (arrdist(cs2,cso2) .gt. drevtol+tolinc2 .or.
     -    arrdist(cs3,cso3) .gt. drevtol+tolinc3 .or.
     -    arrdist(cs4,cso4) .gt. drevtol+tolinc4) idiff=1
      if (LEVTEST .gt. 0)
     -  write (iout,1000) cso2,cso3,cso4,cs2,cs3,cs4,idiff
      return
1000  format(' REVPROX cso2-4:',3(3f10.5,2x),/,
     -  ' REVPROX  cs2-4:',3(3f10.5,2x),' idiff=',i2)
      end
      subroutine modloopinc(it,looptyp,iri,looplist,maxat,maxltor,
     -  isaverest)
c#    MMC routine 150 lstmod: 06/11/04
c*****Modify gentor increments to protect loop members from regenerating
      dimension iri(maxat),looplist(6,maxltor)
      if (isaverest .eq. 1) then
c       Save loop-protecting increment values
        do ii=1,6
          iri(looplist(ii,it))=2
        end do
        if (looptyp .eq. 2) then
          iri(looplist(1,it))=3
          iri(looplist(3,it))=3
          iri(looplist(5,it))=3
        else if (looptyp .eq. 3) then
          iri(looplist(2,it))=3
          iri(looplist(4,it))=3
        else if (looptyp .eq. 4) then
          iri(it)=3
        else if (looptyp .gt. 4) then
          iri(looplist(looptyp-4,it))=3
        end if
      else
c       Restore standard increments
        do ii=1,6
          iri(looplist(ii,it))=1
        end do
        if (looptyp .eq. 4) iri(it)=1
      end if
      return
      end
      subroutine closeloop(r234,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,dflsmn,
     -  dflsmx,dflsmnr,dflsmxr,deldij,it,c,cref,cslt,r2,r3,r4,
     -  r5,r6,r7,i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,
     -  ii8,ii9,label,igetloopat,ifr,ibf,nsol,isol,nosoltyp,neval,
     -  inperr,iout)
c#    MMC routine 151 lstmod: 02/24/21
      dimension cref(3,#ST),c(3,#ST),cslt(3,#ST),r234(3,4,32),
     -  r2(3),r3(3),r4(3),r5(3),r6(3),r7(3),
     -  c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),c9(3)
      real*8 dflsmn,dflsmx,dflsmnr,dflsmxr,deldij,r234,c0,c1,c2,c3,c4,
     -  c5,c6,c7,c8,c9
      character*10 label
c*****Call the requisite loop-closing routine for driver torsion it
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),
     -  d02(#LT),d03(#LT),d12(#LT),d13(#LT),
     -  d14(#LT),d23(#LT),d24(#LT),d25(#LT),d34(#LT),d35(#LT),
     -  d36(#LT),d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),d79(#LT)
      common /option/ iop(200),idebug(200)
      real*8 darrdists,dxymin,dxymax,dxyminr,dxymaxr,deldijr,
     -  cc2,cc3,cc4,cc5,cc6,cc7
      dimension cc2(3),cc3(3),cc4(3),cc5(3),cc6(3),cc7(3),
     -  rr2(3),rr3(3),rr4(3),rr5(3),rr6(3),rr7(3)
      character*10 lab
      ltyp=looptyp(it)
      if (dflsmx .eq. 0.d0) then
        dxymin=dflsmin(it)
        dxymax=dflsmax(it)
        dxyminr=dflsminr(it)
        dxymaxr=dflsmaxr(it)
      else
        dxymin=dflsmn
        dxymax=dflsmx
        dxyminr=dflsmnr
        dxymaxr=dflsmxr
      end if
      if (igetloopat .gt. 0)
     -  call getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,
     -    i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,
     -    ltyp,idebug(71),iout,label,#TR,#LT)
      unrelfac=100.0
      lab=label
      if (idebug(111) .gt. 1)  write (iout,1003)
     -  it,ltyp,(cref(k,ii0),k=1,3),(cref(k,ii1),k=1,3),
     -  (cref(k,ii2),k=1,3),(cref(k,ii3),k=1,3),(cref(k,ii4),k=1,3),
     -  (cref(k,ii5),k=1,3),(cref(k,ii6),k=1,3),(cref(k,ii7),k=1,3),
     -  (cref(k,ii8),k=1,3),(cref(k,ii9),k=1,3)
      if (ltyp .eq. 1) then
c       Consecutive torsions
        call closeloopconsec(it,nsol,cref,cref(1,i2),
     -    cref(1,i3),cref(1,i4),cref,c,r2,r3,r4,r234,
     -    i0,i1,i2,i5,i6,divr3,d3tol,d24tol,dijtol,dextol,
     -    drevtol,isol,nosoltyp,neval,inperr,iout)
      else if (ltyp .lt. 10) then
c       Decide if forward or reverse loop calculation will be done
        if (iop(103) .le. 2) then
          ibf=3-2*iop(103)
        else if (iop(103) .eq. 3) then
          call decidebf(ibf,cref,d02(it),d12(it),d13(it),d23(it),
     -      d45(it),d46(it),d56(it),d57(it),ii0,ii1,ii2,ii3,ii4,ii5,ii6,
     -      ii7,ltyp)
        end if
        if (ibf .eq. 1 .or. iop(103) .eq. 4) then
          if (ltyp .eq. 2) then
c           Peptide bonds, 3[-=-]
            call closelooppep2(it,nsol,cref,cref(1,ii2),
     -        cref(1,ii3),cref(1,ii4),cref(1,ii5),cref(1,ii6),
     -        cref(1,ii7),c,cslt,r2,r3,r4,r5,r6,r7,
     -        d02(it),d03(it),d12(it),d13(it),d23(it),d24(it),
     -        d34(it),d35(it),d36(it),d45(it),d46(it),d56(it),
     -        d57(it),d67(it),d68(it),d69(it),d78(it),d79(it),
     -        c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -        ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,label,
     -        darrdists(cref(1,ii1),cref(1,ii6)),dxymin,dxymax,deldij,
     -        0,divr3,d3tol,unrelfac,d24tol,dijtol,dihpmtol,nosoltyp,
     -        nimptry(2,ifr),nimpfound(1,2,ifr),neval,inperr,iout)
          else if (ltyp .eq. 3) then
c           Peptide bonds, 3[=--]
            call closelooppep3(it,nsol,cref,cref(1,ii3),
     -        cref(1,ii4),cref(1,ii5),cref(1,ii6),cref(1,ii7),
     -        c,cslt,r3,r4,r5,r6,r7,
     -        d13(it),d23(it),d24(it),d25(it),d34(it),d35(it),
     -        d45(it),d46(it),d56(it),d57(it),d58(it),d67(it),
     -        d68(it),d78(it),d79(it),c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -        ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,label,
     -        darrdists(cref(1,ii2),cref(1,ii7)),dxymin,dxymax,
     -        deldij,0,divr3,d3tol,unrelfac,d24tol,dijtol,dihpmtol,
     -        nosoltyp,nimptry(3,ifr),nimpfound(1,3,ifr),neval,inperr,
     -        iout)
          else if (ltyp .lt. 10) then
            call closelooppro1(it,nsol,cref,cref(1,ii2),
     -        cref(1,ii3),cref(1,ii4),cref(1,ii5),c,cslt,r2,r3,r4,r5,
     -        d02(it),d03(it),d12(it),d13(it),d14(it),d23(it),d24(it),
     -        d25(it),d34(it),d35(it),d36(it),d45(it),d46(it),d47(it),
     -        d56(it),d57(it),c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -        ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,label,dxymin,dxymax,
     -        deldij,0,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptry(ltyp,1),
     -        nimpfound(1,ltyp,1),neval,iout,ltyp,1)
          end if
          if (idebug(109) .gt. 0)
     -      write (iout,1002) 'FWRD',it,ltyp,nsol,deldij
        end if
        if (ibf .eq. -1) then
          lab=label(1:8)//'R1'
          if (ltyp .eq. 2) then
c           Peptide bonds, 3[=--]
            call closelooppep2(it,nsol,cref,cref(1,ii7),
     -        cref(1,ii6),cref(1,ii5),cref(1,ii4),cref(1,ii3),
     -        cref(1,ii2),c,cslt,r7,r6,r5,r4,r3,r2,
     -        d79(it),d69(it),d78(it),d68(it),d67(it),d57(it),
     -        d56(it),d46(it),d36(it),d45(it),d35(it),d34(it),
     -        d24(it),d23(it),d13(it),d03(it),d12(it),d02(it),
     -        c9,c8,c7,c6,c5,c4,c3,c2,c1,c0,
     -        ii9,ii8,ii7,ii6,ii5,ii4,ii3,ii2,ii1,ii0,lab,
     -        darrdists(cref(1,ii3),cref(1,ii8)),
     -        dxyminr,dxymaxr,deldijr,1,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptr,nimpfound(1,2,ifr),neval,
     -        inperr,iout)
          else if (ltyp .eq. 3) then
c           Peptide bonds, 3[=--]
            call closelooppep3(it,nsol,cref,cref(1,ii7),
     -        cref(1,ii6),cref(1,ii5),cref(1,ii4),cref(1,ii3),
     -        c,cslt,r7,r6,r5,r4,r3,
     -        d79(it),d78(it),d68(it),d58(it),d67(it),d57(it),
     -        d56(it),d46(it),d45(it),d35(it),d25(it),d34(it),
     -        d24(it),d23(it),d13(it),c9,c8,c7,c6,c5,c4,c3,c2,c1,
     -        ii9,ii8,ii7,ii6,ii5,ii4,ii3,ii2,ii1,lab,
     -        darrdists(cref(1,ii3),cref(1,ii8)),dxyminr,dxymaxr,
     -        deldijr,1,divr3,d3tol,unrelfac,d24tol,dijtol,dihpmtol,
     -        nosoltyp,nimptry(3,ifr),nimpfound(1,3,ifr),neval,inperr,
     -        iout)
          else if (ltyp .eq. 4) then
            call closelooppro1(it,nsol,cref,cref(1,ii2),
     -        cref(1,ii3),cref(1,ii4),cref(1,ii5),c,cslt,r2,r3,r4,r5,
     -        d02(it),d03(it),d12(it),d13(it),d14(it),d23(it),d24(it),
     -        d25(it),d34(it),d35(it),d36(it),d45(it),d46(it),d47(it),
     -        d56(it),d57(it),c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -        ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,label,dxyminr,dxymaxr,
     -        deldijr,0,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptry(ltyp,1),
     -        nimpfound(1,ltyp,1),neval,iout,ltyp,2)
          else
            ltp=14-ltyp
            call closelooppro1(it,nsol,cref,cref(1,ii5),
     -        cref(1,ii4),cref(1,ii3),cref(1,ii2),c,cslt,r5,r4,r3,r2,
     -        d57(it),d47(it),d56(it),d46(it),d36(it),d45(it),d35(it),
     -        d25(it),d34(it),d24(it),d14(it),d23(it),d13(it),d03(it),
     -        d12(it),d02(it),c7,c6,c5,c4,c3,c2,c1,c0,c8,c9,
     -        ii7,ii6,ii5,ii4,ii3,ii2,ii1,ii0,lab,dxyminr,dxymaxr,
     -        deldijr,1,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptry(ltp,1),
     -        nimpfound(1,ltp,1),neval,iout,ltp,1)
          end if
          if (idebug(109) .gt. 0)
     -      write (iout,1002) 'REV1',it,ltyp,nsol,deldijr
        else if (iop(103) .eq. 4) then
          lab=label(1:8)//'R2'
          if (ltyp .eq. 2) then
c           Peptide bonds, 3[-=-]
            call closelooppep2(it,nsolr,cref,cref(1,ii7),
     -        cref(1,ii6),cref(1,ii5),cref(1,ii4),cref(1,ii3),
     -        cref(1,ii2),c,cslt,rr7,rr6,rr5,rr4,rr3,rr2,
     -        d79(it),d69(it),d78(it),d68(it),d67(it),d57(it),
     -        d56(it),d46(it),d36(it),d45(it),d35(it),d34(it),
     -        d24(it),d23(it),d13(it),d03(it),d12(it),d02(it),
     -        c9,c8,cc7,cc6,cc5,cc4,cc3,cc2,c1,c0,
     -        ii9,ii8,ii7,ii6,ii5,ii4,ii3,ii2,ii1,ii0,lab,
     -        darrdists(cref(1,ii3),cref(1,ii8)),
     -        dxyminr,dxymaxr,deldijr,1,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptr,nimpfound(1,2,ifr),neval,
     -        inperr,iout)
          else if (ltyp .eq. 3) then
c           Peptide bonds, 3[=--]
            call closelooppep3(it,nsolr,cref,cref(1,ii7),
     -        cref(1,ii6),cref(1,ii5),cref(1,ii4),cref(1,ii3),
     -        c,cslt,rr7,rr6,rr5,rr4,rr3,
     -        d79(it),d78(it),d68(it),d58(it),d67(it),d57(it),
     -        d56(it),d46(it),d45(it),d35(it),d25(it),d34(it),
     -        d24(it),d23(it),d13(it),c9,c8,cc7,cc6,cc5,cc4,cc3,c2,c1,
     -        ii9,ii8,ii7,ii6,ii5,ii4,ii3,ii2,ii1,lab,
     -        darrdists(cref(1,ii3),cref(1,ii8)),dxyminr,dxymaxr,
     -        deldijr,1,divr3,d3tol,unrelfac,d24tol,dijtol,dihpmtol,
     -        nosoltyp,nimptry(3,ifr),nimpfound(1,3,ifr),neval,inperr,
     -        iout)
          else if (ltyp .eq. 4) then
            call closelooppro1(it,nsolr,cref,cref(1,ii2),cref(1,ii3),
     -        cref(1,ii4),cref(1,ii5),c,cslt,rr2,rr3,rr4,rr5,
     -        d02(it),d03(it),d12(it),d13(it),d14(it),d23(it),d24(it),
     -        d25(it),d34(it),d35(it),d36(it),d45(it),d46(it),d47(it),
     -        d56(it),d57(it),c0,c1,cc2,cc3,cc4,cc5,cc6,cc7,c8,c9,
     -        ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,label,dxyminr,dxymaxr,
     -        deldijr,0,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptry(ltyp,1),
     -        nimpfound(1,ltyp,1),neval,iout,ltyp,2)
          else
            ltp=14-ltyp
            call closelooppro1(it,nsolr,cref,cref(1,ii5),cref(1,ii4),
     -        cref(1,ii3),cref(1,ii2),c,cslt,rr5,rr4,rr3,rr2,
     -        d57(it),d47(it),d56(it),d46(it),d36(it),d45(it),d35(it),
     -        d25(it),d34(it),d24(it),d14(it),d23(it),d13(it),d03(it),
     -        d12(it),d02(it),c7,c6,cc5,cc4,cc3,cc2,c1,c0,c8,c9,
     -        ii7,ii6,ii5,ii4,ii3,ii2,ii1,ii0,lab,dxyminr,dxymaxr,
     -        deldijr,1,divr3,d3tol,unrelfac,d24tol,
     -        dijtol,dihpmtol,nosoltyp,nimptry(ltp,1),
     -        nimpfound(1,ltp,1),neval,iout,ltp,1)
            if (idebug(109) .gt. 0)
     -        write (iout,1002) 'REV2',it,ltyp,nsolr,deldijr
          end if
          nsectry(ltyp)=nsectry(ltyp)+1
          nsecact(nsolr+1,ltyp)=nsecact(nsolr+1,ltyp)+1
c         Select the better solution
          if (nsolr .gt. 0 .and.
     -        (nsol .eq. 0 .or. dabs(deldijr) .lt. dabs(deldij))) then
            call trnsfr(r3,rr3,3)
            call trnsfrd(c3,cc3,3)
            call trnsfr(r4,rr4,3)
            call trnsfrd(c4,cc4,3)
            call trnsfr(r5,rr5,3)
            call trnsfrd(c5,cc5,3)
            if (ltyp .eq. 2) then
              call trnsfr(r2,rr2,3)
              call trnsfrd(c2,cc2,3)
              call trnsfr(r6,rr6,3)
              call trnsfrd(c6,cc6,3)
              call trnsfr(r7,rr7,3)
              call trnsfrd(c7,cc7,3)
            else if (ltyp .eq. 3) then
              call trnsfr(r6,rr6,3)
              call trnsfrd(c6,cc6,3)
              call trnsfr(r7,rr7,3)
              call trnsfrd(c7,cc7,3)
            else if (ltyp .ge. 4) then
              call trnsfr(r2,rr2,3)
              call trnsfrd(c2,cc2,3)
            end if
            deldij=deldijr
            nsecact(3,ltyp)=nsecact(3,ltyp)+1
            nsol=nsolr
            if (idebug(109) .gt. 1)
     -        write (iout,*) 'lt,nsol,r=',ltyp,nsol,nsolr
          end if
        end if
      else
        write (iout,1001) ltyp
        call datprt(2)
      end if
      return
1001  format(' ***** PROGRAM ERROR: invalid looptype=',i4)
1002  format(' CLOSELOOP ',a,' it,looptyp=',i5,i3,' nsol=',i1,
     -  ' deldij=',f10.6)
1003  format(' CLOSELOOP it=',i4,' lt=',i2,' c0=',3f8.4,' c1=',3f8.4,
     -  ' c2=',3f8.4,/,' c3=',3f8.4,' c4=',3f8.4,' c5=',3f8.4,
     -  ' c6=',3f8.4,/,' c7=',3f8.4,' c8=',3f8.4,' c9=',3f8.4)
      end
      subroutine closelooppep2(it,nsol,cref,cref22,cref33,cref44,
     -  cref55,cref66,cref77,c,cslt,r2,r3,r4,r5,r6,r7,
     -  d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,d36it,d45it,
     -  d46it,d56it,d57it,d67it,d68it,d69it,d78it,d79it,
     -  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,lab,d16ref0,d16min0,d16max0,
     -  deld16,iswap,d16div,d3tol,fac16,d24tol,dijtol,dihpmtol,nosoltyp,
     -  nimptry,nimpfound,neval,inperr,iout)
c#    MMC routine 152 lstmod: 06/07/04
      dimension cref(3,#ST),c(3,#ST),cslt(3,#ST),
     -  cref22(3),cref33(3),cref44(3),cref55(3),cref66(3),cref77(3),
     -  r2(3),r3(3),r4(3),r5(3),r6(3),r7(3),nimpfound(2),
     -  c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),c9(3)
      character*10 lab
      real*8 d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,d36it,
     -  d45it,d46it,d56it,d57it,d67it,d68it,d69it,d78it,d79it,
     -  d16ref0,d16min0,d16max0,deld16,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9
      common /solchoice/ isol17(7),isol17alt(7,2)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      common /option/ iop(200),idebug(200)
      real*8 cref1,cref2,cref3,cref4,cref5,cref6,cref7,cref8,
     -  darrdist,deld160m,deld160p,
     -  deld16m,deld16p,deld16t,deld160,d16,d16try,d16ptry,d16mtry,
     -  d16tryn,d16tryf,d16ref,d16min,d16max
      dimension cref1(3),cref2(3),cref3(3),cref4(3),cref5(3),cref6(3),
     -  cref7(3),cref8(3)
      character*8 okmark
c     Peptide-bond-like torsions (-=-)
      do k=1,3
        c0(k)=c(k,i0)
        c1(k)=c(k,i1)
        cref2(k)=cref22(k)
        cref3(k)=cref33(k)
        cref4(k)=cref44(k)
        cref5(k)=cref55(k)
        cref6(k)=cref66(k)
        cref7(k)=cref77(k)
        c8(k)=c(k,i8)
        c9(k)=c(k,i9)
      end do
      neval=0
      deld16=999.9
      tc03=dihangl(cslt(1,i0),cslt(1,i1),cslt(1,i2),cslt(1,i3),
     -  idebug(86),iout)*rdtodg
      if (amin1(abs(tc03),180.0-abs(tc03)) .lt. dihpmtol) then
        itcref03=0
      else
        itcref03=itranscis(c0,c1,cref2,cref3)
      end if
      tc36=dihangl(cslt(1,i3),cslt(1,i4),cslt(1,i5),cslt(1,i6),
     -  idebug(86),iout)*rdtodg
      if (amin1(abs(tc36),180.0-abs(tc36)) .lt. dihpmtol) then
        itcref36=0
      else
        itcref36=itranscis(cref3,cref4,cref5,cref6)
      end if
      tc69=dihangl(cslt(1,i6),cslt(1,i7),cslt(1,i8),cslt(1,i9),
     -  idebug(86),iout)*rdtodg
      if (amin1(abs(tc69),180.0-abs(tc69)) .lt. dihpmtol) then
        itcref69=0
      else
        itcref69=itranscis(cref6,cref7,c8,c9)
      end if
      if (idebug(138) .gt. 0) then
        t03=dihangld(c0,c1,cref2,cref3,idebug(86),iout)*rdtodg
        t36=dihangld(cref3,cref4,cref5,cref6,idebug(86),iout)*rdtodg
        t69=dihangld(cref6,cref7,c8,c9,idebug(86),iout)*rdtodg
        if (idebug(138) .gt. 1) write (iout,1013) it,itcref03,
     -    tc03,t03,itcref36,tc36,t36,itcref69,tc69,t69
      end if
      ntry=3
      if (idebug(137) .gt. 0) ntry=idebug(137)
      do itry=1,ntry
      if (itry .eq. 1) then
        d16ref=d16ref0
        d16min=d16min0
        d16max=d16max0
        ifixsol=0
      else if (itry .eq. 2) then
        call trnsfi(isol17,isol17alt(1,1),7)
        d16ref=darrdist(c1,c6)
        d16min=dmax1(d16ref-20.1*d16div,d16min0)
        d16max=dmin1(d16ref+20.1*d16div,d16max0)
        ifixsol=1
        nimptry=nimptry+1
      else
        call trnsfi(isol17,isol17alt(1,2),7)
      end if
      nsol=0
      nosoltyp=0
      if (idebug(71) .gt. 0) then
        write (iout,1001) lab,i0,i1,i2,i3,i4,i5,i6,i7,i8,i9
        if (iswap .eq. 0) then
          do k=1,3
            cref1(k)=cref(k,i1)
          end do
          call loopmemtest(it,2,c0,cref1,cref2,cref3,cref4,cref5,cref6,
     -      cref7,c8,c9,d14max,d24tol/2.0,d24tol/1.33,'reference',ifail,
     -      idebug(71),iout)
        else
          do k=1,3
            cref8(k)=cref(k,i8)
          end do
          call loopmemtest(it,2,c9,cref8,cref7,cref6,cref5,cref4,cref3,
     -      cref2,c1,c0,d14max,d24tol/2.0,d24tol/1.33,'reference',ifail,
     -      idebug(71),iout)
        end if
      end if
c     d3tol: tolerance in extract3
c     d16tol: tolerance in d16
      d16tol=d3tol
      d16=d16ref
      if (d16ref .lt. d16min) then
        nmstep=0
        d16=d16min
      else
        nmstep=(d16-d16min)/d16div
      end if
      if (d16ref .gt. d16max) then
        npstep=0
        d16=d16max
      else
        npstep=(d16max-d16)/d16div
      end if
      if (idebug(86) .gt. 0) write (iout,1004)
     -  d16ref,d16,d16min,d16max,d16div,nmstep,npstep,itry
      im=0
      ip=0
      d16mtry=d16
      d16ptry=d16
c     Get deviation with d16=d16ref
      call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  cref2,cref3,cref4,cref5,cref6,cref7,itcref03,itcref36,itcref69,
     -  d16,d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,d36it,d45it,
     -  d46it,d56it,d57it,d67it,d68it,d69it,d78it,d79it,
     -  deld160m,d3tol,isolm,ifixsol,neval,iout,idebug(86))
      deld160p=deld160m
      deld16m=deld160m
      deld16p=deld160m
      deld16t=deld160m
      isolp=isolm
      if (isolm*idebug(74) .gt. 0) then
        write (6,1005) lab,'c',6,i6,c6,cref6,dsqrt(darrdist(c6,cref6))
        write (6,1005) lab,'c',7,i7,c7,cref7,dsqrt(darrdist(c7,cref7))
        write (6,1005) lab,'c',3,i3,c3,cref3,dsqrt(darrdist(c3,cref3))
        write (6,1005) lab,'c',2,i2,c2,cref2,dsqrt(darrdist(c2,cref2))
        write (6,1005) lab,'c',4,i4,c4,cref4,dsqrt(darrdist(c4,cref4))
        write (6,1005) lab,'c',5,i5,c5,cref5,dsqrt(darrdist(c5,cref5))
      end if
      do while (im .le. nmstep .and. ip .lt. npstep)
        im=im+1
        if (idebug(86) .gt. 0) write (iout,1002)
     -    im,ip,isolm,isolp,nmstep,npstep,d16mtry,d16ptry,d16div
        if (im .le. nmstep) then
          d16try=d16mtry-d16div
        else
          d16try=d16min
        end if
c       Test for solution between d16mtry and d16try
        if (im .le. nmstep) then
          call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cref2,cref3,
     -      cref4,cref5,cref6,cref7,itcref03,itcref36,itcref69,d16try,
     -      d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,d36it,d45it,
     -      d46it,d56it,d57it,d67it,d68it,d69it,d78it,d79it,
     -      deld16,d3tol,isol,ifixsol,neval,iout,idebug(86))
          if (isol .gt. 0) then
            if (isolm .eq. 0) then
              deld160m=deld16
              deld16t=deld16
              isolm=1
            else if (deld16*deld160m .lt. 0.d0) then
c           Iterate between d16try and d16mtry
              niter=0
              deld16m=deld16
              do while (d16mtry-d16try .gt. d16tol)
                niter=niter+1
                d16tryn=(d16mtry+d16try)/2.d0
                call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cref2,
     -            cref3,cref4,cref5,cref6,cref7,itcref03,itcref36,
     -            itcref69,d16tryn,d02it,d03it,d12it,d13it,d23it,d24it,
     -            d34it,d35it,d36it,d45it,d46it,d56it,d57it,d67it,d68it,
     -            d69it,d78it,d79it,deld16,d3tol,isol,ifixsol,neval,
     -            iout,idebug(86))
                if (deld16*deld160m .lt. 0.d0) then
                  d16try=d16tryn
                  deld16t=deld16
                else
                  d16mtry=d16tryn
                  deld16m=deld16
                end if
              end do
              idone=1
              go to 100
            end if
          else
            im=nmstep
          end if
        end if
        d16mtry=d16try
        deld16m=deld16
        ip=ip+1
        if (ip .le. npstep) then
          d16try=d16ptry+d16div
        else
          d16try=d16max
        end if
c       Test for solution between d16ptry and d16try
        if (ip .le. npstep) then
          call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cref2,cref3,
     -      cref4,cref5,cref6,cref7,itcref03,itcref36,itcref69,d16try,
     -      d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,d36it,d45it,
     -      d46it,d56it,d57it,d67it,d68it,d69it,d78it,d79it,
     -      deld16,d3tol,isol,ifixsol,neval,iout,idebug(86))
          if (isol .gt. 0) then
            if (isolp .eq. 0) then
              deld160p=deld16
              deld16t=deld16
              isolp=1
            else if (deld16*deld160p .lt. 0.d0) then
c             Iterate between d16try and d16ptry
              niter=0
              deld16p=deld16
              do while (d16try-d16ptry .gt. d16tol)
                niter=niter+1
                d16tryn=(d16ptry+d16try)/2.d0
                call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cref2,
     -            cref3,cref4,cref5,cref6,cref7,itcref03,itcref36,
     -            itcref69,d16tryn,d02it,d03it,d12it,d13it,d23it,d24it,
     -            d34it,d35it,d36it,d45it,d46it,d56it,d57it,d67it,d68it,
     -            d69it,d78it,d79it,deld16,d3tol,isol,ifixsol,neval,
     -            iout,idebug(86))
                if (deld16*deld160p .lt. 0.d0) then
                  d16try=d16tryn
                  deld16t=deld16
                else
                  d16ptry=d16tryn
                  deld16p=deld16
                end if
              end do
              idone=2
              go to 100
            end if
          else
            ip=npstep
          end if
        end if
        d16ptry=d16try
        deld16p=deld16
      end do
      if (idebug(74) .gt. 0) then
        write (iout,1017) it
        inperr=inperr+1
      end if
      nosoltyp=1
      if (itry .eq. 1) return
100   okmark='        '
      if (idebug(86) .gt. 0 .and. itry .gt. 1)
     -  write (iout,1010) lab,deld160,deld16,im,ip,itry
      if (nosoltyp .ne. 1 .and. dabs(deld16) .gt. fac16*d16tol) then
c       Solution is unreliable - skip it
        nosoltyp=2
        okmark(5:8)='xxxx'
        if (itry .eq. 1) then
c         Get the better solution order
          d16tryf=0.d0
          if (idone .eq. 1) then
            if (dabs(deld16m) .lt. dabs(deld16t)) then
              if (deld16m .ne. deld16)  d16tryf=d16mtry
            else
              if (deld16t .ne. deld16)  d16tryf=d16try
            end if
          else
            if (dabs(deld16p) .lt. dabs(deld16t)) then
              if (deld16p .ne. deld16)  d16tryf=d16ptry
            else
              if (deld16t .ne. deld16)  d16tryf=d16try
            end if
          end if
          if (idebug(86) .gt. 0) write (iout,1007) idone,d16tryf,d16try,
     -      d16mtry,d16ptry,deld16,deld16t,deld16m,deld16p,itry
          if (d16tryf .ne. 0.d0) then
            call trnsfi(isol17alt(1,2),isol17,7)
            call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cref2,
     -        cref3,cref4,cref5,cref6,cref7,itcref03,itcref36,itcref69,
     -        d16tryf,d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,
     -        d36it,d45it,d46it,d56it,d57it,d67it,d68it,d69it,d78it,
     -        d79it,deld16,d3tol,isol,ifixsol,neval,iout,idebug(86))
            call trnsfi(isol17alt(1,1),isol17,7)
          else
            if (d16tryn .eq. d16try) then
              if (idone .eq. 1) then
                d16tryf=d16mtry
              else
                d16tryf=d16ptry
              end if
            else
              d16tryf=d16try
            end if
            call trnsfi(isol17alt(1,1),isol17,7)
            call d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cref2,cref3,
     -        cref4,cref5,cref6,cref7,itcref03,itcref36,itcref69,
     -        d16tryf,d02it,d03it,d12it,d13it,d23it,d24it,d34it,d35it,
     -        d36it,d45it,d46it,d56it,d57it,d67it,d68it,d69it,d78it,
     -        d79it,deld16t,d3tol,isol,ifixsol,neval,iout,idebug(86))
            call trnsfi(isol17alt(1,2),isol17,7)
            if (idebug(86) .gt. 0)
     -        write (iout,1008) idone,d16tryf,deld16t
          end if
          if (idebug(86) .gt. 0) write (iout,1009) isol17alt
          deld160=deld16
        end if
      else if (nosoltyp .ne. 1) then
        nsol=1
c       Return solution to parameter arrays
        do k=1,3
          r2(k)=c2(k)
          r3(k)=c3(k)
          r4(k)=c4(k)
          r5(k)=c5(k)
          r6(k)=c6(k)
          r7(k)=c7(k)
        end do
        if (itry .gt. 1) nimpfound(itry-1)=nimpfound(itry-1)+1
        if (idebug(138) .gt. 0) then
          itc03=itranscis(c0,c1,c2,c3)
          itc36=itranscis(c3,c4,c5,c6)
          itc69=itranscis(c6,c7,c8,c9)
          if (itc03*itcref03 .eq. -1 .or. itc36*itcref36 .eq. -1 .or.
     -        itc69*itcref69 .eq. -1) then
            t0123=dihangld(c0,c1,c2,c3,idebug(86),iout)*rdtodg
            t3456=dihangld(c3,c4,c5,c6,idebug(86),iout)*rdtodg
            t6789=dihangld(c6,c7,c8,c9,idebug(86),iout)*rdtodg
            write (iout,1003) it,itc03,itcref03,t03,t0123,tc03,
     -        itc36,itcref36,t36,t3456,tc36,
     -        itc69,itcref69,t69,t6789,tc69
          end if
        end if
        if (idebug(74)+idebug(71) .gt. 0) go to 200
        return
      end if
      nosoltyp=2
      end do
200   if (idebug(74) .gt. 0) then
c       Zero torsion for self test
        dev=arrdist(r2,cref22)+arrdist(r3,cref33)+arrdist(r4,cref44)+
     -      arrdist(r5,cref55)+arrdist(r6,cref66)+arrdist(r7,cref77)
        if (dev .gt. dijtol) okmark(1:4)='****'
        write (iout,1012) it,dev,deld16,okmark
      end if
      if (idebug(71) .gt. 1) then
        write (6,1005) lab,'r',6,i6,r6,cref66,sqrt(arrdist(r6,cref66))
        write (6,1005) lab,'r',7,i7,r7,cref77,sqrt(arrdist(r7,cref77))
        write (6,1005) lab,'r',3,i3,r3,cref33,sqrt(arrdist(r3,cref33))
        write (6,1005) lab,'r',2,i2,r2,cref22,sqrt(arrdist(r2,cref22))
        write (6,1005) lab,'r',4,i4,r4,cref44,sqrt(arrdist(r4,cref44))
        write (6,1005) lab,'r',5,i5,r5,cref55,sqrt(arrdist(r5,cref55))
        write (iout,1006) deld16,niter,d24tol,d16tol
        if (iswap .eq. 0) then
          call loopmemtest(it,2,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -      d14max,d24tol/2.0,d24tol/1.33,'solution ',ifail,idebug(71),
     -      iout)
        else
          call loopmemtest(it,2,c9,c8,c7,c6,c5,c4,c3,c2,c1,c0,
     -      d14max,d24tol/2.0,d24tol/1.33,'solution ',ifail,idebug(71),
     -      iout)
        end if
      end if
      return
1001  format(' LOOPPEP2 ',a,' i0-9=',10i6)
1002  format(' LOOPPEP2: im=',i4,' ip=',i4,' isolm,p=',i2,i3,
     -  ' nm/pstep=',2i4,' d16m,ptry=',2f14.9,' d16div=',f8.5)
1003  format(' LOOPPEP2 it=',i4,' cis-trans problem itc03:',2i3,
     -  ' tbef,aft,ref=',3f7.1,' itc36=',2i3,' tbef,aft,ref3456=',3f7.1,
     -  /,' itc69=',2i3,' tbef,aft,ref6789=',3f7.1)
1004  format(' LOOPPEP2: d16ref,d16,d16min,d16max=',4f10.5,' d16div=',
     -  f8.5,' nm,npstep=',2i4,' itry=',i1)
1005  format(' LOOPPEP2: ',a,1x,a,i1,'(',i5,')=',3f10.6,' cref=',3f10.6,
     -  ' d=',f10.5)
1006  format(' LOOPPEP2:  deld16=',e17.7,' niter=',i3,
     -  ' d24tol,d16tol=',2e10.3)
1007  format(' LOOPPEP2: idone=',i1,' d16tryf,try,m,p=',4f14.9,/,
     -  11x,'deld16,t,m,p=',4e15.8,' itry=',i1)
1008  format(' LOOPPEP2: idone=',i1,' d16tryf=',f14.9,' deld16t=',e15.8)
1009  format(' LOOPPEP2: isol17alt=',7i3,2x,7i3)
1010  format(' LOOPPEP2: ',a,' original deld16=',e14.7,' deld refined ',
     -  'with fixed solution choices=',e14.7,' im,p=',i3,i4,' itry=',i1)
1012  format(' LOOPPEP2: it=',i6,' d(ref-sol)^2=',e12.5,
     -  ' deld16=',e14.7,1x,a)
1013  format(' LOOPPEP2: it=',i6,' itc03=',i2,' tc,t03=',2f8.1,
     -  ' itc36=',i2,' tc,t36=',2f8.1,' itc69=',i2,' tc,t69=',2f8.1)
1017  format(' ***** ERROR: no solution in looppep2 for zero torsion ',
     -  'change',i6)
      end
      subroutine d16topeploop(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  cref2,cref3,cref4,cref5,cref6,cref7,itcref03,itcref36,itcref69,
     -  d16,d02,d03,d12,d13,d23,d24,d34,d35,d36,d45,d46,d56,d57,d67,d68,
     -  d69,d78,d79,deld16,d3tol,isol,ifixsol,neval,iout,LEVTEST)
c#    MMC routine 153 lstmod: 02/07/07
      real*8 c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,cc2,cc3,cc4,cc5,cc6,cc7,
     -  cref2,cref3,cref4,cref5,cref6,cref7,d16,
     -  d02,d03,d12,d13,d23,d24,d34,d36,d35,d45,d56,d57,d46,d67,d68,d69,
     -  d78,d79,deld16,darrdist
      dimension c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),
     -  c9(3),cref2(3),cref3(3),cref4(3),cref5(3),cref6(3),cref7(3),
     -  cc2(3),cc3(3),cc4(3),cc5(3),cc6(3),cc7(3)
c*****From a trial r1-r6 distance, get the estimates of c2-c7
      common /solchoice/ isol17(7),isol17alt(7,2)
      if (ifixsol .eq. 0) call zeroiti(isol17,0,7)
      deld16=999.9
      isol=0
      call extract3r2(c6,cc6,1,cref6,c1,c8,c9,d16,d68,d69,d3tol,
     -  isol17(6),'r6 1',iout,LEVTEST)
      if (isol17(6) .ne. 0) then
        call extract3r2(c7,cc7,1,cref7,c6,c8,c9,d67,d78,d79,d3tol,
     -    isol17(7),'r7 1',iout,LEVTEST)
        if (isol17(7) .ne. 0) then
          if (itcref69 .ne. 0) then
c           Check for cis/trans flip
            itc69=itranscis(c6,c7,c8,c9)
            if (itc69 .ne. itcref69) then
c             Switch solution
              itc69=itranscis(c6,cc7,c8,c9)
              if (itc69 .eq. itcref69) then
                call switchsol(c7,cc7,isol17,7)
              else
c               Switch of c7 does not work, try calculating c7 with cc6
                call extract3r2(c7,cc7,1,cref7,cc6,c8,c9,d67,d78,d79,
     -            d3tol,isol17(7),'r7 1',iout,LEVTEST)
                if (isol17(7) .eq. 0) go to 999
                itc69=itranscis(cc6,c7,c8,c9)
                if (itc69 .eq. itcref69) then
                  call switchsol(c6,cc6,isol17,6)
                else
                  itc69=itranscis(cc6,cc7,c8,c9)
                  if (itc69 .eq. itcref69) then
                    call switchsol(c6,cc6,isol17,6)
                    call switchsol(c7,cc7,isol17,7)
                  else
                    go to 999
                  end if
                end if
              end if
            end if
          end if
          call extract3r2(c3,cc3,1,cref3,c0,c1,c6,d03,d13,d36,d3tol,
     -      isol17(3),'r3 1',iout,LEVTEST)
          if (isol17(3) .ne. 0) then
            call extract3r2(c2,cc2,1,cref2,c0,c1,c3,d02,d12,d23,d3tol,
     -        isol17(2),'r2 1',iout,LEVTEST)
            if (isol17(2) .ne. 0) then
              if (itcref69 .ne. 0) then
c               Check for cis/trans flip
                itc03=itranscis(c0,c1,c2,c3)
                if (itc03 .ne. itcref03) then
c                 Switch solution
                  itc03=itranscis(c0,c1,cc2,c3)
                  if (itc03 .eq. itcref03) then
                    call switchsol(c2,cc2,isol17,2)
                  else
c                   Switch of c2 does not work, try calculating c2 with cc3
                    call extract3r2(c2,cc2,1,cref2,c0,c1,cc3,d02,d12,
     -                d23,d3tol,isol17(2),'r7 1',iout,LEVTEST)
                    if (isol17(2) .eq. 0) go to 999
                    itc03=itranscis(c0,c1,c2,cc3)
                    if (itc03 .eq. itcref03) then
                      call switchsol(c3,cc3,isol17,3)
                    else
                      itc03=itranscis(c0,c1,cc2,cc3)
                      if (itc03 .eq. itcref03) then
                        call switchsol(c2,cc2,isol17,2)
                        call switchsol(c3,cc3,isol17,3)
                      else
                        go to 999
                      end if
                    end if
                  end if
                end if
              end if
              call extract3r2(c4,cc4,1,cref4,c2,c3,c6,d24,d34,d46,d3tol,
     -          isol17(4),'r4 1',iout,LEVTEST)
              if (isol17(4) .ne. 0) then
                call extract3r2(c5,cc5,1,cref5,c3,c6,c7,d35,d56,d57,
     -            d3tol,isol17(5),'r5 1',iout,LEVTEST)
                if (isol17(5) .ne. 0) then
                  if (itcref69 .ne. 0) then
c                   Check for cis/trans flip
                    itc36=itranscis(c3,c4,c5,c6)
                    if (itc36 .ne. itcref36) then
c                     Switch solution
                      itc36=itranscis(c3,c4,cc5,c6)
                      if (itc36 .eq. itcref36) then
                        call switchsol(c5,cc5,isol17,5)
                      else
c                       Switch of c5 does not work, try switching c4
                        itc36=itranscis(c3,cc4,c5,c6)
                        if (itc36 .eq. itcref36) then
                          call switchsol(c4,cc4,isol17,4)
                        else
c                         Neither switch worked, try switching both c4 and c5
                          itc36=itranscis(c3,cc4,cc5,c6)
                          if (itc36 .eq. itcref36) then
                            call switchsol(c4,cc4,isol17,4)
                            call switchsol(c5,cc5,isol17,5)
                          else
                            go to 999
                          end if
                        end if
                      end if
                    end if
                  end if
                  deld16=d45-darrdist(c4,c5)
                  isol=1
                end if
              end if
            end if
          end if
        end if
      end if
999   neval=neval+1
      if (LEVTEST .gt. 0) write (iout,1000) d16,deld16,isol,neval
      return
1000  format(' D16TOPEPLOOP: d16=',f12.8,' deld16=',e14.7,' isol=',i1,
     -  ' neval=',i8)
      end
      subroutine closelooppep3(it,nsol,cref,cref33,cref44,cref55,cref66,
     -  cref77,c,cslt,r3,r4,r5,r6,r7,d13it,d23it,d24it,d25it,d34it,
     -  d35it,d45it,d46it,d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -  c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  i1,i2,i3,i4,i5,i6,i7,i8,i9,lab,d27ref0,d27min0,d27max0,deld27,
     -  iswap,d27div,d3tol,fac27,d24tol,dijtol,dihpmtol,nosoltyp,
     -  nimptry,nimpfound,neval,inperr,iout)
c#    MMC routine 154 lstmod: 02/07/07
      dimension cref(3,#ST),c(3,#ST),cslt(3,#ST),
     -  cref33(3),cref44(3),cref55(3),cref66(3),cref77(3),
     -  r3(3),r4(3),r5(3),r6(3),r7(3),nimpfound(2),
     -  c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),c9(3)
      real*8 c1,c2,c3,c4,c5,c6,c7,c8,c9
      real*8 d27ref0,d27min0,d27max0,deld27,d13it,d23it,d24it,
     -  d25it,d34it,d35it,d45it,d46it,d56it,d57it,d58it,d67it,d68it,
     -  d78it,d79it
      character*10 lab
      common /solchoice/ isol17(7),isol17alt(7,2)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      common /option/ iop(200),idebug(200)
      real*8 cref1,cref2,cref3,cref4,cref5,cref6,cref7,cref8,cref9,
     -  darrdist,deld270m,deld270p,
     -  deld27m,deld27p,deld27t,d27,d27try,d27ptry,d27mtry,d27tryn,
     -  d27tryf,d27ref,d27min,d27max,deld270
      dimension cref1(3),cref2(3),cref3(3),cref4(3),cref5(3),cref6(3),
     -  cref7(3),cref8(3),cref9(3)
      character*8 okmark
c     Peptide-bond-like torsions (=--)
      neval=0
      deld27=999.9
      do k=1,3
        c1(k)=c(k,i1)
        c2(k)=c(k,i2)
        cref3(k)=cref33(k)
        cref4(k)=cref44(k)
        cref5(k)=cref55(k)
        cref6(k)=cref66(k)
        cref7(k)=cref77(k)
        c8(k)=c(k,i8)
        c9(k)=c(k,i9)
      end do
      tc25=dihangl(cslt(1,i2),cslt(1,i3),cslt(1,i4),cslt(1,i5),
     -  idebug(86),iout)*rdtodg
      if (amin1(abs(tc25),180.0-abs(tc25)) .lt. dihpmtol) then
        itcref25=0
      else
        itcref25=itranscis(c2,cref3,cref4,cref5)
      end if
      tc58=dihangl(cslt(1,i5),cslt(1,i6),cslt(1,i7),cslt(1,i8),
     -  idebug(86),iout)*rdtodg
      if (amin1(abs(tc58),180.0-abs(tc58)) .lt. dihpmtol) then
        itcref58=0
      else
        itcref58=itranscis(cref5,cref6,cref7,c8)
      end if
      if (idebug(138) .gt. 0) then
        t25=dihangld(c2,cref3,cref4,cref5,idebug(86),iout)*rdtodg
        t58=dihangld(cref5,cref6,cref7,c8,idebug(86),iout)*rdtodg
        if (idebug(138) .gt. 1)
     -    write (iout,1013) it,itcref25,tc25,t25,itcref58,tc58,t58
      end if
      ntry=3
      if (idebug(137) .gt. 0) ntry=idebug(137)
      do itry=1,ntry
      if (itry .eq. 1) then
        d27ref=d27ref0
        d27min=d27min0
        d27max=d27max0
        ifixsol=0
      else if (itry .eq. 2) then
        call trnsfi(isol17,isol17alt(1,1),7)
        d27ref=darrdist(c2,c7)
        d27min=dmax1(d27ref-20.1*d27div,d27min0)
        d27max=dmin1(d27ref+20.1*d27div,d27max0)
        ifixsol=1
        nimptry=nimptry+1
      else
        call trnsfi(isol17,isol17alt(1,2),7)
      end if
      nsol=0
      nosoltyp=0
      d27=d27ref
      if (idebug(71) .gt. 0) then
        write (6,1001) lab,i1,i2,i3,i4,i5,i6,i7,i8,i9
        if (iswap .eq. 0) then
          do k=1,3
            cref1(k)=cref(k,i1)
            cref2(k)=cref(k,i2)
          end do
          call loopmemtest(it,3,c1,cref1,cref2,cref3,cref4,cref5,cref6,
     -      cref7,c8,c9,d14max,d24tol/2.0,d24tol/1.33,'reference',ifail,
     -      idebug(71),iout)
        else
          do k=1,3
            cref1(k)=cref(k,i1)
            cref2(k)=cref(k,i2)
          end do
          call loopmemtest(it,3,c9,cref9,cref8,cref7,cref6,cref5,cref4,
     -      cref3,c2,c1,d14max,d24tol/2.0,d24tol/1.33,'reference',ifail,
     -      idebug(71),iout)
        end if
      end if
c     d3tol: tolerance in extract3
c     d27tol: tolerance in d27
      d27tol=d3tol
      if (d27ref .lt. d27min) then
        nmstep=0
        d27=d27min
      else
        nmstep=(d27-d27min)/d27div
      end if
      if (d27ref .gt. d27max) then
        npstep=0
        d27=d27max
      else
        npstep=(d27max-d27)/d27div
      end if
      if (idebug(86) .gt. 0) write (iout,1004)
     -   d27ref,d27,d27min,d27max,d27div,nmstep,npstep,itry
      im=0
      ip=0
      d27mtry=d27
      d27ptry=d27
c     Get deviation with d27=d27ref
      call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  cref3,cref4,cref5,cref6,cref7,itcref25,itcref58,d27,
     -  d13it,d23it,d24it,d25it,d34it,d35it,d45it,d46it,
     -  d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -  deld270m,d3tol,isolm,ifixsol,neval,iout,idebug(86))
      deld270p=deld270m
      deld27m=deld270m
      deld27p=deld270p
      deld27t=deld270m
      isolp=isolm
      if (isolm*idebug(74) .gt. 0) then
        write (6,1005) lab,'c',7,i7,c7,cref7,dsqrt(darrdist(c7,cref7))
        write (6,1005) lab,'c',5,i5,c5,cref5,dsqrt(darrdist(c5,cref5))
        write (6,1005) lab,'c',6,i6,c6,cref6,dsqrt(darrdist(c6,cref6))
        write (6,1005) lab,'c',3,i3,c3,cref3,dsqrt(darrdist(c3,cref3))
        write (6,1005) lab,'c',4,i4,c4,cref4,dsqrt(darrdist(c4,cref4))
      end if
      do while (im .le. nmstep .and. ip .lt. npstep)
        im=im+1
        if (idebug(86) .gt. 0) write (iout,1002)
     -    im,ip,isolm,isolp,nmstep,npstep,d27mtry,d27ptry,d27div
        if (im .le. nmstep) then
          d27try=d27mtry-d27div
        else
          d27try=d27min
        end if
c       Test for solution between d27mtry and d27try
        if (im .le. nmstep) then
          call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -      cref3,cref4,cref5,cref6,cref7,itcref25,itcref58,d27try,
     -      d13it,d23it,d24it,d25it,d34it,d35it,d45it,d46it,
     -      d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -      deld27,d3tol,isol,ifixsol,neval,iout,idebug(86))
          if (isol .gt. 0) then
            if (isolm .eq. 0) then
              deld270m=deld27
              deld27t=deld27
              isolm=1
            else if (deld27*deld270m .lt. 0.d0) then
c             Iterate between d27try and d27mtry
              niter=0
              deld27m=deld27
                do while (d27mtry-d27try .gt. d27tol)
                niter=niter+1
                d27tryn=(d27mtry+d27try)/2.d0
                call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,cref3,
     -            cref4,cref5,cref6,cref7,itcref25,itcref58,d27tryn,
     -            d13it,d23it,d24it,d25it,d34it,d35it,
     -            d45it,d46it,d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -            deld27,d3tol,isol,ifixsol,neval,iout,idebug(86))
                if (deld27*deld270m .lt. 0.d0) then
                  d27try=d27tryn
                  deld27t=deld27
                else
                  d27mtry=d27tryn
                  deld27m=deld27
                end if
              end do
              idone=1
              go to 100
            end if
          else
            im=nmstep
          end if
        end if
        d27mtry=d27try
        deld27m=deld27
        ip=ip+1
        if (ip .le. npstep) then
          d27try=d27ptry+d27div
        else
          d27try=d27max
        end if
        if (ip .le. npstep) then
c       Test for solution between d27ptry and d27try
          call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -      cref3,cref4,cref5,cref6,cref7,itcref25,itcref58,d27try,
     -      d13it,d23it,d24it,d25it,d34it,d35it,d45it,d46it,
     -      d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -      deld27,d3tol,isol,ifixsol,neval,iout,idebug(86))
          if (isol .gt. 0) then
            if (isolp .eq. 0) then
              deld270p=deld27
              deld27t=deld27
              isolp=1
            else if (deld27*deld270p .lt. 0.d0) then
c             Iterate between d27try and d27ptry
              niter=0
              deld27p=deld27
              do while (d27try-d27ptry .gt. d27tol)
                niter=niter+1
                d27tryn=(d27ptry+d27try)/2.d0
                call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,cref3,
     -            cref4,cref5,cref6,cref7,itcref25,itcref58,d27tryn,
     -            d13it,d23it,d24it,d25it,d34it,d35it,
     -            d45it,d46it,d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -            deld27,d3tol,isol,ifixsol,neval,iout,idebug(86))
                if (deld27*deld270p .lt. 0.d0) then
                  d27try=d27tryn
                  deld27t=deld27
                else
                  d27ptry=d27tryn
                  deld27p=deld27
                end if
              end do
              idone=2
              go to 100
            end if
          else
            ip=npstep
          end if
        end if
        d27ptry=d27try
        deld27p=deld27
      end do
      if (idebug(74) .gt. 0) then
        write (iout,1017) it
        inperr=inperr+1
      end if
      nosoltyp=1
      if (itry .eq. 1) return
100   okmark='        '
      if (idebug(86) .gt. 0 .and. itry .gt. 1)
     -  write (iout,1010) lab,deld270,deld27,im,ip,itry
      if (nosoltyp .ne. 1 .and. dabs(deld27) .gt. fac27*d27tol) then
c       Solution is unreliable - skip it
        nosoltyp=2
        okmark(5:8)='xxxx'
        if (itry .eq. 1) then
c         Get the better solution order
          d27tryf=0.d0
          if (idone .eq. 1) then
            if (dabs(deld27m) .lt. dabs(deld27t)) then
              if (deld27m .ne. deld27)  d27tryf=d27mtry
            else
              if (deld27t .ne. deld27)  d27tryf=d27try
            end if
          else
            if (dabs(deld27p) .lt. dabs(deld27t)) then
              if (deld27p .ne. deld27)  d27tryf=d27ptry
            else
              if (deld27t .ne. deld27)  d27tryf=d27try
            end if
          end if
          if (idebug(89) .gt. 1) write (iout,1007) idone,d27tryf,d27try,
     -      d27mtry,d27ptry,deld27,deld27t,deld27m,deld27p,itry
          if (d27tryf .ne. 0.d0) then
            call trnsfi(isol17alt(1,2),isol17,7)
            call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -        cref3,cref4,cref5,cref6,cref7,itcref25,itcref58,d27tryf,
     -        d13it,d23it,d24it,d25it,d34it,d35it,d45it,d46it,
     -        d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -        deld27,d3tol,isol,ifixsol,neval,iout,idebug(86))
            call trnsfi(isol17alt(1,1),isol17,7)
          else
            if (d27tryn .eq. d27try) then
              if (idone .eq. 1) then
                d27tryf=d27mtry
              else
                d27tryf=d27ptry
              end if
            else
              d27tryf=d27try
            end if
            call trnsfi(isol17alt(1,1),isol17,7)
            call d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -        cref3,cref4,cref5,cref6,cref7,itcref25,itcref58,d27tryf,
     -        d13it,d23it,d24it,d25it,d34it,d35it,d45it,d46it,
     -        d56it,d57it,d58it,d67it,d68it,d78it,d79it,
     -        deld27t,d3tol,isol,ifixsol,neval,iout,idebug(86))
            call trnsfi(isol17alt(1,2),isol17,7)
            if (idebug(86) .gt. 0) write (iout,1008)
     -        idone,d27tryf,deld27t
          end if
          if (idebug(86) .gt. 0) write (iout,1009) isol17alt
          deld270=deld27
        end if
      else if (nosoltyp .ne. 1) then
        nsol=1
c       Return solution to parameter arrays
        do k=1,3
          r3(k)=c3(k)
          r4(k)=c4(k)
          r5(k)=c5(k)
          r6(k)=c6(k)
          r7(k)=c7(k)
        end do
        if (itry .gt. 1) nimpfound(itry-1)=nimpfound(itry-1)+1
        if (idebug(138) .gt. 0) then
          itc25=itranscis(c2,c3,c4,c5)
          itc58=itranscis(c5,c6,c7,c8)
          if (itc25*itcref25 .eq. -1 .or. itc58*itcref58 .eq. -1) then
            t2345=dihangld(c2,c3,c4,c5,idebug(86),iout)*rdtodg
            t5678=dihangld(c5,c6,c7,c8,idebug(86),iout)*rdtodg
            write (iout,1003) it,itc25,itcref25,t25,t2345,tc25,
     -        itc58,itcref58,t58,t5678,tc58
          end if
        end if
        return
      end if
      nosoltyp=2
      end do
200   if (idebug(74) .gt. 0) then
c       Zero torsion for self test
        dev=arrdist(r3,cref33)+arrdist(r4,cref44)+
     -      arrdist(r5,cref55)+arrdist(r6,cref66)+arrdist(r7,cref77)
        if (dev .gt. dijtol) okmark(1:4)='****'
        write (iout,1012) it,dev,deld27,okmark
      end if
      if (idebug(71) .gt. 1) then
        write (6,1005) lab,'r',7,i7,r7,cref77,sqrt(arrdist(r7,cref77))
        write (6,1005) lab,'r',5,i5,r5,cref55,sqrt(arrdist(r5,cref55))
        write (6,1005) lab,'r',6,i6,r6,cref66,sqrt(arrdist(r6,cref66))
        write (6,1005) lab,'r',3,i3,r3,cref33,sqrt(arrdist(r3,cref33))
        write (6,1005) lab,'r',4,i4,r4,cref44,sqrt(arrdist(r4,cref44))
        write (iout,1006) deld27,niter,d24tol,d27tol
        if (iswap .eq. 0) then
          call loopmemtest(it,3,c1,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -      d14max,d24tol/2.0,d24tol/1.33,'solution ',ifail,idebug(71),
     -      iout)
        else
          call loopmemtest(it,3,c9,c9,c8,c7,c6,c5,c4,c3,c2,c2,
     -      d14max,d24tol/2.0,d24tol/1.33,'solution ',ifail,idebug(71),
     -      iout)
        end if
      end if
      return
1001  format(' LOOPPEP3 ',a,' i1-9=',9i6)
1002  format(' LOOPPEP3: im=',i4,' ip=',i4,' isolm,p=',i2,i3,
     -  ' nm/pstep=',2i4,' d27m,ptry=',2f14.9,' d27div=',f8.5)
1003  format(' LOOPPEP3 it=',i4,' cis-trans problem itc25:',2i3,
     -  ' tbef,aft,ref=',3f7.1,' itc58=',2i3,' tbef,aft,ref=',3f7.1)
        if (idebug(74)+idebug(71) .gt. 0) go to 200
1004  format(' LOOPPEP3: d27ref,d27,d27min,d27max=',4f10.5,' d27div=',
     -  f8.5,' nm,npstep=',2i4,' itry=',i1)
1005  format(' LOOPPEP3: ',a,1x,a,i1,'(',i5,')=',3f10.6,' cref=',3f10.6,
     -  ' d=',f10.5)
1006  format(' LOOPPEP3:  deld27=',e14.7,' niter=',i3,
     -  ' d24tol,d27tol=',2e9.3)
1007  format(' LOOPPEP3: idone=',i1,' d27tryf,try,m,p=',4f14.9,/,
     -  11x,'deld27,t,m,p=',4e15.8,' itry=',i1)
1008  format(' LOOPPEP3: idone=',i1,' d27tryf=',f14.9,' deld27t=',e15.8)
1009  format(' LOOPPEP3: isol17alt=',7i3,2x,7i3)
1010  format(' LOOPPEP3: ',a,' original deld27=',e14.7,' deld refined ',
     -  'with fixed solution choices=',e14.7,' im,p=',i3,i4,' itry=',i1)
1012  format(' LOOPPEP3: it=',i6,' d(ref-sol)^2=',e12.5,
     -  ' deld27=',e14.7,1x,a)
1013  format(' LOOPPEP3: it=',i6,' itc25=',i2,' tc,t25=',2f8.1,
     -  ' itc58=',i2,' tc,158=',2f8.1)
1017  format(' ***** ERROR: no solution in looppep3 for zero torsion ',
     -  'change it=',i6)
      end
      subroutine d27topeploop(c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  cref3,cref4,cref5,cref6,cref7,itcref25,itcref58,d27,
     -  d13,d23,d24,d25,d34,d35,d45,d46,d56,d57,d58,d67,d68,d78,d79,
     -  deld27,d3tol,isol,ifixsol,neval,iout,LEVTEST)
c#    MMC routine 155 lstmod: 02/07/07
      real*8 c1,c2,c3,c4,c5,c6,c7,c8,c9,cc3,cc4,cc5,cc6,cc7,
     -  cref3,cref4,cref5,cref6,cref7,d27,
     -  d13,d23,d24,d25,d34,d35,d45,d46,d56,d57,d58,d67,d68,d78,d79,
     -  deld27,darrdist
      dimension c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),
     -  c8(3),c9(3),cref3(3),cref4(3),cref5(3),cref6(3),cref7(3),
     -  cc3(3),cc4(3),cc5(3),cc6(3),cc7(3)
c*****From a trial r2-r7 distance, get the estimates of c3-c7
      common /solchoice/ isol17(7),isol17alt(7,2)
      if (ifixsol .eq. 0) call zeroiti(isol17,0,7)
      deld27=999.9
      isol=0
      call extract3r2(c7,cc7,1,cref7,c2,c8,c9,d27,d78,d79,d3tol,
     -  isol17(7),'r7 2',iout,LEVTEST)
      if (isol17(7) .ne. 0) then
        call extract3r2(c5,cc5,1,cref5,c2,c7,c8,d25,d57,d58,d3tol,
     -    isol17(5),'r5 2',iout,LEVTEST)
        if (isol17(5) .ne. 0) then
          call extract3r2(c6,cc6,1,cref6,c5,c7,c8,d56,d67,d68,d3tol,
     -      isol17(6),'r6 2',iout,LEVTEST)
          if (isol17(6) .ne. 0) then
            if (itcref58 .ne. 0) then
c             Check for cis/trans flip
              itc58=itranscis(c5,c6,c7,c8)
              if (itc58 .ne. itcref58) then
c               Switch solution
                itc58=itranscis(c5,cc6,c7,c8)
                if (itc58 .eq. itcref58) then
                  call switchsol(c6,cc6,isol17,6)
                else
c                 Switch of c6 does not work, try calculating c6 with cc5
                  call extract3r2(c6,cc6,1,cref6,cc5,c7,c8,d56,d67,d68,
     -              d3tol,isol17(6),'r6 2',iout,LEVTEST)
                  if (isol17(6) .eq. 0) go to 999
                  itc58=itranscis(cc5,c6,c7,c8)
                  if (itc58 .eq. itcref58) then
                    call switchsol(c5,cc5,isol17,5)
                  else
                    itc58=itranscis(cc5,cc6,c7,c8)
                    if (itc58 .eq. itcref58) then
                      call switchsol(c5,cc5,isol17,5)
                      call switchsol(c6,cc6,isol17,6)
                    else
                      go to 999
                    end if
                  end if
                end if
              end if
            end if
            call extract3r2(c3,cc3,1,cref3,c1,c2,c5,d13,d23,d35,d3tol,
     -        isol17(3),'r3 2',iout,LEVTEST)
            if (isol17(3) .ne. 0) then
              call extract3r2(c4,cc4,1,cref4,c2,c3,c5,d24,d34,d45,d3tol,
     -          isol17(4),'r4 2',iout,LEVTEST)
              if (isol17(4) .ne. 0) then
                if (itcref25 .ne. 0) then
c                 Check for cis/trans flip
                  itc25=itranscis(c2,c3,c4,c5)
                  if (itc25 .ne. itcref25) then
c                   Switch solution
                    itc25=itranscis(c2,c3,cc4,c5)
                    if (itc25 .eq. itcref25) then
                      call switchsol(c4,cc4,isol17,4)
                    else
c                     Switch of c4 does not work, try calculating c4 with cc3
                      call extract3r2(c4,cc4,1,cref4,c2,cc3,c5,d24,d34,
     -                  d45,d3tol,isol17(4),'r4 2',iout,LEVTEST)
                      if (isol17(6) .eq. 0) go to 999
                      itc25=itranscis(c2,cc3,c4,c5)
                      if (itc25 .eq. itcref25) then
                        call switchsol(c3,cc3,isol17,3)
                      else
                        itc25=itranscis(c2,cc3,cc4,c5)
                        if (itc25 .eq. itcref25) then
                          call switchsol(c3,cc3,isol17,3)
                          call switchsol(c4,cc4,isol17,4)
                        else
                          go to 999
                        end if
                      end if
                    end if
                  end if
                end if
                deld27=d46-darrdist(c4,c6)
                isol=1
              end if
            end if
          end if
        end if
      end if
999   neval=neval+1
      if (LEVTEST .gt. 0) write (iout,1000) d27,deld27,isol,neval
      return
1000  format(' D27TOPEPOOP: d27=',f12.8,' deld27=',e14.7,' isol=',i1,
     -  ' neval=',i8)
      end
      subroutine closelooppro1(it,nsol,cref,cref22,cref33,cref44,cref55,
     -  c,cslt,r2,r3,r4,r5,d02it,d03it,d12it,d13it,d14it,d23it,d24it,
     -  d25it,d34it,d35it,d36it,d45it,d46it,d47it,d56it,d57it,
     -  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,i0,i1,i2,i3,i4,i5,i6,i7,
     -  lab,dxymin0,dxymax0,deldxy,iswap,dxydiv,d3tol,fac1x,d24tol,
     -  dijtol,dihpmtol,nosoltyp,nimptry,nimpfound,neval,iout,
     -  looptyp,loopalt)
c#    MMC routine 156 lstmod: 02/07/07
      dimension cref(3,#ST),c(3,#ST),cslt(3,#ST),
     -  cref22(3),cref33(3),cref44(3),cref55(3),
     -  r2(3),r3(3),r4(3),r5(3),nimpfound(2),
     -  c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),c9(3)
      real*8 c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,d02it,d03it,d12it,d13it,
     -  d14it,d23it,d24it,d25it,d34it,d35it,d36it,d45it,d46it,d47it,
     -  d56it,d57it,dxymin0,dxymax0,deldxy
      character*10 lab
c*****Close loop with consecutive bonds broken by one fixed bond
      common /solchoice/ isol17(7),isol17alt(7,2)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      common /option/ iop(200),idebug(200)
      real*8 cref1,cref2,cref3,cref4,cref5,darrdist,deldxy0m,deldxy0p,
     -  deldxym,deldxyp,deldxyt,dxy,dxytry,dxyptry,dxymtry,dxytryn,
     -  dxytryf,dxyref,dxymin,dxymax,deldxy0
      dimension cref1(3),cref2(3),cref3(3),cref4(3),cref5(3)
      character*8 okmark
      if (looptyp .lt. 4 .or. looptyp .gt. 9) then
        write (iout,1014) looptyp
        call datprt(2)
      end if
      ltyp=looptyp+20*(loopalt-1)
      neval=0
      deldxy=999.9
      do k=1,3
        c0(k)=c(k,i0)
        c1(k)=c(k,i1)
        c2(k)=c(k,i2)
        cref2(k)=cref22(k)
        cref3(k)=cref33(k)
        cref4(k)=cref44(k)
        cref5(k)=cref55(k)
        c6(k)=c(k,i6)
        c7(k)=c(k,i7)
      end do
      itcrefdb=0
      if (ltyp .eq. 5) then
        tcdb=dihangl(cslt(1,i0),cslt(1,i1),cslt(1,i2),cslt(1,i3),
     -    idebug(86),iout)*rdtodg
        if (amin1(abs(tcdb),180.0-abs(tcdb)) .lt. dihpmtol) then
          itcrefdb=itranscis(c0,c1,cref2,cref3)
          if (idebug(138) .gt. 0) tdb=dihangld(c0,c1,cref2,cref3,
     -      idebug(86),iout)*rdtodg
        end if
      else if (ltyp .eq. 6) then
        tcdb=dihangl(cslt(1,i1),cslt(1,i2),cslt(1,i3),cslt(1,i4),
     -    idebug(86),iout)*rdtodg
        if (abs(tcdb) .gt. dihpmtol.and.abs(pi-tcdb) .gt. dihpmtol) then
          itcrefdb=itranscis(c1,cref2,cref3,cref4)
          if (idebug(138) .gt. 0) tdb=dihangld(c1,cref2,cref3,cref4,
     -      idebug(86),iout)*rdtodg
        end if
      else if (ltyp .eq. 7) then
        tcdb=dihangl(cslt(1,i2),cslt(1,i3),cslt(1,i4),cslt(1,i5),
     -    idebug(86),iout)*rdtodg
        if (abs(tcdb) .gt. dihpmtol.and.abs(pi-tcdb) .gt. dihpmtol) then
          itcrefdb=itranscis(cref2,cref3,cref4,cref5)
          if (idebug(138) .gt. 0)tdb=dihangld(cref2,cref3,cref4,cref5,
     -      idebug(86),iout)*rdtodg
        end if
      else if (ltyp .eq. 8) then
        tcdb=dihangl(cslt(1,i3),cslt(1,i4),cslt(1,i5),cslt(1,i6),
     -    idebug(86),iout)*rdtodg
        if (abs(tcdb) .gt. dihpmtol.and.abs(pi-tcdb) .gt. dihpmtol) then
          itcrefdb=itranscis(cref3,cref4,cref5,c6)
          if (idebug(138) .gt. 0) tdb=dihangld(cref3,cref4,cref5,c6,
     -      idebug(86),iout)*rdtodg
        end if
      else if (ltyp .eq. 9) then
        tcdb=dihangl(cslt(1,i4),cslt(1,i5),cslt(1,i6),cslt(1,i7),
     -    idebug(86),iout)*rdtodg
        if (abs(tcdb) .gt. dihpmtol.and.abs(pi-tcdb) .gt. dihpmtol) then
          itcrefdb=itranscis(cref4,cref5,c6,c7)
          if (idebug(138) .gt. 0) tdb=dihangld(cref4,cref5,c6,c7,
     -      idebug(86),iout)*rdtodg
        end if
      end if
      if (idebug(138) .gt. 1 .and. itcrefdb .gt. 0) then
        write (iout,1013) it,ltyp,itcrefdb,tcdb,tdb
      end if
      ntry=3
      if (idebug(137) .gt. 0) ntry=idebug(137)
      do itry=1,ntry
      if (itry .eq. 1) then
c       Set dxyref
        if (ltyp .eq. 4) then
          dxyref=darrdist(cref2,cref5)
        else if (ltyp .eq. 9) then
          dxyref=arrdist(cref(1,i1),cref44)
        else if (ltyp .eq. 24) then
          dxyref=arrdist(cref(1,i7),cref44)
        else
          dxyref=arrdist(cref(1,i1),cref55)
        end if
        dxymin=dxymin0
        dxymax=dxymax0
        ifixsol=0
      else if (itry .eq. 2) then
        call trnsfi(isol17,isol17alt(1,1),7)
        if (ltyp .eq. 4) then
          dxyref=darrdist(c2,c5)
        else if (ltyp .eq. 9) then
          dxyref=darrdist(c1,c4)
        else
          dxyref=darrdist(c1,c5)
        end if
        dxymin=dmax1(dxyref-20.1*dxydiv,dxymin0)
        dxymax=dmin1(dxyref+20.1*dxydiv,dxymax0)
        ifixsol=1
        nimptry=nimptry+1
      else
        call trnsfi(isol17,isol17alt(1,2),7)
      end if
      nsol=0
      nosoltyp=0
      dxy=dxyref
      if (idebug(111) .gt. 0) then
        write (6,1001) lab,i0,i1,i2,i3,i4,i5,i6,i7
        call zeroitd(c8,3)
        call zeroitd(c9,3)
        if (iswap .eq. 0) then
          do k=1,3
            cref1(k)=cref(k,i1)
            cref2(k)=cref(k,i2)
          end do
          call loopmemtest(it,ltyp,c0,cref1,cref2,cref3,cref4,
     -      cref5,c6,c7,c8,c9,d14max,d24tol/2.0,d24tol/1.33,'reference',
     -      ifail,idebug(111),iout)
        else
          do k=1,3
            cref1(k)=cref(k,i1)
            cref2(k)=cref(k,i2)
          end do
          call loopmemtest(it,14-ltyp,c7,c6,cref5,cref4,cref3,cref2,
     -      c1,c0,c8,c9,d14max,d24tol/2.0,d24tol/1.33,'reference',ifail,
     -      idebug(111),iout)
        end if
      end if
c     d3tol: tolerance in extract3
c     dxytol: tolerance in dxy
      dxytol=d3tol
      if (dxyref .lt. dxymin) then
        nmstep=0
        dxy=dxymin
      else
        nmstep=(dxy-dxymin)/dxydiv
      end if
      if (dxyref .gt. dxymax) then
        npstep=0
        dxy=dxymax
      else
        npstep=(dxymax-dxy)/dxydiv
      end if
      if (idebug(112) .gt. 0) write (iout,1004)
     -   dxy,dxyref,dxymin,dxymax,dxydiv,nmstep,npstep,itry
      im=0
      ip=0
      dxymtry=dxy
      dxyptry=dxy
c     Get deviation with dxy=dxyref
      call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,cref4,
     -  cref5,itcrefdb,dxy,d02it,d03it,d12it,d13it,d14it,d23it,d24it,
     -  d25it,d34it,d35it,d36it,d45it,d46it,d47it,d56it,d57it,deldxy0m,
     -  d3tol,isolm,ifixsol,neval,iout,ltyp,idebug(112))
      deldxy0p=deldxy0m
      deldxym=deldxy0m
      deldxyp=deldxy0p
      deldxyt=deldxy0m
      isolp=isolm
      if (isolm*(idebug(74)+idebug(113)) .gt. 0) then
        write (6,1005) lab,'c',5,i5,c5,cref5,dsqrt(darrdist(c5,cref5))
        write (6,1005) lab,'c',4,i4,c4,cref4,dsqrt(darrdist(c4,cref4))
        write (6,1005) lab,'c',3,i3,c3,cref3,dsqrt(darrdist(c3,cref3))
        write (6,1005) lab,'c',2,i2,c2,cref2,dsqrt(darrdist(c2,cref2))
      end if
      do while (im .le. nmstep .and. ip .lt. npstep)
        im=im+1
        if (idebug(112) .gt. 0) write (iout,1002)
     -    im,ip,isolm,isolp,nmstep,npstep,dxymtry,dxyptry,dxydiv
        if (im .le. nmstep) then
          dxytry=dxymtry-dxydiv
        else
          dxytry=dxymin
        end if
        if (im .le. nmstep) then
c         Test for solution between dxymtry and dxytry
          call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,cref4,
     -      cref5,itcrefdb,dxytry,d02it,d03it,d12it,d13it,d14it,d23it,
     -      d24it,d25it,d34it,d35it,d36it,d45it,d46it,d47it,d56it,d57it,
     -      deldxy,d3tol,isol,ifixsol,neval,iout,ltyp,idebug(112))
          if (isol .gt. 0) then
            if (isolm .eq. 0) then
              deldxy0m=deldxy
              deldxyt=deldxy
              isolm=1
            else if (deldxy*deldxy0m .lt. 0.d0) then
c             Iterate between dxytry and dxymtry
              niter=0
              deldxym=deldxy
              do while (dxymtry-dxytry .gt. dxytol)
                niter=niter+1
                dxytryn=(dxymtry+dxytry)/2.d0
                call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,
     -            cref4,cref5,itcrefdb,dxytryn,d02it,d03it,d12it,d13it,
     -            d14it,d23it,d24it,d25it,d34it,d35it,d36it,d45it,d46it,
     -            d47it,d56it,d57it,deldxy,d3tol,isol,ifixsol,neval,
     -            iout,ltyp,idebug(112))
                if (deldxy*deldxy0m .lt. 0.d0) then
                  dxytry=dxytryn
                  deldxyt=deldxy
                else
                  dxymtry=dxytryn
                  deldxym=deldxy
                end if
              end do
              idone=1
              go to 100
            end if
          else
            im=nmstep
          end if
        end if
        dxymtry=dxytry
        deldxym=deldxy
        ip=ip+1
        if (ip .le. npstep) then
          dxytry=dxyptry+dxydiv
        else
          dxytry=dxymax
        end if
c       Test for solution between dxyptry and dxytry
        if (ip .le. npstep) then
          call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,
     -      cref4,cref5,itcrefdb,dxytry,d02it,d03it,d12it,d13it,d14it,
     -      d23it,d24it,d25it,d34it,d35it,d36it,d45it,d46it,d47it,
     -      d56it,d57it,deldxy,d3tol,isol,ifixsol,neval,iout,ltyp,
     -      idebug(112))
          if (isol .gt. 0) then
            if (isolp .eq. 0) then
              deldxy0p=deldxy
              deldxyt=deldxy
              isolp=1
            else if (deldxy*deldxy0p .lt. 0.d0) then
c             Iterate between dxytry and dxyptry
              niter=0
              deldxyp=deldxy
              do while (dxytry-dxyptry .gt. dxytol)
                niter=niter+1
                dxytryn=(dxyptry+dxytry)/2.d0
                call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,
     -            cref4,cref5,itcrefdb,dxytryn,d02it,d03it,d12it,d13it,
     -            d14it,d23it,d24it,d25it,d34it,d35it,d36it,d45it,d46it,
     -            d47it,d56it,d57it,deldxy,d3tol,isol,ifixsol,neval,
     -            iout,ltyp,idebug(112))
                if (deldxy*deldxy0p .lt. 0.d0) then
                  dxytry=dxytryn
                  deldxyt=deldxy
                else
                  dxyptry=dxytryn
                  deldxyp=deldxy
                end if
              end do
              idone=2
              go to 100
            end if
          else
            ip=npstep
          end if
        end if
        dxyptry=dxytry
        deldxyp=deldxy
      end do
      if (idebug(74) .gt. 0) then
        write (iout,1017) it
        inperr=inperr+1
      end if
      nosoltyp=1
      if (itry .eq. 1) return
100   okmark='        '
      if (idebug(112) .gt. 0 .and. itry .gt. 1)
     -  write (iout,1010) lab,deldxy0,deldxy,im,ip,itry
      if (nosoltyp .ne. 1 .and. dabs(deldxy) .gt. fac1x*dxytol) then
c       Solution is unreliable - skip it
        nsol=0
        nosoltyp=2
        okmark(5:8)='xxxx'
        if (itry .eq. 1) then
c         Get the better solution order
          dxytryf=0.d0
          if (idone .eq. 1) then
            if (dabs(deldxym) .lt. dabs(deldxyt)) then
              if (deldxym .ne. deldxy)  dxytryf=dxymtry
            else
              if (deldxyt .ne. deldxy)  dxytryf=dxytry
            end if
          else
            if (dabs(deldxyp) .lt. dabs(deldxyt)) then
              if (deldxyp .ne. deldxy)  dxytryf=dxyptry
            else
              if (deldxyt .ne. deldxy)  dxytryf=dxytry
            end if
          end if
          if (idebug(114) .gt. 1) write (iout,1007) idone,dxytryf,
     -      dxytry,dxymtry,dxyptry,deldxy,deldxyt,deldxym,deldxyp,itry
          if (dxytryf .ne. 0.d0) then
            call trnsfi(isol17alt(1,2),isol17,7)
            call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,
     -        cref4,cref5,itcrefdb,dxytryf,d02it,d03it,d12it,d13it,
     -        d14it,d23it,d24it,d25it,d34it,d35it,d36it,d45it,d46it,
     -        d47it,d56it,d57it,deldxy,d3tol,isol,ifixsol,neval,
     -        iout,ltyp,idebug(112))
            call trnsfi(isol17alt(1,1),isol17,7)
          else
            if (dxytryn .eq. dxytry) then
              if (idone .eq. 1) then
                dxytryf=dxymtry
              else
                dxytryf=dxyptry
              end if
            else
              dxytryf=dxytry
            end if
            call trnsfi(isol17alt(1,1),isol17,7)
            call dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,cref2,cref3,
     -        cref4,cref5,itcrefdb,dxytryf,d02it,d03it,d12it,d13it,
     -        d14it,d23it,d24it,d25it,d34it,d35it,d36it,d45it,d46it,
     -        d47it,d56it,d57it,deldxyt,d3tol,isol,ifixsol,neval,
     -        iout,ltyp,idebug(112))
            call trnsfi(isol17alt(1,2),isol17,7)
            if (idebug(112) .gt. 0) write (iout,1008)
     -        idone,dxytryf,deldxyt
          end if
          if (idebug(112) .gt. 0) write (iout,1009) isol17alt
          deldxy0=deldxy
        end if
      else if (nosoltyp .ne. 1) then
        nsol=1
c       Return solution to parameter arrays
        do k=1,3
          r2(k)=c2(k)
          r3(k)=c3(k)
          r4(k)=c4(k)
          r5(k)=c5(k)
        end do
        if (itry .gt. 1) nimpfound(itry-1)=nimpfound(itry-1)+1
        if (idebug(138) .gt. 0) then
          itcdb=0
          if (ltyp .eq. 5) then
            itcdb=itranscis(c0,c1,c2,c3)
            tdba=dihangld(c0,c1,c2,c3,idebug(86),iout)*rdtodg
          else if (ltyp .eq. 6) then
            itcdb=itranscis(c1,c2,c3,c4)
            tdba=dihangld(c1,c2,c3,c4,idebug(86),iout)*rdtodg
          else if (ltyp .eq. 7) then
            itcdb=itranscis(c2,c3,c4,c5)
            tdba=dihangld(c2,c3,c4,c5,idebug(86),iout)*rdtodg
          else if (ltyp .eq. 8) then
            itcdb=itranscis(c3,c4,c5,c6)
            tdba=dihangld(c3,c4,c5,c6,idebug(86),iout)*rdtodg
          else if (ltyp .eq. 9) then
            itcdb=itranscis(c4,c5,c6,c7)
            tdba=dihangld(c4,c5,c6,c7,idebug(86),iout)*rdtodg
          end if
          if (itcdb .ne. 0) then
            if (itcdb*itcrefdb .eq. -1) then
              write (iout,1003) it,'cis-trans problem',ltyp,
     -          itcdb,itcrefdb,tdb,tdba,tcdb
              if (ltyp .eq. 6)
     -          call printcijkl('L6 driver',c1,c2,c3,c4,iout)
              if (ltyp .eq. 7)
     -          call printcijkl('L7 driver',c2,c3,c4,c5,iout)
            else if (idebug(138) .gt. 1) then
              write (iout,1003) it,'ok',ltyp,
     -         itcdb,itcrefdb,tdb,tdba,tcdb
            end if
          end if
        end if
        if (idebug(74)+idebug(111) .gt. 0) go to 200
        return
      end if
      nosoltyp=2
      end do
200   if (idebug(74) .gt. 0) then
c       Zero torsion for self test
        dev=arrdist(r3,cref33)+arrdist(r4,cref44)+
     -      arrdist(r5,cref55)+arrdist(r2,cref22)
        if (dev .gt. dijtol) okmark(1:4)='****'
        write (iout,1012) it,dev,deldxy,okmark
      end if
      if (idebug(111) .gt. 1) then
        if (nsol .gt. 0) then
          write (6,1005) lab,'r',5,i5,r5,cref55,sqrt(arrdist(r5,cref55))
          write (6,1005) lab,'r',4,i4,r4,cref44,sqrt(arrdist(r4,cref44))
          write (6,1005) lab,'r',3,i3,r3,cref33,sqrt(arrdist(r3,cref33))
          write (6,1005) lab,'r',2,i2,r2,cref22,sqrt(arrdist(r2,cref22))
        end if
        write (iout,1006) deldxy,niter,d24tol,dxytol
        if (iswap .eq. 0) then
          call loopmemtest(it,ltyp,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -      d14max,d24tol/2.0,d24tol/1.33,'solution ',ifail,idebug(111),
     -      iout)
        else
          call loopmemtest(it,14-ltyp,c7,c6,c5,c4,c3,c2,c1,c0,c8,c9,
     -      d14max,d24tol/2.0,d24tol/1.33,'solution ',ifail,idebug(111),
     -      iout)
        end if
      end if
      return
1001  format(' LOOPPRO1 ',a,' i0-7=',8i6)
1002  format(' LOOPPRO1: im=',i4,' ip=',i4,' isolm,p=',i2,i3,
     -  ' nm/pstep=',2i4,' dxym,ptry=',2f14.9,' dxydiv=',f8.5)
1003  format(' LOOPPRO1 it=',i4,1x,a,' ltyp=',i2,
     -   ' itc,itcref=',2i3,' tbef,aft,ref=',3f7.1)
1004  format(' LOOPPRO1: dxy,dxyref,dxymin/max,dxydiv=',5f10.5,
     -  ' nm,npstep=',2i4,' itry=',i1)
1005  format(' LOOPPRO1: ',a,1x,a,i1,'(',i5,')=',3f10.6,' cref=',3f10.6,
     -  ' d=',f10.5)
1006  format(' LOOPPRO1:  deldxy=',e14.7,' niter=',i3,
     -  ' d24tol,dxytol=',2e9.3)
1007  format(' LOOPPRO1: idone=',i1,' dxytryf,try,m,p=',4f14.9,/,
     -  11x,'deldxy,t,m,p=',4e15.8,' itry=',i1)
1008  format(' LOOPPRO1: idone=',i1,' dxytryf=',f14.9,' deldxyt=',e15.8)
1009  format(' LOOPPRO1: isol17alt=',7i3,2x,7i3)
1010  format(' LOOPPRO1: ',a,' original deldxy=',e14.7,' deld refined ',
     -  'with fixed solution choices=',e14.7,' im,p=',i3,i4,' itry=',i1)
1012  format(' LOOPPRO1: it=',i6,' d(ref-sol)^2=',e12.5,
     -  ' deldxy=',e14.7,1x,a)
1013  format(' LOOPPRO1: it=',i5,' ltyp=',i2,' itcrefdb=',i2,
     -  ' tc,t=',2f8.1)
1014  format(' ***** ERROR: invalid loop type in closelooppro1:',i2)
1017  format(' ***** ERROR: no solution in looppro1 for zero torsion ',
     -  'change it=',i6)
      end
      subroutine dxytopro1loop(c0,c1,c2,c3,c4,c5,c6,c7,
     -  cref2,cref3,cref4,cref5,itcrefdb,dxy,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d45,d46,d47,d56,d57,
     -  deldxy,d3tol,isol,ifixsol,neval,iout,looptyp,LEVTEST)
c#    MMC routine 157 lstmod: 02/07/07
      real*8 c0,c1,c2,c3,c4,c5,c6,c7,cc2,cc3,cc4,cc5,
     -  cref2,cref3,cref4,cref5,dxy,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d45,d46,d47,d56,d57,
     -  deldxy,darrdist
      dimension c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),
     -  cref2(3),cref3(3),cref4(3),cref5(3),cc2(3),cc3(3),cc4(3),cc5(3)
c*****From a trial r2-r7 distance, get the estimates of c3-c7
      common /solchoice/ isol17(7),isol17alt(7,2)
      if (ifixsol .eq. 0) call zeroiti(isol17,0,7)
      deldxy=999.9
      isol=0
      if (looptyp .eq. 4) then
        call extract3r2(c5,cc5,1,cref5,c2,c6,c7,dxy,d56,d57,d3tol,
     -    isol17(5),'r5 2',iout,LEVTEST)
        if (isol17(5) .ne. 0) then
          call extract3r2(c3,cc3,1,cref3,c1,c2,c5,d13,d23,d35,d3tol,
     -      isol17(3),'r3 2',iout,LEVTEST)
          if (isol17(3) .ne. 0) then
            call extract3r2(c4,cc4,1,cref4,c2,c5,c6,d24,d45,d46,d3tol,
     -        isol17(4),'r4 2',iout,LEVTEST)
            if (isol17(4) .ne. 0) then
              deldxy=d34-darrdist(c3,c4)
              isol=1
            end if
          end if
        end if
      else if (looptyp .eq. 5) then
        call extract3r2(c5,cc5,1,cref5,c1,c6,c7,dxy,d56,d57,d3tol,
     -    isol17(5),'r5 2',iout,LEVTEST)
        if (isol17(5) .ne. 0) then
          call extract3r2(c3,cc3,1,cref3,c0,c1,c5,d03,d13,d35,d3tol,
     -      isol17(3),'r3 2',iout,LEVTEST)
          if (isol17(3) .ne. 0) then
            call extract3r2(c2,cc2,1,cref2,c0,c1,c3,d02,d12,d23,d3tol,
     -        isol17(2),'r2 2',iout,LEVTEST)
            if (isol17(2) .ne. 0) then
              if (itcrefdb .ne. 0) then
c               Check for cis/trans flip
                itcdb=itranscis(c0,c1,c2,c3)
                if (itcdb .ne. itcrefdb) then
c                 Switch solution
                  itcdb=itranscis(c0,c1,cc2,c3)
                  if (itcdb .eq. itcrefdb) then
                    call switchsol(c2,cc2,isol17,2)
                  else
c                   Switch of c2 does not work, try calculating c2 with cc3
                    call extract3r2(c2,cc2,1,cref2,c0,c1,cc3,d02,d12,
     -                d23,d3tol,isol17(2),'r2 2',iout,LEVTEST)
                    if (isol17(2) .eq. 0) go to 999
                    itcdb=itranscis(c0,c1,c2,cc3)
                    if (itcdb .eq. itcrefdb) then
                      call switchsol(c3,cc3,isol17,3)
                    else
                      itcdb=itranscis(c0,c1,cc2,cc3)
                      if (itcdb .eq. itcrefdb) then
                        call switchsol(c2,cc2,isol17,2)
                        call switchsol(c3,cc3,isol17,3)
                      else
                        go to 999
                      end if
                    end if
                  end if
                end if
              end if
              call extract3r2(c4,cc4,1,cref4,c2,c3,c6,d24,d34,d46,d3tol,
     -          isol17(4),'r4 2',iout,LEVTEST)
              if (isol17(4) .ne. 0) then
                deldxy=d45-darrdist(c4,c5)
                isol=1
              end if
            end if
          end if
        end if
      else if (looptyp .eq. 6) then
        call extract3r2(c5,cc5,1,cref5,c1,c6,c7,dxy,d56,d57,d3tol,
     -    isol17(5),'r5 2',iout,LEVTEST)
        if (isol17(5) .ne. 0) then
          call extract3r2(c4,cc4,1,cref4,c1,c5,c6,d14,d45,d46,d3tol,
     -      isol17(4),'r4 2',iout,LEVTEST)
          if (isol17(4) .ne. 0) then
            call extract3r2(c3,cc3,1,cref3,c1,c4,c5,d13,d34,d35,d3tol,
     -        isol17(3),'r3 2',iout,LEVTEST)
            if (isol17(3) .ne. 0) then
              call extract3r2(c2,cc2,1,cref2,c0,c1,c4,d02,d12,d24,d3tol,
     -          isol17(2),'r2 2',iout,LEVTEST)
              if (isol17(2) .ne. 0) then
                if (itcrefdb .ne. 0) then
c                 Check for cis/trans flip
                  itcdb=itranscis(c1,c2,c3,c4)
                  if (itcdb .ne. itcrefdb) then
c                   Switch c2 solution
                    itcdb=itranscis(c1,cc2,c3,c4)
                    if (itcdb .eq. itcrefdb) then
                      call switchsol(c2,cc2,isol17,2)
                    else
c                     Switch c3 solution
                      itcdb=itranscis(c1,c2,cc3,c4)
                      if (itcdb .eq. itcrefdb) then
                        call switchsol(c3,cc3,isol17,3)
                      else
c                       Switch both c2 and c3 solutions
                        itcdb=itranscis(c1,cc2,cc3,c4)
                        if (itcdb .eq. itcrefdb) then
                          call switchsol(c2,cc2,isol17,2)
                          call switchsol(c3,cc3,isol17,3)
                        else
c                         Switch of c2,c3 didn't work, try calc with cc4
                          call extract3r2(c3,cc3,1,cref3,c1,cc4,c5,d13,
     -                      d34,d35,d3tol,isol17(3),'r3 2',iout,LEVTEST)
                          if (isol17(3) .eq. 0) go to 999
                          call extract3r2(c2,cc2,1,cref2,c0,c1,cc4,
     -                      d02,d12,d24,d3tol,isol17(2),'r2 2',iout,
     -                      LEVTEST)
                          if (isol17(2) .eq. 0) go to 999
                          itcdb=itranscis(c1,c2,c3,cc4)
                          if (itcdb .eq. itcrefdb) then
                            call switchsol(c4,cc4,isol17,4)
                          else
                            itcdb=itranscis(c1,cc2,c3,cc4)
                            if (itcdb .eq. itcrefdb) then
                              call switchsol(c2,cc2,isol17,2)
                              call switchsol(c4,cc4,isol17,4)
                            else
                              itcdb=itranscis(c1,c2,cc3,cc4)
                              if (itcdb .eq. itcrefdb) then
                                call switchsol(c3,cc3,isol17,3)
                                call switchsol(c4,cc4,isol17,4)
                              else
                                itcdb=itranscis(c1,cc2,cc3,cc4)
                                if (itcdb .eq. itcrefdb) then
                                  call switchsol(c2,cc2,isol17,2)
                                  call switchsol(c3,cc3,isol17,3)
                                  call switchsol(c4,cc4,isol17,4)
                                else
                                  go to 999
                                end if
                              end if
                            end if
                          end if
                        end if
                      end if
                    end if
                  end if
                end if
                deldxy=d23-darrdist(c2,c3)
                isol=1
              end if
            end if
          end if
        end if
      else if (looptyp .eq. 7) then
        call extract3r2(c5,cc5,1,cref5,c1,c6,c7,dxy,d56,d57,d3tol,
     -    isol17(5),'r5 2',iout,LEVTEST)
        if (isol17(5) .ne. 0) then
          call extract3r2(c2,cc2,1,cref2,c0,c1,c5,d02,d12,d25,d3tol,
     -      isol17(2),'r2 2',iout,LEVTEST)
          if (isol17(2) .ne. 0) then
            call extract3r2(c3,cc3,1,cref3,c1,c2,c5,d13,d23,d35,d3tol,
     -        isol17(3),'r3 2',iout,LEVTEST)
            if (isol17(3) .ne. 0) then
              call extract3r2(c4,cc4,1,cref4,c2,c5,c6,d24,d45,d46,d3tol,
     -          isol17(4),'r4 2',iout,LEVTEST)
              if (isol17(4) .ne. 0) then
                if (itcrefdb .ne. 0) then
c                 Check for cis/trans flip
                  itcdb=itranscis(c2,c3,c4,c5)
                  if (itcdb .ne. itcrefdb) then
c                   Switch c4 solution
                    itcdb=itranscis(c2,c3,cc4,c5)
                    if (itcdb .eq. itcrefdb) then
                      call switchsol(c4,cc4,isol17,4)
                    else
c                     Switch c3 solution
                      itcdb=itranscis(c2,cc3,c4,c5)
                      if (itcdb .eq. itcrefdb) then
                        call switchsol(c3,cc3,isol17,3)
                      else
c                       Switch both c4 and c3 solutions
                        itcdb=itranscis(c2,cc3,cc4,c5)
                        if (itcdb .eq. itcrefdb) then
                          call switchsol(c4,cc4,isol17,4)
                          call switchsol(c3,cc3,isol17,3)
                        else
c                         Switch of c2,c3 didn't work, try calc with cc2
                          call extract3r2(c3,cc3,1,cref3,c1,cc2,c5,d13,
     -                      d23,d35,d3tol,isol17(3),'r3 2',iout,LEVTEST)
                          if (isol17(3) .eq. 0) go to 999
                          call extract3r2(c4,cc4,1,cref4,cc2,c5,c6,
     -                      d24,d45,d46,d3tol,isol17(4),'r2 2',iout,
     -                      LEVTEST)
                          if (isol17(4) .eq. 0) go to 999
                          itcdb=itranscis(cc2,c3,c4,c5)
                          if (itcdb .eq. itcrefdb) then
                            call switchsol(c2,cc2,isol17,2)
                          else
                            itcdb=itranscis(cc2,c3,cc4,c5)
                            if (itcdb .eq. itcrefdb) then
                              call switchsol(c2,cc2,isol17,2)
                              call switchsol(c4,cc4,isol17,4)
                            else
                              itcdb=itranscis(cc2,cc3,c4,c5)
                              if (itcdb .eq. itcrefdb) then
                                call switchsol(c3,cc3,isol17,3)
                                call switchsol(c2,cc2,isol17,2)
                              else
                                itcdb=itranscis(cc2,cc3,cc4,c5)
                                if (itcdb .eq. itcrefdb) then
                                  call switchsol(c2,cc2,isol17,2)
                                  call switchsol(c3,cc3,isol17,3)
                                  call switchsol(c4,cc4,isol17,4)
                                else
                                  go to 999
                                end if
                              end if
                            end if
                          end if
                        end if
                      end if
                    end if
                  end if
                end if
                deldxy=d34-darrdist(c3,c4)
                isol=1
              end if
            end if
          end if
        end if
      else if (looptyp .eq. 8) then
        call extract3r2(c5,cc5,1,cref5,c1,c6,c7,dxy,d56,d57,d3tol,
     -    isol17(5),'r5 2',iout,LEVTEST)
        if (isol17(5) .ne. 0) then
          call extract3r2(c3,cc3,1,cref3,c1,c5,c6,d13,d35,d36,d3tol,
     -      isol17(3),'r3 2',iout,LEVTEST)
          if (isol17(3) .ne. 0) then
            call extract3r2(c4,cc4,1,cref4,c3,c5,c6,d34,d45,d46,d3tol,
     -        isol17(4),'r4 2',iout,LEVTEST)
            if (isol17(4) .ne. 0) then
              if (itcrefdb .ne. 0) then
c               Check for cis/trans flip
                itcdb=itranscis(c3,c4,c5,c6)
                if (itcdb .ne. itcrefdb) then
c                 Switch c4 solution
                  itcdb=itranscis(c3,cc4,c5,c6)
                  if (itcdb .eq. itcrefdb) then
                    call switchsol(c4,cc4,isol17,4)
                  else
c                   Switch c3 solution
                    itcdb=itranscis(cc3,c4,c5,c6)
                    if (itcdb .eq. itcrefdb) then
                      call switchsol(c3,cc3,isol17,3)
                    else
c                     Switch both c4 and c3 solutions
                      itcdb=itranscis(cc3,cc4,c5,c6)
                      if (itcdb .eq. itcrefdb) then
                        call switchsol(c2,cc2,isol17,2)
                        call switchsol(c4,cc4,isol17,4)
                      else
c                       Switch of c4,c3 didn't work, try calculating with cc5
                        call extract3r2(c3,cc3,1,cref3,c1,cc5,c6,
     -                    d13,d35,d36,d3tol,isol17(3),'r3 2',iout,
     -                    LEVTEST)
                        if (isol17(3) .eq. 0) go to 999
                        call extract3r2(c4,cc4,1,cref4,c3,cc5,c6,
     -                    d34,d45,d46,d3tol,isol17(4),'r4 2',iout,
     -                    LEVTEST)
                        if (isol17(4) .eq. 0) go to 999
                        itcdb=itranscis(c3,c4,cc5,c6)
                        if (itcdb .eq. itcrefdb) then
                          call switchsol(c5,cc5,isol17,5)
                        else
                          itcdb=itranscis(c3,cc4,cc5,c6)
                          if (itcdb .eq. itcrefdb) then
                            call switchsol(c4,cc4,isol17,4)
                            call switchsol(c5,cc5,isol17,5)
                          else
                            itcdb=itranscis(cc3,c4,cc5,c6)
                            if (itcdb .eq. itcrefdb) then
                              call switchsol(c3,cc3,isol17,3)
                              call switchsol(c5,cc5,isol17,5)
                            else
                              itcdb=itranscis(cc3,cc4,cc5,c6)
                              if (itcdb .eq. itcrefdb) then
                                call switchsol(c3,cc3,isol17,3)
                                call switchsol(c4,cc4,isol17,4)
                                call switchsol(c5,cc5,isol17,5)
                              else
                                go to 999
                              end if
                            end if
                          end if
                        end if
                      end if
                    end if
                  end if
                end if
              end if
              call extract3r2(c2,cc2,1,cref2,c0,c1,c3,d02,d12,d23,d3tol,
     -          isol17(2),'r2 2',iout,LEVTEST)
              if (isol17(2) .ne. 0) then
                deldxy=d24-darrdist(c2,c4)
                isol=1
              end if
            end if
          end if
        end if
      else if (looptyp .eq. 9) then
        call extract3r2(c4,cc4,1,cref4,c1,c6,c7,dxy,d46,d47,d3tol,
     -    isol17(4),'r4 2',iout,LEVTEST)
        if (isol17(4) .ne. 0) then
          call extract3r2(c5,cc5,1,cref5,c4,c6,c7,d45,d56,d57,d3tol,
     -      isol17(5),'r5 2',iout,LEVTEST)
          if (isol17(5) .ne. 0) then
            if (itcrefdb .ne. 0) then
c             Check for cis/trans flip
              itcdb=itranscis(c4,c5,c6,c7)
              if (itcdb .ne. itcrefdb) then
c               Switch solution
                itcdb=itranscis(c4,cc5,c6,c7)
                if (itcdb .eq. itcrefdb) then
                  call switchsol(c5,cc5,isol17,5)
                else
c                 Switch of c5 does not work, try calculating c5 with cc4
                  call extract3r2(c5,cc5,1,cref5,cc4,c6,c7,d45,d56,d57,
     -              d3tol,isol17(5),'r5 2',iout,LEVTEST)
                  if (isol17(5) .eq. 0) go to 999
                  itcdb=itranscis(cc4,c5,c6,c7)
                  if (itcdb .eq. itcrefdb) then
                    call switchsol(c4,cc4,isol17,4)
                  else
                    itcdb=itranscis(cc4,cc5,c6,c7)
                    if (itcdb .eq. itcrefdb) then
                      call switchsol(c4,cc4,isol17,4)
                      call switchsol(c5,cc5,isol17,5)
                    else
                      go to 999
                    end if
                  end if
                end if
              end if
            end if
            call extract3r2(c2,cc2,1,cref2,c0,c1,c4,d02,d12,d24,d3tol,
     -        isol17(2),'r2 2',iout,LEVTEST)
            if (isol17(2) .ne. 0) then
              call extract3r2(c3,cc3,1,cref3,c1,c2,c4,d13,d23,d34,d3tol,
     -          isol17(3),'r3 2',iout,LEVTEST)
              if (isol17(3) .ne. 0) then
                deldxy=d35-darrdist(c3,c5)
                isol=1
              end if
            end if
          end if
        end if
      else if (looptyp .eq. 24) then
        call extract3r2(c4,cc4,1,cref4,c2,c6,c7,d24,d46,dxy,d3tol,
     -    isol17(4),'r4 2',iout,LEVTEST)
        if (isol17(4) .ne. 0) then
          call extract3r2(c5,cc5,1,cref5,c4,c6,c7,d45,d56,d57,d3tol,
     -      isol17(5),'r5 2',iout,LEVTEST)
          if (isol17(5) .ne. 0) then
            call extract3r2(c3,cc3,1,cref3,c1,c2,c4,d13,d23,d34,d3tol,
     -        isol17(3),'r3 2',iout,LEVTEST)
            if (isol17(3) .ne. 0) then
              deldxy=d35-darrdist(c3,c5)
              isol=1
            end if
          end if
        end if
      else
        write (iout,1001) looptyp
        call datprt(2)
      end if
999   neval=neval+1
      if (LEVTEST .gt. 0)
     -  write (iout,1000) looptyp,dxy,deldxy,isol,neval
      return
1000  format(' DXYTOPRO1LOOP: lt=',i2,' dxy=',f12.8,' deldxy=',e14.7,
     -  ' isol=',i1,' neval=',i8)
1001  format(' ***** PROGRAM ERROR: invalid loop type in dxytopro1:',i4)
      end
      subroutine switchsol(c,cc,isol17,is)
c#    MMC routine 157/a lstmod: 09/17/12
      real*8 c,cc
      dimension c(3),cc(3),isol17(7)
      c(1)=cc(1)
      c(2)=cc(2)
      c(3)=cc(3)
      isol17(is)=-(3+isol17(is))
      return
      end
      subroutine printcijkl(lab,ci,cj,ck,cl,iout)
      character*(*) lab
      real*8 ci(3),cj(3),ck(3),cl(3)
      common /option/ iop(200),idebug(200)
      if (idebug(138) .gt. 2) write (iout,1000) lab,ci,cj,ck,cl
      return
1000  format(1x,a,' ci=',3f10.5,' cj=',3f10.5,/,
     -  10x,' ck=',3f10.5,' ck=',3f10.5)
      end
      subroutine decidebf(ibf,cref,d02it,d12it,d13it,d23it,d45it,d46it,
     -  d56it,d57it,i0,i1,i2,i3,i4,i5,i6,i7,looptyp)
c#    MMC routine 158 lstmod: 04/29/04
c*****Decide which direction to solve the loop closing problem
      dimension cref(3,#ST)
      real*8 d02it,d12it,d13it,d23it,
     -  d45it,d46it,d56it,d57it
      real*8 dxy,dxyr
      if (looptyp .eq. 2) then
        cushion1=0.0
        cushion2=0.0
      else if (looptyp .eq. 3) then
        cushion1=0.0
        cushion2=0.0
      else if (looptyp .eq. 4) then
        dxy=arrdist(cref(1,i2),cref(1,i5))
        dxyr=arrdist(cref(1,i3),cref(1,i6))
        call triangleineq(dxy,d56it,d57it,cref(1,i2),cref(1,i6),
     -    cref(1,i7),cushion1)
        call triangleineq(dxyr,d13it,d23it,cref(1,i6),cref(1,i1),
     -    cref(1,i2),cushion2)
      else if (looptyp .eq. 9) then
        dxy=arrdist(cref(1,i1),cref(1,i4))
        dxyr=arrdist(cref(1,i2),cref(1,i5))
        call triangleineq(dxy,d45it,d46it,cref(1,i1),cref(1,i5),
     -    cref(1,i6),cushion1)
        call triangleineq(dxyr,d02it,d12it,cref(1,i5),cref(1,i0),
     -    cref(1,i1),cushion2)
      else
        dxy=arrdist(cref(1,i1),cref(1,i5))
        dxyr=arrdist(cref(1,i2),cref(1,i6))
        call triangleineq(dxy,d56it,d57it,cref(1,i1),cref(1,i6),
     -    cref(1,i7),cushion1)
        call triangleineq(dxyr,d02it,d12it,cref(1,i6),cref(1,i0),
     -    cref(1,i1),cushion2)
      end if
      if (cushion1 .ge. cushion2) then
        ibf=+1
      else
        ibf=-1
      end if
      return
      end
      subroutine torsiontest(key0,key1,ntang,iquata,looptyp,labslt,
     -  esf14,vdwf14,ichkp,inperr,inpt,iout)
c#    MMC routine 158/a lstmod: 05/09/19
c     Sets up test calculation of torsion angles in a loop
      dimension iquata(#TR,4),looptyp(#TR)
      character*4 key0,key1,labslt(2,#ST)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /option/ iop(200),idebug(200)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      character*80 pdbfile
c     print *,'TORSIONTEST key0=',key0,' key1=',key1
      emaxprint=999999.9
      iavepdb=0
      call getint(ia1,1,1,1)
      call getint(ia2,1,1,1)
      itt=0
      do it=1,ntang
        if (iquata(it,2) .eq. ia1 .and. iquata(it,3) .eq. ia2 .or.
     -      iquata(it,2) .eq. ia2 .and. iquata(it,3) .eq. ia1)
     -    itt=it
      end do
      if (itt .eq. 0) then
        write (iout,2236) ia1,ia2
        inperr=inperr+1
      end if
      call inicac
      call csave(ichkp,0,inperr,1)
      if (key0 .eq. 'TORT') then
        if (iop(3) .gt. 8) then
          write (iout,2267)
          inperr=inperr+1
        else
          call getreal(anginc,0,5.0)
          write (iout,2237) 'Scanning',itt, ia1,
     -      (labslt(k,ia1),k=1,2),ia2,(labslt(k,ia2),k=1,2)
          call getreal(emaxprint,0,emaxprint)
          write (iout,*) 'Energy printed will be limited to ',emaxprint
        end if
      else
        write (iout,2237) 'Enumerating loop solutions',itt,
     -    ia1,(labslt(k,ia1),k=1,2),ia2,(labslt(k,ia2),k=1,2)
c       Check if torsion is a loop driver
        if (looptyp(itt) .eq. 0) then
          write (iout,2266) itt
          inperr=inperr+1
        end if
        if (iop(91) .eq. 1) then
          write (iout,2268)
          inperr=inperr+1
        end if
      end if
      call getname(pdbfile,lpdbfile,0,80)
      if (lpdbfile .gt. 0)
     -  call fileopen(pdbfile,lpdbfile,filenames(24),namlens(24),24,0,
     -   1,1,3,iform(24),1,iversout,iout,isavepdb,0)
      call torsionlist(key0,key1,itt,anginc,file,namlenf,
     -  esf14,vdwf14,emaxprint,labslt,isavepdb,inperr,inpt,iout)
      if (inperr .gt. 0) then
        write (iout,2239)
        call datprt(-1)
      end if
      call crstr(0)
      return
2236  format(' ***** ERROR: No torsion bond was found between atoms',
     -  i6,' and',i6)
2237  format(/,1x,a,' torsion ',i5,' on bond ',i6,' (',2a4,') - ',
     -  i6,' (',2a4,')')
2239  format(' ***** ERROR: the input so far was not error-free')
2266  format(' ***** ERROR: torsion ',i5,' is not a loop torsion')
2267  format(' ***** ERROR: no potential was specified for torsion ',
     -  'energy list')
2268  format(' ***** ERROR: LOOP NRST will not generate the full ',
     -  'solution set - replace it with LOOP SCAN')
      end
      subroutine torsionlist(key0,key1,it,anginc,file,namlenf,
     -  esf14,vdwf14,emaxprint,labslt,isavepdb,inperr,inpt,iout)
c#    MMC routine 158/a lstmod: 05/09/19
c*****Enumerate torison states and their energies for torsion it
      character*4 key0,key1,labslt(2,#ST)
      character*80 file
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),
     -  d02(#LT),d03(#LT),d12(#LT),d13(#LT),
     -  d14(#LT),d23(#LT),d24(#LT),d25(#LT),d34(#LT),d35(#LT),
     -  d36(#LT),d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),d79(#LT)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abc(3,#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 deldij,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,r234,torsensumn,
     -  torsensumo,eilj,eilj14,eiljes,eiljes14
      dimension d0(3),d1(3),d2(3),d3(3),d4(3),d5(3),d6(3),d7(3),d8(3),
     -  d9(3),r234(3,4,32),dipmom(3)
      dimension r2(3),r3(3),r4(3),r5(3),r6(3),r7(3),keycol(2)
      character*80 filename
c     print *,'TORSIONLIST key01=',key0,' ',key1,' emaxprint=',
c    -  emaxprint
      testangle0=0.0
      angincrad=0.0
      tors0=0.0
      eilj0=0.0
      eiljes0=0.0
      eilj140=0.0
      eiljes140=0.0
      dipmomabs0=0.0
      if (key0 .eq. 'GENT') then
c       Just generate new conformation with input torsion angles
        call getint(ntorch,1,1,0)
        write (iout,1007) ntorch
        do itt=1,ntorch
          read (inpt,1006) ia1,ia2,ang
          call checklim(ifail,iout,inperr,1,nstta,ia1,1,
     -      'torsion atom index',18)
          call checklim(ifail,iout,inperr,1,nstta,ia2,1,
     -      'torsion atom index',18)
          itor=0
          ifound=0
          do while (ifound .eq. 0 .and. itor .lt. ntang)
            itor=itor+1
            if (ia1 .eq. iquata(itor,2) .and.
     -          ia2 .eq. iquata(itor,3)) then
              write (iout,1008) (labslt(2,iquata(itor,k)),
     -          iquata(itor,k),k=1,4),dihang(itor)*rdtodg,ang
              ifound=1
            else if (ia1 .eq. iquata(itor,3) .and.
     -          ia2 .eq. iquata(itor,2)) then
              ang=-ang
              write (iout,1008) (labslt(2,iquata(itor,k)),
     -          iquata(itor,k),k=4,1,-1),-dihang(itor)*rdtodg,ang
              ifound=1
            end if
          end do
          if (ifound .eq. 0) then
            write (iout,1009) ia1,ia2,ntang
            inperr=inperr+1
          end if
          dihang(itor)=ang/rdtodg
        end do
        do mol=1,nsttm
          call gentor(ifirstt(mol),ilastt(mol),dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -      bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -      #TR,#ST)
        end do
        return
      end if
      mol=iamolslt(iquata(it,3))
      call zeroit(texng,nstta)
      if (key0 .eq. 'LPST') then
c       Generate solutions
        call getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,
     -    i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,looptyp(it),
     -    idebug(71),iout,'TORSIONLST',#TR,#LT)
        if (idebug(122) .gt. 0) write (iout,1005)
     -    i2,(c(k,i2),k=1,3),i3,(c(k,i3),k=1,3),i4,(c(k,i4),k=1,3)
        ibf=0
        call trnsfr(abc,c,nstta3)
        call closeloop(r234,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -    dflsmin(it),dflsmax(it),dflsminr(it),dflsmaxr(it),
     -    deldij,it,c,abc,cslt,r2,r3,r4,r5,r6,r7,
     -    i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,
     -    ii9,'TORSIONLST',0,1,ibf,nsol,isol,nosoltyp,neval,inperr,iout)
        if (idebug(122) .gt. 0) write (iout,1002)
     -    (is,i2,(r234(k,2,is),k=1,3),i3,(r234(k,3,is),k=1,3),
     -    i4,(r234(k,4,is),k=1,3),is=1,nsol)
        if (nsol .le. 1) then
          write (iout,1001)
          return
        end if
        nstep=nsol
      else
        testangle0=dihang(it)
        angincrad=anginc/rdtodg
        nstep=360.0/anginc
        if (360.0-nstep*anginc .gt. anginc*1.001) nstep=nstep+1
      end if
      nlwr=0
      do ig=1,nstep
        if (key0 .eq. 'TORT') then
c         Just generate torsion
          testangle=testangle0+(ig-1)*angincrad
          tstang=testangle*rdtodg
          dihang(it)=testangle
          call gentor(ifirstt(mol),ilastt(mol),dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -      bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -      #TR,#ST)
          if (isavepdb .gt. 0)
     -      call savepdb('PDB ',keycol,isavepdb,-iout,1,nstta,3,c,
     -        -1,1,0,1,filename,0,0,0,file,0,1,1,0,inperr,
     -         nwarn,nwwarn,26,0,nlwr,ig,1,#NA)
        else
c         Extract one loop solution, generate rest of the molecule
          do k=1,3
            r2(k)=r234(k,2,ig)
            r3(k)=r234(k,3,ig)
            r4(k)=r234(k,4,ig)
            d2(k)=r234(k,2,ig)
            d3(k)=r234(k,3,ig)
            d4(k)=r234(k,4,ig)
          end do
          call saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,it,looplist,
     -      iquata,c,looptyp,dihang,r2,r3,r4,r5,r6,r7,i0,i1,i2,i3,i4,
     -      i5,i6,ii2,ii3,ii4,ii5,ii6,ii7,idebug(63),iout)
c         Generate atoms moved by the backbone loop
          call gentor(it,it,dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,bondf,
     -      bondproj,xfac13,xfac12,bond,idebug(25),iout,#TR,#ST)
          if (idebug(122) .gt. 0) write (iout,1003) ig,
     -       (looplist(itt,it),dihang(looplist(itt,it))*rdtodg,itt=1,6)
          do itt=1,5
            iit=looplist(itt,it)
            call gentor(iit,iit,dihang,c,itangindx,iprecursor,nrot,iri,
     -        irotlist,irotlinc,sindela,cosdela,bondf,bondproj,xfac13,
     -        xfac12,bond,idebug(25),iout,#TR,#ST)
          end do
c         Generate side chains too
          do ii=ifsctlist(it),ilsctlist(it)
            iit=isctlist(ii)
            call gentor(iit,iltmovtg(itorgrp(iit)),dihang,c,itangindx,
     -        iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -        bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -        #TR,#ST)
          end do
          if (isavepdb .gt. 0)
     -      call savepdb('PDB ',keycol,isavepdb,-iout,1,nstta,3,c,
     -        -1,1,0,1,filename,0,0,0,file,0,1,1,0,inperr,
     -         nwarn,nwwarn,22,0,nlwr,0,1,#NA)
          tstang=ig
        end if
        if (iop(3) .le. 8) then
          call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,
     -      nbits,#NL,ifirstm(mol),ilastm(mol),iclsltt,qslteps,
     -      esf14,vdwf14,eiljes,eiljes14,indexx,iuuon)
          call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,
     -      nbits,#NL,ifirstm(mol),ilastm(mol),iclsltt,texng,
     -      esf14,vdwf14,eilj,eilj14,indexx,iuuon)
          call diheng(torsensumn,itorgrp(it),torsensumo,torsen,
     -      torsennew,iop(127))
          call dipolemoment(c,nstta,qslt,dipmomabs,dipmom,0)
          if (ig .eq. 1) then
            if (key1 .eq. 'RELE') then
c             Save initial values to subtract
              eilj0=eilj
              eiljes0=eiljes
              eilj140=eilj14
              eiljes140=eiljes14
              tors0=torsennew(it)
              etot=tors0+eiljes0+eiljes140
              dipmomabs0=dipmomabs
              write (iout,1010)
              write (iout,1011)
              write (iout,1000) tstang,tors0,amin1(emaxprint,eilj0),
     -          eiljes0-eilj0,amin1(emaxprint,eiljes0),eilj140,
     -          eiljes140-eilj140,eiljes140,amin1(emaxprint,etot),
     -          dipmomabs
            end if
            write (iout,1011)
          end if
          eilj=eilj-eilj0
          eiljes=eiljes-eiljes0
          eilj14=eilj14-eilj140
          eiljes14=eiljes14-eiljes140
          tors=torsennew(it)-tors0
          etot=tors+eiljes+eiljes14
          seilj=eilj
          seiljes=eiljes
          write (iout,1000) tstang,tors,amin1(emaxprint,seilj),
     -      eiljes-eilj,amin1(emaxprint,seiljes),eilj14,
     -      eiljes14-eilj14,eiljes14,amin1(emaxprint,etot),dipmomabs-
     -      dipmomabs0
        end if
      end do
      if (isavepdb .gt. 0) call fileclose(isavepdb,0,iop(24),iout)
      if (key0 .eq. 'LPST') write (iout,1004) nsol,file(1:namlenf)
      return
1000  format(f7.1,9f11.3)
1001  format(' Only one solution was found for the backbone loop')
1002  format((' is=',i2,3(' ia=',i5,' c=',3f10.5)))
1003  format(' is=',i2,' Loop:',6(' it=',i5,' t=',f8.2))
1004  format(i3,' structures with alternative loops were written to ',
     -  'files ',a,'*_*.pdb')
1005  format(' REF: ',3(' ia=',i5,' c=',3f10.5),/)
1006  format(2i5,f10.0)
1007  format(' Generating new conformation by changing ',i5,
     -  ' torsion angles')
1008  format(' Replacing torsion angle ',3(a,1x,i5,' - '),a,1x,i5,
     -  ' (',f6.1,') with ',f6.1,' deg')
1009  format(' ***** ERROR: Torsion ',i6,' - ',i6,' is not found among',
     -  ' the ',i5,' known torsions')
1010  format(' Each energy term printed is relative to the starting ',
     -  'structure',/,' Actual values at the reference conformation:')
1011  format(/,'           E(tor)    E(LJ)      E(es)     ',
     -  'E(nb)    E14(LJ)   E14(es)   E14(nb)   E(tot)    dipole')
      end
      subroutine triangleineq(da,db,dc,a,b,c,cushion)
      real*8 da,db,dc
      dimension a(3),b(3),c(3)
c#    MMC routine 159 lstmod: 04/29/04
      rac=sqrt(arrdist(a,c))
      rab=sqrt(arrdist(a,b))
      rbc=sqrt(arrdist(c,b))
      ra=dsqrt(da)
      rb=dsqrt(db)
      rc=dsqrt(dc)
      cushion=amin1(ra+rc-rac,ra+rb-rab,rb+rc-rbc)
      return
      end
      subroutine closeloopconsec(it,nsol,cref,cref22,cref33,cref44,
     -  ccm,c,r2,r3,r4,r234,i0,i1,i2,i5,i6,divr3,
     -  d3tol,d24tol,dijtol,dextol,drevtol,isolmin,nosoltyp,neval,
     -  inperr,iout)
c#    MMC routine 160 lstmod: 05/19/16
      dimension cref(3,#ST),ccm(3,#ST),c(3,#ST),r2(3),r3(3),
     -  r4(3),cref22(3),cref33(3),cref44(3),r234(3,4,32)
      real*8 r234
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),
     -  d02(#LT),d03(#LT),d12(#LT),d13(#LT),
     -  d14(#LT),d23(#LT),d24(#LT),d25(#LT),d34(#LT),d35(#LT),
     -  d36(#LT),d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),d79(#LT)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      common /option/ iop(200),idebug(200)
      real*8 cref1,cref2,cref3,cref4,c0,c1,c5,c6,dst,phirange,dx3,
     -  d12cis,d12trans,d45cis,d45trans,r3fac,r3rad,r3rad2,rx,rx3,rd,
     -  sqd15it,enmin,enmax,en,e1,e2,prevdif,prevdifr,currdif,currdifr,
     -  prevphi,prevphir,sdif,darrdist,darrdists,dsclprd,d01it,d02it,
     -  d46it,d12it,d23it,d34it,d45it,d56it,d13it,d24it,d35it,d15it,phi,
     -  phir,divphi,divphi2,difmin,difminr,phimax,phirmin,r22,r44,rr234
      dimension cref1(3),cref2(3),cref3(3),cref4(3),c0(3),c1(3),c5(3),
     -  c6(3),rx(3),rx3(3),en(3),e1(3),e2(3),rr234(3,4,32),r22(3,2),
     -  r44(3,2),rd(3),prevdif(4),prevdifr(4),currdif(4),currdifr(4),
     -  sdif(4),phirange(2,16),dx3(3)
      character*4 okmark
      data phimax /0.0/,phirmin /0.0/,kmin /0/,kmax /0/
c     Torsions on consecutive bonds
c     Loop closing without the C-M determinant
      nsol=0
      nosoltyp=0
      neval=0
      d15it=darrdists(c(1,i1),c(1,i5))
c     Filter by 1-5 distance
      if (d15it .gt. dflsmax(it) .or. d15it .lt. dflsmin(it)) then
        nosoltyp=1
        if (idebug(74) .gt. 0) then
          write (iout,1015) d15it,dflsmin(it),dflsmax(it)
          inperr=inperr+1
        end if
        if (idebug(79) .gt. 1 .and. idebug(74) .eq. 0)
     -    write (iout,1020) d15it,dflsmin(it),dflsmax(it)
        if (idebug(79) .lt. 3 .or. d15it .ge. dflsmin(it)) return
      end if
      do k=1,3
        c0(k)=c(k,i0)
        c1(k)=c(k,i1)
        cref1(k)=cref(k,i1)
        cref2(k)=cref22(k)
        cref3(k)=cref33(k)
        cref4(k)=cref44(k)
        c5(k)=c(k,i5)
        c6(k)=c(k,i6)
      end do
      d12it=d12(it)
      d23it=d23(it)
      d34it=d34(it)
      d45it=d45(it)
      d56it=d56(it)
      d13it=d13(it)
      d24it=d24(it)
      d35it=d35(it)
      d01it=darrdists(ccm(1,i0),ccm(1,i1))
      d56it=darrdists(ccm(1,i5),ccm(1,i6))
      d02it=bond2(i1)+d12it-2.0*cangle0(i2)*bond(i1)*sqrt(d12it)
      d46it=bond2(i6)+d45it-2.0*cangle0(i6)*bond(i6)*sqrt(d45it)
      if (idebug(65) .gt. 0) then
        d13it=darrdist(cref1,cref3)
        d35it=darrdist(c5,cref3)
      end if
      if (idebug(71) .gt. 0) then
        write (iout,1003) i0,i1,i2,i5,i6
        call loopmemtest(it,1,c0,cref1,cref2,cref3,cref4,c5,c6,c6,c6,c6,
     -    d14max,d24tol/2.0,d24tol/1.33,'reference',ifail,idebug(71),
     -    iout)
      end if
c     Find center of arc of rx3 (on the line from r1 to r5)
      r3fac=0.5d0 +(d13it-d35it)/(2.d0*d15it)
      r3rad2=d13it-r3fac**2*d15it
      if (r3rad2 .lt. 0.d0) then
        nosoltyp=2
        return
      end if
      r3rad=dsqrt(r3rad2)
      sqd15it=dsqrt(d15it)
      enmax=0.0d0
      enmin=10.0d0
      do k=1,3
        rx(k)=c1(k)+r3fac*(c5(k)-c1(k))
        en(k)=(c5(k)-c1(k))/sqd15it
      end do
      if (iop(91) .eq. 1) then
c       Set phi=0 to the direction of cref3
        call darrdiff(rd,cref3,rx,3)
        call dvprd(en,rd,e2)
        dst=dsqrt(e2(1)**2+e2(2)**2+e2(3)**2)
        do k=1,3
          e2(k)=e2(k)/dst
        end do
        call dvprd(e2,en,e1)
      else
c       Just pick a direction
        do k=1,3
          dst=dabs(en(k))
          if (dst .lt. enmin) then
            enmin=dst
            kmin=k
          end if
          if (dst .gt. enmax) then
            enmax=dst
            kmax=k
          end if
          e1(k)=0.d0
        end do
        e1(kmin)=1.0d0/dsqrt(1.0d0+(en(kmin)/en(kmax))**2)
        e1(kmax)=-(en(kmin)/en(kmax))*e1(kmin)
        call dvprd(en,e1,e2)
      end if
      do k=1,3
        e1(k)=e1(k)*r3rad
        e2(k)=e2(k)*r3rad
      end do
      divphi=divr3/r3rad
      if (idebug(89) .gt. 0) then
        write (iout,1008) 0,c0,1,c1,2,cref2,3,cref3,4,cref4,5,c5,6,c6
        write (iout,1009) e1,e2,rx,r3fac,r3rad,divphi*rdtodg,d13it,d35it
        if (idebug(89) .gt. 1) then
          call checkd1_3_5(rx,e1,e2,c1,c5,0.d0,d13it,d35it,iout)
          call checkd1_3_5(rx,e1,e2,c1,c5,dble(PI/2.0),d13it,d35it,iout)
          write (iout,1010) dsclprd(en,e1),dsclprd(en,e1),dsclprd(e1,e2)
          write (iout,1011)
     -       dsqrt(d15it),dsqrt(darrdist(rx,c1))+dsqrt(darrdist(rx,c5))
        end if
      end if
c     Now a point in the arc is e1*cos phi + e2* sin phi
      if (idebug(75) .gt. 0) then
c       Calculate cis/trans extension with actual d01,d02,d56,d46.
c       Not important, as long as dextol > 0
        call d14minmaxct(d13it,d01it,d12it,d02it,d23it,
     -    d12cis,d12trans,dextol)
        call d14minmaxct(d46it,d34it,d45it,d35it,d56it,
     -    d45cis,d45trans,dextol)
        if (idebug(74) .gt. 0) then
          write (iout,1018) 'Actual',d12cis,d12trans,d45cis,d45trans
          write (iout,1018) 'Standr',dscis(it),dstrans(it),dscis(it+2),
     -      dstrans(it+2)
        end if
      else
        d12cis=dscis(it+2)
        d12trans=dstrans(it+2)
        d45cis=dscis(it+5)
        d45trans=dstrans(it+5)
      end if
c     Find the limits of the feasible arcs
      nrange=1
      phirange(1,1)=0.d0
      phirange(2,1)=dpi2
      if (idebug(78) .eq. 0) then
        call darrdiff(dx3,rx,c0,3)
        call findarclims(e1,e2,dx3,r3rad2,d12cis,d12trans,nrange,
     -    phirange,inperr,iout)
        call darrdiff(dx3,rx,c6,3)
        call findarclims(e1,e2,dx3,r3rad2,d45cis,d45trans,nrange,
     -    phirange,inperr,iout)
        if (idebug(89) .gt. 0)
     -    write (iout,1002) ((phirange(k,i),k=1,2),i=1,nrange)
      end if
      nswitch=0
      if (iop(91) .eq. 1) then
c       Search for the nearest solution only
        nosolprev=-1
        nosolprevr=-1
        nosol=0
        nosolr=0
        prevphi=dpi2
        prevphir=0.d0
        iswitch=0
        iswitchr=0
        do ir=1,nrange
          if (phirange(1,ir) .lt. prevphi) then
            prevphi=phirange(1,ir)
            phimax=phirange(2,ir)
          end if
          if (phirange(2,ir) .gt. prevphir) then
            prevphir=phirange(2,ir)
            phirmin=phirange(1,ir)
          end if
        end do
        phi=prevphi
        phir=prevphir
        if (phimax .gt. dpi) phimax=dpi
        if (phirmin .lt. dpi) phirmin=dpi
        call comparestep(phi,prevphi,e1,e2,rx,rx3,c0,c1,c5,
     -    c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,
     -    rr234,difmin,d12cis,d12trans,d45cis,d45trans,r3rad,
     -    prevdif,currdif,sdif,d3tol,d24tol,drevtol,nsol,nosol,
     -    nosolprev,nosoltyp,iswitch,nswitch,neval,iout,idebug(89))
        call comparestep(phir,prevphir,e1,e2,rx,rx3,c0,c1,c5,
     -    c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,
     -    rr234,difminr,d12cis,d12trans,d45cis,d45trans,r3rad,
     -    prevdifr,currdifr,sdif,d3tol,d24tol,drevtol,nsol,nosolr,
     -    nosolprevr,nosoltyp,iswitchr,nswitch,neval,iout,idebug(89))
        do while (nsol .eq. 0 .and.
     -    (phi .lt. phimax .or. phir .gt. phirmin))
          if ((phi .le. dpi2-phir .or. phir .eq. phirmin) .and.
     -         phi .lt. phimax) then
c           Increment phi
            call setdelphi(difmin,0.2d0,0.02d0,divphi,divphi2)
            phi=phi+divphi2
            if (phi .gt. phimax) phi=phimax
            call comparestep(phi,prevphi,e1,e2,rx,rx3,c0,c1,c5,
     -        c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,
     -        rr234,difmin,d12cis,d12trans,d45cis,d45trans,r3rad,
     -        prevdif,currdif,sdif,d3tol,d24tol,drevtol,nsol,nosol,
     -        nosolprev,nosoltyp,iswitch,nswitch,neval,iout,idebug(89))
          else
c           Decrement phir
            call setdelphi(difminr,0.2d0,0.02d0,divphi,divphi2)
            phir=phir-divphi2
            if (phir .lt. phirmin) phir=phirmin
            call comparestep(phir,prevphir,e1,e2,rx,rx3,c0,c1,c5,
     -        c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,
     -        rr234,difminr,d12cis,d12trans,d45cis,d45trans,r3rad,
     -        prevdifr,currdifr,sdif,d3tol,d24tol,drevtol,nsol,nosolr,
     -        nosolprevr,nosoltyp,iswitchr,nswitch,neval,iout,
     -        idebug(89))
          end if
        end do
      else
c       Full enumeration of solutions
c       Grid search
        do irange=1,nrange
          if (idebug(89) .gt. 0)
     -      write (iout,1019) irange,(phirange(k,irange),k=1,2)
          prevphi=phirange(1,irange)
          call validarc(nosolprev,prevphi,e1,e2,rx,rx3,c0,c1,c5,c6,
     -      d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,prevdif,
     -      difmin,d12cis,d12trans,d45cis,d45trans,d3tol,neval,
     -      iout,idebug(89))
          iswitch=0
          phi=prevphi
          do while (phi .lt. phirange(2,irange))
            call setdelphi(difmin,0.2d0,0.02d0,divphi,divphi2)
            phi=prevphi+divphi2
            if (phi .gt. dpi2) phi=dpi2
            call comparestep(phi,prevphi,e1,e2,rx,rx3,c0,c1,c5,c6,
     -        d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,rr234,
     -        difmin,d12cis,d12trans,d45cis,d45trans,r3rad,prevdif,
     -        currdif,sdif,d3tol,d24tol,drevtol,nsol,nosol,nosolprev,
     -        nosoltyp,iswitch,nswitch,neval,iout,idebug(89))
          end do
        end do
      end if
      if (nswitch .eq. 0) nosoltyp=3
      nsolok=0
      isolmin=0
      if (nsol .gt. 0) then
c       Check all solution candidates and select the nearest
        devmax=10000.0
        ifail=0
        do is=1,nsol
          if (idebug(71) .gt. 0)
     -      call loopmemtest(it,1,c0,c1,rr234(1,2,is),rr234(1,3,is),
     -        rr234(1,4,is),c5,c6,c6,c6,c6,d14max,d24tol/2.0,
     -        d24tol/1.33,'solution ',ifail,idebug(71),iout)
          if (idebug(89) .gt. 1)
     -      call checkd1_3_5(rx,e1,e2,c1,c5,phi,d13it,d35it,iout)
          if (ifail .eq. 0) then
            nsolok=nsolok+1
            do k=1,3
              r234(k,4,nsolok)=rr234(k,4,is)
              r234(k,3,nsolok)=rr234(k,3,is)
              r234(k,2,nsolok)=rr234(k,2,is)
            end do
            ds123=darrdist(r234(1,2,nsolok),cref2)+
     -        darrdist(r234(1,3,nsolok),cref3)+
     -        darrdist(r234(1,4,nsolok),cref4)
            if (ds123 .lt. devmax) then
              devmax=ds123
              isolmin=nsolok
            end if
            if (idebug(77) .gt. 0)
     -        write (iout,1004) is,((rr234(k,j,is),k=1,3),j=2,4)
          end if
        end do
        if (nsolok .eq. 0) nosoltyp=4
        if (isolmin .gt. 0) then
          do k=1,3
            r4(k)=r234(k,4,isolmin)
            r3(k)=r234(k,3,isolmin)
            r2(k)=r234(k,2,isolmin)
          end do
          if (isolmin .gt. 1) then
            if (iop(91) .eq. 1) then
              do k=1,3
                r234(k,4,1)=r234(k,4,isolmin)
                r234(k,3,1)=r234(k,3,isolmin)
                r234(k,2,1)=r234(k,2,isolmin)
              end do
            end if
          end if
        end if
      end if
      if (idebug(77) .gt. 0 .and. nsolok .gt. 0) then
        write (iout,1004) 0,r2,r3,r4
        write (iout,1005) cref22,cref33,cref44
      end if
      if (idebug(74) .gt. 0) then
c       Zero torsion for self test
        if (nsolok .gt. 0) then
          dev=arrdist(r2,cref22)+arrdist(r3,cref33)+arrdist(r4,cref44)
          okmark='    '
          if (dev .gt. dijtol) okmark='****'
          write (iout,1012) it,dev,okmark
        else
          write (iout,1017) it
          inperr=inperr+1
          dev=0.0
        end if
        if (dev .gt. dijtol) then
          ds03=darrdist(c0,cref3)
          ds36=darrdist(c6,cref3)
          write (6,1014) '03',ds03,d12cis,d12trans
          write (6,1014) '36',ds36,d45cis,d45trans
        end if
        if (dev .gt. dijtol .or. nsolok .eq. 0) then
          do k=1,3
            rd(k)=c(k,iquata(it,2))
          end do
          t01=rdtodg*dihangld(rd,c0,c1,cref2,0,iout)
          t12=rdtodg*dihangld(c0,c1,cref2,cref3,0,iout)
          t23=rdtodg*dihangld(c1,cref2,cref3,cref4,0,iout)
          t34=rdtodg*dihangld(cref2,cref3,cref4,c5,0,iout)
          t45=rdtodg*dihangld(cref3,cref4,c5,c6,0,iout)
          write (iout,1016) it,t01,t12,t23,t34,t45
        end if
      end if
      nsol=nsolok
      if (nsol .eq. 0 .and. nosoltyp .eq. 0) nosoltyp=8
      return
1002  format(' Valid phi ranges:  ',5(2f10.6))
1003  format(' i0,i1,i2,i5,i6:',5i6)
1004  format(' Sol',i2,' c2=',3f9.4,' c3=',3f9.4,' c4=',3f9.4,a,
     -  ' d12,13=',f6.4,f7.4)
1005  format(' Ref   r2=',3f9.4,' r3=',3f9.4,' r4=',3f9.4,a)
1008  format(' c(',i2,')=',3e12.5)
1009  format(' e1=',3f12.8,' e2=',3f12.8,' rx=',3f12.8,/,
     -  ' r3fac,rad,dr=',3f15.9,' d13it,d35it=',2f15.9)
1010  format(' en.e1=',e12.5,' en.e2=',e12.5,' e1.e2=',e12.5)
1011  format(' d15=',e15.8,' d(1-x)+d(5-x)=',e15.8)
1012  format(' it=',i6,' d(ref-sol)^2=',e12.5,1x,a)
1014  format(' d',a,'=',f12.6,' dcis=',f12.6,' dtrans=',f12.6)
1015  format(' ***** PROGRAM ERROR: invalid d15 filter d15=',f12.6,
     -  ' d15min,max=',2f12.6)
1016  format(' it=',i6,' t01,t12,23,34,45=',5f12.6,' deg')
1017  format(' ***** ERROR: no solution in loopconsec for zero change',
     -  ' for torsion',i6)
1018  format(1x,a,' d12cis,trans=',2f12.6,' d25cis,trans=',2f12.6)
1019  format(' Scanning interval',i3,': [',f8.5,',',f8.5,']')
1020  format(' LOOPCONSEC d15 filter: d15=',f12.6,' d15min,max=',2f12.6)
      end
      subroutine setdelphi(difmin,dlim1,dlim10,div0,div)
c#    MMC routine 161 lstmod: 12/15/00
      real*8 difmin,dlim1,dlim10,div0,div
c*****Decide on the angle change based on the  current difference
      if (difmin .gt. dlim1) then
        div=div0
      else if (difmin .gt. dlim10) then
        div=div0/10.d0
      else
        div=div0/100.d0
      end if
      return
      end
      subroutine comparestep(phi,prevphi,e1,e2,rx,rx3,c0,c1,c5,c6,
     -  d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,rr234,difmin,
     -  d12cis,d12trans,d45cis,d45trans,r3rad,prevdif,currdif,sdif,
     -  d3tol,d24tol,drevtol,nsol,nosol,nosolprev,nosoltyp,iswitch,
     -  nswitch,neval,iout,LEVTEST)
c#    MMC routine 162 lstmod: 01/26/01
      real*8 phi,prevphi,e1,e2,rx,rx3,c0,c1,c5,c6,d02it,d12it,
     -  d23it,d46it,d45it,d34it,d24it,r22,r44,rr234,difmin,d12cis,
     -  d12trans,d45cis,d45trans,r3rad,prevdif,currdif,sdif
      dimension e1(3),e2(3),rx(3),rx3(3),c0(3),c1(3),c5(3),c6(3),
     -  prevdif(4),currdif(4),sdif(4),r22(3,2),r44(3,2),rr234(3,4,32)
c*****Execute the search for one angle increment
      real*8 phip,phio,phim,phis,difm,difo,difp,difo4,darrdist
      dimension difo4(4)
      call validarc(nosol,phi,e1,e2,rx,rx3,c0,c1,c5,c6,
     -  d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,currdif,
     -  difmin,d12cis,d12trans,d45cis,d45trans,d3tol,neval,
     -  iout,LEVTEST)
      phis=0.d0
      if (nosol .eq. 0 .and. nosolprev .gt. 0) then
        if (iswitch .ne. 1) then
          iswitch=1
          call findsolvable(iswitch,phi,prevphi,phis,e1,e2,rx,rx3,
     -      c0,c1,c5,c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,
     -      r22,r44,difmin,d12cis,d12trans,d45cis,d45trans,d3tol,
     -      r3rad,prevdif,currdif,sdif,neval,iout,LEVTEST)
        end if
      else if (nosol .gt. 0 .and. nosolprev .eq. 0) then
        if (iswitch .ne. -1) then
          iswitch=-1
          call findsolvable(iswitch,phi,prevphi,phis,e1,e2,rx,rx3,
     -      c0,c1,c5,c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,
     -      r22,r44,difmin,d12cis,d12trans,d45cis,d45trans,d3tol,
     -      r3rad,prevdif,currdif,sdif,neval,iout,LEVTEST)
        end if
      else
        iswitch=0
        if (nosolprev .eq. -1) then
          prevphi=phis
          call trnsfrd(prevdif,currdif,4)
        end if
      end if
      if (iswitch .ne. 0 .and. phis .ne. 0.d0) then
c       Sign switch was found - use it if final config pair has none
        nsw=0
        do is24=1,4
          if (dsign(1.d0,currdif(is24)) .ne.
     -        dsign(1.d0,prevdif(is24))) nsw=1
        end do
        if (nsw .eq. 0) then
          if (nosol .eq. 0 .and. nosolprev .gt. 0) then
            prevphi=phis
            call trnsfrd(prevdif,sdif,4)
          else if (nosolprev .eq. 0) then
            currphi=phis
            call trnsfrd(currdif,sdif,4)
          end if
        end if
      end if
      if (nosolprev .eq. 2) call trnsfrd(prevdif,currdif,4)
      if (LEVTEST .gt. 0)
     -   write (iout,1006) phi,rx3,currdif,nosolprev,nosol
      if (nosol .eq. 0 .or. iswitch .ne. 0) then
c       Check for sign switch and iterate to solution when switch found
        is24=0
        do iss2=1,2
          do iss4=1,2
            is24=is24+1
            isol2=iss2
            isol4=iss4
            if (dsign(1.d0,prevdif(is24)) .ne.
     -          dsign(1.d0,currdif(is24))) then
c             Sign swith - iterate to the solution
              nswitch=nswitch+1
              phim=prevphi
              phip=phi
              difm=prevdif(is24)
              difp=currdif(is24)
              iter=0
              wm=dabs(difm)/dabs(difm-difp)
              wp=dabs(difp)/dabs(difm-difp)
              if (wm .gt. wp) then
                phio=phim+(phip-phim)*wm*0.8d0
              else
                phio=phip-(phip-phim)*wp*0.8d0
              end if
c             phio=(phim+phip)/2.0d0
              difo=1000.d0
              do while (dabs(phip-phim) .gt. d3tol/r3rad .and.
     -          iter .lt. 100)
                sinphi=dsin(phio)
                cosphi=dcos(phio)
                do k=1,3
                  rx3(k)=rx(k)+cosphi*e1(k)+sinphi*e2(k)
                end do
                call getd24r3(c0,c1,rx3,c5,c6,d02it,d12it,d23it,d46it,
     -            d45it,d34it,d24it,r22,r44,difo4,d3tol,nosoli,
     -            iout,neval,LEVTEST)
                difo=difo4(is24)
                if (LEVTEST .gt. 0) write (iout,1010) iter,
     -            phim,phio,phip,difm,difo,difp,iss2,iss4,nosoli
                if (LEVTEST .gt. 1) write (iout,1013) iter,currdif
                if (nosoli .eq. 1) then
                  nosoltyp=5
                  if (LEVTEST .gt. 0)
     -              write (iout,1003) iss2,iss4
                  call getd24r3(c0,c1,rx3,c5,c6,d02it,d12it,d23it,d46it,
     -              d45it,d34it,d24it,r22,r44,difo4,d3tol,nosoli,
     -              iout,neval,LEVTEST+1)
                  go to 100
                end if
                if (dsign(1.d0,difm) .eq. dsign(1.d0,difo)) then
                  phim=phio
                  difm=difo
                else
                  phip=phio
                  difp=difo
                end if
                iter=iter+1
                phio=(phim+phip)/2.0d0
              end do
              if (iter .le. 100 .and. dabs(difo) .lt. d24tol) then
c               Save solution
                if (nsol .lt. 32) then
                  dev=100000.0
                  if (nsol .gt. 0) dev=
     -              darrdist(rr234(1,2,nsol),r22(1,isol2))+
     -              darrdist(rr234(1,3,nsol),rx3)+
     -              darrdist(rr234(1,4,nsol),r44(1,isol4))
                  if (dev .gt. 3.d0*drevtol) then
                    nsol=nsol+1
                    do k=1,3
                      rr234(k,2,nsol)=r22(k,isol2)
                      rr234(k,3,nsol)=rx3(k)
                      rr234(k,4,nsol)=r44(k,isol4)
                    end do
                  end if
                else
                  nosoltyp=6
                end if
              else
                nosoltyp=7
              end if
            end if
100         prevdif(is24)=currdif(is24)
          end do
        end do
        nosolprev=0
      else
        nosolprev=1
      end if
      prevphi=phi
      nosolprev=nosol
      return
1003  format(' No solution for is2=',i1,' is4=',i1)
1006  format(' phi=',f10.6,' rx3=',3f10.5,' currdif=',4e10.3,
     -  ' nosol,prev=',2i2,1x,a)
1010  format(' iter',i3,' phimop=',3f10.6,' difmop=',3e12.5,
     -  ' is2,4=',2i2,' nos=',i1)
1013  format(' iter',i3,' currd=',4e10.3)
      end
      subroutine findsolvable(iswitch,phi,prevphi,phis,e1,e2,rx,rx3,
     -  c0,c1,c5,c6,d02it,d12it,d23it,d46it,d45it,d34it,d24it,
     -  r22,r44,difmin,d12cis,d12trans,d45cis,d45trans,d3tol,r3rad,
     -  prevdif,currdif,sdif,neval,iout,LEVTEST)
c#    MMC routine 163 lstmod: 12/22/00
      real*8 phi,prevphi,phis,e1,e2,rx,rx3,c0,c1,c5,c6,d02it,d12it,
     -  d23it,d46it,d45it,d34it,d24it,r22,r44,difmin,d12cis,d12trans,
     -  d45cis,d45trans,prevdif,currdif,sdif,r3rad
      dimension e1(3),e2(3),rx(3),rx3(3),c0(3),c1(3),c5(3),c6(3),
     -  r22(3,2),r44(3,2),prevdif(4),currdif(4),sdif(4)
c*****Find the smallest (iswitch=1) or largest (iswitch=-1) solvable prevphi
      real*8 phim,phio,phip,difmini,xdif,xxdif
      dimension xdif(4),xxdif(4)
      character*3 onoff(3)
      character*5 lab
      data lab /'ITER-'/,onoff /'OFF','   ','ON '/
      data xxdif /4*99.0d0/
      phim=prevphi
      phip=phi
      phis=0.d0
      do while (phip-phim .gt. 10.d0*d3tol/r3rad)
        phio=(phim+phip)/2.d0
        call validarc(nosoli,phio,e1,e2,rx,rx3,c0,c1,c5,c6,
     -    d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,
     -    xdif,difmini,d12cis,d12trans,d45cis,d45trans,d3tol,
     -    neval,iout,LEVTEST)
        if (LEVTEST .gt. 0)
     -    write (iout,1006) phio,rx3,xdif,lab,onoff(iswitch+2)
        if (nosoli .eq. 0) then
          difmin=difmini
          nsw=0
          if (iswitch .eq. 1) then
            do is24=1,4
              prevdif(is24)=xdif(is24)
c             Save search if sign change was found
              if (dsign(1.d0,currdif(is24)) .ne.
     -            dsign(1.d0,prevdif(is24))) nsw=1
            end do
            if (nsw .gt. 0) then
              phis=phio
              call trnsfrd(sdif,xdif,4)
            end if
            phip=phio
          else
            do is24=1,4
              currdif(is24)=xdif(is24)
c             Save search if sign change was found
              if (dsign(1.d0,currdif(is24)) .ne.
     -            dsign(1.d0,prevdif(is24))) nsw=1
            end do
            phim=phio
          end if
          if (nsw .gt. 0) then
            phis=phio
            call trnsfrd(sdif,xdif,4)
          end if
        else
          if (iswitch .eq. 1) then
            phim=phio
            call trnsfrd(prevdif,xxdif,4)
          else
            phip=phio
            call trnsfrd(currdif,xxdif,4)
          end if
        end if
      end do
      if (iswitch .eq. 1) then
        prevphi=phip
        if (LEVTEST .gt. 0)
     -    write (iout,1006) prevphi,rx3,prevdif,' ',onoff(iswitch+2)
      else
        phi=phim
        if (LEVTEST .gt. 0)
     -    write (iout,1006) phi,rx3,currdif,' ',onoff(iswitch+2)
      end if
      return
1006  format(' phi=',f10.6,' rx3=',3f10.5,' currdif=',4e10.3,1x,a,a)
      end
      subroutine validarc(nosol,phi,e1,e2,rx,rx3,c0,c1,c5,c6,
     -  d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,r44,dif,difmin,
     -  d12cis,d12trans,d45cis,d45trans,d3tol,neval,iout,LEVTEST)
      real*8 e1,e2,rx,rx3,c0,c1,c5,c6,d12cis,d12trans,d45cis,
     -  d45trans,dst2,d02it,d12it,d23it,d46it,d45it,d34it,d24it,r22,
     -  r44,dif,difmin,sinphi,cosphi,phi
      dimension e1(3),e2(3),rx(3),rx3(3),c0(3),c1(3),c5(3),c6(3),
     -  r22(3,2),r44(3,2),dif(4)
c#    MMC routine 164 lstmod: 11/13/00
c*****Decide if rx3 is a feasible point
      real*8 darrdist
      nosol=2
      difmin=999.d0
      sinphi=dsin(phi)
      cosphi=dcos(phi)
      do k=1,3
        rx3(k)=rx(k)+cosphi*e1(k)+sinphi*e2(k)
      end do
      dst2=darrdist(rx3,c0)
      if (LEVTEST .gt. 1)
     -  write (iout,1000) '12',dst2,'12',d12cis,d12trans
      if (dst2 .gt. d12cis .and. dst2 .lt. d12trans) then
        dst2=darrdist(rx3,c6)
        if (LEVTEST .gt. 1)
     -    write (iout,1000) '36',dst2,'45',d45cis,d45trans
        if (dst2 .gt. d45cis .and. dst2 .lt. d45trans) then
c         Not infeasible angle, check with actual routine
          call getd24r3(c0,c1,rx3,c5,c6,d02it,d12it,d23it,d46it,
     -      d45it,d34it,d24it,r22,r44,dif,d3tol,nosol,iout,neval,
     -      LEVTEST)
          if (nosol .eq. 0) then
            do is24=1,4
              if (dabs(dif(is24)) .lt. difmin) difmin=dabs(dif(is24))
            end do
          end if
        end if
      end if
      return
1000  format(' VALIDARC dst2(',a,')=',f10.5,' d',a,'cis/trans=',2f10.5)
      end
      subroutine findarclims(e1,e2,d03,r32,dcis,dtrans,nrange,
     -  phirange,inperr,iout)
c#    MMC routine 165 lstmod: 11/27/00
c*****Find the limits of feasible arcs
      real*8 e1,e2,d03,r32,dcis,dtrans,phirange,dsclprd
      dimension e1(3),e2(3),d03(3),phirange(2,16)
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      common /option/ iop(200),idebug(200)
      real*8 d03e1,d03e2,d030,phi0,phi1,sinphi0,cosphi0,tanphi0,
     -  phi1c,phi2c,phi1t,phi2t,phic,phit,d20,d21
      d03e1=dsclprd(d03,e1)
      d03e2=dsclprd(d03,e2)
      d030=dsclprd(d03,d03)
      tanphi0=d03e2/d03e1
      phi0=datan(tanphi0)
      phi1=phi0+dpi
      if (phi0 .lt. 0.d0) phi0=phi0+dpi2
      if (phi1 .ge. dpi2) phi1=phi1-dpi2
      sinphi0=dsin(phi0)
      cosphi0=sinphi0/tanphi0
      d20=d030+r32+2.d0*(d03e1*cosphi0+d03e2*sinphi0)
      d21=d030+r32-2.d0*(d03e1*cosphi0+d03e2*sinphi0)
      if (d20 .lt. d21) then
c       phi0 is the angle closest to c on the r3 circle
        phic=phi0
        phit=phi1
      else
c       phi1 is the angle closest to c on the r3 circle
        phic=d20
        d20=d21
        d21=phic
        phic=phi1
        phit=phi0
      end if
      sphic=phic
      sphit=phit
      call cutcircle(d03e1,d03e2,d030,r32,dcis,phi1c,phi2c,nosolc,
     -  inperr,iout)
      call cutcircle(d03e1,d03e2,d030,r32,dtrans,phi1t,phi2t,nosolt,
     -  inperr,iout)
      if (idebug(89) .gt. 1) then
         write (iout,1001)
     -     nosolc,phic,phi1c,phi2c,nosolt,phit,phi1t,phi2t
        call comparedist(phic,d20,e1,e2,d03,iout,'CIS0')
        if (nosolc .eq. 0) then
          call comparedist(phi1c,dcis,e1,e2,d03,iout,'CIS1')
          call comparedist(phi2c,dcis,e1,e2,d03,iout,'CIS2')
        end if
        call comparedist(phit,d21,e1,e2,d03,iout,'TRN0')
        if (nosolt .eq. 0) then
          call comparedist(phi1t,dtrans,e1,e2,d03,iout,'TRN1')
          call comparedist(phi2t,dtrans,e1,e2,d03,iout,'TRN2')
        end if
      end if
      if (nosolc .eq. 0) then
        if (phic .gt. phi1c .and. phic .lt. phi2c) then
          call updaterange(phi1c,phi2c,phirange,nrange)
          if (dabs(phi1c+phi2c-2.d0*phic) .gt. 0.001) then
            write (iout,1000) phic,phi1c,phi2c
            inperr=inperr+1
          end if
        else
          call updaterange(0.d0,phi1c,phirange,nrange)
          call updaterange(phi2c,dpi2,phirange,nrange)
        end if
      end if
      if (nosolt .eq. 0) then
        if (phit .gt. phi1t .and. phit .lt. phi2t) then
          call updaterange(phi1t,phi2t,phirange,nrange)
          if (dabs(phi1t+phi2t-2.d0*phit) .gt. 0.001) then
            write (iout,1000) phit,phi1t,phi2t
            inperr=inperr+1
          end if
        else
          call updaterange(0.d0,phi1t,phirange,nrange)
          call updaterange(phi2t,dpi2,phirange,nrange)
        end if
      end if
      return
1000  format('***** PROGRAM ERROR: phi0=',f10.5,' is not bisecting ',
     -  ' phi1c,phi2c:',2f11.5)
1001  format(' FINDARCLIM nosolc=',i1,' phic=',f9.5,' phi1c,phi2c=',
     -  2f9.5,' nosolt=',i1,' phit=',f9.5,' phi1t,phi2t=',2f9.5)
      end
      subroutine cutcircle(d03e1,d03e2,d030,r32,dist2,phi0,phi1,nosol,
     -  inperr,iout)
c#    MMC routine 166 lstmod: 04/14/004/14/08
c*****Find the angles of radii to the ponts where sphere of radius dist
c     cuts the r3 circle; phi0 <= phi1 and phi* >= 0 is ensured
      real*8 d03e1,d03e2,d030,r32,dist2,phi0,phi1,sinphi0,sinphi1,
     -  aa,bb,delt,disc
      real*8 dpi,dpi2
      common /dnmbrs/ dpi,dpi2
      nosol=1
      aa=d03e2*d03e2+d03e1*d03e1
      delt=dist2-d030-r32
      bb=delt*d03e2
c     cc=delt*delt-4.d0*d03e1*d03e1
c     disc=bb*bb-aa*cc
      disc=4.d0*aa-delt*delt
      if (disc .ge. 0.d0) then
c       disc=dsqrt(disc)
        disc=dsqrt(disc)*d03e1
        nosol=0
        sinphi0=(bb+disc)/(2.d0*aa)
        sinphi1=(bb-disc)/(2.d0*aa)
        phi0=dasincheck(sinphi0,iout,inperr,'CUTCIRCL0')
        if ((aa*(1.d0-sinphi0**2)+delt**2/4.d0-d03e2**2)/(delt*d03e1)
     -      .lt. 0.d0) phi0=dpi-phi0
        if (phi0 .lt. 0.d0) phi0=phi0+dpi2
        phi1=dasincheck(sinphi1,iout,inperr,'CUTCIRCL1')
        if ((aa*(1.d0-sinphi1**2)+delt**2/4.d0-d03e2**2)/(delt*d03e1)
     -      .lt. 0.d0) phi1=dpi-phi1
        if (phi1 .lt. 0.d0) phi1=phi1+dpi2
        if (phi1 .lt. phi0) then
          aa=phi1
          phi1=phi0
          phi0=aa
        end if
      else
        phi0=0.d0
        phi1=0.d0
      end if
      return
      end
      subroutine comparedist(phi,dist2,e1,e2,d03,iout,lab)
c#    MMC routine 167 lstmod: 11/29/00
      real*8 phi,dist2,e1,e2,d03
      character*4 lab
      dimension e1(3),e2(3),d03(3)
      sphi=phi
      dd=0.0
      do k=1,3
        cxk=cos(sphi)*e1(k)+sin(sphi)*e2(k)
        dd=dd+(cxk+d03(k))**2
      end do
      d0=dd-dist2
      write (iout,1020) lab,phi,dist2,dd,d0
      return
1020  format(1x,a,' phi=',f10.5,' dref^2,d^2=',2f12.5,' diff=',e12.5)
      end
      subroutine checkd1_3_5(rx,e1,e2,c1,c5,phi,d13it,d35it,iout)
c#    MMC routine 168 lstmod: 07/03/02
      real*8 darrdist,rx,e1,e2,c1,c5,phi,d13it,d35it,rd,d13,d35
      dimension rx(3),e1(3),e2(3),c1(3),c5(3),rd(3)
      do k=1,3
        rd(k)=e1(k)*dcos(phi)+e2(k)*dsin(phi)+rx(k)
      end do
      d13=darrdist(rd,c1)
      d35=darrdist(rd,c5)
      write (iout,1010) phi,d13-d13it,d35-d35it
      return
1010  format(' phi=',f10.4,' dev13=',e12.5,' dev35=',e12.5)
      end
      subroutine updaterange(phi1,phi2,range,nrange)
c#    MMC routine 169 lstmod: 11/28/00
      real*8 phi1,phi2,range,r1,r2
      dimension range(2,16)
c     Forbid the range [phi1,phi2]
      irange=1
      do while (irange .le. nrange)
        incr=1
        r1=range(1,irange)
        r2=range(2,irange)
        if (phi1 .lt. r2 .and. phi2 .gt. r1) then
c         Overlap found
          if (phi1 .le. r1) then
c           Just shorten lower end
            range(1,irange)=phi2
          else if (phi2 .ge. r2) then
c           Just shorten higher end
            range(2,irange)=phi1
          else if (phi1 .le. r1 .and. phi2 .ge. r2) then
c           Eliminate interval
            do ir=irange+1,nrange
              range(1,ir-1)=range(1,ir)
              range(2,ir-1)=range(2,ir)
            end do
            nrange=nrange-1
            incr=0
          else
c           Split interval in two
            nrange=nrange+1
c           Make room
            do irr=irange+1,nrange
              ir=nrange-irr+irange+1
              range(1,ir)=range(1,ir-1)
              range(2,ir)=range(2,ir-1)
            end do
            range(2,irange)=phi1
            range(1,irange+1)=phi2
            incr=2
          end if
        end if
        irange=irange+incr
      end do
      return
      end
      function acoscheck(arg,iout,lab)
c#    MMC routine 170 lstmod: 12/19/01
c*****Make sure cos is in the [-1,1] range, return acos(arg)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*(*) lab
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      if (arg .lt. -1.0) then
        if (arg .lt. -costol) write (iout,1000) arg,lab,costol
        arg=-1.0
        acoscheck=pi
      else if (arg .gt. 1.0) then
        if (arg .gt. costol) write (iout,1000) arg,lab,costol
        arg=1.0
        acoscheck=0.0
      else
        acoscheck=acos(arg)
      end if
      return
1000  format(' ***** PROGRAM ERROR: invalid cos value:',f10.6,
     -  ' in subroutine ',a,' tolerance:',f5.3)
      end
      function dasincheck(arg,iout,inperr,lab)
c#    MMC routine 171 lstmod: 12/20/01
c*****Make sure sin is in the [-1,1] range, return dasin(arg)
      real*8 arg
      character*(*) lab
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      ifail=0
      if (arg .lt. -1.0d0) then
        if (arg .lt. -dble(costol)) then
          write (iout,1000) arg,lab,costol
          inperr=inperr+1
        end if
        arg=-1.0d0
        dasincheck=dasin(-1.d0)
      else if (arg .gt. 1.0d0) then
        if (arg .gt. dble(costol)) then
          write (iout,1000) arg,lab,costol
          inperr=inperr+1
        end if
        arg=1.0d0
        dasincheck=dasin(1.d0)
      else
        dasincheck=dasin(arg)
      end if
      return
1000  format(' ***** PROGRAM ERROR: invalid sin value:',f10.6,
     -  ' in subroutine ',a,' tolerance:',f5.3)
      end
      function dacoscheck(arg,iout,lab)
c#    MMC routine 172 lstmod: 12/20/01
c*****Make sure cos is in the [-1,1] range, return dacos(arg)
      real*8 arg
      character*(*) lab
      if (arg .lt. -1.0d0) then
        if (arg .lt. -1.01d0) write (iout,1000) arg,lab
        arg=-1.0d0
        dacoscheck=dacos(-1.d0)
      else if (arg .gt. 1.d0) then
        if (arg .gt. 1.01d0) write (iout,1000) arg,lab
        arg=1.0d0
        dacoscheck=0.d0
      else
        dacoscheck=dacos(arg)
      end if
      return
1000  format(' ***** PROGRAM ERROR: invalid sin or cos value:',f10.6,
     -  ' in subroutine ',a)
      end
      subroutine getd24r3(c0,c1,c3,c5,c6,d02it,d12it,d23it,d46it,
     -  d45it,d34it,d24it,r22,r44,currdif,d3tol,nosol,iout,neval,
     -  LEVTEST)
c#    MMC routine 173 lstmod: 02/18/02
c*****Calculate r2-r4 distance from a tentative r3
      real*8 c0,c1,c3,c5,c6,d02it,d12it,d23it,d46it,d45it,d34it,
     -  d24it,r22,r44,rxx,currdif,darrdist
      dimension c0(3),c1(3),c3(3),c5(3),c6(3),
     -  r22(3,2),r44(3,2),rxx(3),currdif(4)
      nosol=1
      call extract3r2(r22,rxx,2,c0,c0,c1,c3,d02it,d12it,d23it,d3tol,
     -  isol2,'r22 ',iout,LEVTEST)
      if (isol2 .ne. 0) then
        call extract3r2(r44,rxx,2,c6,c6,c5,c3,d46it,d45it,d34it,d3tol,
     -    isol4,'r44 ',iout,LEVTEST)
        if (isol4 .ne. 0) then
          is24=0
          do is2=1,2
            do is4=1,2
              is24=is24+1
              currdif(is24)=darrdist(r22(1,is2),r44(1,is4))-d24it
            end do
          end do
          nosol=0
        end if
      end if
      if (nosol .eq. 1) then
        do is24=1,4
          currdif(is24)=99.d0
        end do
      end if
      neval=neval+1
      return
      end
      subroutine extract3r2(r12,rsec,nsol,rref,a,b,c,ra,rb,rc,d3tol,
     -  isol,lab,iout,LEVTEST)
c#    MMC routine 174 lstmod: 03/03/08
c*****Calculate the coordinates of an atom whose distance squares from
c     a,b,c are ra,rb,rc
      real*8 r12,rsec,rref,a,b,c,ra,rb,rc,raa,rbb,rcc,bbx,bby,bbz,ccx,
     -  ccy,ccz,denom,betax,alphax,betay,alphay,aa,bb,cc,disc,dnmx,
     -  root1,root2,deva,devb,devc,ccxyz,bbxyz,denom123,rr,
     -  darrdist
      dimension r12(3,nsol),rsec(3),rref(3),a(3),b(3),c(3),ccxyz(3,3),
     -  bbxyz(3,3),denom123(3),ii123(3,3),rr(3,2)
      character*4 lab
      data ii123 /1,2,3,3,1,2,2,3,1/
      data alphax /0.d0/,betax /0.d0/,alphay /0.d0/,betay /0.d0/
c     If nsol=1, pick the solution closer to rref
      if (LEVTEST .gt. 2) write (iout,1000) lab,ra,a,rb,b,rc,c
c     raa=sclprd(a,a)-ra
c     rbb=sclprd(b,b)-rb
c     rcc=sclprd(c,c)-rc
      raa=a(1)*a(1)+a(2)*a(2)+a(3)*a(3)-ra
      rbb=b(1)*b(1)+b(2)*b(2)+b(3)*b(3)-rb
      rcc=c(1)*c(1)+c(2)*c(2)+c(3)*c(3)-rc
c     x=alphax+betax*z
c     y=alphay/2+betay*z
      dnmx=0.d0
      kopt=1
      do k=1,3
        ccxyz(1,k)=a(ii123(1,k))-c(ii123(1,k))
        ccxyz(2,k)=a(ii123(2,k))-c(ii123(2,k))
        ccxyz(3,k)=a(ii123(3,k))-c(ii123(3,k))
        bbxyz(1,k)=a(ii123(1,k))-b(ii123(1,k))
        bbxyz(2,k)=a(ii123(2,k))-b(ii123(2,k))
        bbxyz(3,k)=a(ii123(3,k))-b(ii123(3,k))
        denom123(k)=ccxyz(1,k)*bbxyz(2,k)-bbxyz(1,k)*ccxyz(2,k)
        if (dabs(denom123(k)) .gt. dnmx) then
          dnmx=dabs(denom123(k))
          kopt=k
        end if
      end do
      bbx=bbxyz(1,kopt)
      bby=bbxyz(2,kopt)
      bbz=bbxyz(3,kopt)
      ccx=ccxyz(1,kopt)
      ccy=ccxyz(2,kopt)
      ccz=ccxyz(3,kopt)
      denom=denom123(kopt)
      i1=ii123(1,kopt)
      i2=ii123(2,kopt)
      i3=ii123(3,kopt)
      if (dabs(denom) .lt. 1.0d-50) then
        disc=-1.0d0
      else
c       x=alphax+betax*z
c       y=alphay/2+betay*z
        betax=(bbz*ccy-ccz*bby)/denom
        alphax=((raa-rcc)*bby-(raa-rbb)*ccy)/denom
        betay=(ccz*bbx-bbz*ccx)/denom
        alphay=((raa-rbb)*ccx-(raa-rcc)*bbx)/denom
c       Substitute back to get a quadratic in z
        aa=betax*betax+betay*betay+1.0d0
        bb=alphax*betax+alphay*betay-
     -    2.0d0*(a(i1)*betax+a(i2)*betay+a(i3))
        cc=0.25d0*(alphax*alphax+alphay*alphay)+raa-
     -    (a(i1)*alphax+a(i2)*alphay)
        disc=bb*bb-4.0d0*aa*cc
      end if
      if (LEVTEST .gt. 3) write (iout,1001) aa,bb,cc,disc,denom
c     if (disc .lt. -d3tol*4.0d0*aa*aa) then
      if (disc .lt. 0.d0) then
        isol=0
        if (LEVTEST .gt. 1) write (iout,1002) lab,disc,denom,aa,d3tol
        if (LEVTEST .gt. 2) then
          rac=dsqrt(darrdist(a,c))
          rab=dsqrt(darrdist(a,b))
          rbc=dsqrt(darrdist(c,b))
          ra0=dsqrt(ra)
          rb0=dsqrt(rb)
          rc0=dsqrt(rc)
          write (iout,1006) 'ac',rac,ra0,rc0,ra0+rc0,ra0+rc0-rac
          write (iout,1006) 'ab',rab,ra0,rb0,ra0+rb0,ra0+rb0-rab
          write (iout,1006) 'bc',rbc,rb0,rc0,rc0+rb0,rc0+rb0-rbc
1006      format(1x,a2,' rij,ri,rj=',3f10.5,' ri+rj=',f10.5,
     -      ' diff=',f10.5)
        end if
        return
c     else if (disc .lt. 0.0d0) then
c       disc=0.0d0
      end if
      root1=(-bb+dsqrt(disc))/(2.0d0*aa)
      root2=(-bb-dsqrt(disc))/(2.0d0*aa)
      if (nsol .gt. 1) then
c       Extract both solutions
        isol=1
        r12(i3,1)=root1
        r12(i3,2)=root2
        r12(i2,1)=betay*r12(i3,1)+alphay*0.5d0
        r12(i2,2)=betay*r12(i3,2)+alphay*0.5d0
        r12(i1,1)=betax*r12(i3,1)+alphax*0.5d0
        r12(i1,2)=betax*r12(i3,2)+alphax*0.5d0
      else
        rr(i3,1)=root1
        rr(i3,2)=root2
        rr(i2,1)=betay*rr(i3,1)+alphay*0.5d0
        rr(i2,2)=betay*rr(i3,2)+alphay*0.5d0
        rr(i1,1)=betax*rr(i3,1)+alphax*0.5d0
        rr(i1,2)=betax*rr(i3,2)+alphax*0.5d0
        if (isol .ge. 0) then
          if (darrdist(rref,rr(1,1)) .le. darrdist(rref,rr(1,2))) then
            call trnsfrd(r12,rr,3)
            isol=-1
          else
            call trnsfrd(r12,rr(1,2),3)
            isol=-2
          end if
        else
          call trnsfrd(r12,rr(1,-isol),3)
        end if
c       Save in rsec the solution not chosen based on the reference atom
        call trnsfrd(rsec,rr(1,3+isol),3)
      end if
      if (LEVTEST .gt. 1) then
        if (nsol .eq. 1)
     -    write (iout,1005) lab,(r12(k,1),k=1,3),rref
        if (nsol .gt. 1)
     -    write (iout,1004) lab,isol,((r12(k,is),k=1,3),is=1,nsol)
c       Substitute back the solution(s)
        if (LEVTEST .gt. 2) then
          do is=1,nsol
            deva=darrdist(a,r12(1,is))-ra
            devb=darrdist(b,r12(1,is))-rb
            devc=darrdist(c,r12(1,is))-rc
            zz=aa*r12(i3,is)**2+bb*r12(i3,is)+cc
            refdev=darrdist(rref,r12(1,is))
            write (iout,1003) lab,is,deva,devb,devc,zz,refdev
          end do
        end if
      end if
      return
1000  format(' EXTRACT3R2 ',a4,': d2a=',e12.5,' ra=',3f9.5,' d2b=',
     -  e12.5,' rb=',3f9.5,/,17x,' d2c=',e12.5,' rc=',3f9.5)
1001  format(11x,' aa,bb,cc=',3e15.8,' disc=',e12.5,' denom=',e12.5)
1002  format(' EXTRACT3R2: No solution for ',a4,' disc=',e12.5,
     -  ' denom=',e12.5,' aa=',e12.5,' d3tol=',e12.5)
1003  format(' EXTRACT3R2: ',a4,' is=',i2,' Subst. errors=',3e10.3,
     -  ' Quadratic error=',e10.3,' Ref. dev=',e10.3)
1004  format(' EXTRACT3R2: ',a4,' isol=',i2,' Solution #1: ',3f10.5,
     -  ' Solution #2:',3f10.5)
1005  format(' EXTRACT3R2: ',a4,' Solution: ',3f10.5,' rref=',3f10.5)
      end
      subroutine d14minmaxct(d24,d12,d23,d13,d34,d14minct,d14maxct,
     -  dextol)
c#    MMC routine 175 lstmod: 11/20/00
c*****Calculate the lowest and highest possible values of d14
c     obtained from the cis/trans conformations
      real*8 d24,d12,d23,d13,d34,d14minct,d14maxct
      real*8 sq12,sq23,sq34,cos123n,cos234n
      sq12=dsqrt(d12)
      sq23=dsqrt(d23)
      sq34=dsqrt(d34)
      cos123n=(d13-d12-d23)/2.d0
      cos234n=(d24-d23-d34)/2.d0
      sin123n=dsqrt(d12*d23-cos123n*cos123n)
      sin234n=dsqrt(d23*d34-cos234n*cos234n)
      d14maxct=((d23+cos234n+cos123n)**2+
     -       (sin123n+sin234n)**2)/d23+dextol
      d14minct=((d23+cos234n+cos123n)**2+
     -       (sin123n-sin234n)**2)/d23-dextol
      return
      end
      subroutine d04maxex(d01,d02,d12,d13,d23,d24,d34,d04min,d04max,
     -  pi,dextol)
c#    MMC routine 176 lstmod: 04/26/02
c*****Calculate the highest possible values of d04 from a fully extended conf.
      real*8 d01,d02,d12,d13,d23,d24,d34,d04min,d04max
      real*8 r(3,5),cosa,cosb,cosc,h,r13(3),r23(3),ex(3),ey0(3),ez0(3),
     -  ey4(3),ez4(4),d0(3),d4(3),sina1,cosa1,sina3,cosa3
      cosa=(d12+d23-d13)/(2.d0*dsqrt(d12*d23))
      cosb=(d12+d13-d23)/(2.d0*dsqrt(d12*d13))
      cosc=(d13+d23-d12)/(2.d0*dsqrt(d13*d23))
      r(1,3)=0.d0
      r(2,3)=0.d0
      r(3,3)=0.d0
      h=sqrt(d23)*dsqrt(1.0-cosc**2)
      r(1,2)=-dsqrt(d12)*cosb
      r(2,2)=h
      r(3,2)=0.d0
      r(1,4)=dsqrt(d23)*cosc
      r(2,4)=h
      r(3,4)=0.d0
      do k=1,3
        r13(k)=r(k,4)-r(k,2)
        r23(k)=r(k,4)-r(k,3)
      end do
      call dvprd(r13,r23,ex)
      call dnorm(ex,3)
      do k=1,3
        ez4(k)=r23(k)
      end do
      call dnorm(ez4,3)
      call dvprd(ez4,ex,ey4)
      cosa3=-(d23+d34-d24)/(2.d0*dsqrt(d23*d34))
      do k=1,3
        d4(k)=r(k,4)+ez4(k)*dsqrt(d34)*cosa3
      end do
      do k=1,3
        ez0(k)=r(k,2)-r(k,3)
      end do
      call dnorm(ez0,3)
      call dvprd(ex,ez0,ey0)
      cosa1=-(d01+d12-d02)/(2.d0*dsqrt(d01*d12))
      do k=1,3
        d0(k)=r(k,2)+ez0(k)*dsqrt(d01)*cosa1
      end do
      sina1=dsqrt(1.d0-cosa1**2)
      sina3=dsqrt(1.d0-cosa3**2)
      call d04_gridsearch(pi,pi,pi,pi,1,r(1,1),r(1,5),div0,div4,d0,d4,
     -  ex,ey0,ey4,d01,d34,sina1,sina3,dih0min,dih4min,d04minmin)
      d04min=d04minmin-dextol
      ngrid=20
      call d04_gridsearch(0.0,pi,-pi,0.0,ngrid,r(1,1),r(1,5),div0,div4,
     -  d0,d4,ex,ey0,ey4,d01,d34,sina1,sina3,dih0max,dih4max,d04maxmax)
      ngrid=ngrid-1
      dih0l=amax1(dih0max-div0,0.0)
      dih0h=amin1(dih0max+div0,pi)
      dih4l=amax1(dih4max-div4,-pi)
      dih4h=amin1(dih4max+div4,0.0)
      call d04_gridsearch(dih0l,dih0h,dih4l,dih4h,ngrid,
     -  r(1,1),r(1,5),div0,div4,d0,d4,ex,ey0,ey4,d01,d34,
     -  sina1,sina3,dih0max,dih4max,d04maxmax)
      d04max=d04maxmax+dextol
      return
      end
      subroutine d04_gridsearch(dih01,dih02,dih41,dih42,ngrid,r1,r5,
     -  div0,div4,d0,d4,ex,ey0,ey4,d01,d34,sina1,sina3,dih0max,dih4max,
     -  d04maxmax)
c#    MMC routine 176/a lstmod: 04/26/02
c*****Search the torsion angles creating non-planarity for maximum d04
      real*8 r1(3),r5(3),d01,d34,sina1,sina3,
     -  d0(3),d4(3),ex(3),ey0(3),ey4(3)
      real*8 dih0,dih4
      d04maxmax=0.0
      dih0max=0.0
      dih4max=0.0
      if (ngrid .eq. 1) then
        div0=0.0
        div4=0.0
      else
        div0=(dih02-dih01)/(ngrid-1)
        div4=(dih42-dih41)/(ngrid-1)
      end if
      do i0=1,ngrid
        do i4=1,ngrid
          dih0=dih01+(i0-1)*div0
          dih4=dih41+(i4-1)*div4
          do k=1,3
            r1(k)=d0(k)+dsqrt(d01)*sina1*
     -        (ex(k)*dsin(dih0)+ey0(k)*dcos(dih0))
            r5(k)=d4(k)+dsqrt(d34)*sina3*
     -        (ex(k)*dsin(dih4)+ey4(k)*dcos(dih4))
          end do
          d04max=0.d0
          do k=1,3
            d04max=d04max+(r1(k)-r5(k))**2
          end do
          if (d04maxmax .lt. d04max) then
            d04maxmax=d04max
            dih0max=dih0
            dih4max=dih4
          end if
        end do
      end do
      return
      end
c      subroutine d04maxex(d01,d02,d12,d13,d23,d24,d34,d04min,d04max,
c     -  dextol)
cc#    MMC routine 176 lstmod: 01/08/01
cc*****Calculate the highest possible values of d04 from a fully extended conf.
c      real*8 d01,d02,d12,d13,d23,d24,d34,d04min,d04max,sq0212,
c     -  sq1223,sq2324,cosa,sina,cosb,sinb,cosc,sinc
c      sq0212=dsqrt(d02*d12)
c      sq1223=dsqrt(d12*d23)
c      sq2324=dsqrt(d23*d24)
c      cosa=(d02+d12-d01)/(2.0d0*sq0212)
c      sina=dsqrt(1.0d0-(d02+d12-d01)**2/(4.0d0*d02*d12))
c      cosb=(d12+d23-d13)/(2.0d0*sq1223)
c      sinb=dsqrt(1.0d0-(d12+d23-d13)**2/(4.0d0*d12*d23))
c      cosc=(d23+d24-d34)/(2.0d0*sq2324)
c      sinc=dsqrt(1.0d0-(d23+d24-d34)**2/(4.0d0*d23*d24))
c      d04min=-dextol+d02+d24-2.0d0*dsqrt(d02*d24)*
c     -  ((cosa*cosc-sina*sinc)*cosb+(sina*cosc+cosa*sinc)*sinb)
c      d04max=dextol+d02+d24-2.0d0*dsqrt(d02*d24)*
c     -  ((cosa*cosb-sina*sinb)*cosc-(sina*cosb+cosa*sinb)*sinc)
c      return
c      end
      subroutine d16maxex(d12,d23,d34,d45,d56,d13,d24,d35,d46,
     -  d16min,d16max,dextol)
c#    MMC routine 177 lstmod: 01/02/04
c*****Calculate the highest and lowest possible values of d16
c     from all cis and all trans conformations. resp.
      real*8 d12,d23,d34,d45,d56,d13,d24,d35,d46,d16min,d16max
      real*8 a132,a136,a436,a234,a345,a346,a546,d36,acoslaw,dcoslaw
      a132=acoslaw(d23,d13,d12)
      a546=acoslaw(d46,d45,d56)
      a345=acoslaw(d34,d45,d35)
      a346=a345-a546
      d36=dcoslaw(d34,d46,a346)
      a436=acoslaw(d36,d34,d46)
      a234=acoslaw(d23,d34,d24)
      a136=a234-a132-a436
      d16min=dcoslaw(d13,d36,a136)-dextol
      a346=a345+a546
      d36=dcoslaw(d34,d46,a346)
      a436=acoslaw(d34,d36,d46)
      a136=a132+a234+a436
      d16max=dcoslaw(d13,d36,a136)+dextol
      return
      end
      subroutine dxymaxex(d12,d23,d34,d45,d13,d24,d35,c1,c2,c3,c4,c5,
     -  dxymin,dxymax,dextol,it,looptyp,iout,nwarn,inperr)
c#    MMC routine 178 lstmod: 04/11/04
c*****Calculate the highest and lowest possible values of the distance scanned
c     from all cis and all trans conformations. resp.
      real*8 d12,d23,d34,d45,d13,d24,d35,dxymin,dxymax
      dimension c1(3),c2(3),c3(3),c4(3),c5(5)
      real*8 a135,a135p,a132,a234,a435,acoslaw,dcoslaw
      if (looptyp .eq. 4) then
        call d14minmaxct(d35,d23,d34,d24,d45,dxymin,dxymax,dextol)
      else if (looptyp .eq. 9) then
        call d14minmaxct(d24,d12,d23,d13,d34,dxymin,dxymax,dextol)
      else
        a132=acoslaw(d23,d13,d12)
        a234=acoslaw(d23,d34,d24)
        a435=acoslaw(d34,d35,d45)
        a135p=a132+a234+a435
        dxymax=dcoslaw(d13,d35,a135p)+dextol
        if (looptyp .eq. 5 .or. looptyp .eq. 8) then
          a135=a234-a132-a435
          dxymin=dcoslaw(d13,d35,a135)
        else
          if (looptyp .eq. 6) then
            call d15limminmax(d34,d45,d35,c1,c2,c3,c4,dxymin,dxymax)
          else
            call d15limminmax(d23,d12,d13,c5,c4,c3,c2,dxymin,dxymax)
          end if
          d15=arrdist(c1,c5)
          sdxymin=dxymin
          sdxymax=dxymax
          dd=amax1(sdxymin-d15,d15-sdxymax)
          if (dd .gt. dextol) then
            write (iout,1000) '***** ERROR',
     -        sqrt(d15),sqrt(sdxymin),sqrt(sdxymax),it,looptyp,
     -        ' tolerance=',dextol
            inperr=inperr+1
          else if (dd .gt. 0.0) then
            write (iout,1000) '----- WARNING',
     -        sqrt(d15),sqrt(sdxymin),sqrt(sdxymax),it,looptyp
            nwarn=nwarn+1
          end if
        end if
      end if
      dxymin=dxymin-dextol
      return
1000  format(1x,a,': current 1-5 distance (',f10.5,') is out of the ',
     -  'range found ([',f10.5,',',f10.5,']) it=',i5,' looptyp=',i2,
     -  a,f6.4)
      end
      subroutine d15limminmax(d34,d45,d35,c1,c2,c3,c4,dxymin,dxymax)
c#    MMC routine 179 lstmod: 04/12/04
c*****Calculate the highest and lowest possible values of the distance scanned
      real*8 d34,d45,d35,dxymin,dxymax,dcosphi
      dimension c1(3),c2(3),c3(3),c4(3)
      dimension ex(3),ey(3),ez(3),c50(5),dd(3)
      call arrdiff(ez,c4,c3,3)
      call anorm(ez,3)
      dcosphi=(d35-d34-d45)/(2.d0*dsqrt(d34*d45))
      do k=1,3
        c50(k)=c4(k)+ez(k)*dsqrt(d45)*dcosphi
      end do
      call arrdiff(ey,c2,c4,3)
      call vprd(ey,ez,ex)
      call anorm(ex,3)
      call vprd(ez,ex,ey)
      r50=dsqrt(d45)*dsqrt(1.0d0-dcosphi**2)
      do k=1,3
        dd(k)=(c50(k)-c1(k))/r50
      end do
      dx=sclprd(dd,ex)
      dy=sclprd(dd,ey)
      call arrdiff(c50,c50,c1,3)
      do k=1,3
        ex(k)=ex(k)*r50
        ey(k)=ey(k)*r50
      end do
      if (abs(dx) .lt. 0.001) then
c       phi= 0 or pi
        dxy1=arrdist(c50,ey)
        call arrdiff(c50,c50,ey,3)
        dxy2=sclprd(c50,c50)
      else if (abs(dy) .lt. 0.001) then
c       phi= pi/2 or 3*pi/2
        dxy1=arrdist(c50,ex)
        call arrdiff(c50,c50,ex,3)
        dxy2=sclprd(c50,c50)
      else
        cosphi=dy/sqrt(dx**2+dy**2)
        sinphi=cosphi* (dx/dy)
        dxy1=0.0
        dxy2=0.0
        do k=1,3
          dxy1=dxy1+(c50(k)+ex(k)*sinphi+ey(k)*cosphi)**2
          dxy2=dxy2+(c50(k)-ex(k)*sinphi-ey(k)*cosphi)**2
        end do
      end if
      if (dxy1 .lt. dxy2) then
        dxymin=dxy1
        dxymax=dxy2
      else
        dxymin=dxy2
        dxymax=dxy1
      end if
      return
      end
      function acoslaw(a,b,c)
c#    MMC routine 180 lstmod: 12/26/03
      real*8 a,b,c,acoslaw
c*****Returns the angle of the triangle with side squares a,b,c (opposite c)
      acoslaw=dacos((a+b-c)/(2.0d0*dsqrt(a*b)))
      return
      end
      function dcoslaw(a,b,ang)
c#    MMC routine 181 lstmod: 12/26/03
      real*8 a,b,ang,dcoslaw
c*****Returns the side of the triangle with sides a,b ang angle ang inbetween
      dcoslaw=a+b-2.0d0*dsqrt(a*b)*dcos(ang)
      return
      end
      subroutine loopmemtest(it,looptyp,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,
     -  d14max,d12tol,d13tol,source,ifail,LEVTEST,iout)
c#    MMC routine 182 lstmod: 07/01/04
c*****Full check on the interatomic distances for the loop atoms
      real*8 c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,darrdist
      dimension c0(3),c1(3),c2(3),c3(3),c4(3),c5(3),c6(3),c7(3),c8(3),
     -  c9(3)
      character*(*) source
      common /dijdiff/ n12diff(20),n13diff(20)
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),d02(#LT),
     -  d03(#LT),d12(#LT),d13(#LT),d14(#LT),d23(#LT),
     -  d24(#LT),d25(#LT),d34(#LT),d35(#LT),d36(#LT),
     -  d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),
     -  d79(#LT)
      character*4 label(2)
      data label /'    ','****'/
      ltyp=looptyp
      if (ltyp .gt. 20) ltyp=ltyp-20
      d14tol=d12tol*2.0
      ifail12=0
      ifail13=0
      ifail14=0
      dev12=dabs(d12(it)-darrdist(c1,c2))/dsqrt(d12(it))
      dev23=dabs(d23(it)-darrdist(c2,c3))/dsqrt(d12(it))
      dev34=dabs(d34(it)-darrdist(c3,c4))/dsqrt(d12(it))
      dev45=dabs(d45(it)-darrdist(c4,c5))/dsqrt(d12(it))
      d12max=amax1(dev12,dev23,dev34,dev45)/2.0
      if (ltyp .eq. 1) then
        dev56=dabs(d56(it)-darrdist(c5,c6))/(2.d0*dsqrt(d56(it)))
        d12max=amax1(d12max,dev56)
      else if (ltyp .eq. 2 .or. ltyp .eq. 3) then
        dev56=dabs(d56(it)-darrdist(c5,c6))/(2.d0*dsqrt(d56(it)))
        dev67=dabs(d67(it)-darrdist(c6,c7))/(2.d0*dsqrt(d67(it)))
        dev78=dabs(d78(it)-darrdist(c7,c8))/(2.d0*dsqrt(d78(it)))
        d12max=amax1(d12max,dev56,dev67,dev78)
      else if (ltyp .gt. 4) then
        dev56=dabs(d56(it)-darrdist(c5,c6))/(2.d0*dsqrt(d56(it)))
        d12max=amax1(d12max,dev56)
      else
        dev56=0.0
      end if
      if (d12max .gt. d12tol) then
         ifail12=1
         ix=d12max/d12tol
         ix=min0(20,ix)
         n12diff(ix)=n12diff(ix)+1
      end if
      dev02=0.0
      if (ltyp .le. 2)
     -  dev02=dabs(d02(it)-darrdist(c0,c2))/(2.d0*dsqrt(d02(it)))
      dev13=dabs(d13(it)-darrdist(c1,c3))/dsqrt(d13(it))
      dev24=dabs(d24(it)-darrdist(c2,c4))/dsqrt(d24(it))
      dev35=dabs(d35(it)-darrdist(c3,c5))/dsqrt(d35(it))
      dev46=dabs(d46(it)-darrdist(c4,c6))/dsqrt(d46(it))
      d13max=amax1(dev02,dev13,dev24,dev35,dev46)/2.0
      if (ltyp .gt. 1) then
        dev57=dabs(d57(it)-darrdist(c5,c7))/(2.0*dsqrt(d57(it)))
        d13max=amax1(d13max,dev57)
        if (ltyp .eq. 2 .or. ltyp .eq. 3) then
          dev68=dabs(d68(it)-darrdist(c6,c8))/(2.d0*dsqrt(d68(it)))
          dev79=dabs(d79(it)-darrdist(c7,c9))/(2.d0*dsqrt(d79(it)))
          d13max=amax1(d13max,dev68,dev79)
        end if
      end if
      if (d13max .gt. d13tol) then
         ifail13=1
         ix=d13max/d13tol
         ix=min0(20,ix)
         n13diff(ix)=n13diff(ix)+1
      end if
      d14max=0.0
      if (ltyp .eq. 2) then
        dev03=dabs(d03(it)-darrdist(c0,c3))/dsqrt(d03(it))
        dev36=dabs(d36(it)-darrdist(c3,c6))/dsqrt(d36(it))
        dev69=dabs(d69(it)-darrdist(c6,c9))/dsqrt(d69(it))
        d14max=amax1(dev03,dev36,dev69)/2.0
      else if (ltyp .eq. 3) then
        dev25=dabs(d25(it)-darrdist(c2,c5))/dsqrt(d25(it))
        dev58=dabs(d58(it)-darrdist(c5,c8))/dsqrt(d58(it))
        d14max=amax1(dev25,dev58)/2.0
      else if (ltyp .gt. 3) then
        dev69=0.0
        if (ltyp .eq. 5) then
          dev69=dabs(d03(it)-darrdist(c0,c3))/(2.d0*dsqrt(d03(it)))
          if (dev69 .gt. d14tol .and. LEVTEST .gt. 2) write (iout,1012)
     -      dev69,d03(it),c0,c3
        else if (ltyp .eq. 6) then
          dev69=dabs(d14(it)-darrdist(c1,c4))/(2.d0*dsqrt(d14(it)))
          if (dev69 .gt. d14tol .and. LEVTEST .gt. 2) write (iout,1012)
     -      dev69,d03(it),c1,c4
        else if (ltyp .eq. 7) then
          dev69=dabs(d25(it)-darrdist(c2,c5))/(2.d0*dsqrt(d25(it)))
          if (dev69 .gt. d14tol .and. LEVTEST .gt. 2) write (iout,1012)
     -      dev69,d03(it),c2,c5
        else if (ltyp .eq. 8) then
          dev69=dabs(d36(it)-darrdist(c3,c6))/(2.d0*dsqrt(d36(it)))
          if (dev69 .gt. d14tol .and. LEVTEST .gt. 2) write (iout,1012)
     -      dev69,d03(it),c3,c6
        else if (ltyp .eq. 9) then
          dev69=dabs(d47(it)-darrdist(c4,c7))/(2.d0*dsqrt(d47(it)))
          if (dev69 .gt. d14tol .and. LEVTEST .gt. 2) write (iout,1012)
     -      dev69,d03(it),c7,c7
        end if
        d14max=dev69
      end if
      if (d14max .gt. d14tol) ifail14=1
      ifail=ifail12+ifail13+ifail14
      if (ifail .gt. 0) write (iout,1000) it,looptyp,source,'FAILED',
     -  d12max,d13max,d14max,d12tol,d13tol,d14tol
      if (ifail .gt. 0 .or. LEVTEST .gt. 0) then
        if (ifail .eq. 0) write (iout,1000) it,looptyp,source,'passed',
     -  d12max,d13max,d14max,d12tol,d13tol,d14tol
        if (looptyp .eq. 1) then
          write (iout,1001) it,dev12,dev23,dev34,dev45,
     -      label(ifail12+1)
          write (iout,1002) it,dev02,dev13,dev24,dev35,dev46,
     -      label(ifail13+1)
        else if (looptyp .eq. 2 .or. looptyp .eq. 3) then
          write (iout,1003) it,dev12,dev23,dev34,dev45,dev56,dev67,
     -      dev78,label(ifail12+1)
          write (iout,1004) it,dev02,dev13,dev24,dev35,dev46,dev57,
     -      dev68,dev79,label(ifail13+1)
          if (looptyp .eq. 2) write (iout,1005) it,dev03,dev36,dev69,
     -      label(ifail14+1)
          if (looptyp .eq. 3) write (iout,1006) it,dev25,dev58,
     -      label(ifail14+1)
        else
          write (iout,1009) it,dev12,dev23,dev34,dev45,dev56,
     -      label(ifail12+1)
          write (iout,1010) it,dev02,dev13,dev24,dev35,dev46,dev57,
     -      label(ifail13+1)
          write (iout,1011) it,dev69,label(ifail14+1)
        end if
      end if
      if (LEVTEST .gt. 1) then
        write (iout,1007) c0,c1,c2,c3,c4,c5
        if (looptyp .gt. 1 .and. looptyp .lt. 4) then
          write (iout,1008) c6,c7,' ',c8,c9
        else if (looptyp .gt. 3) then
          write (iout,1008) c6,c7
        end if
      end if
      return
1000  format(' it',i5,' lt',i2,' LOOPMEMTEST on ',a,' atoms ',a,', ',
     -  'd12,d13,d14max=',e7.1,2e8.1,' d12,13,14tol=',e8.2,2e9.2)
1001  format(' it',i5,' d12-c: dev12,23,34,45=',4e10.3,1x,a4)
1002  format(' it',i5,' d13-c: dev02,13,24,35,56=',5e10.3,1x,a4)
1003  format(' it',i5,' d12-c: dev12,23,34,45,56,67,78=',7e10.3,1x,a4)
1004  format(' it',i5,' d13-c: dev02,13,24,35,56,57,68,79=',8e10.3,
     -  1x,a4)
1005  format(' it',i5,' d14-c: dev03,36,69=',3e9.2,1x,a4)
1006  format(' it',i5,' d14-c: dev25,58=',2e9.2,1x,a4)
1007  format(' c0=',3f8.4,' c1=',3f8.4,' c2=',3f8.4,' c3=',3f8.4,/,
     -  ' c4=',3f8.4,' c5=',3f8.4)
1008  format(' c6=',3f8.4,' c7=',3f8.4,a,'c8=',3f8.4,' c9=',3f8.4)
1009  format(' it',i5,' d12-c: dev12,23,34,45,56=',5e10.3,1x,a4)
1010  format(' it',i5,' d13-c: dev02,13,24,35,46,57=',6e10.3,1x,a4)
1011  format(' it',i5,' d14-c: dev69=',e9.2,1x,a4)
1012  format(' dev69=',f5.3,' dxy(it)=',f10.5,' ca=',3f9.4,' cb=',3f9.4)
      end
      subroutine jacobian(r0,r1,r2,r3,r4,r5,r6,detjac,iout,nsng,LEVTEST)
c#    MMC routine 183 lstmod: 03/03/08
c     Calculate the Jacobian for the volume element of a loop move
      dimension r0(3),r1(3),r2(3),r3(3),r4(3),r5(3),r6(3)
      dimension ajc(6,5),u(3,6),r5i(3,4),vp(3)
      data imax /0/
      do k=1,3
        r5i(k,1)=r5(k)-r1(k)
        r5i(k,2)=r5(k)-r2(k)
        r5i(k,3)=r5(k)-r3(k)
        r5i(k,4)=r5(k)-r4(k)
        u(k,1)=r1(k)-r0(k)
        u(k,2)=r2(k)-r1(k)
        u(k,3)=r3(k)-r2(k)
        u(k,4)=r4(k)-r3(k)
        u(k,5)=r5(k)-r4(k)
        u(k,6)=r6(k)-r5(k)
      end do
      do i=1,6
        us=0.d0
        do k=1,3
          us=us+u(k,i)**2
        end do
        us=sqrt(us)
        do k=1,3
          u(k,i)=u(k,i)/us
        end do
      end do
      do i=1,4
        call vprd(u(1,i),r5i(1,i),vp)
        do k=1,3
          ajc(k,i)=vp(k)
        end do
      end do
      do i=1,5
        call vprd(u(1,i),u(1,6),vp)
        do k=1,3
         ajc(k+3,i)=vp(k)
        end do
      end do
      do k=1,3
       ajc(k,5)=0.0
      end do
      s44=0.0
      s55=0.0
      s66=0.0
      s45=0.0
      s46=0.0
      s56=0.0
      do j=1,5
        s44=s44+ajc(4,j)*ajc(4,j)
        s55=s55+ajc(5,j)*ajc(5,j)
        s66=s66+ajc(6,j)*ajc(6,j)
        s45=s45+ajc(4,j)*ajc(5,j)
        s56=s56+ajc(5,j)*ajc(6,j)
        s46=s46+ajc(4,j)*ajc(6,j)
      end do
      s45=abs(s45)/(s44*s55)
      s46=abs(s46)/(s44*s66)
      s56=abs(s56)/(s55*s66)
      if (s46 .le. s45 .and. s46 .le. s56) then
c       Angle between rows 4 and 6 is closest to perpendicular
c       Replace row 5 by row 6
        do i=1,5
          ajc(5,i)=ajc(6,i)
        end do
      else if (s56 .le. s45 .and. s56 .le. s46) then
c       Angle between rows 5 and 6 is closest to perpendicular
c       Replace row 4 by row 6
        do i=1,5
          ajc(4,i)=ajc(6,i)
        end do
      end if
      if (LEVTEST .gt. 0)
     -   write (iout,1000) 'Original',((ajc(i,j),j=1,5),i=1,5)
c     Now calculate the determinant
      do i=1,4
c       Find the largest element in row i
        ajcmax=0.0
        do ii=i,5
          if (abs(ajc(i,ii)) .gt. ajcmax) then
            ajcmax=abs(ajc(i,ii))
            imax=ii
          end if
        end do
        if (imax .ne. i) then
          do j=i,5
            x=ajc(j,i)
            ajc(j,i)=ajc(j,imax)
            ajc(j,imax)=x
          end do
        end if
        if (ajc(i,i) .ne. 0.0) then
          do ii=i+1,5
c           Eliminate the matrix element (ii,i)
            pivotfac=ajc(ii,i)/ajc(i,i)
            do j=i,5
              ajc(ii,j)=ajc(ii,j)-ajc(i,j)*pivotfac
            end do
          end do
        end if
      end do
      if (LEVTEST .gt. 0)
     -   write (iout,1000) 'Row-reduced',((ajc(i,j),j=1,5),i=1,5)
      detjac=ajc(1,1)
      do i=2,5
        detjac=detjac*ajc(i,i)
      end do
      if (detjac .ne. 0.0) then
        detjac=1.0/abs(detjac)
        if (LEVTEST .gt. 0) write (iout,*) '1/|Determinant|=',detjac
      else
        detjac=1.0
        if (LEVTEST .gt. 0) write (iout,*) 'singular'
        nsng=nsng+1
      end if
      return
1000  format(1x,a,' Jacobian:',/,(5f10.5))
      end
      subroutine deploysp(iout)
c#    MMC routine 184 lstmod: 04/19/05
c*****Generate the special sampling move(s)
      write (iout,*) '***** ERROR: Special sampling is not implemented'
      call datprt(2)
      end
      subroutine lincmb(c,crmslt,cplpar,irest,qslt,nslt0)
c#    MMC routine 185 lstmod: 03/16/99
c*****Prepare the l.c. of r1*& + r0*(1-&) into the last third of c and
c     Combine charges and LJ coefficients if needed
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      dimension c(3,#ST),crmslt(3),qslt(#ST),crm2new(3),
     -  eulernew(3)
      nslt1=2*nslt0
      cplpr1=1.0-cplpar
      if (irest .eq. 0) then
        if (iop(18) .le. 2) then
c         Combine the coordinates of the atoms
          do k=1,3
            do i=1,nslt0
              c(k,nslt1+i)=cplpar*c(k,nslt0+i)+cplpr1*c(k,i)
            end do
          end do
        else if (iop(18) .eq. 3) then
c         Translate and rotate second part
          do k=1,3
            crm2new(k)=crmslt(k)+cplpar*crm2nd1(k)+cplpr1*crm2nd0(k)
          end do
c         Combine Euler angles, generate rotation matrix
          eulernew(1)=cplpar*euler2nd(1)
          eulernew(3)=cplpar*euler2nd(3)
c!!
          eulernew(2)=acoscheck(1.0+abs(cplpar)*eulercos2,iout,'LINCMB')
          if (euler2nd(2)*cplpar .lt. 0.0) eulernew(2)=-eulernew(2)
          call eulertorot(ort2nd,eulernew(1),eulernew(2),eulernew(3))
          call rot_trans(ort2nd,rlcsec,crm2new,c(1,nslt1+1),nslt0)
        else if (iop(18) .eq. 4) then
c         Combine torsion angles
          do it=1,ntorpmf
            dihang(it)=dih0(it)+cplpar*deldih(it)
          end do
          call gentor(iftmovtg(1),iltmovtg(1),dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -      bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -      #TR,#ST)
        else
c         Combine center of mass only
          do k=1,3
            crmpmf0(k)=cplpar*crm2nd1(k)+cplpr1*crm2nd0(k)
          end do
          if (idebug(55) .gt. 0)
     -      write (iout,1000) cplpar,crm2nd0,crm2nd1,crmpmf0
        end if
      end if
      if (iop(38) .gt. 0) then
c       Combine the charges
        do i=1,nslt0
          qslt(nslt1+i)=cplpar*qslt(nslt0+i)+cplpr1*qslt(i)
        end do
        if (iop(26) .ne. 4) then
c         Water solvent
          do j=1,2
            do i=1,nslt0
              qji(nslt1+i,j)=cplpar*qji(nslt0+i,j)+cplpr1*qji(i,j)
            end do
          end do
          if (iop(38) .eq. 2) then
c           Combine the LJ coefficients
            do j=1,lclen
              do i=1,nslt0
                c6ji(nslt1+i,j)=cplpar*c6ji(nslt0+i,j)+
     -            cplpr1*c6ji(i,j)
                c12ji(nslt1+i,j)=cplpar*c12ji(nslt0+i,j)+
     -            cplpr1*c12ji(i,j)
              end do
            end do
          end if
        else
c         General 1-6-12 solvent
          do j=1,nslv
            do i=1,nslt0
              qtv(nslt1+i,j)=cplpar*qtv(nslt0+i,j)+cplpr1*qtv(i,j)
            end do
          end do
          if (iop(38) .eq. 2) then
c           Combine the LJ coefficients
            do j=1,nslv
              do i=1,nslt0
                c6tv(nslt1+i,j)=cplpar*c6tv(nslt0+i,j)+
     -            cplpr1*c6tv(i,j)
                c12tv(nslt1+i,j)=cplpar*c12tv(nslt0+i,j)+
     -            cplpr1*c12tv(i,j)
              end do
            end do
          end if
        end if
      end if
      return
1000  format(' LINCMB lambda=',f7.4,' crm2nd0=',3f9.4,
     -  ' crm2nd1=',3f9.4,' crmpmf0=',3f9.4)
      end
      subroutine trnsor(ori,orj,iaxis,phi,rot)
c#    MMC routine 186 lstmod: 04/05/13
c*****Obtain the new rot matrix orj from rotating around iaxis by phi
c     ori: old rotation matrix
      dimension ori(3,3),orj(3,3),rot(3,3)
      csp=cos(phi)
      snp=sin(phi)
      if (iaxis .eq. 1) then
        i1=2
        i2=3
        i3=1
      else if (iaxis .eq. 2) then
        i1=3
        i2=1
        i3=2
      else
        i1=1
        i2=2
        i3=3
      end if
c     rot: rotation matrix of the change
      call zeroit(rot,9)
      rot(i1,i1)=csp
      rot(i1,i2)=-snp
      rot(i2,i1)=snp
      rot(i2,i2)=csp
      rot(i3,i3)=1.0
c     orj: rotation matrix transforming the local water to the actual
      call matprod(rot,ori,orj)
      call vprod(orj,1,2,3)
      call vprod(orj,3,1,2)
      call mnorm(orj,ifail)
      return
      end
      subroutine hcp_trnsor(ori,orj,iaxis,phi,iopt)
c#    MMC routine 186/a lstmod: 06/01/07
c*****Obtain the new rot matrix orj from rotating around iaxis by phi
c     followed by an HCP rotation as needed
c     ori: old rotation matrix
      common /hcp_rotmat/ hcprot_p(3,3),hcprot_m(3,3),ishift_pm(19)
      dimension rot(3,3),ori(3,3),orj(3,3)
      dimension orx(3,3)
      csp=cos(phi)
      snp=sin(phi)
      if (iaxis .eq. 1) then
        i1=2
        i2=3
        i3=1
      else if (iaxis .eq. 2) then
        i1=3
        i2=1
        i3=2
      else
        i1=1
        i2=2
        i3=3
      end if
      call zeroit(rot,9)
c     rot: rotation matrix of the change
      rot(i1,i1)=csp
      rot(i1,i2)=-snp
      rot(i2,i1)=snp
      rot(i2,i2)=csp
      rot(i3,i3)=1.0
      if (ishift_pm(iopt) .eq. 1) then
        call matprod(ori,hcprot_p,orj)
        call trnsfr(orx,orj,9)
        call matprod(rot,orx,orj)
      else if (ishift_pm(iopt) .eq. -1) then
        call matprod(ori,hcprot_m,orj)
        call trnsfr(orx,orj,9)
        call matprod(rot,orx,orj)
      else
        call matprod(rot,ori,orj)
      end if
c     orj: rotation matrix transforming the local water to the actual
      call vprod(orj,1,2,3)
      call vprod(orj,3,1,2)
      call mnorm(orj,ifail)
      return
      end
      subroutine hcp_rot_trans(crm,c,ctrans,ifst,ilst,cic,iopt,ishftcrm)
c#    MMC routine 186/p lstmod: 06/01/07
c*****Transform a whole molecule for HCP cell move
      dimension crm(3),c(3,ilst),ctrans(3,ilst),cic(3)
      common /hcp_rotmat/ hcprot_p(3,3),hcprot_m(3,3),ishift_pm(19)
      dimension crmtrans(3)
      if (ishift_pm(iopt) .eq. 0) then
c       Just normal shift
        do ia=ifst,ilst
          ctrans(1,ia)=c(1,ia)+cic(1)
          ctrans(2,ia)=c(2,ia)+cic(2)
          ctrans(3,ia)=c(3,ia)+cic(3)
        end do
      else
        if (ishftcrm .gt. 0) then
          crmtrans(1)=crm(1)+cic(1)
          crmtrans(2)=crm(2)+cic(2)
          crmtrans(3)=crm(3)+cic(3)
          call hcp_rotate(crmtrans(1),crmtrans(2),iopt)
        else
          call trnsfr(crmtrans,crm,3)
        end if
        n=ilst-ifst+1
        if (ishift_pm(iopt) .eq. 1) then
c         Shift and +60 deg rotation
          call rot_trans(hcprot_p,c(1,ifst),crm,ctrans(1,ifst),n)
        else if (ishift_pm(iopt) .eq. -1) then
c         Shift and -60 deg rotation
          call rot_trans(hcprot_m,c(1,ifst),crm,ctrans(1,ifst),n)
        end if
      end if
      return
      end
      subroutine rot_trans(rot,cloc,com,clab,natm)
c#    MMC routine 187 lstmod: 06/01/04
c*****Perform the transformation of the coordinates from local to lab frame
c*****followed by a transation to com
c     clab and cloc can be the same array.
      dimension rot(3,3),cloc(3,natm),com(3),clab(3,natm)
      cm1=com(1)
      cm2=com(2)
      cm3=com(3)
      do i=1,natm
        cl1=cloc(1,i)
        cl2=cloc(2,i)
        cl3=cloc(3,i)
        clab(1,i)=rot(1,1)*cl1+rot(1,2)*cl2+rot(1,3)*cl3+cm1
        clab(2,i)=rot(2,1)*cl1+rot(2,2)*cl2+rot(2,3)*cl3+cm2
        clab(3,i)=rot(3,1)*cl1+rot(3,2)*cl2+rot(3,3)*cl3+cm3
      end do
      return
      end
      subroutine trans_rot(rot,cloc,com,clab,natm,rsign,norot)
c#    MMC routine 188 lstmod: 01/04/13
c*****Perform the transformation of the coordinates from local to lab frame
c*****preceded by a transation to com
c     clab and cloc can be the same array.
      dimension rot(3,3),cloc(3,natm),com(3),clab(3,natm)
      cm1=rsign*com(1)
      cm2=rsign*com(2)
      cm3=rsign*com(3)
      if (norot .eq. 0) then
        do i=1,natm
          c1=cloc(1,i)+cm1
          c2=cloc(2,i)+cm2
          c3=cloc(3,i)+cm3
          clab(1,i)=rot(1,1)*c1+rot(1,2)*c2+rot(1,3)*c3
          clab(2,i)=rot(2,1)*c1+rot(2,2)*c2+rot(2,3)*c3
          clab(3,i)=rot(3,1)*c1+rot(3,2)*c2+rot(3,3)*c3
        end do
      else
        do i=1,natm
          clab(1,i)=cloc(1,i)+cm1
          clab(2,i)=cloc(2,i)+cm2
          clab(3,i)=cloc(3,i)+cm3
        end do
      end if
      return
      end
      subroutine pbc_shift(c,iaf,ial,cic,iopt,ioppbc,crm)
c#    MMC routine 188/a lstmod: 01/22/09
c*****Perform the shift to reset to the PBC cell the atoms in c
      dimension c(3,ial),cic(3),crm(3)
      if (ioppbc .ne. 2) then
        do k=1,3
          crm(k)=crm(k)+cic(k)
          do ia=iaf,ial
            c(k,ia)=c(k,ia)+cic(k)
          end do
        end do
      else
c       HCP - add 60 degree rotation
        call hcp_rot_trans(crm,c,c,iaf,ial,cic,iopt,0)
      end if
      return
      end
      subroutine biasfc(bfct)
c#    MMC routine 189 lstmod: 04/17/00
c*****Compute the biasing factor for the force-bias
      real*8 bfct
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      common /fblam/ wfblam(#PG),rfblam(9),afblam(9),nfblam
      real*8 cisod,frcito,trqito
      common /dptobs/ frcito(3),trqito(3),cisod,beta2l,iop6,kminis
      real*8 frcitn,trqitn,frctco,frctcn,cdf,cisnd,caf,frctch
      dimension frcitn(3),trqitn(3)
      if (iop6 .le. 4) return
c     Truncate forces, torques, if necessary
      do k=1,3
        frcitn(k)=frci(k)
        trqitn(k)=trqi(k)
      end do
      kut0=kut
      if (notrans .eq. 0) call ftcut(frcitn,frcmax,kut)
      if (norot .eq. 0) call ftcut(trqitn,trqmax,kut)
      if (kut .gt. kut0) return
      cisnd=1.0
      if (iop6 .eq. 5) then
c       Force-biased of P.R.B. no scaling
        frctch=0.0
        if (notrans .eq. 0) then
          do k=kminis,3
            frctch=frctch+(frcito(k)+frcitn(k))*(ch(k)-cd(k))
            cdf=cdbt2*frcitn(k)
            cisnd=cisnd*beta4*frcitn(k)/dsinh(cdf)
          end do
        end if
        if (norot .eq. 0) then
          frctch=frctch+(trqito(iaxis)+trqitn(iaxis))*phi
          caf=rabt2*trqitn(iaxis)
          cisnd=cisnd*beta4*trqitn(iaxis)/dsinh(caf)
        end if
        bfct=bfct*dexp(-beta2*frctch)*(cisnd/cisod)
      else
c       Force biased with scaling (MM)
        beta2o=beta2l
        frctco=0.0
        frctcn=0.0
        rlamfc=prfwgt(nis(1),wfblam,0)
        beta2l=beta2*rlamfc
        beta4l=beta4*rlamfc
        if (notrans .eq. 0) then
          cdbt2l=cdbt2*rlamfc
          do k=kminis,3
            frctco=frctco+frcito(k)*(ch(k)-cd(k))
            frctcn=frctcn+frcitn(k)*(ch(k)-cd(k))
            cdf=cdbt2l*frcitn(k)
            cisnd=cisnd*beta4l*frcitn(k)/dsinh(cdf)
          end do
        end if
        if (norot .eq. 0) then
          rabt2l=rabt2*rlamfc
          frctco=frctco+trqito(iaxis)*phi
          frctcn=frctcn+trqitn(iaxis)*phi
          caf=rabt2l*trqitn(iaxis)
          cisnd=cisnd*beta4l*trqitn(iaxis)/dsinh(caf)
        end if
        bfct=bfct*dexp(-beta2l*frctcn-beta2o*frctco)*(cisnd/cisod)
      end if
      return
      end
      subroutine ftcut(ft,ftmax,kut)
c#    MMC routine 190 lstmod: 08/31/86
c*****Truncate the force/torque components to avoid overflow, etc
      real*8 ft
      dimension ft(3)
      do k=1,3
        ftk=ft(k)
        if (abs(ftk) .gt. ftmax) then
          kut=kut+1
          if (ft(k) .lt. 0.d0) ft(k)=-ftmax
          if (ft(k) .gt. 0.d0) ft(k)=ftmax
        else if (ft(k) .eq. 0.d0) then
          ft(k)=1.0d-5
        end if
      end do
      return
      end
      function engslt(jjj,riijj,riijj0,rijps0,isprox,idistmv,idistid,
     -  c,crm,crm1)
c#    MMC routine 191 lstmod: 12/24/12
      dimension c(3,#NA),crm(3),crm1(3)
c*****Calls solute-solvent energy functions, takes care of COM distances.
      common /ecell/ cic(3,27),ncell
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /isoeng/ dimax,dijs,dijq,dijso,dijqo,eniemx,eniemo
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /dstsv/ ignorehs,r2stsv(#ST)
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind2/ crat6,crat1
      common /frind3/ eone(3,#MO),etwo(3,#MO),eonen(3,#MO),
     -  etwon(3,#MO)
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
C@DM      real*8 engxslt_in(4),engxslt_out(4),fcjslv_out(3,#SV)
      dimension rij2gr(#GR),z(3),crmslt(3),riijjpx(3)
C@FR      dimension rsxslv(3,#SV),fjxyzo(3),vircacc(3)
C@FRC@TS      dimension trixyz2(3)
      real*8 engsum,engsum2
C@DB      dimension DEBUG(#GR)
      data estg1 /0.0/,engie /0.0/
C@FR      do i=1,nsvtmx
C@FR        do k=1,3
C@FR          fcjslv(k,i)=0.0
C@FR        end do
C@FR      end do
C@FRC@TS      call zeroit(fcslt,nstta3)
C@FR      do k=1,3
C@FR        virc(k)=0.0
C@FR        trixyz(k)=0.0
C@FR        trjxyz(k)=0.0
C@FR        frjxyz(k)=0.0
C@FR      end do
      engslt=0.d0
      engsum=0.d0
      engsum2=0.d0
      xslt12=0.0
      xslt6=0.0
      xslt1=0.0
      if (iop(43) .eq. 0) then
        call trnsfr(crmslt,crm1,3)
      else
        call trnsfr(crmslt,crmpmf,3)
      end if
      riijj=0.0
c-----No FE or Widom calc
      if (iop(30) .gt. 3) then
        if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
c---------TI or pertubation method calc
c         e01stn(1,is), e01stn(2,is): pair energy of solvent is with 1st and 2nd
c         part of the solute after the perturbation
          uend1=0.d0
          uend2=0.d0
C@FR          call zeroit(vircacc,3)
C@FR          call zeroit(fjxyzo,3)
C@FR          call zeroit(rsxslv,3*nslv)
          do ivx=1,3
            etwon(ivx,jjj)=0.d0
            eonen(ivx,jjj)=0.d0
          end do
          do ig=npfgr(1)+1,npfgr(2)
            if (noppti(ig) .eq. 0) then
              crat1=crat10
              crat6=crat60
              cplfac=cpl0tix(1)
              cplpti12=cpl0tix(1)
              cplpti6=cpl0tix(2)
              cplpti1=cpl0tix(3)
            else
              crat1=1.0
              crat6=1.0
              cplfac=cplpar
              cplpti12=cplpar
              cplpti6=cplpar
              cplpti1=cplpar
            end if
C@FR            call zeroit(frjxyz,3)
C@FR            call zeroit(fcjslv,3*nstsvgr(ig))
C@FR            call zeroit(virc,3)
            estg2=eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),ilpfgr(ig),
     -        nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),1,ioppbc,
     -        iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
            if (noppti(ig) .eq. 2) then
c             Group is identical in the two copies - calculate only once
              indexx(ig-npfgr(1))=ioppbc
C@FR              do i=1,nstsvgr(ig)
C@FR                do k=1,3
C@FR                  rsxslv(k,i)=rsxslv(k,i)+fcjslv(k,i)
C@FR                end do
C@FR              end do
C@FR              do k=1,3
C@FR                fjxyzo(k)=fjxyzo(k)+frjxyz(k)
C@FR              end do
              do i=ifpfgr(ig),ilpfgr(ig)
                r2stsv(ifpfgr(ig-npfgr(1))+i-ifpfgr(ig))=r2stsv(i)
              end do
C@FRC@TS              do i=ifpfgr(ig),ilpfgr(ig)
C@FRC@TS                i0=ifpfgr(ig)-ifpfgr(ig-npfgr(1))
C@FRC@TS                do k=1,3
C@FRC@TS                  fciki=fcslt(k,i)
C@FRC@TS                  fcslt(k,i)=fciki*cplpar
C@FRC@TS                  fcslt(k,i-i0)=fciki*cplpar1
C@FRC@TS                end do
C@FRC@TS              end do
C@FR              do k=1,3
C@FR                vircacc(k)=vircacc(k)+virc(k)
C@FR              end do
              uend1=uend1+uitot
              uend2=uend2+uitot
c             Since the contributions cancel in the TI integrand, don't
c             even bother to accumulate eonen and etwon
c             The factors cplpar and cplpar1 sum up to 1, so they can be omitted
              xslt12=xslt12+uind12
              xslt6=xslt6+uind6
              xslt1=xslt1+uind1
              estgr(ig)=estg2*cplpar
              estgr(ig-npfgr(1))=estg2*cplpar1
              engsum=engsum+estgr(ig-npfgr(1))
              engsum2=engsum2+estgr(ig)
              rij2gr(ig)=riijj
              rij2gr(ig-npfgr(1))=riijj
            else
              if (cplpr0 .gt. cplpr1) indexx(ig-npfgr(1))=ipfgr(ig)
              estgr(ig)=estg2*cplfac
C@FR              do i=1,nstsvgr(ig)
C@FR                do k=1,3
C@FR                  rsxslv(k,i)=rsxslv(k,i)+fcjslv(k,i)*cplfac
C@FR                end do
C@FR              end do
C@FR              do k=1,3
C@FR                fjxyzo(k)=fjxyzo(k)+frjxyz(k)*cplfac
C@FR              end do
C@FRC@TS              do i=ifpfgr(ig),ilpfgr(ig)
C@FRC@TS                do k=1,3
C@FRC@TS                  fcslt(k,i)=fcslt(k,i)*cplfac
C@FRC@TS              end do
C@FRC@TS            end do
C@FR              do k=1,3
C@FR                vircacc(k)=vircacc(k)+virc(k)*cplfac
C@FR              end do
              uend2=uend2+uitot
              if (noppti(ig) .eq. 0) then
                etwon(1,jjj)=etwon(1,jjj)+uind12
                etwon(2,jjj)=etwon(2,jjj)+uind6
                etwon(3,jjj)=etwon(3,jjj)+uind1
              else
c               Since the exponent is changed, multiply with a factor to obtain
c               the correct value when the TI integrand is computed
                etwon(1,jjj)=etwon(1,jjj)+uind12/tifactwo(1)
                etwon(2,jjj)=etwon(2,jjj)+uind6/tifactwo(2)
                etwon(3,jjj)=etwon(3,jjj)+uind1/tifactwo(3)
              end if
              xslt12=xslt12+uind12*cplpti12
              xslt6=xslt6+uind6*cplpti6
              xslt1=xslt1+uind1*cplpti1
              rij2gr(ig)=riijj
              engsum2=engsum2+estgr(ig)
            end if
          end do
C@DB            write (iout,4423) jjj,crat1,crat6,(ig,estgr(ig),
C@DB     -        ig=npfgr(1)+1,npfgr(2))
C@DB4423        format(' ENGSLT jjj=',i3,' crat1,6=',2f6.4,4(' ig=',i2,
C@DB     -        i' estgr=',e12.5))
          do ig=1,npfgr(1)
            if (noppti(ig) .lt. 2) then
              if (noppti(ig) .eq. 0) then
                crat1=crat11
                crat6=crat61
                cplfac=cpl1tix(1)
                cplpti12=cpl1tix(1)
                cplpti6=cpl1tix(2)
                cplpti1=cpl1tix(3)
              else
                crat1=1.0
                crat6=1.0
                cplfac=cplpar1
                cplpti12=cplpar1
                cplpti6=cplpar1
                cplpti1=cplpar1
              end if
C@FR              call zeroit(frjxyz,3)
C@FR              call zeroit(fcjslv,3*nstsvgr(ig))
C@FR              call zeroit(virc,3)
              estg1=eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),
     -          ilpfgr(ig),nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),1,
     -          ioppbc0,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
     -          *cplfac
C@FR              do i=1,nstsvgr(ig)
C@FR                do k=1,3
C@FR                  rsxslv(k,i)=rsxslv(k,i)+fcjslv(k,i)*cplfac
C@FR                end do
C@FR              end do
C@FR              do k=1,3
C@FR                fjxyzo(k)=fjxyzo(k)+frjxyz(k)*cplfac
C@FR              end do
C@FRC@TS              do i=ifpfgr(ig),ilpfgr(ig)
C@FRC@TS                do k=1,3
C@FRC@TS                  fcslt(k,i)=fcslt(k,i)*cplfac
C@FRC@TS                end do
C@FRC@TS              end do
C@FR              do k=1,3
C@FR                vircacc(k)=vircacc(k)+virc(k)*cplfac
C@FR              end do
              uend1=uend1+uitot
              if (noppti(ig) .eq. 0) then
                eonen(1,jjj)=eonen(1,jjj)+uind12
                eonen(2,jjj)=eonen(2,jjj)+uind6
                eonen(3,jjj)=eonen(3,jjj)+uind1
              else
c               Since the exponent is changed, multiply with a factor to obtain
c               the correct value when the TI integrand is computed
                eonen(1,jjj)=eonen(1,jjj)+uind12/tifacone(1)
                eonen(2,jjj)=eonen(2,jjj)+uind6/tifacone(2)
                eonen(3,jjj)=eonen(3,jjj)+uind1/tifacone(3)
              end if
              xslt12=xslt12+uind12*cplpti12
              xslt6=xslt6+uind6*cplpti6
              xslt1=xslt1+uind1*cplpti1
              engsum=engsum+estg1
              rij2gr(ig)=riijj
C@DB              DEBUG(ig)=estg1
            end if
            if (cplpr0 .le. cplpr1) indexx(ig)=ioppbc0
            estgr(ig)=estgr(ig)+estg1
          end do
C@DB          write (6,4424) jjj,crat1,crat6,(ig,DEBUG(ig),
C@DB     -      ig=1,npfgr(1))
C@DB4424      format(' ENGSLT jjj=',i3,' crat1,6=',2f6.4,4(' ig=',i2,
C@DB     -      ' esg=',e12.5))
C@FR          call trnsfr(fcjslv,rsxslv,3*nslv)
C@FR          call trnsfr(frjxyz,fjxyzo,3)
C@FR          call trnsfr(virc,vircacc,3)
          e01stn(1,jjj)=uend1
          e01stn(2,jjj)=uend2
          engsum=engsum2+engsum
          engslt=engsum
        else if (iop(30) .eq. 7) then
c---------Variable solute
          crat1=1.0
          crat6=1.0
          if (iop(7) .eq. 2) then
c           Iso-energy cutoff
c           Cutoff should be based on the same images
            call arrdiff(c,crm,crmpmf,3)
            call pbcnd(z(1),z(2),z(3),iop(5),ioppbc,rij2)
            rs1=0.0
            rs2=0.0
            do k=1,3
              cjjjk=crm(k)+cic(k,ioppbc)
              rs1=rs1+(cjjjk-c(k,icent1))**2
              rs2=rs2+(cjjjk-c(k,icent2))**2
            end do
            if (rs2 .lt. rs1) then
              rsxx=rs1
              rs1=rs2
              rs2=rsxx
            end if
            rq1=rs1*rs1
            rq2=rs2*rs2
            ct12n=(dijs-rs1-rs2)
            r12=sqrt(rs1*rs2)
            qq=(dijq+(rs1-rs2)**2-2.0*dijs*(rs1+rs2))/
     -         (4.0*rs1*rs2*(rq1+rq2+r12*ct12n))
            ct1s=1.0+rq1*qq
            ct2s=1.0+rq2*qq
            if (ct1s .lt. 0.0) then
              if (-ct1s .gt. 1.e-4)
     -          write (iout,*) 'Negative sqrt in engslt=',ct1s
              ct1s=0.0
            end if
            ct1=sqrt(ct1s)
            if (ct2s .lt. 0.0) then
              if (-ct2s .gt. 1.e-4)
     -          write (iout,*) 'Negative sqrt in engslt=',ct2s
              ct2s=0.0
            end if
            ct2=sqrt(ct2s)
            isig2=1
            if (ct1 .gt. 1.0) ct1=1.0
            ct12=-ct12n/(2.0*r12)
            if (ct12 .lt. -1.0) ct12=-1.0
            if (ct12 .gt. +1.0) ct12=+1.0
            if (acoscheck(ct1,iout,'ENGSLT')+
     -          acoscheck(ct12,iout,'ENGSLT') .lt. pi/2.0) isig2=-1
            engie=ct1/rs1+isig2*ct2/rs2
            if (engie .lt. eniemx) then
              do ig=5,6
                estgr(ig)=0.0
c               Calculate the group-based distances
                call arrdiff(z,crm,c(1,molcnt(ig)),3)
                call pbcnd(z(1),z(2),z(3),iop(5),iopt,rij2gr(ig))
                if (rij2gr(ig) .lt. dijmin) dijmin=rij2gr(ig)
              end do
              go to 9000
            end if
          end if
c         Group center set to zero to force using crmpmf
          do ig=npfgr(2)+1,npfgr(3)
            estgr(ig)=eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),
     -        ilpfgr(ig),nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),
     -        ig-npfgr(2),ioppbc,iop(43),c,crm,ctslts,
     -        edgex2,edgey2,edge2)
            rij2gr(ig)=riijj
            engsum=engsum+estgr(ig)
            xslt12=xslt12+uind12
            xslt6=xslt6+uind6
            xslt1=xslt1+uind1
            indexx(ig-npfgr(2))=ioppbc
          end do
          engslt=engsum
        else
c---------Overlap ratio and perturbation a la Jorgensen
          uend1=0.d0
          uend2=0.d0
C@FR          call zeroit(vircacc,3)
C@FR          call zeroit(fjxyzo,3)
C@FR          call zeroit(rsxslv,3*nslv)
          do ivx=1,3
            etwon(ivx,jjj)=0.d0
            eonen(ivx,jjj)=0.d0
          end do
          crat1=1.
          crat6=1.
          do igg=1,npfgr(1)
            ig=npfgr(1)+igg
            uend2=uend2+
     -        eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),ilpfgr(ig),
     -        nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),1,ioppbc2,
     -        iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
            etwon(1,jjj)=etwon(1,jjj)+uind12
            etwon(2,jjj)=etwon(2,jjj)+uind6
            etwon(3,jjj)=etwon(3,jjj)+uind1
            ig=igg
            uend1=uend1+
     -        eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),ilpfgr(ig),
     -        nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),2,ioppbc2,
     -        iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
            eonen(1,jjj)=eonen(1,jjj)+uind12
            eonen(2,jjj)=eonen(2,jjj)+uind6
            eonen(3,jjj)=eonen(3,jjj)+uind1
C@FRc           Zero out forces again
C@FR            do i=1,nsvtmx
C@FR              do k=1,3
C@FR                fcjslv(k,i)=0.0
C@FR              end do
C@FR            end do
C@FRC@TS            call zeroit(fcslt,nstta3)
C@FR            do k=1,3
C@FR              virc(k)=0.0
C@FR              frjxyz(k)=0.0
C@FR            end do
            ig=npfgr(2)+igg
            engsum=engsum+
     -        eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),ilpfgr(ig),
     -        nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),2,ioppbc,
     -        iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
            xslt12=xslt12+uind12
            xslt6=xslt6+uind6
            xslt1=xslt1+uind1
            indexx(igg)=ioppbc
            rij2gr(ig)=riijj
          end do
          e01stn(1,jjj)=uend1
          e01stn(2,jjj)=uend2
          engslt=engsum
        end if
      end if
9000  if (npfgr(4) .gt. npfgr(3)) then
c-------Non-FE (part of the) solute
        crat1=1.
        crat6=1.
C@DM        if (iop(21) .lt. 3) then
          do ig=npfgr(3)+1,npfgr(4)
            estgr(ig)=eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),
     -        ilpfgr(ig),nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),ig,
     -        ioppbc,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
            rij2gr(ig)=riijj
            engsum=engsum+estgr(ig)
            xslt12=xslt12+uind12
            xslt6=xslt6+uind6
            xslt1=xslt1+uind1
            indexx(ig)=ioppbc
          end do
          engslt=engsum
C@DM        else
C@DMc         MPI calculation
C@DM          do igx=iflsltg(1,MYRANK+1),iflsltg(2,MYRANK+1)
C@DM            ig=mixupslt(igx)
C@DM            estgr(ig)=eslt(jjj,riijj,iop(2),ipfgr(ig),ifpfgr(ig),
C@DM     -        ilpfgr(ig),nstsvgr(ig),nslvggr(ig),crmslt,igrcnt(ig),ig,
C@DM     -        ioppbc,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
C@DM            rij2gr(ig)=riijj
C@DM            engsum=engsum+estgr(ig)
C@DM            xslt12=xslt12+uind12
C@DM            xslt6=xslt6+uind6
C@DM            xslt1=xslt1+uind1
C@DM            indexx(ig)=ioppbc
C@DM          end do
C@DM        end if
C@DMc       Sum up across processors
C@DM        engxslt_in(1)=xslt12
C@DM        engxslt_in(2)=xslt6
C@DM        engxslt_in(3)=xslt1
C@DM        engxslt_in(4)=engsum
C@DM        call MPI_Allreduce(engxslt_in,engxslt_out,4,
C@DM     -    MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DM        xslt12=engxslt_out(1)
C@DM        xslt6=engxslt_out(2)
C@DM        xslt1=engxslt_out(3)
C@DM        engslt=engxslt_out(4)
C@DM        call MPI_Allreduce(fcjslv,fcjslv_out,3*nsvtmx,
C@DM     -    MPI_REAL,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DM        call trnsfr(fcjslv,fcjslv_out,3*nsvtmx)
C@DM        call MPI_Allreduce(frjxyz,fcjslv_out,3,
C@DM     -    MPI_REAL,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DM        call trnsfr(frjxyz,fcjslv_out,3)
      end if
C@FRc     Force antisymmetry on the forces
C@FR      do k=1,3
C@FR        frixyz(k)=-frjxyz(k)
C@FR      end do
C@FRc     Calculate torques (Do it always -
C@FRc     unless ig loop above keeps track if there was any contribution)
C@FRC@TS      nstdone=nslttl(1)
C@FRC@TS      call torque(c,crm,fcslt,nslttf(1),nslttl(1),trixyz,1)
C@FRC@TS      if (ntorcop .gt. 1) then
C@FRC@TS        nstdone=nslttl(2)
C@FRC@TS        call torque(c,crm,fcslt,nslttf(2),nslttl(2),trixyz2,1)
C@FRC@TS        call arrsum(trixyz,trixyz,trixyz2,3)
C@FRC@TS      end if
C@FRC@TS      if (nstdone .lt. nstta) then
C@FRC@TS        call torque(c,crm,fcslt,nstdone+1,nstta,trixyz2,1)
C@FRC@TS        call arrsum(trixyz,trixyz,trixyz2,3)
C@FRC@TS      end if
C@FR      call torque(c(1,ic01+jjj*nslv),crm,fcjslv,1,nsvtmx,
C@FR     -  trjxyz,jjj)
c     Save in riijjpx potentially all the four types of distances since they
c     may be needed for the different types of preferential samplings.
      riijjpx(1)=riijj
      if (iop(43) .eq. 0 .and. iop(30) .le. 3) then
        rij2gr(1)=riijj
c       riijj0 is the 'true' COM-COM slt-slv distance square
        riijj0=riijj
      else
c       Find the slt-slv COM distance
        call arrdiff(z,crm1,crm,3)
        call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj0)
c       Find the smallest group distance
        riijj=1.e+5
C@DM        if (iop(21) .ne. 3) then
          do ig=nsltgru,nsttg
            if (riijj .gt. rij2gr(ig)) riijj=rij2gr(ig)
          end do
C@DM        else
C@DM          do igx=iflsltg(1,MYRANK+1),iflsltg(2,MYRANK+1)
C@DM            ig=mixupslt(igx)
C@DM            if (riijj .gt. rij2gr(ig)) riijj=rij2gr(ig)
C@DM          end do
C@DM        end if
C@DMc       Get the lowest value on all cpu's
C@DM        call MPI_Allreduce(riijj,riijjmin,1,
C@DM     -    MPI_REAL,MPI_MIN,MPI_COMM_WORLD,iostat1)
C@DM        riijj=riijjmin
      end if
      if (iop(22) .gt. 0) then
c       Use keeppx for selection
        riijj=1.e+5
C@DM        if (iop(21) .ne. 3) then
        do ia=1,nstta
          if (keeppx(ia) .gt. 0) then
            if (r2stsv(ia) .lt. riijj) then
              riijj=r2stsv(ia)
              isprox=ia
            end if
          end if
        end do
C@DM        else
C@DM          do igx=iflsltg(1,MYRANK+1),iflsltg(2,MYRANK+1)
C@DM            ig=mixupslt(igx)
C@DM            do ia=ifgrslt(ig),ilgrslt(ig)
C@DM              if (keeppx(ia) .gt. 0) then
C@DM                if (r2stsv(ia) .lt. riijj) then
C@DM                  riijj=r2stsv(ia)
C@DM                  isprox=ia
C@DM                end if
C@DM              end if
C@DM            end do
C@DM          end do
C@DM        end if
      else if (iop(17) .eq. 1 .or. iop(8) .eq. 1 .or. iop(92) .gt. 0
     -  .or. iop(6) .eq. 6 .or. iop(42) .eq. 2 .or.
     -  (iop(30) .ge. 1 .and. iop(30) .le. 3)) then
c       Put into riijj the distance from the nearest slt heavy atom
C@DM        if (iop(21) .ne. 3) then
          do j=nsltu,nstta
            if (ianslt(j) .gt. 1) then
              if (r2stsv(j) .lt. riijj) then
                riijj=r2stsv(j)
                isprox=j
              end if
            end if
          end do
C@DM        else
C@DM          do igx=iflsltg(1,MYRANK+1),iflsltg(2,MYRANK+1)
C@DM            ig=mixupslt(igx)
C@DM            do j=ifgrslt(ig),ilgrslt(ig)
C@DM              if (ianslt(j) .gt. 1) then
C@DM                if (r2stsv(j) .lt. riijj) then
C@DM                  riijj=r2stsv(j)
C@DM                  isprox=j
C@DM                end if
C@DM              end if
C@DM            end do
C@DM          end do
C@DM        end if
c
C@DMc       Get the lowest value on all cpu's
C@DM        if (MYRANK .gt. 0) then
C@DM          call MPI_send(isprox,1,MPI_INTEGER,0,111+MYRANK,
C@DM     -      MPI_COMM_WORLD,ierr)
C@DM          call MPI_send(riijj,1,MPI_REAL,0,222+MYRANK,
C@DM     -      MPI_COMM_WORLD,ierr)
C@DM        else
C@DM          do icpu=2,NUMNOD
C@DM            call MPI_recv(isprox_n,1,MPI_INTEGER,icpu-1,
C@DM     -        111+icpu-1,MPI_COMM_WORLD,MPI_stat,ierr)
C@DM            call MPI_recv(riijj_n,1,MPI_REAL,icpu-1,
C@DM     -        222+icpu-1,MPI_COMM_WORLD,MPI_stat,ierr)
C@DM            if (riijj_n .lt. riijj) then
C@DM              riijj=riijj_n
C@DM              isprox=isprox_n
C@DM            end if
C@DM          end do
C@DM        end if
C@DM        call MPI_Bcast(isprox,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(riijj,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
c       Check if eslt has been called when iop(7)=2, if no, use cutoff
        if (iop(7) .eq. 2) then
          if (engie .lt. eniemx) riijj=ctslts
        end if
        riijjpx(2)=riijj
      end if
c     Primary hydration shell run - deduct VdW radius
      if (iop(92) .gt. 0) then
c       Put into riijj the distance from the nearest selected solute atom
        riijj=1.e+5
        do j=nsltu,nstta
          if (iaphsslt(j) .gt. 1) then
            if (r2stsv(j) .lt. riijj) then
              riijj=r2stsv(j)
              isprox=j
            end if
          end if
        end do
        rijps0=sqrt(riijj)
        if (iop(92) .eq. 1) then
          riijj=amax1(0.0,rijps0-vdw(ianslt(isprox)))
        else if (iop(92) .eq. 2) then
          riijj=amax1(0.0,rijps0-sigslt(isprox)/2.0)
        end if
        idistmv=int(rijps0*rri)+1
      else
        if (iop(17) .eq. 2) then
          rijxx=wpfmvcen(1)-crm(1)
          rijyy=wpfmvcen(2)-crm(2)
          rijzz=wpfmvcen(3)-crm(3)
          call pbcnd(rijxx,rijyy,rijzz,iop(5),iopt,riijj)
          riijjpx(3)=riijj
        end if
        if (iop(22) .eq. 0) then
          riijjx=riijjpx(iop(17)+1)
          if (riijjx .gt. ctslts) riijjx=ctslts
          idistmv=int(sqrt(riijjx)*rri)+1
           riijj=riijjx
        else
          idistmv=int(sqrt(riijj)*rri)+1
        end if
      end if
      if (iop(56) .eq. 0) then
        idistid=idistmv
      else if (iop(8) .eq. 2) then
        idistid=intgpsdis(iop(8),crm,wpfidcen,rri,c,crm1)
      else
        idistid=int(sqrt(riijjpx(iop(8)+1))*rri)+1
      end if
      return
      end
      function eww(ii,jj,iopt,ccx,ccy,ccz,riijj,c,crm)
c#    MMC routine 192 lstmod: 05/23/21
c*****Calculates the interaction energy between two waters
      dimension c(3,#NA),crm(3,#MO)
c     The atomic locations in the article correspond to
c     h1=i+1, h2=i+2, h3=j+1, h4=j+2, o5=i, o6=j.
c     MCY-CI energy calculation originally written by S. Swaminathan.
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /mcydat/ qq,dqq,a1,a2,a3,a4,b1,b2,b3,b4,ab1,ab2,ab3,ab4,qqq
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /cutinr/ rwwina,rwwin2
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 deww,virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),fix,fiy,fiz,fjx,fjy,fjz,vrsltn(3,#MO),
     -  vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /option/ iop(200),idebug(200)
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      dimension cj(3,#SV),cicxyz(3)
      equivalence (fcislv(1,1),fiox),(fcislv(2,1),fioy),
     -  (fcislv(3,1),fioz),(fcislv(1,2),fih1x),(fcislv(2,2),fih1y),
     -  (fcislv(3,2),fih1z),(fcislv(1,3),fih2x),(fcislv(2,3),fih2y),
     -  (fcislv(3,3),fih2z),(fcislv(1,4),filx),(fcislv(2,4),fily),
     -  (fcislv(3,4),filz)
      equivalence (fcjslv(1,1),fjox),(fcjslv(2,1),fjoy),
     -  (fcjslv(3,1),fjoz),(fcjslv(1,2),fjh1x),(fcjslv(2,2),fjh1y),
     -  (fcjslv(3,2),fjh1z),(fcjslv(1,3),fjh2x),(fcjslv(2,3),fjh2y),
     -  (fcjslv(3,3),fjh2z),(fcjslv(1,4),fjlx),(fcjslv(2,4),fjly),
     -  (fcjslv(3,4),fjlz)
c     The assumed order of atomic centers is O,H,H,LP.
c     The distance convention used in this routine is
c     r13-(H1,H1), r14-(H1,H2), r23-(H2,H1), r24-(H2,H2),
c     r18-(H1,LP), r28-(H2,LP), r37-(LP,H1), r47-(LP,H2),
c     r16-(H1,Ox), r26-(H2,Ox), r35-(Ox,H1), r45-(Ox,H2),
c     r56-(Ox,Ox), r78-(LP,LP)
c     Skip evaluation if riijj is < (rwwin Angstrom)**2 (rwwin2 au**2)
      eww=0.0
      if (riijj .le. rwwin2) then
        eww=1000.0+10.0*exp(rwwin2-riijj)
C@FR        zsq=sqrt(riijj)
C@FR        if (zsq .gt. 0.0) then
C@FR          fix=0.1*(crm(1,jj)-crm(1,ii))/zsq
C@FR          fjx=-fix
C@FR          fiy=0.1*(crm(2,jj)-crm(2,ii))/zsq
C@FR          fjy=-fiy
C@FR          fiz=0.1*(crm(3,jj)-crm(3,ii))/zsq
C@FR          fjz=-fiz
C@FR        end if
C@FR        call zeroit(fcislv,nslv3)
C@FR        call zeroit(fcjslv,nslv3)
        return
      end if
      i0=ic01+ii*nslv
      j0=ic01+jj*nslv
      if (iop(26) .lt. 4) then
c       Water solvents
        a1x=c(1,i0)
        a1y=c(2,i0)
        a1z=c(3,i0)
        a2x=c(1,i0+1)
        a2y=c(2,i0+1)
        a2z=c(3,i0+1)
        a3x=c(1,i0+2)
        a3y=c(2,i0+2)
        a3z=c(3,i0+2)
        b1x=c(1,j0)
        b1y=c(2,j0)
        b1z=c(3,j0)
        b2x=c(1,j0+1)
        b2y=c(2,j0+1)
        b2z=c(3,j0+1)
        b3x=c(1,j0+2)
        b3y=c(2,j0+2)
        b3z=c(3,j0+2)
        if (iop(26) .eq. 1) then
c---------TIPS/TIP3P water
          if (iopt .gt. 1) then
            b1x=b1x+ccx
            b1y=b1y+ccy
            b1z=b1z+ccz
            b2x=b2x+ccx
            b2y=b2y+ccy
            b2z=b2z+ccz
            b3x=b3x+ccx
            b3y=b3y+ccy
            b3z=b3z+ccz
          end if
          rabx=a1x-b1x
          raby=a1y-b1y
          rabz=a1z-b1z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)+alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fiox=-rabx*rab3
C@FR          fioy=-raby*rab3
C@FR          fioz=-rabz*rab3
C@FR          fjox=+rabx*rab3
C@FR          fjoy=+raby*rab3
C@FR          fjoz=+rabz*rab3
          rabx=a2x-b2x
          raby=a2y-b2y
          rabz=a2z-b2z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fih1x=-rabx*rab3
C@FR          fih1y=-raby*rab3
C@FR          fih1z=-rabz*rab3
C@FR          fjh1x=+rabx*rab3
C@FR          fjh1y=+raby*rab3
C@FR          fjh1z=+rabz*rab3
          rabx=a2x-b3x
          raby=a2y-b3y
          rabz=a2z-b3z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fih1x=fih1x-rabx*rab3
C@FR          fih1y=fih1y-raby*rab3
C@FR          fih1z=fih1z-rabz*rab3
C@FR          fjh2x=+rabx*rab3
C@FR          fjh2y=+raby*rab3
C@FR          fjh2z=+rabz*rab3
          rabx=a3x-b2x
          raby=a3y-b2y
          rabz=a3z-b2z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fih2x=-rabx*rab3
C@FR          fih2y=-raby*rab3
C@FR          fih2z=-rabz*rab3
C@FR          fjh1x=fjh1x+rabx*rab3
C@FR          fjh1y=fjh1y+raby*rab3
C@FR          fjh1z=fjh1z+rabz*rab3
          rabx=a3x-b3x
          raby=a3y-b3y
          rabz=a3z-b3z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fih2x=fih2x-rabx*rab3
C@FR          fih2y=fih2y-raby*rab3
C@FR          fih2z=fih2z-rabz*rab3
C@FR          fjh2x=fjh2x+rabx*rab3
C@FR          fjh2y=fjh2y+raby*rab3
C@FR          fjh2z=fjh2z+rabz*rab3
          rabx=a2x-b1x
          raby=a2y-b1y
          rabz=a2z-b1z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fih1x=fih1x-rabx*rab3
C@FR          fih1y=fih1y-raby*rab3
C@FR          fih1z=fih1z-rabz*rab3
C@FR          fjox=fjox+rabx*rab3
C@FR          fjoy=fjoy+raby*rab3
C@FR          fjoz=fjoz+rabz*rab3
          rabx=a3x-b1x
          raby=a3y-b1y
          rabz=a3z-b1z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fih2x=fih2x-rabx*rab3
C@FR          fih2y=fih2y-raby*rab3
C@FR          fih2z=fih2z-rabz*rab3
C@FR          fjox=fjox+rabx*rab3
C@FR          fjoy=fjoy+raby*rab3
C@FR          fjoz=fjoz+rabz*rab3
          rabx=a1x-b2x
          raby=a1y-b2y
          rabz=a1z-b2z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          fiox=fiox-rabx*rab3
C@FR          fioy=fioy-raby*rab3
C@FR          fioz=fioz-rabz*rab3
C@FR          fjh1x=fjh1x+rabx*rab3
C@FR          fjh1y=fjh1y+raby*rab3
C@FR          fjh1z=fjh1z+rabz*rab3
          rabx=a1x-b3x
          raby=a1y-b3y
          rabz=a1z-b3z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          fiox=fiox-rabx*rab3
C@FR          fioy=fioy-raby*rab3
C@FR          fioz=fioz-rabz*rab3
C@FR          fjh2x=fjh2x+rabx*rab3
C@FR          fjh2y=fjh2y+raby*rab3
C@FR          fjh2z=fjh2z+rabz*rab3
c         Calculate interaction energy.
            deww=dble(
C@RF     -      rfcorr13*
     -      qhh/r13+
C@RF     -      rfcorr14*
     -      qhh/r14+
C@RF     -      rfcorr23*
     -      qhh/r23+
C@RF     -      rfcorr24*
     -      qhh/r24+
C@RF     -      rfcorr56*
     -      qoo/r56)
     -      -dble(
C@RF     -      rfcorr16*
     -      qho/r16+
C@RF     -      rfcorr26*
     -      qho/r26+
C@RF     -      rfcorr53*
     -      qho/r53+
C@RF     -      rfcorr54*
     -      qho/r54)
     -      +dble(blj12/rlj12)-dble(alj6/rlj6)
            eww=deww
C@FR        fix=fiox+fih1x+fih2x
C@FR        fiy=fioy+fih1y+fih2y
C@FR        fiz=fioz+fih1z+fih2z
C@FR        fjx=fjox+fjh1x+fjh2x
C@FR        fjy=fjoy+fjh1y+fjh2y
C@FR        fjz=fjoz+fjh1z+fjh2z
        else if (iop(26) .eq. 2) then
c---------TIPS2/TIP4P/BF water
c         LJ interaction center is not the negative center
          a4x=c(1,i0+3)
          a4y=c(2,i0+3)
          a4z=c(3,i0+3)
          b4x=c(1,j0+3)
          b4y=c(2,j0+3)
          b4z=c(3,j0+3)
          if (iopt .gt. 1) then
            b1x=b1x+ccx
            b1y=b1y+ccy
            b1z=b1z+ccz
            b2x=b2x+ccx
            b2y=b2y+ccy
            b2z=b2z+ccz
            b3x=b3x+ccx
            b3y=b3y+ccy
            b3z=b3z+ccz
            b4x=b4x+ccx
            b4y=b4y+ccy
            b4z=b4z+ccz
          end if
          rab2x=a1x-b1x
          rab2y=a1y-b1y
          rab2z=a1z-b1z
          rab2=rab2x*rab2x+rab2y*rab2y+rab2z*rab2z
          rlj6=rab2*rab2*rab2
          rlj12=rlj6*rlj6
C@FR          rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR          fjox=rab2x*rab3
C@FR          fjoy=rab2y*rab3
C@FR          fjoz=rab2z*rab3
C@FR          fiox=-fjox
C@FR          fioy=-fjoy
C@FR          fioz=-fjoz
          rabx=a4x-b4x
          raby=a4y-b4y
          rabz=a4z-b4z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r56=sqrt(rab2)
C@RF          rfcorr56=1.0+r56*rab2*rccon
C@FR          rab3=-qoo/(r56*rab2)
C@FR          filx=-rabx*rab3
C@FR          fily=-raby*rab3
C@FR          filz=-rabz*rab3
C@FR          fjlx=+rabx*rab3
C@FR          fjly=+raby*rab3
C@FR          fjlz=+rabz*rab3
          rabx=a2x-b2x
          raby=a2y-b2y
          rabz=a2z-b2z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          rab3=-qhh/(r13*rab2)
C@FR          fih1x=-rabx*rab3
C@FR          fih1y=-raby*rab3
C@FR          fih1z=-rabz*rab3
C@FR          fjh1x=+rabx*rab3
C@FR          fjh1y=+raby*rab3
C@FR          fjh1z=+rabz*rab3
          rabx=a2x-b3x
          raby=a2y-b3y
          rabz=a2z-b3z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          rab3=-qhh/(r14*rab2)
C@FR          fih1x=fih1x-rabx*rab3
C@FR          fih1y=fih1y-raby*rab3
C@FR          fih1z=fih1z-rabz*rab3
C@FR          fjh2x=+rabx*rab3
C@FR          fjh2y=+raby*rab3
C@FR          fjh2z=+rabz*rab3
          rabx=a3x-b2x
          raby=a3y-b2y
          rabz=a3z-b2z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          rab3=-qhh/(r23*rab2)
C@FR          fih2x=-rabx*rab3
C@FR          fih2y=-raby*rab3
C@FR          fih2z=-rabz*rab3
C@FR          fjh1x=fjh1x+rabx*rab3
C@FR          fjh1y=fjh1y+raby*rab3
C@FR          fjh1z=fjh1z+rabz*rab3
          rabx=a3x-b3x
          raby=a3y-b3y
          rabz=a3z-b3z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          rab3=-qhh/(r24*rab2)
C@FR          fih2x=fih2x-rabx*rab3
C@FR          fih2y=fih2y-raby*rab3
C@FR          fih2z=fih2z-rabz*rab3
C@FR          fjh2x=fjh2x+rabx*rab3
C@FR          fjh2y=fjh2y+raby*rab3
C@FR          fjh2z=fjh2z+rabz*rab3
          rabx=a2x-b4x
          raby=a2y-b4y
          rabz=a2z-b4z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r16=sqrt(rab2)
C@RF          rfcorr16=1.0+r16*rab2*rccon
C@FR          rab3=qho/(r16*rab2)
C@FR          fih1x=fih1x-rabx*rab3
C@FR          fih1y=fih1y-raby*rab3
C@FR          fih1z=fih1z-rabz*rab3
C@FR          fjlx=fjlx+rabx*rab3
C@FR          fjly=fjly+raby*rab3
C@FR          fjlz=fjlz+rabz*rab3
          rabx=a3x-b4x
          raby=a3y-b4y
          rabz=a3z-b4z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r26=sqrt(rab2)
C@RF          rfcorr26=1.0+r26*rab2*rccon
C@FR          rab3=qho/(r26*rab2)
C@FR          fih2x=fih2x-rabx*rab3
C@FR          fih2y=fih2y-raby*rab3
C@FR          fih2z=fih2z-rabz*rab3
C@FR          fjlx=fjlx+rabx*rab3
C@FR          fjly=fjly+raby*rab3
C@FR          fjlz=fjlz+rabz*rab3
          rabx=a4x-b2x
          raby=a4y-b2y
          rabz=a4z-b2z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r53=sqrt(rab2)
C@RF          rfcorr53=1.0+r53*rab2*rccon
C@FR          rab3=qho/(r53*rab2)
C@FR          filx=filx-rabx*rab3
C@FR          fily=fily-raby*rab3
C@FR          filz=filz-rabz*rab3
C@FR          fjh1x=fjh1x+rabx*rab3
C@FR          fjh1y=fjh1y+raby*rab3
C@FR          fjh1z=fjh1z+rabz*rab3
          rabx=a4x-b3x
          raby=a4y-b3y
          rabz=a4z-b3z
          rab2=rabx*rabx+raby*raby+rabz*rabz
          r54=sqrt(rab2)
C@RF          rfcorr54=1.0+r54*rab2*rccon
C@FR          rab3=qho/(r54*rab2)
C@FR          filx=filx-rabx*rab3
C@FR          fily=fily-raby*rab3
C@FR          filz=filz-rabz*rab3
C@FR          fjh2x=fjh2x+rabx*rab3
C@FR          fjh2y=fjh2y+raby*rab3
C@FR          fjh2z=fjh2z+rabz*rab3
c         Calculate interaction energy.
          deww=dble(
C@RF     -    rfcorr13*
     -      qhh/r13+
C@RF     -    rfcorr14*
     -      qhh/r14+
C@RF     -    rfcorr23*
     -      qhh/r23+
C@RF     -    rfcorr24*
     -      qhh/r24+
C@RF     -    rfcorr56*
     -      qoo/r56)
     -         -dble(
C@RF     -    rfcorr16*
     -      qho/r16+
C@RF     -    rfcorr26*
     -      qho/r26+
C@RF     -    rfcorr53*
     -      qho/r53+
C@RF     -    rfcorr54*
     -      qho/r54)
     -         +dble(blj12/rlj12)-dble(alj6/rlj6)
          eww=deww
C@FR          fix=fiox+fih1x+fih2x+filx
C@FR          fiy=fioy+fih1y+fih2y+fily
C@FR          fiz=fioz+fih1z+fih2z+filz
C@FR          fjx=fjox+fjh1x+fjh2x+fjlx
C@FR          fjy=fjoy+fjh1y+fjh2y+fjly
C@FR          fjz=fjoz+fjh1z+fjh2z+fjlz
        else if (iop(26) .eq. 3) then
c---------TIP5P water
          i00=i0-1
          j00=j0-1
C@FR          do i=2,5
C@FR            do k=1,3
C@FR              fcislv(k,i)=0.0
C@FR              fcjslv(k,i)=0.0
C@FR            end do
C@FR          end do
          if (iopt .eq. 1) then
            rabx=a1x-b1x
            raby=a1y-b1y
            rabz=a1z-b1z
            rab2=rabx*rabx+raby*raby+rabz*rabz
            rlj6=rab2*rab2*rab2
            rlj12=rlj6*rlj6
            deww=dble(blj12/rlj12)-dble(alj6/rlj6)
C@FR            rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR            fcislv(1,1)=-rabx*rab3
C@FR            fcislv(2,1)=-raby*rab3
C@FR            fcislv(3,1)=-rabz*rab3
C@FR            fcjslv(1,1)=+rabx*rab3
C@FR            fcjslv(2,1)=+raby*rab3
C@FR            fcjslv(3,1)=+rabz*rab3
            do i=2,5
              do j=2,5
                rabx=c(1,i00+i)-c(1,j00+j)
                raby=c(2,i00+i)-c(2,j00+j)
                rabz=c(3,i00+i)-c(3,j00+j)
                rab2=rabx*rabx+raby*raby+rabz*rabz
                rab=sqrt(rab2)
                deww=deww+dble(qqt5(i,j)/rab)
C@RF     -            +dble(1.0+rab*rab2*rccon)
C@FR                rab3=-qqt5(i,j)/(rab*rab2)
C@FR                fcislv(1,i)=fcislv(1,i)-rabx*rab3
C@FR                fcislv(2,i)=fcislv(2,i)-raby*rab3
C@FR                fcislv(3,i)=fcislv(3,i)-rabz*rab3
C@FR                fcjslv(1,j)=fcjslv(1,j)+rabx*rab3
C@FR                fcjslv(2,j)=fcjslv(2,j)+raby*rab3
C@FR                fcjslv(3,j)=fcjslv(3,j)+rabz*rab3
              end do
            end do
          else
            rabx=a1x-b1x-ccx
            raby=a1y-b1y-ccy
            rabz=a1z-b1z-ccz
            rab2=rabx*rabx+raby*raby+rabz*rabz
            rlj6=rab2*rab2*rab2
            rlj12=rlj6*rlj6
            deww=dble(blj12/rlj12)-dble(alj6/rlj6)
C@FR            rab3=alj66/(rlj6*rab2)-blj122/(rlj12*rab2)
C@FR            fcislv(1,1)=-rabx*rab3
C@FR            fcislv(2,1)=-raby*rab3
C@FR            fcislv(3,1)=-rabz*rab3
C@FR            fcjslv(1,1)=+rabx*rab3
C@FR            fcjslv(2,1)=+raby*rab3
C@FR            fcjslv(3,1)=+rabz*rab3
            do i=2,5
              do j=2,5
                rabx=c(1,i00+i)-c(1,j00+j)-ccx
                raby=c(2,i00+i)-c(2,j00+j)-ccy
                rabz=c(3,i00+i)-c(3,j00+j)-ccz
                rab2=rabx*rabx+raby*raby+rabz*rabz
                rab=sqrt(rab2)
                deww=deww+dble(qqt5(i,j)/rab)
C@RF     -            +dble(1.0+rab*rab2*rccon)
C@FR                rab3=-qqt5(i,j)/(rab*rab2)
C@FR                fcislv(1,i)=fcislv(1,i)-rabx*rab3
C@FR                fcislv(2,i)=fcislv(2,i)-raby*rab3
C@FR                fcislv(3,i)=fcislv(3,i)-rabz*rab3
C@FR                fcjslv(1,j)=fcjslv(1,j)+rabx*rab3
C@FR                fcjslv(2,j)=fcjslv(2,j)+raby*rab3
C@FR                fcjslv(3,j)=fcjslv(3,j)+rabz*rab3
              end do
            end do
          end if
          eww=deww
C@FR          fix=0.0
C@FR          fiy=0.0
C@FR          fiz=0.0
C@FR          fjx=0.0
C@FR          fjy=0.0
C@FR          fjz=0.0
C@FR          do k=1,5
C@FR            fix=fix+fcislv(1,k)
C@FR            fiy=fiy+fcislv(2,k)
C@FR            fiz=fiz+fcislv(3,k)
C@FR            fjx=fjx+fcjslv(1,k)
C@FR            fjy=fjy+fcjslv(2,k)
C@FR            fjz=fjz+fcjslv(3,k)
C@FR          end do
        else if (iop(26) .eq. 0) then
c---------MCY water
c         Matsuoka, Clementi and Yoshimine,  JCP 64,1351-1361(1976).
          a4x=c(1,i0+3)
          a4y=c(2,i0+3)
          a4z=c(3,i0+3)
          b4x=c(1,j0+3)
          b4y=c(2,j0+3)
          b4z=c(3,j0+3)
          if (iopt .gt. 1) then
            b1x=b1x+ccx
            b1y=b1y+ccy
            b1z=b1z+ccz
            b2x=b2x+ccx
            b2y=b2y+ccy
            b2z=b2z+ccz
            b3x=b3x+ccx
            b3y=b3y+ccy
            b3z=b3z+ccz
            b4x=b4x+ccx
            b4y=b4y+ccy
            b4z=b4z+ccz
          end if
          r132x=a2x-b2x
          r132y=a2y-b2y
          r132z=a2z-b2z
          rab2=r132x*r132x+r132y*r132y+r132z*r132z
          r13=sqrt(rab2)
C@RF          rfcorr13=1.0+r13*rab2*rccon
C@FR          r133=-qq/(r13*rab2)
C@FR          fih1x=-r132x*r133
C@FR          fih1y=-r132y*r133
C@FR          fih1z=-r132z*r133
C@FR          fjh1x=+r132x*r133
C@FR          fjh1y=+r132y*r133
C@FR          fjh1z=+r132z*r133
          r142x=a2x-b3x
          r142y=a2y-b3y
          r142z=a2z-b3z
          rab2=r142x*r142x+r142y*r142y+r142z*r142z
          r14=sqrt(rab2)
C@RF          rfcorr14=1.0+r14*rab2*rccon
C@FR          r143=-qq/(r14*rab2)
C@FR          fih1x=fih1x-r142x*r143
C@FR          fih1y=fih1y-r142y*r143
C@FR          fih1z=fih1z-r142z*r143
C@FR          fjh2x=+r142x*r143
C@FR          fjh2y=+r142y*r143
C@FR          fjh2z=+r142z*r143
          r232x=a3x-b2x
          r232y=a3y-b2y
          r232z=a3z-b2z
          rab2=r232x*r232x+r232y*r232y+r232z*r232z
          r23=sqrt(rab2)
C@RF          rfcorr23=1.0+r23*rab2*rccon
C@FR          r233=-qq/(r23*rab2)
C@FR          fih2x=-r232x*r233
C@FR          fih2y=-r232y*r233
C@FR          fih2z=-r232z*r233
C@FR          fjh1x=fjh1x+r232x*r233
C@FR          fjh1y=fjh1y+r232y*r233
C@FR          fjh1z=fjh1z+r232z*r233
          r242x=a3x-b3x
          r242y=a3y-b3y
          r242z=a3z-b3z
          rab2=r242x*r242x+r242y*r242y+r242z*r242z
          r24=sqrt(rab2)
C@RF          rfcorr24=1.0+r24*rab2*rccon
C@FR          r243=-qq/(r24*rab2)
C@FR          fih2x=fih2x-r242x*r243
C@FR          fih2y=fih2y-r242y*r243
C@FR          fih2z=fih2z-r242z*r243
C@FR          fjh2x=fjh2x+r242x*r243
C@FR          fjh2y=fjh2y+r242y*r243
C@FR          fjh2z=fjh2z+r242z*r243
          r182x=a2x-b4x
          r182y=a2y-b4y
          r182z=a2z-b4z
          rab2=r182x*r182x+r182y*r182y+r182z*r182z
          r18=sqrt(rab2)
C@RF          rfcorr18=1.0+r18*rab2*rccon
C@FR          r183=dqq/(r18*rab2)
C@FR          fih1x=fih1x-r182x*r183
C@FR          fih1y=fih1y-r182y*r183
C@FR          fih1z=fih1z-r182z*r183
C@FR          fjlx=+r182x*r183
C@FR          fjly=+r182y*r183
C@FR          fjlz=+r182z*r183
          r282x=a3x-b4x
          r282y=a3y-b4y
          r282z=a3z-b4z
          rab2=r282x*r282x+r282y*r282y+r282z*r282z
          r28=sqrt(rab2)
C@RF          rfcorr28=1.0+r28*rab2*rccon
C@FR          r283=dqq/(r28*rab2)
C@FR          fih2x=fih2x-r282x*r283
C@FR          fih2y=fih2y-r282y*r283
C@FR          fih2z=fih2z-r282z*r283
C@FR          fjlx=fjlx+r282x*r283
C@FR          fjly=fjly+r282y*r283
C@FR          fjlz=fjlz+r282z*r283
          r372x=a4x-b2x
          r372y=a4y-b2y
          r372z=a4z-b2z
          rab2=r372x*r372x+r372y*r372y+r372z*r372z
          r37=sqrt(rab2)
C@RF          rfcorr37=1.0+r37*rab2*rccon
C@FR          r373=dqq/(r37*rab2)
C@FR          filx=-r372x*r373
C@FR          fily=-r372y*r373
C@FR          filz=-r372z*r373
C@FR          fjh1x=fjh1x+r372x*r373
C@FR          fjh1y=fjh1y+r372y*r373
C@FR          fjh1z=fjh1z+r372z*r373
          r472x=a4x-b3x
          r472y=a4y-b3y
          r472z=a4z-b3z
          rab2=r472x*r472x+r472y*r472y+r472z*r472z
          r47=sqrt(rab2)
C@RF          rfcorr47=1.0+r47*rab2*rccon
C@FR          r473=dqq/(r47*rab2)
C@FR          filx=filx-r472x*r473
C@FR          fily=fily-r472y*r473
C@FR          filz=filz-r472z*r473
C@FR          fjh2x=fjh2x+r472x*r473
C@FR          fjh2y=fjh2y+r472y*r473
C@FR          fjh2z=fjh2z+r472z*r473
          r782x=a4x-b4x
          r782y=a4y-b4y
          r782z=a4z-b4z
          rab2=r782x*r782x+r782y*r782y+r782z*r782z
          r78=sqrt(rab2)
C@RF          rfcorr78=1.0+r78*rab2*rccon
C@FR          r783=-qqq/(r78*rab2)
C@FR          filx=filx-r782x*r783
C@FR          fily=fily-r782y*r783
C@FR          filz=filz-r782z*r783
C@FR          fjlx=fjlx+r782x*r783
C@FR          fjly=fjly+r782y*r783
C@FR          fjlz=fjlz+r782z*r783
c         Calculate interaction energy.
          deww=dble(
C@RF     -      rfcorr13*
     -      qq/r13+
C@RF     -      rfcorr14*
     -      qq/r14+
C@RF     -      rfcorr23*
     -      qq/r23+
C@RF     -      rfcorr24*
     -      qq/r24+
C@RF     -      rfcorr78*
     -      qqq/r78)
     -        -dble(
C@RF     -      rfcorr18*
     -      dqq/r18+
C@RF     -      rfcorr28*
     -      dqq/r28+
C@RF     -      rfcorr37*
     -      dqq/r37+
C@RF     -      rfcorr47*
     -      dqq/r47)
c         Calculate remaining distances.
          r562x=a1x-b1x
          r562y=a1y-b1y
          r562z=a1z-b1z
          r562=r562x*r562x+r562y*r562y+r562z*r562z
          if (r562 .lt. ctexps) then
            r56=sqrt(r562)
            r162x=a2x-b1x
            r162y=a2y-b1y
            r162z=a2z-b1z
            r162=r162x*r162x+r162y*r162y+r162z*r162z
            r16=sqrt(r162)
            r262x=a3x-b1x
            r262y=a3y-b1y
            r262z=a3z-b1z
            r262=r262x*r262x+r262y*r262y+r262z*r262z
            r26=sqrt(r262)
            r352x=a1x-b2x
            r352y=a1y-b2y
            r352z=a1z-b2z
            r352=r352x*r352x+r352y*r352y+r352z*r352z
            r35=sqrt(r352)
            r452x=a1x-b3x
            r452y=a1y-b3y
            r452z=a1z-b3z
            r452=r452x*r452x+r452y*r452y+r452z*r452z
            r45=sqrt(r452)
            er56b1=exp(-b1*r56)
            er13b2=exp(-b2*r13)
            er14b2=exp(-b2*r14)
            er23b2=exp(-b2*r23)
            er24b2=exp(-b2*r24)
            er16b3=exp(-b3*r16)
            er26b3=exp(-b3*r26)
            er35b3=exp(-b3*r35)
            er45b3=exp(-b3*r45)
            er16b4=exp(-b4*r16)
            er26b4=exp(-b4*r26)
            er35b4=exp(-b4*r35)
            er45b4=exp(-b4*r45)
            deww=deww+dble(a1*er56b1+a2*(er13b2+er14b2+er23b2+er24b2))
     -           +dble(a3*(er16b3+er26b3+er35b3+er45b3))
     -           -dble(a4*(er16b4+er26b4+er35b4+er45b4))
C@FR            f1=ab1*er56b1/r56
C@FR            f2=(ab3*er35b3-ab4*er35b4)/r35
C@FR            f3=(ab3*er45b3-ab4*er45b4)/r45
C@FR            fiox=+r562x*f1+r352x*f2+r452x*f3
C@FR            fioy=+r562y*f1+r352y*f2+r452y*f3
C@FR            fioz=+r562z*f1+r352z*f2+r452z*f3
C@FR            f11=ab2*er13b2/r13
C@FR            f12=ab2*er14b2/r14
C@FR            f13=(ab3*er16b3-ab4*er16b4)/r16
C@FR            fih1x=fih1x+r132x*f11+r142x*f12+r162x*f13
C@FR            fih1y=fih1y+r132y*f11+r142y*f12+r162y*f13
C@FR            fih1z=fih1z+r132z*f11+r142z*f12+r162z*f13
C@FR            f21=ab2*er23b2/r23
C@FR            f22=ab2*er24b2/r24
C@FR            f23=(ab3*er26b3-ab4*er26b4)/r26
C@FR            fih2x=fih2x+r232x*f21+r242x*f22+r262x*f23
C@FR            fih2y=fih2y+r232y*f21+r242y*f22+r262y*f23
C@FR            fih2z=fih2z+r232z*f21+r242z*f22+r262z*f23
C@FR            fjox=-r562x*f1-r162x*f13-r262x*f23
C@FR            fjoy=-r562y*f1-r162y*f13-r262y*f23
C@FR            fjoz=-r562z*f1-r162z*f13-r262z*f23
C@FR            fjh1x=fjh1x-r352x*f2-r132x*f11-r232x*f21
C@FR            fjh1y=fjh1y-r352y*f2-r132y*f11-r232y*f21
C@FR            fjh1z=fjh1z-r352z*f2-r132z*f11-r232z*f21
C@FR            fjh2x=fjh2x-r452x*f3-r142x*f12-r242x*f22
C@FR            fjh2y=fjh2y-r452y*f3-r142y*f12-r242y*f22
C@FR            fjh2z=fjh2z-r452z*f3-r142z*f12-r242z*f22
          else
c           Zero out forces on oxygen when no exponential terms were used
C@FR            fiox=0.0
C@FR            fioy=0.0
C@FR            fioz=0.0
C@FR            fjox=0.0
C@FR            fjoy=0.0
C@FR            fjoz=0.0
          end if
          eww=deww
        end if
      else
c       General solvent-solvent interaction
c-------Kollman, BVG or OPLS type potential for general solvent-solvent
        i01=i0-1
        j01=j0-1
        deww=0.d0
C@FR        call zeroit(fcislv,nslv3)
C@FR        call zeroit(fcjslv,nslv3)
        if (iop(5) .ne. 2) then
          do j=1,nslv
            cj(1,j)=c(1,j01+j)+ccx
            cj(2,j)=c(2,j01+j)+ccy
            cj(3,j)=c(3,j01+j)+ccz
          end do
        else
          cicxyz(1)=ccx
          cicxyz(2)=ccy
          cicxyz(3)=ccz
          call hcp_rot_trans(crm(1,jj),c(1,j0),cj,1,nslv,cicxyz,iopt,1)
        end if
        do i=1,nslv
          do j=1,nslv
c           Loop on the solvent atoms
            rxyz1v=c(1,i01+i)-cj(1,j)
            rxyz2v=c(2,i01+i)-cj(2,j)
            rxyz3v=c(3,i01+i)-cj(3,j)
            rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
            rij=sqrt(rij2)
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
            er6=c6vv(j,i)/rij6
            er12=c12vv(j,i)/rij12
            qr=(qvv(j,i)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
            deww=deww+(dble(er12)-dble(er6)+dble(qr))
C@FR            abcf=(er6*6.0-er12*12.0-qr)/rij2
C@FR            fcislv(1,i)=fcislv(1,i)-abcf*rxyz1v
C@FR            fcislv(2,i)=fcislv(2,i)-abcf*rxyz2v
C@FR            fcislv(3,i)=fcislv(3,i)-abcf*rxyz3v
C@FR            fcjslv(1,j)=fcjslv(1,j)+abcf*rxyz1v
C@FR            fcjslv(2,j)=fcjslv(2,j)+abcf*rxyz2v
C@FR            fcjslv(3,j)=fcjslv(3,j)+abcf*rxyz3v
          end do
        end do
        eww=deww
C@FR        fix=0.0
C@FR        fiy=0.0
C@FR        fiz=0.0
C@FR        fjx=0.0
C@FR        fjy=0.0
C@FR        fjz=0.0
C@FR        do i=1,nslv
C@FR          fix=fix+fcislv(1,i)
C@FR          fiy=fiy+fcislv(2,i)
C@FR          fiz=fiz+fcislv(3,i)
C@FR          fjx=fjx+fcjslv(1,i)
C@FR          fjy=fjy+fcjslv(2,i)
C@FR          fjz=fjz+fcjslv(3,i)
C@FR        end do
      end if
      return
      end
      function eslt(jj,riijj,iop2,iopst,islt1,islt2,nsvst,nsvg,crmslt,
     -  igrcent,igrp,ioppbc,iopgrml,c,crm,ctslts,edgex2,edgey2,edge2)
c#    MMC routine 193 lstmod: 05/25/21
c*****Calculates water-solute interaction energies between solvent jj
c     and solute 1. riijj is the solute-solvent COM distance.
      dimension c(3,#NA),crm(3)
c     BVG interaction originally written by P.V. Maye.
c     Kollman and Clementi ion interactions originally written by B. Jayaram.
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /ecell/ cic(3,27),ncell
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /reactionfield/ epsrf,rccon
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),fslt(3),fslv(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      dimension crmslt(3),a(3,#SV),b(3,#ST),z(3)
      dimension c6ji1(#ST),c12ji1(#ST)
C@FR      dimension fj0(3,#SV)
      real*8 deslt
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind2/ crat6,crat1
      equivalence (c6ji1(1),c6ji(1,1)),(c12ji1(1),c12ji(1,1))
      eslt=0.0
      uind12=0.d0
      uind6=0.d0
      uind1=0.d0
      uitot=0.d0
c     Dont calculate for dummy groups
      if (iopst .gt. 9) return
C@FR      if (igrp .gt. 1) call trnsfr(fj0,fcjslv,3*nsvst)
c     Compute COM-COM distance
      z(1)=0.0
      if (iopgrml*igrcent .eq. 0) then
c       Use solute com
        do k=kxmn,3
          z(k)=crm(k)-crmslt(k)
        end do
      else
c       Use atom igrcent
        do k=kxmn,3
          z(k)=crm(k)-c(k,igrcent)
        end do
      end if
      call pbcnd(z(1),z(2),z(3),iop(5),ioppbc,riijj)
      if (iop(82) .gt. 0) iopbso(jj)=ioppbc
      ivopt(jj)=ioppbc
      if (riijj .gt. ctslts) then
c       Fill in the slv-slt-atom distance
        do j=islt1,islt2
          r2stsv(j)=ctslts+1.0
        end do
        return
      end if
      if (iop2 .le. 1) then
        call trnsfr(a,c(1,ic01+jj*nslv),3*nsvg)
        call trnsfr(b(1,islt1),c(1,islt1),3*(islt2-islt1+1))
        if (ioppbc .gt. 1) then
          if (iop(5) .ne. 2) then
            do i=1,nsvg
              do k=kxmn,3
                a(k,i)=a(k,i)+cic(k,ioppbc)
              end do
            end do
          else
            do i=1,nsvg
              do k=kxmn,3
                a(k,i)=a(k,i)+cic(k,ioppbc)
              end do
              call hcp_rotate(a(1,i),a(2,i),ioppbc)
            end do
          end if
        end if
        if (iop2 .eq. 1) then
c.........Infinite periodic solute along the x axis
c         Translate solvent and solute to put solvent at x=0
          dx=crm(1)
          do i=1,nsvg
            a(1,i)=a(1,i)-dx
          end do
          do i=islt1,islt2
            c(1,i)=c(1,i)-dx
            kx=int(c(1,i)/edge2)+2
            c(1,i)=c(1,i)+dex(kx)
          end do
        end if
      else
c.......Crystal solute - create the replica of the cell around the solvent
        do i=1,nsvg
          do k=1,3
            a(k,i)=c(k,ic00+jj*nslv+i)-crm(k)
          end do
        end do
        call trnsfr(b(1,islt1),c(1,islt1),3*(islt2-islt1+1))
        do i=islt1,islt2
          cix=c(1,i)-crm(1)
          ciy=c(2,i)-crm(2)
          ciz=c(3,i)-crm(3)
          kx=int(cix/edgex2)+3
          ky=int(ciy/edgey2)+3
          kz=int(ciz/edge2)+3
          c(1,i)=cix+dex(kx)
          c(2,i)=ciy+dey(ky)
          c(3,i)=ciz+dez(kz)
        end do
        riijj=crm(1)**2+crm(2)**2+crm(3)**2
      end if
      deslt=0.d0
      if (iopst .eq. 3 .or. iopst .eq. 4) then
c-------Kollman, Charmm, BVG or OPLS for solute-solvent with TIP3P water
c       Do interactions with water oxygen first: LJ + el.stat.
c       First water atom is the oxygen
        i=ione
C@PS        do i=1,ione
        do j=islt1,islt2
c         Loop on solute atoms
          rxyz1v=a(1,1)-c(1,j)
          rxyz2v=a(2,1)-c(2,j)
          rxyz3v=a(3,1)-c(3,j)
          rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
          rij=sqrt(rij2)
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          er1=(qji(j,1)/rij)
C@RF     -          *(1.0+rij*rij2*rccon)
          er6=c6ji1(j)/rij6
          er12=c12ji1(j)/rij12
          uind12=uind12+dble(er12)
          uind6=uind6+dble(er6)
          uind1=uind1+dble(er1)
C@FR          abcf=(crat6*er6*6.0-er12*12.0-crat1*er1)/rij2
C@FRC@TS          fcslt(1,j)=fcslt(1,j)+abcf*rxyz1v
C@FRC@TS          fcslt(2,j)=fcslt(2,j)+abcf*rxyz2v
C@FRC@TS          fcslt(3,j)=fcslt(3,j)+abcf*rxyz3v
C@FR          fcjslv(1,i)=fcjslv(1,i)-abcf*rxyz1v
C@FR          fcjslv(2,i)=fcjslv(2,i)-abcf*rxyz2v
C@FR          fcjslv(3,i)=fcjslv(3,i)-abcf*rxyz3v
          r2stsv(j)=rij2
        end do
C@PS        end do
c       Loop on water hydrogen atoms
        do i=2,3
          do j=islt1,islt2
c           Loop on solute atoms
            rxyz1v=a(1,i)-c(1,j)
            rxyz2v=a(2,i)-c(2,j)
            rxyz3v=a(3,i)-c(3,j)
            rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
            rij=sqrt(rij2)
            rij3=rij2*rij
c           uind1a(j)=uind1a(j)+dble(qji(j,2)/rij)
            uind1=uind1+dble(qji(j,2)/rij)
C@RF     -          *(1.0+rij*rij2*rccon)
C@FR            abcf=-crat1*qji(j,2)/rij3
C@FRC@TS            fcslt(1,j)=fcslt(1,j)+abcf*rxyz1v
C@FRC@TS            fcslt(2,j)=fcslt(2,j)+abcf*rxyz2v
C@FRC@TS            fcslt(3,j)=fcslt(3,j)+abcf*rxyz3v
C@FR            fcjslv(1,i)=fcjslv(1,i)-abcf*rxyz1v
C@FR            fcjslv(2,i)=fcjslv(2,i)-abcf*rxyz2v
C@FR            fcjslv(3,i)=fcjslv(3,i)-abcf*rxyz3v
          end do
        end do
      else if (iopst .eq. 6) then
c-------Kollman, BVG or OPLS potential for solute-solvent with TIP4/5P water
        i=ione
C@PS        do i=1,ione
        do j=islt1,islt2
c         Loop on the solute atoms
c         LJ interaction with the oxygen
          rxyz1v=a(1,1)-c(1,j)
          rxyz2v=a(2,1)-c(2,j)
          rxyz3v=a(3,1)-c(3,j)
          rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          er6=c6ji1(j)/rij6
          er12=c12ji1(j)/rij12
          uind6=uind6+dble(er6)
          uind12=uind12+dble(er12)
C@FR          abcf=(crat6*er6*6.0-er12*12.0)/rij2
C@FRC@TS          fcslt(1,j)=fcslt(1,j)+abcf*rxyz1v
C@FRC@TS          fcslt(2,j)=fcslt(2,j)+abcf*rxyz2v
C@FRC@TS          fcslt(3,j)=fcslt(3,j)+abcf*rxyz3v
C@FR          fcjslv(1,i)=fcjslv(1,i)-abcf*rxyz1v
C@FR          fcjslv(2,i)=fcjslv(2,i)-abcf*rxyz2v
C@FR          fcjslv(3,i)=fcjslv(3,i)-abcf*rxyz3v
          r2stsv(j)=rij2
        end do
C@PS        end do
        do i=2,nslv
c         Loop on the solvent atoms
          icli=islvtp(i)
          do j=islt1,islt2
            rxyz1v=a(1,i)-c(1,j)
            rxyz2v=a(2,i)-c(2,j)
            rxyz3v=a(3,i)-c(3,j)
            rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
            rij=sqrt(rij2)
            rij3=rij2*rij
c           uind1a(j)=uind1a(j)+dble(qji(j,icli)/rij)
            uind1=uind1+dble(qji(j,icli)/rij)
C@RF     -          *(1.0+rij*rij2*rccon)
C@FR            abcf=-crat1*qji(j,icli)/rij3
C@FRC@TS            fcslt(1,j)=fcslt(1,j)+abcf*rxyz1v
C@FRC@TS            fcslt(2,j)=fcslt(2,j)+abcf*rxyz2v
C@FRC@TS            fcslt(3,j)=fcslt(3,j)+abcf*rxyz3v
C@FR            fcjslv(1,i)=fcjslv(1,i)-abcf*rxyz1v
C@FR            fcjslv(2,i)=fcjslv(2,i)-abcf*rxyz2v
C@FR            fcjslv(3,i)=fcjslv(3,i)-abcf*rxyz3v
          end do
        end do
      else if (iopst .eq. 7) then
c       General solvent
c-------Kollman, BVG or OPLS potential for solute-general solvent
        do i=1,nslv
          do j=islt1,islt2
c           Loop on the solute atoms
            rxyz1v=a(1,i)-c(1,j)
            rxyz2v=a(2,i)-c(2,j)
            rxyz3v=a(3,i)-c(3,j)
            rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
            rij=sqrt(rij2)
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
            er6=c6tv(j,i)/rij6
            er12=c12tv(j,i)/rij12
            if (er6 .lt. 0.0 .or. er12 .lt. 0.0) write (6,8712)
     -        i,j,c6tv(j,i),c12tv(j,i),rij2
8712        format(' WRONG SIGN: i,j=',i4,i6,' c6tv(i,j)=',e12.5,
     -        ' c12tv=',e12.5,' rij=',f10.5)
            er1=(qtv(j,i)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
c           uind12a(j)=uind12a(j)+dble(er12)
c           uind6a(j)=uind6a(j)+dble(er6)
c           uind1a(j)=uind1a(j)+dble(er1)
            uind12=uind12+dble(er12)
            uind6=uind6+dble(er6)
            uind1=uind1+dble(er1)
C@FR            abcf=(crat6*er6*6.0-er12*12.0-crat1*er1)/rij2
C@FRC@TS            fcslt(1,j)=fcslt(1,j)+abcf*rxyz1v
C@FRC@TS            fcslt(2,j)=fcslt(2,j)+abcf*rxyz2v
C@FRC@TS            fcslt(3,j)=fcslt(3,j)+abcf*rxyz3v
C@FR            fcjslv(1,i)=fcjslv(1,i)-abcf*rxyz1v
C@FR            fcjslv(2,i)=fcjslv(2,i)-abcf*rxyz2v
C@FR            fcjslv(3,i)=fcjslv(3,i)-abcf*rxyz3v
            if (i .eq. islvrep) r2stsv(j)=rij2
          end do
        end do
      else if (iopst .eq. 8) then
c-------Hard sphere solute
        if (ignorehs .eq. 0) then
          do j=islt1,islt2
c           Loop on the solute atoms
            rxyz1v=a(1,islvrep)-c(1,j)
            rxyz2v=a(2,islvrep)-c(2,j)
            rxyz3v=a(3,islvrep)-c(3,j)
            rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
            if (rij2 .lt. c12ji(j,1)) then
c             Overlap with HS found
              uind12=realmx
              go to 999
            end if
          end do
        end if
      else if (iopst .eq. 1) then
c-------Clementi potential for solute-solvent
        do i=1,3
c         Loop on water atoms
          icli=islvtp(i)
          do j=islt1,islt2
c           Loop on the solute atoms
            rxyz1v=a(1,i)-c(1,j)
            rxyz2v=a(2,i)-c(2,j)
            rxyz3v=a(3,i)-c(3,j)
            rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
            rij=sqrt(rij2)
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
            er1=(qji(j,icli)/rij)
C@RF     -          *(1.0+rij*rij2*rccon)
            er6=c6ji(j,icli)/rij6
            er12=c12ji(j,icli)/rij12
            uind12=uind12+dble(er12)
            uind6=uind6+dble(er6)
            uind1=uind1+dble(er1)
C@FR            abcf=(crat6*er6*6.0-er12*12.0-crat1*er1)/rij2
C@FRC@TS            fcslt(1,j)=fcslt(1,j)+abcf*rxyz1v
C@FRC@TS            fcslt(2,j)=fcslt(2,j)+abcf*rxyz2v
C@FRC@TS            fcslt(3,j)=fcslt(3,j)+abcf*rxyz3v
C@FR            fcjslv(1,i)=fcjslv(1,i)-abcf*rxyz1v
C@FR            fcjslv(2,i)=fcjslv(2,i)-abcf*rxyz2v
C@FR            fcjslv(3,i)=fcjslv(3,i)-abcf*rxyz3v
            if (i .eq. islvrep) r2stsv(j)=rij2
          end do
        end do
      else if (iopst .eq. 2) then
c-------QPEN potential for solute-solvent
        call qpen(a,b,riijj,eslta)
        eslt=eslta
        uind12=eslt
        uind6=0.d0
        uind1=0.d0
        uitot=eslt
      end if
999   eslt=uind1*dble(crat1)-uind6*dble(crat6)+uind12
      uitot=uind1-uind6+uind12
c     Restore solute conformation that may have been shifted
      if (iop2 .gt. 0)
     -  call trnsfr(c(1,islt1),b(1,islt1),3*(islt2-islt1+1))
C@FR      if (igrp .le. 1) then
C@FRc       Add up atomic force contributions, virial sum contributions
C@FR        do k=1,3
C@FR          fslvk0=fslv(k)
C@FR          do i=1,nsvst
C@FR            fslv(k)=fslv(k)+fcjslv(k,i)
C@FR          end do
C@FR          virc(k)=virc(k)-z(k)*(fslv(k)-fslvk0)
C@FR        end do
C@FR      else
C@FRc       Deduct contributions from previous slt groups
C@FR        do k=1,3
C@FR          fslvk0=fslv(k)
C@FR          do i=1,nsvst
C@FR            fslv(k)=fslv(k)+(fcjslv(k,i)-fj0(k,i))
C@FR          end do
C@FR          virc(k)=virc(k)-z(k)*(fslv(k)-fslvk0)
C@FR        end do
C@FR      end if
      return
      end
      subroutine qpen(a,b,riijj,eslta)
c#    MMC routine 194 lstmod: 04/29/96
c*****Compute QPEN slt-slv interaction energy
c     Originally written by P.K. Mehrotra
c     a - coordinates of the solvent molecule.
c     the first "nslvn" atoms constitute the nuclear centers.
c     The next atom is a dummy atom (it was used to accommodate
c     the Clementi lone-pair for the water). The remainig
c     atoms are the electronic centers.
c     b - coordinates of the solute molecule.
c     The first "nsltn" atoms constitute the nuclear centers
c     and remaing constitute the electronic centers.
c     riijj - the distance between the center of mass of the
c      the solute and the center of mass of the "solvent"
c     eslta - the solute - solvent pair energy in atomic units
      dimension a(3,#SV),b(3,#ST)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /pfconst/ mixrule(11),vdw14fac(11),es14fac(11),nslvst(11),
     -  maxtyp(11)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),fslt(3),fslv(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      dimension cqsltn(3,#TN),cqslvn(3,#VN),cqslte(3,#TE),
     -  cqslve(3,#VE)
      common /cqpen/ qnn(#TN,#VN),qne(#TN,#VE),qen(#TE,#VN),
     -  qee(#TE,#VE),aee(#TE,#VE),bee(#TE,#VE),cee(#TE,#VE),
     -  iopict,nsltn,nslvn,nslte,nslve
      common /cvdw/ vdm2(#TN,#VN),cutin,escale
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      dimension ax(3)
      real*8 enb,ucn,cnn,ucne,uc
      eslta=0.0
      if (iopict .eq. 1) then
        rinr=sqrt(riijj)
        if (rinr .le. cutin) then
          eslta=10.0*exp(-1.0*rinr)
          return
        end if
      end if
c-----Extract the nuclear and electron coordinates from the atom arrays
c     Coordinates for solute nuclei
      call trnsfr(cqsltn,b,3*nsltn)
c     Coordinates for solute electrons
      call trnsfr(cqslte,b(1,nsltn+1),3*nslte)
c     Coordinates for solvent nuclei
      call trnsfr(cqslvn,a,3*nslvn)
c     Coordinates for solvent electrons
c     Skip the dummy pseudo atom which was inputted in the solvent
c     coordinates to accommodate MCY-CI water-water pot function
      call trnsfr(cqslve,a(1,nslvn+1),3*nslve)
      if (iopict .eq. 2) then
c-------See whether the Van der Waals envelope of solvent overlaps
c       with van der waals envelope of solute
        do i=1,nsltn
          do j=1,nslvn
            sum=0.0
            do k=1,3
              axk=cqsltn(k,i)-cqslvn(k,j)
              sum=sum+axk*axk
            end do
            if (sum .lt. vdm2(i,j)) then
              eslta=10.0*exp(-1.0*sqrt(sum))
              write (iout,220) eslta
              return
            end if
          end do
        end do
      end if
c     Perform the energy calculation
      ucn=0.d0
c-----Nuclear-nuclear Coulombic repulsion is computed
      do i=1,nsltn
        do j=1,nslvn
          rij2=0.0
          do k=1,3
            ax(k)=cqsltn(k,i)-cqslvn(k,j)
            rij2=rij2+ax(k)*ax(k)
          end do
          rij=sqrt(rij2)
          con1=qnn(i,j)/rij
C@FR          do k=1,3
C@FR            con2=(con1*ax(k))/rij2
C@FRC@TS            fcslt(k,i)=fcslt(k,i)+con2
C@FR            fcjslv(k,j)=fcjslv(k,j)-con2
C@FR          end do
          ucn=ucn+con1
        end do
      end do
      cnn=ucn
c-----Nuclei - electron Coulombic interaction is computed
      ucne=0.d0
      do i=1,nsltn
        do j=1,nslve
          j1=nslvn+j
          rij2=0.0
          do k=1,3
            ax(k)=cqsltn(k,i)-cqslve(k,j)
            rij2=rij2+ax(k)*ax(k)
          end do
          rij=sqrt(rij2)
          con1=qne(i,j)/rij
C@FR          do k=1,3
C@FR            con2=(con1*ax(k))/rij2
C@FRC@TS            fcslt(k,i)=fcslt(k,i)+con2
C@FR            fcjslv(k,j1)=fcjslv(k,j1)-con2
C@FR          end do
          ucne=ucne+con1
        end do
      end do
      do i=1,nslte
        i1=nsltn+i
        do j=1,nslvn
          rij2=0.0
          do k=1,3
            ax(k)=cqslte(k,i)-cqslvn(k,j)
            rij2=rij2+ax(k)*ax(k)
          end do
          rij=sqrt(rij2)
          con1=qen(i,j)/rij
C@FR          do k=1,3
C@FR            con2=(con1*ax(k))/rij2
C@FRC@TS            fcslt(k,i1)=fcslt(k,i1)+con2
C@FR            fcjslv(k,j)=fcjslv(k,j)-con2
C@FR          end do
          ucne=ucne+con1
        end do
      end do
      uc=ucne
c-----Compute electron-electron interaction
      enb=0.0
      do i=1,nslte
        i1=nsltn+i
        do j=1,nslve
          j1=nslvn+j
          r2=0.0
          do k=1,3
            ax(k)=cqslte(k,i)-cqslve(k,j)
            r2=r2+ax(k)*ax(k)
          end do
          r6=r2*r2*r2
          r1=sqrt(r2)
          con1=1./r1
          con2=aee(i,j)*exp(-bee(i,j)*r1)
          con3=cee(i,j)/r6
C@FR          do k=1,3
C@FR            abcf=qee(i,j)*((con1/r2)+(bee(i,j)*con2/r1)-(6.0*con3/r2))
C@FR     -           *ax(k)
C@FRC@TS            fcslt(k,i1)=fcslt(k,i1)+abcf
C@FR            fcjslv(k,j1)=fcjslv(k,j1)-abcf
C@FR          end do
          enb=enb+qee(i,j)*(con1+con2-con3)
        end do
      end do
      eslta=(enb+uc+cnn)
      if (escale .eq. 1.0) return
c     Take care of scaling now
      eslta=escale*eslta
C@FRC@TS      do i=1,nstta
C@FRC@TS        do k=1,3
C@FRC@TS          fcslt(k,i)=escale*fcslt(k,i)
C@FRC@TS        end do
C@FRC@TS      end do
      nsvst=nslvst(2)
C@FR      do j=1,nsvst
C@FR        do k=1,3
C@FR          fcjslv(k,j)=escale*fcjslv(k,j)
C@FR        end do
C@FR      end do
      return
220   format('*** Van der Waals envelopes of solute and solvent',
     -  ' molecs overlap, energy=',f10.5,' kcal/mol')
      end
      subroutine epsltslv(cst,csv,icmg,cmv,cent,ixst,maxix,igrslt,
     -  igf1,igl1,igf2,igl2,nml,ngmax,ngf,ngl,msvfirst,msvlast,icopy,
     -  iopst,ianslt,tex,vrslt,tsind,frc,trqis,trq,e01st,rijpso,rijps,
     -  rphs0iso,rphs0is,iaphsslt,ipsdist,ipxo,ipxn,etotp,etotpsc,
     -  virsump,nstta,realmx)
c#    MMC routine 195 lstmod: 05/16/17
c*****Calculates water-solute interaction energies between all solvents
c     and part of the solute. Solute indices are in ixst, grouped into
c     ng groups. The atomindices for each group ig are from ngf(ig) to
c     ngl(ig)
      real*8 etotp,etotpsc,virsump
      dimension cst(3,#ST),csv(3,#NA),cent(3),icmg(#GR),
     -  cmv(3,#MO),ixst(maxix),igrslt(#ST),ngf(ngmax),ngl(ngmax),
     -  ianslt(#ST),rijpso(#MO),rijps(#MO),rphs0iso(#MS),
     -  rphs0is(#MS),ipxo(#MO),ipxn(#MO),iopst(ngmax),
     -  iaphsslt(#ST),tex(#MO),vrslt(3,#MO),tsind(3,#MO),
     -  frc(3,#MO),trqis(3,#MO),trq(3,#MO),e01st(2,#MO),
     -  virsump(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /reactionfield/ epsrf,rccon
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      common /allpfdat/ c6clm(#AT,2),c12clm(#AT,2),c1clm(#AT,2),
     -  rminamb02(#AT),enminamb02(#AT),sigamb02(#AT),epsamb(#AT),
     -  rmin94(#AT),enmin94(#AT),sigkol94(#AT),epskol94(#AT),
     -  rmincha(#AT),emincha(#AT),sigcha(#AT),epscha(#AT),
     -  c6bvg(#AT),c12bvg(#AT),sigbvg(#AT),epsbvg(#AT),
     -  c6bvg14(#AT),c12bvg14(#AT),sigbvg14(#AT),epsbvg14(#AT),
     -  sigjrg(#AT),epsjrg(#AT),qjrg(#AT),c6jrg(#AT),c12jrg(#AT),
     -  emincha14(#AT),rmincha14(#AT),sigcha14(#AT),epscha14(#AT),
     -  c6gro(#AT),c12gro(#AT),siggro(#AT),epsgro(#AT),c6gro14(#AT),
     -  c12gro14(#AT),siggro14(#AT),epsgro14(#AT),sighs(#AT)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /frind2/ crat6,crat1
      common /frind6/ crat60,crat61,crat10,crat11,cpl0tix(3),cpl1tix(3)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      common /ecell/ cic(3,27),ncell
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      dimension crmslt(3),d(3),igf(2),igl(2)
      dimension c6ji1(#ST),c12ji1(#ST)
      real*8 uind120,uind60,uind10
      equivalence (c6ji1(1),c6ji(1,1)),(c12ji1(1),c12ji(1,1))
      data vdwo /0.0/
C@PS      write (6,1111)
C@PS1111  format(' The subroutines epsltslv, esltsltmm,and esltslttmm have',
C@PS     -  ' to be replaced ',/,
C@PS     -  'with the parallelizable versions')
C@PS      call datprt(2)
      if (iop(26) .eq. 3) then
        write (6,2222)
2222    format(' TIP5P is not implemented with partial solute changes')
        call datprt(2)
      end if
      etotpsc=0.d0
      etotp=0.d0
      tex(1)=0
      do k=1,3
        virsump(k)=0.d0
        tsind(k,1)=0.d0
      end do
      kxmn=1
      if (iop(2) .eq. 1) then
        kxmn=2
        do is=msvfirst,msvlast
          zv(1,is)=0.0
        end do
      end if
      if (iop(30) .ne. 5 .or. icopy .eq. 3) then
        crat1=1.0
        crat6=1.0
      else
        if (icopy .eq. 1) then
          crat1=crat11
          crat6=crat61
        else
          crat1=crat10
          crat6=crat60
        end if
        if (icopy .ne. 3) then
          do is=msvfirst,msvlast
            e01st(icopy,is)=0.0
          end do
        end if
      end if
      crat66=crat6*6.0
      do is=msvfirst,msvlast
        tex(is)=0.0
        do k=1,3
C@FR          vrslt(k,is)=0.0
C@FR          frc(k,is)=0.0
C@FR          trq(k,is)=0.0
C@FRC@FR          trqis(k,is)=0.0
          tsind(k,is)=0.0
        end do
      end do
      iclh1=islvtp(2)
      iclh2=islvtp(3)
      icllp=islvtp(4)
      igf(1)=igf1
      igf(2)=igf2
      igl(1)=igl1
      igl(2)=igl2
      if (ipsdist .eq. 1) then
c       Set pref distance to a large value
        call zeroiti(ipxn,msvfirst-1,msvlast)
        do is=msvfirst,msvlast
          rijps(is)=10000.0
        end do
      end if
      do im=1,nml
        do ig=igf(im),igl(im)
          if (iop(43) .eq. 0) then
c           Use real COM
            do k=1,3
              crmslt(k)=cmv(k,1)
            end do
          else
            icmgg=icmg(igrslt(ixst(ngf(ig))))
            if (icmgg .eq. 0) then
              do k=1,3
                crmslt(k)=cent(k)
              end do
            else
              do k=1,3
                crmslt(k)=cst(k,icmgg)
              end do
            end if
          end if
c         Compute COM-COM distance
          do is=msvfirst,msvlast
            zv(1,is)=0.0
            do k=kxmn,3
              zv(k,is)=cmv(k,is)-crmslt(k)
            end do
          end do
          call pbcvec(iop(5),msvfirst,msvlast)
          do is=msvfirst,msvlast
            if (riijjv(is) .le. ctslts) then
              cmv1=cmv(1,is)
              cmv2=cmv(2,is)
              cmv3=cmv(3,is)
              is01=(is-2)*nslv+1
              is02=is01+1
              is03=is02+1
              is04=is03+1
              do k=kxmn,3
                d(k)=cci(k,is)
              end do
              if (iop(2) .eq. 0) then
                do iaa=ngf(ig),ngl(ig)
                  do k=1,3
                    zvv(k,ixst(iaa))=d(k)
                  end do
                end do
              else if (iop(2) .eq. 1) then
c               Infinite polymer in the x direction
                do iaa=ngf(ig),ngl(ig)
                  ia=ixst(iaa)
                  do k=1,3
                    zvv(k,ia)=d(k)
                  end do
                  zvv(1,ia)=zvv(1,ia)-
     -              dex(int((cst(1,ia)-cmv1)/edge2)+2)
                end do
              else
c               Crystal solute
                do iaa=ngf(ig),ngl(ig)
                  ia=ixst(iaa)
                  cix=cst(1,ia)-cmv1
                  ciy=cst(2,ia)-cmv2
                  ciz=cst(3,ia)-cmv3
                  kx=int(cix/edgex2)+3
                  ky=int(ciy/edgey2)+3
                  kz=int(ciz/edge2)+3
                  zvv(1,ia)=-dex(kx)
                  zvv(2,ia)=-dey(ky)
                  zvv(3,ia)=-dez(kz)
                end do
              end if
              uind120=0.d0
              uind60=0.d0
              uind10=0.d0
C@FR              fslv1=0.0
C@FR              fslv2=0.0
C@FR              fslv3=0.0
C@FRC@TS              do iaa=ngf(ig),ngl(ig)
C@FRC@TS                do k=1,3
C@FRC@TS                  fcslt(k,ixst(iaa))=0.0
C@FRC@TS                end do
C@FRC@TS              end do
              if (iopst(ig) .eq. 1) then
c---------------Clementi potential for solute-solvent
                do i=1,3
c                 Loop on water atoms
                  icli=islvtp(i)
C@FR                  fslva1=0.0
C@FR                  fslva2=0.0
C@FR                  fslva3=0.0
                  do iaa=ngf(ig),ngl(ig)
c                   Loop on the solute atoms
                    ia=ixst(iaa)
                    rxyz1v=csv(1,(is-2)*nslv+i)-cst(1,ia)+zvv(1,ia)
                    rxyz2v=csv(2,(is-2)*nslv+i)-cst(2,ia)+zvv(2,ia)
                    rxyz3v=csv(3,(is-2)*nslv+i)-cst(3,ia)+zvv(3,ia)
                    rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
                    rij=sqrt(rij2)
                    rij6=rij2*rij2*rij2
                    rij12=rij6*rij6
                    er1=(qji(ia,icli)/rij)
C@RF     -                *(1.0+rij*rij2*rccon)
                    er6=c6ji(ia,icli)/rij6
                    er12=c12ji(ia,icli)/rij12
                    uind120=uind120+dble(er12)
                    uind60=uind60+dble(er6)
                    uind10=uind10+dble(er1)
C@FR                    abcf=(crat66*er6-er12*12.0-crat1*er1)/rij2
C@FRC@TS                    fcslt(1,ia)=fcslt(1,ia)+abcf*rxyz1v
C@FRC@TS                    fcslt(2,ia)=fcslt(2,ia)+abcf*rxyz2v
C@FRC@TS                    fcslt(3,ia)=fcslt(3,ia)+abcf*rxyz3v
C@FR                    fslva1=fslva1-abcf*rxyz1v
C@FR                    fslva2=fslva2-abcf*rxyz2v
C@FR                    fslva3=fslva3-abcf*rxyz3v
                    if (i .eq. islvrep) r2stsv(ia)=rij2
                  end do
C@FR                  fslv1=fslv1+fslva1
C@FR                  fslv2=fslv2+fslva2
C@FR                  fslv3=fslv3+fslva3
C@FR                  dr1=csv(1,(is-2)*nslv+i)-cmv1
C@FR                  dr2=csv(2,(is-2)*nslv+i)-cmv2
C@FR                  dr3=csv(3,(is-2)*nslv+i)-cmv3
C@FR                  trq(1,is)=trq(1,is)+(dr2*fslva3-fslva2*dr3)
C@FR                  trq(2,is)=trq(2,is)+(dr3*fslva1-fslva3*dr1)
C@FR                  trq(3,is)=trq(3,is)+(dr1*fslva2-fslva1*dr2)
                end do
              else if (iopst(ig) .eq. 2) then
c---------------QPEN potential for solute-solvent
c               call qpen(a,b,riijj,eslta)
c               QPEN does not work in this context
                uind120=0.d0
                uind60=0.d0
                uind10=0.d0
                uitot=0.d0
                go to 9111
              else if (iopst(ig) .eq. 3 .or. iopst(ig) .eq. 4) then
c---------------Kollman, BVG or OPLS potential with TIP3P water (O,H1,H1)
C@FR                fslva1o=0.0
C@FR                fslva2o=0.0
C@FR                fslva3o=0.0
C@FR                fslva1h1=0.0
C@FR                fslva2h1=0.0
C@FR                fslva3h1=0.0
C@FR                fslva1h2=0.0
C@FR                fslva2h2=0.0
C@FR                fslva3h2=0.0
                do iaa=ngf(ig),ngl(ig)
c                 Loop on the solute atoms
                  ia=ixst(iaa)
                  cst1=cst(1,ia)-zvv(1,ia)
                  cst2=cst(2,ia)-zvv(2,ia)
                  cst3=cst(3,ia)-zvv(3,ia)
c                 Water oxygen
                  rxyz1o=csv(1,is01)-cst1
                  rxyz2o=csv(2,is01)-cst2
                  rxyz3o=csv(3,is01)-cst3
                  rij2o=rxyz1o*rxyz1o+rxyz2o*rxyz2o+rxyz3o*rxyz3o
                  rijo=sqrt(rij2o)
                  rij6o=rij2o*rij2o*rij2o
                  rij12o=rij6o*rij6o
                  er1o=(qji(ia,1)/rijo)
C@RF     -                *(1.0+rijo*rij2o*rccon)
                  er6=c6ji1(ia)/rij6o
                  er12=c12ji1(ia)/rij12o
                  r2stsv(ia)=rij2o
c                 First water hydrogen
                  rxyz1h1=csv(1,is02)-cst1
                  rxyz2h1=csv(2,is02)-cst2
                  rxyz3h1=csv(3,is02)-cst3
                  rij2h1=rxyz1h1*rxyz1h1+rxyz2h1*rxyz2h1+rxyz3h1*rxyz3h1
                  rijh1=sqrt(rij2h1)
                  er1h1=(qji(ia,2)/rijh1)
C@RF     -                *(1.0+rijh1*rij2h1*rccon)
c                 Second water hydrogen
                  rxyz1h2=csv(1,is03)-cst1
                  rxyz2h2=csv(2,is03)-cst2
                  rxyz3h2=csv(3,is03)-cst3
                  rij2h2=rxyz1h2*rxyz1h2+rxyz2h2*rxyz2h2+rxyz3h2*rxyz3h2
                  rijh2=sqrt(rij2h2)
                  er1h2=(qji(ia,2)/rijh2)
C@RF     -              *(1.0+rijh2*rij2h2*rccon)
c                 Energy contributions
                  uind120=uind120+dble(er12)
                  uind60=uind60+dble(er6)
                  uind10=uind10+dble(er1o)+dble(er1h1)+dble(er1h2)
C@FR                  abcfo=(crat66*er6-er12*12.0-crat1*er1o)/rij2o
C@FR                  abcfh1=-crat1*qji(ia,2)/(rij2h1*rijh1)
C@FR                  abcfh2=-crat1*qji(ia,2)/(rij2h2*rijh2)
C@FRC@TS                  fcslt(1,ia)=fcslt(1,ia)+abcfo*rxyz1o+
C@FRC@TS     -              abcfh1*rxyz1h1+abcfh2*rxyz1h2
C@FRC@TS                  fcslt(2,ia)=fcslt(2,ia)+abcfo*rxyz2o+
C@FRC@TS     -              abcfh1*rxyz2h1+abcfh2*rxyz2h2
C@FRC@TS                  fcslt(3,ia)=fcslt(3,ia)+abcfo*rxyz3o+
C@FRC@TS     -              abcfh1*rxyz3h1+abcfh2*rxyz3h2
C@FR                  fslva1o=fslva1o-abcfo*rxyz1o
C@FR                  fslva2o=fslva2o-abcfo*rxyz2o
C@FR                  fslva3o=fslva3o-abcfo*rxyz3o
C@FR                  fslva1h1=fslva1h1-abcfh1*rxyz1h1
C@FR                  fslva2h1=fslva2h1-abcfh1*rxyz2h1
C@FR                  fslva3h1=fslva3h1-abcfh1*rxyz3h1
C@FR                  fslva1h2=fslva1h2-abcfh2*rxyz1h2
C@FR                  fslva2h2=fslva2h2-abcfh2*rxyz2h2
C@FR                  fslva3h2=fslva3h2-abcfh2*rxyz3h2
                end do
C@FR                fslv1=fslva1o+fslva1h1+fslva1h2
C@FR                fslv2=fslva2o+fslva2h1+fslva2h2
C@FR                fslv3=fslva3o+fslva3h1+fslva3h2
C@FRc               Torque contributions
C@FR                dr1o=csv(1,is01)-cmv1
C@FR                dr2o=csv(2,is01)-cmv2
C@FR                dr3o=csv(3,is01)-cmv3
C@FR                dr1h1=csv(1,is02)-cmv1
C@FR                dr2h1=csv(2,is02)-cmv2
C@FR                dr3h1=csv(3,is02)-cmv3
C@FR                dr1h2=csv(1,is03)-cmv1
C@FR                dr2h2=csv(2,is03)-cmv2
C@FR                dr3h2=csv(3,is03)-cmv3
C@FR                trq(1,is)=trq(1,is)+(dr2o*fslva3o-fslva2o*dr3o)+
C@FR     -            (dr2h1*fslva3h1-fslva2h1*dr3h1)+
C@FR     -            (dr2h2*fslva3h2-fslva2h2*dr3h2)
C@FR                trq(2,is)=trq(2,is)+(dr3o*fslva1o-fslva3o*dr1o)+
C@FR     -            (dr3h1*fslva1h1-fslva3h1*dr1h1)+
C@FR     -            (dr3h2*fslva1h2-fslva3h2*dr1h2)
C@FR                trq(3,is)=trq(3,is)+(dr1o*fslva2o-fslva1o*dr2o)+
C@FR     -            (dr1h1*fslva2h1-fslva1h1*dr2h1)+
C@FR     -            (dr1h2*fslva2h2-fslva1h2*dr2h2)
              else if (iopst(ig) .eq. 6) then
c---------------Kollman, BVG or OPLS potential for with TIP4P water (O,H1,H2,LP)
C@FR                fslva1o=0.0
C@FR                fslva2o=0.0
C@FR                fslva3o=0.0
C@FR                fslva1h1=0.0
C@FR                fslva2h1=0.0
C@FR                fslva3h1=0.0
C@FR                fslva1h2=0.0
C@FR                fslva2h2=0.0
C@FR                fslva3h2=0.0
C@FR                fslva1lp=0.0
C@FR                fslva2lp=0.0
C@FR                fslva3lp=0.0
                do iaa=ngf(ig),ngl(ig)
c                 Loop on the solute atoms
                  ia=ixst(iaa)
                  cst1=cst(1,ia)-zvv(1,ia)
                  cst2=cst(2,ia)-zvv(2,ia)
                  cst3=cst(3,ia)-zvv(3,ia)
c                 Water oxygen
                  rxyz1o=csv(1,is01)-cst1
                  rxyz2o=csv(2,is01)-cst2
                  rxyz3o=csv(3,is01)-cst3
                  rij2o=rxyz1o*rxyz1o+rxyz2o*rxyz2o+rxyz3o*rxyz3o
                  rij6o=rij2o*rij2o*rij2o
                  rij12o=rij6o*rij6o
                  er6=c6ji1(ia)/rij6o
                  er12=c12ji1(ia)/rij12o
                  r2stsv(ia)=rij2o
c                 First water hydrogen
                  rxyz1h1=csv(1,is02)-cst1
                  rxyz2h1=csv(2,is02)-cst2
                  rxyz3h1=csv(3,is02)-cst3
                  rij2h1=rxyz1h1*rxyz1h1+rxyz2h1*rxyz2h1+rxyz3h1*rxyz3h1
                  rijh1=sqrt(rij2h1)
                  er1h1=(qji(ia,iclh1)/rijh1)
C@RF     -                *(1.0+rijh1*rij2h1*rccon)
c                 Second water hydrogen
                  rxyz1h2=csv(1,is03)-cst1
                  rxyz2h2=csv(2,is03)-cst2
                  rxyz3h2=csv(3,is03)-cst3
                  rij2h2=rxyz1h2*rxyz1h2+rxyz2h2*rxyz2h2+rxyz3h2*rxyz3h2
                  rijh2=sqrt(rij2h2)
                  er1h2=(qji(ia,iclh2)/rijh2)
C@RF     -                *(1.0+rijh2*rij2h2*rccon)
c                 "Lone pair" center
                  rxyz1lp=csv(1,is04)-cst1
                  rxyz2lp=csv(2,is04)-cst2
                  rxyz3lp=csv(3,is04)-cst3
                  rij2lp=rxyz1lp*rxyz1lp+rxyz2lp*rxyz2lp+rxyz3lp*rxyz3lp
                  rijlp=sqrt(rij2lp)
                  er1lp=(qji(ia,icllp)/rijlp)
C@RF     -                *(1.0+rijlp*rij2lp*rccon)
c                 Energy contributions
                  uind120=uind120+dble(er12)
                  uind60=uind60+dble(er6)
                  uind10=uind10+dble(er1h1)+dble(er1h2)+dble(er1lp)
c                 Force contributions
C@FR                  abcfo=(crat66*er6-er12*12.0)/rij2o
C@FR                  abcfh1=-crat1*qji(ia,2)/(rij2h1*rijh1)
C@FR                  abcfh2=-crat1*qji(ia,2)/(rij2h2*rijh2)
C@FR                  abcflp=-crat1*qji(ia,1)/(rij2lp*rijlp)
C@FRC@TS                  fcslt(1,ia)=fcslt(1,ia)+abcfo*rxyz1o+
C@FRC@TS     -              abcfh1*rxyz1h1+abcfh2*rxyz1h2+abcflp*rxyz1lp
C@FRC@TS                  fcslt(2,ia)=fcslt(2,ia)+abcfo*rxyz2o+
C@FRC@TS     -              abcfh1*rxyz2h1+abcfh2*rxyz2h2+abcflp*rxyz2lp
C@FRC@TS                  fcslt(3,ia)=fcslt(3,ia)+abcfo*rxyz3o+
C@FRC@TS     -              abcfh1*rxyz3h1+abcfh2*rxyz3h2+abcflp*rxyz3lp
C@FR                  fslva1o=fslva1o-abcfo*rxyz1o
C@FR                  fslva2o=fslva2o-abcfo*rxyz2o
C@FR                  fslva3o=fslva3o-abcfo*rxyz3o
C@FR                  fslva1h1=fslva1h1-abcfh1*rxyz1h1
C@FR                  fslva2h1=fslva2h1-abcfh1*rxyz2h1
C@FR                  fslva3h1=fslva3h1-abcfh1*rxyz3h1
C@FR                  fslva1h2=fslva1h2-abcfh2*rxyz1h2
C@FR                  fslva2h2=fslva2h2-abcfh2*rxyz2h2
C@FR                  fslva3h2=fslva3h2-abcfh2*rxyz3h2
C@FR                  fslva1lp=fslva1lp-abcflp*rxyz1lp
C@FR                  fslva2lp=fslva2lp-abcflp*rxyz2lp
C@FR                  fslva3lp=fslva3lp-abcflp*rxyz3lp
                end do
C@FR                fslv1=fslva1o+fslva1h1+fslva1h2+fslva1lp
C@FR                fslv2=fslva2o+fslva2h1+fslva2h2+fslva2lp
C@FR                fslv3=fslva3o+fslva3h1+fslva3h2+fslva3lp
C@FRc               Torque contributions
C@FR                dr1o=csv(1,is01)-cmv1
C@FR                dr2o=csv(2,is01)-cmv2
C@FR                dr3o=csv(3,is01)-cmv3
C@FR                dr1h1=csv(1,is02)-cmv1
C@FR                dr2h1=csv(2,is02)-cmv2
C@FR                dr3h1=csv(3,is02)-cmv3
C@FR                dr1h2=csv(1,is03)-cmv1
C@FR                dr2h2=csv(2,is03)-cmv2
C@FR                dr3h2=csv(3,is03)-cmv3
C@FR                dr1lp=csv(1,is04)-cmv1
C@FR                dr2lp=csv(2,is04)-cmv2
C@FR                dr3lp=csv(3,is04)-cmv3
C@FR                trq(1,is)=trq(1,is)+(dr2o*fslva3o-fslva2o*dr3o)+
C@FR     -            (dr2h1*fslva3h1-fslva2h1*dr3h1)+
C@FR     -            (dr2h2*fslva3h2-fslva2h2*dr3h2)+
C@FR     -            (dr2lp*fslva3lp-fslva2lp*dr3lp)
C@FR                trq(2,is)=trq(2,is)+(dr3o*fslva1o-fslva3o*dr1o)+
C@FR     -            (dr3h1*fslva1h1-fslva3h1*dr1h1)+
C@FR     -            (dr3h2*fslva1h2-fslva3h2*dr1h2)+
C@FR     -            (dr3lp*fslva1lp-fslva3lp*dr1lp)
C@FR                trq(3,is)=trq(3,is)+(dr1o*fslva2o-fslva1o*dr2o)+
C@FR     -            (dr1h1*fslva2h1-fslva1h1*dr2h1)+
C@FR     -            (dr1h2*fslva2h2-fslva1h2*dr2h2)+
C@FR     -            (dr1lp*fslva2lp-fslva1lp*dr2lp)
              else if (iopst(ig) .eq. 7) then
c---------------Kollman, BVG or OPLS potential for solute-general solvent
                do i=1,nslv
C@FR                  fslva1=0.0
C@FR                  fslva2=0.0
C@FR                  fslva3=0.0
                  do iaa=ngf(ig),ngl(ig)
c                   Loop on the solute atoms
                    ia=ixst(iaa)
                    rxyz1v=csv(1,(is-2)*nslv+i)-cst(1,ia)+zvv(1,ia)
                    rxyz2v=csv(2,(is-2)*nslv+i)-cst(2,ia)+zvv(2,ia)
                    rxyz3v=csv(3,(is-2)*nslv+i)-cst(3,ia)+zvv(3,ia)
                    rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
                    rij=sqrt(rij2)
                    rij6=rij2*rij2*rij2
                    rij12=rij6*rij6
                    er6=c6tv(ia,i)/rij6
                    er12=c12tv(ia,i)/rij12
                    qr=(qtv(ia,i)/rij)
C@RF     -              *(1.0+rij*rij2*rccon)
C@DD     -              *dd_ms_inter(rij)
                    uind120=uind120+dble(er12)
                    uind60=uind60+dble(er6)
                    uind10=uind10+dble(qr)
C@FR                    abcf=(crat66*er6-er12*12.0-crat1*qr)/rij2
C@FRC@TS                    fcslt(1,ia)=fcslt(1,ia)+abcf*rxyz1v
C@FRC@TS                    fcslt(2,ia)=fcslt(2,ia)+abcf*rxyz2v
C@FRC@TS                    fcslt(3,ia)=fcslt(3,ia)+abcf*rxyz3v
C@FR                      fslva1=fslva1-abcf*rxyz1v
C@FR                      fslva2=fslva2-abcf*rxyz2v
C@FR                      fslva3=fslva3-abcf*rxyz3v
                      if (i .eq. islvrep) r2stsv(ia)=rij2
                  end do
C@FR                    fslv1=fslv1+fslva1
C@FR                    fslv2=fslv2+fslva2
C@FR                    fslv3=fslv3+fslva3
C@FR                    dr1=csv(1,(is-2)*nslv+i)-cmv1
C@FR                    dr2=csv(2,(is-2)*nslv+i)-cmv2
C@FR                  dr3=csv(3,(is-2)*nslv+i)-cmv3
C@FRC@DB                  trq1=(dr2*fslva3-fslva2*dr3)
C@FRC@DB                  trq2=(dr3*fslva1-fslva3*dr1)
C@FRC@DB                  trq3=(dr1*fslva2-fslva1*dr2)
C@FRC@DB                  write (6,7724) ia,fslva1,fslva2,fslva3,dr1,dr2,dr3,
C@FRC@DB     -              trq1,trq2,trq3
C@FRC@DB7724              format(' EPSLTSLV ia=',i3,' fi=',3e13.6,' dr=',3f10.6,
C@FRC@DB     -              ' trqi=',3e13.6)
C@FR                  trq(1,is)=trq(1,is)+(dr2*fslva3-fslva2*dr3)
C@FR                  trq(2,is)=trq(2,is)+(dr3*fslva1-fslva3*dr1)
C@FR                  trq(3,is)=trq(3,is)+(dr1*fslva2-fslva1*dr2)
                end do
              else if (iopst(ig) .eq. 8) then
c---------------Hard sphere
                if (ignorehs .eq. 0) then
                  do iaa=ngf(ig),ngl(ig)
c                   Loop on the solute atoms
                    ia=ixst(iaa)
                    rxyz1v=csv(1,(is-2)*nslv+islvrep)-
     -                cst(1,ia)+zvv(1,ia)
                    rxyz2v=csv(2,(is-2)*nslv+islvrep)-
     -                cst(2,ia)+zvv(2,ia)
                    rxyz3v=csv(3,(is-2)*nslv+islvrep)-
     -                cst(3,ia)+zvv(3,ia)
                    rij2=rxyz1v*rxyz1v+rxyz2v*rxyz2v+rxyz3v*rxyz3v
                    r2stsv(ia)=rij2
                    if (rij2 .lt. c12ji(ia,1)) then
                      uind120=realmx
                      go to 999
                    end if
                  end do
                end if
              end if
c-------------Part common to all pf's
C@FR              frc(1,is)=frc(1,is)+fslv1
C@FR              frc(2,is)=frc(2,is)+fslv2
C@FR              frc(3,is)=frc(3,is)+fslv3
              tsind(1,is)=tsind(1,is)+uind120
              tsind(2,is)=tsind(2,is)+uind60*crat6
              tsind(3,is)=tsind(3,is)+uind10*crat1
              if (icopy .ne. 3)
     -          e01st(icopy,is)=e01st(icopy,is)+uind120-uind60+uind10
              tex(is)=tex(is)+
     -          uind10*dble(crat1)-uind60*dble(crat6)+uind120
c             Calculate virial sum contribution
C@FR              vrslt(1,is)=vrslt(1,is)-zv(1,is)*fslv1
C@FR              vrslt(2,is)=vrslt(2,is)-zv(2,is)*fslv2
C@FR              vrslt(3,is)=vrslt(3,is)-zv(3,is)*fslv3
C@FRC@TSc             Calculate solvent contribution to torque on the solute
C@FRC@TS              torqs1=0.0
C@FRC@TS              torqs2=0.0
C@FRC@TS              torqs3=0.0
C@FRC@TS              do iaa=ngf(ig),ngl(ig)
C@FRC@TS                ia=ixst(iaa)
C@FRC@TS                dr1=cst(1,ia)-cmv(1,1)
C@FRC@TS                dr2=cst(2,ia)-cmv(2,1)
C@FRC@TS                dr3=cst(3,ia)-cmv(3,1)
C@FRC@TS                torqs1=torqs1+(dr2*fcslt(3,ia)-fcslt(2,ia)*dr3)
C@FRC@TS                torqs2=torqs2+(dr3*fcslt(1,ia)-fcslt(3,ia)*dr1)
C@FRC@TS                torqs3=torqs3+(dr1*fcslt(2,ia)-fcslt(1,ia)*dr2)
C@FRC@TS              end do
C@FRC@TS              trqis(1,is)=trqis(1,is)+torqs1
C@FRC@TS              trqis(2,is)=trqis(2,is)+torqs2
C@FRC@TS              trqis(3,is)=trqis(3,is)+torqs3
999           if (ipsdist .eq. 1) then
c               Check if the PS distance array has to be updated
                do iaa=ngf(ig),ngl(ig)
c                 Loop on the solute atoms
                  ia=ixst(iaa)
                  if (iaphsslt(ia) .gt. 1) then
                    if (r2stsv(ia) .lt. rijps(is)) then
                      rijps(is)=r2stsv(ia)
                      ipxn(is)=ia
                      if (iop(92) .gt. 0) then
                        if (iop(92) .eq. 1) then
                          texng(is)=vdw(ianslt(ia))
                        else if (iop(92) .eq. 2) then
                          texng(is)=sigslt(ia)/2.0
                        end if
                      end if
                    end if
                  end if
                end do
              end if
            end if
          end do
        end do
      end do
      if (ipsdist .eq. 1) then
        call zeroiti(indexx,0,nstta)
        do im=1,nml
          do ig=igf(im),igl(im)
            do iaa=ngf(ig),ngl(ig)
              indexx(ixst(iaa))=1
            end do
          end do
        end do
        if (iop(92) .gt. 0) then
          do is=msvfirst,msvlast
            if (ipxn(is) .eq. 0) then
              rijps(is)=rijpso(is)
              rphs0is(is)=rphs0iso(is)
              ipxn(is)=ipxo(is)
            else
              rijps2=rijps(is)
              sqrijps2=sqrt(rijps2)
              rphs0is(is)=sqrijps2
              rijps(is)=amax1(0.0,sqrijps2-texng(is))
              if (iop(92) .eq. 1) then
                vdwo=vdw(ianslt(ipxo(is)))
              else if (iop(92) .eq. 2) then
                vdwo=sigslt(ipxo(is))/2.0
              end if
              if (indexx(ipxo(is)) .eq. 0) then
                if (rijpso(is)+vdwo .lt. rijps(is)+texng(is)) then
                  rijps(is)=rijpso(is)
                  ipxn(is)=ipxo(is)
                  rphs0is(is)=rphs0iso(is)
                end if
              else if (rijps(is)+texng(is) .gt.
     -           rijpso(is)+vdwo-1.e-5) then
c               Too bad - has to check all solute atoms to be sure
                call phspx(is,ipx,rpx,rpx0,sqrpx0,iaphsslt)
                if (rpx0 .lt. rijps2) then
                  rijps(is)=rpx
                  ipxn(is)=ipx
                  rphs0is(is)=sqrpx0
                end if
              end if
            end if
          end do
        else
c         No PHS, just update rijps
          do is=msvfirst,msvlast
            if (ipxn(is) .eq. 0) then
              rijps(is)=rijpso(is)
              ipxn(is)=ipxo(is)
            else
              if (indexx(ipxo(is)) .eq. 0) then
c               Nearest solute atom before move was not moved
                if (rijps(is) .gt. rijpso(is)) then
c                 Nothing better - retain old values
                  rijps(is)=rijpso(is)
                  ipxn(is)=ipxo(is)
                end if
c             else
c               Nearest solute atom before move was moved
c               To keep everything perfect, when  rijps(is)>rijpso(is)
c               a full search should be done, but this is too expensive
c               Instead, self-test tolerance will be relaxed
              end if
            end if
          end do
        end if
      end if
9111  if (iop(43) .eq. 1) then
c       Recalculate COM distances based on real COM for sphere contribution
        do is=msvfirst,msvlast
          do k=1,3
            zv(k,is)=cmv(k,is)-cmv(k,1)
          end do
        end do
        call pbcvec(iop(5),msvfirst,msvlast)
      end if
C@DB      write (6,7122) crat1,crat6,(tex(is),is=msvfirst,msvlast)
C@DB7122  format(' EPSLTSLV crat1,6=',2f6.4,' tex=',(5e12.5))
      do is=msvfirst,msvlast
        if (riijjv(is) .lt. rinscs) etotpsc=etotpsc+tex(is)
        etotp=etotp+tex(is)
C@FR        do k=1,3
C@FR          virsump(k)=virsump(k)+vrslt(k,is)
C@FR        end do
      end do
      return
      end
      subroutine esltsltt(cst,ixst,molsltf,molslt,molfst,mollst,igrmf,
     -  igrml,igraf,igral,ifgg,ilgg,ifgga,ilgga,ifsta,ilsta,ilhbsta,
     -  mapbit,maxbw,maxba,nbits,istf,nslt,iclsltt,qslt,mol,l0lim,l1lim,
     -  cpl0,cpl1,gsuml0,gsuml1,igrslt,igrcnt,molcnt,cent,beg,begr,
     -  begself,iop5,ioppbcm,iself,indexx,iclslttt,qsltt,cgs,cutuus,
     -  noeng,maxtorat,maxgg)
c#    MMC routine 196 lstmod: 08/30/17
c*****Calculates solute-solute interaction energies between solute atoms
c     affected by a solute torsion. Solute indices are in ixst
c     iself=0: only inter; iself=1: inter+intra; iself=2: only intra
      real*8 beg,begr,begself,gsuml0,gsuml1,engrow
      real*8 beg12,beg6,beg1
C@NL      logical mapbit
C@D4      common /eijmol/ eijslto(#ST,#ST),eijsltn(#ST,#ST),
C@D4     -  eijslt(#ST,#ST)
      dimension cst(3,#ST),ixst(maxtorat),indexx(#ST),
     -  iclslttt(#ST),beg(#ST),begr(#ST),mapbit(maxbw,maxba),
     -  iclsltt(#ST),qslt(#ST),cent(3),molfst(#MM),mollst(#MM),
     -  igraf(#GR),igral(#GR),igrmf(#MM),igrml(#MM),ifgga(maxgg),
     -  ilgga(maxgg),igrslt(#ST),igrcnt(#GR),molcnt(#MM),
     -  cgs(3,#UV),qsltt(#ST),cpl0(3),cpl1(3),cpl(3),
     -  beg12(#FE),beg6(#FE),beg1(#FE),
     -  c0(3),c0m(3),gsuml0(3),gsuml1(3),shift(3)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      real*8 beg2
      common /begwork/ beg2(#ST)
C@dc      character*4 labcall
C@dc      common /testprint/ labcall
      data minus1 /-1/
      enfgrow=0.d0
      if (noeng .gt. 0) then
        begself=0.d0
        return
      end if
      if (noeng .gt. 1) return
      if (iself .le. 1) then
        do ia=1,nslt
          beg(ia)=0.d0
          begr(ia)=0.d0
        end do
        istfnofe=istf
        ifemm=0
        molsltdiff=0
        if (l1lim .gt. 0) then
          istfnofe=l1lim+1
          do ia=1,l1lim
            beg12(ia)=0.d0
            beg6(ia)=0.d0
            beg1(ia)=0.d0
          end do
c         With TI/CA separate fe calls when torsion is not on an FE molecule
          if (molfst(mol) .gt. l1lim) then
            ifemm=1
          else
            ifemm=2
            molsltdiff=-1
            if (molfst(mol) .le. l0lim) then
              call trnsfr(cpl,cpl0,3)
            else
              call trnsfr(cpl,cpl1,3)
            end if
          end if
        end if
        if (molslt-molsltf .gt. molsltdiff .or. mol .lt. molsltf) then
c         For each PBC/cutoff option gather the list and
c         calculate the intermolecular eng
          ifdiff=0
c         ifdiff is the first solute atom gathered for calculation where
c         indexx(ia) .ne. ia
          if (istf .gt. 1) call zeroiti(indexx,0,istf-1)
          if (ioppbcm .eq. 0) then
c===========No PBC
c           Just gather the ones to be used
            natsdo=istf-1
            do im=molsltf,molslt
              if (im .ne. mol) then
                do ia=molfst(im),mollst(im)
                  natsdo=natsdo+1
                  do k=1,3
                    cgs(k,natsdo)=cst(k,ia)
                  end do
                  iclslttt(natsdo)=iclsltt(ia)
                  qsltt(natsdo)=qslt(ia)
                  indexx(natsdo)=ia
                end do
              else if (ifdiff .eq. 0) then
                ifdiff=natsdo+1
              end if
            end do
            if (ifemm .eq. 2) then
              call esltslttmmfe3(cst,cgs,beg12,beg6,beg1,beg,iclsltt,
     -          iclslttt,qslt,qsltt,ixst,ifsta,ilsta,cpl,
     -          istfnofe,natsdo)
            else
              if (ifemm .eq. 1)
     -          call esltslttmmfe(cst,cgs,beg12,beg6,beg1,begr,
     -            iclsltt,iclslttt,qslt,qsltt,ixst,ifsta,ilsta,
     -            cpl0,cpl1,l0lim,l1lim,indexx,minus1)
              call esltslttmm(cst,cgs,beg,begr,iclsltt,iclslttt,
     -          qslt,qsltt,ixst,ifsta,ilsta,istfnofe,natsdo,indexx)
            end if
          else if (ioppbcm .eq. 1) then
c===========Molec-based PBC
c           Obtain the PBC shifts and gather coords
c           Use input center if center index is zero
            call getcent(c0,cent,cst,molcnt(mol))
            natsdo=istf-1
            do im=molsltf,molslt
              natsdoprev=natsdo
              if (im .ne. mol) then
                call getcent(c0m,cent,cst,molcnt(im))
                call esltsltpbc(c0,c0m,shift,ishift,iop5,riijj)
                if (ishift .eq. 0) then
                  call trnsfr(cgs(1,natsdo+1),cst(1,molfst(im)),
     -              3*(mollst(im)-molfst(im)+1))
                else
                  do ia=molfst(im),mollst(im)
                    call arrdiff(cgs(1,ia-molfst(im)+natsdo+1),
     -                cst(1,ia),shift,3)
                  end do
                end if
                do ia=molfst(im),mollst(im)
                  natsdo=natsdo+1
                  iclslttt(natsdo)=iclsltt(ia)
                  qsltt(natsdo)=qslt(ia)
                  indexx(natsdo)=ia
                end do
              end if
              if (ifdiff .eq. 0) then
                if (natsdoprev .eq. natsdo) ifdiff=natsdo+1
              end if
            end do
            if (ifemm .eq. 2) then
              call esltslttmmfe3(cst,cgs,beg12,beg6,beg1,beg,iclsltt,
     -          iclslttt,qslt,qsltt,ixst,ifsta,ilsta,cpl,
     -          istfnofe,natsdo)
            else
              if (ifemm .eq. 1)
     -          call esltslttmmfe(cst,cgs,beg12,beg6,beg1,begr,
     -            iclsltt,iclslttt,qslt,qsltt,ixst,ifsta,ilsta,
     -            cpl0,cpl1,l0lim,l1lim,indexx,minus1)
              call esltslttmm(cst,cgs,beg,begr,iclsltt,iclslttt,
     -          qslt,qsltt,ixst,ifsta,ilsta,istfnofe,natsdo,indexx)
            end if
          else if (ioppbcm .eq. 2) then
c===========Molec-based PBC with cutoff
c           Obtain the PBC shifts and gather coords
c           Use input center if center indexx is zero
            call getcent(c0,cent,cst,molcnt(mol))
            natsdo=istf-1
            do im=molsltf,molslt
              if (im .ne. mol) then
                call getcent(c0m,cent,cst,molcnt(im))
                call esltsltpbc(c0,c0m,shift,ishift,iop5,riijj)
                if (riijj .lt. cutuus) then
                  if (ishift .eq. 0) then
                    call trnsfr(cgs(1,natsdo+1),cst(1,molfst(im)),
     -                3*(mollst(im)-molfst(im)+1))
                  else
                    do ia=molfst(im),mollst(im)
                      call arrdiff(cgs(1,ia-molfst(im)+natsdo+1),
     -                  cst(1,ia),shift,3)
                    end do
                  end if
                  do ia=molfst(im),mollst(im)
                    natsdo=natsdo+1
                    iclslttt(natsdo)=iclsltt(ia)
                    qsltt(natsdo)=qslt(ia)
                    indexx(natsdo)=ia
                  end do
                else if (ifdiff .eq. 0) then
                  ifdiff=natsdo+1
                end if
              else if (ifdiff .eq. 0) then
                ifdiff=natsdo+1
              end if
            end do
            if (ifemm .eq. 2) then
              call esltslttmmfe3(cst,cgs,beg12,beg6,beg1,beg,iclsltt,
     -          iclslttt,qslt,qsltt,ixst,ifsta,ilsta,cpl,
     -          istfnofe,natsdo)
            else
              if (ifemm .eq. 1)
     -          call esltslttmmfe(cst,cgs,beg12,beg6,beg1,begr,
     -            iclsltt,iclslttt,qslt,qsltt,ixst,ifsta,ilsta,
     -            cpl0,cpl1,l0lim,l1lim,indexx,minus1)
              call esltslttmm(cst,cgs,beg,begr,iclsltt,iclslttt,
     -          qslt,qsltt,ixst,ifsta,ilsta,istfnofe,natsdo,indexx)
            end if
          else if (ioppbcm .eq. 3) then
c===========Group-based PBC
c           Obtain the PBC shifts and gather coords
            do igg=ifgg,ilgg
              igno=igrslt(ixst(ifgga(igg)))
              do k=1,3
                c0(k)=cst(k,igrcnt(igno))
              end do
              natsdo=istf-1
              do im=molsltf,molslt
                if (im .ne. mol) then
                  do ig=igrmf(im),igrml(im)
                    call esltsltpbc(c0,cst(1,igrcnt(ig)),shift,ishift,
     -                iop5,riijj)
 
 
                    if (ishift .eq. 0) then
                      call trnsfr(cgs(1,natsdo+1),cst(1,igraf(ig)),
     -                  3*(igral(ig)-igraf(ig)+1))
                    else
                      do ia=igraf(ig),igral(ig)
                        call arrdiff(cgs(1,ia-igraf(ig)+natsdo+1),
     -                    cst(1,ia),shift,3)
                      end do
                    end if
                    do ia=igraf(ig),igral(ig)
                      natsdo=natsdo+1
                      iclslttt(natsdo)=iclsltt(ia)
                      qsltt(natsdo)=qslt(ia)
                      indexx(natsdo)=ia
                    end do
                  end do
                else if (ifdiff .eq. 0) then
                  ifdiff=natsdo+1
                end if
              end do
              if (ifemm .eq. 2) then
                call esltslttmmfe3(cst,cgs,beg12,beg6,beg1,beg,iclsltt,
     -            iclslttt,qslt,qsltt,ixst,ifgga(igg),ilgga(igg),cpl,
     -            istfnofe,natsdo)
              else
                if (ifemm .eq. 1)
     -            call esltslttmmfe(cst,cgs,beg12,beg6,beg1,begr,
     -              iclsltt,iclslttt,qslt,qsltt,ixst,ifgga(igg),
     -              ilgga(igg),cpl0,cpl1,l0lim,l1lim,indexx,ifdiff)
                call esltslttmm(cst,cgs,beg,begr,iclsltt,iclslttt,
     -            qslt,qsltt,ixst,ifgga(igg),ilgga(igg),istfnofe,natsdo,
     -            indexx)
              end if
            end do
          else if (ioppbcm .eq. 4) then
c===========Group-based PBC with cutoff
c           Obtain the PBC shifts and gather coords
            do igg=ifgg,ilgg
              call zeroitd(beg2,nslt)
              igno=igrslt(ixst(ifgga(igg)))
              do k=1,3
                c0(k)=cst(k,igrcnt(igno))
              end do
              natsdo=istf-1
              do im=molsltf,molslt
                if (im .ne. mol) then
                  do ig=igrmf(im),igrml(im)
                    call esltsltpbc(c0,cst(1,igrcnt(ig)),shift,ishift,
     -                iop5,riijj)
                    if (riijj .lt. cutuus) then
                      if (ishift .eq. 0) then
                        call trnsfr(cgs(1,natsdo+1),cst(1,igraf(ig)),
     -                    3*(igral(ig)-igraf(ig)+1))
                      else
                        do ia=igraf(ig),igral(ig)
                          call arrdiff(cgs(1,ia-igraf(ig)+natsdo+1),
     -                      cst(1,ia),shift,3)
                        end do
                      end if
                      do ia=igraf(ig),igral(ig)
                        natsdo=natsdo+1
                        iclslttt(natsdo)=iclsltt(ia)
                        qsltt(natsdo)=qslt(ia)
                        indexx(natsdo)=ia
                      end do
                    else if (ifdiff .eq. 0) then
                      ifdiff=natsdo+1
                    end if
                  end do
                else if (ifdiff .eq. 0) then
                  ifdiff=natsdo+1
                end if
              end do
              if (ifemm .eq. 2) then
                call esltslttmmfe3(cst,cgs,beg12,beg6,beg1,beg2,iclsltt,
     -            iclslttt,qslt,qsltt,ixst,ifgga(igg),ilgga(igg),cpl,
     -            istfnofe,natsdo)
              else
                if (ifemm .eq. 1)
     -            call esltslttmmfe(cst,cgs,beg12,beg6,beg1,begr,
     -              iclsltt,iclslttt,qslt,qsltt,ixst,ifgga(igg),
     -              ilgga(igg),cpl0,cpl1,l0lim,l1lim,indexx,ifdiff)
                call esltslttmm(cst,cgs,beg2,begr,iclsltt,iclslttt,
     -            qslt,qsltt,ixst,ifgga(igg),ilgga(igg),istfnofe,natsdo,
     -            indexx)
              end if
c             For cutoff option, scatter results for each group igg
              do ia=1,natsdo
                beg(indexx(ia))=beg(indexx(ia))+beg2(ia)
              end do
            end do
          end if
c=========All PBC
          if (ioppbcm .ne. 4) then
c           Scatter the beg values to their original place
            if (ifdiff .eq. 0) ifdiff=1
            do ia=natsdo,ifdiff,-1
              beg(indexx(ia))=beg(ia)
              beg(ia)=0.d0
            end do
          end if
        end if
        if (l1lim .gt. 0 .and. molslt .ge. molsltf) then
c         Factor in the coupling parameter, generate TI slt term
          do k=1,3
            gsuml0(k)=0.d0
            gsuml1(k)=0.d0
          end do
          do ia=1,l0lim
            gsuml0(1)=gsuml0(1)+beg12(ia)
            gsuml0(2)=gsuml0(2)+beg6(ia)
            gsuml0(3)=gsuml0(3)+beg1(ia)
            beg(ia)=beg12(ia)*cpl0(1)+beg6(ia)*cpl0(2)+beg1(ia)*cpl0(3)
          end do
          do ia=l0lim+1,l1lim
            gsuml1(1)=gsuml1(1)+beg12(ia)
            gsuml1(2)=gsuml1(2)+beg6(ia)
            gsuml1(3)=gsuml1(3)+beg1(ia)
            beg(ia)=beg12(ia)*cpl1(1)+beg6(ia)*cpl1(2)+beg1(ia)*cpl1(3)
          end do
        end if
      end if
c     Now do the intramolecular part
      if (iself .ge. 1) then
        begself=0.d0
        if (nospecterm .eq. 1) then
          do iaa=ifsta,ilsta
            ia=ixst(iaa)
            cx=cst(1,ia)
            cy=cst(2,ia)
            cz=cst(3,ia)
            call readbitc(mapbit,ia,indexx,1,mollst(mol)-molfst(mol)+1,
     -        maxbw,maxba,nbits)
c             Eliminate j>=i within torsion groups to prevent double count
            do jaa=iaa,ilsta
              indexx(ixst(jaa)-molfst(mol)+1)=0
            end do
C@DB            write (6,1712) ia,(indexx(i),i=1,(mollst(mol)-molfst(mol)+1))
C@DB1712        format(' ia=',i3,(' ix=',120i1))
            engrow=0.d0
            do ja=molfst(mol),mollst(mol)
              if (indexx(ja-molfst(mol)+1) .gt. 0) then
                rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+
     -            (cz-cst(3,ja))**2
                rij6=rij2*rij2*rij2
                rij12=rij6*rij6
C@NR                rij=sqrt(rij2)
                eng=c12tt(iclsltt(ia),iclsltt(ja))/rij12-
     -            c6tt(iclsltt(ia),iclsltt(ja))/rij6+
C@1R     -            (qslt(ia)*qslt(ja)/rij2)
C@NR     -            (qslt(ia)*qslt(ja)/rij)
C@RF     -            *(1.0+rij*rij2*rccon)
C@DD     -            *dd_ms_inter(rij)
                begself=begself+eng
C@DB                write (6,1713) ia,ja,eng,rij,cx,cst(1,ja)
C@DB1713           format (' ESLTSLT ia,ja=',2i4,' eng=',e12.5,
C@DB     -         ' rij,cxi,cxj=',3f10.5)
              end if
            end do
          end do
        else
c         Intramolecular solvation term and/or H-bond term is included
          do iaa=ifsta,ilhbsta
            ia=ixst(iaa)
            cx=cst(1,ia)
            cy=cst(2,ia)
            cz=cst(3,ia)
            call readbitc(mapbit,ia,indexx,1,mollst(mol)-molfst(mol)+1,
     -        maxbw,maxba,nbits)
c             Eliminate j>=i within torsion groups to prevent double count
            do jaa=iaa,ilsta
              indexx(ixst(jaa)-molfst(mol)+1)=0
            end do
C@DB            write (6,1712) ia,(indexx(i),i=1,(mollst(mol)-molfst(mol)+1))
C@DB1712        format(' ia=',i3,(' ix=',120i1))
            engrow=0.d0
            si=s_solv_slt(ia)
            vi=v_solv_slt(ia)
            do ja=molfst(mol),mollst(mol)
              rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+
     -          (cz-cst(3,ja))**2
              if (indexx(ja-molfst(mol)+1) .gt. 0) then
               if (iaa .le. ilsta) then
c                VdW and desolvation calculation does not need the extra atoms
                  rij6=rij2*rij2*rij2
                  rij12=rij6*rij6
C@NR                  rij=sqrt(rij2)
                  engvdw1=c12tt(iclsltt(ia),iclsltt(ja))/rij12-
     -              c6tt(iclsltt(ia),iclsltt(ja))/rij6
C@1R                  engelst=(qslt(ia)*qslt(ja)/rij2)
C@NR                  engelst=(qslt(ia)*qslt(ja)/rij)
C@RF     -              *(1.0+rij*rij2*rccon)
C@DD     -              *dd_ms_inter(rij)
                  begself=begself+engelst+engvdw1
                end if
                if (iopdesolvself .gt. 0) then
                  if (si .ne. 0.0) then
                    if (rij2 .lt. gaussdistlim) then
                      sj=s_solv_slt(ja)
                      if (sj .ne. 0.0) then
                        if (ipolarslt(ia)+ipolarslt(ja) .lt. 2) then
                          vj=v_solv_slt(ja)
                          engdes=(si*vj+sj*vi)*exp(-rij2/gaussdist2)
                          begself=begself+engdes
                        end if
                      end if
                    end if
                  end if
                end if
                enghb0=0.0
                if (ihbtypsltsltself .gt. 0) then
                  if (ihbdonacc(ia)*ihbdonacc(ja) .lt. 0) then
c                   Donor-acceptor pair found
                    if (rij2 .lt. rmaxhb2) then
                      if (rij2 .gt. rminhb2) then
                        if (ihbdonacc(ia) .gt. 0) then
                          iahyd=ia
                          iaox=ja
                          iaheavy=iahbheavy(ia)
                        else
                          iahyd=ja
                          iaox=ia
                          iaheavy=iahbheavy(ja)
                        end if
                        ihbnum=
     -                    ixdonacc(ihbdonacc(iahyd),-ihbdonacc(iaox))
                        if (ihbnum .gt. 0) then
                          doheavy2=arrdist(cst(1,iaheavy),cst(1,iaox))
                          dhheavy2=arrdist(cst(1,iahyd),cst(1,iaheavy))
                          call hbond(iaox,iaox,iahyd,iaheavy,
     -                      dhheavy2,doheavy2,rij2,ihbtypsltslt,
     -                      ihbsignslt,ihbnum,ihbdonacc(ia),iexptheta,
     -                      iexpomega,ecocoef,ecopcoef,cohhb10,cohhb12,
     -                      rminhbheavy2,cst,cst,enghb0)
C@dc                      write (6,4811) labcall,ia,ja,iaox,iahyd,rij2,
C@dc     -                   enghb0
C@dc4811                  format(' ESLTSLTT ',a,' ia,ja=',2i5,' iaox,hyd=',
C@dc     -                  2i5,' rij2=',f8.4,' enghb0=',e12.5)
                        end if
                      end if
                    end if
                  end if
                end if
                begself=begself+enghb0
              end if
            end do
          end do
        end if
      end if
      return
      end
      subroutine intrasums(cst,nneig3,nneig4,ineig,mapbit,maxbw,maxba,
     -  nbits,maxneig,ifirstm,ilastm,iclsltt,qslt,esf14,vdwf14,gbegei,
     -  gbegei14,indexx,ibitmap)
c#    MMC routine 197 lstmod: 04/15/08
c*****Get the intramolecular contributions to the NB and 1-4 energies
      dimension cst(3,#ST),iclsltt(#ST),qslt(#ST),
     -  nneig3(#ST),nneig4(#ST),ineig(maxneig,#ST),
     -  indexx(#ST),mapbit(maxbw,maxba)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      real*8 gbegei,gbegei14,enges,engvdw
      gbegei=0.d0
      enges=0.d0
      engvdw=0.d0
C@DB  epsinv=1.0
      if (ibitmap .eq. 0) return
      if (nospecterm .eq. 1) then
        do ia=ifirstm,ilastm
          cx=cst(1,ia)
          cy=cst(2,ia)
          cz=cst(3,ia)
c         Consider only ja<ia to eliminate double counting
          call readbitc(mapbit,ia,indexx,1,ia-ifirstm,maxbw,maxba,nbits)
C@db          write (6,1712) ia,(indexx(i-ifirstm+1),i=ifirstm,ia-1)
C@db1712      format(' ia=',i3,(' ix=',120i1))
          do ja=ifirstm,ia-1
            if (indexx(ja-ifirstm+1) .gt. 0) then
              rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+(cz-cst(3,ja))**2
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
C@NR              rij=sqrt(rij2)
              eng=c12tt(iclsltt(ia),iclsltt(ja))/rij12-
     -          c6tt(iclsltt(ia),iclsltt(ja))/rij6+
C@1R     -          (qslt(ia)*qslt(ja)/rij2)
C@NR     -          (qslt(ia)*qslt(ja)/rij)
C@RF     -          *(1.0+rij*rij2*rccon)
C@DD     -          *dd_ms_inter(rij)
              gbegei=gbegei+eng
C@DBC@1R              rij=sqrt(rij2)
C@DB              elst0=(qslt(ia)*qslt(ja)/rij)
C@DBC@DD              epsinv=dd_ms_inter(rij)
C@DBC@1R              epsinv=1.0/rij
C@DB              write (6,1713) ia,ja,eng,elst0,epsinv,elst0*epsinv,rij
C@DB1713         format (' INTRASUMS ia,ja=',2i4,' eng=',e12.5,
C@DB     -         ' qiqj/r=',e12.5,' 1/eps=',e12.5,' e(elst)=',e12.5,
C@DB     -         ' rij=',f10.5)
            end if
          end do
c         Now create non-redundant 1-4 list
          nfound=0
          do in=nneig3(ia)+1,nneig4(ia)
            if (ineig(in,ia) .le. ia) then
              nfound=nfound+1
              indexx(nfound)=ineig(in,ia)
            end if
          end do
          do jaa=1,nfound
            ja=indexx(jaa)
            rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+(cz-cst(3,ja))**2
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
            engvdw=engvdw+c12tt14(iclsltt(ia),iclsltt(ja))/rij12-
     -        c6tt14(iclsltt(ia),iclsltt(ja))/rij6
C@NR            rij=sqrt(rij2)
C@NR            enges=enges+(qslt(ia)*qslt(ja)/rij)
C@1R            enges=enges+(qslt(ia)*qslt(ja)/rij2)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
            ev=c12tt14(iclsltt(ia),iclsltt(ja))/rij12-
     -          c6tt14(iclsltt(ia),iclsltt(ja))/rij6
C@DBC@1R              rij=sqrt(rij2)
C@DB              elst0=(qslt(ia)*qslt(ja)/rij)
C@DBC@DD              epsinv=dd_ms_inter(rij)
C@DBC@1R              epsinv=1.0/rij
C@DB              write (6,1714) ia,ja,ev,elst0,epsinv,elst0*epsinv,rij
C@DB1714         format (' INTRASUMS14 ia,ja=',2i4,' engvdw=',e12.5,
C@DB     -         ' qiqj/r=',e12.5,' 1/eps=',e12.5,' e(elst)=',e12.5,
C@DB     -         ' rij=',f10.5)
          end do
        end do
      else
c       Intramolecular solvation term and/or H-bond term is included
        do ia=ifirstm,ilastm
          cx=cst(1,ia)
          cy=cst(2,ia)
          cz=cst(3,ia)
c         Consider only ja<ia to eliminate double counting
          call readbitc(mapbit,ia,indexx,1,ia-ifirstm,maxbw,maxba,nbits)
C@db          write (6,1712) ia,(indexx(i-ifirstm+1),i=ifirstm,ia-1)
          si=s_solv_slt(ia)
          vi=v_solv_slt(ia)
          do ja=ifirstm,ia-1
            if (indexx(ja-ifirstm+1) .gt. 0) then
              rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+
     -          (cz-cst(3,ja))**2
              rij6=rij2*rij2*rij2
              rij12=rij6*rij6
C@NR              rij=sqrt(rij2)
              engvdw1=c12tt(iclsltt(ia),iclsltt(ja))/rij12-
     -          c6tt(iclsltt(ia),iclsltt(ja))/rij6
C@1R              engelst=(qslt(ia)*qslt(ja)/rij2)
C@NR              engelst=(qslt(ia)*qslt(ja)/rij)
C@RF     -          *(1.0+rij*rij2*rccon)
C@DD     -          *dd_ms_inter(rij)
C@DBC@1R              rij=sqrt(rij2)
C@DB              elst0=(qslt(ia)*qslt(ja)/rij)
C@DBC@DD              epsinv=dd_ms_inter(rij)
C@DBC@1R              epsinv=1.0/rij
C@DB              write (6,1713) ia,ja,eng,elst0,epsinv,elst0*epsinv,rij
              enghb0=0.0
              if (ihbtypsltsltself .gt. 0) then
                if (ihbdonacc(ia)*ihbdonacc(ja) .lt. 0) then
c                 Donor-acceptor pair found
C@dc                  write (6,4821) ia,ja,rij2,rminhb2,rmaxhb2
C@dc4821              format(' INTRASUMS donor-acceptor ia,ja=',2i4,
C@dc     -               'rij^2=',f10.4,' riminhb2,rmaxhb2=',2f8.4)
                  if (rij2 .lt. rmaxhb2) then
                    if (rij2 .gt. rminhb2) then
                      if (ihbdonacc(ia) .gt. 0) then
                        iahyd=ia
                        iaox=ja
                        iaheavy=iahbheavy(ia)
                      else
                        iahyd=ja
                        iaox=ia
                        iaheavy=iahbheavy(ja)
                      end if
                      ihbnum=
     -                  ixdonacc(ihbdonacc(iahyd),-ihbdonacc(iaox))
                      if (ihbnum .gt. 0) then
                        doheavy2=arrdist(cst(1,iaheavy),cst(1,iaox))
                        dhheavy2=arrdist(cst(1,iahyd),cst(1,iaheavy))
                        call hbond(iaox,iaox,iahyd,iaheavy,
     -                    dhheavy2,doheavy2,rij2,ihbtypsltslt,
     -                    ihbsignslt,ihbnum,ihbdonacc(ia),iexptheta,
     -                    iexpomega,ecocoef,ecopcoef,cohhb10,cohhb12,
     -                    rminhbheavy2,cst,cst,enghb0)
C@dc                    write (6,4822) iaox,iahyd,iaheavy,enghb0
C@dc4822                format(' INTRASUMS iaox=',i4,' iahyd=',i4,
C@dc     -                ' iaheavy=',i4,' enghb0=',f10.5)
                      end if
                    end if
                  end if
                end if
              end if
              eng=engelst+engvdw1+enghb0
C@db               write (6,4812) ia,ja,sqrt(rij2),engvdw1,enghb0,
C@db     -           engelst,eng
C@db4812           format(' INTRASUMS ia,ja=',2i4,' rij=',f8.4,' engvdw1=',
C@db     -           e12.5,' enghb=',e12.5,' engest=',e12.5,' eng=',e12.5)
              gbegei=gbegei+eng
              if (iopdesolvself .gt. 0) then
                if (si .ne. 0.0) then
                  if (rij2 .lt. gaussdistlim) then
                    sj=s_solv_slt(ja)
                    if (sj .ne. 0.0) then
                      if (ipolarslt(ia)+ipolarslt(ja) .lt. 2) then
                        vj=v_solv_slt(ja)
                        engdes=(si*vj+sj*vi)*exp(-rij2/gaussdist2)
C@db                        write (6,4813) ia,ja,sqrt(rij2),engdes
C@db4813                    format(' INTRASUMS ia,ja=',2i4,' rij=',f8.4,
C@db     -                    ' engdes=',e12.5)
                        gbegei=gbegei+engdes
                      end if
                    end if
                  end if
                end if
              end if
            end if
          end do
c         Now create non-redundant 1-4 list
          nfound=0
          do in=nneig3(ia)+1,nneig4(ia)
            if (ineig(in,ia) .le. ia) then
              nfound=nfound+1
              indexx(nfound)=ineig(in,ia)
            end if
          end do
          do jaa=1,nfound
            ja=indexx(jaa)
            rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+(cz-cst(3,ja))**2
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
            engvdw=engvdw+c12tt14(iclsltt(ia),iclsltt(ja))/rij12-
     -        c6tt14(iclsltt(ia),iclsltt(ja))/rij6
C@NR            rij=sqrt(rij2)
C@1R            enges=enges+(qslt(ia)*qslt(ja)/rij2)
C@NR            enges=enges+(qslt(ia)*qslt(ja)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
            evdw=c12tt14(iclsltt(ia),iclsltt(ja))/rij12-
     -        c6tt14(iclsltt(ia),iclsltt(ja))/rij6
C@DBC@1R              rij=sqrt(rij2)
C@DB              elst0=(qslt(ia)*qslt(ja)/rij)
C@DBC@DD              epsinv=dd_ms_inter(rij)
C@DBC@1R              epsinv=1.0/rij
C@DB            write (6,1714) ia,ja,evdw,elst0,epsinv,elst0*epsinv,rij
          end do
        end do
      end if
      gbegei14=esf14*enges+vdwf14*engvdw
      return
      end
      subroutine esltsltg(cst,molsltf,molslt,molfst,mollst,igrmf,igrml,
     -  igraf,igral,beg,begr,izrbr,istf,nslt,iclsltt,qslt,mol,mol2,i12,
     -  gsum12,l0lim,l1lim,cpl0,cpl1,gsuml0,gsuml1,igrcnt,molcnt,
     -  cent,iop5,ioppbcm,indexx,iclslttt,qsltt,cgs,cutuus,noeng)
c#    MMC routine 198 lstmod: 08/16/17
c*****Calculates solute-solute interaction energies between solute atoms
c     affected by one (mol2=0) or two (mol2 > mol) solute molecule change(s),
c     optonally using group or molecule-based PBC
c     beg(ia): atom ia's energy with the changed part
c     begr(ia): atom ia's energy (ia in the changed part) with the other mols
      real*8 beg,begr,gsum12,gsuml0,gsuml1
      real*8 beg12,beg6,beg1,begmol1
C@NL      logical mapbit
      dimension cst(3,#ST),beg(#ST),begr(#ST),molfst(#MM),
     -  igraf(#GR),igral(#GR),igrmf(#MM),igrml(#MM),
     -  mollst(#MM),molcnt(#MM),iclsltt(#ST),qslt(#ST),
     -  igrcnt(#GR),indexx(#UV),iclslttt(#UV),qsltt(#UV),
     -  cgs(3,#UV),cpl0(3),cpl1(3),
     -  beg12(#FE),beg6(#FE),beg1(#FE),begmol1(#FE)
      dimension gsuml0(3),gsuml1(3),
     -  cent(3),c0(3),c0m(3),shift(3),c012(3,2),mol12(2)
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      common /liga/ ligand_start_molecule,last_slt_mol_g
      common /selfindex/ indexself(#UV)
C@dc      character*4 labcall
C@dc      common /testprint/ labcall
      real*8 beg2
      common /begwork/ beg2(#ST)
      data minus1 /-1/
      gsum12=0.d0
      if (noeng .gt. 1) return
c     Last molecule to consider in solute-solute intermolecular energy calcs
c     i12 = 0: all; 1:  only 1-2; 2: all but 1-2
      i12yes=0
      iallyes=1
      moll2=0
      i2only=0
c     If it's a ligand that moved, we don't want to calculate intermolecular
c     energies among ligands.  If it isn't a ligand, it won't affect ligand-
c     ligand interactions, so calculate between mol and all solute molecules
      if (mol .gt. last_slt_mol_g) then
        molsltl = last_slt_mol_g
      else
        molsltl = molslt
      end if
      if (i12 .eq. 0) then
        mol2donly=1
        if (mol .lt. molsltf) mol2donly=0
        if (molsltl-molsltf .eq. mol2donly) i2only=1
        if (mol2 .ne. 0) then
c         There is a second special molec
          moll2=mol2
          i12yes=1
        else if (molsltl-molsltf .eq. mol2donly) then
c         Only two molecs - the other is the special
          if (mol .lt. molsltf) then
            moll2=molsltf
          else
            moll2=molsltf+molslt-mol
          end if
          i12yes=1
          iallyes=0
          i2only=1
        end if
      else if (i12 .eq. 1) then
        i12yes=1
        iallyes=0
        moll2=mol2
      end if
      if (izrbr .gt. 0) then
        do ia=molfst(mol),mollst(mol)
          begr(ia)=0.d0
        end do
      end if
      if (molsltf .gt. molslt) return
      mol12(1)=mol
      mol12(2)=mol2
      nmol12=1
      if (mol2 .ne. 0) nmol12=2
      istfnofe=istf
c     immfe=0
      if (l1lim .gt. 0) then
        istfnofe=l1lim+1
c       mol,mol2 can't be FE solute for now
c       if (molfst(mol) .lt. l1lim) immfe=1
        do k=1,3
          gsuml0(k)=0.d0
          gsuml1(k)=0.d0
        end do
        do ia=1,l1lim
          beg12(ia)=0.d0
          beg6(ia)=0.d0
          beg1(ia)=0.d0
        end do
      end if
      call getcent(c012(1,1),cent,cst,molcnt(mol))
      if (moll2+mol2 .gt. 0) then
        m2=moll2
        if (m2 .eq. 0) m2=mol2
        if (izrbr .gt. 0) then
          do ia=molfst(m2),mollst(m2)
            begr(ia)=0.d0
          end do
        end if
        call getcent(c012(1,2),cent,cst,molcnt(m2))
      end if
      call zeroitd(beg,nslt)
      if (i12yes .eq. 1) then
c-------Do the mol-mol2 calc first so the sum of begr can give gsum12
        gsum12=0.d0
        if (ioppbcm .eq. 0) then
c========= No PBC
c         Do 1-2  calculation for mol and the other
          call esltsltmm(cst,cst,begr,begr,iclsltt,iclsltt,qslt,
     -      qslt,molfst(mol),mollst(mol),molfst(moll2),mollst(moll2),
     -      indexself)
        else if (ioppbcm .eq. 1) then
c======== Molecule-based PBC
          call esltsltpbc(c012(1,1),c012(1,2),shift,ishift,iop5,riijj)
          if (ishift .eq. 0) then
            call trnsfr(cgs(1,molfst(moll2)),cst(1,molfst(moll2)),
     -        3*(mollst(moll2)-molfst(moll2)+1))
          else
            do ja=molfst(moll2),mollst(moll2)
              call arrdiff(cgs(1,ja),cst(1,ja),shift,3)
            end do
          end if
          call esltsltmm(cst,cgs,begr,begr,iclsltt,iclsltt,qslt,
     -      qslt,molfst(mol),mollst(mol),molfst(moll2),mollst(moll2),
     -      indexself)
        else if (ioppbcm .eq. 2) then
c======== Molecule-based PBC with cutoff
          call esltsltpbc(c012(1,1),c012(1,2),shift,ishift,iop5,riijj)
          if (riijj .lt. cutuus) then
            if (ishift .eq. 0) then
              call trnsfr(cgs(1,molfst(moll2)),cst(1,molfst(moll2)),
     -          3*(mollst(moll2)-molfst(moll2)+1))
            else
              do ja=molfst(moll2),mollst(moll2)
                call arrdiff(cgs(1,ja),cst(1,ja),shift,3)
              end do
            end if
            call esltsltmm(cst,cgs,begr,begr,iclsltt,iclsltt,qslt,
     -        qslt,molfst(mol),mollst(mol),molfst(moll2),mollst(moll2),
     -      indexself)
          end if
        else if (ioppbcm .eq. 3) then
c======== Group-based PBC
          do igm=igrmf(mol),igrml(mol)
            do igm2=igrmf(moll2),igrml(moll2)
              call esltsltpbc(cst(1,igrcnt(igm)),cst(1,igrcnt(igm2)),
     -          shift,ishift,iop5,riijj)
              if (ishift .eq. 0) then
                call trnsfr(cgs(1,igraf(igm2)),cst(1,igraf(igm2)),
     -            3*(igral(igm2)-igraf(igm2)+1))
              else
                do ja=igraf(igm2),igral(igm2)
                  call arrdiff(cgs(1,ja),cst(1,ja),shift,3)
                end do
              end if
              call esltsltmm(cst,cgs,begr,begr,iclsltt,iclsltt,qslt,
     -          qslt,igraf(igm),igral(igm),igraf(igm2),igral(igm2),
     -          indexself)
            end do
          end do
        else if (ioppbcm .eq. 4) then
c======== Group-based PBC with cutoff
          do igm=igrmf(mol),igrml(mol)
            do igm2=igrmf(moll2),igrml(moll2)
              call esltsltpbc(cst(1,igrcnt(igm)),cst(1,igrcnt(igm2)),
     -          shift,ishift,iop5,riijj)
              if (riijj .lt. cutuus) then
                if (ishift .eq. 0) then
                  call trnsfr(cgs(1,igraf(igm2)),cst(1,igraf(igm2)),
     -              3*(igral(igm2)-igraf(igm2)+1))
                else
                  do ja=igraf(igm2),igral(igm2)
                    call arrdiff(cgs(1,ja),cst(1,ja),shift,3)
                  end do
                end if
                call esltsltmm(cst,cgs,begr,begr,iclsltt,iclsltt,qslt,
     -            qslt,igraf(igm),igral(igm),igraf(igm2),igral(igm2),
     -            indexself)
              end if
            end do
          end do
        end if
      end if
c     Sum common to all PBC's
      do ia=molfst(mol),mollst(mol)
        gsum12=gsum12+begr(ia)
      end do
      if (iallyes .eq. 1) then
c-------Interaction between mol, mol2 and still other solute molecules
        do im12=1,nmol12
          if (ioppbcm .eq. 0) then
c========== No PBC
            natsdo=istf-1
            ifdiff=0
c           Just gather the ones to be used
            if (im12 .eq. 1) then
c             Since there is no PBC, gather data only once
              do im=molsltf,molsltl
                if (im .ne. mol .and. im .ne. mol2) then
                  call trnsfr(cgs(1,natsdo+1),cst(1,molfst(im)),
     -              3*(mollst(im)-molfst(im)+1))
                  do ia=molfst(im),mollst(im)
                    natsdo=natsdo+1
                    iclslttt(natsdo)=iclsltt(ia)
                    qsltt(natsdo)=qslt(ia)
                    indexx(natsdo)=ia
                  end do
                else if (ifdiff .eq. 0) then
                  ifdiff=natsdo+1
                end if
              end do
            end if
c           if (immfe .eq. 0) then
              if (l1lim .gt. 0)
     -          call esltsltmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -            iclslttt,qslt,qsltt,molfst(mol12(im12)),
     -            mollst(mol12(im12)),cpl0,cpl1,l0lim,l1lim,indexx,
     -            minus1)
              call esltsltmm(cst,cgs,beg,begr,iclsltt,iclslttt,qslt,
     -          qsltt,molfst(mol12(im12)),mollst(mol12(im12)),istfnofe,
     -          natsdo,indexx)
c           else
c             call ??? Need different esltsltmmfe? subroutine here
c           end if
          else if (ioppbcm .eq. 1) then
c========== Molecule-based PBC
            natsdo=istf-1
            ifdiff=0
c           Obtain the PBC shifts from centers of mol (mol2) and gather coords
c           Use input center if center index is zero
            do im=molsltf,molsltl
              if (im .ne. mol .and. im .ne. mol2) then
                call getcent(c0m,cent,cst,molcnt(im))
                call esltsltpbc(c012(1,im12),c0m,shift,ishift,iop5,
     -            riijj)
                if (ishift .eq. 0) then
                  call trnsfr(cgs(1,natsdo+1),cst(1,molfst(im)),
     -              3*(mollst(im)-molfst(im)+1))
                else
                  do ia=molfst(im),mollst(im)
                    call arrdiff(cgs(1,ia-molfst(im)+natsdo+1),
     -                cst(1,ia),shift,3)
                  end do
                end if
                do ia=molfst(im),mollst(im)
                  natsdo=natsdo+1
                  iclslttt(natsdo)=iclsltt(ia)
                  qsltt(natsdo)=qslt(ia)
                  indexx(natsdo)=ia
                end do
              else if (ifdiff .eq. 0) then
                ifdiff=natsdo+1
              end if
            end do
            if (l1lim .gt. 0)
     -        call esltsltmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -          iclslttt,qslt,qsltt,molfst(mol12(im12)),
     -          mollst(mol12(im12)),cpl0,cpl1,l0lim,l1lim,indexx,minus1)
            call esltsltmm(cst,cgs,beg,begr,iclsltt,iclslttt,qslt,
     -        qsltt,molfst(mol12(im12)),mollst(mol12(im12)),istfnofe,
     -        natsdo,indexx)
          else if (ioppbcm .eq. 2) then
c========== Molecule-based PBC with cutoff
            natsdo=istf-1
            ifdiff=0
c           Obtain the PBC shifts from centers of mol (mol2) and gather coords
c           Use input center if center index is zero
            do im=molsltf,molsltl
              natsdoprev=natsdo
              if (im .ne. mol .and. im .ne. mol2) then
                call getcent(c0m,cent,cst,molcnt(im))
                call esltsltpbc(c012(1,im12),c0m,shift,ishift,iop5,
     -            riijj)
                if (riijj .lt. cutuus) then
                  if (ishift .eq. 0) then
                    call trnsfr(cgs(1,natsdo+1),cst(1,molfst(im)),
     -                3*(mollst(im)-molfst(im)+1))
                  else
                    do ia=molfst(im),mollst(im)
                      call arrdiff(cgs(1,ia-molfst(im)+natsdo+1),
     -                  cst(1,ia),shift,3)
                    end do
                  end if
                  do ia=molfst(im),mollst(im)
                    natsdo=natsdo+1
                    iclslttt(natsdo)=iclsltt(ia)
                    qsltt(natsdo)=qslt(ia)
                    indexx(natsdo)=ia
                  end do
                end if
              end if
              if (ifdiff .eq. 0) then
                if (natsdoprev .eq. natsdo) ifdiff=natsdo+1
              end if
            end do
            if (l1lim .gt. 0)
     -        call esltsltmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -          iclslttt,qslt,qsltt,molfst(mol12(im12)),
     -          mollst(mol12(im12)),cpl0,cpl1,l0lim,l1lim,indexx,minus1)
            call esltsltmm(cst,cgs,beg,begr,iclsltt,iclslttt,qslt,
     -        qsltt,molfst(mol12(im12)),mollst(mol12(im12)),istfnofe,
     -        natsdo,indexx)
          else if (ioppbcm .eq. 3) then
c========== Group-based PBC
            do igm=igrmf(mol12(im12)),igrml(mol12(im12))
              call trnsfr(c0,cst(1,igrcnt(igm)),3)
c             Obtain the PBC shifts from the first molec and gather coords
              natsdo=istf-1
              ifdiff=0
              do im=molsltf,molsltl
                if (im .ne. mol .and. im .ne. mol2) then
                  do ig=igrmf(im),igrml(im)
                    call esltsltpbc(c0,cst(1,igrcnt(ig)),
     -                shift,ishift,iop5,riijj)
 
                    if (ishift .eq. 0) then
                      call trnsfr(cgs(1,natsdo+1),cst(1,igraf(ig)),
     -                  3*(igral(ig)-igraf(ig)+1))
                    else
                      do ia=igraf(ig),igral(ig)
                        call arrdiff(cgs(1,ia-igraf(ig)+natsdo+1),
     -                     cst(1,ia),shift,3)
                      end do
                    end if
                    do ia=igraf(ig),igral(ig)
                      natsdo=natsdo+1
                      iclslttt(natsdo)=iclsltt(ia)
                      qsltt(natsdo)=qslt(ia)
                      indexx(natsdo)=ia
                    end do
                  end do
                else if (ifdiff .eq. 0) then
                  ifdiff=natsdo+1
                end if
              end do
              if (l1lim .gt. 0)
     -          call esltsltmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -            iclslttt,qslt,qsltt,igraf(igm),igral(igm),cpl0,cpl1,
     -            l0lim,l1lim,indexx,ifdiff)
              call esltsltmm(cst,cgs,beg,begr,iclsltt,iclslttt,qslt,
     -          qsltt,igraf(igm),igral(igm),istfnofe,natsdo,indexx)
            end do
          else if (ioppbcm .eq. 4) then
c========== Group-based PBC with cutoff
            do igm=igrmf(mol12(im12)),igrml(mol12(im12))
              call zeroitd(beg2,nslt)
              call trnsfr(c0,cst(1,igrcnt(igm)),3)
c             Obtain the PBC shifts from the first molec and gather coords
              natsdo=istf-1
              ifdiff=0
              do im=molsltf,molsltl
                if (im .ne. mol .and. im .ne. mol2) then
                  do ig=igrmf(im),igrml(im)
                    call esltsltpbc(c0,cst(1,igrcnt(ig)),
     -                shift,ishift,iop5,riijj)
                    if (riijj .lt. cutuus) then
                      if (ishift .eq. 0) then
                        call trnsfr(cgs(1,natsdo+1),cst(1,igraf(ig)),
     -                    3*(igral(ig)-igraf(ig)+1))
                      else
                        do ia=igraf(ig),igral(ig)
                          call arrdiff(cgs(1,ia-igraf(ig)+natsdo+1),
     -                       cst(1,ia),shift,3)
                        end do
                      end if
                      do ia=igraf(ig),igral(ig)
                        natsdo=natsdo+1
                        iclslttt(natsdo)=iclsltt(ia)
                        qsltt(natsdo)=qslt(ia)
                        indexx(natsdo)=ia
                      end do
                    else if (ifdiff .eq. 0) then
                      ifdiff=natsdo+1
                    end if
                  end do
                else if (ifdiff .eq. 0) then
                  ifdiff=natsdo+1
                end if
              end do
              if (l1lim .gt. 0)
     -          call esltsltmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -            iclslttt,qslt,qsltt,igraf(igm),igral(igm),cpl0,cpl1,
     -            l0lim,l1lim,indexx,ifdiff)
              call esltsltmm(cst,cgs,beg2,begr,iclsltt,iclslttt,qslt,
     -          qsltt,igraf(igm),igral(igm),istfnofe,natsdo,indexx)
c             For cutoff option, scatter results for each group igg
c!!!???       do ia=1,natsdo
              do ia=istf,natsdo
                beg(indexx(ia))=beg(indexx(ia))+beg2(ia)
              end do
            end do
          end if
          if (mol2 .gt. 0 .and. im12 .eq. 1) then
c           Actions betwen im12=1 and im12=2
            if (l1lim .gt. 0) then
              do ia=1,l0lim
                gsuml0(1)=gsuml0(1)+beg12(ia)
                gsuml0(2)=gsuml0(2)+beg6(ia)
                gsuml0(3)=gsuml0(3)+beg1(ia)
                begmol1(ia)=beg12(ia)*cpl0(1)+beg6(ia)*cpl0(2)+
     -            beg1(ia)*cpl0(3)
                beg12(ia)=0.d0
                beg6(ia)=0.d0
                beg1(ia)=0.d0
              end do
              do ia=l0lim+1,l1lim
                gsuml1(1)=gsuml1(1)+beg12(ia)
                gsuml1(2)=gsuml1(2)+beg6(ia)
                gsuml1(3)=gsuml1(3)+beg1(ia)
                begmol1(ia)=beg12(ia)*cpl1(1)+beg6(ia)*cpl1(2)+
     -            beg1(ia)*cpl1(3)
                beg12(ia)=0.d0
                beg6(ia)=0.d0
                beg1(ia)=0.d0
              end do
            end if
            if (ioppbcm .ne. 4) then
c             Save beg
              if (ifdiff .eq. 0) ifdiff=natsdo+1
              call trnsfrd(beg2,beg,ifdiff-1)
              call zeroitd(beg2(ifdiff),nslt-ifdiff+1)
              do ia=natsdo,ifdiff,-1
                beg2(indexx(ia))=beg(ia)
              end do
              call zeroitd(beg,nslt)
            end if
          end if
        end do
c       Scatter the beg values to their original place
        if (ioppbcm .ne. 4) then
          if (ifdiff .eq. 0) ifdiff=natsdo+1
          do ia=natsdo,ifdiff,-1
            beg(indexx(ia))=beg(ia)
            beg(ia)=0.d0
          end do
          if (nmol12 .eq. 2) then
c           Add the beg2 values
            do ia=1,nslt
              beg(ia)=beg(ia)+beg2(ia)
            end do
          end if
        end if
      end if
c-----Parts common to all PBC types
      if (i12yes .eq. 1) then
        if (i2only .eq. 1) then
          do ia=molfst(moll2),mollst(moll2)
            beg(ia)=begr(ia)
          end do
        end if
        if (mol2 .eq. 0) then
          do ia=molfst(moll2),mollst(moll2)
            begr(ia)=0.d0
          end do
        end if
      end if
      if (l1lim .gt. 0) then
c       Generate TI slt term
        do ia=1,l0lim
          gsuml0(1)=gsuml0(1)+beg12(ia)
          gsuml0(2)=gsuml0(2)+beg6(ia)
          gsuml0(3)=gsuml0(3)+beg1(ia)
        end do
        do ia=l0lim+1,l1lim
          gsuml1(1)=gsuml1(1)+beg12(ia)
          gsuml1(2)=gsuml1(2)+beg6(ia)
          gsuml1(3)=gsuml1(3)+beg1(ia)
        end do
c       Factor in the coupling parameter
        do ia=1,l0lim
          beg(ia)=beg12(ia)*cpl0(1)+beg6(ia)*cpl0(2)+beg1(ia)*cpl0(3)
        end do
        do ia=l0lim+1,l1lim
          beg(ia)=beg12(ia)*cpl1(1)+beg6(ia)*cpl1(2)+beg1(ia)*cpl1(3)
        end do
        if (mol2 .ne. 0) then
          do ia=1,l1lim
            beg(ia)=beg(ia)+begmol1(ia)
          end do
        end if
      end if
      return
      end
      subroutine esltsltmm(cst,cgs,beg,begr,iclsltt,iclslttt,qslt,
     -  qsltt,mf,ml,istf,natsdo,indexats)
c#    MMC routine 199 lstmod: 04/15/08
c*****Calculates solute-solute interaction energy terms between solute atoms
c     mf to ml and istf to natsdo in cst and cgs, resp.
c     Called from esltsltg only
      real*8 beg,begr,engrow
      dimension cst(3,#ST),beg(#ST),begr(#ST),iclsltt(#ST),
     -  iclslttt(#ST),qslt(#ST),qsltt(#ST),cgs(3,#ST),
     -  indexats(#ST)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
C@dc      character*4 labcall
C@dc      common /testprint/ labcall
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
C@D4      common /eijmol/ eijslto(#ST,#ST),eijsltn(#ST,#ST),
C@D4     -  eijslt(#ST,#ST)
C@PS      write (6,1111)
C@PS1111  format(' The subroutines epsltslv, esltsltmm,and esltslttmm have',
C@PS     -  ' to be replaced ',/,
C@PS     -  'with the parallelizable versions')
C@PS      call datprt(2)
      if (nospecterm .eq. 1) then
        do ia=mf,ml
          cx=cst(1,ia)
          cy=cst(2,ia)
          cz=cst(3,ia)
          engrow=0.d0
          do ja=istf,natsdo
            rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
C@NR            rij=sqrt(rij2)
            eng=c12tt(iclsltt(ia),iclslttt(ja))/rij12-
     -        c6tt(iclsltt(ia),iclslttt(ja))/rij6+
C@1R     -        (qslt(ia)*qsltt(ja)/rij2)
C@NR     -        (qslt(ia)*qsltt(ja)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
            beg(ja)=beg(ja)+eng
            engrow=engrow+eng
C@D4            eijslt(ia,ja)=eng
C@D4            eijslt(ja,ia)=eng
C@DB            write (6,1711) ia,ja,eng,rij,cx,cgs(1,ja)
C@DB1711            format (' ESLTSLT ia,ja=',2i4,' eng=',e12.5,
C@DB     -           ' rij,cxi,cxj=',3f10.5)
          end do
          begr(ia)=begr(ia)+engrow
        end do
      else
c       Intramolecular solvation term and/or H-bond term is included
        do ia=mf,ml
          si=s_solv_slt(ia)
          vi=v_solv_slt(ia)
          cx=cst(1,ia)
          cy=cst(2,ia)
          cz=cst(3,ia)
          engrow=0.d0
          do ja=istf,natsdo
            ja0=indexats(ja)
            if (ia .gt. ja0) then
              rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
            else
              rij2=(cgs(1,ja)-cx)**2+(cgs(2,ja)-cy)**2+(cgs(3,ja)-cz)**2
            end if
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
C@NR            rij=sqrt(rij2)
            eng=c12tt(iclsltt(ia),iclslttt(ja))/rij12-
     -        c6tt(iclsltt(ia),iclslttt(ja))/rij6+
C@1R     -        (qslt(ia)*qsltt(ja)/rij2)
C@NR     -        (qslt(ia)*qsltt(ja)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
            beg(ja)=beg(ja)+eng
            engrow=engrow+eng
C@D4            eijslt(ia,ja)=eng
C@D4            eijslt(ja,ia)=eng
C@DB            write (6,1711) ia,ja,eng,rij,cx,cgs(1,ja)
C@DB1711            format (' ESLTSLT ia,ja=',2i4,' eng=',e12.5,
C@DB     -           ' rij,cxi,cxj=',3f10.5)
            if (ihbtypsltslt .gt. 0) then
              if (ihbdonacc(ia)*ihbdonacc(ja0) .lt. 0) then
c               Donor-acceptor pair found
                if (rij2 .lt. rmaxhb2) then
                  if (rij2 .gt. rminhb2) then
                    if (ihbdonacc(ia) .gt. 0) then
                      iahyd=ia
                      iahyd0=ia
                      iaox=ja
                      iaox0=ja0
                      iaheavy=iahbheavy(ia)
                      ihbnum=
     -                  ixdonacc(ihbdonacc(iahyd0),-ihbdonacc(iaox0))
                      if (ihbnum .gt. 0) then
                        doheavy2=arrdist(cst(1,iaheavy),cgs(1,iaox))
                        dhheavy2=arrdist(cst(1,iahyd),cst(1,iaheavy))
                      end if
                    else
                      iahyd=ja
                      iahyd0=ja0
                      iaox=ia
                      iaox0=ia
                      iaheavy=ja+(iahbheavy(ja0)-ja0)
                      ihbnum=
     -                  ixdonacc(ihbdonacc(iahyd0),-ihbdonacc(iaox0))
                      if (ihbnum .gt. 0) then
                        doheavy2=arrdist(cgs(1,iaheavy),cst(1,iaox))
                        dhheavy2=arrdist(cgs(1,iahyd),cgs(1,iaheavy))
                      end if
                    end if
                    if (ihbnum .gt. 0) then
                      call hbond(iaox,iaox0,iahyd,iaheavy,
     -                  dhheavy2,doheavy2,rij2,ihbtypsltslt,ihbsignslt,
     -                  ihbnum,ihbdonacc(ia),iexptheta,iexpomega,
     -                  ecocoef,ecopcoef,cohhb10,cohhb12,rminhbheavy2,
     -                  cgs,cst,enghb0)
C@dc                      write (6,4811) labcall,ia,ja,ja0,rij2,enghb0
C@dc4811                  format(' ESLTSLTMM ',a,' ia,ja,ja0=',3i6,
C@dc     -                  ' rij2=',f8.4,' enghb0=',e12.5)
                      beg(ja)=beg(ja)+enghb0
                      engrow=engrow+enghb0
                    end if
                  end if
                end if
              end if
            end if
            if (iopdesolv .gt. 0) then
              if (si .ne. 0.0) then
                if (rij2 .lt. gaussdistlim) then
                  sj=s_solv_slt(ja0)
                  if (sj .ne. 0.0) then
                    if (ipolarslt(ia)+ipolarslt(ja0) .lt. 2) then
                      vj=v_solv_slt(ja0)
                      if (ia .gt. ja0) then
                        engdes=(si*vj+sj*vi)*exp(-rij2/gaussdist2)
                      else
                        engdes=(sj*vi+si*vj)*exp(-rij2/gaussdist2)
                      end if
C@dc                      write (6,4812) labcall,ia,ja,ja0,rij2,engdes
C@dc4812                  format(' ESLTSLTMM ',a,' ia,ja,ja0=',3i4,
C@dc     -                  ' rij2=',f8.4,' engdes=',e12.5)
                      beg(ja)=beg(ja)+engdes
                      engrow=engrow+engdes
                    end if
                  end if
                end if
              end if
            end if
          end do
          begr(ia)=begr(ia)+engrow
        end do
      end if
      return
      end
      subroutine esltslttmm(cst,cgs,beg,begr,iclsltt,iclslttt,qslt,
     -  qsltt,ixst,ifsta,ilsta,istf,natsdo,indexats)
c#    MMC routine 200 lstmod: 05/25/08
c*****Calculates solute-solute interaction energy terms between solute atoms
c     Called from esltsltt only
c     mf to ml and istf to natsdo in cst and cgs, resp.
      real*8 beg,begr,engrow
      dimension cst(3,#ST),beg(#ST),begr(#ST),iclsltt(#ST),
     -  iclslttt(#ST),qslt(#ST),qsltt(#ST),cgs(3,#ST),
     -  ixst(#TA),indexats(natsdo)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
C@dc      character*4 labcall
C@dc      common /testprint/ labcall
C@D4      common /eijmol/ eijslto(#ST,#ST),eijsltn(#ST,#ST),
C@D4     -  eijslt(#ST,#ST)
C@PS      write (6,1111)
C@PS1111  format(' The subroutines epsltslv, esltsltmm,and esltslttmm have',
C@PS     -  ' to be replaced ',/,
C@PS     -  'with the parallelizable versions')
C@PS      call datprt(2)
      if (nospecterm .eq. 1) then
        do iaa=ifsta,ilsta
          ia=ixst(iaa)
          cx=cst(1,ia)
          cy=cst(2,ia)
          cz=cst(3,ia)
          engrow=0.d0
          do ja=istf,natsdo
            rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+
     -        (cz-cgs(3,ja))**2
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
C@NR            rij=sqrt(rij2)
            eng=c12tt(iclsltt(ia),iclslttt(ja))/rij12-
     -        c6tt(iclsltt(ia),iclslttt(ja))/rij6+
C@1R     -        (qslt(ia)*qsltt(ja)/rij2)
C@NR     -        (qslt(ia)*qsltt(ja)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
            beg(ja)=beg(ja)+eng
            engrow=engrow+eng
C@D4            eijslt(ia,ja)=eng
C@D4            eijslt(ja,ia)=eng
C@DB            write (6,1712) ia,ja,eng,rij,cx,cgs(1,ja)
C@DB1712        format (' ESLTSLT ia,ja=',2i4,' eng=',e12.5,
C@DB     -        ' rij,cxi,cxj=',3f10.5)
          end do
          begr(ia)=begr(ia)+engrow
        end do
      else
c       Intramolecular solvation term and/or H-bond term is included
        do iaa=ifsta,ilsta
          ia=ixst(iaa)
          si=s_solv_slt(ia)
          vi=v_solv_slt(ia)
          cx=cst(1,ia)
          cy=cst(2,ia)
          cz=cst(3,ia)
          engrow=0.d0
          do ja=istf,natsdo
            ja0=indexats(ja)
            if (ia .gt. ja0) then
              rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
            else
              rij2=(cgs(1,ja)-cx)**2+(cgs(2,ja)-cy)**2+(cgs(3,ja)-cz)**2
            end if
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
C@NR            rij=sqrt(rij2)
            engvdw1=c12tt(iclsltt(ia),iclslttt(ja))/rij12-
     -        c6tt(iclsltt(ia),iclslttt(ja))/rij6
C@1R            engelst=(qslt(ia)*qsltt(ja)/rij2)
C@NR            engelst=(qslt(ia)*qsltt(ja)/rij)
C@RF     -        *(1.0+rij*rij2*rccon)
C@DD     -        *dd_ms_inter(rij)
            eng=engelst+engvdw1
            beg(ja)=beg(ja)+eng
            engrow=engrow+eng
            if (ihbtypsltslt .gt. 0) then
              if (ihbdonacc(ia)*ihbdonacc(ja0) .lt. 0) then
c               Donor-acceptor pair found
                if (rij2 .lt. rmaxhb2) then
                  if (rij2 .gt. rminhb2) then
                    if (ihbdonacc(ia) .gt. 0) then
                      iahyd=ia
                      iahyd0=ia
                      iaox=ja
                      iaox0=ja0
                      iaheavy=iahbheavy(ia)
                      ihbnum=
     -                  ixdonacc(ihbdonacc(iahyd0),-ihbdonacc(iaox0))
                      if (ihbnum .gt. 0) then
                        doheavy2=arrdist(cst(1,iaheavy),cgs(1,iaox))
                        dhheavy2=arrdist(cst(1,iahyd),cst(1,iaheavy))
                      end if
                    else
                      iahyd=ja
                      iahyd0=ja0
                      iaox=ia
                      iaox0=ia
                      iaheavy=ja+(iahbheavy(ja0)-ja0)
                      ihbnum=
     -                  ixdonacc(ihbdonacc(iahyd0),-ihbdonacc(iaox0))
                      if (ihbnum .gt. 0) then
                        doheavy2=arrdist(cgs(1,iaheavy),cst(1,iaox))
                        dhheavy2=arrdist(cgs(1,iahyd),cgs(1,iaheavy))
                      end if
                    end if
                    if (ihbnum .gt. 0) then
                      call hbond(iaox,iaox0,iahyd,iaheavy,
     -                  dhheavy2,doheavy2,rij2,ihbtypsltslt,ihbsignslt,
     -                  ihbnum,ihbdonacc(ia),iexptheta,iexpomega,
     -                  ecocoef,ecopcoef,cohhb10,cohhb12,rminhbheavy2,
     -                  cgs,cst,enghb0)
C@dc                  write (6,4811) labcall,ia,ja,ja0,rij2,enghb0
C@dc4811              format(' ESLTSLTTMM ',a,' ia,ja,ja0=',3i4,
C@dc     -              ' rij2=',f8.4,' enghb0=',e12.5)
                      beg(ja)=beg(ja)+enghb0
                      engrow=engrow+enghb0
                    end if
                  end if
                end if
              end if
            end if
            if (iopdesolv .gt. 0) then
              if (si .ne. 0.0) then
                if (rij2 .lt. gaussdistlim) then
                  sj=s_solv_slt(ja0)
                  if (sj .ne. 0.0) then
                    if (ipolarslt(ia)+ipolarslt(ja0) .lt. 2) then
                      vj=v_solv_slt(ja0)
                      if (ia .gt. ja0) then
                        engdes=(si*vj+sj*vi)*exp(-rij2/gaussdist2)
                      else
                        engdes=(sj*vi+si*vj)*exp(-rij2/gaussdist2)
                      end if
C@dc                      write (6,4812) labcall,ia,ja,ja0,rij2,engdes
C@dc4812                  format(' ESLTSLTTMM ',a,' ia,ja,ja0=',3i4,
C@dc     -                  ' rij2=',f8.4,' engdes=',e12.5)
                      beg(ja)=beg(ja)+engdes
                      engrow=engrow+engdes
                    end if
                  end if
                end if
              end if
            end if
          end do
          begr(ia)=begr(ia)+engrow
        end do
      end if
      return
      end
      subroutine hbond(iaox,iaox0,iahyd,iaheavy,dhheavy2,
     -  doheavy2,rij2,ihbtypsltslt,ihbsign,ihbnum,ihbdonaccia,iexptheta,
     -  iexpomega,ecocoef,ecopcoef,cohhb10,cohhb12,rminhbheavy2,cgs,cst,
     -  enghb0)
c#    MMC routine 200/a lstmod: 08/25/08
c*****Calculates solute-solute interaction energy terms between solute atoms
      dimension cohhb10(100),cohhb12(100),rminhbheavy2(100),
     -  cgs(3,#ST),cst(3,#ST)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      dimension eco(3),b1(3),b2(3),eco2(3),ecop(3),rlp1(3),rlp2(3),
     -  roh(3)
C@dc      dimension rlp(3),rox(3)
      enghb0=0.0
      costheta_sign=(dhheavy2+rij2-doheavy2)
      if (costheta_sign .lt. 0.0) then
c       Form H bond
        r10=rij2**5
        r12=rij2**6
        c12=cohhb12(ihbnum)
        c10=cohhb10(ihbnum)
        if (ihbtypsltslt .eq. 1) then
          enghb0=-(c12/r12-c10/r10)*costheta_sign/
     -      (2.0*sqrt(dhheavy2*rij2))
        else if (ihbtypsltslt .eq. 2) then
c         2-angle expression
          if (nneig(iaox0) .eq. 1) then
c           >C=O acceptor
            iacox0=ineig(1,iaox0)
            iacox=iacox0+(iaox-iaox0)
            if (rminhbheavy2(ihbnum) .gt. 0.0) then
c             Apply N-C filter
              if (ihbdonaccia .gt. 0) then
                dnc2=arrdist(cgs(1,iacox),cst(1,iaheavy))
              else
                dnc2=arrdist(cst(1,iacox),cgs(1,iaheavy))
              end if
C@dc              print *,'dnc2,ihbnum,rminhbheavy2(ihbnum)=',
C@dc     -              dnc2,ihbnum,rminhbheavy2(ihbnum)
              if (dnc2 .lt. rminhbheavy2(ihbnum)) then
                enghb0=0.0
                return
              end if
            end if
            if (iaox0 .eq. ineig(1,iacox0)) then
              iacoxn10=ineig(2,iacox0)
              iacoxn20=ineig(3,iacox0)
            else if (iaox0 .eq. ineig(2,iacox0)) then
              iacoxn10=ineig(1,iacox0)
              iacoxn20=ineig(3,iacox0)
            else
              iacoxn10=ineig(1,iacox0)
              iacoxn20=ineig(2,iacox0)
            end if
            iacoxn1=iacoxn10+(iaox-iaox0)
            iacoxn2=iacoxn20+(iaox-iaox0)
            if (ihbdonaccia .gt. 0) then
              call arrdiff(eco,cgs(1,iaox),cgs(1,iacox),3)
              call arrdiff(b1,cgs(1,iacoxn1),cgs(1,iacox),3)
              call arrdiff(b2,cgs(1,iacoxn2),cgs(1,iacox),3)
              call arrdiff(roh,cst(1,iahyd),cgs(1,iaox),3)
C@dc              call trnsfr(rox,cgs(1,iaox),3)
            else
              call arrdiff(eco,cst(1,iaox),cst(1,iacox),3)
              call arrdiff(b1,cst(1,iacoxn1),cst(1,iacox),3)
              call arrdiff(b2,cst(1,iacoxn2),cst(1,iacox),3)
              call arrdiff(roh,cgs(1,iahyd),cst(1,iaox),3)
C@dc              call trnsfr(rox,cst(1,iaox),3)
            end if
            call vprd(b1,b2,eco2)
            call vprd(eco,eco2,ecop)
            call anorm(eco,3)
            call anorm(ecop,3)
            do k=1,3
              rlp1(k)=ecocoef*eco(k)+ecopcoef*ecop(k)
              rlp2(k)=ecocoef*eco(k)-ecopcoef*ecop(k)
            end do
C@dc            write (6,*) 'ecocoef,ecopcoef=',ecocoef,ecopcoef
C@dc            coslp12=sclprd(rlp1,rlp2)
C@dc            rlp12=acoscheck(coslp12,6,'LP12  ')
C@dc            coslpco=sclprd(rlp1,eco)
C@dc            rlpco=acoscheck(coslpco,6,'LP12  ')
C@dc            print *,'rlp12=',rlp12*180.0/3.141592,
C@dc     -        ' rlpco=',rlpco*180.0/3.141592
          else
c           R-O-H acceptor
            iaoxn10=ineig(1,iaox0)
            iaoxn20=ineig(2,iaox0)
            iaoxn1=iaoxn10+(iaox-iaox0)
            iaoxn2=iaoxn20+(iaox-iaox0)
            if (ihbdonaccia .gt. 0) then
              call arrdiff(b1,cgs(1,iaoxn1),cgs(1,iaox),3)
              call arrdiff(b2,cgs(1,iaoxn2),cgs(1,iaox),3)
              call arrdiff(roh,cst(1,iahyd),cgs(1,iaox),3)
C@dc              call trnsfr(rox,cgs(1,iaox),3)
            else
              call arrdiff(b1,cst(1,iaoxn1),cst(1,iaox),3)
              call arrdiff(b2,cst(1,iaoxn2),cst(1,iaox),3)
              call arrdiff(roh,cgs(1,iahyd),cst(1,iaox),3)
C@dc              call trnsfr(rox,cst(1,iaox),3)
            end if
            call anorm(b1,3)
            call anorm(b2,3)
            call arrsum(eco,b1,b2,3)
            call arrdiff(ecop,b1,b2,3)
            call vprd(eco,ecop,eco2)
            call anorm(eco,3)
            call anorm(eco2,3)
            do k=1,3
              rlp1(k)=ecocoef*eco(k)+ecopcoef*ecop(k)
              rlp2(k)=ecocoef*eco(k)-ecopcoef*ecop(k)
            end do
          end if
C@dc          coslp12=sclprd(rlp1,rlp2)
C@dc          rlp12=acoscheck(coslp12,6,'LP12  ')
C@dc          coslpco=sclprd(rlp1,eco)
C@dc          rlpco=acoscheck(coslpco,6,'LP12  ')
C@dc          print *,'rlp12=',rlp12*180.0/3.141592,
C@dc     -        ' rlpco=',rlpco*180.0/3.141592
          cosomegasign1=sclprd(rlp1,roh)
          cosomegasign2=sclprd(rlp2,roh)
          if (cosomegasign1 .gt. cosomegasign2) then
            cosomegasign=cosomegasign1
            rnormlp=sclprd(rlp1,rlp1)
C@dc            call arrsum(rlp,rox,rlp1,3)
          else
            cosomegasign=cosomegasign2
            rnormlp=sclprd(rlp2,rlp2)
C@dc            call arrsum(rlp,rox,rlp2,3)
          end if
          if (cosomegasign .gt. 0.0) then
            rnormoh=sclprd(roh,roh)
            enghb0=ihbsign*(c12/r12-c10/r10)*(costheta_sign/
     -        (2.0*sqrt(dhheavy2*rij2)))**iexptheta*
     -        (cosomegasign/sqrt(rnormlp*rnormoh))**iexpomega
C@dc            costheta=costheta_sign/(2.0*sqrt(dhheavy2*rij2))
C@dc            theta=acoscheck(costheta,6,'THETA ')
C@dc            cosomega=cosomegasign/sqrt(rnormlp*rnormoh)
C@dc            omega=acoscheck(cosomega,6,'OMEGA ')
C@dc            write (6,4812) theta*180.0/3.14159,omega*180.0/3.14159,rlp
C@dc4812        format(' theta=',e12.5,' omega=',e12.5,' LP=',3f10.5)
          end if
        end if
      end if
      return
      end
      subroutine esltsltmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -  iclslttt,qslt,qsltt,mf,ml,cpl0,cpl1,l0lim,l1lim,indexx,ifdiff)
c#    MMC routine 201 lstmod: 12/13/99
c*****Calculates solute-solute interaction energy terms between solute atoms
c     mf to ml and istf to natsdo in cst and cgs, resp.
      real*8 beg12,beg6,beg1,begr,engr12,engr6,engr1
      dimension cst(3,#ST),begr(#ST),iclsltt(#ST),
     -  beg12(#FE),beg6(#FE),beg1(#FE),cpl0(3),cpl1(3),indexx(#UV),
     -  iclslttt(#UV),qslt(#ST),qsltt(#UV),cgs(3,#UV)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
C@D4      common /eijmol/ eijslto(#ST,#ST),eijsltn(#ST,#ST),
C@D4     -  eijslt(#ST,#ST)
      do ia=mf,ml
        cx=cst(1,ia)
        cy=cst(2,ia)
        cz=cst(3,ia)
        engr12=0.d0
        engr6=0.d0
        engr1=0.d0
        do ja=1,l0lim
          rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          e12=c12tt(iclsltt(ia),iclslttt(ja))/rij12
          e6=c6tt(iclsltt(ia),iclslttt(ja))/rij6
C@NR          rij=sqrt(rij2)
C@1R          e1=(qslt(ia)*qsltt(ja)/rij2)
C@NR          e1=(qslt(ia)*qsltt(ja)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
          beg12(ja)=beg12(ja)+e12
          beg6(ja)=beg6(ja)+e6
          beg1(ja)=beg1(ja)+e1
          engr12=engr12+e12
          engr6=engr6+e6
          engr1=engr1+e1
        end do
        begr(ia)=begr(ia)+engr12*cpl0(1)+engr6*cpl0(2)+engr1*cpl0(3)
        engr12=0.d0
        engr6=0.d0
        engr1=0.d0
        do ja=l0lim+1,l1lim
          rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          e12=c12tt(iclsltt(ia),iclslttt(ja))/rij12
          e6=c6tt(iclsltt(ia),iclslttt(ja))/rij6
C@NR          rij=sqrt(rij2)
C@1R          e1=(qslt(ia)*qsltt(ja)/rij2)
C@NR          e1=(qslt(ia)*qsltt(ja)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
          beg12(ja)=beg12(ja)+e12
          beg6(ja)=beg6(ja)+e6
          beg1(ja)=beg1(ja)+e1
          engr12=engr12+e12
          engr6=engr6+e6
          engr1=engr1+e1
        end do
        begr(ia)=begr(ia)+engr12*cpl1(1)+engr6*cpl1(2)+engr1*cpl1(3)
      end do
      if (ifdiff .ge. 0) then
c       Scatter the beg12-6-1 values if needed
        if (ifdiff .eq. 0) ifdiff=1
        if (ifdiff .le. l1lim) then
c        Find first the current limit of FE solute
          l1limpbc=ifdiff
          do while (indexx(l1limpbc) .lt. l1lim)
            l1limpbc=l1limpbc+1
          end do
          do ia=l1limpbc,ifdiff,-1
            beg12(indexx(ia))=beg12(ia)
            beg12(ia)=0.d0
            beg6(indexx(ia))=beg6(ia)
            beg6(ia)=0.d0
            beg1(indexx(ia))=beg1(ia)
            beg1(ia)=0.d0
          end do
        end if
      end if
      return
      end
      subroutine esltslttmmfe3(cst,cgs,beg12,beg6,beg1,beg,iclsltt,
     -  iclslttt,qslt,qsltt,ixst,ifsta,ilsta,cpl,istfnofe,natsdo)
c#    MMC routine 202 lstmod: 12/09/99
c*****Version of esltslttmm for torsion moved on the fe molecule
      real*8 beg,beg12,beg6,beg1,engr12,engr6,engr1
      dimension cst(3,#ST),beg(#ST),iclsltt(#ST),
     -  beg12(#FE),beg6(#FE),beg1(#FE),cpl(3),
     -  iclslttt(#ST),qslt(#ST),qsltt(#ST),cgs(3,#ST),
     -  ixst(#TA)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      do iaa=ifsta,ilsta
        ia=ixst(iaa)
        cx=cst(1,ia)
        cy=cst(2,ia)
        cz=cst(3,ia)
        engr12=0.d0
        engr6=0.d0
        engr1=0.d0
        do ja=istfnofe,natsdo
          rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          e12=c12tt(iclsltt(ia),iclslttt(ja))/rij12
          e6=c6tt(iclsltt(ia),iclslttt(ja))/rij6
C@NR          rij=sqrt(rij2)
C@1R          e1=(qslt(ia)*qsltt(ja)/rij2)
C@NR          e1=(qslt(ia)*qsltt(ja)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
          beg(ja)=beg(ja)+e12*cpl(1)+e6*cpl(2)+e1*cpl(3)
          engr12=engr12+e12
          engr6=engr6+e6
          engr1=engr1+e1
        end do
        beg12(ia)=beg12(ia)+engr12
        beg6(ia)=beg6(ia)+engr6
        beg1(ia)=beg1(ia)+engr1
      end do
      return
      end
      subroutine esltslttmmfe(cst,cgs,beg12,beg6,beg1,begr,iclsltt,
     -  iclslttt,qslt,qsltt,ixst,ifsta,ilsta,cpl0,cpl1,l0lim,l1lim,
     -  indexx,ifdiff)
c#    MMC routine 203 lstmod: 12/13/99
c*****Calculates solute-solute interaction energy terms between solute atoms
c     ixst(ifsta) to ixst(lsta) and istf to natsdo in cst and cgs, resp.
      real*8 beg12,beg6,beg1,begr,engr12,engr6,engr1
      dimension cst(3,#ST),begr(#ST),iclsltt(#ST),
     -  beg12(#FE),beg6(#FE),beg1(#FE),cpl0(3),cpl1(3),indexx(#ST),
     -  iclslttt(#ST),qslt(#ST),qsltt(#ST),cgs(3,#ST),
     -  ixst(#TA)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      do iaa=ifsta,ilsta
        ia=ixst(iaa)
        cx=cst(1,ia)
        cy=cst(2,ia)
        cz=cst(3,ia)
        engr12=0.d0
        engr6=0.d0
        engr1=0.d0
        do ja=1,l0lim
          rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          e12=c12tt(iclsltt(ia),iclslttt(ja))/rij12
          e6=c6tt(iclsltt(ia),iclslttt(ja))/rij6
C@NR          rij=sqrt(rij2)
C@1R          e1=(qslt(ia)*qsltt(ja)/rij2)
C@NR          e1=(qslt(ia)*qsltt(ja)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
          beg12(ja)=beg12(ja)+e12
          beg6(ja)=beg6(ja)+e6
          beg1(ja)=beg1(ja)+e1
          engr12=engr12+e12
          engr6=engr6+e6
          engr1=engr1+e1
        end do
        begr(ia)=begr(ia)+engr12*cpl0(1)+engr6*cpl0(2)+engr1*cpl0(3)
        eng12w=0.d0
        eng6w=0.d0
        eng1w=0.d0
        do ja=l0lim+1,l1lim
          rij2=(cx-cgs(1,ja))**2+(cy-cgs(2,ja))**2+(cz-cgs(3,ja))**2
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          e12=c12tt(iclsltt(ia),iclslttt(ja))/rij12
          e6=c6tt(iclsltt(ia),iclslttt(ja))/rij6
C@NR          rij=sqrt(rij2)
C@1R          e1=(qslt(ia)*qsltt(ja)/rij2)
C@NR          e1=(qslt(ia)*qsltt(ja)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
          beg12(ja)=beg12(ja)+e12
          beg6(ja)=beg6(ja)+e6
          beg1(ja)=beg1(ja)+e1
          engr12=engr12+e12
          engr6=engr6+e6
          engr1=engr1+e1
        end do
        begr(ia)=begr(ia)+engr12*cpl1(1)+engr6*cpl1(2)+engr1*cpl1(3)
      end do
      if (ifdiff .ge. 0) then
c       Scatter the beg12-6-1 values if needed
        if (ifdiff .eq. 0) ifdiff=1
        if (ifdiff .le. l1lim) then
c        Find first the current limit of FE solute
          l1limpbc=ifdiff
          do while (indexx(l1limpbc) .lt. l1lim)
            l1limpbc=l1limpbc+1
          end do
          do ia=l1limpbc,ifdiff,-1
            beg12(indexx(ia))=beg12(ia)
            beg12(ia)=0.d0
            beg6(indexx(ia))=beg6(ia)
            beg6(ia)=0.d0
            beg1(indexx(ia))=beg1(ia)
            beg1(ia)=0.d0
          end do
        end if
      end if
      return
      end
      subroutine esltsltpbc(c1,c2,shift,ishift,iop5,riijj)
c#    MMC routine 204 lstmod: 05/04/08
      dimension c1(3),c2(3),shift(3)
c*****Obtain the PBC shift and distance between two solute molecules
      common /ecell/ cic(3,27),ncell
      z1=c1(1)-c2(1)
      z2=c1(2)-c2(2)
      z3=c1(3)-c2(3)
      call pbcnd(z1,z2,z3,iop5,ioppbc,riijj)
      ishift=ioppbc-1
      if (ioppbc .gt. 1) then
c       Repeat PBC
        shift(1)=cic(1,ioppbc)
        shift(2)=cic(2,ioppbc)
        shift(3)=cic(3,ioppbc)
        call pbcnd(z1,z2,z3,iop5,ioppbc,riijj)
        if (ioppbc .gt. 1) then
          shift(1)=shift(1)+cic(1,ioppbc)
          shift(2)=shift(2)+cic(2,ioppbc)
          shift(3)=shift(3)+cic(3,ioppbc)
        end if
      end if
      return
      end
      subroutine esltslt14(cst,ixst,ifst,ilst,nneig3,nneig4,ineig,
     -  iclsltt,qslt,esf14,vdwf14,e14sum,indexx,noeng,maxneig)
c#    MMC routine 205 lstmod: 08/19/17
c*****Calculates solute-solute interaction energies between all solvents
c     and part of the solute. Solute indices are in ixst
      real*8 e14sum,essum,vdwsum
      dimension cst(3,#ST),ixst(#TA),nneig3(#ST),nneig4(#ST),
     -  ineig(maxneig,#ST),iclsltt(#ST),qslt(#ST),
     -  indexx(#UV)
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      essum=0.d0
      vdwsum=0.d0
      e14sum=0.d0
      if (noeng .gt. 1) return
      do iaa=ifst,ilst
        ia=ixst(iaa)
        cx=cst(1,ia)
        cy=cst(2,ia)
        cz=cst(3,ia)
        nn4=nneig4(ia)-nneig3(ia)
        do in=1,nn4
          indexx(in)=ineig(in+nneig3(ia),ia)
        end do
c       Eliminate ixst(jaa), jaa>iaa from the 1-4 ng list
        jaa=iaa+1
        ing=1
        do while (jaa .le. ilst)
          do while (indexx(ing) .lt. ixst(jaa) .and. ing .lt. nn4)
            ing=ing+1
          end do
          if (indexx(ing) .eq. ixst(jaa)) indexx(ing)=0
          jaa=jaa+1
        end do
c       Condense the list
        nng=nn4
        do in=1,nn4
          do while (indexx(in) .eq. 0 .and. in .le. nng)
            do ii=in+1,nng
              indexx(ii-1)=indexx(ii)
            end do
            nng=nng-1
          end do
        end do
        do in=1,nng
          ja=indexx(in)
          rij2=(cx-cst(1,ja))**2+(cy-cst(2,ja))**2+(cz-cst(3,ja))**2
          rij6=rij2*rij2*rij2
          rij12=rij6*rij6
          vdwsum=vdwsum+c12tt14(iclsltt(ia),iclsltt(ja))/rij12-
     -      c6tt14(iclsltt(ia),iclsltt(ja))/rij6
C@NR          rij=sqrt(rij2)
C@1R          essum=essum+(qslt(ia)*qslt(ja)/rij2)
C@NR          essum=essum+(qslt(ia)*qslt(ja)/rij)
C@RF     -      *(1.0+rij*rij2*rccon)
C@DD     -      *dd_ms_inter(rij)
C@DB              ev=c12tt(iclsltt(ia),iclsltt(ja))/rij12-
C@DB     -          c6tt(iclsltt(ia),iclsltt(ja))/rij6
C@DB              ee=qslt(ia)*qslt(ja)/rij
C@DB              write (6,1711) ia,ja,ee,ev,rij,cx,cst(1,ja)
C@DB1711          format (' ESLTSLT14 ia,ja=',2i4,' ees,evdw=',2e12.5,
C@DB     -          ' rij,cxi,cxj=',3f10.5)
        end do
      end do
      e14sum=esf14*essum+vdwf14*vdwsum
      return
      end
      subroutine getcent(c0,cent,cst,molcnt)
c#    MMC routine 206 lstmod: 04/23/97
c*****Pick up the molecule center
      dimension c0(3),cent(3),cst(3,#ST)
      if (molcnt .gt. 0) then
        do k=1,3
          c0(k)=cst(k,molcnt)
        end do
      else
        do k=1,3
          c0(k)=cent(k)
        end do
      end if
      return
      end
      subroutine esltfield(cst,indexx,nstf,nstl,engfld,esltfld,
     -  ifieldtyp,inperr,iout,ixmax)
c#    MMC routine 207 lstmod: 01/06/15
c*****Calculates field-dependent energy for the solute molecule using
c     only atoms indexx(iafirst)-indexx(ialast)
c     NOTE: Charges have been divided by SQRT(dielc)
      real*8 engfld
      dimension cst(3,#ST),indexx(ixmax),esltfld(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /energymap/ engmap(#GM,#GM,#GM,10),gridmapcent(3),
     -  nemap,ngridmap,gridmap,edgemap,edgemap2,scalemap,evdwlim,
     -  elstatmin,hbgrid,gridedgeinc(3),egridmin(3),egridmax(3),
     -  mapedone,nhbgrid,maxhbng,maxhbgrid,maptyph,
     -  nhbaccng(#GH,#GH,#GH),nhbdonng(#GH,#GH,#GH),
     -  ihbng(25,#GH,#GH,#GH)
      common /griderror/ ngriderr,nhbgriderr,igridprint,griderrmax
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      common /fieldpot/ niparf,nrparf,niparm,nrparm,intf(10),intm(10),
     -  rf(10),rm(10)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /option/ iop(200),idebug(200)
      engfld=0.d0
c     Hydrogen should be the last of the atom list
      if (ifieldtyp .le. 3) then
c       Map-based potentials
        do iaa=nstf,nstl
c         Work with cst(k,ia) here
          ia=indexx(iaa)
          if (isltmv(ia) .gt. 0) then
            newmap=1
            if (qslt(ia) .ne. 0.0) then
              engelst=esltmap(cst(1,ia),engmap(1,1,1,maxmaptyp),
     -          gridedgeinc,egridmin,egridmax,gridmap,ngridmap,newmap,
     -          jg,kg,lg,c000,c010,c001,c100,c110,c101,c011,c111,
     -          iorig_of_split(ia),evdwlim,idebug(134)-3,inperr,
     -          igriderr,iout)
              if (igriderr .eq. 0) then
                engelst=engelst*qslt(ia)
              else
                engvdw=0.0
                enghb=0.0
                go to 100
              end if
              newmap=0
            else
              engelst=0.0
            end if
            maptyp=iatdtypslt(ia)
            enghb=0.0
            if (maptyp .lt. maxmaptyp-1) then
c             Van der Waals term
              engvdw=esltmap(cst(1,ia),engmap(1,1,1,maptyp),
     -          gridedgeinc,egridmin,egridmax,gridmap,ngridmap,newmap,
     -          jg,kg,lg,c000,c010,c001,c100,c110,c101,c011,c111,
     -          iorig_of_split(ia),evdwlim,idebug(134)-3,inperr,
     -          igriderr,iout)
              newmap=0
c             Loop-protein contribution to desolvation term
c             Loop-loop contributions are calculated in esltsltt, esltslttmm and
c             intrasums
              if (qslt(ia)*s_solv_slt(ia) .ne. 0.0 .and.
     -           ((iop(113) .ne. 4  .and. iop(113) .ne. 5) .or.
     -             (ianslt(ia) .eq. 6 .and. ipolarslt(ia) .eq. 0))) then
                engvdw=engvdw+abs(qslt(ia))*
     -            esltmap(cst(1,ia),engmap(1,1,1,maxmaptyp-1),
     -            gridedgeinc,egridmin,egridmax,gridmap,ngridmap,newmap,
     -            jg,kg,lg,c000,c010,c001,c100,c110,c101,c011,c111,
     -            iorig_of_split(ia),evdwlim,idebug(134)-3,inperr,
     -            igriderr,iout)
              end if
c             Hydrogen-bonding term
              if (ihbtypsltmap .gt. 0) then
                if (( maptyp .eq. maptyph .or. maptyp .eq. maptyphh)
     -            .and. ihbdonacc(ia) .gt. 0) then
                  ix=(cst(1,ia)+gridedgeinc(1))/hbgrid+1
                  iy=(cst(2,ia)+gridedgeinc(2))/hbgrid+1
                  iz=(cst(3,ia)+gridedgeinc(3))/hbgrid+1
                  if (ix .lt. 1 .or. iy .lt. 1 .or. iz .lt. 1 .or.
     -                ix .gt. #GH .or. iy .gt. #GH .or.
     -                iz .gt. #GH) then
                    if (igridprint .gt. 0)
     -                write (iout,1003) ia,(cst(k,ia),k=1,3)
                    enghb=0
                    nhbgriderr=nhbgriderr+1
                    go to 100
                  end if
                  do ing=1,nhbaccng(ix,iy,iz)
                    iox=ihbng(ing,ix,iy,iz)
                    ihbnum=
     -                ixdonacc(ihbdonacc(ia),-ihbdonacc(iox))
                    if (ihbnum .gt. 0) then
                      rhb2=arrdist(cst(1,ia),cslt(1,iox))
                      if (rhb2 .lt. rmaxhb2) then
                        if (rhb2 .gt. rminhb2) then
                          iaheavy=ineig(1,ia)
                          doheavy2=arrdist(cst(1,iaheavy),cslt(1,iox))
                          dhheavy2=arrdist(cst(1,ia),cst(1,iaheavy))
                          call hbond(iox,iox,ia,iaheavy,dhheavy2,
     -                      doheavy2,rhb2,ihbtypsltmap,ihbsignmap,
     -                      ihbnum,ihbdonacc(ia),iexptheta,iexpomega,
     -                      ecocoef,ecopcoef,cohhb10,cohhb12,
     -                      rminhbheavy2,cslt,cst,enghb0)
C@dc                          write (iout,1002) ia,ing,iox,sqrt(rhb2),
C@dc     -                      enghb0,engvdw,enghb
                            enghb=enghb+enghb0
                        end if
                      end if
                    end if
                  end do
                  if (ihbtypsltmap .gt. 1) then
c                   H-bond donor from the protein
                    do ing=maxhbng,maxhbng+1-nhbdonng(ix,iy,iz),-1
                      ihyd=ihbng(ing,ix,iy,iz)
                      iox=ia
                      ihbnum=
     -                  ixdonacc(ihbdonacc(ihyd),-ihbdonacc(iox))
                      if (ihbnum .gt. 0) then
                        rhb2=arrdist(cst(1,iox),cslt(1,ihyd))
                        if (rhb2 .lt. rmaxhb2) then
                          if (rhb2 .gt. rminhb2) then
                            iaheavy=ineig(1,ihyd)
                            doheavy2=arrdist(cslt(1,iaheavy),cst(1,iox))
                            dhheavy2=arrdist(cslt(1,ihyd),
     -                        cslt(1,iaheavy))
                            call hbond(iox,iox,ia,iaheavy,dhheavy2,
     -                        doheavy2,rhb2,ihbtypsltmap,ihbsignmap,
     -                        ihbnum,ihbdonacc(iox),iexptheta,iexpomega,
     -                        ecocoef,ecopcoef,cohhb10,cohhb12,
     -                        rminhbheavy2,cst,cslt,enghb0)
C@dc                            write (iout,1002) ihyd,ing,iox,sqrt(rhb2),
C@dc     -                        enghb0,engvdw,enghb
                              enghb=enghb+enghb0
                          end if
                        end if
                      end if
                    end do
                  end if
                end if
              end if
            else
              engvdw=0.0
            end if
100         eng=engelst+engvdw+enghb
            esltfld(ia)=eng
            if (idebug(134) .gt. 1) write (iout,1000) iaa,ia,maptyp,
     -        (cst(k,ia),k=1,3),engelst,engvdw,enghb,eng,ianslt(ia)
            engfld=engfld+eng
          else
            esltfld(ia)=0.0
          end if
        end do
        if (idebug(134) .gt. 0)
     -     write (iout,1001) engfld,gridedgeinc,gridmap
      end if
      return
1000  format(i4,i7,' maptyp=',i2,' c=',3f10.5,' Eelst=',e12.5,
     -  ' Evdw=',e12.5,' Ehb=',e12.5,' E=',e12.5,' atno=',i3)
1001  format(' E(map)=',e12.5,'  edgeinc=',3f10.5,' gridmap=',f8.5)
C@dc1002  format(' ia,ing,iox=',3i4,' rhb=',f6.3,
C@dc     -  ' enghb0=',e13.5,' engvdw,enghb=',2e13.5)
1003  format(' ERROR: solute atom ',i5,' c=',3f10.4,' is outside ',
     -  'the hydrogen-bond grid')
      end
      function esltmap(c,emap,edgeinc,egridmin,egridmax,grid,ngrid,
     -  newgrid,j,k,l,c000,c010,c001,c100,c110,c101,c011,c111,ia,
     -  evdwlim,levtest,inperr,igriderr,iout)
c#    MMC routine 207/a lstmod: 05/28/20
c*****Calculate the energy of atom c in the field of the map emap
c     Code from Dr. Meng Cui
      dimension c(3),emap(#GM,#GM,#GM),edgeinc(3),egridmin(3),
     -  egridmax(3)
      if (newgrid .eq. 1) then
        igriderr=0
        griderr=0.0
        call setgridindex(c,1,j,dx,edgeinc(1),egridmin(1),
     -    egridmax(1),grid,ngrid,ia,inperr,igriderr,griderr,iout)
        call setgridindex(c,2,k,dy,edgeinc(2),egridmin(2),
     -    egridmax(2),grid,ngrid,ia,inperr,igriderr,griderr,iout)
        call setgridindex(c,3,l,dz,edgeinc(3),egridmin(3),
     -    egridmax(3),grid,ngrid,ia,inperr,igriderr,griderr,iout)
c       Coefficients:
        dxdy=dx*dy
        dxdz=dx*dz
        dydz=dy*dz
        dxdydz=dxdy*dz
        dy_dydz=dy-dydz
        dz_dydz=dz-dydz
        dx_dxdy=dx-dxdy
        dz_dxdz=dz-dxdz
        c000=1.0-dx_dxdy-dy_dydz-dz_dxdz-dxdydz
        c100=dx_dxdy-dxdz+dxdydz
        c010=dy_dydz-dxdy+dxdydz
        c001=dz_dydz-dxdz+dxdydz
        c110=dxdy-dxdydz
        c101=dxdz-dxdydz
        c011=dydz-dxdydz
        c111=dxdydz
      end if
      if (igriderr .gt. 0) then
        esltmap=evdwlim*(1.0+griderr)
        return
      end if
c     Potential energy
      esltmap=
     -  emap(j,k,l)*c000+
     -  emap(j+1,k,l)*c100+
     -  emap(j,k+1,l)*c010+
     -  emap(j,k,l+1)*c001+
     -  emap(j+1,k+1,l)*c110+
     -  emap(j+1,k,l+1)*c101+
     -  emap(j,k+1,l+1)*c011+
     -  emap(j+1,k+1,l+1)*c111
      if (levtest .gt. 0) write (iout,1000)
     -  c,j,k,l,emap(j,k,l),dx,dy,dz,esltmap,newgrid,edgeinc
      return
1000  format(' c=',3f8.3,' j,k,l=',3i4,' emap(j,k,l)=',f15.5,
     -  ' dx,dy,dz=',3f7.4,' emap=',f15.5,/,
     -  ' newgrid=',i1,' edgeinc=',3f10.5)
      end
      subroutine setgridindex(c,ix,jkl,dxyz,edgeinc,egridmin,
     -  egridmax,grid,ngrid,ia,inperr,igriderr,griderr,iout)
c#    MMC routine 207/b lstmod: 04/23/15
c*****Get the grid corner index or the ix-th coordinate
      dimension c(3)
      character*1 lxyz
      common /names/ lxyz(3)
      common /griderror/ ngriderr,nhbgriderr,igridprint,griderrmax
      jkl=int((c(ix)+edgeinc)/grid)
      dxyz=(c(ix)+edgeinc)/grid-jkl
      if (jkl .lt. 1 .or. jkl .ge. ngrid) then
c       dev=(jkl-ngrid)*grid
c       if (jkl .lt. 1) dev=(1-jkl)*grid
        if (jkl .lt. 1) then
          dev=egridmin-c(ix)+0.001
        else
          dev=c(ix)-egridmax+0.001
        end if
        if (igridprint .gt. 0)
     -    write (iout,1000) ia,lxyz(ix),dev,lxyz(ix),jkl,grid,
     -      edgeinc,c
        ngriderr=ngriderr+1
        if (igriderr .eq. 0) igriderr=1
        if (jkl+1 .gt. ngrid) then
          jkl=ngrid-1
          griderr0=c(ix)+edgeinc-grid*ngrid
        else
          jkl=2
          griderr0=-(edgeinc+c(ix))
        end if
        if (griderr0 .gt. griderr) griderr=griderr0
        if (griderr .gt. griderrmax) griderrmax=griderr
      else if (dxyz .lt. 0.0 .or. dxyz .gt. 1.0) then
        if (dxyz .lt. 0.0 .and. dxyz .gt. -1.e-5) then
          dxyz=0.0
        else if (dxyz .gt. 1.0 .and. dxyz .lt. 1.00001) then
          dxyz=1.0
        else
          write (iout,1001) lxyz(ix),jkl,dxyz,edgeinc,c
          inperr=inperr+1
        end if
      end if
      return
1000  format(' ----- WARNING: atom #',i6,' is outside the grid; ',
     -  a1,'dev=',f6.2,1x,a1,'grid#:',i4,' grid,edgeinc=',f6.3,f8.3,
     -  ' c=',3f8.2)
c1000  format(' ----- WARNING: ',a,' coordinate is outside the grid; ',
c     -  'grid#:',i4,' grid,edgeinc=',f6.3,f8.3,
c     -  ' atom#:',i5,' c=',3f8.2)
1001  format(' PROGRAM ERROR in grid weight:' ,a,'=',i4,' dxyz=',f10.5,
     -  ' e2=',f10.5,' c=',3f10.5)
      end
      subroutine addox(ia,nhbdonng,nhbaccng,ihbng,ix,iy,iz,ihydox,
     -  inperr,iout,ngrid,maxg,maxng)
      dimension nhbaccng(maxg,maxg,maxg),nhbdonng(maxg,maxg,maxg),
     -  ihbng(maxng,maxg,maxg,maxg)
c#    MMC routine 207/c lstmod: 05/31/08
c*****Add ia to the Oxygen neighbor list of grid (ix,iy,iz)
      if (min0(ix,iy,iz) .gt. 0 .and.
     -    max0(ix,iy,iz) .le. ngrid) then
        if (ihydox .eq. -1) then
c         Oxygen acceptor
          if (nhbaccng(ix,iy,iz) .lt. 0) then
            nhbaccng(ix,iy,iz)=nhbaccng(ix,iy,iz)-1
          else if (nhbaccng(ix,iy,iz) .lt.
     -             maxng-nhbdonng(ix,iy,iz)) then
            nhbaccng(ix,iy,iz)=nhbaccng(ix,iy,iz)+1
            ihbng(nhbaccng(ix,iy,iz),ix,iy,iz)=ia
          else
            write (iout,1000) maxng,ix,iy,iz
            inperr=inperr+1
            nhbaccng(ix,iy,iz)=-1
          end if
        else
c         Hydrogen donor
          if (nhbdonng(ix,iy,iz) .lt. 0) then
            nhbdonng(ix,iy,iz)=nhbdonng(ix,iy,iz)-1
          else if (nhbaccng(ix,iy,iz) .lt.
     -             maxng-nhbdonng(ix,iy,iz)) then
            nhbdonng(ix,iy,iz)=nhbdonng(ix,iy,iz)+1
            ihbng(maxng+1-nhbdonng(ix,iy,iz),ix,iy,iz)=ia
          else
            write (iout,1000) maxng,ix,iy,iz
            inperr=inperr+1
            nhbdonng(ix,iy,iz)=-1
          end if
        end if
      end if
      return
1000  format(' ERROR: maximum number of hydrogens and oxygens per ',
     -  'grid (',i2,') exceeed for grid ',3i4)
      end
      subroutine readtypelist(ninp,ityplist,ioppf,pflab,key0,key,
     -  pftyp,inperr,iout,maxtyp)
c#    MMC routine 207/d lstmod: 05/04/15
c*****Read in a list of pf labels for pf type ioppf, convert it to type numbers
      dimension ityplist(20)
      character*4 key0,key,pftyp
      character*6 pflab(#AT,11),stuff
      call getint(ninp,1,1,1)
      if (ninp .gt. maxtyp) then
        write (iout,2019) maxtyp,key0,ninp
        inperr=inperr+1
        ninp=maxtyp
      end if
      do i=1,ninp
        stuff='      '
        call getname(stuff,namlen,1,6)
        call find(stuff,1,#AT,pflab(1,ioppf),icl,6)
        if (icl .eq. 0) then
          write (iout,2116) stuff,pftyp,key0,key
          inperr=inperr+1
          icl=1
        end if
        ict=icl+#AT*ioppf
        ityplist(i)=ict
      end do
      return
2019  format(' ***** ERROR: maximum number of types to read (',
     -  i3,') for key ',a,' is exceeded:',i4)
2116  format(' ***** ERROR: potential label ',a,' is not found for ',
     -  'potential type ',a,/,' Keys used were: ',a,1x,a)
      end
      subroutine hbondsetup(nogridrun,iout)
c#    MMC routine 207/e lstmod: 05/19/16
c*****Input/initialize hydrogen bond calculations
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      character*80 line
      common /inpline/ line,lineno,icol
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      ihbtypsltmap=ihbtypsltmap-1
      if (ihbtypsltmap .eq. 2 .or. ihbtypsltslt .eq. 2) then
        iop(112)=2
      else if (ihbtypsltmap+ihbtypsltslt .gt. 0) then
        iop(112)=1
      end if
      if (iop(112) .eq. 0) return
      nospecterm=0
      call getreal(rmaxhb,0,3.0)
      call getreal(rminhb,0,1.65)
      rmaxhb2=rmaxhb**2
      rminhb2=rminhb**2
      call getreal(qsalthbdonmin,0,0.3)
      call getreal(qsalthbaccmax,0,-0.55)
      call getint(iexptheta,0,1,2)
      call getint(iexpomega,0,1,4)
      call getreal(colpang,0,120.0)
      ecocoef=cos((colpang/2.0)/rdtodg)
      ecopcoef=sin((colpang/2.0)/rdtodg)
C@dc      write (6,*) 'colpang,ecocoef,ecopcoef=',
C@dc     -  colpang,ecocoef,ecopcoef
      if (ihbtypsltslt .eq. 2 .and. mod(iexptheta,2) .eq. 0)
     -  ihbsignslt=+1
      if (ihbtypsltmap .eq. 2 .and. mod(iexptheta,2) .eq. 0)
     -  ihbsignmap=+1
c     Donor hydrogen: iahbheavy(ia)=atom number of the H's heavy atom
      call zeroiti(iahbheavy,0,nstta_full)
c     Acceptor oxygen: ihbdonacc(ia)=-1 (O=C<) -2: H-O-R or R-O-R;
c     Donor hydrogen: ihbdonacc(ia)=1: >NH; 2: -OH 3: >NH+
      call zeroiti(ihbdonacc,0,nstta_full)
c     ixdonacc(i,j): interaction type (see block data for types 1-6)
c     (1,1): >NH...O=C< ;  (1,2): >NH...O-H
c     (2,1): -OH...O=C< ;  (2,2): -OH...O-H
c     Set default H-bond parameters (modify them with HBMO ADDC)
c     Published paper's constants:
c     cohhb10(4)=4610.0
c     cohhb12(1)=12040.0
c     cohhb10(1)=4014.0
c     cohhb12(2)=13344.0
c     cohhb10(2)=5783.0
c     cohhb12(3)=5890.0
c     cohhb10(3)=2624.0
c     cohhb12(4)=11220.0
c     H(O)
c     Previous non-salt bridge generic values: c10: 9298  c12:25820
c     Latest non-salt bridge generic values: c12: 29513   c10:10628
      cohhb12(2)=29513.
      cohhb10(2)=10628.
      cohhb12(4)=29513.
      cohhb10(4)=10628.
      cohhb12(7)=11063.
      cohhb10(7)=3984.
c     H(N)
      cohhb12(1)=29513.
      cohhb10(1)=10628.
      cohhb12(3)=29513.
      cohhb10(3)=10628.
      cohhb12(8)=11063.
      cohhb10(8)=3984.
c     H+(N)
      cohhb12(5)=11063.
      cohhb10(5)=3984.
      cohhb12(6)=11063.
      cohhb10(6)=3984.
      cohhb12(9)=11063.
      cohhb10(9)=3984.
      call zeroiti(ihbdonacc,nstta_full,#ST)
      nhbdonaccp=0
      do ia=1,nstta_full
        call hbdonacctype(ia,ia,ianslt,qslt,nneig,ineig,
     -    qsalthbdonmin,qsalthbaccmax,ihbdonacc,iahbheavy,
     -    0,#NL,#ST)
        if (ihbdonacc(ia) .ne. 0) then
          nhbdonaccp=nhbdonaccp+1
          indexhb(nhbdonaccp)=ia
        end if
      end do
      if (nogridrun .eq. 0) then
        write (iout,2000) 'found',nhbdonaccp
        if (nstta_full .gt. nstta) write (iout,2001) nstta_full-nstta
      end if
      return
2000  format(' Number of donor/acceptor information records ',a,'=',i4)
2001  format(' Number of atoms contributing to the energy maps=',i5)
      end
      subroutine hbdonacctype(ia,ihb,ianslt,qslt,nneig,ineig,
     -  qsalthbdonmin,qsalthbaccmax,ihbdonacc,iahbheavy,nodonor,
     -  maxneig,maxat)
c#    MMC routine 207/f lstmod: 01/23/11
c*****Assign hydrogen-bond donor/acceptor types
      dimension ianslt(maxat),qslt(maxat),nneig(maxat),
     -  ineig(maxneig,maxat),ihbdonacc(maxat),iahbheavy(maxat)
c     character*4 labslt(2,maxat)
c     character*3 resnam1
c     character*4 atom1,atom2
      if (ianslt(ia) .eq. 8) then
c       Acceptor oxygen
        if (nneig(ia) .eq. 1) then
          in=ineig(1,ia)
c         atom1=labslt(1,ia)
c         call leftadjust(atom1,atom1,4)
c         resnam1=atom1(1:3)
c         if (resnam1 .eq. 'ASP' .or. resnam1 .eq. 'GLU' .or.
c    -        resnam1 .eq. 'ASX' .or. resnam1 .eq. 'GLX') then
c           atom1=labslt(2,ia)
c           atom2=labslt(2,in)
c           call leftadjust(atom1,atom1,4)
c           call leftadjust(atom2,atom2,4)
c           if (atom1 .eq. 'O   ' .and. atom2 .eq. 'C   ') then
          if (qslt(ia) .gt. qsalthbaccmax) then
            ihbdonacc(ihb)=-1
          else
            ihbdonacc(ihb)=-3
          end if
        else if (nneig(ia) .eq. 2) then
          ihbdonacc(ihb)=-2
        end if
      else if (nodonor .eq. 0) then
        if (ianslt(ia) .eq. 1 .and. nneig(ia) .gt. 0) then
          iahbheavy(ihb)=ineig(1,ia)
          if (ianslt(iahbheavy(ihb)) .eq. 7) ihbdonacc(ihb)=1
          if (ianslt(iahbheavy(ihb)) .eq. 8) then
            if (qslt(ia) .le. qsalthbdonmin) then
              ihbdonacc(ihb)=2
            else
              ihbdonacc(ihb)=3
            end if
          end if
        end if
      end if
      return
      end
      subroutine setatdtype(n,maxmaptyp,naromc,iatdtypslt,ianatdtyp,
     -  ianslt,iaromc,indextyp,iclsltt,nneig,ineig,maxneig,
     -  max_atdtyp,inperr,iout)
c#    MMC routine 207/e lstmod: 01/13/11
      dimension iatdtypslt(n),iaromc(100),iclsltt(n),ianslt(n),
     -  ianatdtyp(100),indextyp(#UU),nneig(n),ineig(maxneig,n)
c*****Establish Autodock types for the solute atoms
      do ia=1,n
        iatdtypslt(ia)=ianatdtyp(ianslt(ia))
        if (iatdtypslt(ia) .lt. 0) then
          write (iout,2000) ianslt(ia)
          inperr=inperr+1
        else if (iatdtypslt(ia) .eq. 0) then
          iatdtypslt(ia)=max_atdtyp+1
        else
          if (ianslt(ia) .eq. 6) then
c           See if aromatic
            do i=1,naromc
              if (iaromc(i) .eq. indextyp(iclsltt(ia)))
     -          iatdtypslt(ia)=iatdtypslt(ia)+1
            end do
          else if (ianslt(ia) .eq. 1) then
c           Drop aliphatic (carbon-bonded) hydrogens
            iaheavy=ineig(1,ia)
            if (ianslt(iaheavy) .eq. 6) iatdtypslt(ia)=max_atdtyp+1
c???        -OH hydrogens are different donors
c           if (ianslt(iaheavy) .eq. 8) iatdtypslt(ia)=iatdtypslt(ia)+1
c         else if (ianslt(ia) .eq. 8) then
c           >C=O oxygen is different acceptor (in principle)
c           if (nneig(ia) .eq. 1) iatdtypslt(ia)=maxmaptyp-2
          end if
        end if
      end do
      if (naromc .eq. 0) then
        write (iout,2209)
        inperr=inperr+1
      end if
      return
2000  format(' ***** ERROR: no map was read for atomic number ',i2)
2209  format(' ***** ERROR: aromatic atom types have to be specified ',
     -  'with the AROM key')
      end
      subroutine setdesolvparams(iopsolv,keep,ia,ianslt,qslt,ipolarslt,
     -  iatdtypslt,qpolarcarbmin,v_solv_slt,s_solv_slt,
     -  v_solv_par,a_solv_par,qk_par,nslt,iout,inperr,max_atdtyp)
c#    MMC routine 207/f lstmod: 01/12/12
      dimension ianslt(nslt),qslt(nslt),ipolarslt(nslt),
     -  iatdtypslt(nslt),v_solv_slt(nslt),s_solv_slt(nslt),
     -  v_solv_par(max_atdtyp),a_solv_par(max_atdtyp)
c#    MMC routine 207/f lstmod: 02/01/11
      keep=1
      if (iopsolv .eq. 2) then
c       Drop non-carbons
        if (ianslt(ia) .ne. 6) keep=0
      else if (iopsolv .eq. 3) then
c       Drop hydrogens
        if (ianslt(ia) .eq. 1) keep=0
      else if (iopsolv .eq. 4) then
        if (ianslt(ia) .eq. 6) then
          if (qslt(ia) .le. qpolarcarbmin) ipolarslt(ia)=0
        end if
      else if (iopsolv .eq. 5) then
c       Drop non-carbons and polar carbons
        if (ianslt(ia) .ne. 6 .or.
     -      qslt(ia) .ge. qpolarcarbmin) keep=0
        if (ianslt(ia) .eq. 6 .and.
     -      qslt(ia) .ge. qpolarcarbmin) ipolarslt(ia)=1
      end if
      if (iatdtypslt(ia) .eq. max_atdtyp+1) keep=0
      if (iatdtypslt(ia) .lt. 1 .or.
     -    iatdtypslt(ia) .gt.  max_atdtyp+1) then
        keep=0
        write (iout,1000) iatdtypslt(ia)
        inperr=inperr+1
      end if
      if (keep .eq. 1) then
        v_solv_slt(ia)=v_solv_par(iatdtypslt(ia))
        s_solv_slt(ia)=a_solv_par(iatdtypslt(ia))+
     -    qk_par*abs(qslt(ia))
      end if
      return
1000  format(' ***** (PROGRAM?) ERROR: invalid ATD type=',i9)
      end
      subroutine readbond(ifiletyp,nats,inpt,nneig,nneigh,ineig,ianslt,
     -  nats_full,isplit_of_orig,inperr,iout,maxng,maxat)
c#    MMC routine 207/i lstmod: 05/26/20
      dimension nneig(nats),nneigh(nats),ineig(maxng,nats),ianslt(nats),
     -  isplit_of_orig(nats_full)
      dimension i20(20)
      character*6 stuff
      character*25 read_format
      character*80 liner
      map=0
      if (nats_full .gt. nats) map=1
      if (ifiletyp .eq. 1) then
c       MAKB syntax
        iok=0
        read(inpt,1000,end=100) liner
c       write (iout,*) liner
        icol=1
        call getname(stuff,lstuff,1,80)
        call getint(ntotbond,0,1,0)
        write (iout,2007) ntotbond
        do nbr=1,ntotbond
          call getint(i1,0,1,0)
          call getint(i2,0,1,0)
          call checklim(ifail,iout,inperr,1,nats_full,i1,1,'atom index',
     -      10)
          call checklim(ifail,iout,inperr,1,nats_full,i2,1,'atom index',
     -      10)
          if (map .eq. 1) then
            i1=isplit_of_orig(i1)
            i2=isplit_of_orig(i2)
          end if
          if (max0(i1,i2) .le. nats) then
            nneig(i1)=nneig(i1)+1
            nneig(i2)=nneig(i2)+1
            ineig(nneig(i1),i1)=i2
            ineig(nneig(i2),i2)=i1
            if (ianslt(i1) .eq. 1) nneigh(i2)=nneigh(i2)+1
            if (ianslt(i2) .eq. 1) nneigh(i1)=nneigh(i1)+1
          end if
        end do
      else if (ifiletyp .eq. 2) then
c       Charmm PSF syntax
        call find_n_psf(inpt,nerr,0,nat_psf,'!NATOM',6,iout)
        if (nat_psf .ne. nats) then
          write (iout,2000) nats,nat_psf
          inperr=inperr+1
        end if
        call find_n_psf(inpt,nerr,0,natbond,'!NBOND',6,iout)
        if (nerr .gt. 0) then
          inperr=inperr+1
          return
        end if
        nwr=natbond
        nbr=0
        do while (nwr .gt. 0)
          nb=min0(4,nwr)
          read (inpt,1001,err=100) (i20(i),i=1,2*nb)
          do i=1,nb
            i1=i20(2*i-1)
            i2=i20(2*i)
            call checklim(ifail,iout,inperr,1,nats_full,i1,1,
     -        'atom index',10)
            call checklim(ifail,iout,inperr,1,nats_full,i2,1,
     -        'atom index',10)
            if (map .eq. 1) then
              i1=isplit_of_orig(i1)
              i2=isplit_of_orig(i2)
            end if
            if (max0(i1,i2) .le. nats) then
              nneig(i1)=nneig(i1)+1
              nneig(i2)=nneig(i2)+1
              ineig(nneig(i1),i1)=i2
              ineig(nneig(i2),i2)=i1
              if (ianslt(i1) .eq. 1) nneigh(i2)=nneigh(i2)+1
              if (ianslt(i2) .eq. 1) nneigh(i1)=nneigh(i1)+1
            end if
          end do
          nwr=nwr-nb
          nbr=nbr+nb
        end do
        if (nbr .ne. natbond) then
          write (iout,*) '***** PROGRAM ERROR: nbr=',nbr,
     -      ' natbond=',natbond
          inperr=inperr+1
        end if
      else if (ifiletyp .eq. 3) then
c       Amber top syntax
        call find_ambertyp(inpt,'%FLAG BONDS_INC_HYDROGEN',24,
     -    read_format,lread_format,iout)
        call zeroiti(nneig,0,nats)
        call zeroiti(nneigh,0,nats)
        ierrtop=1
        ic=2
        do while (isdigit(read_format(ic:ic)) .eq. 1)
          ic=ic+1
        end do
        read (read_format(2:ic-1),*,err=100,end=100) ncol
        ic=ic+1
        icc=ic
        do while (isdigit(read_format(ic:ic)) .eq. 1)
          ic=ic+1
        end do
        read (read_format(icc:ic-1),*,err=100,end=100) ndig
        nr=0
        call read_amber_bonds(1,inpt,nneig,nneigh,ineig,ianslt,
     -    read_format,lread_format,ndig,nats,nats_full,isplit_of_orig,
     -    map,nr,liner,inperr,ifail,iout,maxng)
        if (liner(1:28) .eq. '%FLAG BONDS_WITHOUT_HYDROGEN') then
          read (inpt,1000,end=613)
        else
          call find_ambertyp(inpt,'%FLAG BONDS_WITHOUT_HYDROGEN',28,
     -      read_format,lread_format,iout)
        end if
        call read_amber_bonds(2,inpt,nneig,nneigh,ineig,ianslt,
     -    read_format,lread_format,ndig,nats,nats_full,isplit_of_orig,
     -    map,nr,liner,inperr,ifail,iout,maxng)
        natbond=nr
        write (iout,*) 'Number of bonds read:',natbond
        ierrtop=0
613     if (ierrtop .gt. 0) then
          write (iout,*) '***** ERROR: runout of data in the top file'
          inperr=inperr+1
        end if
      else
        write (iout,*) '***** PROGRAM ERROR: invalid bond syntax code:',
     -    ifiletyp
        inperr=inperr+1
      end if
      return
100   write (iout,2001) nbr
      inperr=inperr+1
      return
1000  format(a)
1001  format(8i10)
2000  format(' ***** ERROR: number of atoms in the structure (',i6,
     -  ') and ',/,' number of atoms in the PSF file (',i6,') differ')
2001  format(' ***** ERROR: bond list file ended prematurely or ',
     -  'invalid data was read',/,5x,'Reading bond #',i6)
2007  format(' Reading ',i6,' bonds')
      end
      subroutine read_amber_bonds(ih,inp_top,nneig,nhneig,ineig,iatnum,
     -  read_format,lread_format,ndig,n,n_full,isplit_of_orig,map,nr,
     -  liner,ierr,ifail,iout,maxng)
      dimension nneig(n),nhneig(n),ineig(maxng,n),iatnum(n),
     -  isplit_of_orig(n_full)
      character*25 read_format
      character*80 liner
      dimension i20(20)
c     write (iout,*) *,'READ_AMBER_BONDS ih=',ih,' n,n_full=',n,n_full
      i12=1
      i1=0
      call blankout(liner,1,80)
      do while (liner(1:5) .ne. '%FLAG')
        call blankout(liner,1,80)
        read (inp_top,1000,end=613) liner
        if (liner(1:5) .ne. '%FLAG') then
          call lastchar(liner,lc,80)
          nc=lc/ndig
          read (liner,read_format(1:lread_format),end=613)
     -      (i20(i),i=1,nc)
          do i=1,nc
            if (i12 .eq. 1) then
              i1=i20(i)/3+1
              i12=2
            else if (i12 .eq. 2) then
              i2=i20(i)/3+1
              call checklim(ifail,iout,inperr,1,n_full,i1,1,
     -          'atom index',10)
              call checklim(ifail,iout,inperr,1,n_full,i2,1,
     -          'atom index',10)
              if (map .eq. 1) then
                i1=isplit_of_orig(i1)
                i2=isplit_of_orig(i2)
              end if
              if (max0(i1,i2) .le. n) then
                nneig(i1)=nneig(i1)+1
                nneig(i2)=nneig(i2)+1
                ineig(nneig(i1),i1)=i2
                ineig(nneig(i2),i2)=i1
                if (iatnum(i1) .eq. 1) nhneig(i2)=nhneig(i2)+1
                if (iatnum(i2) .eq. 1) nhneig(i1)=nhneig(i1)+1
                if (ih .eq. 1) then
                  if (iatnum(i1) .ne. 1 .and. iatnum(i2) .ne. 1) then
                    write (iout,2000) i1,i2,' not'
                    ierr=1
                  end if
                else
                  if (iatnum(i1) .eq. 1 .or. iatnum(i2) .eq. 1) then
                    write (iout,2000) i1,i2,' '
                    ierr=1
                  end if
                end if
              end if
              i12=3
            else if (i12 .eq. 3) then
              nr=nr+1
              if (i1 .gt. n_full .or. i2 .gt. n_full) then
                write (iout,2001) i1,i2,n_full
                ierr=1
              end if
              i12=1
            end if
          end do
c         write (iout,8767) (i,itemp1(i),itemp2(i),i=nr0+1,nr)
c8767     format(i5,' IT1,2=',2i6)
        end if
      end do
      if (i12 .ne. 1) then
        write (iout,2002)
        ierr=ierr+1
      end if
      return
613   ierr=1
      return
1000  format(a)
2000  format(' ***** (PROGRAM?) ERROR: bond ',i7,' - ',i7,' does',a,
     -  ' involve a hydrogen')
2001  format(' ***** ERROR: atom index ',i7,' or ',i6,' exceeds the ',
     -  'number of atoms (',i7,')')
2002  format(' ***** PROGRAM ERROR: bond list length is not a multiple',
     -  ' of three')
      end
      subroutine find_n_psf(inpt,ierr,n,n_psf,label,llabel,iout)
c#    MMC routine 207/j lstmod: 02/03/20
      character*80 line
      character*(*) label
c     write (iout,*) 'FIND_N_PSF inpt=',inpt,' LABEL=',label(1:llabel)
      ierr=0
      n_psf=0
      nl=0
      do while (n_psf .eq. 0)
        call blankout(line,1,80)
        read (inpt,1010,end=602) line
        nl=nl+1
        ic=1
        call nextchar(line,ic,1,inpt,iout)
        ic1=ic
        call nextblank(line,ic,1)
        ic2=ic-1
        call nextchar(line,ic,1,inpt,iout)
        ic21=ic
        call nextblank(line,ic,1)
        ic22=ic-1
        if (ic22 .gt. ic21) then
          if (line(ic21:ic21+llabel-1) .eq. label(1:llabel))
     -      read(line(ic1:ic2),*,err=602) n_psf
        end if
      end do
602   if (n_psf .eq. 0) then
        write (iout,2001) label(1:llabel),nl
        ierr=1
      else if (n_psf .lt. n .and. label(1:llabel) .eq. '!NATOM') then
        write (iout,2000) n,n_psf
        ierr=1
      else
        write (iout,*) 'Number of ',label(2:llabel),
     -    ' found in the PSF file=',n_psf
      end if
      return
1010  format(a)
2000  format(' ***** ERROR: the number of atoms to read (',i8,') ',
     -  'exceeds the number of atoms in the PSF file (',i8,')')
2001  format(' ***** ERROR: no ',a,' line was found; number of lines ',
     -  'read=',i6)
      end
      subroutine find_ambertyp(inpt,flag,lflag,form,lform,iout)
c#    MMC routine 207/k lstmod: 02/03/20
      character*(*)flag,form
      character*80 liner
      rewind inpt
      liner(1:1)=' '
      do while (liner(1:lflag) .ne. flag(1:lflag))
        read(inpt,1010,end=100) liner
      end do
      call blankout(liner,1,80)
      read(inpt,1010,end=100) liner
      if (liner(1:7) .eq. '%FORMAT') then
        call lastchar(liner,lc,80)
        form=liner(8:lc)
        lform=lc-7
      end if
      return
100   write (iout,*) 'Format not found after flag ',flag(1:lflag)
1010  format(a)
      end
      subroutine eslvfield(c,nslv,efieldo)
c#    MMC routine 208 lstmod: 11/19/12
c*****Calculate global field potential energy for solvent molecule islv
      dimension c(3,nslv)
      common /fieldpot/ niparf,nrparf,niparm,nrparm,intf(10),intm(10),
     -  rf(10),rm(10)
      common /option/ iop(200),idebug(200)
      efieldo=0.0
      if (c(intf(1),intf(2)) .lt. rf(1) .and.
     -  c(intf(1),intf(2)) .gt. rf(2)) efieldo=1.e+32
      return
      end
      subroutine esltmolec(cst,mol,mol2,eng)
c#    MMC routine 209 lstmod: 04/10/97
c*****Calculates molecule-dependent energies between molecules mol and mol2
      dimension cst(3,#ST)
      real*8 eng
      common /fieldpot/ niparf,nrparf,niparm,nrparm,intf(10),intm(10),
     -  rf(10),rm(10)
      common /option/ iop(200),idebug(200)
      eng=0.d0
      return
      end
      subroutine eslt_constraint(c,eng)
c#    MMC routine 209/a lstmod: 12/13/24
c*****Calculates conctraint energies (iop(117) > 0
      dimension c(3,#ST)
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      real*8 eng
      eng=0.d0
      do i=1,nconstr_pair
        dev=0.0
        do k=1,3
          dev=dev+(c(k,iconstr_pair(1,i))-c(k,iconstr_pair(2,i)))**2
        end do
        dev=sqrt(dev)-d_target(i)
        if (tol_target(i) .eq. 0) then
          eng=eng+force_target(i)*dev**2
        else if (abs(dev) .gt. tol_target(i)) then
          eng=eng+force_target(i)*dev**2-eng_tol(i)
        end if
      end do
      return
      end
C@DD      function dd_ms_inter(r)
C@DDc#    MMC routine 209/a lstmod: 04/09/08
C@DDc*****Interpolate the pre-calculated Mehler-Solmayer DDD table
C@DD      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
C@DD     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
C@DD      rr=r/rdiv_ddd
C@DD      i=rr
C@DD      i1=i+1
C@DD      if (i1 .gt. ngrid_ddd) then
C@DD        dd_ms_inter=dd_ms(ngrid_ddd)
C@DD      else  if (i .lt. 1) then
C@DD        dd_ms_inter=dd_ms(1)
C@DD      else
C@DD        dd_ms_inter=dd_ms(i)*(float(i1)-rr)+dd_ms(i1)*(rr-float(i))
C@DD      end if
C@DB      write (6,1111) r,i,i1,ri,ri1,dd_ms(i),dd_ms(i1),dd_ms_inter
C@DB1111  format(' DD_MS r=',f6.2,' i,i1=',2i4,' ri,ri1=',2f7.2,
C@DB     -  ' ddi,ddi1,dd=',3f8.5)
C@DD      return
C@DD      end
      subroutine disini
c#    MMC routine 210 lstmod: 04/15/07
c*****Initializes the distribution function accummulators
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /dispar/ rfsslv,rfsslt,rssmin,rssmax,dmnslt,dmxslt,
     -  dmnslv,dmxslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /option/ iop(200),idebug(200)
      character*80 line
      common /inpline/ line,lineno,icol
      call initcutoff(iout,nwarn)
      if (iop(4) .gt. 0) then
c       Data for radial distribution function, binding eng QCDF
        irectx=32
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) rdmx,ri,rfsslv,empslv,egrslv
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1341) rdmx,ri,rfsslv, empslv,egrslv
c       Data solvent-solvent distr, solute  QCDF's
        irectx=33
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999)
     -    rssmin,rssmax,rfsslt,empslt,egrslt,ksltmn
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1342) rssmin,rssmax,rfsslt,empslt,egrslt,ksltmn
      end if
      if (ri .eq. 0.0) ri=0.05
      if (rfsslv .eq. 0.0) rfsslv=3.3
      if (rfsslt .eq. 0.0) rfsslt=5.0
      if (egrslv .eq. 0.0) egrslv=0.25
      if (rdmx .eq. 0.0 .or. rdmx .gt. cutslv) rdmx=amin1(cutslv,rinscr)
      if (egrslt .eq. 0.0) egrslt=0.5
      if (rssmax .eq. 0.0) rssmax=rdmx
      if (rssmin .eq. 0.0) rssmin=rfsslt
      if (rssmin .gt. rinscr) then
        if (MYRANK .eq. 0) write (iout,2000) rssmin
        nchng=nchng+1
        rssmin=0.0
      end if
      nssmin=rssmin/ri+1
      nssmax=rssmax/ri+1
      if (iop(4) .gt. 1) then
c       Limits for near-neighbours
        irectx=34
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) dmnslt,dmxslt,dmnslv,dmxslv
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1343) dmnslt,dmxslt,dmnslv,dmxslv
c       Pair-energy QCDF grid data
        irectx=35
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) emnslt,egpslt,emnslv,egpslv
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1344) emnslt,egpslt,emnslv,egpslv
        if (emnslt .ge. 0.0) then
          if (MYRANK .eq. 0) write (iout,2004) 'solute',emnslt
          nwarn=nwarn+1
        end if
        if (emnslv .ge. 0.0) then
          if (MYRANK .eq. 0) write (iout,2004) 'solvent',emnslv
          nwarn=nwarn+1
        end if
        if (dmxslv .eq. 0.0) dmxslv=rfsslv
        if (dmxslt .eq. 0.0) dmxslt=rfsslt
        if (egpslt .eq. 0.0) egpslt=0.5
        if (egpslv .eq. 0.0) egpslv=0.25
      end if
      nd=(rdmx/ri)+1
      if (nd .gt. 500) then
        if (MYRANK .eq. 0) write (iout,2005) ri*500,rdmx/500
        nchng=nchng+1
        nd=500
      end if
      rri=1.0/ri
c     Make sure that if r=n*ri then n(r)=n
      ri=ri-ri*1.e-5
c     thus if there is an interval (n1*d,n2*d) then nx=n1 is in and
c     nx=n2 is out. Note that all cutoff distances are rounded off
c     to be int(r/ri)*ri
      mndslt=dmnslt/ri+1
      mxdslt=dmxslt/ri+1
      mndslv=dmnslv/ri+1
      mxdslv=dmxslv/ri+1
      nfslww=(rfsslv/ri)+1
      nfsslt=(rfsslt/ri)+1
      if (iop(4) .gt. 0) then
c       Check first shell radii if they are small enough for proper accounting
        cedt=cedslt*sq3p2
        if (iop(17) .eq. 1) then
c         Take into account the rotation to calculate the maximum change in
c         slt-slv distance
          rleng2=0.0
          do ia=1,nstta
            r2=rlcslt(1,ia)**2+rlcslt(2,ia)**2+rlcslt(3,ia)**2
            if (r2 .gt. rleng2) rleng2=r2
          end do
          rleng=sqrt(rleng2)
c         Reduce nfsslt if PBC cell change can occur to molecs within the
c         first shell
          if (rfsslt+cedt+rleng .ge. rinscr) then
            rfsslt=rinscr-cedt-rleng
            if (MYRANK .eq. 0) write (iout,2001) 'solute',rfsslt
            nfsslt=(rfsslt/ri)+1
          end if
          cedt=cedt+rleng*rtxslt/2.0
        end if
        ngrdel=amax1(cedslv*sq3p2,cedt)/ri+2.0
        if (nd-ngrdel .lt. nfsslt) then
          nfsslt=nd-ngrdel
          rnd=nfsslt*ri
          if (MYRANK .eq. 0) write (iout,2001) 'solute',rnd
          nchng=nchng+1
        end if
        if (nd-ngrdel .lt. nfslww) then
          nfslww=nd-ngrdel
          rnd=nfslww*ri
          if (MYRANK .eq. 0) write (iout,2001) 'solvent',rnd
          nchng=nchng+1
        end if
        if (nfslww .le. 0 .or. nfsslt .le. 0) then
c         Stop if either first shell radius is reduced to zero or less.
          if (MYRANK .eq. 0) write (iout,2003)
          call datprt(2)
        end if
        if (iop(4) .gt. 0) then
          if (nssmin .ge. nssmax) then
            write (iout,2006) 'solute-solvent',rssmin,rssmax
            inperr=inperr+1
          end if
          if (mndslt .ge. mxdslt) then
            write (iout,2006) 'solute-solvent',dmnslt,dmxslt
            inperr=inperr+1
          end if
          if (mndslv .ge. mxdslt) then
            write (iout,2006) 'solvent-solvent',dmnslv,dmxslv
            inperr=inperr+1
          end if
        end if
      end if
c     nd        : no. of divisions in the radial distribution accumulators
c     nfslww    : solvent first solvation shell radius
c     nfsslt    : solute first solvation shell radius
c     nssmin    : distance from solute within which no solvent-solvent
c                 distribution is to be computed
c     nssmax    : distance from solute outside which no slv-slv
c     mndslt    : minimum radius for solute pair property distributions
c     mxdslt    : maximum radius for solute pair property distributions
c     mndslv    : minimum radius for solvent pair property distributions
c     mxdslv    : maximum radius for solvent pair property distributions
      return
999   call invalidform(iout,irectx)
1000  format(5f15.0,i5)
1341  format(' rectype 32  :',5f15.5,i5)
1342  format(' rectype 33  :',5f15.5,i5)
1343  format(' rectype 34  :',5f15.5,i5)
1344  format(' rectype 35  :',5f15.5,i5)
2000  format(' >>>>> OVERRIDE: Slv-slv g(r) region minimum is set to ',
     -  'zero from',f8.3)
2001  format(' >>>>> OVERRIDE: ',a,' first shell radius is',
     -  ' reduced to ',f6.2,' A')
2003  format(' ***** ERROR: Program stopped since first shell radii',
     -  ' are negative',/,32x,' increase max no of g(r) bins or reduce',
     -  ' stepsize or drop the DSTC key')
2004  format(' ----- WARNING: ',a,'-solvent energy grid minimum (',
     -  f6.1,') is not negative')
2005  format(' >>>>> OVERRIDE: range of radial distributions collected',
     -  ' is reduced to ',f6.2,' - increase the gridsize above ',f6.5,
     -  ' to avoid this')
2006  format(' ***** ERROR: Invalid ',a,' distance range:',2f10.4)
      end
      subroutine disper(iout)
c#    MMC routine 211 lstmod: 05/30/07
c*****Accumulates contributions from the last accepted configuration
c     to all the distribution functions.
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      dimension dipmom(3)
c     ncor,tesi always refer to the previously accepted orientation at this
c     stage of the calculation and thus have to be summed with weight nrpt
c     Increment dkcrslt,dnesslt
      kcnt=ncor(1)
      if (kcnt .gt. 30) kcnt=30
      if (kcnt .lt. 1) kcnt=1
      dkcrslt(kcnt)=dkcrslt(kcnt)+nrpt
      ncnt=(tesi(1)-empslt)/egrslt+50
      if (ncnt .lt. 1) ncnt=1
      if (ncnt .gt. 100) ncnt=100
      dnesslt(ncnt)=dnesslt(ncnt)+nrpt
c     Increment dkcrslv,dnesmww
      do i=2,nmolec
        if (nslvds(i) .ge. nssmin .and. nslvds(i) .lt. nssmax) then
          kcnt=ncor(i)
          if (kcnt .lt. 1) kcnt=1
          if (kcnt.gt.20) kcnt=20
          dkcrslv(kcnt)=dkcrslv(kcnt)+nrpt
          ncnt=(tesi(i)-empslv)/egrslv+50
          if (ncnt .lt. 1) ncnt=1
          if (ncnt.gt.100) ncnt =100
          dnesmww(ncnt)=dnesmww(ncnt)+nrpt
        end if
      end do
c     For distribution functions depending on pair-properties
c     only those contributions are summed that have been changed at this
c     step. Thus their weight should be nmc-max(lstmvd(i),lstmvd(isolv))
c     where lstmvd(i) is the nmc number for the last step where molec. i
c     was moved.
      if (isolv .gt. 1) then
        inc=1
        call update(isolv,1,nfsslt,nmc,ncor(1),ndummy,dnrslt,inc,ntpo,
     -    lstmvd,nd)
        if (iop(4) .eq. 2) then
          if (nis(1) .ge. mndslt .and. nis(1) .lt. mxdslt) then
            ind=(texo(1)-emnslt)/egpslt+1
            if (ind .lt. 1) ind=1
            if (ind .gt. 100) ind=100
            dnsltpe(ind)=dnsltpe(ind)+inc
          end if
        end if
        nos01=0
        if (nslvds(isolv) .ge. nssmin .and.
     -    nslvds(isolv) .lt. nssmax) then
          nos01=1
          dngwws=dngwws+nrpt
        end if
        do im=2,nmolec
          if (im .ne. isolv) then
            inc=nos01
            if (nslvds(im) .ge. nssmin .and. nslvds(im) .lt. nssmax)then
              inc=inc+1
              dngwws=dngwws+nrpt
            end if
            call update(isolv,im,nfslww,nmc,ncor(isolv),ncor(im),dnrww,
     -        inc,ntpo,lstmvd,nd)
            if (iop(4) .eq. 2) then
              if (inc .gt. 0) then
                if (ntpo .lt. mxdslv .and. ntpo .ge. mndslv) then
c                 Pair energy distribution
                  ind=(texo(im)-emnslv)/egpslv+1
                  if (ind .lt. 1) ind=1
                  if (ind .gt. 100) ind=100
                  dnslvpe(ind)=dnslvpe(ind)+inc
                  epijsum=epijsum+inc*texo(im)
                  epijct=epijct+inc
c                 Dipole correlation distribution
                  rr=sclprd(orient(1,1,isolv),orient(1,1,im))
                  ind=int(acoscheck(rr,iout,'DISPER')*rdtodg*0.99999)+1
                  dndipc(ind)=dndipc(ind)+inc
                end if
              end if
            end if
          end if
        end do
      else
c       Solute moved - special handling
        do im=2,nmolec
          if (nslvds(im) .ge. nssmin .and. nslvds(im) .lt. nssmax)
     -      dngwws=dngwws+nrpt
          inc=1
          if (ncor1ok .eq. 1) call update(1,im,nfsslt,nmc,ncor(1),ndumm,
     -      dnrslt,inc,ntpo,lstmvd,nd)
          if (iop(4) .eq. 2) then
            if (nslvds(im) .ge. mndslt .and. nslvds(im) .lt. mxdslt)then
              ind=(texo(im)-emnslt)/egpslt+1
              if (ind .lt. 1) ind=1
              if (ind .gt. 100) ind=100
              dnsltpe(ind)=dnsltpe(ind)+inc
            end if
          end if
        end do
      end if
      if (isolv .gt. 1 .and. iop(111) .gt. 0) then
c       Solvent dipole distribution contribution
        call dipolemoment(cslvo,nslv,qslvdip,dipmomabs,dipmom,1)
        do k=1,3
          proj=sclprd(exyzabc(1,k),dipmom)
          ind=int(acoscheck(proj,iout,'DISPRD')*rdtodg*0.99999)+1
          dndipmom(k,ind)=dndipmom(k,ind)+(nmc-lstmvd(isolv))
        end do
      end if
      return
      end
      subroutine update(i1,i2,nfs,nmc,nc1,nc2,dnr,inc,ntpo,lstmvd,nd)
c#    MMC routine 212 lstmod: 01/19/01
c*****Modify the coordination numbers nc1,nc2 for molecules i1 and i2,
c     obtain the old distance between i1 and i2 (ntpo) and
c     increment the g(r) accumulator (dnr).
      real*8 dnr
      dimension dnr(nd),lstmvd(#MO)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /option/ iop(200),idebug(200)
      ntpo=niso(i2)
c     if (ntpo .gt. nd) return
      ntpn=nis(i2)
c     Update ncor
      if (ntpo .ge. nfs) go to 323
      if (ntpn .lt. nfs) go to 321
c     i2-th molec moved away from the i1-th
      nc2=nc2-1
      nc1=nc1-1
323   if (ntpn .ge. nfs) go to 321
c     i2-th molecule moved to the i1-th
      nc2=nc2+1
      nc1=nc1+1
321   inc=inc*(nmc-max0(lstmvd(i2),lstmvd(i1)))
c     g(r)
      if (ntpo .le. nd) dnr(ntpo)=dnr(ntpo)+inc
      return
      end
      subroutine wrapup(nmc,nmolec,c,orient,crm,nslt,nslv,iout)
c#    MMC routine 213 lstmod: 04/05/07
c*****Accumulate the pair properties from the last strech of steps
      dimension c(3,#NA),orient(3,3,#MO),crm(3,#MO)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      dimension z(3),dipmom(3)
      do im=1,nmolec
        if (im .gt. 1 .and. iop(111) .gt. 0) then
c         Solvent dipole distribution contribution
          call zeroit(dipmom,3)
          ii00=nslt+(im-2)*nslv+1
          call dipolemoment(c(1,ii00),nslv,qslvdip,dipmomabs,dipmom,1)
          do k=1,3
            proj=sclprd(exyzabc(1,k),dipmom)
            ind=int(acoscheck(proj,iout,'WRAPD')*rdtodg*0.99999)
            dndipmom(k,ind)=dndipmom(k,ind)+(nmc-lstmvd(im))
          end do
        end if
        if (iop(4) .ge. 2) then
          do jm=1,nmolec
            nis(jm)=0
          end do
          call engold(iop(21),iop(119),im,texslt,vrcslt,frcslt,
     -      trtslt,trvslt,c,crm)
        end if
        do i=1,nmolec
          if (i .ne. im) then
            call arrdiff(z,crm(1,i),crm(1,im),3)
            if (iop(2) .eq. 1 .and. min0(i,im) .eq. 1) z(1)=0.0
            call pbcnd(z(1),z(2),z(3),iop(5),iopt,dist2)
            ntpo=int(rri*sqrt(dist2))+1
            inc=(nmc-max0(lstmvd(i),lstmvd(im)))
            if (inc .ne. 0 .and. ntpo .le. nd) then
c             G(r)
              if (im .eq. 1) then
                dnrslt(ntpo)=dnrslt(ntpo)+inc
                if (ntpo .ge. mndslt .and. ntpo .lt. mxdslt .and.
     -              iop(4) .eq. 2) then
                  ind=(texo(i)-emnslt)/egpslt+1
                  if (ind .lt. 1) ind=1
                  if (ind .gt. 100) ind=100
                  dnsltpe(ind)=dnsltpe(ind)+inc
                end if
              else
                in=0
                if (nslvds(i) .ge. nssmin .and. nslvds(i) .lt. nssmax)
     -            in=in+1
                if (nslvds(im) .ge. nssmin .and. nslvds(im) .lt. nssmax)
     -            in=in+1
                if (in .gt. 0) then
                  inc=inc*in
                  dnrww(ntpo)=dnrww(ntpo)+inc
                  if (ntpo .lt. mxdslv .and. ntpo .ge. mndslv  .and.
     -              iop(4) .eq. 2) then
c                   Pair energy distribution
                    ind=(texo(i)-emnslv)/egpslv+1
                    if (ind .lt. 1) ind=1
                    if (ind .gt. 100) ind=100
                    dnslvpe(ind)=dnslvpe(ind)+inc
c                   Dipole correlation distribution
                    rr=sclprd(orient(1,1,im),orient(1,1,i))
                    ind=int(acoscheck(rr,iout,'DISPER')*rdtodg*0.99999)
     -                +1
                    dndipc(ind)=dndipc(ind)+inc
                  end if
                end if
              end if
            end if
          end if
        end do
        lstmvd(im)=nmc
      end do
      return
      end
C@SPLIT2
      subroutine disfin(nt,c,orient,crm,orientsltm,crm0)
c#    MMC routine 214 lstmod: 04/01/22
c*****Print and save the distribution functions, averages.
      dimension c(3,#NA),orient(3,3,#MO),crm(3,#MO),
     -  orientsltm(3,3,#MM),crm0(3,#MO)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 ew0nb,teslt1,teslt1n,uwnb,uwnbn,uwnbmin,uwnbmax,
     -  etsincr
      common /nonboltz/ ew0nb,teslt1,teslt1n,
     -  uwnb,uwnbn,uwnbmin,uwnbmax,etsincr,tornbfac,repnbfac,slttmp,
     -  sltsltfac,signincfac,tsexp,tsfac
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      real*8 ediffsm,ediffsm2,expediffsm
      common /virtvolcha/ ediffsm,ediffsm2,expediffsm,ediffmn,ediffmx,
     -  volchaperc,volchafac(3),volchadiff(3),delvvol,delvarea
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 ue0ind,ue1ind,ue0ttnb,ue1ttnb,ue0innb,ue1innb,
     -  ue0t14,ue1t14,ue0tor,ue1tor
      common /frind5/ ue0ind(3),ue1ind(3),ue0ttnb(3),ue1ttnb(3),
     -  ue0innb(3),ue1innb(3),ue0t14(3),ue1t14(3),ue0tor(3),ue1tor(3)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      common /cavprb/ ndistr(#MO),ninstr(#MO),nocavf(#MO),
     -  ndela,nran,ndlast,nmdlst,niddst,namin,namax
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
CJJ   variables
      real*8 setpoint,gain_n,gain_den,integraltime,oldpv,controlerror,
     -  dbetadt,dpvdt
      common /control/ setpoint,gain_n,gain_den,integraltime,oldpv,
     -  controlerror,dbetadt,dpvdt
      real*8 rnsumprev,uavcorprev,delndelbsum
      common /tuneb/ rnsumprev(2),uavcorprev,delndelbsum,nitconv,
     -  nunphys,nmctunskip,nmctunave,nmclastch,ntune,nmccorprev,
     -  ndelndelbsum,inorout,targetden,targetn,tolden,toln,delndelb0,
     -  rnaviprev,baprev,chabmax,pv
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /torauc/ nmctorauc,ntorsaved,ntaucprint,nauc(#AU),
     -  tauc_timestep,tauc_min,torsave(#AU,#TR),auctor(#AU,#TR)
      common /expfit_tau/ ntaumax,ntaufit,aucsaved(#AU),ixt(#AU)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /dispar/ rfsslv,rfsslt,rssmin,rssmax,dmnslt,dmxslt,
     -  dmnslv,dmxslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /constraint/ nconstr_pair,isplitdone,iconstr_pair(2,100),
     -  d_target(100),force_target(100),tol_target(100),eng_tol(100)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      character*80 ident
      common /title/ nlident,ident(2)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      common /dijdiff/ n12diff(20),n13diff(20)
      real*8 fsmslt,fsmslv,tsmslt,tsmslv,wpsmvi,dis,displs,racors,
     -  racors2
      common /quantm/ fsmslt,fsmslv,tsmslt(3),tsmslv(3),wpsmvi,nsslt
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
c     The energy common block is used partially for work area
      real*8 tesiis
      common /slvenergy/ tesiis,perrat(#MO),accrat(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),
     -  cgx(#UV),cgy(#UV),cgz(#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),
     -  cy1(#UV),cy2(#UV),cy3(#UV),
     -  cx1(#UV),cx2(#UV),cx3(#UV),cv1(#UV),cv2(#UV),
     -  cv3(#UV),abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),rrii(#UV),
     -  rrimav(#UV),r2imav(#UV),rrimmin(#UV),rrimmax(#UV),
     -  cvar(#UV)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /howfar/ dtot(#MI,2),decay(#MI,2),nhowfar,nhowfarsamp
      common /ecell/ cic(3,27),ncell
      common /cellshift/ ncross(27)
      character*15 selectname
      character*23 movname
      character*36 exbiname
      common /stratnames/ selectname(4),movname(7),exbiname(5)
      character*40 itcplp
      common /cplnames/ itcplp
      character*1 lxyz
      common /names/ lxyz(3)
      character*30 looptypname
      common /loopnames/ looptypname(9)
C@DM      include "mpif.h"
      real*8 racsltors,racsltors2,stinout,dtd
      dimension gww(500),gslt(500),rkslt(500),rkslv(500),gesslv(100),
     -  gesslt(100),esslv(100),esslt(100),gr(500),gdvslv(500),
     -  gdvslt(500),gcrslv(20),gcrslt(30),gpeslt(100),gpeslv(100),
     -  gdipc(180),gor(#OR),por(#OR),pnor(#OR),ort(3,3),ntkacc(3),tm(3),
     -  ntktry(3),ptkacc(3),edgexyzread(3),rowd(10),robd(10),sss(3),
     -  pnocav(#MO),cm(3),vastepxyz(3),rtx(3),itd(#TD),dtd(#TD),rrr(3),
     -  racsltors(3),racsltors2(3),racsltmin(3),racsltmax(3),tmslt(3),
     -  cmslt(3),xtv0(3),xtv1(3),xtt0(3),xtt1(3),stinout(2),keycol(2),
     -  ixrep3slt(3)
C@FR      dimension rinslt(3),rinslv(3)
      character*1 loopmark
      character*4 looptyplab(10)
      character*8 stunelab(2),torsnames(8)
      character*9 loopstrat(4)
      character*10 peakcent(3)
      character*14 label
      character*63 itfdif,itsdif
      character*80 filename1
      real*8 uavc,sinsumit,cossumit,beav,dstcplk,dnbslvs,
     -  dnpslts,dnpslvs,dtsum,uavcors,ussucs,
     -  um14im,uum14im,uintranbim,uuintranbim,uinterim,uuinterim,
     -  cv,dh,dh2,rmsav,rms2av,dnt,d9,uavg,usavg,uscavg,usttavg,
     -  usinavg,uintranbimavg,uinterimavg
      data loopstrat /'Forward  ','Backward ','Guessed  ','Both ways'/
      data peakcent /'centered  ','off-center','undefined '/
      data itfdif /
     -'First  energy difference distribution: * Number distribution: O'/
      data itsdif /
     -'Second energy difference distribution: * Number distribution: O'/
      data stunelab /'        ',' (tuned)'/
      data r9 /9999.9/ d9 /999999999.d0/
      data uavcors /0.d0/,irmax /0/,iarmax /0/,iar2max /0/
      call testconst(0,1,2,0.0,1.0,2.0,iout,nfail,1)
      if (nfail .gt. 0) call datprt(2)
      nmolecx=nmolec
      nat0=natoms
      if (iop(41) .gt. 0) nat0=nstta
      nrep3slt=0
      uavcor=(ucsmmv+ucsmid+ucsmvv)
      call readcrd(cgs,icord,nmolecx,nmol3x,numsolvx,nat0,nstta,nstfa,
     -  nslv,cplparx,edgexyzread,icplp,1,1,0,filenames(2),namlens(2),
     -  1,iout,nwwarn,inperr)
      if (iop(43) .gt. 0 .and. nmolec .gt. 1) then
C@ND        do i=1,nsttg
C@ND          estgr(i)=estgrs(i)/uavcor
C@ND        end do
C@DM        call zeroit(estgr,nsttg)
C@DM        do igx=iflsltg(1,MYRANK+1),iflsltg(2,MYRANK+1)
C@DM          ig=mixupslt(igx)
C@DM          estgr(ig)=estgrs(ig)/uavcor
C@DM        end do
C@DM        call MPI_Allreduce(estgr,cv1,nsttg,
C@DM     -    MPI_REAL,MPI_SUM,MPI_COMM_WORLD,iostat)
C@DM        call trnsfr(estgr,cv1,nsttg)
      end if
C@DM      if (MYRANK .gt. 0) go to 9999
      if (nt .lt. 1) go to 9999
      if (iop(41) .gt. 0) nt=nt+nidmc
      if (iop(71) .gt. 0) nt=nt+nvchmc
      dnt=nt
      do im=1,#MO
        indexx(im)=im
        ivtm(im)=0
      end do
      if (iop(71) .gt. 0 .and. ucsmvv .gt. 0.d0) then
c       (TPN) ensemble results
        write (iout,2000) 'VOLUME'
        call avstdev_r(vsum,vvsum,ucsmvv,vav,sdv)
        if (vav .eq. 0.0) vav=1.0d0
        volav=vav
        call avstdev_r(hsum,hhsum,ucsmvv,h_av,sd_h)
        call avstdev_r(exsum,exsum_2,ucsmvv,exav,sd_x)
        call avstdev_r(eysum,eysum_2,ucsmvv,eyav,sd_y)
        call avstdev_r(ezsum,ezsum_2,ucsmvv,ezav,sd_z)
        den=(wmslt+(nmolec-1)*wmslv)/volav*wmmltona3
        b_t=(sdv**2)/volav/(boltz*temp)
        b_t=b_t*avogad*0.02418*1.e-27
        write (iout,1110) 'X',exav,sd_x,'Y',eyav,sd_y,'Z',ezav,sd_z
        write (iout,1103) volav,sdv,den,b_t
        if (iop(71) .eq. 2) then
          ayz=volav/exav
          write (iout,1083) exav,ayz
        end if
      else
        volav=vol
      end if
      write (iout,2000) 'ENERGY'
      de=emax-emin
      if (de .gt. r9) de=r9
      call avgsdlim(usum,uusum,uavcor,d9,r9,uavg,sdev)
      if (sdev .ge. r9) cv=r9
      if (iop(41) .eq. 0 .and. nmolec .gt. 1) then
        if (iop(71) .eq. 0) then
          if (sdev .lt. r9)
     -      cv=sdev**2*1000.0/float(nmolec)/(boltz*temp**2)
          if (iop(11) .ne. 3 .and. iop(11) .ne. 4)
     -      write (iout,1041) uavg,sdev,de
          if ((nmolec .gt. 1 .or. iop(57) .gt. 0) .and.
     -        iop(11) .ne. 3 .and. iop(11) .ne. 4 .and.
     -        iop(114) .eq. 0) write (iout,1006) cv
        else
          if (sd_h .gt. rlsqmx/100.0) then
            sd_h=r9
            c_p=r9
          else
            c_p=(sd_h**2)*1000.0/float(nmolec)/(boltz*temp**2)
          end if
          a_p=sdv*sd_h/volav/(boltz*temp**2)
          write (iout,1009) uavg,h_av,sd_h,c_p,a_p
        end if
      else
        if (iop(11) .ne. 3 .and. iop(11) .ne. 4)
     -    write (iout,1041) uavg,sdev,de
      end if
      uavc=uavcor/dnt
      write (iout,1095) uavc
      if (iop(23) .ne. 3) write (iout,1189) emaxchange
      if (nmolec .gt. 1) then
        call avgsdlim(uslt,uuslt,uavcor,d9,r9,usavg,sdus)
        write (iout,1056) usavg,sdus
        if (iop(7) .eq. 1) then
          ussucs=estsua/uavcor
          call avgsdlim(estsca,estsaa,uavcor,d9,r9,uscavg,sdusc)
          corr=0.0
          if (sdus*sdusc .gt. 0.0 .and.
     -        sdusc .ne. r9 .and. sdus .ne. r9)
     -      corr=(ussucs-usavg*uscavg)/(sdus*sdusc)
          usscw=0.0
          if (eoutxs .ne. 0.0) usscw=einoxs/eoutxs
          if (usscw .ge. r9) usscw=r9
          write (iout,1072) uscavg,sdusc,corr,usscw
        end if
        usind12=tscum(1)/uavcor
        usind6=tscum(2)/uavcor
        usind1=tscum(3)/uavcor
        write (iout,1076) usind12,usind6,usind1
      end if
      if (iop(57)+iop(58) .gt. 0 .or. iop(18) .eq. 4) then
        call avgsdlim(uttnb,uuttnb,uavcor,d9,r9,usttavg,sdg)
        write (iout,1084) 'inter',usttavg,sdg
        call avgsdlim(uinnb,uuinnb,uavcor,d9,r9,usinavg,sdg)
        usltin=usttavg+usinavg
        write (iout,1084) 'intra',usinavg,sdg
        if (nsttm .gt. 1) then
          noclone=1
          do im=molstf,nsttm
            newclonstart=0
            if (im .lt. nsttm) then
c             Check if new clone type is starting
              if (icorig(ifirstm(im)) .gt. 0 .and.
     -            icorig(ifirstm(im+1)) .lt. 0) newclonstart=1
            end if
            if (newclonstart .eq. 1 .or. im .eq. molstf) then
              um14im=0.d0
              uum14im=0.d0
              uintranbim=0.d0
              uuintranbim=0.d0
              uinterim=0.d0
              uuinterim=0.d0
              uavcors=0.d0
              if (newclonstart .eq. 1) noclone=0
              nclones=0
            end if
            if (noclone .eq. 0) then
              um14im=um14im+um14(im)
              uum14im=uum14im+uum14(im)
              uintranbim=uintranbim+uintranb(im)
              uuintranbim=uuintranbim+uuintranb(im)
              uinterim=uinterim+uinter(im)
              uuinterim=uuinterim+uuinter(im)
              uavcors=uavcors+uavcor
              nclones=nclones+1
            else
              call avstdev_r(um14(im),uum14(im),uavcor,um14imavg,sd14)
              call avgsdlim(uintranb(im),uuintranb(im),uavcor,d9,r9,
     -          uintranbimavg,sduintra)
              call avgsdlim(uinter(im),uuinter(im),uavcor,d9,r9,
     -          uinterimavg,sduinter)
              write (iout,1096) im,um14imavg,sd14,uintranbimavg,
     -          sduintra,uinterimavg,sduinter
            end if
            newclonend=0
            if (im .lt. nsttm) then
              if (icorig(ifirstm(im)) .lt. 0 .and.
     -            icorig(ifirstm(im+1)) .gt. 0) newclonend=1
            else if (noclone .eq. 0) then
              newclonend=1
            end if
            if (newclonend .eq. 1) then
              call avstdev_r(um14im,uum14im,uavcors,um14imav,sd14)
              call avgsdlim(uintranbim,uuintranbim,uavcors,d9,r9,
     -          uintranbimavg,sduintra)
              call avgsdlim(uinterim,uuinterim,uavcors,d9,r9,
     -          uinterimavg,sduinter)
              write (iout,1105) nclones,im-nclones+1,im,um14imav,sd14,
     -          uintranbimavg,sduintra,uinterimavg,sduinter
              noclone=1
            end if
          end do
        end if
      else
        usltin=ettnbo+einnbo+es14o
        usttavg=0.0
        usinavg=0.0
      end if
      if (iop(92) .gt. 0) then
        call avstdev_n(rphssum,rrphssum,nt,rphss,sdrphs)
        call avstdev_n(ephssum,eephssum,nt,ephss,sdephs)
        call avstdev_n(sumnphs,sumnnphs,nt,avnout,sdnout)
        fphss=fphssum/nt
        write (iout,1146) rphss,sdrphs,avnout,sdnout,ephss,sdephs,fphss
        if (rnphsout .gt. 0.d0) then
          usout=usphsout/rnphsout
          ussout=ussphsout/rnphsout
          write (iout,1153)  usout,ussout
        end if
      end if
      if (iop(117) .gt. 0) then
c       Print constraint energies
        ectot=0.0
        do i=1,nconstr_pair
          eng=0.0
          dist=0.0
          do k=1,3
            dist=dist+(c(k,iconstr_pair(1,i))-c(k,iconstr_pair(2,i)))**2
          end do
          dist=sqrt(dist)
          dev=abs(dist-d_target(i))
          if (tol_target(i) .eq. 0) then
            eng=eng+force_target(i)*dev**2
          else if (abs(dev) .gt. tol_target(i)) then
            eng=force_target(i)*dev**2-eng_tol(i)
          end if
          write (iout,1190) (iconstr_pair(k,i),
     -     (labslt(kk,iconstr_pair(k,i)),kk=1,2),k=1,2),d_target(i),
     -     dist,eng
           ectot=ectot+eng
        end do
        write (iout,1191) econstro
        if (econstro*ectot .gt. 0.0) then
          ecerr=econstro-ectot
          if (abs(ecerr)/(econstro+ectot) .gt. 0.001) then
            write (iout,1204) econstro,ectot
            inperr=inperr+1
          end if
        end if
      end if
      if (ntang .gt. 0) then
        call avstdev_r(uslt14,uuslt14,uavcor,us14,sd14)
        call avstdev_r(uslttor,uuslttor,uavcor,usto,sdt)
        usltin=usltin+us14+usto
        write (iout,1086) us14,sd14,usto,sdt
        igrid=360.0/#TD.0
        if (#TD .gt. 1) write (iout,1141) igrid
        if (iop(58) .gt. 0 .and. iop(69) .eq. 0 .or. iop(1) .lt. 2) then
          idivfac=1
          if (nmc/#TD .gt. 1000000) idivfac=10
          do it=1,ntang
            contrib=circadd(ta0(it),dihang(it),-1.0)
            dtsum=(uavcor-dlastrot(it))
            dh0=(tangav(it)+dtsum*contrib)/uavcor
            dh=dble(rdtodg)*(tangav(it)+dtsum*contrib)
            dh2=dble(rdtodg)**2*(tang2av(it)+dtsum*contrib**2)
            call avstdev_r(dh,dh2,uavcor,dhavg,dhsd)
            sinsumit=(sinsum(it)+dtsum*sin(dihang(it)))/uavcor
            cossumit=(cossum(it)+dtsum*cos(dihang(it)))/uavcor
            sqsum=dsqrt(sinsumit**2+cossumit**2)
            cvar(it)=1.0-sqsum
            sinsumit=sinsumit/sqsum
            cossumit=cossumit/sqsum
            if (dabs(dabs(sinsumit)-0.5d0) .lt.
     -          dabs(dabs(cossumit)-0.5d0)) then
              cavg=dasin(sinsumit)*rdtodg
              if (cossumit .lt. 0.d0) then
                if (sinsumit .lt. 0.d0) then
                  cavg=-180.d0-cavg
                 else
                  cavg=180.d0-cavg
                end if
              end if
            else
              cavg=dacos(cossumit)*rdtodg
              if (sinsumit .lt. 0.d0) cavg=-cavg
            end if
            loopmark=' '
            if (looptyp(it) .ne. 0) loopmark='L'
            write (iout,1087) it,(igrslt(iquata(it,ii)),
     -        labslt(1,iquata(it,ii)),iquata(it,ii),
     -        labslt(2,iquata(it,ii)),ii=2,3),loopmark,rdtodg*
     -        circadd(ta0(it),dh0,+1.0),dhsd,cavg,cvar(it)
            if (#TD .gt. 1) then
              call trnsfi(itd,itangd(1,it),#TD)
              call trnsfrd(dtd,dtangd(1,it),#TD)
              ig=#TD.0*(dihang(it)+pi)/pi2+1
              if (ig .lt. 1) ig=1
              if (ig .gt. #TD) ig=#TD
              itd(ig)=itd(ig)+(nmc-lastrot(it))/nsltfreq
              dtd(ig)=(dtd(ig)+(uavcor-dlastrot(it)))
              call analtdist(itd,nzg,itdmin,itdmax,itdsum,
     -          ioffcent,1,#TD)
              write (iout,1137) it,float(itdmin)/float(itdsum),
     -         float(itdmax)/float(itdsum),nzg,peakcent(ioffcent+1),
     -         'Sampling',(float(itd(ig))/float(itdsum),ig=1,#TD)
              if (iop(96) .gt. 0)
     -          write (iout,1149) it,(dtd(ig),ig=1,#TD)
            end if
          end do
        end if
        if (iop(58) .gt. 0 .and. iop(69) .gt. 0 .and. #TD .gt. 1) then
c         Obtain the clone-averaged distributions
          write (iout,*)
c         Count torsions
          ntlim=0
          do it=1,ntang
            call origtor(it,itorig,1,itn)
            if (itn .gt. ntlim) ntlim=itn
          end do
          do ito=1,ntlim
c           Collect data for the original ito-th torsion
            call zeroiti(itd,0,#TD)
            ntorg=0
            do it=1,ntang
              call origtor(it,itorig,1,itn)
              if (itn .eq. ito) then
                ntorg=ntorg+1
                do ig=1,#TD
                  itd(ig)=itd(ig)+itangd(ig,it)
                end do
                ig=#TD.0*(dihang(it)+pi)/pi2+1
                if (ig .lt. 1) ig=1
                if (ig .gt. #TD) ig=#TD
                itd(ig)=itd(ig)+(nmc-lastrot(it))/nsltfreq
              end if
            end do
            call analtdist(itd,nzg,itdmin,itdmax,itdsum,
     -        ioffcent,ntorg,#TD)
            if (itdsum .gt. 0) write (iout,1137) ito,
     -        float(itdmin)/float(itdsum),float(itdmax)/float(itdsum),
     -        nzg,peakcent(ioffcent+1),'Clone-averaged sampling',
     -        (float(itd(ig))/float(itdsum),ig=1,#TD)
          end do
        end if
      end if
      if (iop(67) .gt. 0 .and. iop(67) .ne. 4) then
        call avstdev_r(usltf,uusltf,uavcor,usav,sdg)
        call avstdev_r(uslvf,uuslvf,uavcor,us1,sdg1)
        write (iout,1093) usav,sdg,us1,sdg1
        usltin=usltin+usav+us1
      end if
      if (iop(108) .gt. 0) then
        call avstdev_r(usltms,uusltms,uavcor,usav,sdg)
        write (iout,1094) usav,sdg
        usltin=usltin+usav
      end if
      if (iop(92) .eq. 0 .and. iop(21) .ne. 3 .and.iop(119) .eq. 0) then
C@FR        virsumx=vircsm(1)/uavcor
C@FR        virsumy=vircsm(2)/uavcor
C@FR        virsumz=vircsm(3)/uavcor
C@FR        vircsum=virsumx+virsumy+virsumz
C@FR        vsltsumx=vsltsm(1)/float(nmvd(1)+1)/uavcor/dnt
C@FR        vsltsumy=vsltsm(2)/float(nmvd(1)+1)/uavcor/dnt
C@FR        vsltsumz=vsltsm(3)/float(nmvd(1)+1)/uavcor/dnt
C@FR        vsltsum=vsltsumx+vsltsumy+vsltsumz
C@FR        p=(nmolec-vircsum/(3.0*boltz*temp))*
C@FR     -    (8.2054e-02*temp)/(avogad*vol*1.e-27)
C@FR        write (iout,1002) p,vircsum,vsltsum,virsumx,virsumy,virsumz,
C@FR     -    vsltsumx,vsltsumy,vsltsumz
      end if
      if (iop(96) .gt. 0) then
        write (iout,1148) uwnbmin,uwnbmax
      end if
      if (iop(80) .gt. 0) then
        write (iout,*)
        call denincalc(suminout,suminout2,nt,volin,volav,wmslv,
     -    wmmltona3,'Average',1,nmc,0,0,iout)
        rnavi=(suminout(2)-rnsumprev(2))/(nmc+nidmc-nmccorprev)
        if ((iop(76) .eq. 0 .or. iop(76) .eq. 3) .and.
     -       nmcmax .gt. 0) then
          stinout(1)=suminout(1)-rnsumprev(1)
          stinout(2)=suminout(2)-rnsumprev(2)
          if (nmclastch .lt. nmc)
     -      call denincalc(stinout,stinout,nmc+nidmc-nmccorprev,volin,
     -        volav,wmslv,wmmltona3,'Average',nmclastch+1,nmc,1,1,iout)
          rnsumprev(1)=suminout(1)
          rnsumprev(2)=suminout(2)
          nmccorprev=nmc+nidmc
          nmclastch=nmc
        end if
        if (iop(76) .gt. 0 .and. rnavi .gt. 0.0) then
          if (iop(76) .lt. 3)
     -      write (iout,1139)  wmslv*wmmltona3*rnavi/(volav-volin)
        end if
        stinout(1)=nmolinout(1)
        stinout(2)=nmolinout(2)
        call denincalc(stinout,stinout,1,volin,volav,wmslv,wmmltona3,
     -    'Current',nmc,nmc,1,1,iout)
      end if
      if (iop(41) .gt. 0) then
        if (iop(76) .eq. 1 .or. iop(76) .eq. 2) then
           if (nitconv .eq. 0) write (iout,1138) 'Current',ba
           if (nitconv .gt. 0) write (iout,1138) 'Tuned',ba,' ',nitconv
        else if (iop(76) .eq. 3) then
          write (iout,1173) ba,dbetadt
          write (iout,1174) bsum/(2*nmc)
        end if
        rnav=rnsum/uavcor
        if (ucsmid .eq. 0.0) ucsmid=1.0
        rnnav=rnnsum/uavcor-rnav**2
        unav=unsum/uavcor-uavg*rnav
        uslvav=uavg-usltin
c       Correct volume with the solute volume
        vslt=pmvslt*wmmltona3
        den=rnav/(vol-vslt)
        dengr=rnav/(vol-vsltgr)
        rmw=0.0
        dens=den*wmslv*wmmltona3
        densgr=dengr*wmslv*wmmltona3
        if (nmolec .gt. 1) then
          xxx1=(uavg-usavg-usttavg-usinavg)/rnav
          xxx2=usavg/rnav
          xxx3=usind1/rnav
          write (iout,1203) nmc,rnav,xxx1,xxx2,xxx3
        end if
c       Calculate fluctuation over the last stretch
        uavcordif=uavcor-uavcorprv
        if (uavcordif .gt. 0.d0) then
          rnavprv=(rnsum-rnsumprv)/uavcordif
          rnnavprv=(rnnsum-rnnsumprv)/uavcordif-rnavprv**2
          write (iout,1160) nmcprv,nmc,rnnavprv,rnsum,rnnsum,uavcordif
        end if
        nmcprv=nmc
        rnsumprv=rnsum
        rnnsumprv=rnnsum
        uavcorprv=uavcor
        if (namin .gt. 0)
     -    write (iout,1158) namin-1,namax-1,(ndistr(i),i=namin,namax)
        cv=0.0
        if (rnnav .gt. 0.00001)
     -    cv=1000.0*(sdev**2-unav**2/rnnav)/(rnav*boltz*temp**2)
        abeta=rnnav/rnav*
     -    ((vol-vslt)*(1.e-09)**3)/(0.00821*temp/avogad)
        abetagr=rnnav/rnav*
     -    ((vol-vsltgr)*(1.e-09)**3)/(0.00821*temp/avogad)
        alphmp=-(unav-uavg*rnnav/rnav)/(rnav*boltz*temp**2)
        fav=0.0
        rmu=(ba-alog(rnav))/beta
        write (iout,1044) den,dens,vslt,rmu
        write (iout,1078) dengr,densgr,vsltgr
        write (iout,1042) cv,abeta,abetagr,alphmp
        write (iout,1043) sdev**2,rnnav,unav
        if (iop(79) .eq. 2) write (iout,1025) 's',ncrossin,ncrossout
        if (iop(79) .eq. 3)
     -    write (iout,1025) ' attempts',ncrossin,ncrossout
        if (iop(24) .gt. 1) then
          write (iout,1049) (nocavf(i),i=namin,namax)
          write (iout,1050) (ninstr(i),i=namin,namax)
        end if
        if (nran .gt. 0 .and. (iop(41) .eq. 1 .or. iop(41) .eq. 2)) then
          do i=namin,namax
            pnocav(i)=0.0
            if (ninstr(i) .gt. 0)
     -        pnocav(i)=float(nocavf(i))/float(ninstr(i))
          end do
          write (iout,1048) (pnocav(i),i=namin,namax)
          prx=float(nran)/float(nitry)
          write (iout,1046) nran,prx
        else
          write (iout,1058)
        end if
        write (iout,1045) nitry,nidmc-nitry
        write (iout,1047) niaccp,ndaccp,ndlast
        if (iop(42) .gt. 0) then
c         Scan insertion/deletion log
          if (numrec(5) .ne. niaccp+ndaccp) write (iout,1136)
          rewind iindel
          lifeav=0
          llifav=0
          nprox=0
          if (iop(42) .eq. 2) then
            call zeroiti(l1,0,nstta)
            call zeroiti(l2,0,nstta)
          end if
          do i=1,numrec(5)
            if (iop(42) .eq. 1) then
              read (iindel,4600) indel,is,nmol,nmclog,cplxx,cm
              if (iop(24) .gt. 2) write (iout,1051) indel,is,
     -          nmol,nmclog,cplxx,cm
            else
              read (iindel,4600) indel,is,nmol,nmclog,cplxx,cm,ipx,rpx
              if (iop(24) .gt. 2) write (iout,1051) indel,is,
     -          nmol,nmclog,cplxx,cm,' ',ipx,rpx
              if (rpx .le. rpxidlim) then
                if (indel .eq. 1) l1(ipx)=l1(ipx)+1
                if (indel .eq. -1) l2(ipx)=l2(ipx)+1
                nprox=nprox+1
              end if
            end if
            is=is+1
            if (indel .eq. +1) then
              ivtm(is)=nmclog
            else
              lifeav=lifeav+(nmclog-ivtm(is))
              if (is .lt. nmolec) then
                llifav=llifav+(nmclog-ivtm(is))
c               Shift ivtm to reflect deletion of molec is
                is1=is+1
                do j=is1,#MO
                  indexx(j-1)=indexx(j)
                  ivtm(j-1)=ivtm(j)
                end do
              end if
            end if
          end do
          if (ndaccp .gt. 0) then
            avlife=float(lifeav)/float(ndaccp)
            write (iout,1052) avlife
            if (ndaccp-ndlast .gt. 0) then
              avllif=float(llifav)/float(ndaccp-ndlast)
              write (iout,1053) avllif
            end if
          end if
          norig=0
          beav=0.d0
          bemin=realmx
          bemax=-realmx
          do im=idsvfst,nmolec
            if (ivtm(im) .eq. 0) then
              norig=norig+1
            end if
          end do
          write (iout,1054) norig
          if (norig .gt.  0) then
            if (norig .gt. 10) then
              write (iout,*) 'First 10 undeleted molecules:'
            else
              write (iout,*) ' Undeleted molecules:'
            end if
            norig=0
            do im=idsvfst,nmolec
               if (ivtm(im) .eq. 0) then
                 norig=norig+1
                 if (norig .le. 10) write (iout,1077) im-1,(c(k,ic01+
     -             im*nslv),k=1,3),tesi(im),tsind(3,im)
                 beav=beav+tesi(im)
                 if (bemin .gt. tesi(im)) bemin=tesi(im)
                 if (bemax .lt. tesi(im)) bemax=tesi(im)
               end if
            end do
            beav=beav/norig
            write (iout,1060) beav,bemin,bemax
          end if
          write (iout,1059) numrec(5)
          if (iop(24) .gt. 1)
     -      write (iout,1055) (ivtm(im),im=idsvfst,nmolec)
          if (nprox .gt. 0) then
c           Print solute atoms with i/d sites in their vicinity
            do ia=1,nstta
              if (l1(ia)+l2(ia) .gt. 0)
     -          write (iout,1187) ia,(labslt(k,ia),k=1,2),l1(ia),l2(ia)
            end do
          end if
        end if
        if (iop(22) .gt. 0) then
c         Proximity i/d acceptance rate print
          nmerge=0
          do ia=1,nstta
            if (ianslt(ia) .eq. 1) then
              if (nneig(ia) .eq. 1) then
                in=ineig(1,ia)
                do k=1,4
                  idproxacc(k,in)=idproxacc(k,ia)
                  idproxacc(k,ia)=0
                end do
                nmerge=nmerge+1
                if (iop(24) .gt. 1)
     -            write (iout,1200) ia,labslt(2,ia),igrslt(ia),
     -              labslt(1,ia),in,labslt(2,in),igrslt(in),labslt(1,in)
              else
                write (iout,1202) ia,labslt(2,ia),igrslt(ia),
     -            labslt(1,ia),nneig(ia)
              end if
            end if
          end do
          if (nmerge .gt. 0) write (iout,1201) nmerge
          write (iout,1199)
          do ia=1,nstta
            acc_ins=0.0
            if (idproxacc(2,ia) .gt. 0)
     -        acc_ins=float(idproxacc(1,ia))/float(idproxacc(2,ia))
            acc_del=0.0
            if (idproxacc(4,ia) .gt. 0)
     -        acc_del=float(idproxacc(3,ia))/float(idproxacc(4,ia))
            if (acc_ins+acc_del .gt. 0.0)
     -        write (iout,1198) ia,labslt(2,ia),igrslt(ia),labslt(1,ia),
     -        acc_ins,acc_del,(idproxacc(k,ia),k=2,4,2)
          end do
        end if
      end if
      if (iop(43) .gt. 0 .and. nmolec .gt. 1) then
        if (nsttg .lt. 30 .or. iop(1) .lt. 2) then
          write (iout,1089) (i,estgr(i),i=1,nsttg)
          if (iop(57)+iop(58) .gt. 0) write (iout,1057)
        end if
      end if
      if (iop(106) .gt. 0) then
c       Virtual volume change results
        write (iout,1175) nvvchmc
        if (nvvchmc .gt. 0) then
          call avstdev_n(ediffsm,ediffsm2,nvvchmc,usav,sd)
          sexpediffsm=expediffsm
          expedifflog=alog(sexpediffsm/nvvchmc)
          write (iout,1176) usav,sd,expedifflog
          write (iout,1178) ediffmn,ediffmx
          if (iop(106) .eq. 1) then
            write (iout,1177) 'volume',delvvol
            write (iout,1179) 138.0*temp*expedifflog/delvvol
          end if
          if (iop(106) .gt. 1) write (iout,1177) 'area',delvarea
        end if
      end if
c     iop(53) > 1 can happen only if iop(30)=0
      if (iop(30) .gt. 3) then
c-------Free energy result output
        write (iout,2000) 'FREE-ENERGY'
        if (iop(30) .ne. 7) then
c         Coupling parameter does not change during the run
          if (iop(30) .eq. 5 .or. iop(35) .eq. 0) then
            write (iout,1028) ue0/dnt,
     -        (ue0ttnb(1)+ue0ttnb(2)+ue0ttnb(3))/dnt,
     -        ue1/dnt,
     -        (ue1ttnb(1)+ue1ttnb(2)+ue1ttnb(3))/dnt
c           Print TI integrand for coupling non linear in lambda
            udele=0.0
            udelesv=0.0
            do k=1,3
              xtv0(k)=-tifactwo(k)*ue0ind(k)/dnt
              xtt0(k)=-tifactwo(k)*ue0ttnb(k)/dnt
              xtv1(k)=tifacone(k)*ue1ind(k)/dnt
              xtt1(k)=tifacone(k)*ue1ttnb(k)/dnt
              udelesv=udelesv+xtv0(k)+xtv1(k)
              udele=udele+xtv0(k)+xtt0(k)+xtv1(k)+xtt1(k)
            end do
            write (iout,1031) cplpar,ptiexp,nmc,udele
            if (abs(udele-udelesv) .gt. 0.01)
     -        write (iout,1040) cplpar,udelesv
            write (iout,1073)
            write (iout,1074) 0.0,(xtv0(k),k=1,3),(xtt0(k),k=1,3)
            write (iout,1074) 1.0,(xtv1(k),k=1,3),(xtt1(k),k=1,3)
            write (iout,1099)
            ein0=(ue0innb(1)+ue0t14(1)+ue0tor(1))/dnt
            ein1=(ue1innb(1)+ue1t14(1)+ue1tor(1))/dnt
            write (iout,1097) 0.0,ue0innb(1)/dnt,
     -        ue0t14(1)/dnt,ue0tor(1)/dnt,ein0
            write (iout,1097) 1.0,ue1innb(1)/dnt,
     -        ue1t14(1)/dnt,ue1tor(1)/dnt,ein1
            write (iout,1098) ein1-ein0
          end if
          if (iop(30) .eq. 6 .or. iop(30) .eq. 8) then
c           Perturbation method run
            uus0=(uus0/uws0)
            uus1=(uus1/uws1)
            expav0=uws0/nt
            expav1=uws1/nt
            if (iop(30) .eq. 6) then
c             Perturbation method with half umbrella sampling
              decpl=delest*(uspar1-uspar0)
              dela0=alog(expav0)/beta-delest*(uspar0-cplpar)
              dela1=-alog(expav1)/beta+delest*(uspar1-cplpar)
            else
c             Perturbation method with explicite middle state
              dela0=alog(expav0)/beta+del0st
              dela1=alog(expav1)/beta+del1st
            end if
            dela01=dela0+dela1
            cplparo=uspro0+cplpar*(uspro1-uspro0)
            write (iout,1135) ' inputted  ',cplparo
            if (iop(35) .gt. 0) write (iout,1135) 'precombined',cplpar
            write (iout,1024) cplparo,uspro1,'+',uspro0,cplparo,dela0
            write (iout,1024) uspro1,cplparo,'-',uspro1,cplparo,dela1
            write (iout,1036) uspro1,uspro0,cplparo,uspro0,
     -        uspro1,cplparo,dela01
            write (iout,1029) uspro0,uspro0,uus0
            write (iout,1029) uspro1,uspro1,uus1
            write (iout,1035) de01mn,nm01mn,de01mx,nm01mx
            write (iout,1033) expav0,expav1,decpl
            if (iop(30) .eq. 8) then
c             Plot the energy difference distributions (overlap ratio method)
              isum=0
              do i=1,#OR
                isum=isum+norde0(i)
              end do
              pmax=0.0
              do i=1,#OR
                pnor(i)=float(norde0(i))/float(isum)
                por(i)=0.0
                if (pnor(i) .gt. 0.0) por(i)=alog(pnor(i))
                if (pmax .lt. por(i)) pmax=por(i)
                gor(i)=gmor0k+(i-1)*gdvork+gdvork/2.0
              end do
              if (uspar0 .lt. cplpar)
     -          call plot(gor,por,pnor,#OR,0.0,0.0,0.0,0.0,50,
     -            2,iop(16),40,63,itfdif,0,0,1)
              isum=0
              do i=1,#OR
                isum=isum+norde1(i)
              end do
              pmax=0.0
              do i=1,#OR
                pnor(i)=float(norde1(i))/float(isum)
                por(i)=0.0
                if (pnor(i) .gt. 0.0) por(i)=alog(pnor(i))
                if (pmax .lt. por(i)) pmax=por(i)
                gor(i)=gmor1k+(i-1)*gdvork+gdvork/2.0
              end do
              if (uspar1 .gt. cplpar)
     -           call plot(gor,por,pnor,#OR,0.0,0.0,0.0,0.0,50,
     -             2,iop(16),40,63,itsdif,0,0,1)
            end if
          end if
c         Add intramolecular contributions
c         esltin code has been removed
c???
        else
c         Variable solute output
          ndh0sm=0
          do k=1,#WG
            ndh0sm=ndh0sm+nfisum(k)
            pbzavi(k)=1.0
            if (nfisum(k) .ne. 0) then
              nls=nfisum(k)-nfismo(k)
              dstcplk=dstcplsum(k)+dstcpl(k)
              pbzavi(k)=-boltz*temp*dlog(dstcplk/uwtav)
              dstcplk=dstcpl(k)
              if (nls .eq. 0) dstcplk=1.d0
              upmftota=(upmftotsum(k)+nls*upmftot(k)/dstcplk)/nfisum(k)
              upmftva=(upmftvsum(k)+nls*upmftv(k)/dstcplk)/nfisum(k)
              upmftta=(upmfttsum(k)+nls*upmftt(k)/dstcplk)/nfisum(k)
              eincpl(k)=upmftta
              write (iout,1088) cpl(k),upmftota,upmftva,upmftta
            end if
          end do
c         call lincmb(c,crm,cplpar,1,qslt,nstfa0)
          if (iop(51) .eq. 0) then
c           Harmonic US output
c           rndh(k): fraction of configurations spent in grid k
            do k=1,#WG
              rndh(k)=float(nfisum(k))/float(ndh0sm)
            end do
            call plot(cpl(kp1zro),pbzavi(kp1zro),rndh(kp1zro),#WG/2,
     -        0.0,0.0,0.0,0.0,20,1,iop(16),40,20,itcplp,0,0,1)
          end if
        end if
      end if
      write (iout,2000) 'SAMPLING-RELATED'
      if (iop(7) .eq. 2) then
        dijmn=sqrt(dijmin)
        write (iout,1067) dijmn
      end if
      if (iop(6) .eq. 5 .or. iop(6) .eq. 6)
     -   write (iout,1016) nftcut,nftcta
C@NN      if (numsolv .gt. 0) write (iout,1017) nupdat
      if (nvchmc .eq. 0) nvchmc=1
      if (iop(71) .gt. 0) then
        vchacc=0.0
        if (nvchmc .gt. 0) vchacc=float(nvchacc)/float(nvchmc)
        write (iout,1104) vchacc,nvchmc
      end if
      nsltmv=nmvd(1)
      if (isltmove .gt. 0) write (iout,1012) npckd(1),nsltmv
      if (iop(30) .eq. 7) then
        acc=0.0
        if (npmftry .gt. 0) acc=float(npmfacc)/npmftry
        write (iout,1079) acc,npmftry
      end if
      if (iop(57) .gt. 0) then
        do k=1,3
          ntkacc(k)=0
          ntktry(k)=0
          do i=1,50
            ntkacc(k)=ntkacc(k)+nptaacc(k,i)
            ntktry(k)=ntktry(k)+nptatry(k,i)
          end do
          tmslt(k)=0.0
          if (ntkacc(k) .gt. 0) tmslt(k)=rdtodg*avstrot(k)/ntkacc(k)
          ptkacc(k)=0.0
          if (ntktry(k) .gt. 0)
     -      ptkacc(k)=float(ntkacc(k))/float(ntktry(k))
        end do
        write (iout,1181) ntktry,ptkacc
        if (iop(44) .ne. 2) then
          nptdtry=ntktry(1)+ntktry(2)+ntktry(3)
          nptdacc=ntkacc(1)+ntkacc(2)+ntkacc(3)
          npddtry=npdslttry-nptdtry
          npddacc=npdsltacc-nptdacc
          accd=0.0
          if (npddtry .gt. 0) accd=float(npddacc)/float(npddtry)
          acct=0.0
          if (nptdtry .gt. 0) acct=float(nptdacc)/float(nptdtry)
          write (iout,1159) 'solute',accd,acct
        end if
        call prtacc(npdsttry,npdstacc,1,nsttm,#MM,cv1,#UV,
     -    'Partial solute move ',iout,iop(70))
        if (iop(70) .gt. 0) then
          do k=1,3
            if (dispmax(k) .gt. 0.0) then
              write (iout,1091) k
              do i=1,50
                gesslt(i)=0.0
                if (nptatry(k,i) .gt. 0)
     -            gesslt(i)=float(nptaacc(k,i))/float(nptatry(k,i))
              end do
              if (iop(57) .eq. 1) write (iout,1092) 'absolute rotation',
     -          dispmax(k)*rdtodg
              if (iop(57) .ge. 2) write (iout,1092)
     -          'maximum angle range',dispmax(k)*rdtodg
              write (iout,1102) (gesslt(i),i=1,50)
              if (iop(70) .gt. 1) write (iout,1085)(nptatry(k,i),i=1,50)
            end if
          end do
c         Average stepsize for solute molecules
          do im=1,nsttm
            cx1(im)=0.0
            if (npdstacc(im) .gt. 0) cx1(im)=sltstepsum(im)/npdstacc(im)
          end do
          write (iout,1131) (cx1(im),im=1,nsttm)
        end if
        if (iop(64) .gt. 0) then
c         Solute group swap output
          call prtacc(nswtry,nswacc,2,nsttm,#MM,cv1,#UV,
     -      'Solute molecule swap',iout,iop(70))
        end if
        if (iop(66) .gt. 0) then
c         Solute group swap output
          call prtacc(n2stry,n2sacc,2,nsttm,#MM,cv1,#UV,
     -      '2-solute molec move ',iout,iop(70))
          if (nmv2stry .gt. 0 .and. r2scut .gt. 0.0)
     -      write (iout,1157) r2scut,nn2min,nn2max
        end if
      end if
      if (iop(68) .gt. 0)
     -  call prtacc(nspsttry,nspstacc,1,ntorgrp,#MM,cv1,#UV,
     -    'Special solute move ',iout,iop(70))
      if (iop(58) .gt. 0) then
        if (iop(91) .gt. 0) then
c         Loop move stats
          if (nloopmtry .gt. 0) then
            write (iout,1167) nloopmtry
            if (iop(91) .eq. 3) then
              accn=0.0
              accf=0.0
              if (numnearpicked .gt. 0)
     -          accn=float(numnearacc)/float(numnearpicked)
              if (numnearpicked .lt. nloopmtry)
     -          accf=float(nloopacc-numnearacc)/
     -            float(nloopmtry-numnearpicked)
              write (iout,1155) numnearpicked,nloopmtry-numnearpicked,
     -         accn,accf
            end if
            nloopctrysum=2*nloopmtry-numrej0
            if (nloopctrysum .gt. 0) then
              write (iout,1140) float(numrej0)/float(nloopmtry),
     -          float(numrevrej)/float(nloopmtry),nloopctrysum,
     -          evalnum/dfloat(nloopctrysum),
     -          solnum/dfloat(nloopctrysum),numnosol
              do it=1,nlooptyp
                if (looptypcnt(it) .gt. 0) then
                  if (it .eq. 1) then
                    write (iout,1151) looptypname(it),it
                  else
                    write (iout,1151) looptypname(it),it,' ',
     -                loopstrat(iop(103))
                  end if
                  do id=1,2
                    if (id .eq. 1) write (iout,1152) 'direct',
     -                nloopctry(id,it)
                    if (id .eq. 2) write (iout,1152)'reverse proximity',
     -                nloopctry(id,it)
                    write (iout,1150) 'fixed root choice',
     -                nimptry(it,id),(nimpfound(ii,it,id),ii=1,2)
                    call printnumdist('failures',8,10,
     -                nosoltyps(1,it,id),iout)
                  end do
                  if (iop(103) .ge. 3) write (iout,1164) nsectry(it),
     -              nsecact(1,it)
                  if (iop(103) .eq. 4) write (iout,1165) nsecact(3,it)
                end if
              end do
              write (iout,*)
              if (looptypcnt(1) .gt. 0) then
                call printnumdist('d23 failure',11,20,n12diff,iout)
                call printnumdist('d13 failure',11,20,n13diff,iout)
              end if
            else
              write (iout,1154)
              nwarn=nwarn+1
            end if
            write (iout,1163) njacsing
          end if
        end if
      end if
      if (nmccd .gt. 0) write (iout,1161) nacortry
      if (nmccgd .gt. 0) write (iout,1162) ngcortry,ngcorfail
      if (nmolec .gt. 1) then
        if (iop(6) .ne. 2) then
c         Print statistics over stepsize - acceptance
          accmax=0.0
          ntrytot=0
          nacctot=0
          armax=0.0
          ar2max=0.0
          do i=1,50
            gpeslt(i)=0.0
            if (nrtry(i) .gt. 0)
     -        gpeslt(i)=float(nracc(i))/float(nrtry(i))
            if (accmax .le. gpeslt(i)) then
              accmax=gpeslt(i)
              irmax=i
            end if
            if (armax .le. gpeslt(i)*float(i)) then
              armax=gpeslt(i)*float(i)
              iarmax=i
            end if
            if (ar2max .le. gpeslt(i)*float(i*i)) then
              ar2max=gpeslt(i)*float(i*i)
              iar2max=i
            end if
            ntrytot=ntrytot+nrtry(i)
            nacctot=nacctot+nracc(i)
          end do
          rsmax=float(iarmax-1)*((cedslv/2.0)*sqrt(3.0)+0.0001)/50.0
          r2smax=float(iar2max-1)*((cedslv/2.0)*sqrt(3.0)+0.0001)/50.0
          do i=1,50
            gesslt(i)=0.0
            if (nrcorr(i) .gt. 0)
     -        gesslt(i)=drcorr(i)/float(nrcorr(i))
            gesslv(i)=float(nrtry(i))/float(ntrytot)
          end do
          if (iop(70) .gt. 0) then
            if (iop(6) .gt. 4) write (iout,1071) (gesslv(i),i=1,50)
            write (iout,1068) (gpeslt(i),i=1,50)
            write (iout,1070) (gesslt(i),i=1,50)
          end if
c         Find the stepsizes where the acceptance rate drops to 1/2, 1/3, 1/5
          irmax2=0
          irmax3=0
          irmax5=0
          do i=irmax,50
            ii=50-i+irmax
            if (irmax2 .eq. 0 .and. gpeslt(ii) .gt. accmax/2.0)irmax2=ii
            if (irmax3 .eq. 0 .and. gpeslt(ii) .gt. accmax/3.0)irmax3=ii
            if (irmax5 .eq. 0 .and. gpeslt(ii) .gt. accmax/5.0)irmax5=ii
          end do
          rmax1=sqrt(3.0)*(float(irmax)/50.0)*cedslv/2.0
          rmax2=sqrt(3.0)*(float(irmax2)/50.0)*cedslv/2.0
          rmax3=sqrt(3.0)*(float(irmax3)/50.0)*cedslv/2.0
          rmax5=sqrt(3.0)*(float(irmax5)/50.0)*cedslv/2.0
          write (iout,1069) accmax,rmax1,rmax2,rmax3,rmax5,rsmax,r2smax
        else
          ntrytot=nrtry(1)
          nacctot=nracc(1)
        end if
        if (iop(44) .eq. 2 .or. iop(44) .eq. 3) then
          nrottry=nmovtry-npckd(1)-ntrytot
          nrotacc=nmovacc-nmvd(1)-nacctot
          accd=0.0
          if (ntrytot .gt. 0) accd=float(nacctot)/float(ntrytot)
          accr=0.0
          if (nrottry .gt. 0) accr=float(nrotacc)/float(nrottry)
          write (iout,1159) 'solvent',accd,accr
        end if
c       Compute the picking rate and acceptance rate for every molecule
        accmin=1.0
        accmax=0.0
        permin=1.0
        permax=0.0
        notmov=0
        acc=0.0
        if (nmovtry-npckd(1) .gt. 0)
     -    acc=float(nmovacc-nmvd(1))/float(nmovtry-npckd(1))
        notmovmin=nmc
        notmovfac=50
        if (acc .lt. 1.0 .and. acc .gt. 0.0)
     -    notmovmin=-alog(float(notmovfac*nmolec))/alog(1.0-acc)
        write (iout,1081) notmovmin,notmovfac,
     -    1.0/(float(notmovfac*nmolec))
        if (nsltfreq .ne. 1) then
          nmfx=nsolvfix+isltmove
          nrejmax=0
          irejmax=0
          do im=mvfst,nmolec
            perrat(im)=float((nmolec-nmfx)*npckd(im))/float(nt)
            accrat(im)=0.0
            if (npckd(im) .ne. 0)
     -          accrat(im)=float(nmvd(im))/float(npckd(im))
            if (nrejis(im) .gt. notmovmin) then
              write (iout,1077) im-1,(c(k,ic01+im*nslv),k=1,3),
     -            tesi(im),(tsind(k,im),k=1,3),nrejis(im)
              notmov=notmov+1
            end if
            if (nrejmax .lt. nrejis(im)) then
              nrejmax=nrejis(im)
              irejmax=im
            end if
            if (accrat(im) .gt. accmax) accmax=accrat(im)
            if (accrat(im) .lt. accmin) accmin=accrat(im)
            if (perrat(im) .gt. permax) permax=perrat(im)
            if (perrat(im) .lt. permin) permin=perrat(im)
          end do
          if (notmov .gt. 0) then
            write (iout,1034) notmov,notmovmin
            nwarn=nwarn+1
            if (iop(24) .gt. 2) then
              call savepdb('PDB ',keycol,iunm,iout,1,nstta,nslv,c,
     -          notmov,0,0,1,filename1,namlens1,nmc,2,file,namlenf,
     -          numrun,1,3,inperr,nwarn,nwwarn,9,0,nlwr,0,1,#HA)
              write (iout,1075) filename1(1:namlens1)
            end if
          end if
          write (iout,1197) nrejmax,irejmax-1
          if (iop(70) .gt. 0) then
            if (iop(70) .gt. 1)
     -        write (iout,1022) (perrat(im),im=mvfst,nmolec)
            write (iout,1021) (accrat(im),im=mvfst,nmolec)
          end if
          if (iop(12) .gt. 3) write (iout,1032) permin,permax
          write (iout,1027) accmin,accmax,acc
          if ((accmin .le. accpmn .and. nmc .ge. 200*nmolec) .and.
     -      iop(24) .gt. 1) then
c           For solvents below accpmn acceptance rate, print nearest solute atom
            nclose=0
            npckmn=10
            if (iop(24) .gt. 1) npckmn=2
            do im=2,nmolec
              if (accrat(im) .le. accpmn .and.
     -            npckd(im) .ge. npckmn) then
                nclose=nclose+1
                ivtm(nclose)=im
                accrat(nclose)=accrat(im)
              end if
            end do
            if (nclose .gt. 0) then
              call mrgsrt(iout,ivtm,accrat,nclose,indexx,indexn,
     -          ixnear,cv1,#UV)
              iaccmn=100.0*accpmn+0.0001
              write (iout,1037) iaccmn,nclose
              do ii=1,nclose
                im=ivtm(ii)
c               Now find the nearest slt atom
                n1=1
                if (iop(30) .ge. 7) n1=nstfa1+1
                jmin=0
                r2min=1.e+6
                do js=n1,nstta
                  r2=arrdist(crm(1,im),c(1,js))
                  if (r2 .lt. r2min) then
                    r2min=r2
                    jmin=js
                  end if
                end do
                r2=sqrt(r2min)
                write (iout,1038) im,perrat(im),accrat(ii)
                if (nstta .gt. 0) write (iout,1039) jmin,
     -           iatnam(iatnos(iclslt(jmin),iopslt(jmin))),r2,texslt(im)
              end do
            end if
          end if
        end if
      end if
      write (iout,2000) 'CONFIGURATION SPACE EXPLORATION'
      if (iop(71) .gt. 0) then
        write (iout,1082) (vstep/max0(1,nvchacc)),vmin,vmax
        do k=1,3
          vastepxyz(k)=vxstep(k)/max0(1,nxstep(k))
        end do
        vastpx=vastepxyz(1)*eyav*ezav
        vastpy=vastepxyz(2)*exav*ezav
        vastpz=vastepxyz(3)*exav*eyav
        write (iout,1106) vastepxyz
        write (iout,1107) vastpx,vastpy,vastpz
        vastp=vastpx+vastpy+vastpz
        if (iop(72) .eq. 0) then
          write (iout,1109) ' ',vastp
        else if (iop(72) .eq. 1) then
          vastp=vastp/3.0
          write (iout,1109) '/3 ',vastp
        else if (iop(72) .eq. 2) then
          vastpyz=vastpy+vastpz
          write (iout,1108) vastpx,vastpyz
        end if
      end if
      if (nhowfar .eq. #MI) then
c       Double up sampling extent data
        nhowfarsamp=nhowfarsamp*2
        nhowfar=nhowfar/2
        do i=1,nhowfar
          dtot(i,1)=dtot(2*i,1)
          dtot(i,2)=dtot(2*i,2)
          decay(i,1)=decay(2*i,1)
          decay(i,2)=decay(2*i,2)
        end do
      end if
      numplot=max0(1,nmc/nplt)
      if (mod(numplot,nhowfarsamp) .eq. 0) nhowfar=nhowfar+1
      if (nmolec .gt. 1 .and. iop(41) .eq. 0) then
c-------Compute various diffusion characteristics
        if (nsltmv .gt. 0) then
          r2=arrdist(crm(1,1),crm0(1,1))
          write (iout,1018) sqrt(r2)
        end if
        if (nmovacc-nsltmv .gt. 0) then
          avstp=avstp/dfloat(nmovacc-nsltmv)
          avrot=avrot/dfloat(nmovacc-nsltmv)*rdtodg
        end if
        write (iout,1030) 'solvent',avstp,avrot
        dmin=1000.0
        dmax=0.0
        dis=0.d0
        displs=0.d0
        do is=2,nmolec
          r2=arrdist(crm(1,is),crm0(1,is))
          if (r2 .lt. dmin) dmin=r2
          if (r2 .gt. dmax) dmax=r2
          dis=dis+sqrt(r2)
          displs=displs+r2
        end do
        di=dis/nmolec
        displ=displs
        dp2pm=displ/float(nmolec)
        displ=sqrt(displ)
        sdv=sqrt(displ**2/float(nmolec)-di**2)
        dmin=sqrt(dmin)
        dmax=sqrt(dmax)
        diffcr=float(nmovacc)/float(nt)*avstp**2
        crav=0.0
        if (ncorav .gt. 0) crav=corrav/ncorav
        dfftot=sqrt(diffcr)*(1.0+crav)
        write (iout,1000) displ,dp2pm,di,sdv,dmin,dmax,crav,diffcr,
     -    dfftot
        if (mod(numplot,nhowfarsamp) .eq. 0) dtot(nhowfar,2)=dp2pm
        call printslope(dtot(1,2),nmc,nhowfar,nhowfarsamp*nplt,
     -    'Solvent',iout)
        write (iout,1186) (ncross(i),i=1,ncell)
      end if
c     cgs was read at the start of disfin
      if (iop(41) .eq. 0 .and. nmolec. gt. 1) then
c       Compute orientational correlations between start and end (canonical)
        racors=0.d0
        racors2=0.d0
        racmin=1.0
        racmax=-1.0
        nmolcr=0
        do i=2,nmolec
          if (ivtm(i) .eq. 0) then
            nmolcr=nmolcr+1
            if (iop(26) .lt. 4) then
c             Standard water solvent
              call ortslv(cgs(1,ic01+indexx(i)*nslv),ort,ifail)
            else
c             General solvent
              call getort(cgs(1,ic01+indexx(i)*nslv),cm,ianslv,rlcslv,
     -          nslv,ort,(i-1),ixislt,-1,linear,0,0,ixrep3,nrep3,ifail,
     -          idebug(29),iout,nslv)
            end if
            racorr=0.0
            do k=1,3
              racorr=racorr+ort(k,1)*orient(k,1,i)
            end do
            if (racmin .gt. racorr) racmin=racorr
            if (racmax .lt. racorr) racmax=racorr
            racors=racors+racorr
            racors2=racors2+racorr**2
          end if
        end do
        if (nmolcr .gt. 0) then
          racorr=racors/nmolcr
          racorr2=racors2/nmolcr
          racord=sqrt(racorr2-racorr**2)
          if (mod(numplot,nhowfarsamp) .eq. 0) decay(nhowfar,2)=racorr
          write (iout,1020) racmin,racmax,racmin*rdtodg,racmax*rdtodg,
     -      racorr,racord,racorr*rdtodg
        end if
      end if
      if (iop(57) .gt. 0) then
c       Compute mean stepsizes for solute molecules
        call trnsfr(rtx,rtxpslt,3)
        do k=1,3
          if (iop(57) .eq. 1) rtx(k)=rtx(k)*rdtodg
          if (npdsltacc .gt. 0) cmslt(k)=avststp(k)/npdsltacc
        end do
        if (npdsltacc .gt. 0) then
          call avstdev_n(avststptot,avststptot2,npdsltacc,totstep,sd)
        else
          call zeroit(cmslt,3)
          totstep=0.0
          sd=0.0
        end if
        if (istune(1) .gt. 0) then
          istn=2
          do im=movmolf,movmoll
            do k=1,3
              rrr(k)=0.0
              sss(k)=0.0
              if (ntrantune(im) .gt. 0) then
                sss(k)=stepsumtrans(k,im)*
     -            (wstepsum1(1)/(1.d0-wstepsum(1)**(ntrantune(im))))
                rrr(k)=stepsumtranscumu(k,im)/ntrantune(im)
              end if
            end do
            write (iout,1182) im,'translation',wstepsum(1),sss,
     -        wsum(1),accsumtrans(im)
            write (iout,1188) 'translation',rrr
          end do
        else
          istn=1
          write (iout,1080) cmslt,totstep,sd,
     -      selectname(iop(73)+1),cedpslt
        end if
        if (istune(2) .gt. 0) then
          do im=movmolf,movmoll
            do k=1,3
              sss(k)=0.0
              rrr(k)=0.0
              if (nrottune(k,im) .gt. 0) then
                sss(k)=stepsumrot(k,im)*
     -            (wstepsum1(2)/(1.d0-wstepsum(2)**(nrottune(k,im))))
                rrr(k)=stepsumrotcumu(k,im)/nrottune(k,im)
              end if
            end do
            write (iout,1182) im,'rotation   ',wstepsum(2),sss,
     -        wsum(2),(accsumrot(k,im),k=1,3)
            write (iout,1188) 'rotation   ',rrr
          end do
        end if
        if (waxis(3) .gt. 0) then
          if (iop(57) .gt. 1) write (iout,1170)
     -      tmslt,exbiname(iop(57)-1),stunelab(istn),rtx
          if (iop(57) .eq. 1) write (iout,1169) tmslt,stunelab(istn),rtx
c         Compute orient. correl. of solute molecs. between start and end
          do k=1,3
             racsltors(k)=0.d0
             racsltors2(k)=0.d0
             racsltmin(k)=1.0
             racsltmax(k)=-1.0
          end do
          im0=1
          do im=1,nsttm
            if (im .gt. 1) im0=natfix(im-1)+1
            if (iop(58) .gt. 0) then
              call getort(cgs(1,ifirstm(im)),cgs(1,molcnt(im)),
     -          iclslt(ifirstm(im)),rlcslt(1,ifirstm(im)),
     -          natfix(im)-im0+1,ort,0,iroots(im0),
     -          ifirstm(im)-1,linear,1,0,ixrep3slt,nrep3slt,ifail,
     -          idebug(29),iout,natoms)
            else
              call getort(cgs(1,ifirstm(im)),cgs(1,molcnt(im)),
     -          iclslt(ifirstm(im)),rlcslt(1,ifirstm(im)),
     -          ilastm(im)-ifirstm(im)+1,ort,0,ixislt,
     -          0,linear,1,0,ixrep3slt,nrep3slt,ifail,idebug(29),
     -          iout,ilastm(im)-ifirstm(im)+1)
            end if
            do k=1,3
              racsltorr=0.0
              do l=1,3
                racsltorr=racsltorr+ort(l,k)*orientsltm(l,k,im)
              end do
              if (racsltmin(k) .gt. racsltorr) racsltmin(k)=racsltorr
              if (racsltmax(k) .lt. racsltorr) racsltmax(k)=racsltorr
              racsltors(k)=racsltors(k)+racsltorr
              racsltors2(k)=racsltors2(k)+racsltorr**2
            end do
          end do
          do k=1,3
            racsltorr=racsltors(k)/nsttm
            racsltorr2=racsltors2(k)/nsttm
            racsltord=sqrt(abs(racsltorr2-racsltorr**2))
            write (iout,1023) lxyz(k),racsltmin(k),racsltmax(k),lxyz(k),
     -        racsltorr,racsltord,
     -        acoscheck(racsltorr,iout,'DISFIN')*rdtodg
            if (k .eq. 1) then
              if (mod(numplot,nhowfarsamp) .eq. 0)
     -          decay(nhowfar,1)=racsltorr
            end if
          end do
        end if
      end if
      if (iop(57) .gt. 0 .and. iop(64) .eq. 0) then
c       Calculate overall solute molecule RMS's
        noclone=1
        do im=movmolf,movmoll
          newclonstart=0
          if (im .lt. nsttm) then
c           Check if new clone type is starting
            if (icorig(ifirstm(im)) .gt. 0 .and.
     -          icorig(ifirstm(im+1)) .lt. 0) newclonstart=1
          end if
          if (newclonstart .eq. 1 .or. im .eq. 1) then
            rmsav=0.d0
            rms2av=0.d0
            rmsmin=100000.0
            rmsmax=0.0
            if (newclonstart .eq. 1) noclone=0
            nclones=0
          end if
          nclones=nclones+1
          call arrdiff(cm,cgs(1,molcnt(im)),c(1,molcnt(im)),3)
          call trnsfr(tm,cm,3)
          call pbcnd(cm(1),cm(2),cm(3),iop(5),iopt,r2)
          r2=0.0
          do ia=ifirstm(im),ilastm(im)
            do k=1,3
              r2=r2+(cgs(k,ia)-c(k,ia)+cm(k)-tm(k))**2
            end do
          end do
          rr=sqrt(r2)
          if (noclone .eq. 0) then
            if (rmsmin .gt. rr) rmsmin=rr
            if (rmsmax .lt. rr) rmsmax=rr
            rmsav=rmsav+rr
            rms2av=rms2av+r2
          end if
          newclonend=0
          if (im .lt. nsttm) then
            if (icorig(ifirstm(im)) .lt. 0 .and.
     -          icorig(ifirstm(im+1)) .gt. 0) newclonend=1
          else if (noclone .eq. 0) then
            newclonend=1
          end if
          if (newclonend .eq. 1) then
            call avstdev_n(rmsav,rms2av,nclones,rmsavg,rmssd)
            write (iout,1133) im-nclones+1,im,rmsavg,rmssd,rmsmin,rmsmax
          else if (noclone .eq. 1) then
            write (iout,1134) im,rr
          end if
        end do
      end if
      if (iop(57) .gt. 0 .and. nsltcp(iop(30)+1) .ne. 2) then
c       Print molecule center diffusion results
        r2sum=0.0
        r2min=10000.0
        r2max=0.0
        do im=movmolf,movmoll
          call arrdiff(cm,cgs(1,molcnt(im)),c(1,molcnt(im)),3)
          call pbcnd(cm(1),cm(2),cm(3),iop(5),iopt,r2)
          cv2(im)=sqrt(r2)
          r2sum=r2sum+r2
          if (r2 .gt. r2max) r2max=r2
          if (r2 .lt. r2min) r2min=r2
        end do
        r2sum=sqrt(r2sum/(movmoll-movmolf+1))
        write (iout,1090) r2sum,sqrt(r2min),sqrt(r2max),
     -    (cv2(im),im=movmolf,movmoll)
        if (mod(numplot,nhowfarsamp) .eq. 0) dtot(nhowfar,1)=r2sum**2
        call printslope(dtot(1,1),nmc,nhowfar,nhowfarsamp*nplt,
     -    'Solute ',iout)
      end if
      if (cedslt+rtxslt .gt. 0.0)
     -  write (iout,1168) 'global solute',wslttry(1)
      if (iop(57) .gt. 0)
     -  write (iout,1168) 'solute molecule',wslttry(3)-wslttry(2)
      if (iop(30) .eq. 7)
     -  write (iout,1168) 'coupling parameter',wslttry(3)-wslttry(2)
      if (iop(58) .gt. 0)
     -  write (iout,1168) 'torsion',wslttry(4)-wslttry(3)
      if (iop(64) .gt. 0)
     -  write (iout,1168) 'solute swap',wslttry(5)-wslttry(4)
      if (iop(66) .gt. 0)
     -  write (iout,1168) '2-solute',wslttry(6)-wslttry(5)
      if (iop(68) .gt. 0)
     -  write (iout,1168) 'special sampling',wslttry(7)-wslttry(6)
      if (iop(58) .gt. 0) then
c       Print torsion angle change statistics
        if (iop(58) .eq. 1) write (iout,1171)
        if (iop(58) .gt. 1) write (iout,1172) exbiname(iop(58)-1)
        if (ntorsinp .gt. 0) then
           do ic=1,nsltcop
           write (iout,1147) 'T',ic,rngfac(ic)
           if (iop(91) .gt. 0)
     -       write (iout,1147) 'Loop t',ic,rngfacl(ic)
          end do
        end if
        if (ngrtmx .gt. ngrtmn) then
          write (iout,1180) selectname(iop(74)+1)
          write (iout,1132) selectname(iop(75)+1)
        end if
        do it=1,ntang
          cv1(it)=abs(circadd(ta0(it),dihang(it),-1.0))*rdtodg
        end do
        wmaxx=0.0
        if (iop(69) .eq. 1) then
c         Average circular variance, stepsizes over clones
          call cloneav(ntang,ntangorg,itorig,l3,cv1,cv2,cgz,#TR)
          call trnsfr(cv3,torstep,ntang)
          if (iop(91) .gt. 0) call trnsfr(cy3,steploop,ntang)
          do it=1,ntang
            call origtor(it,itorig,1,itn)
c           itn: original index of torsion on first copy
            abx(itn)=wtors(itorgrp(itn)+1)-wtors(itorgrp(itn))
            if (abx(itn) .gt. wmaxx) wmaxx=abx(itn)
          end do
          write (iout,1101) (it,cv2(it),cgz(it),it=1,ntangorg)
        else
          call trnsfr(cv2,cv1,ntang)
          call trnsfr(cv3,torstep,ntang)
          if (iop(91) .gt. 0) then
            call trnsfr(cy3,steploop,ntang)
          end if
          do it=1,ntang
            abx(it)=wtors(itorgrp(it)+1)-wtors(itorgrp(it))
            if (abx(it) .gt. wmaxx) wmaxx=abx(it)
          end do
        end if
        call torsionacc(ntang,l1,l2,ixnear,nptstacc,nptsttry,
     -    tstepsum,tstepmax,ntorgrp,ntorg,ifdhgrlst,ildhgrlst,itorig,
     -    aby,riijjv,abz,iop(69),iout)
        if (iop(91) .gt. 0)
     -    call torsionacc(ntang,l3,l4,ixnear,nptloopacc,nptlooptry,
     -      tlstepsum,tlstepmax,ntorgrp,ntorg,ifdhgrlst,ildhgrlst,
     -      itorig,cx1,cx2,cx3,iop(69),iout)
        do it=1,ntangorg
          abx(it)=abx(it)/wmaxx
          if (iop(58) .le. 1) then
            cv3(it)=torstep(it)*rdtodg
          end if
          if (iop(91) .gt. 0) then
            cy3(it)=cy3(it)*rdtodg
          end if
        end do
        if (iop(69) .eq. 0 .or. iop(1) .lt. 2)
     -    write (iout,1100) (cv1(it),it=1,ntang)
c       Gather stepsizes, weights
        wmaxx=0.0
c       Calculate RMS due to torsions only
        im0=1
        noclone=1
        do im=itmfrst,nsttm
          if (im .gt. 1) im0=natfix(im-1)+1
          nrootused=natfix(im)-im0+1
          newclonstart=0
          if (im .lt. nsttm) then
c           Check if new clone type is starting
            if (icorig(ifirstm(im)) .gt. 0 .and.
     -          icorig(ifirstm(im+1)) .lt. 0) newclonstart=1
          end if
          if (newclonstart .eq. 1 .or. im .eq. 1) then
            rmsav=0.0
            rms2av=0.0
            rmsmin=10000.0
            rmsmax=0.0
            imc1=im
            do ia=1,nrootused
              rrimav(ia)=0.0
              r2imav(ia)=0.0
              rrimmin(ia)=100000.0
              rrimmax(ia)=0.0
            end do
            if (newclonstart .eq. 1) noclone=0
            nclones=0
          end if
          nclones=nclones+1
          call getort(c(1,ifirstm(im)),c(1,molcnt(im)),
     -      iclslt(ifirstm(im)),cgs(1,ifirstm(im)),natfix(im)-im0+1,ort,
     -      0,iroots(im0),ifirstm(im)-1,linear,1,0,ixrep3slt,nrep3slt,
     -      ifail,idebug(29),iout,natoms)
          call trnsfr(cm,cgs(1,molcnt(im)),3)
          do ia=ifirstm(im),ilastm(im)
            call arrdiff(cgs(1,ia),cgs(1,ia),cm,3)
          end do
          call rot_trans(ort,cgs(1,ifirstm(im)),c(1,molcnt(im)),
     -      cgs(1,ifirstm(im)),(ilastm(im)-ifirstm(im)+1))
          r2=0.0
          do ia=ifirstm(im),ilastm(im)
            r2=r2+arrdist(c(1,ia),cgs(1,ia))
          end do
          rr=sqrt(r2)
          if (noclone .eq. 0) then
            if (rmsmin .gt. rr) rmsmin=rr
            if (rmsmax .lt. rr) rmsmax=rr
            rmsav=rmsav+rr
            rms2av=rms2av+r2
          end if
          if (idebug(42) .gt. 0) write (iout,7895) im,rr,r2
          do ita=im0,natfix(im)
            irt=ita-im0+1
            it=itorsfind(iroots(ita),ntang,iquata,inperr,iout,1)
            if (it .gt. 0) then
              r2i=0.0
              do iaa=1,nnexttorat(itangindx(it))
                ia=irotlist(irotlinc(it)+iaa)
                r2i=r2i+arrdist(c(1,ia),cgs(1,ia))
              end do
              rrii(irt)=sqrt(abs(r2i))
              if (noclone .eq. 0) then
                if (rrimmin(irt) .gt. rrii(irt)) rrimmin(irt)=rrii(irt)
                if (rrimmax(irt) .lt. rrii(irt)) rrimmax(irt)=rrii(irt)
                rrimav(irt)=rrimav(irt)+rrii(irt)
                r2imav(irt)=r2imav(irt)+r2i
              end if
              if (idebug(42) .gt. 0) then
                write (iout,7897) ita,r2i,rrii(irt)
                if (idebug(42) .gt. 1)
     -            write (iout,7896) iroots(ita),it,
     -              (irotlist(irotlinc(it)+iaa),
     -              iaa=1,nnexttorat(itangindx(it)))
              end if
            else
              rrii(irt)=-1.0
            end if
          end do
          newclonend=0
          if (im .lt. nsttm) then
            if (icorig(ifirstm(im)) .lt. 0 .and.
     -          icorig(ifirstm(im+1)) .gt. 0) then
              newclonend=1
              imc2=im
            end if
          else if (noclone .eq. 0) then
            newclonend=1
            imc2=im
          end if
          if (newclonend .eq. 1) then
            if (nmtmn(im) .le. nmtmx(im)) then
              call avstdev_n(rmsav,rms2av,nclones,rmsavg,rmssd)
              write (iout,1111) nmc,nclones,rmsavg,rmssd,rmsmin,rmsmax
            end if
          else if (noclone .eq. 1) then
            if (nmtmn(im) .le. nmtmx(im)) write (iout,1114) nmc,im,rr
          end if
          irtp=0
          do irt=1,nrootused
            iempty=1
            iaroot=iroots(im0-1+irt)
            if (newclonend .eq. 1) then
              if (rrimmax(irt) .gt. 0.0) then
                call avstdev_n(dble(rrimav(irt)),dble(r2imav(irt)),
     -            nclones,rrimavg,rrimsd)
                irtp=irtp+1
                if (iop(61) .eq. 0) then
                  iarootw=iaroot
                  igrw=igrslt(iaroot)
                else
                  iarootw=iorig_of_split(iaroot)
                  igrw=ir_split_orig(iarootw)
                end if
                write (iout,1113) irtp,iarootw,igrw,
     -            (labslt(k,iaroot),k=1,2),rrimavg,imc1,imc2,rrimsd,
     -            rrimmin(irt),rrimmax(irt)
                iempty=0
              end if
              noclone=1
            else if (noclone .eq. 1) then
              if (rrii(irt) .ge. 0.0) then
                irtp=irtp+1
                if (iop(61) .eq. 0) then
                  iarootw=iaroot
                  igrw=igrslt(iaroot)
                else
                  iarootw=iorig_of_split(iaroot)
                  igrw=ir_split_orig(iarootw)
                end if
                write (iout,1112) im,irtp,iarootw,igrw,
     -            (labslt(k,iaroot),k=1,2),rrii(irt)
                iempty=0
              end if
            end if
            if (iempty .eq. 0) then
c             Collect the torsions in this branch
              ita=im0+irt-1
              it=iabs(itorig(
     -          itorsfind(iroots(ita),ntang,iquata,inperr,iout,0)))
              indexx(1)=it
              nchain=1
              do iaa=1,nnexttorat(itangindx(it))
                ia=irotlist(irotlinc(it)+iaa)
                itt=itorsfind(ia,ntang,iquata,inperr,iout,1)
                if (itt .ne. 0) then
                  itt=abs(itorig(itt))
                  nchain=nchain+1
                  indexx(nchain)=itt
                end if
              end do
              nrow=10
              i1=1
              i2=min0(i1+nrow-1,nchain)
              nolf=1
              do while (i2 .ge. i1)
                if (nolf .eq. 0) write (iout,*)
                nolf=0
                do ii=i1,i2
                  if (looptyp(indexx(ii)) .eq. 0) then
                    looptyplab(ii-i1+1)='    '
                    cy3(indexx(ii))=0.0
                  else
                    write (looptyplab(ii-i1+1),1166)looptyp(indexx(ii))
                  end if
                end do
                if (iop(61) .eq. 0) then
                  write (iout,1115)
     -              ((iquata(indexx(ii),k),k=2,3),ii=i1,i2)
                else
                   write (iout,1115) ((iorig_of_split(iquata(indexx(ii),
     -               k)),k=2,3),ii=i1,i2)
                end if
                if (iop(24) .gt. 1)
     -            write (iout,2115) (indexx(ii),ii=i1,i2)
                if (iop(91) .gt. 0) then
                  write (iout,1123)
     -              (looptyplab(ii-i1+1),cx3(indexx(ii)),ii=i1,i2)
                  if (iop(24) .gt. 1 .or. istune(4) .gt. 0) then
                    istn=1
                    if (istune(4) .gt. 0) then
                      istn=2
                      write (iout,2117)(accsumloop(indexx(ii)),ii=i1,i2)
                      do ii=i1,i2
                        robd(ii-i1+1)=0.0
                        if (looptyp(indexx(ii)) .eq. 0) then
                          rowd(ii-i1+1)=0.0
                        else
cwww                      rowd(ii-i1+1)=stepsumloop(indexx(ii))
                          rowd(ii-i1+1)=stepsumloop(indexx(ii))*
     -                     (wstepsum1(4)/
     -                     (1.d0-wstepsum(4)**(l4(indexx(ii))+1)))
                          if (l4(indexx(ii)) .gt. 0) robd(ii-i1+1)=
     -                      stepsumloopcumu(indexx(ii))/l4(indexx(ii))
                        end if
                      end do
                      write (iout,1128) '(W aver)',
     -                  (rdtodg*rowd(ii),ii=1,i2-i1+1)
                      write (iout,1128) '(C aver)',
     -                  (rdtodg*robd(ii),ii=1,i2-i1+1)
                    end if
                    write (iout,1128) stunelab(istn),
     -                (cy3(indexx(ii)),ii=i1,i2)
                  end if
                  write (iout,1124) (cx2(indexx(ii)),ii=i1,i2)
                  write (iout,1127) (cx1(indexx(ii)),ii=i1,i2)
                  if (iop(24) .gt. 0)
     -              write (iout,1125) (l4(indexx(ii)),ii=i1,i2)
                  if (idebug(40) .gt. 1)
     -              write (iout,2125) (l3(indexx(ii)),ii=i1,i2)
                end if
                write (iout,1116) (abz(indexx(ii)),ii=i1,i2)
                if (iop(24) .gt. 1 .or. istune(3) .gt. 0) then
                  istn=1
                  if (istune(3) .gt. 0) then
                    istn=2
                    write (iout,2116) (accsumtor(indexx(ii)),ii=i1,i2)
                      do ii=i1,i2
                        if (looptyp(indexx(ii)) .gt. 0) then
                          rowd(ii-i1+1)=0.0
                          robd(ii-i1+1)=0.0
                        else
cwww                      rowd(ii-i1+1)=stepsumtor(indexx(ii))
                          rowd(ii-i1+1)=stepsumtor(indexx(ii))*
     -                     (wstepsum1(3)/
     -                     (1.d0-wstepsum(3)**(l2(indexx(ii))+1)))
                          if (l2(indexx(ii)) .gt. 0) robd(ii-i1+1)=
     -                      stepsumtorcumu(indexx(ii))/l2(indexx(ii))
                        end if
                      end do
                      write (iout,1118) '(W aver)',
     -                  (rdtodg*rowd(ii),ii=1,i2-i1+1)
                      write (iout,1118) '(C aver)',
     -                  (rdtodg*robd(ii),ii=1,i2-i1+1)
                  end if
                  write (iout,1118) stunelab(istn),
     -              (cv3(indexx(ii)),ii=i1,i2)
                end if
                write (iout,1121) (riijjv(indexx(ii)),ii=i1,i2)
                write (iout,1120) (aby(indexx(ii)),ii=i1,i2)
                if (iop(24) .gt. 1)
     -            write (iout,1122) (l2(indexx(ii)),ii=i1,i2)
                if (idebug(40) .gt. 1)
     -            write (iout,2122) (l1(indexx(ii)),ii=i1,i2)
                if (idebug(140) .gt. 0) then
                  write (iout,1184) (rdtodg*dihang(indexx(ii)),ii=i1,i2)
                  write (iout,1185) (torsen(indexx(ii)),ii=i1,i2)
                end if
                if (iop(24) .gt. 1)
     -            write (iout,1119) (abx(indexx(ii)),ii=i1,i2)
                write (iout,1126) (cvar(indexx(ii)),ii=i1,i2)
                write (iout,1117) (cv2(indexx(ii)),ii=i1,i2)
                i1=i2+1
                i2=min0(i1+nrow-1,nchain)
              end do
              write (iout,*)
            end if
          end do
          if (iop(180) .gt. 0) then
c           Torsion autocorrelation output
            nauclim=min0(#AU,ntorsaved)
            naucfitlim=min0(#AU,ntorsaved/2)
            ntaumax=naucfitlim
            call indexit(ixt,1,#AU,-1)
            do it=1,ntang
              do itt=1,nauclim
                if (nauc(itt) .gt. 0)
     -            aucsaved(itt)=auctor(itt,it)/float(nauc(itt))
              end do
              call gettorsnames(it,4,torsnames,labslt,ianslt,iatnam,
     -          0,ixt,iquata)
              write (iout,1192) it,(iquata(it,k),torsnames(k),k=1,4)
              write (label,1194) it
              call fitexp(tauc_timestep,naucfitlim,tauc_min,0,label,
     -          ihalf,tailavg,iout)
              intprint=max0(1,naucfitlim/ntaucprint)
              if (looptyp(it) .eq. 0) then
                looptyplab(it)='    '
              else
                write (looptyplab(it),1166) looptyp(it)
              end if
              write (iout,1195) label,looptyplab(it),abz(it),cx3(it),
     -          ntaufit,tailavg,ihalf
              write (iout,1193) (aucsaved(i),i=1,naucfitlim,intprint)
            end do
          end if
        end do
        if (iop(91) .gt. 0) then
c         Calculate overall torsional RMS for loop root atoms only
          dmxloopats=0.0
          dmxfloopats=0.0
          rmsloopats=0.0
          rmsfloopats=0.0
          nloop=0
          nfloop=0
          do it=1,ntang
            lra=iquata(it,4)
            dlra=arrdist(c(1,lra),cgs(1,lra))
            if (looptyp(it) .gt. 0) then
              rmsloopats=rmsloopats+dlra
              if (dlra .gt. dmxloopats) dmxloopats=dlra
              nloop=nloop+1
            end if
            if (loopmem(it) .gt. 0) then
              rmsfloopats=rmsfloopats+dlra
              if (dlra .gt. dmxfloopats) dmxfloopats=dlra
              nfloop=nfloop+1
            end if
          end do
          if (nloop .gt. 0) write (iout,1156) nmc,'loop-move root',
     -      sqrt(rmsloopats),sqrt(rmsloopats)/nloop,sqrt(dmxloopats)
          if (nfloop .gt. 0)
     -      write (iout,1156) nmc,'flexible loop member',
     -      sqrt(rmsfloopats),sqrt(rmsfloopats)/nfloop,sqrt(dmxfloopats)
        end if
      end if
      if (iop(96) .eq. 0 .and. numsolv .gt. 0) then
C@FRc-------Compute quantum correction
C@FR        write (iout,2000) 'QUANTUM CORRECTION'
C@FR        if (nsslt .eq. 0) nsslt=1
C@FR        if (wpsmvi .eq. 0.d0) wpsmvi=1.d0
C@FR        fsmslv=fsmslv/wpsmvi
C@FR        fsmslt=fsmslt/dfloat(nsslt)
C@FR        if (iop(41) .ne. 0) write (iout,8000)
C@FR        do k=1,3
C@FR          tsmslt(k)=tsmslt(k)/dfloat(nsslt)
C@FR          tsmslv(k)=tsmslv(k)/wpsmvi
C@FR         end do
C@FR        call qcorre(wmslt,rinslt,iclslt,rlcslt,nstta,fsmslt,tsmslt,
C@FR     -    qcrslt,0)
C@FR        call qcorre(wmslv,rinslv,ianslv,rlcslv,nslv,fsmslv,tsmslv,
C@FR     -    qcrslv,1)
C@FR        write (iout,1003) fsmslt,fsmslv,wmslt,wmslv,tsmslt,tsmslv,
C@FR     -    rinslt,rinslv,qcrslt,qcrslv
      end if
      if (iop(4) .lt. 1 .and. iop(111).eq. 0) go to 9999
      write (iout,2000) 'DISTRIBUTION FUNCTION'
      if (iop(111) .gt. 0)
     -  call disfin_dipoledist(gdipc,dndipmom,nmc,numrun,rdtodg,
     -  iop(24),inperr,iout)
      if (iop(32) .eq. 1) then
        nskp=(nmc-1)/nplt
        rewind idstr
        if (nskp .gt. 0) then
          do k=1,nskp
            read (idstr,end=110)
          end do
          go to 100
110       kk=k-1
          write (iout,1001) kk,nskp
          nwarn=nwarn+1
          rewind idstr
          do k=1,kk
            read (idstr)
          end do
        end if
      end if
c-----Prepare the radial gridpoint coordinates(gr) and volume
c     elements (gdvslt and gdvslv).
100   if (iop(41) .eq. 0) rnav=nmolec-1
      solden=rnav/vol
      if (iop(92) .gt. 0) solden=denphs/(wmslv*wmmltona3)
      gr(1)=0.0
      do i=2,nd
        gr(i)=gr(i-1)+ri
      end do
      dv=4.0*pi*ri*solden
      do i=1,nd
        gdvslv(i)=gr(i)**2*dv
        gdvslt(i)=gdvslv(i)
      end do
      if (iop(2) .eq. 1) then
c       For linear periodic solute volume element has cylindrical symm.
        dv=pi2*edgexyz(1)*ri*solden
        do i=1,nd
          gdvslt(i)=gr(i)*dv
        end do
      end if
c-----Prepare the radial distribution functions
      gww(1)=0.0
      gslt(1)=0.0
      if (dngwws .eq. 0.d0) dngwws=1.d0
      rkslt(1)=dnrslt(1)/nt
      rkslv(1)=dnrww(1)/dngwws
      rnw=dngwws/dnt
      do i=2,nd
        gslt(i)=dnrslt(i)/(gdvslt(i)*nt)
        gww(i)=dnrww(i)/(gdvslv(i)*dngwws)
        rkslt(i)=rkslt(i-1)+dnrslt(i)/nt
        rkslv(i)=rkslt(i-1)+dnrww(i)/dngwws
      end do
c-----Prepare the binding energy distributions
      dnbslvs=0
      do i=1,100
        dnbslvs=dnbslvs+dnesmww(i)
      end do
      if (dnbslvs .eq. 0.d0) dnbslvs=1.d0
      do i=1,100
        gesslt(i)=dnesslt(i)/float(nt)
        gesslv(i)=dnesmww(i)/dnbslvs
      end do
      write (iout,1019) rssmin,rssmax,rnw
      if (iop(1) .lt. 2) then
        write (iout,1007) (gr(i),i=1,nd)
        write (iout,1008) 'Solute',ri,(gslt(i),i=1,nd)
        call gmax('Solute',gslt,gr,nd-1,iout)
        write (iout,1008) 'Solvent',ri,(gww(i),i=1,nd)
        call gmax('Solvent',gww,gr,nd-1,iout)
        write (iout,1196) 'Solute',ri,(rkslt(i),i=1,nd)
        write (iout,1196) 'Solvent',ri,(rkslv(i),i=1,nd)
      else if (iop(1) .gt. 2) then
        write (iout,1142)(gr(i),gslt(i),gww(i),rkslt(i),rkslv(i),i=1,nd)
      end if
      if (iop(4) .ge. 1) then
        do i=2,nd
          im=i
          if (dnrww(i) .gt. 0.d0) go to 132
        end do
132     write (iout,1026) gr(im)
      end if
      if (iop(1) .le. 1 .or. iop(1) .ge. 3) then
        corslv=corn(dkcrslv,gcrslv,20,0)
        write (iout,1005) 'Solvent',corslv,rfsslv,gcrslv
        if (ncor1ok .eq. 1) then
          corslt=corn(dkcrslt,gcrslt,30,ksltmn)
          write (iout,1005) 'Solute',corslt,rfsslt,gcrslt
          if (ksltmn .ne. 0) write (iout,1004) ksltmn
        end if
        if (iop(1) .eq. 0) then
          write (iout,1013) 'Solute',empslt,egrslt,gesslt
          call glims(empslt,egrslt,49,gesslt,100,0.001,iout,' ')
          write (iout,1013) 'Solvent',empslv,egrslv,gesslv
          call glims(empslv,egrslv,49,gesslv,100,0.001,iout,' ')
        else if (iop(1) .eq. 3) then
          do ig=1,100
            esslt(ig)=empslt+egrslt/2.0+(ig-51)*egrslt
            esslv(ig)=empslv+egrslv/2.0+(ig-51)*egrslv
          end do
          write (iout,1143) (esslt(ig),gesslt(ig),esslv(ig),gesslv(ig),
     -      ig=1,100)
          call glims(empslt,egrslt,49,gesslt,100,0.001,iout,
     -      ' solute-solvent binding energy ')
          call glims(empslv,egrslv,49,gesslv,100,0.001,iout,
     -      ' solvent-solvent binding energy ')
        end if
      end if
      if (iop(4) .eq. 2) then
c-------Prepare the pair-property distributions
        dnpslts=0.d0
        dnpslvs=0.d0
        do i=1,100
          dnpslts=dnpslts+dnsltpe(i)
          dnpslvs=dnpslvs+dnslvpe(i)
        end do
        if (dnpslts .eq. 0.d0) dnpslts=1.d0
        if (dnpslvs .eq. 0.d0) dnpslvs=1.d0
        do i=1,100
          gpeslt(i)=dnsltpe(i)/dnpslts
          gpeslv(i)=dnslvpe(i)/dnpslvs
        end do
        do i=1,180
          gdipc(i)=dndipc(i)/dnpslvs
        end do
        if (iop(1) .eq. 0) then
          write (iout,1015) dmnslt,dmxslt,emnslt,egpslt,gpeslt
          call glims(emnslt,egpslt,0,gpeslt,100,0.001,iout,' ')
          write (iout,1010) rssmin,rssmax,dmnslv,dmxslv
          write (iout,1183) emnslv,egpslv,gpeslv
          call glims(emnslv,egpslv,0,gpeslv,100,0.001,iout,' ')
          write (iout,1011) gdipc
          call glims(0.0,1.0,0,gdipc,180,0.001,iout,' ')
        else if (iop(1) .eq. 3) then
          do ig=1,100
            esslt(ig)=emnslt+egpslt/2.0+(ig-1)*egpslt
            esslv(ig)=emnslv+egpslv/2.0+(ig-1)*egpslv
          end do
          write (iout,1010) rssmin,rssmax,dmnslv,dmxslv
          write (iout,1144)
     -      (esslt(ig),gpeslt(ig),esslv(ig),gpeslv(ig),ig=1,100)
          call glims(emnslt,egpslt,0,gpeslt,100,0.001,iout,
     -      ' solute-solvent near-neighbor pair energy ')
          call glims(emnslv,egpslv,0,gpeslv,100,0.001,iout,
     -      ' solvent-solvent near-neighbor pair energy ')
          write (iout,1145) (ig,gdipc(ig),ig=1,180)
          call glims(0.0,1.0,0,gdipc,180,0.001,iout,' ')
        end if
        if (epijct .gt. 0.d0) write (iout,1014) epijsum/epijct
      end if
      if (iop(32) .eq. 1)
     -  write (idstr) nd,iop(4),nt,ident,dngwws,dnbslvs,dnpslts,
     -  dnpslvs,ksltmn,gr,gdvslv,gdvslt,gww,gslt,gcrslv,gcrslt,
     -  gesslv,egrslv,empslv,gesslt,empslt,egrslt,gpeslt,emnslt,egpslt,
     -  gpeslv,emnslv,egpslv,gdipc,rnav
c-----Sensitivity coefficient output
        if (iop(82) .gt. 0) call dvpsltfin
9999  continue
C@DM        call MPI_BARRIER(MPI_COMM_WORLD,ierr)
      return
1000  format(/,' The total displacement of the solvent system=',f12.6,
     -  ' A',/,' The average solvent displacement square=',f12.6,
     -  ' A**2', /,' The average total solvent displacement=',f12.6,
     -  ' A SD=',f12.6,' A',/,
     -  ' The minimum and maximum total solvent displacements=',
     -  2f12.6,' A',//,' Average translational correlation between ',
     -  'successive solvent moves=',f10.5,/,
     -  ' The acceptance-rate * average displacement**2=',f12.6,
     -  ' A**2',/,' The average displacement * sqrt(acceptance rate) *',
     -  ' (1.0 + average correlation between moves)=',f12.6,' A',/)
1001  format(' ----- WARNING: only',i4,' records were found ',
     -  ' instead of',i4)
C@FR1002  format(' Pressure=',e15.6,' atm  Virial sum=',e15.6,' kcal/mol/A',
C@FR     -  ' Solute virial sum=',e15.6,' kcal/mol/A ',/,' Virial sum ',
C@FR     -  'components=',3e15.6,/,' Solute virial sum components:',3e15.6)
C@FR1003  format(' Quantum corr: solute, solvent <F**2>=',2e11.4,'     ',/
C@FR     -  14x,' Solute, solvent mass=',2f10.4,' a.m.u.',/,
C@FR     -  14x,' Solute, solvent <T(i)**2>=',9x,2(3x,3e11.4),'     ',/,14x,
C@FR     -  ' Solute, solvent moments of inertia=',2(3x,3e11.4),'     ',/,
C@FR     -  14x,' Solute, solvent intermolecular quantum correction=',
C@FR     -  2e11.4,' kcal/mol')
1004  format(' Solute coordination number list starts at K=',i2)
1005  format(/,1x,a,' coordination number=',f10.5,
     -  ' Shell radius=',f6.3,' A distribution=',/,(10f9.5))
1006  format(' Constant volume excess heat capacity=',f8.2,
     -  ' cal/mol/deg')
1007  format(/,' Radial distribution function gridpoints=',/,
     -  30(15f8.4,/))
1008  format(/,1x,a,'-solvent radial distribution function ',
     -  '(gridsize=',f6.3,' A)=',/,30(15f8.4,/))
1009  format(/,' Total energy average=',f15.6,10x,'kcal/mol',/,
     -  ' Average enthalpy=',e12.5,' kcal/mol SD=',e12.5,' kcal/mol',
     -  /,' Constant pressure excess heat capacity=',f12.6,
     -  ' cal/mol/deg',/,' Thermal expansion coefficient = ',e12.5,
     -  ' 1/K')
1010  format(/,' The solvent near-neighbour pair-energy distribution',/,
     -  ' Solute-solvent distance range',2f8.4,' A ',/,
     -  ' Solvent-solvent distance range',2f8.4,' A')
1011  format(/,' The solvent near-neighbour dipole correlation ',
     -  'distribution=',/,(1x,20f6.3))
1012  format(' The solute has been perturbed',i7,' times',
     -  ' moved',i7,' times')
1013  format(/,1x,a,' binding energy distribution  (midpoint=',f9.3,
     -  ' grid size=',f8.5,' kcal/mol)=',/,(1x,20f6.3))
1014  format(/,' The solvent near-neighbour pair-energy average=',f12.5)
1015  format(/,' The solute near-neighbour pair-energy distribution ',
     -  'in the range',2f8.4,' A',/,
     -  '   (minimum=',f8.4,' grid size=',f8.4,' kcal/mol)=',/,
     -  (1x,20f6.3))
1016  format(' Number of force-cuts applied=',i8,' accepted=',i8)
C@NN1017  format(' The number of neighbour-table updates=',i8)
1018  format(' Overall solute displacement=',f6.1,' A')
1019  format(' Solvent-solvent distributions are computed only in',
     -  ' a shell around the solute of radii ',2(f12.5,' A'),/,
     -  ' Average number of waters contributing to water-water ',
     -  ' distributions=',f8.2)
1020  format(' Minimum and maximum orientational correlations',
     -  ' for solvent molecules between start and end=',2f8.5,
     -  ' (',2f8.2,' deg)',/,
     -  ' Average solvent orientational correlation between start and',
     -  ' end=',f10.5,' +/- ',f10.5,' (',f8.2,' deg)')
1021  format(/,' Acceptance rate for moved solvent molecules ',/,
     -        (1x,20f6.2))
1022  format(/,' Perturbation rate for moved solvent molecules',/
     -        ' Perturbation rate=nmolec* probability of a molecule',
     -        ' being selected for perturbation '/,
     -        (1x,20f6.2))
1023  format(' Minimum and maximum orientational correlations',
     -  ' for solute molecules between start and end (',a1,' axis',')=',
     -  2f8.5,/,' Average orientational correlation between start and ',
     -  'end (',a1,' axis',')=',f10.5,' +/- ',f10.5,' (',f9.3,' deg)')
1024  format(" A'(",f8.5,")-A'(",f8.5,")=",a1,"kT*ln <E(",f8.5,")-E(",
     -  f8.5,")>=",e12.6," kcal/mol")
1025  format(' The number of crossing',a,' into and out of the grid ',
     -  'region=',2i8)
1026  format(' The closest solvent-solvent distance found=',f6.2,' A')
1027  format(' The smallest, largest and mean solvent acceptance ',
     -  'rates=',3f10.5)
1028  format(/,' <E(st-sv)0>=',e12.5,' <E(st-st)0>=',e12.5,
     -  ' <E(st-sv)1>=',e12.5,' <E(st-st)1>=',e12.5,' kcal/mol')
1029  format(' <E(cplpar=',f5.3,')> (in the cplpar=',f5.3,' ensemble)=',
     -  f12.6,' kcal/mol (for consistency check)')
1030  format(' The average translational and rotational displacements',
     -  ' per ',a,' step=',
     -  f12.6,' A ; ',f10.5,' degrees')
1031  format(' The TI integrand for coupling parameter =',f8.5,
     -  ' exponents=',3(f5.2,2x),' at Nmc=',i10,' is ',e12.6)
1032  format(' The smallest and largest solvent perturbation rates=',
     -  2f10.5)
1033  format(' The exponential averages for the two segements=',2e14.6,/
     -  ' The energy difference at the initial configuration=',f12.6,
     -  ' kcal/mol')
1034  format(' ----- WARNING: above listed',i6,' solvent molecules ',
     -  'were not moved in more than',i4,' successive trys')
1035  format(' Minimum and maximum of (E1-E0)=',2(f12.5,
     -  ' (at Nmc=',i10,')'),' kcal/mol',/,
     -  ' ///// NOTE: if the (E1-E0) range is larger than a ',
     -  'few kcal/mol, the PM result is unreliable')
1036  format(" A'(",f8.5,")-A'(",f8.5,")=A'(",f8.5,")-A'(",f8.5,")+",
     -  "A'(",f8.5,")-A'(",f8.5,")=",e12.5)
1037  format(' List of solvents with less than',i3,'% acceptance rate',
     -  ' ----- (',i5,'):')
1038  format(' Solvent',i5,' Perturbation/acceptance rate=',f7.2,f5.2)
1039  format(' Nearest solute atom:',i5,1x,a4,' at',f7.2,' A ',
     -  ' slt-slv e=',f10.2,' kcal/mol')
1040  format(' The TI integrand for coupling parameter =',f8.5,
     -  ' from solvent contributions only is ',e12.6)
1041  format(/,' Total energy average=',f20.5,' kcal/mol',/,
     -  ' Standard deviation =',f20.5,'  Range=',f10.3,' kcal/mol')
1042  format(/,' Constant volume excess heat capacity=',e12.5,
     -  ' cal/mol deg',/,' Isothermal compressibility (using input',
     -  ' solute volume) =',f10.5,' atm**(-1)',/,
     -  ' Isothermal compressibility (using estimated',
     -  ' solute volume) =',f10.5,' atm**(-1)',/,
     -  ' Expansivity-p*beta/kT=',f10.5,' deg**(-1)')
1043  format(/,' <U,U>=',e12.5,' <N,N>=',e12.5,' <U,N>=',e12.5)
1044  format(' Solvent density from input estimate of solute volume=',
     -  e15.6,' molecs/A**3',f10.6,' g/ml',
     -  ' (input solute volume=',f10.2,' A**3)',/
     -  ' Excess chemical potential=',e15.6)
1045  format(' The number of insertion and deletion attempts=',2i10)
1046  format(/,' Number of random insertion attempts=',i8,/,
     -  ' Probability of random insertion=',f10.5)
1047  format(/,' The number of insertions=',i101,
     -  ' the number of deletions=',i10,/,
     -  6x,' The number of times the last molecule was deleted=',i7)
1048  format(/,' Estimated probabilities of random insertion='/(15f8.5))
1049  format(/,' nocavf=',/,(15i8))
1050  format(/,' ninstr=',/,(15i8))
1051  format(' i/d:',i2,' is=',i5,' nmolec=',i5,' nmc=',i10,
     -  ' cpl=',f8.5,' c=',3f9.3,a,' ia(px)=',i6,' r(px)=',f8.2)
1052  format(' Average lifetime of a solvent molecule before deletion=',
     -  f10.1)
1053  format(' Average lifetime of a solvent molecule before deletion=',
     -  f10.1,' (not counting immediately deleted ones)')
1054  format(' Number of solvent molecules that were never deleted=',i5)
1055  format(' MC stepnumbers where the molecules were created=',/,
     -  (1x,12i10))
1056  format(' Solute-solvent energy=',f16.4,' SD=',f13.4,' kcal/mol')
1057  format(' Changes due to solute flexibility are included only',
     -  ' after a solvent or the whole solute moved')
1058  format(' No random insertions were needed')
1059  format(' Number of records on the I/D log file=',i10)
1060  format(' Average of the binding energies of the molecules never',
     -  ' deleted=',f10.4,'  Minimum and maximum=',2f12.4,' kcal/mol')
c??   Labels 1061-1066 are not used
c1061  format(' Electrostatic intramolecular contribution at ',
c     -  ' cplpar=',f6.4,' is ',e12.5,' at cplpar=',f6.4,' is ',e12.5,/,
c     -  43x,' Difference=',e12.5,' kcal/mol')
c1062  format(' Electrostatic intramolecular contribution at ',
c     -  ' cplpar=',f6.4,' is ',e12.5,' kcal/mol')
c1063  format(' Lennard-Jones intramolecular contribution at ',
c     -  ' cplpar=',f6.4,' is ',e12.5,' at cplpar=',f6.4,' is ',e12.5,/,
c     -  43x,' Difference=',e12.5,' kcal/mol')
c1064  format(' Lennard-Jones intramolecular contribution at ',
c     -  ' cplpar=',f6.4,' is ',e12.5,' kcal/mol')
c1065  format(' Free energy difference updated with intramolecular',
c     - ' electrostatic contribution=',e12.5,' kcal/mol')
c1066  format(' Free energy difference updated with intramolecular',
c     - ' Lennard-Jones contribution=',e12.5,' kcal/mol')
1067  format(' The shortest ion-water distance rejected=',f6.2,' A')
1068  format(' Acceptance rates over the solvent stepsize range:',
     -  /(1x,20f6.2))
1069  format(' Maximum solvent acceptance rate=',f6.3,' at stepsize ',
     -  f4.2,' max/2 at ',f4.2,' max/3 at ',f4.2,' max/5 at ',f4.2,/,
     -  ' Maximum of Pacc*|r| at |r|=',f6.3,
     -  ' Maximum of Pacc*|r|**2 at |r|=',f6.3)
1070  format(' Correlations between successive steps over the solvent',
     -  '  stepsize range:',/(1x,20f6.2))
1071  format(' Solvent stepsize selection probabilities:',/,
     -  (1x,20(1x,f5.4)))
1072  format(' Solute-solvent energy with inscribed sphere cutoff=',
     -  f15.4,' SD=',f10.2,' kcal/mol Correlation coefficient=',f10.5,/,
     -  ' Solute solvent energy with inscribed sphere cutoff',
     -  ' reweighted average=',f15.4,' kcal/mol')
1073  format(' Individual cumulative contributions to the TI',
     -  ' integrand:',/,17x,
     -  '  st-sv,1/r^12   st-sv,1/r^6     st-sv,1/r   ',
     -  '  st-st,1/r^12   st-st,1/r^6     st-st,1/r   ')
1074  format(' Lambda=',f5.3,' :',6f15.6,' kcal/mol')
1075  format(' A PDB file with the unmoved solvents and the solute ',
     -  'has been writen to file',/,5x,a,/,
     -  5x,'Set PRNT NECH or PRNT ECHO to avoid writing this file')
1076  format(' Solute-solvent energy contributions:',e12.5,
     -  ' (1/r**12) ',e12.5,' (1/r**6) ',e12.5,' (1/r)  kcal/mol')
1077  format(' Solvent ',i6,' c=',3f6.1,' Eb=',f15.3,' E(slt-slv/',
     -  '12-6-1)=',f13.1,2f10.1,' (',i6,' successive rejections)')
1078  format(' Solvent density from grid estimate of solute',
     -  ' volume=',e12.5,' molecs/A**3',f8.4,' g/ml',
     -  ' (estimated solute volume=',f8.1,' A**3)')
1079  format(' Coupling parameter change acceptance rate=',f8.5,
     -  ' Number of attempts=',i8)
1080  format(/,' Average absolute solute molecule displacements in the',
     -  ' x, y, z directions (per step)=',3f11.6,' A',/,
     -  ' Average total absolute solute molecule displacement=',f11.6,
     -  ' SD=',f11.6,' A',/,
     -  ' Solute selection is ',a15,25x,
     -  ' Displacement stepsizes=',3f9.4,' A')
1081  format(' Testing for solvents not moved in ',i4,' successive ',
     -  'trys - this would normally occur with probability ',
     -  '1/(',i3,'*nmolec)=',f8.6)
1082  format(' Average volume change=',f8.2,' A^3 minimum and maximum ',
     -  'volumes=',2f10.2,' A^3')
1083  format(' Mean cell edge in the X direction=',f10.5,' A',/
     -  ' Mean area in the Y-Z plane=',f12.5,' A^2')
1084  format(' Solute ',a5,'molecular NB energy contribution from ',
     -  'groups with moving atoms=',e12.5,' SD=',e12.5,' kcal/mol')
1085  format(' Number of trials:',/,(15i8))
1086  format(' Total solute 1-4 energy=',
     -  e12.5,' SD=',e12.5,' kcal/mol',/,
     -  ' Total torsion energy=',e12.5,' SD=',e12.5,' kcal/mol')
1087  format(' Torsion ',i5,' (Res',i5,1x,a4,' Atom',i6,1x,a4,' - ',
     -  ' Res',i5,1x,a4,' Atom',i5,1x,a4,')',1x,a1,' Av?=',f6.1,
     -  ' SD=',f6.1,' C av=',f6.1,' deg  C-var=',f6.4)
1088  format(' cplpar=',f6.3,'  <Etot>=',f16.6,'  <Eslt-slv>=',f12.6,
     -  '  <Eslt(intra)>=',f12.3,' kcal/mol')
1089  format(' Solute-solvent group energy averages (kcal/mol)=',/,
     -  (7(i5,e13.5)))
1090  format(' Root mean square displacement of solute molecular ',
     -  'centers=',f9.3,' A Minimum:',f9.3,' Maximum:',f9.3,/,
     -  ' Individual solute molecule center displacements (A)=',/,
     -  (15f8.2))
1091  format(' Stepsize statistics for axis',i2)
1092  format(' Acceptance rates per ',a,' (in uniform bins from 0 to',
     -  f9.4,' deg):')
1093  format(' Solute field energy=',e12.5,' SD=',e12.5,' kcal/mol',/,
     -  ' Solvent field energy=',e12.5,' SD=',e12.5,' kcal/mol')
1094  format(' Solute molecule-dependent energy=',e12.5,' SD=',
     -  e12.5,' kcal/mol')
1095  format(' Umbrella Sampling correction factor (if any) average=',
     -  e12.5)
1096  format(' Molecule',i4,' <e14>=',f10.3,' SD=',f7.2,
     -  ' <Enb-intra>=',e12.5,' SD=',f8.2,' <E-inter>=',e12.5,
     -  ' SD=',f8.2,' kcal/mol')
1097  format(' Lambda=',f5.2,' :',4f15.5)
1098  format(' E(intra)1-E(intra)0=',e15.6)
1099  format(' Intramolecular energies of the free energy solutes:',/,
     - 21x,'Non bonded        1-4           Torsion         Total')
1100  format(' Torsion angle differences between the initial and final',
     -  ' configurations (degrees):',/,(15f8.3))
1101  format(' Average torsion angle differences between initial and ',
     -  'final configurations (degrees):',/,6(i4,f7.2,'+/-',f6.2))
1102  format((1x,20(1x,f5.3)))
1103  format(/' Average volume=',e12.5,' SD=',e12.5,' A**3 Density=',
     -  f8.5,' g/ml',/,' Isothermal compressibility = ',e12.5,' 1/atm')
1104  format(' Volume change acceptance rate=',f7.3,
     -  ' Number of attempts=',i7)
1105  format(' Averages over',i5,' clones (',i5,' - ',i5,'):',/,
     -  14x,'<e14>=',f10.3,' SD=',f7.2,' <Enb-intra>=',e12.5,
     -  ' SD=',f8.2,' <E-inter>=',e12.5,' SD=',f8.2,' kcal/mol')
1106  format(' Absolute edge length changes=',3f8.4)
1107  format(' dVx=',f10.5,' dVy=',f10.5,' dVz=',f10.5)
1108  format(' dVx=',f10.5,' dVy + dVz =',f10.5)
1109  format(' (dVx + dVy + dVz)',a,'=',f10.5)
1110  format(' Average edgelengths:',
     -  (/,' edge ',a1,'= ',f9.5,' A  SD=',f9.5,' A'))
1111  format(/,' Nmc=',i10,' RMS mean torsional displacements over',i4,
     -  ' solute molecules=',f6.2,' +/-',f8.4,' Minimum:',f8.4,
     -  ' Maximum:',f8.4)
1112  format(/,20x,'RMS total torsional displacement for solute ',
     -  'molecule',i5,' branch',i4,' on atom',i6,' residue',i5,
     -  ' (',2a4,')=',f6.2)
1113  format(/,' RMS total torsional displacements for solute ',
     -  'branch',i3,' on atom',i5,' residue ',i4,' (',2a4,')=',f6.2,/,
     -  5x,'(average over cloned solute molecules ',i4,' - ',i4,')',
     -  ' SD=',f8.3,' Minimum:',f8.3,' Maximum:',f8.3)
1114  format(/,' Nmc=',i10,' RMS torsional displacement of the solute ',
     -  'molecule',i4,'=',f8.3)
1115  format(' Torsion bond:            ',10(1x,i4,'-',i4))
2115  format(' Torsion number:          ',10(i10))
1116  format(' Torsion acceptance rate: ',10(5x,f5.3))
2116  format(' Tuning torsion acceptnce:',10(5x,f5.3))
2117  format(' Tuning loop acceptance:  ',10(5x,f5.3))
1117  format(' Total change:            ',10(f10.3))
1118  format(' Torsion stepsize',a,':',10(f10.3))
1119  format(' Selection weight:        ',10(f10.4))
1120  format(' Average torsion step:    ',10(f10.3))
1121  format(' Maximum torsion step:    ',10(f10.3))
1122  format(' Number of torsion trys:  ',10(i10))
2122  format(' Number of torsion accs:  ',10(i10))
1123  format(' Loop acceptance rate:    ',10(a4,1x,f5.3))
1124  format(' Maximum loop step:       ',10(f10.3))
2125  format(' Number of loop acs:      ',10(i10))
1125  format(' Number of loop trys:     ',10(i10))
1126  format(' Circular variance:       ',10(5x,f5.3))
1127  format(' Average loop step:       ',10(f10.3))
1128  format(' Loop stepsize   ',a,':',10(f10.3))
1131  format(' Average solute steps:',/,10(f10.3))
1132  format(' Selection of torsion groups within a molecules is ',a15)
1133  format(' Total (translational+rotational) RMS displacements ',
     -  'averaged over solute molecules',
     -  i4,'-',i4,'=',f6.2,' +/-',f5.2,' Min,max=',f6.2,f7.2)
1134  format(' Total (translational+rotational) RMS displacements of ',
     -  'solute molecule ',i4,'=',f6.2,' A')
1135  format(' Reference coupling parameter value in terms of the ',a11,
     -  ' states=',f8.5)
1136  format(' NOTE: I/D log file was damaged on restart')
1137  format(' Torsion ',i5,' Grid occupancy range: [',
     -  f8.6,',',f9.6,'];',i4,' grids sampled; Max:',a,1x,
     -  a,' distribution:',/,(6x,15f8.5))
1138  format(1x,a,' B parameter=',f12.4,a,
     -  'Number of consecutive convergent iterations=',i3)
1139  format(' Density outside the inner rectangle during the last ',
     -  'completed tuning iteration=',f10.5,' g/ml')
1140  format(' Fraction of outright rejections (no solutions for loop',
     -  ' closing)=',f6.4,/,
     -  ' Fraction of reverse proximity rejections=',f6.4,/,
     -  ' Number of loop closure calculations=',i9,/,
     -  '   Average number of scan steps=',f6.1,/,
     -  '   Average number of solutions=',f7.3,/,
     -  '   Number of loop closing failures=',i9)
1141  format(' Distribution of the torsion angles sampled in the -180',
     - '  -  +180 degree interval with ',i3,' degree grids'/,' C avg: ',
     -  'arc[<sin(phi)>;<cos(phi>]; C-var=<sin(phi)>^2+<cos(phi>^2',
     -  ' Mean and SD are calculated w/o circular arithmetics ')
1142  format(/,'    r    gslt(r)   gslv(r)  rkslt(r)  rkslv(r)  ',/,
     -  (f6.2,2f10.5,2f10.3))
1143  format(/,' Binding  energy distributions:',/,
     -  '    e(slt)    P[e(slt)]    e(slv)   P[e(slv)]',/,
     -  (f10.3,f12.5,f10.3,f12.5))
1144  format(' e(slt)    P[e(slt)]    e(slv)    P[e(slv)]'/
     -  (f10.3,f12.5,f10.3,f12.5))
1145  format(/,' Near-neighbor dipole correlation function',/,
     -  '   angle    P(angle)',/,(i8,f12.5))
1146  format(' Average shell radius=',f8.3,' +/-',f6.3,' A',/,
     -  ' Average number of solvents in the restraining shell=',f8.3,
     -  ' +/-',f6.3,/,
     -  ' Average total shell restraining energy=',e12.4,' +/-',e12.4,
     -  ' average total shell restraining force=',e12.4,' kcal/mol/A')
1147  format(1x,a,'orsion stepsizes read for solute copy',i2,
     -  ' were multiplied by=',3f10.5)
1148  format(' Smallest and largest non-Boltzmann weight=',2e14.5)
1149  format(' Torsion ',i5,' Boltzmann weighted distribution:',/,
     -  (6x,15f8.5))
1150  format(' Number of loop-closure trys with ',a,'=',i9,
     -  '   Number of times it improved the solution=',2i9)
1151  format(/,' Loop type ',a,' (',i3,')',a,
     -  ' loop-closure strategy: ',a)
1152  format(' Number of ',a,' loop-closure trys=',i9)
1153  format(' Averege energy of shell solvents=',e12.4,' kcal/mol ',
     -  'average solvent-solvent energy of shell solvents=',e12.4,
     -  ' kcal/mol')
1154  format(' ------ WARNING: No loop moves were attempted')
1155  format(' Number of times the nearest and non-nearest solutions ',
     -  'were picked:',2i8,' their acceptance rates=',2f8.4,/)
1156  format(' Nmc=',i10,' Total RMS of ',a,' atoms=',f10.4,
     -  ' A  RMS/atom=',f8.4,' A  Largest displacement=',f8.4,' A')
1157  format(' Minimum and maximum number of neighbors found for ',
     -  'r2scut=',f5.2,' : ',2i4)
1158  format(/,' The smallest and the greatest number of solvent ',
     -  'molecules sampled=',2i6,/,' The number distribution=',/,(8i10))
1159  format(' Acceptance rate for ',a,' displacement ',
     -  '(w/o rotation)=',f6.3,' for rotation (w/o displacement)=',f6.3)
1160  format(' From Nmc=',i10,' to Nmc=',i10,' <N,N>=',e12.5,
     -  5x,'(rn,rnn,wsum=',3e18.10,')',/,
     -  ' NOTE: Del N / Del B = <N,N>')
1161  format(' Number of full round-off error eliminations=',i8)
1162  format(' Number of geometry improvement trys=',i8,' failures=',i5)
1163  format(' Number of singular Jacobians encountered=',i8)
1164  format(' Number of iterations in the reverse direction=',i8,
     -  ' Number of solution failures= ',i8)
1165  format(' Number of times the reverse direction iteration ',
     -  'improved the solution=',i8)
1166  format(' LP',i1)
1167  format(' Number of local torsion (loop) move attempts=',i9)
1168  format(' Relative frequencies of ',a,' move=',f8.4)
1169  format(' Average absolute solute molecule rotations around the ',
     -  'x, y, z axes (per step)=',6x,3f9.4,' deg',/,' Rotation is ',
     -  'uniformly sampled',32x,'Stepsizes',a,'=',3f9.4,' deg')
1170  format(' Average absolute solute molecule rotations around the ',
     -  'x, y, z axes (per step)=',6x,3f9.4,' deg',/,' Rotation is ',
     -  'extension biased with ',a36,3x,' stepsizes',a,'=',3f9.4)
1171  format(' Torsion angles are sampled uniformly ')
1172  format(' Torsion angles are sampled with extension bias,',
     -  ' based on ',a36)
1173  format(' Tuned B parameter=',f9.4,' Final dBETA/dT=',f10.5)
1174  format(' Average B parameter=',f9.4)
1175  format(' Number of virtual volume changes=',i6)
1176  format(' Average virtual energy change=',e12.5,' S.D.=',e10.3,/,
     -  ' ln <exp(-DU/kT)> = ',e12.5)
1177  format(' Virtual ',a,' change=',e12.5)
1178  format(' Virtual energy change range: [',e12.5,',',e12.5,
     -  '] kcal/mol')
1179  format(' Estimated pressure=',f10.4,' atm')
1180  format(' Selection of solute molecules for torsion sampling is ',
     -  a15)
1181  format(' Number of rotation trials around the x, y, z axes:',3i11,
     -  10x,' Acceptance rates=',3f4.2)
1182  format(' Solute molecule ',i4,1x,a,
     -  ' stepsizes averaged with weight ',f8.6,'=',3f10.5,/,
     -  22x,'Acceptance rate averaged with w=',f8.6,': ',3f8.5)
1183  format(' (minimum=',f8.4,' Grid size=',f8.4,' kcal/mol)',/,
     -  (1x,20f6.3))
1184  format(' Current angle:           ',10(f10.3))
1185  format(' Torsion energy:          ',10(f10.3))
1186  format(' Number of crossing to neighboring cells in the current ',
     -  'run:',/,(10i7))
1187  format(' Solute atom ',i6,' (',a,1x,a,') vicinity: number of ',
     -  'insertions=',i5,' number of deletions=',i5)
1188  format(' Cumulative ',a,' stepsizes averages=',3f10.5)
1189  format(' Largest energy increase with an attempted move=',e12.5,
     -  ' kcal/mol')
1190  format(' Atom1:',i6,' (',a,1x,a,')  Atom2:',i6,' (',a,1x,a,') ',
     -  'target distance=',f6.2,' Actual distance=',f6.2,
     -  ' Constraint energy=',e13.5)
1191  format(' Total constraint energy=',e13.5,' kcal/mol')
1192  format(' Torsion',i6,'  Sampling characteristics from ',
     -  'autocorrelation for angle(',3(i4,1x,a8,'-'),i4,1x,a8,'):')
1193  format(8x,20f6.3)
1194  format('Torsion',i6,':')
1195  format(1x,a,1x,a,' Tacc=',f6.4,' Lacc=',f6.4,
     -  ' # of AUC values used=',i6,' <AUC> over the last 5%=',f6.3,
     -  ' 0.5 first reached at term',i6)
1196  format(/,1x,a,'-solvent running coordination numbers ',
     -  '(gridsize=',f6.3,' A)=',/,30(15f8.4,/))
1197  format(' Largest number of successive rejections=',i6,' (for ',
     -  'solvent',i7,')')
1198  format(' Solute ',i6,'(',a,', res',i6,1x,a,') Pacc(ins)=',f8.6,
     -  ' Pacc(del)=',f8.6,' (Nitry=',i10,' Ndtry=',i10,')')
1199  format(/,' Proximity insertion and deletion acceptance rates:')
1200  format(' Hydrogen ',i6,'(',a,', res',i6,1x,a,') merged to atom ',
     -  i6,'(',a,', res',i6,1x,a,')')
1201  format(' Number of hydrogens merged to their heavy atoms=',i6)
1202  format(' ----- WARNING: Hydrogen ',i6,'(',a,', res',i6,1x,a,
     -  ') number of bonds (',i2,') is not one')
1203  format(/,' Nmc=',i10,' Average number of solvent molecules=',
     -  f10.4,' Solvent-solvent energy per solvent molecule=',e15.6,
     -  /,' Solute-solvent energy/solvent molecule=',e15.6,/,
     -  ' Solute-solvent Coulomb energy/solvent molecule=',e15.6)
1204  format(' ***** PROGRAM ERROR: constraint energy used=',e15.6,
     -  ' recalculated constraint energy=',e15.6)
2000  format(/,1x,a,' RESULTS:')
4600  format(i3,2i6,i10,f6.3,3f13.3,i6,f10.2)
C@FR8000  format(' ------ WARNING: Quantum correction calculations with ',
C@FR     -  ' the grand canonical ensemble most probably are wrong and ',
C@FR     -  ' are unchecked')
7895  format(' DISFIN im=',i4,' rms=',f10.5,' rms2=',f10.5)
7896  format(' DISFIN root atom=',i5,' it=',i5,' list=',(20i5))
7897  format(' DISFIN root number=',i5,' r2im,rrim=',2f10.5)
      end
      subroutine torsionacc(ntang,l1,l2,l3,nacc,ntry,stepsum,stepmax,
     -  ntorgrp,ntorg,ifdhgrlst,ildhgrlst,itorig,stepav,stepmaxt,acc,
     -  iclone,iout)
c#    MMC routine 215 lstmod: 03/03/08
c*****Expand over torsion groups and average over clones (if applicable)
      real*8 stepsum
      dimension l1(ntang),l2(ntang),l3(ntang),itorig(ntang),nacc(ntang),
     -  ntry(ntang),stepsum(ntang),stepmax(ntang),ifdhgrlst(ntang),
     -  ildhgrlst(ntang),stepav(ntang),stepmaxt(ntang),acc(ntang)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      call zeroiti(l1,0,ntang)
      call zeroiti(l2,0,ntang)
      call zeroiti(l3,0,ntang)
      call zeroit(acc,ntang)
      ntlim=0
      do itg=1,ntorgrp
        do it=ifdhgrlst(itg),ildhgrlst(itg)
          call origtor(it,itorig,iclone,itn)
c         itn: original index of torsion
          if (itn .gt. ntlim) ntlim=itn
          l1(itn)=l1(itn)+nacc(itg)
          l2(itn)=l2(itn)+ntry(itg)
          if (ntry(itg) .gt. 0)
     -      acc(it)=float(nacc(itg))/float(ntry(itg))
          l3(itn)=l3(itn)+1
        end do
      end do
c     stepav and acc are the mean step and acceptance rate for each torsion
      accmin=1.0
      accmax=0.0
      ntrytot=0
      nacctot=0
      call zeroit(stepav,ntlim)
      call zeroit(stepav,ntang)
      call zeroit(stepmaxt,ntang)
      do itg=1,ntorgrp
        do it=ifdhgrlst(itg),ildhgrlst(itg)
          call origtor(it,itorig,iclone,itn)
          stepav(itn)=stepav(itn)+stepsum(it)
          if (stepmaxt(itn) .lt. stepmax(it)) stepmaxt(itn)=stepmax(it)
        end do
      end do
      do it=1,ntlim
        if (l1(it) .gt. 0) stepav(it)=rdtodg*stepav(it)/l1(it)
        stepmaxt(it)=rdtodg*stepmaxt(it)
C!!!    if (l2(it) .gt. 0 .and. iavg .gt. 0)
        if (l2(it) .gt. 0) acc(it)=float(l1(it))/float(l2(it))
        if (accmin .gt. acc(it)) accmin=acc(it)
        if (accmax .lt. acc(it)) accmax=acc(it)
        ntrytot=ntrytot+l2(it)
        nacctot=nacctot+l1(it)
      end do
      if (iclone .gt. 0) then
        ntorg=0
        do itg=1,ntlim
          if (l3(itg) .gt. 0) then
            ntorg=ntorg+1
          end if
        end do
        write (iout,1018) ntlim
      else
        ntorg=ntorgrp
        ntlim=ntang
      end if
      return
1018  format(' Torsions on cloned solutes will be concatenated, the ',
     -  'list below refers to the',i5,' torsions on explicitly ',
     -  'inputted solutes',/,
     -  '     The groups are ordered by their first members')
      end
      subroutine cloneav(ntang,ntangorg,itorig,nsum,orig,avg,sd,max)
c#    MMC routine 215/a lstmod: 07/31/06
c*****Just average over clones (duplicate of torsionacc??)
      dimension itorig(max),orig(max),avg(max),sd(max),nsum(max)
      call zeroiti(nsum,0,ntangorg)
      call zeroit(avg,ntangorg)
      call zeroit(sd,ntangorg)
      do it=1,ntang
        call origtor(it,itorig,1,itn)
c       itn: original index of torsion on first copy
        nsum(itn)=nsum(itn)+1
        avg(itn)=avg(itn)+orig(it)
        sd(itn)=sd(itn)+orig(it)**2
      end do
      do it=1,ntangorg
        if (nsum(it) .gt. 0) then
          avg(it)=avg(it)/nsum(it)
          sd(it)=sqrt(abs(sd(it)/nsum(it)-avg(it)**2))
        end if
      end do
      return
      end
      subroutine clonespread(ntang,itorig,orig,avg,max)
c#    MMC routine 215/b lstmod: 07/31/06
c*****Just average over clones (~duplicate of torsionacc??)
      dimension itorig(max),avg(max),orig(max)
      do it=1,ntang
        call origtor(it,itorig,1,itn)
c       itn: original index of torsion on first copy
        orig(it)=avg(itn)
      end do
      return
      end
      subroutine origtor(it,itorig,iclone,itn)
c#    MMC routine 215/c lstmod: 11/10/07
c*****Find original torison (when cloned)
      dimension itorig(#TR)
      if (iclone .gt. 0) then
        itn=itorig(it)
        if (itn .lt. 0) itn=-itn
      else
        itn=it
      end if
      return
      end
      subroutine prtacc(ntrya,nacca,mlt,n,maxa,g,maxg,name,iout,iopverb)
c#    MMC routine 216 lstmod: 04/24/16
c*****Print acceptance information for a given sampling type
      dimension ntrya(maxa),nacca(maxa),g(maxg)
      character*20 name
      accmin=1.0
      accmax=0.0
      ntry=0
      nacc=0
      do i=1,n
        ntry=ntry+ntrya(i)
        nacc=nacc+nacca(i)
      end do
      ndd=min0(maxg,n)
      do i=1,ndd
        g(i)=0.0
        if (ntrya(i) .gt. 0) g(i)=float(nacca(i))/float(ntrya(i))
        if (accmin .gt. g(i)) accmin=g(i)
        if (accmax .lt. g(i)) accmax=g(i)
      end do
      acc=0.0
      if (ntry .gt. 0) acc=float(nacc)/ntry
      write (iout,1080) name,acc,accmin,accmax,ntry/mlt
      if (iopverb .gt. 0) write (iout,1081) name,(g(i),i=1,ndd)
      if (iopverb .gt. 1) then
        write (iout,1082) name,'attempted',(ntrya(i),i=1,ndd)
        write (iout,1082) name,'accepted',(nacca(i),i=1,ndd)
      end if
      return
1080  format(1x,a,' acceptance rate=',f8.5,' Minimum and maximum=',
     -  2f9.5,' Number of attempts=',i10)
1081  format(1x,a,' individual acceptance rates=',/(1x,20f6.2))
1082  format(1x,a,' number of trials',a,'=',/(10i8))
      end
      subroutine volincalc(vol,iop5,edgexyz,edge2xyz,rinscr,rboxmax,
     -  volin,edgelinxyz,edgerinxyz)
c#    MMC routine 217 lstmod: 06/15/12
c*****Calculates volume inside and outside of rect (defined by MOND or LIMG)
      dimension edgexyz(3),edge2xyz(3),cent(3),edgeinxyz(3),
     -  edgelinxyz(3),edgerinxyz(3)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      volin=0.0
      centsum=0.0
      do k=1,3
        edgeinxyz(k)=edgerinxyz(k)-edgelinxyz(k)
        cent(k)=(edgerinxyz(k)+edgelinxyz(k))/2.0
        centsum=centsum+abs(cent(k))
        if (edgeinxyz(k) .lt. 0.0) then
          if (MYRANK .eq. 0)
     -      write (iout,1003) k,edgelinxyz(k),edgerinxyz(k)
          inperr=inperr+1
        end if
      end do
      if (iop5 .gt. 0 .and. centsum .gt. 0.001) then
        if (MYRANK .eq. 0) write (iout,1000)
        inperr=inperr+1
      end if
      if (iop5 .eq. 0) then
        volin=1.0
        do k=1,3
          volin=volin*(amin1(edgerinxyz(k),edge2xyz(k))
     -      -amax1(edgelinxyz(k),-edge2xyz(k)))
        end do
      else if (iop5 .ge. 1 .and. iop5 .le. 3) then
        if (amax1(edgeinxyz(1),edgeinxyz(2),edgeinxyz(3))*sq3 .lt.
     -      rinscr) then
              volin=8.0*edgeinxyz(1)*edgeinxyz(2)*edgeinxyz(3)
        else if (amin1(edgeinxyz(1),edgeinxyz(2),edgeinxyz(3)) .gt.
     -      rboxmax) then
          if (iop5 .eq. 1) then
            volin=2.0*edgeinxyz(1)**3
          else if (iop5 .eq. 2) then
c           HCP
            volin=edgeinxyz(1)**3/sqrt(2.0)
          else if (iop5 .eq. 3) then
c           TOCT
            volin=4.0*edgexyz(1)**3
          end if
        end if
      else if (iop5 .eq. 4) then
        area=0.0
        if (edgeinxyz(2) .gt. edgexyz(2)*sq3p2 .and.
     -      edgeinxyz(3) .gt. edgexyz(2)) then
              area=edgexyz(2)**2*sq3p2*3.0
        else if (edgeinxyz(2) .lt. edgexyz(2)*sq3p2 .and.
     -      edgeinxyz(3) .lt. edgexyz(2)/2.0) then
              area=4.0*edgeinxyz(2)*edgeinxyz(3)
        end if
        if (edgeinxyz(1) .lt. edgexyz(1)) then
          volin=edgeinxyz(1)*area
        else
          volin=edgexyz(1)*area
        end if
      end if
      if (vol .le. volin) then
          if (MYRANK .eq. 0) write (iout,1001) volin,vol
        inperr=inperr+1
      else if ((vol-volin)/vol .lt. 0.1) then
         if (MYRANK .eq. 0) write (iout,1002)
         nwarn=nwarn+1
      end if
      if (volin .lt. 0.0) then
        if (MYRANK .eq. 0) write (iout,1004)
        inperr=inperr+1
      end if
      return
1000  format(' ***** ERROR: off-center central cube is implemented',
     -  ' only for rectangular periodic cell')
1001  format(' ***** ERROR: volume of inside region (',f10.0,') ',
     -  'is not less than the cell volume (',f10.0,')')
1002  format(' ----- WARNING: outside volume is less than 10 % of the',
     -  ' total volume')
1003  format(' ***** ERROR: invalid rectangle limits for component ',i1,
     -  ': ',2f10.5)
1004  format(' ***** ERROR: negative inner volume:',f12.4)
      end
      subroutine denincalc(suminout,suminout2,nt,volin,volav,wmslv,
     -  wmmltona3,label,nmc1,nmc2,novolp,nosd,iout)
c#    MMC routine 218 lstmod: 07/17/12
c*****Calculates and prints density inside and outside of rect specified by MOND
      real*8 suminout,suminout2
      dimension suminout(2),suminout2(2)
      real*8 rnin,rnout
      character*7 label
      character*37 range
      if (volin .eq. 0.0) return
      rnin=suminout(1)/nt
      rnout=suminout(2)/nt
      if (nmc1 .eq. nmc2) then
        write (range,1003) nmc1
      else if (nmc2 .gt. nmc1) then
        write (range,1004) nmc1,nmc2
      else
        write (iout,1005) nmc1,nmc2
      end if
      volout=volav-volin
      if (novolp .eq. 0) write (iout,1001) volin,volout
      write (iout,1000) label,'number of solvents',range,rnin,rnout
      if (nosd .eq. 0) then
        sdin=suminout2(1)/dfloat(nt)-rnin**2
        sdout=suminout2(2)/dfloat(nt)-rnout**2
        write (iout,1000) label,'MS fluctuations   ',range,sdin,sdout
      end if
      if (volin .gt. 0.0) then
        denin=(rnin/volin)*wmslv*wmmltona3
        denout=(rnout/volout)*wmslv*wmmltona3
        write (iout,1002) label,range,denin,denout
      end if
      return
1000  format(1x,a,1x,a,1x,a,' in the inner rectangle=',
     -  f10.2,' outside the inner rectangle=',f10.2)
1001  format(' Volume of the inner rectangle=',f10.2,' A^3',
     -  '  region outside the inner rectangle=',f10.2,' A^3')
1002  format(1x,a,' density',12x,a,' in the inner rectangle=',f10.5,
     -  ' outside the inner rectangle=',f10.5,' g/ml')
1003  format('  at Nmc=',i10,18x)
1004  format('from Nmc=',i10,' to Nmc=',i10)
1005  format(' ***** PROGRAM ERROR: invalid Nmc range in denincalc:',
     -  2i10)
      end
      subroutine idaggregate(c,nslt,nresslt,nrecid,file,namlenf,
     -  filename1,namlens1,idfilename,lidfilename,numrun,ivers,nmc,
     -  labslt,ianslt,rminprx1,rminprx2,key,key1)
c#    MMC routine 219 lstmod: 01/18/12
c*****Prepares a PDB file with the insertion/deletion sites
      dimension c(3,#NA),cm(3),rminprx1(nslt),rminprx2(nslt),
     -  ianslt(nslt)
      character*4 labslt(2,#ST)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*80 file,filename1,idfilename
      character*4 idatom(2),idres(2),key,key1
      character*1 chain
      dimension keycol(2),nsites(2)
      data idatom /'N   ','O   '/,idres /'N   ','O   '/
      if (key1 .eq. 'FILT') then
        call getreal(rmax,1,0.0)
        call getint(nslt1,0,1,1)
        call getint(nslt2,0,1,nslt)
        if (nslt2 .gt. nslt) then
          nslt2=nslt
          nchng=nchng+1
          write (iout,1018) nslt2,nslt
        end if
        if (nslt2 .lt. nslt1) then
          inperr=inperr+1
          write (iout,1019) nslt1,nslt2
        end if
      else
        nslt1=1
        nslt2=nslt
        rmax=1000000.0
      end if
      call getint(nmcscan,0,1,0)
      write (iout,1001) idfilename(1:lidfilename)
      if (nrecid .eq. 0) then
        write (iout,1011)
        nwarn=nwarn+1
        if (nmcscan .eq. 0) write (iout,1014)
      else
        write (iout,1007) nrecid
      end if
      if (nmcscan .gt. 0) write (iout,1008) nmcscan
      if (key .eq. 'BOTH') then
        write (iout,1005)
        write (iout,1006)
        write (iout,1010) 'both insertion and deletion'
      else if(key .eq. 'INSR') then
        write (iout,1005)
        write (iout,1010) 'insertion'
      else if (key .eq. 'DELE') then
        write (iout,1006)
        write (iout,1010) 'deletion'
      else if(key .eq. 'DELD') then
        write (iout,1006)
        write (iout,1010) 'deletion',
     -    ', but only when there are less insertions than deletions'
      end if
      if (key1 .eq. 'FILT') write (iout,1004) rmax,nslt1,nslt2
c     First get the proximity counts
      rewind iindel
      i=0
      nmclog=0
      call zeroiti(nsites,0,2)
      do ia=nslt1,nslt2
        rminprx1(ia)=rmax
        rminprx2(ia)=rmax
      end do
      rewind iindel
      ig=nresslt
      call zeroiti(l1,0,nslt)
      call zeroiti(l2,0,nslt)
      do while (i .lt. nrecid .or. nmclog .lt. nmcscan .or.
     -          nrecid+nmcscan .eq. 0)
        i=i+1
        read (iindel,4600,end=888) indel,is,nmol,nmclog,cplxx,cm,ipx,rpx
        if (nslt1 .gt. 1 .or. nslt2 .lt. nslt) then
c         Recalculate ipx and rpx for the limited solute
          rpx2=100000.0
          ipx=0
          do ia=nslt1,nslt2
            if (ianslt(ia) .gt. 1) then
              d2=arrdist(cm,c(1,ia))
              if (d2 .lt. rpx2) then
                rpx2=d2
                ipx=ia
              end if
            end if
          end do
          rpx=sqrt(rpx2)
c         write (78,*) 'nmc=',nmclog,' recalculated ipx=',ipx,
c    -      ' rpx=',rpx
        end if
        if (rpx .le. rmax) then
          if (indel .eq. +1) then
            l1(ipx)=l1(ipx)+1
          else
            l2(ipx)=l2(ipx)+1
            if (rpx .lt. rminprx1(ipx) .or. rminprx1(ipx) .eq. 0.0)
     -        rminprx1(ipx)=rpx
          end if
        end if
      end do
888   do ia=1,nslt
        l3(ia)=10.0*rminprx1(ia)
      end do
      if (key .eq. 'BOTH') then
        call zeroiti(l4,0,nslt)
        do ia=nslt1,nslt2
          l4(ia)=l1(ia)+l2(ia)
        end do
      else if (key .eq.'DELD') then
        call zeroiti(l4,0,nslt)
        do ia=nslt1,nslt2
          if (l2(ia) .ge. l1(ia)) l4(ia)=l2(ia)
        end do
      else if (key .eq. 'INSR') then
        call trnsfi(l4,l1,nslt)
      else if (key .eq. 'DELE') then
        call trnsfi(l4,l2,nslt)
      end if
      nsitemaxw=0
      do ia=nslt1,nslt2
        if (l4(ia) .gt. nsitemaxw) nsitemaxw=l4(ia)
      end do
      write (iout,1021) nsitemaxw
      call savepdb('PDBC',keycol,iupdb,iout,1,nslt,1,c,-1,0,0,0,
     -  filename1,namlens1,nmc,1,file,namlenf,numrun,ivers,1,inperr,
     -  nwarn,nwwarn,21,0,nlwr,0,1,#NA)
      if (key1 .eq. 'FILT') then
        write (iupdb,1016) rmax
        if (nslt1 .gt. 1 .or. nslt2 .lt. nslt)
     -    write (iupdb,1017) nslt1,nslt2
      end if
      write (iout,1013) filename1(1:namlens1)
      iw=0
      i=0
      nmclog=0
      call zeroiti(nsites,0,2)
      call zeroiti(l1,0,nslt)
      call zeroiti(l2,0,nslt)
      do ia=nslt1,nslt2
        rminprx1(ia)=rmax
        rminprx2(ia)=rmax
      end do
      iendok=0
      chain='S'
      if (key .eq. 'INSR') chain='I'
      if (key .eq. 'DELE' .or. key .eq. 'DELD') chain='R'
      rewind iindel
      do while (i .lt. nrecid .or. nmclog .lt. nmcscan .or.
     -          nrecid+nmcscan .eq. 0)
        i=i+1
        if (iop(42) .lt. 2) then
        read (iindel,4600,end=999) indel,is,nmol,nmclog,cplxx,cm
          rclose=100000.0
          iaclose=0
          do ia=nslt1,nslt2
            if (ianslt(ia) .gt. 1) then
              d2=arrdist(cm,c(1,ia))
              if (d2 .lt. rclose) then
                rclose=d2
                iaclose=ia
              end if
            end if
          end do
          rclose=sqrt(rclose)
        else
          read (iindel,4600,end=999) indel,is,nmol,nmclog,cplxx,cm,
     -      iaclose,rclose
        end if
        if (key1 .ne. 'FILT' .or. rclose .le. rmax) then
          if (indel .eq. +1) then
            l1(iaclose)=l1(iaclose)+1
            if (rminprx1(iaclose) .gt. rclose) rminprx1(iaclose)=rclose
          else
            l2(iaclose)=l2(iaclose)+1
            if (rminprx2(iaclose) .gt. rclose) rminprx2(iaclose)=rclose
          end if
          nsites((indel+3)/2)=nsites((indel+3)/2)+1
          if (key .eq. 'BOTH' .or.
     -        (indel .eq. +1 .and. key .eq. 'INSR') .or.
     -        (indel .eq. -1 .and.
     -        (key .eq. 'DELE' .or. key .eq. 'DELD'))) then
            iw=iw+1
            call pdblim('IDAG',nslt+iw,iaw,99999,'atom',7,nwwarn,iout)
            call pdblim('IDAG',nresslt+iw,igw,9999,'residue',8,nwwarn,
     -        iout)
            write (iupdb,1003) iaw,idatom((indel+3)/2),
     -        idres((indel+3)/2)(1:3),chain,igw,cm,float(iaclose),rclose
          end if
        end if
      end do
      iendok=1
999   if (iendok .eq. 0) then
c       End of file reached in the while loop
        if (nrecid .gt. 0) then
          write (iout,1000) idfilename(1:lidfilename),i-1,nrecid
          inperr=inperr+1
        else
          write (iout,1009) i-1,nmclog
          if (nmcscan .gt. 0) then
            if (nmcscan-nmclog .gt. 2*(nmclog/(i-1))) then
              write (iout,1015)
              inperr=inperr+1
            end if
          end if
        end if
      end if
      write (iupdb,1002)
      call fileclose(iupdb,0,1,iout)
      write (iout,1012) nsites(2),nsites(1),nsites(1)+nsites(2)
      do ia=nslt1,nslt2
        if (l1(ia)+l2(ia) .gt. 0) write (iout,1020) ia,
     -    (labslt(k,ia),k=1,2),l1(ia),rminprx1(ia),l2(ia),rminprx2(ia)
      end do
      return
1000  format(' ***** ERROR: Inserion/deletion log file ',a,' ended ',
     -  'at record #',i6,' instead of record #',i9)
1001  format(' Insertion/deletion log file ',a,' will be aggregated ',
     -  'into a single PDB file')
1002  format('END')
1003  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,
     -  f6.0,f6.1)
1004  format(' Only sites within',f5.1,' A of solute atoms',i6,' - ',
     -  i6,' will be kept')
1005  format(' Insertion sites are represented by oxygens')
1006  format(' Deletion  sites are represented by nitrogens')
1007  format(' Log file contains ',i6,' records')
1008  format(' Log file will be scanned until MC step number',i10)
1009  format(' Insertion/deletion log file ended - last record read:',
     -  i9,'-th, at MC step',i10)
1010  format(' Site count will include ',a,' sites',a)
1011  format(' ----- WARNING: inserion/deletion log file record ',
     -  'counter is unavailable ')
1012  format(' Number of insertion sites=',i6,' deletion sites=',i6,
     -  ' total number of sites=',i6)
1013  format(' Solute records written on file ',a)
1014  format(' The whole file will be scanned')
1015  format(' ***** ERROR: premature ending')
1016  format('REMARK Insertion/deletion sites are extracted within',
     - f5.1,' A of the solute')
1017  format('REMARK Insertion/deletion site list is limited to the ',
     -  'proximity of',/,'REMARK solute atoms ',i6,' - ',i6)
1018  format(' >>>>> OVERRIDE: Solute atom range upper limit changed ',
     -  'from',i7,' to',i7)
1019  format(' ***** ERROR: invalid solute atom range: [',i7,',',i7,']')
1020  format(' Solute atom ',i6,' (',a,1x,a,') vicinity: # of ',
     -  'insertions=',i5,' Closest at',f5.1,' A # of deletions=',i5,
     -  ' Closest at',f5.1,' A')
1021  format(' The maximum number of sites written on the PDB file=',i4)
4600  format(i3,2i6,i10,f6.3,3f13.3,i6,f10.2)
      end
      subroutine printslope(dtot,nmc,nhowfar,incr,label,iout)
c#    MMC routine 220 lstmod: 11/07/12
      dimension dtot(nhowfar)
      character*7 label
c*****Calculate and print slope of diffusion progress
      if (nhowfar .ge. 4) then
        i1=nhowfar/3
        i2=nhowfar/2
        i3=nhowfar-nhowfar/3
        write (iout,1000) label,'simple',
     -    (dtot(nhowfar)-dtot(i1))/(nmc-i1*incr),
     -    (dtot(nhowfar)-dtot(i2))/(nmc-i2*incr),
     -    (dtot(nhowfar)-dtot(i3))/(nmc-i3*incr)
        if (nhowfar .ge. 6) then
          xs=0.0
          xs2=0.0
          ys=0.0
          xys=0.0
          s1=0.0
          s2=0.0
          s3=0.0
          do i=i3,nhowfar
            x=i*incr
            xs=xs+x
            xs2=xs2+x**2
            ys=ys+dtot(i)
            xys=xys+x*dtot(i)
          end do
          rn=nhowfar-i3+1
          if (xs**2-rn*xs2 .ne. 0.0) s3=(xs*ys-rn*xys)/(xs**2-rn*xs2)
          do i=i2,i3-1
            x=i*incr
            xs=xs+x
            xs2=xs2+x**2
            ys=ys+dtot(i)
            xys=xys+x*dtot(i)
          end do
          rn=nhowfar-i2+1
          if (xs**2-rn*xs2 .ne. 0.0) s2=(xs*ys-rn*xys)/(xs**2-rn*xs2)
          do i=i1,i2-1
            x=i*incr
            xs=xs+x
            xs2=xs2+x**2
            ys=ys+dtot(i)
            xys=xys+x*dtot(i)
          end do
          rn=nhowfar-i1+1
          if (xs**2-rn*xs2 .ne. 0.0) s1=(xs*ys-rn*xys)/(xs**2-rn*xs2)
          write (iout,1000) label,'fitted',s1,s2,s3
        end if
      end if
      return
1000  format(1x,a,' diffusion slope (',a,') on last 2/3rd, last half,',
     -  ' last 1/3rd of the run=',3e15.5)
      end
      subroutine gmax(lab,g,r,n,iout)
c#    MMC routine 221 lstmod: 01/18/01
c*****Find and print the extrema of the function g(r).
      dimension g(n),r(n)
      character*(*) lab
      call gext(1,n,g,+1,imx1)
      call gext(imx1,n,g,-1,imn1)
      call gext(imn1,n,g,+1,imx2)
      write (iout,2002) lab,r(imx1),g(imx1),r(imn1),g(imn1),
     -  r(imx2),g(imx2)
2002  format(1x,a,'-solvent g(r) First max: g(',f6.3,')=',f7.3,
     -  ' First min: g(',f6.3,')=',f7.3,' Second max: g(',f6.3,')=',
     -  f7.3)
      return
      end
      subroutine gext(i1,i2,g,isg,im)
c#    MMC routine 222 lstmod: 05/04/00
c*****Find the minimum (isg=-1) or maximum (isg=+1) of an array
      dimension g(i2)
      rext=-1.0e+35
      im=i2
      do i=i1,i2
        if (g(i) .ne. 0.0) then
          if (rext .lt. isg*g(i)) then
            rext=isg*g(i)
            im=i
          end if
        end if
      end do
      return
      end
      subroutine glims(r0,dr,idel,g,imax,fractn,iout,lab)
c#    MMC routine 223 lstmod: 12/26/03
c*****Find and print the limits and the max of a distribution
      dimension g(imax)
      character*(*) lab
      rav=0.0
      do i=1,imax
        rav=rav+(r0+(i-idel-1)*dr+dr/2.0)*g(i)
      end do
      gsum=0.0
      i1=1
      i2=imax
11    if (g(i1) .le. g(i2)) then
        gsum=gsum+g(i1)
        if (gsum .gt. fractn) go to 21
        i1=i1+1
        if (i1 .eq. i2) go to 21
        go to 11
      end if
      gsum=gsum+g(i2)
      if (gsum .le. fractn) then
        i2=i2-1
        if (i1 .eq. i2) go to 21
        go to 11
      end if
21    call gext(2,imax-1,g,1,im)
      pct=fractn*100.0
      ri1=r0+(i1-idel-1)*dr
      ri2=r0+(i2-idel-1)*dr
      rim=r0+(im-idel-1)*dr
      half=g(im)/2.0
      ih1=im
      ih2=im
      do i=i1,im
        ih1=i
        if (g(i) .ge. half) go to 31
      end do
31    do i=im,i2
        ih2=i
        if (g(i) .le. half) go to 41
      end do
41    rih1=r0+(ih1-idel-1)*dr
      rih2=r0+(ih2-idel-1)*dr
      write (iout,1000) ri1-dr/2.0,ri2+dr/2.0,pct,lab,g(im),rim,rav,
     -  rih1,rih2
      return
1000  format(' The interval (',f10.4,',',f10.4,')  contains all but',
     -  f8.4,' % of the',a,'distribution',/,
     -  ' *** Max:',f10.5,' at',f10.4,' average=',f10.4,
     -  '  half-width: (',f10.4,',',f10.4,')')
      end
      subroutine accu_dipoledist(nslt,nslv,qslvdip,dipmomabs,dndipmom,
     -  exyzabc,c,nmolec,rdtodg,iout)
c#    MMC routine 224 lstmod: 01/14/10
c*****Solute dipole distribution contribution for config in c
      real*8 dndipmom
      dimension c(3,#NA),dndipmom(3,180),exyzabc(3,3),qslvdip(nslv)
      dimension dipmom(3)
      ii01=nslt-2*nslv+1
      do im=2,nmolec
        call dipolemoment(c(1,ii01+im*nslv),nslv,qslvdip,dipmomabs,
     -    dipmom,1)
        do k=1,3
          proj=sclprd(exyzabc(1,k),dipmom)
          ind=int(acoscheck(proj,iout,'DIPMAC')*rdtodg*0.99999)+1
          dndipmom(k,ind)=dndipmom(k,ind)+1
        end do
      end do
      return
      end
      subroutine disfin_dipoledist(gdipc,dndipmom,nmc,numrun,
     -  rdtodg,iverbose,inperr,iout)
c#    MMC routine 224/a lstmod: 08/22/07
c*****Print/plot solvent dipole distribution
      real*8 dndipmom
      dimension gdipc(180),dndipmom(3,180)
      real*8 dpsum
      dimension dpsum(3),dip(3),pdip(3),pdipmom(180,3),
     -  ifsta(3),ilsta(3),ixstart(3),ldiplab(3)
      character*3 diplab(3)
      character*39 psnmc
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      data diplab /'D.X','D.Y','D.Z'/,ldiplab /3*3/
      call zeroitd(dpsum,3)
      nang=180
      halfinc=float(180/nang)*0.50
      pmax=1.2/float(nang)
      do i=1,nang
        gdipc(i)=float(i)*(180.0/float(nang))-halfinc
        do k=1,3
          dpsum(k)=dpsum(k)+dndipmom(k,i)
        end do
      end do
      do i=1,nang
        do k=1,3
          dip(k)=dndipmom(k,i)/dpsum(k)
          pdip(k)=dip(k)/sin(gdipc(i)/rdtodg)
        end do
        write (iout,1186) gdipc(i),dip,pdip
        do k=1,3
          if (pdip(k) .gt. 2.0*pmax) pdip(k)=2.0*pmax
          pdipmom(i,k)=pdip(k)+(k-1)*pmax
        end do
      end do
      do k=1,3
        ifsta(k)=(k-1)*nang+1
        ilsta(k)=k*nang
        ixstart(k)=1
      end do
      iversps=1
      ihead=1
      call fileopen(file,namlenf,filenames(31),namlens(31),31,0,
     -  numrun,iversps,3,iform(31),1,iversout,iout,idipps,0)
      write (iout,1187) filenames(31)(1:namlens(31))
      write (psnmc,1188) nmc,pmax
      call plotnps(gdipc,pdipmom,nang,3*nang,3,ifsta,ilsta,ixstart,
     -  0.0,180.0/float(nang),0.0,30.0,6,0.0,pmax*0.3,999999.0,15,0,57,
     -  'Normalized solvent dipole moment projection distributions',
     -  39,psnmc,'Angle',5,diplab,ldiplab,idipps,ihead,0,inperr,iout)
      call fileclose(idipps,0,iverbose,iout)
      return
1186  format(' Angle=',f5.1,' deg P(D-X,Y,Z=Angle):',3f10.7,
     -  ' P/sin(a)=',3f10.7)
1187  format(' Solvent dipole distributions are written to file ',a)
1188  format('nMC=',i10,' Curves shifted by',f7.4)
      end
      subroutine dipolemoment(c,n,q,dnorm,dipmom,inorm)
c#    MMC routine 224/b lstmod: 03/016/15
c*****Prepare the normalized dipole moment vector
      dimension c(3,n),q(n),dipmom(3)
      call zeroit(dipmom,3)
      qsum=0.0
      do i=1,n
        qsum=qsum+q(i)
        do k=1,3
          dipmom(k)=dipmom(k)+q(i)*c(k,i)
        end do
      end do
      dnorm=sqrt(sclprd(dipmom,dipmom))
      if (inorm .eq. 1) then
        do k=1,3
          dipmom(k)=dipmom(k)/dnorm
        end do
      end if
      return
      end
      function corn(dk,c,n,kcmin)
c#    MMC routine 224/c lstmod: 02/11/86
c*****Prepare the normalized Xc(K) QCDF and compute <nK>
      real*8 dk,dnk
      dimension dk(n),c(n)
      dnk=0.d0
      do i=1,n
        dnk=dnk+dk(i)
      end do
      if (dnk .eq. 0.d0) dnk=1.d0
      corn=kcmin
      do i=1,n
        c(i)=dk(i)/dnk
        corn=corn+(i-1)*c(i)
      end do
      return
      end
      subroutine printnumdist(title,len,n,ndist,iout)
c#    MMC routine 225 lstmod: 03/29/02
c*****Prints a number distribution, appropriately scaled
      character*(*) title
      dimension ndist(n),nd(20)
      character*10 div
      data div /'1000000000'/
      if (n .gt. 20) then
        write (iout,1002) n
        return
      end if
      nmax=0
      do i=1,n
        if (nmax. lt. ndist(i)) nmax=ndist(i)
        nd(i)=ndist(i)
      end do
      ndiv=1
      ndivdig=1
      limnum=10000
      if (n .le. 14) limnum=limnum*10
      do while (nmax .ge. limnum)
        nmax=nmax/10
        ndiv=ndiv*10
        ndivdig=ndivdig+1
      end do
      if (ndiv .gt. 1) then
        do i=1,n
          if (nd(i) .ne. 0) nd(i)=max0(1,nd(i)/ndiv)
        end do
      end if
      if (n .le. 15) then
        write (iout,1001) title(1:len),div(1:ndivdig),(nd(i),i=1,n)
      else
        write (iout,1000) title(1:len),div(1:ndivdig),(nd(i),i=1,n)
      end if
      return
1000  format(' Distribution of ',a,'/',a,' :',20i5)
1001  format(' Distribution of ',a,'/',a,' :',14i6)
1002  format(' ***** PROGRAM ERROR: list length=',i5,' exceeds 20')
      end
      subroutine analtdist(itd,nzg,itdmin,itdmax,itdsum,ioffcent,
     -  ntorg,maxg)
c#    MMC routine 226 lstmod: 11/07/03
c*****Finds the range and center position of a torsion angle distribution
      dimension itd(maxg)
      nzg=0
      itdmin=10000000
      itdmax=0
      igtmax=1
      igmin=1
      igmax=maxg
      itdsum=0
      do ig=1,maxg
        if (itd(ig) .ne .0) then
          if (ig .gt. 1) then
            if (itd(ig-1) .eq. 0) igmin=ig
          end if
          nzg=nzg+1
          itd(ig)=itd(ig)/ntorg
          itdsum=itdsum+itd(ig)
          if (itdmax .lt. itd(ig)) then
            itdmax=itd(ig)
            igtmax=ig
          end if
        end if
        if (itdmin .gt. itd(ig)) itdmin=itd(ig)
      end do
      igg=0
      ig=igmin
      do while (igg .lt. maxg .and. itd(ig) .gt. 0)
        ig=mod(ig,maxg)+1
        igmax=igmin+igg
        igg=igg+1
      end do
      if (nzg .lt. #TD) then
        ioffcent=0
        if (nzg .gt. 2 .and. nzg .lt. 5) then
          if (igtmax .eq. igmin .or. igtmax .eq. igmax) ioffcent=1
        else if (nzg .gt. 4) then
c         See if distribution peak is near the center
          igcdiff=igtmax-igmin
          if (igcdiff .lt. 0) igcdiff=igcdiff+maxg
          posfac=float(igcdiff)/float(nzg-1)
          if (posfac .lt. 0.4 .or. posfac .gt. 0.6) ioffcent=1
        end if
      else
        ioffcent=2
      end if
      return
      end
      subroutine qcorre(amass,rinert,ityp,relcrd,natoms,fsum,tsum,qcorr,
     -  istsv)
c#    MMC routine 227 lstmod: 03/03/08
c*****Compute free energy quantum corrections a la Powles and Riykajzen
      real*8 fsum,tsum
      dimension rinert(3),ityp(natoms),relcrd(3,natoms),tsum(3)
      common /tdstate/ press,pressv,ba,temp,beta
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      qcorr=0.0
c     Compute atomic mass and moments of inertia
      call zeroit(rinert,3)
      if (amass .eq. 0.0) return
      amas=amass/(9.109e-28*avogad)
      cisum=0.0
      tsumi=0.0
      if (natoms .ge. 3) then
        nzero=0
        do i=1,natoms
          if (istsv .eq. 0) then
            iatno=iatnos(ityp(i),iopslt(i))
          else
            iatno=ityp(i)
          end if
          do k=1,3
            k1=mod(k,3)+1
            k2=mod(k+1,3)+1
            rinert(k)=rinert(k)+aw(iatno)/(9.109e-28*avogad)*
     -        (relcrd(k1,i)**2+relcrd(k2,i)**2)
            if (rinert(k) .eq. 0.0) nzero=nzero+1
          end do
        end do
        if (nzero .eq. 0) then
c         Spherical or cylindrical symmetry case has not been implemented
          do k=1,3
            tsumi=tsumi+tsum(k)/rinert(k)
            k1=mod(k,3)+1
            k2=mod(k+1,3)+1
            cisum=cisum+2.0/rinert(k)-rinert(k)/(rinert(k1)*rinert(k2))
          end do
        end if
      end if
      hbar=1.0
      qcorr=(hbar**2/(24.0*(boltz/temp)**2)*(fsum/amas+
     -  tsumi)-hbar/24.0*cisum)
      return
      end
      subroutine crorgn(edgexa,edgeya,edgea,iop5,ndim)
c#    MMC routine 228 lstmod: 03/31/19
c*****Generate the negative cell-center coordinates for the PBC routines
      common /ecell/ cic(3,27),ncell
      character*80 line
      common /inpline/ line,lineno,icol
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /option/ iop(200),idebug(200)
      dimension y(3),x(3),yx(3),yy(3)
      data ireadok /0/
c     cic will contain the negative of the respective cell center coords
      if (iop5 .eq. 0)  then
c-------Simple cubic
        ncell=27
        y(1)=0.
        y(2)=edgea
        y(3)=- edgea
        yx(1)=0.0
        yx(2)=edgexa
        yx(3)=-edgexa
        yy(1)=0.0
        yy(2)=edgeya
        yy(3)=-edgeya
        ii=0
        do i=1,ndim
          x(3)=y(i)
          do k=1,ndim
            x(2)=yy(k)
            do l=1,ndim
              x(1)=yx(l)
              ii=ii+1
              do j=1,3
                cic(j,ii)=x(j)
              end do
            end do
          end do
        end do
      else if (iop5 .eq. 1)  then
c-------Face-centered cubic
        ncell=19
        do i=1,19
          do j=1,3
            cic(j,i)=0.0
          end do
        end do
        do i=2,5
          cic(2,i)=-edgea
          cic(3,i)=-edgea
        end do
        cic(2,2)=edgea
        cic(3,2)=edgea
        cic(2,4)=edgea
        cic(3,5)=edgea
        do i=2,5
          cic(1,4+i)=cic(2,i)
          cic(3,4+i)=cic(3,i)
          cic(1,8+i)=cic(2,i)
          cic(2,8+i)=cic(3,i)
        end do
        cic(1,14)=-2.0*edgea
        cic(1,15)=-cic(1,14)
        cic(2,16)=cic(1,14)
        cic(2,17)=-cic(2,16)
        cic(3,18)=cic(1,14)
        cic(3,19)=-cic(3,18)
      else if (iop5 .eq. 2)  then
c-------HCP
c       Negative of Simulaid center coords
        ncell=19
        cic(1,2)=-edgea
        cic(1,3)=-edgea/2.0
        cic(2,3)=-edgea*sq3p2
        cic(1,4)=-edgea/2.0
        cic(2,4)=edgea*sq3p2
        cic(1,5)=edgea
        cic(1,6)=edgea/2.0
        cic(2,6)=-edgea*sq3p2
        cic(1,7)=edgea/2.0
        cic(2,7)=edgea*sq3p2
c       Neighbour cics above with touching face
        cic(2,8)=-edgea/sq3
        cic(1,9)=-edgea/2.0
        cic(2,9)=edgea/(2.0*sq3)
        cic(1,10)=edgea/2.0
        cic(2,10)=edgea/(2.0*sq3)
c       Neighbour cics above with touching vertex
        cic(2,11)=edgea*2.0/sq3
        cic(1,12)=-edgea
        cic(2,12)=-edgea/sq3
        cic(1,13)=edgea
        cic(2,13)=-edgea/sq3
        call trnsfr(cic(1,14),cic(1,8),18)
        do k=8,13
          cic(1,k+6)=cic(1,k)
          cic(2,k+6)=cic(2,k)
          cic(3,k)=-edgea*sq2p3
          cic(3,k+6)=-cic(3,k)
        end do
      else if (iop5 .eq. 3)  then
c-------TOCT
        ncell=15
c       Truncated face tranforms
c       Negative of Simulaid center coords
        do i=2,6,2
          cic(i/2,i)=-2.0*edgea
          cic(i/2,i+1)=2.0*edgea
        end do
c     +/-z, xy face transforms
        ic=7
        do ix=2,3
          do iy=2,3
            do iz=2,3
              ic=ic+1
              cic(1,ic)=(-1)**(ix)*edgea
              cic(2,ic)=(-1)**(iy)*edgea
              cic(3,ic)=(-1)**(iz)*edgea
            end do
          end do
        end do
      else if (iop5 .eq. 4)  then
c-------Hexagonal prism along the x axis, hexagon vertices on the z axis
        ncic=21
        do i=1,7
          cic(1,i)=0.0
        end do
        cic(2,1)=0.0
        cic(3,1)=0.0
        cic(2,2)=-edgea*sq3p2
        cic(3,2)=-edgea*threp2
        cic(2,3)=-edgea*sq3
        cic(3,3)=0.0
        cic(2,4)=-edgea*sq3p2
        cic(3,4)=edgea*threp2
        do k=5,7
          l=9-k
          cic(2,k)=-cic(2,l)
          cic(3,k)=cic(3,l)
        end do
        do k=1,7
          l1=k+7
          l2=k+14
          cic(1,l1)=edgexa
          cic(1,l2)=-edgexa
          cic(2,l1)=cic(2,k)
          cic(2,l2)=cic(2,k)
          cic(3,l1)=cic(3,k)
          cic(3,l2)=cic(3,k)
        end do
      else if (iop5 .eq. 5) then
c       Sphere BC
        call zeroit(cic,6)
        ncell=2
      else if (iop5 .eq. 6) then
c       PHS BC
        call zeroit(cic,3)
        ncell=1
      else if (iop5 .eq. 7)  then
c-------Input cell center coordinates
c       Number of new centers
        irectx=39
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) ncell
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,1339) ncell
        if (ncell .gt. 27) then
          write (iout,1001) ncell
          inperr=inperr+1
        end if
C@DM        call MPI_Bcast(ncell,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(inperr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        if (iop(24) .gt. 2) write (ioutdb,3000) MYRANK,ncell
c       New center coordinates
        irectx=38
        ireadok=0
        do i=1,ncell
          call getnextrec(inpt,iout,irectx,nwwarn)
          read (line,1002,err=999) (cic(k,i),k=1,3)
        end do
        ireadok=1
999     if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,1340)
        write (iout,1003) 'read in',
     -     (i,(cic(k,i),k=1,3),i=1,ncell)
C@DM        call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
        if (ireadok .eq. 0) call invalidform(iout,irectx)
C@DM        call MPI_Bcast(cic,3*ncell,MPI_REAL,0,MPI_COMM_WORLD,ierr)
C@DM        if (iop(24) .gt. 2) write (ioutdb,3001) MYRANK,
C@DM     -    (i,(cic(k,i),k=1,3),i=1,ncell)
c       Take negative
        do i=1,ncell
          do k=1,3
            cic(k,i)=-cic(k,i)
          end do
        end do
      end if
      if (idebug(80) .gt. 1) write (iout,1003) 'generated',
     -    (i,(cic(k,i),k=1,3),i=1,ncell)
      return
1000  format(i5)
1001  format(' ***** ERROR: number of cells is greater than 27')
1002  format(3f15.0)
1003  format(/,' The periodic cell centers ',a,'=',/,(i5,3f10.5))
1339  format(' rectype 39  : ',i5)
1340  format(' rectype 38-s:')
C@DM3000  format(' MPI in crorgn MYRANK=',i3,' ncell=',i3)
C@DM3001  format(' MPI in crorgn MYRANK=',i3,' cic:=',(/,i4,3f10.5))
      end
      subroutine pbcnd(x1,x2,x3,iop5,iopt,dist2)
c#    MMC routine 229 lstmod: 05/28/07
c*****Find the cell number for the nearest image and give the necessary
c     displacement to transform the actual distance to the nearest.
c     note, that <x1,x2,x3> is translated as well by the subroutine!
c     FCC routines were written by J.C. Owicki.
      common /ecell/ cic(3,27),ncell
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      iopt=1
      if (iop5 .eq. 0) then
c-------Rectangular (generalized simple cubic)
        if (x1 .gt. edgex2) then
          x1=x1-edgexa
          iopt=iopt+2
        else if (x1 .le. -edgex2) then
          x1=x1+edgexa
          iopt=iopt+1
        end if
        if (x2 .gt. edgey2) then
          x2=x2-edgeya
          iopt=iopt+6
        else if (x2 .le. -edgey2) then
          x2=x2+edgeya
          iopt=iopt+3
        end if
        if (x3 .gt. edge2) then
          x3=x3-edgea
          iopt=iopt+18
        else if (x3 .le. -edge2) then
          x3=x3+edgea
          iopt=iopt+9
        end if
        dist2=x1*x1+x2*x2+x3*x3
      else if (iop5 .eq. 6) then
c-------Primary hydration shell model
        dist2=x1*x1+x2*x2+x3*x3
      else if (iop5 .eq. 5) then
c-------Sphere boundary conditions
        dist2=x1*x1+x2*x2+x3*x3
        if (dist2 .gt. rinscs) iopt=2
      else if (iop5 .eq. 1) then
c-------Face-centered cubic
        dist2=x1*x1+x2*x2+x3*x3
        if (dist2 .gt. rinscs) then
          ax=abs(x1)
          ay=abs(x2)
          az=abs(x3)
          abmn=amin1(ax,ay,az)
          if (abmn .eq. ax) call clfn(x2,x3,edge2,0,16,18,iopt)
          if (abmn .eq. ay) call clfn(x1,x3,edge2,4,14,18,iopt)
          if (abmn .eq. az) call clfn(x1,x2,edge2,8,14,16,iopt)
          if (iopt .gt. 1) then
            x1=x1+cic(1,iopt)
            x2=x2+cic(2,iopt)
            x3=x3+cic(3,iopt)
            dist2=x1*x1+x2*x2+x3*x3
          end if
        end if
      else if (iop5 .eq. 4) then
c-------Hexagonal prism
        dist2=x1*x1+x2*x2+x3*x3
        if (dist2 .gt. rinscs) then
c         Determine the 2-d hexagonal nearest image
c         First work in the (+,+) quarter
          x=abs(x2)
          y=abs(x3)
          if (y .ge. x/sq3) then
c           Cell 1 or 2
            if (y .gt. edge2-x/sq3) iopt=2
          else
c           Cell 1 or 3
            if (x .gt. edge2*sq3p2) iopt=3
          end if
          if (iopt .gt. 1) then
c           Transform to the quarter of (x2,x3)
            if (x3 .lt. 0.0) iopt=6-iopt
            if (x2 .lt. 0.0) iopt=9-iopt
            x2=x2+cic(2,iopt)
            x3=x3+cic(3,iopt)
          end if
c         Finally, look at the x direction
          if (x1 .le. -edgex2) then
            iopt=iopt+7
            x1=x1+cic(1,iopt)
          else if (x1 .gt. edgex2) then
            iopt=iopt+14
            x1=x1+cic(1,iopt)
          end if
          if (iopt .gt. 1) dist2=x1*x1+x2*x2+x3*x3
        end if
      else if (iop5 .eq. 2) then
c-------HCP
        xs=x1*x1
        ys=x2*x2
        zs=x3*x3
        dist2=xs+ys+zs
        if (dist2 .gt. rinscs) then
c         Work in the (+,+/-,+) quadrant
          ax=abs(x1)
          az=abs(x3)
          if (x2 .ge. 0.0) then
c           iopt=1,2,3,8,9 or 12
            if (ax .gt. edgex2)  then
c             iopt=2,3,9 or 12
              if (x2 .lt. ax/sq3) then
c               iopt=2,9 or 12
                if (x2 .lt. edgpsq3-ax/sq3) then
c                 iopt=2 or 9
                  if ((ax-edgexa)**2+ys+zs .lt. (ax-edgex2)**2+
     -                (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                    iopt=2
                  else
                    iopt=9
                  end if
                else
c                 iopt=2 or 12
                  if ((ax-edgexa)**2+ys+zs .lt. (ax-edgexa)**2+
     -                (x2-edgpsq3)**2+(az-edgsq2p3)**2) then
                    iopt=2
                  else
                    iopt=12
                  end if
                end if
              else
c               iopt=3 or 12
                if ((ax-edgex2)**2+(x2-edgsq3p2)**2+zs .lt.
     -            (ax-edgexa)**2+(x2-edgpsq3)**2+(az-edgsq2p3)**2) then
                  iopt=3
                else
                  iopt=12
                end if
              end if
            else
c             iopt=1,8,3 or 9
              if (x2 .lt. ax/sq3) then
c               iopt=1 or 9
                if (dist2 .gt.
     -            (ax-edgex2)**2+(x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                  iopt=9
c               else iopt=1
                end if
              else
c               iopt=1,3 or 8
                if (x2 .gt. edgpsq3-ax/sq3) then
c                 iopt=3 or 8
                  if (xs+(x2-edgpsq3)**2+(az-edgsq2p3)**2 .lt.
     -                (ax-edgex2)**2+(x2-edgsq3p2)**2+zs) then
                    iopt=8
                  else
                    iopt=3
                  end if
                else
c                 iopt=1 or 8
                  if (dist2 .gt.
     -              xs+(x2-edgpsq3)**2+(az-edgsq2p3)**2) then
                    iopt=8
c                 else iopt=1
                  end if
                end if
              end if
            end if
          else
c           iopt=1,2,4,9, or 11
            if (ax .gt. edgex2)  then
c             iopt=2,4, or 9
              if (x2 .gt. -edgp2sq3-(ax-edgex2)/sq3) then
c               iopt=2 or 9
                if ((ax-edgexa)**2+ys+zs .lt.
     -            (ax-edgex2)**2+(x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                  iopt=2
                else
                  iopt=9
                end if
              else
c               iopt=4 or 9
c               dx=ax-edgex2 cancels
                if ((x2+edgsq3p2)**2+zs .lt.
     -            (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                  iopt=4
                else
                  iopt=9
                end if
              end if
            else
c             iopt=1,4,9, or 11
              if (x2 .gt. -edgpsq3-ax/sq3) then
c               iopt=1,4,or 9
                if (x2 .lt. -edgpsq3+ax/sq3) then
c                 iopt=4,or 9
c                 dx=ax-edgex2 cancels
                  if ((x2+edgsq3p2)**2+zs .lt.
     -              (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                    iopt=4
                  else
                    iopt=9
                  end if
                else
c                 iopt=1 or 9
                  if (dist2 .gt. (ax-edgex2)**2+
     -                (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                    iopt=9
c                 else iopt=1
                  end if
                end if
              else
c               iopt=4 or 11
                if ((ax-edgex2)**2+(x2+edgsq3p2)**2+zs .lt.
     -              xs+(x2+edg2psq3)**2+(az-edgsq2p3)**2) then
                  iopt=4
                else
                  iopt=11
                end if
              end if
            end if
          end if
          if (x1 .lt. 0.0) then
            if (iopt .eq. 9 .or. iopt .eq. 12) then
              iopt=iopt+1
            else if (iopt .gt. 1 .and. iopt .lt. 5) then
             iopt=iopt+3
            end if
          end if
          if (iopt .gt. 7) then
            if (x3 .lt. 0.0) iopt=iopt+6
          end if
          if (iopt .gt. 1) then
            x1=x1+cic(1,iopt)
            x2=x2+cic(2,iopt)
            x3=x3+cic(3,iopt)
            call hcp_rotate(x1,x2,iopt)
            dist2=x1*x1+x2*x2+x3*x3
          end if
        end if
      else if (iop5 .eq. 3) then
c-------TOCT
        xs=x1*x1
        ys=x2*x2
        zs=x3*x3
        dist2=xs+ys+zs
        iopt=1
        if (dist2 .gt. rinscs) then
          xa=abs(x1)
          ya=abs(x2)
          za=abs(x3)
          dist111=(xa-edgexa)**2+(ya-edgexa)**2+(za-edgexa)**2
          if (xa .gt. edgexa) then
            dist2x=(xa-et3)**2+ys+zs
            if (dist2x .lt. dist111) then
              iopt=2
              if (x1 .lt. 0.0) iopt=3
              dist2=dist2x
            else
              iopt=8
              dist2=dist111
            end if
          else if (ya .gt. edgexa) then
            dist2y=xs+(ya-et3)**2+zs
            if (dist2y .lt. dist111) then
              iopt=4
              if (x2 .lt. 0.0) iopt=5
              dist2=dist2y
            else
              iopt=8
              dist2=dist111
            end if
          else if (za .gt. edgexa) then
            dist2z=xs+ys+(za-et3)**2
            if (dist2z .lt. dist111) then
              iopt=6
              if (x3 .lt. 0.0) iopt=7
              dist2=dist2z
            else
              iopt=8
              dist2=dist111
            end if
          else if (dist2 .gt. dist111) then
            iopt=8
            dist2=dist111
          end if
          if (iopt .eq. 8) then
c           Examine signs
            if (x1 .gt. 0.0) iopt=iopt+4
            if (x2 .gt. 0.0) iopt=iopt+2
            if (x3 .gt. 0.0) iopt=iopt+1
          end if
          if (iopt .gt. 1) then
            x1=x1+cic(1,iopt)
            x2=x2+cic(2,iopt)
            x3=x3+cic(3,iopt)
          end if
        end if
      else
c-------Input boundary conditions
        dist2=10000.0
        do i=1,ncell
          r2=(x1+cic(1,i))**2+(x2+cic(2,i))**2+(x3+cic(3,i))**2
          if (r2 .lt. dist2) then
            iopt=i
            dist2=r2
            if (r2 .le. rinscs) go to 90
          end if
        end do
c       Now shift to the minimum image
90      if (iopt .gt. 1) then
          x1=x1+cic(1,iopt)
          x2=x2+cic(2,iopt)
          x3=x3+cic(3,iopt)
        end if
        dist2=x1*x1+x2*x2+x3*x3
      end if
      return
      end
      subroutine clfn(x,y,hlfedg,iop0,iopa,iopb,iopt)
c#    MMC routine 230 lstmod: 06/15/01
c*****Auxiliary routine for FCC PBC
c     Originally written by J.C. Owicki
      iopt=1
      xpy=x+y
      xmy=x-y
      nout=0
      if (xmy .gt. -hlfedg .and. xmy .le. hlfedg) then
        nout=nout+1
        if (xpy .le. -hlfedg) then
          iopt=iop0+2
        else if (xpy .gt. hlfedg) then
          iopt=iop0+3
        end if
      end if
      if (xpy .gt. -hlfedg .and. xpy .le. hlfedg) then
        nout=nout+1
        if (xmy .le. -hlfedg) then
          iopt=iop0+4
        else if (xmy .gt. hlfedg) then
          iopt=iop0+5
        end if
      end if
      if (nout .eq. 0) then
        if (abs(x) .lt. hlfedg) then
          if (y .lt. 0.0) then
            iopt=iopb+1
          else
            iopt=iopb
          end if
        else
          if (x .lt. 0.0) then
            iopt=iopa+1
          else
            iopt=iopa
          end if
        end if
      end if
      return
      end
      subroutine hcp_rotate(x,y,iopt)
c#    MMC routine 230/a lstmod: 05/27/07
c*****Rotates the X,Y coordinates around the Z axis by +/- 60 deg
      common /hcp_rotmat/ hcprot_p(3,3),hcprot_m(3,3),ishift_pm(19)
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      if (ishift_pm(iopt) .eq. -1) then
        xin=x
        yin=y
        x=0.5*xin-sq3p2*yin
        y=sq3p2*xin+0.5*yin
      else if (ishift_pm(iopt) .eq. 1) then
        xin=x
        yin=y
        x=0.5*xin+sq3p2*yin
        y=-sq3p2*xin+0.5*yin
      end if
      return
      end
      subroutine pbcvec(iop5,nmol0,nvmolg)
c#    MMC routine 231 lstmod: 03/03/08
c*****This subroutine performs the PBC algorithm in vector mode
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /ecell/ cic(3,27),ncell
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      dimension kxx(5),kyy(5),kzz(5)
      data kxx /2,2,1,3,3/,kyy /3,3,0,6,6/,kzz /9,9,0,18,18/,r2 /0.0/
      if (iop5 .eq. 0) then
c       Rectangular periodic boundary conditions
        do i=nmol0,nvmolg
          kx=int(zv(1,i)/edgex2)+3
          ky=int(zv(2,i)/edgey2)+3
          kz=int(zv(3,i)/edge2)+3
          zv(1,i)=zv(1,i)+dex(kx)
          zv(2,i)=zv(2,i)+dey(ky)
          zv(3,i)=zv(3,i)+dez(kz)
          riijjv(i)=zv(1,i)*zv(1,i)+zv(2,i)*zv(2,i)+zv(3,i)*zv(3,i)
          cci(1,i)=dex(kx)
          cci(2,i)=dey(ky)
          cci(3,i)=dez(kz)
c         This line is only needed when proximity analysis is performed
          ivopt(i)=kxx(kx)+kyy(ky)+kzz(kz)
        end do
      else if (iop5 .eq. 1) then
c       Face-centered cubic boundary conditions
        do i=nmol0,nvmolg
          ivopt(i)=1
          abx(i)=abs(zv(1,i))
          aby(i)=abs(zv(2,i))
          abz(i)=abs(zv(3,i))
          cv1(i)=amin1(abx(i),aby(i),abz(i))
          riijjv(i)=zv(1,i)**2+zv(2,i)**2+zv(3,i)**2
        end do
        do i=nmol0,nvmolg
          if (riijjv(i) .gt. rinscs) then
            iopt=1
            if (cv1(i) .eq. abx(i))
     -        call clfn(zv(2,i),zv(3,i),edge2,0,16,18,iopt)
            if (cv1(i) .eq. aby(i))
     -        call clfn(zv(1,i),zv(3,i),edge2,4,14,18,iopt)
            if (cv1(i) .eq. abz(i))
     -        call clfn(zv(1,i),zv(2,i),edge2,8,14,16,iopt)
            ivopt(i)=iopt
          end if
        end do
        do i=nmol0,nvmolg
          cci(1,i)=cic(1,ivopt(i))
          cci(2,i)=cic(2,ivopt(i))
          cci(3,i)=cic(3,ivopt(i))
          zv(1,i)=zv(1,i)+cci(1,i)
          zv(2,i)=zv(2,i)+cci(2,i)
          zv(3,i)=zv(3,i)+cci(3,i)
          riijjv(i)=zv(1,i)**2+zv(2,i)**2+zv(3,i)**2
        end do
      else if (iop5 .eq. 4) then
c       Hexagonal prism boundary conditions
        do i=nmol0,nvmolg
          x1=zv(1,i)
          x2=zv(2,i)
          x3=zv(3,i)
c         Determine the 2-d hexagonal nearest image
c         first work in the (+,+) quarter
          x=abs(x2)
          y=abs(x3)
c         i2or3: 1 if y>x/sqrt(3) (->cell 1 or 2) and 0 otherwise(->cell 1 or 3)
          d2or3=y-x/sq3
          ic2or3=sign(1.0,d2or3)
          i2or3=(ic2or3+1)/2
c         i1or23 : 1 if outside central cell (cell 2 or 3), 0 otherwise (cell 1)
c         Flip sign, so d1or23=0.0 will result in i1or3=0
c         d1or23=x/chexdx(i2or3+1)+y*i2or3-chexy(i2or3+1)
          d1or23=chexy(i2or3+1)-x/chexdx(i2or3+1)-y*i2or3
          ic1r23=sign(1.0,d1or23)
c         i1or23=(ic1r23+1)/2
          i1or23=(1-ic1r23)/2
c         First figure only the segment, either in central or outside
          i23=3-i2or3
c         Transform to the quarter of (x2,x3)
          ix3=sign(1.0,x3)
          ix2=sign(1.0,x2)
          ifx3=(ix3+1)/2
          ifx2=(ix2+1)/2
c         Transpose over the y axis of the hexagon, if needed
          itop=i23*ifx3+(6-i23)*(1-ifx3)
c         Transpose over the x axis of the hexagon, if needed
          iall=itop*ifx2+(9-itop)*(1-ifx2)
c         Change to 1 if it was inside the hexagon
          ivopt(i)=iall*i1or23+(1-i1or23)
c         Finally, look at the x direction
          kx=int(x1/edgex2)+3
          dpbcx=dexhex(kx)
          zv(1,i)=zv(1,i)+dpbcx
          cci(1,i)=dpbcx
        end do
        do i=nmol0,nvmolg
          ioptv=ivopt(i)
          dpbcy=cic(2,ioptv)
          dpbcz=cic(3,ioptv)
          zv(2,i)=zv(2,i)+dpbcy
          zv(3,i)=zv(3,i)+dpbcz
          riijjv(i)=zv(1,i)*zv(1,i)+zv(2,i)*zv(2,i)+zv(3,i)*zv(3,i)
          cci(2,i)=dpbcy
          cci(3,i)=dpbcz
        end do
      else if (iop5 .eq. 2) then
c       HCP (just a copy of pbcnd version)
        do i=nmol0,nvmolg
          x1=zv(1,i)
          x2=zv(2,i)
          x3=zv(3,i)
          xs=x1*x1
          ys=x2*x2
          zs=x3*x3
          dist2=xs+ys+zs
          riijjv(i)=dist2
          iopt=1
          if (dist2 .gt. rinscs) then
c           Work in the (+,+/-,+) quadrant
            ax=abs(x1)
            az=abs(x3)
            if (x2 .ge. 0.0) then
c             iopt=1,2,3,8,9 or 12
              if (ax .gt. edgex2)  then
c               iopt=2,3,9 or 12
                if (x2 .lt. ax/sq3) then
c                 iopt=2,9 or 12
                  if (x2 .lt. edgpsq3-ax/sq3) then
c                   iopt=2 or 9
                    if ((ax-edgexa)**2+ys+zs .lt.(ax-edgex2)**2+
     -                (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                      iopt=2
                    else
                      iopt=9
                    end if
                  else
c                   iopt=2 or 12
                    if ((ax-edgexa)**2+ys+zs .lt. (ax-edgexa)**2+
     -                (x2-edgpsq3)**2+(az-edgsq2p3)**2) then
                      iopt=2
                    else
                      iopt=12
                    end if
                  end if
                else
c                 iopt=3 or 12
                  if ((ax-edgex2)**2+(x2-edgsq3p2)**2+zs .lt.
     -              (ax-edgexa)**2+(x2-edgpsq3)**2+(az-edgsq2p3)**2)
     -               then
                    iopt=3
                  else
                    iopt=12
                  end if
                end if
              else
c               iopt=1,8,3 or 9
                if (x2 .lt. ax/sq3) then
c                 iopt=1 or 9
                  if (dist2 .gt. (ax-edgex2)**2+
     -                (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                    iopt=9
c                 else iopt=1
                  end if
                else
c                 iopt=1,3 or 8
                  if (x2 .gt. edgpsq3-ax/sq3) then
c                   iopt=3 or 8
                    if (xs+(x2-edgpsq3)**2+(az-edgsq2p3)**2 .lt.
     -                  (ax-edgex2)**2+(x2-edgsq3p2)**2+zs) then
                      iopt=8
                    else
                      iopt=3
                    end if
                  else
c                   iopt=1 or 8
                    if (dist2 .gt.
     -                xs+(x2-edgpsq3)**2+(az-edgsq2p3)**2) then
                      iopt=8
c                   else iopt=1
                    end if
                  end if
                end if
              end if
            else
c             iopt=1,2,4,9, or 11
              if (ax .gt. edgex2)  then
c               iopt=2,4, or 9
                if (x2 .gt. -edgp2sq3-(ax-edgex2)/sq3) then
c                 iopt=2 or 9
                  if ((ax-edgexa)**2+ys+zs .lt. (ax-edgex2)**2+
     -                (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                    iopt=2
                  else
                    iopt=9
                  end if
                else
c                 iopt=4 or 9
c                 dx=ax-edgex2 cancels
                  if ((x2+edgsq3p2)**2+zs .lt.
     -              (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                    iopt=4
                  else
                    iopt=9
                  end if
                end if
              else
c               iopt=1,4,9, or 11
                if (x2 .gt. -edgpsq3-ax/sq3) then
c                 iopt=1,4,or 9
                  if (x2 .lt. -edgpsq3+ax/sq3) then
c                   iopt=4,or 9
c                   dx=ax-edgex2 cancels
                    if ((x2+edgsq3p2)**2+zs .lt.
     -                (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                      iopt=4
                    else
                      iopt=9
                    end if
                  else
c                   iopt=1 or 9
                    if (dist2 .gt. (ax-edgex2)**2+
     -                  (x2+edgp2sq3)**2+(az-edgsq2p3)**2) then
                      iopt=9
c                   else iopt=1
                    end if
                  end if
                else
c                 iopt=4 or 11
                  if ((ax-edgex2)**2+(x2+edgsq3p2)**2+zs .lt.
     -                xs+(x2+edg2psq3)**2+(az-edgsq2p3)**2) then
                    iopt=4
                  else
                    iopt=11
                  end if
                end if
              end if
            end if
            if (x1 .lt. 0.0) then
              if (iopt .eq. 9 .or. iopt .eq. 12) then
                iopt=iopt+1
              else if (iopt .gt. 1 .and. iopt .lt. 5) then
               iopt=iopt+3
              end if
            end if
            if (iopt .gt. 7) then
              if (x3 .lt. 0.0) iopt=iopt+6
            end if
            if (iopt .gt. 1) then
              zv(1,i)=zv(1,i)+cic(1,iopt)
              zv(2,i)=zv(2,i)+cic(2,iopt)
              zv(3,i)=zv(3,i)+cic(3,iopt)
              call hcp_rotate(zv(1,i),zv(2,i),iopt)
              riijjv(i)=zv(1,i)*zv(1,i)+zv(2,i)*zv(2,i)+zv(3,i)*zv(3,i)
            end if
          end if
          cci(1,i)=cic(1,iopt)
          cci(2,i)=cic(2,iopt)
          cci(3,i)=cic(3,iopt)
          ivopt(i)=iopt
        end do
      else if (iop5 .eq. 3) then
c       TOCT
        do i=nmol0,nvmolg
          x1=zv(1,i)
          x2=zv(2,i)
          x3=zv(3,i)
          xs=x1*x1
          ys=x2*x2
          zs=x3*x3
          riijjv(i)=xs+ys+zs
          iopt=1
          if (riijjv(i) .gt. rinscs) then
            xa=abs(x1)
            ya=abs(x2)
            za=abs(x3)
            dist111=(xa-edgexa)**2+(ya-edgexa)**2+(za-edgexa)**2
            if (xa .gt. edgexa) then
              dist2x=(xa-et3)**2+ys+zs
              if (dist2x .lt. dist111) then
                iopt=2
                if (x1 .lt. 0.0) iopt=3
                r2=dist2x
              else
                iopt=8
                r2=dist111
              end if
            else if (ya .gt. edgexa) then
              dist2y=xs+(ya-et3)**2+zs
              if (dist2y .lt. dist111) then
                iopt=4
                if (x2 .lt. 0.0) iopt=5
                r2=dist2y
              else
                iopt=8
                r2=dist111
              end if
            else if (za .gt. edgexa) then
              dist2z=xs+ys+(za-et3)**2
              if (dist2z .lt. dist111) then
                iopt=6
                if (x3 .lt. 0.0) iopt=7
                r2=dist2z
              else
                iopt=8
                r2=dist111
              end if
            else if (riijjv(i) .gt. dist111) then
              iopt=8
              r2=dist111
            end if
            if (iopt .eq. 8) then
c             Examine signs
              if (x1 .gt. 0.0) iopt=iopt+4
              if (x2 .gt. 0.0) iopt=iopt+2
              if (x3 .gt. 0.0) iopt=iopt+1
            end if
            if (iopt .gt. 1) then
              zv(1,i)=zv(1,i)+cic(1,iopt)
              zv(2,i)=zv(2,i)+cic(2,iopt)
              zv(3,i)=zv(3,i)+cic(3,iopt)
              riijjv(i)=r2
            end if
          end if
          cci(1,i)=cic(1,iopt)
          cci(2,i)=cic(2,iopt)
          cci(3,i)=cic(3,iopt)
          ivopt(i)=iopt
        end do
      else if (iop5 .eq. 5) then
c       Sphere boundary conditions
        do i=nmol0,nvmolg
          riijjv(i)=zv(1,i)*zv(1,i)+zv(2,i)*zv(2,i)+zv(3,i)*zv(3,i)
          ivopt(i)=1
          if (riijjv(i) .gt. rinscs) ivopt(i)=2
          cci(1,i)=0.0
          cci(2,i)=0.0
          cci(3,i)=0.0
        end do
      else if (iop5 .eq. 6) then
c       Primary hydration shell
        do i=nmol0,nvmolg
          riijjv(i)=zv(1,i)*zv(1,i)+zv(2,i)*zv(2,i)+zv(3,i)*zv(3,i)
          ivopt(i)=1
          cci(1,i)=0.0
          cci(2,i)=0.0
          cci(3,i)=0.0
        end do
      else if (iop5 .eq. 7) then
c       Input boundary conditions
        dist2=10000.0
        do i=nmol0,nvmolg
          ivopt(i)=1
          do ic=1,ncell
            r2=(zv(1,i)+cic(1,ic))**2+(zv(2,i)+cic(2,ic))**2+
     -         (zv(3,i)+cic(3,ic))**2
            if (r2 .lt. dist2) then
              iopt=ic
              riijjv(i)=r2
              if (r2 .le. rinscs) go to 557
            end if
          end do
c         Now shift to the minimum image
557       if (iopt .gt. 1) then
            zv(1,i)=zv(1,i)+cic(1,iopt)
            zv(2,i)=zv(2,i)+cic(2,iopt)
            zv(3,i)=zv(3,i)+cic(3,iopt)
          end if
          cci(1,i)=cic(1,iopt)
          cci(2,i)=cic(2,iopt)
          cci(3,i)=cic(3,iopt)
          ivopt(i)=iopt
        end do
      else if (iop5 .eq. 8) then
c       Rectangular periodic boundary conditions for proximity anal
        do i=nmol0,nvmolg
          kx=int(zv(1,i)/edgex2)+3
          ky=int(zv(2,i)/edgey2)+3
          kz=int(zv(3,i)/edge2)+3
          zv(1,i)=zv(1,i)+dex(kx)
          zv(2,i)=zv(2,i)+dey(ky)
          zv(3,i)=zv(3,i)+dez(kz)
          riijjv(i)=zv(1,i)*zv(1,i)+zv(2,i)*zv(2,i)+zv(3,i)*zv(3,i)
          cci(1,i)=dex(kx)
          cci(2,i)=dey(ky)
          cci(3,i)=dez(kz)
c         This line is only needed when proximity analysis is performed
          ivopt(i)=kxx(kx)+kyy(ky)+kzz(kz)
        end do
      end if
      return
      end
      subroutine edgetogredge(gredge,edgelgr,edgergr,edge,iop79,
     -  limgrl,limgru,gridcent,grll,grlu,iout,nchng,LEVTEST)
c#    MMC routine 232 lstmod: 05/15/07
c*****Get rectangle enclosing the simulation cell
      dimension gredge(3),edgelgr(3),edgergr(3),edge(3),limgrl(3),
     -  limgru(3),gridcent(3),grll(3),grlu(3)
      common /rangen/ xyzlim(3),xyzlm2(3),ixpxo
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      call trnsfr(gredge,xyzlm2,3)
      call zeroiti(limgrl,0,3)
      call zeroiti(limgru,0,3)
      if (iop79 .eq. 0) then
c       Full cell used for the grid
        call zeroit(gridcent,3)
      else
c       Reduced cell used for grid
        npbcl=0
        do k=1,3
          if (grll(k) .gt. -gredge(k)/2.0+1.e-5) then
            limgrl(k)=1
            npbcl=npbcl+1
          else
            grll(k)=-gredge(k)/2.0
          end if
          if (grlu(k) .lt. gredge(k)/2.0-1.e-5) then
            limgru(k)=1
            npbcl=npbcl+1
          else
            grlu(k)=gredge(k)/2.0
          end if
          gridcent(k)=(grll(k)+grlu(k))/2.0
          gredge(k)=grlu(k)-grll(k)
        end do
        if (npbcl .eq. 0) then
          if (MYRANK .eq. 0) write (iout,1000)
          iop79=0
          nchng=nchng+1
        end if
      end if
      do k=1,3
        edgelgr(k)=gridcent(k)-gredge(k)/2.0
        edgergr(k)=gridcent(k)+gredge(k)/2.0
      end do
      if (LEVTEST .gt. 0) write (iout,1001) edge,gredge,limgrl,limgru
      return
1000  format(' >>>>> OVERRIDE: limits read with LIMG did not reduce ',
     -  ' the grid - LIMG key is ignored')
1001  format(' EDGETOGREDGE edge=',3f10.5,' gredge=',3f10.5,' limgrl=',
     -  3i2,' limgru=',3i2)
      end
      subroutine inicpl(faclim,cplpar,cplimn,cplimx,iopus,tolera)
c#    MMC routine 233 lstmod: 05/19/16
c*****Initialize the pi/pj method accumulators, parameters
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      common /sweep/ nsweep,nlast,nswavg,nswav2,minswp,maxswp,
     -  nswpit(#WI),nswrep(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      real*8 fac
c     dstcpl(i),dstcplsum(i): accumulators for weighted frequencies of the
c     cpl par. per iteration and total run.
c     uwcplo, uwcpln: us weight before and after a perturbation
c     uwtav: accumulator for reciprocal us weight.
c     nfisum(k), nfismo(k): number of configurations in the grid k for the
c     current and previous adaptive iteration.
c     encfac(k): encouragement factor to steer toward abandoned regions
      g0cpl=2.0/#WG.0
      d00cpl=-0.5
      d0cpl=d00cpl-g0cpl/2.0
c     The number of repetitions and interval sweeps for each iteration are
c     saved in nswrep and nswpit, resp.
      do k=1,#WI
        nswrep(k)=1
        nswpit(k)=0
        iterz(k)=0
      end do
c     nsweep is the number of times the cpl par went from one end of the range
c     to the other (one sweep), nlast is 1 when lambda is in the left end and
c     2 when it is at the right end
      nsweep=0
      nlast=0
      do k=1,#WG
        cpl(k)=d00cpl+k*g0cpl
        dstcpl(k)=0.d0
        dstcplsum(k)=0.d0
        wcplus(k)=1.0d0
        pbzavg(k)=0.0
        nfisum(k)=0
        nfisum_prev(k)=0
        nfismo(k)=0
        encfac(k)=1.0
        eincpl(k)=0.0
        upmftot(k)=0.d0
        upmftv(k)=0.d0
        upmftt(k)=0.d0
        upmftotsum(k)=0.d0
        upmftvsum(k)=0.d0
        upmfttsum(k)=0.d0
      end do
      uwtav=0.d0
      cplimn=cplpar
      cplimx=cplpar
      kgimno=(cplpar-d0cpl)/g0cpl
      kgimxo=kgimno
      kp1mn=(cplmin-d0cpl)/g0cpl
      kp1mx=(cplmax-d0cpl)/g0cpl
      kgamn=kgimno
      kgamx=kgimxo
      kp1zro=(0.0-d0cpl)/g0cpl
      kp1one=(1.0-d0cpl)/g0cpl
c     ktol is the number of grids allowed outside kp1zro and kp1one
      ktol=tolera/g0cpl
      if (kp1zro-kgimno .gt. ktol) ktol=kp1zro-kgimno
      if (kgimno-kp1one .gt. ktol) ktol=kgimno-kp1one
      iterw=0
      iterws=0
      nitskp=0
      newlim=0
      nsets=1
      ifirst(1)=1
      limit1(1)=1
      limit2(1)=1
c     Modify w-s to discourage sampling outside the required range
      k1=kp1mn-1
      fac=1.0d0
      do l=1,k1
        k=k1-l+1
        if (fac .gt. 1.d+6/(faclim*dpmx)) fac=fac*faclim
        wcplus(k)=wcplus(kp1mn)*fac
      end do
      k2=kp1mx+1
      fac=1.0d0
      do k=k2,#WG
        if (fac .gt. 1.d+6/(faclim*dpmx)) fac=fac*faclim
        wcplus(k)=wcplus(kp1mx)*fac
      end do
      call cplweight(cplpar,uwcplo,iopus)
      uwcplo=1.0d0/uwcplo
      uwcpln=uwcplo
      igleft=kp1mn+1
      igright=kp1mx-1
      return
      end
      subroutine print_cplw(cpl,wd,ws,isd,n,title,ltitle,iout)
c#    MMC routine 233/a lstmod: 08/10/12
c*****Print a list of weights with the associated cpl parameter
      real*8 wd
      dimension cpl(n),wd(n),ws(n)
      character*(*) title
      if (n .lt. 1) return
      write (iout,1000) title(1:ltitle)
      nleft=n
      nprint=0
      do while (nprint .lt. n)
        kfst=nprint+1
        klst=min0(nprint+10,n)
        nprint=klst
        if (isd .eq. 1) then
          write (iout,1001) cpl(kfst),cpl(klst),(wd(k),k=kfst,klst)
        else
          write (iout,1001) cpl(kfst),cpl(klst),(ws(k),k=kfst,klst)
        end if
      end do
      return
1000  format(/,1x,a)
1001  format(' CPL: [',f5.2,',',f5.2,'] W:',10e11.4)
      end
      subroutine cplweight(cplpar,wtfcpl,iopus)
c#    MMC routine 234 lstmod: 04/22/04
c*****Compute the US weighting fct for 1-d parameter
      real*8 wtfcpl
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /option/ iop(200),idebug(200)
c     g0cpl: grid interval for cplpar distribution
c     d0cpl: left (lower) limit of the first grid point
      if (iop(38) .eq. 2) then
c       Don't allow cplpar outside the [0,1] interval when full pf changes
        if (cplpar .lt. 0.0 .or. cplpar .gt. 1.0) then
          wtfcpl=1.d+6/dpmx
          return
        end if
      end if
      if (iopus .eq. 0) then
c       Harmonic US
        wtfcpl=exp(-c0cplh*(cplpar-p0cplh)**2)
      else
c       Adaptive umbrella sampling
        iwr=(cplpar-d0cpl)/g0cpl
        if (iwr .lt. kp1zro-ktol .or. iwr .gt. kp1one+ktol) then
c         Don't let the simulation too far out of the [0,1] range
          wtfcpl=1.d+6/dpmx
          return
        end if
        if (iwr .lt. 2) iwr=2
        if (iwr .gt. #WG-1) iwr=#WG-1
        cpiwr=d0cpl+g0cpl/2.0+iwr*g0cpl
        rprop=(cplpar-cpiwr)/g0cpl
        if (iopus .eq. 1) then
c         Linear interpolation
          if (rprop .ge. 0.0) then
            wtfcpl=wcplus(iwr)+rprop*(wcplus(iwr+1)-wcplus(iwr))
          else
            wtfcpl=wcplus(iwr-1)+
     -        (1.0+rprop)*(wcplus(iwr)-wcplus(iwr-1))
          end if
        else if (iopus .eq. 2) then
c         Exponential interpolation
          if (rprop .ge. 0.0) then
            wtfcpl=wcplus(iwr)*(wcplus(iwr+1)/wcplus(iwr))**rprop
          else
            wtfcpl=wcplus(iwr-1)*
     -        (wcplus(iwr)/wcplus(iwr-1))**(1.0+rprop)
          end if
        else
          wtfcpl=1.0
        end if
      end if
      return
      end
      subroutine wadapt(ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,
     -  rldvmx,ngrcor,iopnrm,itadap,nitssk,ioplst,ioptst,iopeql,
     -  iopenc,negitdel,iopvrb,nsubmn,ngovmn,diffmx,iout,ichkp,nwarn,
     -  nwwarn,cplpar,cplimn,cplimx,beta,iuponl,nmc,MYRANK)
c#    MMC routine 235 lstmod: 10/02/12
c*****Compute new w table from u distribution
c     ratmax: maximum ratio of subsequent w(i)'s allowed after smoothing
c     smplmx: no smoothing is done if sampling is at least smplmx fraction
c     of the best sampled grid
c     faclim: ratio of neighbouring w's set to limit the run
c     fcenc1: ratio of neighbouring w's to extend sampling  if needed
c     fcenc2: weight factor for grids that are unsampled (iopenc=1 or 3)
c     ngrcor: number of grids to force after shrinking
c     iopnrm =-1 : linear n-step optimization on probabilities
c     iopnrm =-2 : linear n-step optimization on pmf's
c     iopnrm =-3 : gridwise calculation of the pmf's
c     iopnrm = 0 : non-linear n-step optimization, no new initial guess gen.
c     iopnrm > 0 : non-linear n-step optimization,    new initial guess is
c                  is generated at every iopnrm-th iteration.
c     itadap > 0 : continue iter if (at least) itadap sweeps were done
c     iopeql .gt. 0 : self-checking for equilibration
c     iopenc .gt. 0 : scale grids in adaptive us to extend region.
c     iopenc .gt. 1 : use the extension scheme on just abandoned regions
c     iopenc .eq. 1 or 3: gradually increase the weight of gridpoints
c                      as long as they are unsampled.
c     iopenc .lt. 0 : Weights based on sampling rate, not Boltzmann probs
c     iopvrb: 0/1/2: No detail/detail/lots of detail printed
c     nitssk: number of iterations to be skipped in equilibration
c     ioptst: if iteration no is le ioptst, storage array contents will be
c             printed; if =#WI, run will stop after saving the
c             iteration data.
c     ngovmn: each pair of iterations is examined if at least
c     ngovmn grids overlap.
c     diffmx: violation occurs if the overlap index is greater than diffmx.
c     nsubmn: the iteration is rejected if more than (nsubov-1)/nsubmn+1
c     violations found when the iteration overlaps with nsubov subsequent
c     iterations.
c     cplpar: value of the 1-d parameter
c     iuponl : if = 1, only generate wcplus from pbzavg or nfisum
c     cplimn,cplimx: min  and max of coupling paramater for the last iteration
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /sweep/ nsweep,nlast,nswavg,nswav2,minswp,maxswp,
     -  nswpit(#WI),nswrep(#WI)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      real*8 gisum,psum
      common /wwork/ gisum(#WG),ami(#W2)
      common /eval/ nfceva,kount
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      character*40 itcplp
      common /cplnames/ itcplp
      dimension nfisoo(#WG)
      dimension rndlst(#WG),nlstit(#WG),wpnew(#WG)
      real*8 fac
      data kgimn /0/,kgimx /0/,ndhlsts /0/,rndhmx /0.0/,nginc /0/
c     pbzavi: p(u) for the last iteration
c     pbzavg: p(u) for the complete run (to be updated)
c     wcplus: weighting function smoothed and manipulated
c     iterw: number of iterations used
c     iterws: number of iterations stored
c     nsets: number of disjoint interval sets
c     limgr1,limgr2: first and last gridpoints of the disjoint clusters
c     limit1,limit2: first and last iterations of the disjoint sets
c     ifirst(i),ilast(i) : position of first and last data points for
c     iteration i in the linear storage arrays nfikl,pikl.
c     kstart(i): the bin number of the data stored at ifirst(i) in
c     nfikl,pikl is kstart(i).
c     kgimn,kgimx: min and max gridpoint sampled in this iteration
c     kgimno,kgimxo: min and max gridpoint sampled in the previous iteration
c     kgamn,kgamx: min and max gridpoint sampled in the whole run
c     kgamno,kgamxo: min and max gridpoint sampled up to the previous iteration
c     kp1mn,kp1mx: min and max gridpoints to be sampled
c     kclst1,kclst2: limgr1(is),limgr2(is) for the cluster just handled
c     istr1,istr2: limit1(is),limit2(is) for the cluster just handled
c     nitskp: counter of iteration skipped
c     newlim: if set to 1, newly inputted range is to be reached
c             and nitssk iterations to be skipped
      encfacmax=rlsqmx
      if (MYRANK .eq. 0) write (iout,2037) 'Start',nmc
      ratmxi=1.0/ratmax
      if (iuponl .eq. 1) then
c       Just get the weights
        call gen_weights(wcplus,pbzavg,nfisum,nfisum_prev,iopenc,encexp)
        go to 1111
      end if
      if (iterws .lt. iterw) iterws=iterw
c     Increment iterws only before the csave call
      itrwss=iterws+1
      iterw=iterw+1
      if (MYRANK .eq. 0) write (iout,2011) itrwss,cplimn,cplimx,nsweep
      if (iopeql .ne. 0) then
        ndrop=iterws-iterw+1
        if (MYRANK .eq. 0) write (iout,2006) ndrop
      end if
      cplimn=cplpar
      cplimx=cplpar
c     Find the range sampled in this iteration (don't use end point)
      kgimn=2
      do k=2,#WG
        kgimn=k
        if (nfisum(k) .gt. nfismo(k)) go to 171
      end do
171   nwgrd1=#WG-1
      kgimx=nwgrd1
      do l=kgimn,nwgrd1
        k=kgimn+nwgrd1-l
        kgimx=k
        if (nfisum(k) .gt. nfismo(k)) go to 173
      end do
173   ndh0sm=0
      psum=0.d0
      ndhlsts=0
      do k=1,#WG
        ndh0sm=ndh0sm+nfisum(k)
        ndhlsts=ndhlsts+(nfisum(k)-nfismo(k))
        nlstit(k)=nfisum(k)-nfismo(k)
        psum=psum+dstcpl(k)
      end do
c     Normalize the cpl param distribution
      if (psum .eq. 0.d0) psum=1.d0
      do k=1,#WG
        pbzavi(k)=dstcpl(k)/psum
      end do
      if (MYRANK .eq. 0) call print_cplw(cpl(kgimn),wcplus,
     -  pbzavi(kgimn),2,kgimx-kgimn+1,
     -  'Probability distribution in the latest iteration',48,iout)
      nswpit(iterw)=nswpit(iterw)+nsweep
      nsweep=0
      if (nsweep .gt. itadap .and. itadap .gt. 0) then
        nswrep(iterw)=nswrep(iterw)+1
        iterw=iterw-1
        if (MYRANK .eq. 0) write (iout,2009)
        if (MYRANK .eq. 0) write (iout,2037) 'Start',nmc
        return
      end if
      kgimn0=max0(kgimn,kp1mn-3)
      kgimx0=min0(kgimx,kp1mx+3)
      nlimst=0
      if (kgimx .lt. kp1mn .or. kgimn .gt. kp1mx) then
c       Skip iteration because it is completely outside the coupling par range
        if (MYRANK .eq. 0) write (iout,2036) cplmin,cplmax
        nitskp= -2
        go to 245
      end if
      kgamno=kgamn
      kgamxo=kgamx
      if (kgamn .gt. kgimn) kgamn=kgimn
      if (kgamx .lt. kgimx) kgamx=kgimx
      if (newlim .ne. 0) then
c       Parameter limits have been changed on input and equilibration was
c       requested.
        nlimst=1
        nitskp= -2
        if (MYRANK .eq. 0) write (iout,2031)
        if (min0(kgimx0-kp1mn,kp1mx-kgimn0) .ge. 3) then
c         New range has been penetrated by this iteration
          if (MYRANK .eq. 0) write (iout,2030)
          nitskp= -1
          newlim=0
        end if
      else if (iterw .gt. 1 .and. iopenc .gt. 0 .and.
     -        (kgimn0+3 .le. kgamno .or. kgimx0-3 .ge. kgamxo)) then
c       Significantly new range was reached, drop iteration
        if (MYRANK .eq. 0) write (iout,2024)
        nitskp= -1
      end if
245   if (nitskp .ne. 0 .and. nitskp .lt. nitssk) then
c       (Continue) skip(ping) if required
        if (nitskp .gt. 0) then
          nitskp=nitskp+1
          if (MYRANK .eq. 0) write (iout,2032) nitskp
        else if (nitskp .eq. -1) then
          nitskp=1
        else
          nitskp=0
        end if
c       Drop iteration
        do k=1,#WG
          dstcpl(k)=0.d0
          upmftot(k)=0.d0
          upmftv(k)=0.d0
          upmftt(k)=0.d0
          nfisum(k)=nfismo(k)
        end do
        kgimno=kgimn
        kgimxo=kgimx
        iterw=iterw-1
        if (nlimst .gt. 0) go to 180
        return
      end if
      nitskp=0
      if (iterw .le. 1) then
c       Initialize group limits
        limgr1(1)=kgimn0
        limgr2(1)=kgimx0
      end if
c     Compute primitive (unweighted) norm
      pavism=0.0
      pavgsm=0.0
      do k=kgamn,kgamx
        if (pbzavi(k) .ne. 0.0 .and. nfisum(k) .ne. 0) then
          pavism=pavism+pbzavi(k)
          pavgsm=pavgsm+pbzavg(k)
        end if
      end do
      if (iopnrm .eq. -3) then
c       Gridwise pmf calculation
        rnrmo1=0.0
      else
        rnrmpr=1.0
        if (pavgsm .ne. 0.0 .and. pavism .ne. 0.0) rnrmpr=pavgsm/pavism
c       Compute 1-step optimized norm
        ioutopt1=0
        if (iopvrb .gt. 1) ioutopt1=iout
        rnrmo1=opt1st(0,ioutopt1,MYRANK)
        if (iopvrb .gt. 1 .and. MYRANK .eq. 0)
     -    write (iout,2013) rnrmpr,rnrmo1
      end if
c     Optimize all norms at all steps
      rnorm=1.0
c     Get relative frequency of sampling for each grid and its maximum
      if (ndh0sm .eq. 0) ndh0sm=1
      rndhmx=0.0
      do k=1,#WG
        rndh(k)=float(nfisum(k))/float(ndh0sm)
        if (rndhmx .lt. rndh(k)) rndhmx=rndh(k)
      end do
c     Save current iteration data in nfikl, pikl
      if (itrwss .gt. 1) ifirst(itrwss)=ilast(itrwss-1)+1
      kk=ifirst(itrwss)-1
      nksm=0
      do k=kgimn0,kgimx0
        kk=kk+1
        nfikl(kk)=nfisum(k)-nfismo(k)
        nksm=nksm+nfikl(kk)
        if (nfikl(kk) .eq. 0) then
          wikl(kk)=0.0
        else
          wikl(kk)=-alog(pbzavi(k))/beta
        end if
        pikl(kk)=pbzavi(k)
      end do
      ilast(itrwss)=kk
      kstart(itrwss)=kgimn0
c     ixiter(i): the original iteration number of the i-th iteration
c     nfksum,ifirst,ilast,kstart, pikl,nfikl store the iteration information
c     in the original order,
c     limit1, limit2, rnrmo2, grad refer to the rearranged order,
c     necessitated by the grouping of overlapping iterations.
      ixiter(iterw)=itrwss
c     nfksum(i): number of configurations spent in the relevant
c     part of the cpl par range in iteration i.
      nfksum(itrwss)=nksm
      iterws=itrwss
c     Move nfismo into nfisum now in case minimization runs out of time
      call trnsfi(nfisoo,nfismo,#WG)
      call trnsfi(nfismo,nfisum,#WG)
      call csave(ichkp,1,iskipfail,1)
      if (ioptst .eq. #WI) then
        if (MYRANK .eq. 0) write (iout,2010)
        call datprt(1)
      end if
      nspace=#WS-kk
      if (nspace .lt. #WS/10 .or. iopvrb .gt. 1) then
        if (MYRANK .eq. 0) write (iout,2028) nspace
        if (nspace .lt. #WS/10) then
          if (MYRANK .eq. 0) write (iout,2029)
          nwarn=nwarn+1
        end if
      end if
      call checkdim(ifail,iout,inperr,'WS',kk,0,0,0)
      if (ifail .gt. 0) call datprt(2)
      if (iterws .lt. ioptst .and. iopvrb .gt. 1 .and.
     -    MYRANK .eq. 0) then
        write (iout,3000) (ifirst(i),i=1,iterws)
        write (iout,3001) (ilast(i),i=1,iterws)
        write (iout,3002) (kstart(i),i=1,iterws)
        write (iout,3006) limit1,limit2,limgr1,limgr2
        im=ilast(iterws)
        write (iout,3004) (nfikl(i),i=1,im)
        write (iout,3005) iterw,nsets,kgimn0,kgimx0
      end if
      rnrmo2(iterws)=1.0d0
      if (iterws .gt. 1) then
        call clstru(iout,isetac,rnrmo1,MYRANK)
        if (iterws .lt. ioptst .and. iopvrb .gt. 1 .and.
     -      MYRANK .eq. 0) then
          write (iout,3001) (ilast(i),i=1,iterws)
          write (iout,3007) (ixiter(i),i=1,iterws)
          write (iout,3006) limit1,limit2,limgr1,limgr2
          write (iout,3005) iterw,nsets,kgimn0,kgimx0
        end if
        if (iopeql .gt. 0 .and. iterw .gt. 2)
     -    call scrnit(0,isetac,nitdel,nsubmn,ngovmn,diffmx,
     -        0,beta,iopnrm,nwwarn,iout,MYRANK)
c       Optimize only the cluster of the last iteration
        istr1=limit1(isetac)
        istr2=limit2(isetac)
        istr21=istr2-1
        nvars=istr2-istr1
      else
        nvars=0
      end if
      if (nvars .gt. 0 .and. iterws .gt. 0) then
        kclst1=limgr1(isetac)
        kclst2=limgr2(isetac)
        if (nsets .gt. 1 .and. MYRANK .eq. 0) write (iout,2026)
     -    isetac,istr1,istr2,kclst1,kclst2
        istrdl=istr1-1
        if (iopnrm .ge. 0) then
c         Matching by minimizing the relative deviation square sum (requires
c         nonlinear minimizer) - used for matching in the probability space
          if (iopnrm .eq. 0) then
c           Minimize without fresh initial guess generation
            call nlnmin(3,rldvmx,nwwarn,iout,MYRANK)
          else if (mod(iterw,iopnrm) .ne. 1) then
            call nlnmin(3,rldvmx,nwwarn,iout,MYRANK)
          else
c           Minimize with new initial guess generation. It will sort the
c           iterations by the interval covered and obtain the match without
c           using the previous PMF estimate
            if (MYRANK .eq. 0) write (iout,2004)
            call nlnmin(2,rldvmx,nwwarn,iout,MYRANK)
          end if
          if (negitdel .gt. 0) then
            do it=1,iterw
              if (rnrmo2(it) .eq. 0)
     -          iterz(ixiter(it))=iterz(ixiter(it))+1
            end do
          end if
        else
c         Matching by minimizing the deviation square sum (requires solving a
c         system of linear equations at worst) - used mostly for matching
c         in the PMF space.
          if (nvars*(nvars+1) .ge. #W2 .and. iopnrm .ge. -2) then
            if (MYRANK .eq. 0) write (iout,2033)
            call csave(ichkp,0,iskipfail,1)
            call datprt(2)
          end if
          if (iopnrm .eq. -1) then
c           Probability space matching - do not use unless PMF is very flat
            do k=1,#WG
              pbzavi(k)=1.0
            end do
            call linopt(ier,iout,MYRANK)
          else if (iopnrm .eq. -2) then
c           PMF space matching (Bartels & Karplus)
            rnrmo2(istr2)=1.0d0
            dvsm=wdevsm(istr1,istr2,kclst1,kclst2,beta)
            if (MYRANK .eq. 0) write (iout,2017) dvsm
            if (iopvrb .gt. 1) then
c             Comparing PMF matching option with rel dev matching
c             (not needed for production runs, only for testing the method)
              call devsum(nvars+1,rnrmo2(istr1),dvsm,grad,0)
              if (MYRANK .eq. 0)
     -          write (iout,2019)'relative','before',dvsm
              dvsm=wdevsm(istr1,istr2,kclst1,kclst2,beta)
              if (MYRANK .eq. 0) write (iout,2019) 'PMF','before',dvsm
              call nlnmin(2,rldvmx,nwwarn,iout,MYRANK)
              do i=1,iterw
                rnrmo2(i)=rnrmo2(i)/rnrmo2(iterw)
              end do
              if (MYRANK .eq. 0) write (iout,2038) (rnrmo2(i),i=1,iterw)
              call devsum(nvars+1,rnrmo2(istr1),dvsm,grad,0)
              if (MYRANK .eq. 0)
     -          write (iout,2019) 'relative','after',dvsm
            end if
            call linopw(ier,beta,iout,MYRANK)
          else
c           PMF matching of neighboring grid differences only (van Eijck et al.)
            call linsmp(beta)
            go to 290
          end if
          if (ier .ne. 0 .and. MYRANK .eq. 0) write (iout,2018) ier
c         Compute rel. dev sum while preparing the new combined p(lambda)
c         from rnrmo2.
          call devsum(nvars+1,rnrmo2(istr1),dvsm,grad,0)
          if (MYRANK .eq. 0) write (iout,2020) dvsm
          if (iopnrm .eq. -2) then
c           Compute dev sum and new combined p(lambda) from the pmf sum
            dvsm=wdevsm(istr1,istr2,kclst1,kclst2,beta)
            if (MYRANK .eq. 0) write (iout,2023) dvsm
          end if
        end if
        if (iopvrb .gt. 1 .and. MYRANK .eq. 0) write (iout,2016)
     -    (rnrmo2(i),i=1,iterw)
      end if
      if (nvars .le. 0 .or. iterws .eq. 1) then
        do k=1,#WG
          if (nfisum(k) .ne. 0) pbzavg(k)=(pbzavg(k)*float(nfisoo(k))+
     -      float(nfisum(k)-nfisoo(k))*rnorm*pbzavi(k))/float(nfisum(k))
          end do
      end if
c     Compute wcplus from pbzavg, update nfisoo and reset dstcpl
290   call gen_weights(wcplus,pbzavg,nfisum,nfisum_prev,iopenc,encexp)
      do k=1,#WG
        dstcplsum(k)=dstcplsum(k)+dstcpl(k)
        if (dstcpl(k) .ne. 0.d0) then
          upmftotsum(k)=upmftotsum(k)+nlstit(k)*upmftot(k)/dstcpl(k)
          upmftvsum(k)=upmftvsum(k)+nlstit(k)*upmftv(k)/dstcpl(k)
          upmfttsum(k)=upmfttsum(k)+nlstit(k)*upmftt(k)/dstcpl(k)
          dstcpl(k)=0.d0
          upmftot(k)=0.d0
          upmftv(k)=0.d0
          upmftt(k)=0.d0
        end if
      end do
      if (iopvrb .gt. 1) then
c       pbzavi is not needed any more, put in it -kT*ln(p(u)) for plot
        do k=1,#WG
          pbzavi(k)=0.0
          if (pbzavg(k) .ne. 0.0) pbzavi(k)=-alog(pbzavg(k))/beta
        end do
        nnnxxx=kp1mx-kp1mn+6
        call plot(cpl(kp1mn-3),pbzavi(kp1mn-3),rndh(kp1mn-3),
     -    nnnxxx,0.0,0.0,0.0,0.0,50,1,ioplst,40,20,itcplp,0,0,1)
      end if
1111  if (iopvrb .gt. 1 .and. MYRANK .eq. 0) call print_cplw(cpl,wcplus,
     - encfac,1,#WG,'The new w table before manipulations',36,iout)
c     Eliminate possible middle zeros
      do k=kgamn,kgamx
        if (nfisum(k) .eq. 0) wcplus(k)=wcplus(k-1)
      end do
c     Bring to same scale the possible disjoint sets
      if (nsets .gt. 1) then
        ngaps=nsets-1
        if (MYRANK .eq. 0) write (iout,2027) ngaps
        do j=1,ngaps
          if (limgr1(j+1)-limgr2(j) .gt. 1) then
            k1=limgr2(j)+1
            k2=limgr1(j+1)-1
            do k=k1,k2
              wcplus(k)=wcplus(limgr2(j))
            end do
          end if
          k1=limgr1(j+1)
          wt0=wcplus(k1)
          do k=k1,#WG
            wcplus(k)=wcplus(k)*wcplus(limgr2(j))/wt0
          end do
        end do
      end if
c     Eliminate extreme jumps
      if (smplmx .gt. 0.0 .and. kgamx-kgamn .ge. 3 .and. iuponl .ne. 1)
     -  then
        k1=kgamn+1
        fac=1.0
        do k=k1,kgamx
          if (rndh(k)/rndhmx .le. smplmx .or.
     -          rndh(k-1)/rndhmx .le. smplmx) then
            ratio=fac*wcplus(k)/wcplus(k-1)
            if (ratio .gt. ratmax) fac=fac*(ratmax/ratio)
            if (ratio .lt. ratmxi) fac=fac*(ratmxi/ratio)
          end if
          if (fac .ne. 1.0) wcplus(k)=wcplus(k)*fac
        end do
      end if
c     Eliminate "spikes" from w
      k1=kgamn+2
      k2=kgamx-2
      if (k1 .le. k2) then
        do k=k1,k2
c         Modified version: make sure that wcplus(k) falls between the
c         logarithmic extrapolations from both sides
          wlim1=wcplus(k-1)**2/wcplus(k-2)
          wlim2=wcplus(k+1)**2/wcplus(k+2)
          wmn=amin1(wlim1,wlim2)
          wmx=amax1(wlim1,wlim2)
          wk=wcplus(k)
          if (wk .lt. wmn) wcplus(k)=wmn
          if (wk .gt. wmx) wcplus(k)=wmx
        end do
      end if
      if (iopenc .eq. 1 .or. iopenc .eq. 3) then
        if (iuponl .ne. 1) then
c         Weight the grids based on how late it was sampled
c         Update encfac
          if (kgimn .gt. kp1mn) then
            k2=kgimn-1
            do k=kp1mn,k2
              encfac(k)=encfac(k)*fcenc2
            end do
          end if
          if (kgimx .lt. kp1mx) then
            k1=kgimx+1
            do k=k1,kp1mx
              encfac(k)=encfac(k)*fcenc2
            end do
          end if
          do k=kgimn,kgimx
            encfac(k)=encfac(k)**encexp
          end do
          efacmn=1000.0
          efacmx=0.0
          do k=kp1mn,kp1mx
            if (encfac(k) .gt. encfacmax) encfac(k)=encfacmax
            if (efacmn .gt. encfac(k)) efacmn=encfac(k)
            if (efacmx .lt. encfac(k)) efacmx=encfac(k)
          end do
          if (iopvrb .gt. 1 .and. MYRANK .eq. 0)
     -      call print_cplw(cpl,wcplus,encfac,2,#WG,
     -        'Weight modifier factors for sampling extension',46,iout)
          if (MYRANK .eq. 0) write (iout,2008) efacmn,efacmx
        end if
        do k=kp1mn,kp1mx
          wcplus(k)=wcplus(k)*encfac(k)
        end do
      end if
      if (iopenc .eq. 2 .or. iopenc .eq. 3) then
        nginc=0
        if (kgimno .le. kgimn .and. kgimn .ge. kp1mn .and.
     -      rndh(kgimno)/rndhmx .le. 0.5 .and. iuponl .ne. 1)
     -    call promote(-1,wcplus,cpl,kp1mn,kp1mx,kgimn,kgimx,fcenc1,
     -      ngrcor,iout,#WG)
        if (kgimxo .ge. kgimx .and. kgimx .le. kp1mx .and.
     -      rndh(kgimxo)/rndhmx .le. 0.5 .and. iuponl .ne. 1)
     -    call promote(+1,wcplus,cpl,kp1mn,kp1mx,kgimn,kgimx,fcenc1,
     -      ngrcor,iout,#WG)
      else if (iopenc .lt. 0) then
        nginc=ngrcor
        if (kgamn .ge. kp1mn) call promote(-1,wcplus,cpl,kp1mn,kp1mx,
     -    kgamn,kgamx,fcenc1,ngrcor,iout,#WG)
        if (kgamx .le. kp1mx) call promote(+1,wcplus,cpl,kp1mn,kp1mx,
     -    kgamn,kgamx,fcenc1,ngrcor,iout,#WG)
      end if
c     Set the unsampled w-s to constant
180   k1=kgamn-nginc-1
      do k=1,k1
        wcplus(k)=wcplus(kgamn-nginc)
      end do
      k2=kgamx+nginc+1
      do k=k2,#WG
        wcplus(k)=wcplus(kgamx+nginc)
      end do
c     Modify w-s to discourage sampling outside the required range
      k1=kp1mn-1
      fac=1.0
      do l=1,k1
        k=k1-l+1
        if (fac .gt. 1.d+6/(faclim*dpmx)) fac=fac*faclim
        wcplus(k)=wcplus(kp1mn)*fac
      end do
      k2=kp1mx+1
      fac=1.0
      do k=k2,#WG
        if (fac .gt. 1.d+6/(faclim*dpmx)) fac=fac*faclim
        wcplus(k)=wcplus(kp1mx)*fac
      end do
      call cplweight(cplpar,uwcplo,2)
      uwcplo=1.0d0/uwcplo
      if (iopvrb .gt. 1) then
        if (ndhlsts .eq. 0) ndhlsts=1
        do k=1,#WG
          rndlst(k)=float(nlstit(k))/float(ndhlsts)
          wpnew(k)=0.0
          if (wcplus(k) .gt. 0.0) wpnew(k)=dlog(wcplus(k))/beta
        enddo
        if (MYRANK .eq. 0) write (iout,2021)
        nnnxxx=kp1mx-kp1mn+2
        call plot(cpl(kp1mn-1),wpnew(kp1mn-1),rndlst(kp1mn-1),
     -    nnnxxx,0.0,0.0,0.0,0.0,50,1,ioplst,40,20,itcplp,0,0,1)
        if (MYRANK .eq. 0) call print_cplw(cpl,wcplus,encfac,1,
     -    #WG,'The new w table after manipulations',35,iout)
      end if
      sammin=realmx
      sammax=0.0
      ksmin=kp1mn-1
      ksmax=kp1mx+1
      do k=kp1mn,kp1mx
        if (rndh(k) .gt. 0.0) then
          if (rndh(k) .gt. sammax) then
            sammax=rndh(k)
            ksmax=k
          end if
          if (rndh(k) .lt. sammin) then
            sammin=rndh(k)
            ksmin=k
          end if
        end if
      end do
      ngsamp=ksmax-ksmin+1
      if (ngsamp .gt. 1 .and. ngsamp .le. #MI) then
        call var(rndh(kp1mn),ngsamp,sd2,num,ndown,nrun)
        if (MYRANK .eq. 0) write (iout,2014) cpl(ksmax),sammax,
     -    cpl(ksmin),sammin,(sammax/sammin),sd2,nrun
      end if
      if (MYRANK .eq. 0) write (iout,2012) cpl(kp1mn),wcplus(kp1mn),
     -  cpl(kp1mx),wcplus(kp1mx),cplpar,1.0d0/uwcplo,cpl(kp1mn),
     -  pbzavg(kp1mn),cpl(kp1mx),pbzavg(kp1mx)
      if (MYRANK .eq. 0) write (iout,2037) 'End',nmc
      if (iuponl .eq. 1) return
      kgimno=kgimn
      kgimxo=kgimx
      return
2004  format(' +++++ Minimization started from scratch')
2006  format(' Number of iterations dropped a posteriori as',
     -  ' equilibration=',i3)
2008  format(' Smallest and largest weightmodifier (used with ',
     -  'global encouraging)=',e10.2,e10.2)
2009  format(' Iteration continues since the interval is fully',
     -  ' sampled')
2010  format(' AUS iteration data saved and run stopped as requested')
2011  format(' Smallest and largest coupling parameter sampled in ',
     -  'iteration',i4,' =',2f10.4,' Number of sweeps=',i4)
2012  format(' AUS weights at the interval limits: w(',f5.2,')=',e12.5,
     -  '  w(',f5.2,')=',e12.5,', current w(',f6.3,')=',e12.5,/,
     -  ' Sampling probabilities at the interval limits=',
     -  ' p(',f5.2,')=',e12.5,' p(',f5.2,')=',e12.5)
2013  format(' Primitive norm=',e12.5,' 1-step optimized norm=',e12.5)
2014  format(' Best  sampled grid: freq(',f5.2,')=',f9.6,
     -  /,' Worst sampled grid: freq(',f5.2,')=',f9.6,
     -  ' ratio=',e10.3,' 2*SD=',f8.5,
     -  ' Number of runs around the median=',i4)
2016  format(' Reoptimized iteration norms=',/,(1x,10e12.5))
2017  format(' PMF deviation square sum     before optimization=',e12.5)
2018  format('+',50x,'***** ERROR ier=',i2,2x)
2019  format(' Test - ',a,' deviation square sum ',a,
     -  ' minimizing the relative deviation sum=',e12.5)
2020  format(' Relative deviation square sum after optimization=',e12.5)
2021  format(' PMF and sampling frequency for the last iteration only')
2023  format(' PMF deviation square sum      after optimization=',e12.5)
2024  format(' +++++ New region was reached - iteration discarded')
2026  format(' Cluster',i3,' from iteration',i3,' to iteration',i3,
     -  ' in the grid interval',2i4,' is minimized')
2027  format(' The number of gaps between the sampled intervals:',i3)
2028  format(' Space left in storage array=',i5)
2029  format(' ----- WARNING: less than 10 percent')
2030  format(' The new coupling-parameter interval has been reached')
2031  format(' +++++ Region was changed from input - iteration',
     -  ' discarded')
2032  format(' +++++ Equilibration is continued - iteration',
     -  ' discarded',/,31x,' Number of iterations dropped=',i4)
2033  format(' ***** ERROR: program is not dimensioned to ',
     -  'solve linear equations with this many iterations')
 
2036  format(' +++++ Iteration is outside the requested',f5.2,
     -  '-',f5.2,' range  - skipped')
2037  format(1x,32('.'),1x,a,' adaptive umbrella sampling weight ',
     -  'update at Nmc=',i12,1x,32('.'))
2038  format(' Rel. dev. optimized norms=',/,(1x,10e12.5))
3000  format(' ifirst=',20i5)
3001  format(' ilast= ',20i5)
3002  format(' kstart=',20i5)
3004  format(' nfikl= ',15i8,/,(7x,15i8))
3005  format(' iterw,nsets,kgimn0,kgimx0=',4i5)
3006  format(' limit1,2=',5i3,5x,5i3,' limgr1,2=',5i3,5x,5i3)
3007  format(' ixiter=',20i5)
      end
      subroutine gen_weights(wcplus,pbzavg,nfisum,nfisum_prev,
     -  iopenc,encexp)
c#    MMC routine 235/a lstmod: 08/20/12
c*****Calculate US weights from sampling info
      real*8 wcplus
      dimension wcplus(#WG),pbzavg(#WG),nfisum(#WG),nfisum_prev(#WG)
      real*8 sumnfi
      if (iopenc .ge. 0) then
c       Compute wcplus from pbzavg
        do k=1,#WG
          wcplus(k)=1.0d0
          if (pbzavg(k) .ne. 0.0) wcplus(k)=1.0d0/pbzavg(k)
        end do
      else
c       Compute wcplus from actual sampling rate
        sumnfi=0.d0
        nfimax=0
        do k=1,#WG
          sumnfi=sumnfi+nfisum(k)
          if (nfisum(k)-nfisum_prev(k) .gt. nfimax)
     -      nfimax=nfisum(k)-nfisum_prev(k)
        end do
        nfac=100
        if (nfimax .lt. 100) nfac=1
        do k=1,#WG
          if (nfisum(k)-nfisum_prev(k) .ge. nfimax/nfac) then
            wcplus(k)=(sumnfi/dfloat(nfisum(k)-nfisum_prev(k)))**encexp
          else
            wcplus(k)=(sumnfi/dfloat(nfimax/nfac))**encexp
          end if
        end do
      end if
      return
      end
      subroutine promote(leftright,wcplus,cpl,kp1mn,kp1mx,kgimn,kgimx,
     -  fcenc1,ngrcor,iout,maxgrid)
c#    MMC routine 235/b lstmod: 07/30/12
      real*8 wcplus
      dimension wcplus(maxgrid),cpl(maxgrid)
c*****Modify weights to extend sampling from sampled regions
      if (leftright .eq. -1) then
c       Encourage sampling just outside kgimn
        k1=kgimn-ngrcor
        if (k1 .lt. kp1mn) k1=kp1mn
        k2=kgimn-1
        wcpk1o=wcplus(k1)
        currat=wcplus(kgimn)/wcplus(k2)
        do kk=k1,k2
          k=k2-kk+k1
          fac=1.0/fcenc1
          if (currat .lt. fac) fac=currat
          currat=wcplus(k)/wcplus(k-1)
          wcplus(k)=wcplus(k+1)/fac
        end do
        fac=wcplus(k1)/wcpk1o
        k2=k1-1
        do k=1,k2
          wcplus(k)=wcplus(k)*fac
        end do
        write (iout,1000) 'lower',cpl(kgimn)
      else
c       Encourage sampling just outside kgimx
        k1=kgimx+1
        k2=kgimx+ngrcor
        if (k2 .gt. kp1mx) k2=kp1mx
        wcpk2o=wcplus(k2)
        currat=wcplus(kgimx)/wcplus(k1)
        do k=k1,k2
          fac=1.0/fcenc1
          if (currat .lt. fac) fac=currat
          currat=wcplus(k)/wcplus(k+1)
          wcplus(k)=wcplus(k-1)/fac
        end do
        fac=wcplus(k2)/wcpk2o
        k1=k2+1
        do k=k1,#WG
          wcplus(k)=wcplus(k)*fac
        end do
        write (iout,1000) 'higher',cpl(kgimx)
      end if
      return
1000  format(' +++++ Sampling extension is forced at ',a,' end from ',
     -  ' cpl=',f6.3)
      end
      subroutine plotiter(iplot,igr,maxit,nfstplt,nfrplt,nrad,beta,
     -  iopnrm,fcintra,iout)
c#    MMC routine 236 lstmod: 08/17/12
c*****Plots the matched PMF's for the individual iterations
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /sweep/ nsweep,nlast,nswavg,nswav2,minswp,maxswp,
     -  nswpit(#WI),nswrep(#WI)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      character*80 ident
      common /title/ nlident,ident(2)
      dimension xp(#WG),yp(#WG),nsamp(#WG)
      character*26 intraterm
      data intraterm /' - Intra term factor=     '/
      maxit=min0(maxit,iterw)
      write (iout,2004) nfstplt,maxit
      if (nfstplt .gt. maxit) then
        write (iout,2007)
        return
      end if
      if (nfrplt .gt. 1) write (iout,2005) nfrplt
      if (nrad .gt. 0) write (iout,2006) 'logarithmic',nrad
      if (nrad .lt. 0) write (iout,2006) 'linear',-nrad
      call zeroiti(iterix,0,iterw)
      do itr=1,iterw
        iterix(ixiter(itr))=itr
      end do
      ix0=100
      iy0=90
      ixwid=480
      iyhgt=600
      pmfmin=1000000.0
      pmfmax=-pmfmin
      nsampmax=0
      nzn=0
      do i=nfstplt,maxit,nfrplt
        ii=iterix(i)
        nzn=nzn+iterz(i)
        if (ii .ne. 0) then
          ifrst=ifirst(i)
          ilst=ilast(i)
          k0=-ifrst+kstart(i)
          do kk=ifrst,ilst
            prob=0.0
            prob=rnrmo2(ii)*pikl(kk)
            if (prob .gt. 0.0) then
              pmf=-alog(prob)/beta
              if (pmfmin .gt. pmf) pmfmin=pmf
              if (pmfmax .lt. pmf) pmfmax=pmf
              if (nfikl(kk) .gt. nsampmax) nsampmax=nfikl(kk)
            end if
          end do
        end if
      end do
      iymin=pmfmin/10.0
      iymax=pmfmax/10.0
      ymin=10.0*(iymin-1)
      ymax=10.0*(iymax+1)
      call psheader(iplot,'AUS iterations',14,0,0,612,792,1)
      write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
      write (iplot,1001) ix0+150,iy0+iyhgt+10
      write (iplot,1004) 'PMF of individual AUS iterations'
      write (iplot,1002) ix0+20,iy0+iyhgt-15
      write (iplot,1004) ident(1)
      write (iplot,1002) ix0+20,iy0+iyhgt-30
      write (iplot,1004) ident(2)
      write (iplot,1002) ix0+20,iy0+iyhgt-45
      if (igr .eq. 1) write (iplot,1004) 'Circles on linear scale'
      if (igr .eq. 2) write (iplot,1004) 'Circles on square root scale'
      if (igr .eq. 3) write (iplot,1004) 'Circles on logarithmic scale'
      write (iplot,1002) ix0+20,iy0+iyhgt-60
      if (iopnrm .ge. 0) write (iplot,1004) 'Rel. dev. P match'
      if (iopnrm .eq. -1) write (iplot,1004) 'Linear P match'
      if (iopnrm .eq. -2) write (iplot,1004) 'Linear W match'
      if (iopnrm .eq. -3) write (iplot,1004) 'Gridwise W match'
      write (intraterm(22:26),1015) fcintra
      write (iplot,1004) intraterm
      iyhgt=iyhgt-75
      ixmin=(cplmin-0.0001)*20
      ixmax=(cplmax+0.0001)*20
      xmin=(ixmin-1)/20.0
      xmax=(ixmax+2)/20.0
      write (iplot,1001) ix0+200,iy0-40
      write (iplot,1004) 'Coupling parameter'
      cplw=xmin
      ndiv=0
      iy=iy0
      do while (cplw .le. xmax+0.0001)
        ix=ix0+ixwid*(cplw-xmin)/(xmax-xmin)
        write (iplot,1008)
        write (iplot,1002) ix,iy
        write (iplot,1003) 0,5
        write (iplot,1007)
        write (iplot,1002) ix-10,iy-20
        write (iplot,1005) cplw
        ndiv=ndiv+1
        cplw=xmin+ndiv*0.05
      end do
      pmfw=ymin
      ndiv=0
      ix=ix0
      do while (pmfw .le. ymax+0.0001)
        iy=iy0+iyhgt*(pmfw-ymin)/(ymax-ymin)
        write (iplot,1008)
        write (iplot,1002) ix,iy
        write (iplot,1003) 5,0
        write (iplot,1007)
        write (iplot,1002) ix-50,iy-5
        write (iplot,1006) pmfw
        ndiv=ndiv+1
        pmfw=ymin+ndiv*2.0
      end do
      write (iout,2000) pmfmin,pmfmax
      kfmin=#WI
      kfmax=1
      write (iplot,1012) 0
      osampmaxlog=alog(float(nsampmax))
      osampmaxsqr=sqrt(float(nsampmax))
      do i=nfstplt,maxit,nfrplt
        ii=iterix(i)
        if (ii .ne. 0) then
          ifrst=ifirst(i)
          ilst=ilast(i)
          k0=-ifrst+kstart(i)
          kf=-1
          kl=kf
          do kk=ifrst,ilst
            prob=rnrmo2(ii)*pikl(kk)
            if (prob .gt. 0.0) then
              pmf=-alog(prob)/beta
              xp(k0+kk)=cpl(k0+kk)
              yp(k0+kk)=pmf
              nsamp(k0+kk)=nfikl(kk)
              if (kf .eq. -1) kf=k0+kk
              kl=k0+kk
            end if
          end do
          if (kl .gt. kf) then
            if (kfmin .gt. kf) kfmin=kf
            if (kfmax .lt. kl) kfmax=kl
            write (iplot,1008)
            do k=kf,kl
              ix=ix0+ixwid*(xp(k)-xmin)/(xmax-xmin)
              iy=iy0+iyhgt*(yp(k)-ymin)/(ymax-ymin)
              if (k .eq. kf) write (iplot,1002) ix,iy
              if (k .gt. kf) write (iplot,1009) ix,iy
              if (igr .eq. 1) then
                irad=nrad*float(nsamp(k))/float(nsampmax)+1.0
              else if (igr .eq. 2) then
                osamp=sqrt(float(nsamp(k)))
                irad=nrad*osamp/osampmaxsqr+1.0
              else
                osamp=alog(float(nsamp(k)))
                irad=nrad*osamp/osampmaxlog+1.0
              end if
              write (iplot,1014) ix,iy,irad,360
              write (iplot,1002) ix,iy
            end do
            write (iplot,1013) i
            if (iterz(i) .gt. 0) then
              write (iplot,1004) 'Z'
              write (iplot,1013) iterz(i)
            end if
            write (iplot,1011)
            write (iout,2002) i
            do while (kf .le. kl)
              kll= min0(kf+9,kl)
              write (iout,2001) 'cpl',(xp(k),k=kf,kll)
              write (iout,2001) 'PMF',(yp(k),k=kf,kll)
              write (iout,2008) (nsamp(k),k=kf,kll)
              kf=kf+10
            end do
          end if
        end if
      end do
      do k=kfmin,kfmax
        if (pbzavg(k) .gt. 0) then
          ix=ix0+ixwid*(cpl(k)-xmin)/(xmax-xmin)
          yp(k)=-alog(pbzavg(k))/beta
          iy=iy0+iyhgt*(yp(k)-ymin)/(ymax-ymin)
c         write (iplot,1002) ix,iy
c         write (iplot,1004) 'X'
c         write (iplot,1016) ix,iy,nrad,360
          write (iplot,1016) ix,iy,3,360
        end if
      end do
      write (iout,2003)
      do while (kfmin .le. kfmax)
        kll= min0(kfmin+9,kfmax)
        write (iout,2001) 'cpl',(cpl(k),k=kfmin,kll)
        write (iout,2001) 'PMF',(yp(k),k=kfmin,kll)
        kfmin=kfmin+10
      end do
      write (iplot,1099)
      return
1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
     -  i4,i4,' moveto')
1002  format(i4,i4,' moveto')
1003  format(i4,i4,' rlineto')
1004  format('(',a,') show')
1005  format('(',f5.2,') show')
1006  format('(',f8.1,') show')
1007  format('closepath',/,'stroke')
1008  format('newpath')
1009  format(i4,i4,' lineto')
1010  format('% Drawing of graph boundaries',/,'newpath',/,
     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('stroke')
1012  format(i2,' setlinewidth')
1013  format('(',i3,') show')
1014  format('stroke',/,'newpath',/,3i4,' 0 ',i4,' arc',/,
     -  'closepath',/,'stroke')
1015  format(f5.3)
1016  format('newpath',/,3i4,' 0 ',i4,' arc',/,'fill',/,
     -  'closepath',/,'stroke')
1099  format('%%Trailer',/,'showpage')
2000  format(' PMF range=',2e12.5,' kcal/mol')
2001  format(1x,a3,'=',10f12.3)
2002  format(' AUS iteration #',i3)
2003  format(' Matched PMF:')
2004  format(' Plotting from iteration',i4,' to iteration',i4,' the ',
     -  'individual AUS iterations')
2005  format(' Every ',i2,'-th iterations will be plotted only')
2006  format(' Circles represent ',a,' sampling scale with',i3,' steps')
2007  format(' ERROR: more iterations are skipped than there are')
2008  format(' Nsm=',10i12)
      end
      subroutine plotprogress(key,numrun,tiinteg,itiquad,inperr,iout)
c#    MMC routine 237 lstmod: 06/20/07
c*****Plot various convergence behaviors
      character*4 key
      dimension tiinteg(50)
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /option/ iop(#MI),idebug(200)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*1 plotsym
      character*19 plotname(5)
      character*80 file1
      dimension blockav1(#MI),blockav2(#MI),lplotname(5)
      data plotname /'energy','volume','number of molecules',
     -  'B parameter','free energy'/
      data lplotname /6,6,19,11,11/
      if (ncntrl .ge. 2) then
        numplot=0
        iversps=1
        ihead=1
        call getreal(xmin,0,0.0)
        call getreal(xdiv,0,0.0)
        call getint(nxdiv,0,1,0)
        call getreal(ymin,0,0.0)
        call getreal(ydiv,0,0.0)
        call getint(nydiv,0,1,0)
        call getint(linwid,0,1,1)
        call getname(plotsym,lensym,0,1)
        if (lensym .lt. 1) plotsym='*'
        if (plotsym .eq. ' ') plotsym='*'
        file1=file
        if (key .eq. 'ENRG') then
          numplot=1
          file1(namlenf+1:namlenf+4)='.eng'
          call fileopen(file1,namlenf+4,filenames(31),namlens(31),31,0,
     -      numrun,iversps,3,iform(31),1,iversout,iout,iplot,0)
          call blockfromcum(blockav1,unmc,uwnmc,ncntrl)
          call dividedr(blockav2,unmc,uwnmc,ncntrl)
          call plotconv(iplot,xnmc,blockav1,blockav2,ncntrl,xmin,xdiv,
     -      nxdiv,ymin,ydiv,nydiv,plotname(1),lplotname(1),linwid,
     -      plotsym,iop(24),iout)
        else if (key .eq. 'VOLU') then
          if (iop(71) .eq. 0) then
            write (iout,2203) 'volume','constant pressure'
            inperr=inperr+1
          else
            numplot=2
            file1(namlenf+1:namlenf+4)='.vol'
            call fileopen(file1,namlenf+4,filenames(31),namlens(31),31,
     -        0,numrun,iversps,3,iform(31),1,iversout,iout,iplot,0)
            call blockfromcum(blockav1,vnmc,uvvnmc,ncntrl)
            call dividedr(blockav2,vnmc,uvvnmc,ncntrl)
            call plotconv(iplot,xnmc,blockav1,blockav2,ncntrl,xmin,xdiv,
     -        nxdiv,ymin,ydiv,nydiv,plotname(2),lplotname(2),linwid,
     -        plotsym,iop(24),iout)
          end if
        else if (key .eq. 'NUMB') then
          if (iop(41) .eq. 0) then
            write (iout,2203) 'number of molecules','grand-canonical'
            inperr=inperr+1
          else
            numplot=3
            file1(namlenf+1:namlenf+4)='.nml'
            call fileopen(file1,namlenf+4,filenames(31),namlens(31),31,
     -        0,numrun,iversps,3,iform(31),1,iversout,iout,iplot,0)
            call blockfromcum(blockav1,rnnmc,uwnmc,ncntrl)
            call dividedr(blockav2,rnnmc,uwnmc,ncntrl)
            call plotconv(iplot,xnmc,blockav1,blockav2,ncntrl,
     -        xmin,xdiv,nxdiv,ymin,ydiv,nydiv,plotname(3),lplotname(3),
     -        linwid,plotsym,iop(24),iout)
          end if
        else if (key .eq. 'BPAR') then
          if (iop(41) .eq. 0) then
            write (iout,2203) 'B parameter','grand-canonical'
            inperr=inperr+1
          else if (iop(76) .ne. 3) then
            write (iout,2265)
            inperr=inperr+1
          else
            numplot=4
            file1(namlenf+1:namlenf+4)='.bpr'
            call fileopen(file1,namlenf+4,filenames(31),namlens(31),31,
     -        0,numrun,iversps,3,iform(31),1,iversout,iout,iplot,0)
            call blockfromcum(blockav1,vnmc,uvvnmc,ncntrl)
            call dividedr(blockav2,vnmc,uvvnmc,ncntrl)
            call plotconv(iplot,xnmc,blockav1,blockav2,ncntrl,xmin,xdiv,
     -        nxdiv,ymin,ydiv,nydiv,plotname(4),lplotname(4),linwid,
     -        plotsym,iop(24),iout)
          end if
        else if (key .eq. 'FETI') then
          if (itiquad .eq. 0) then
            write (iout,2216)
            inperr=inperr+1
          else
            do i=1,ncntrl
              blockav1(i)=ufenmc(i)
              blockav2(i)=uf2nmc(i)
            end do
            numplot=5
            file1(namlenf+1:namlenf+4)='.fen'
            call fileopen(file1,namlenf+4,filenames(31),namlens(31),31,
     -        0,numrun,iversps,3,iform(31),1,iversout,iout,iplot,0)
            call plotconv(iplot,xnmc,blockav1,blockav2,ncntrl,xmin,xdiv,
     -        nxdiv,ymin,ydiv,nydiv,plotname(5),lplotname(5),linwid,
     -        plotsym,iop(16),iout)
            call plotpolyfit(iplot,tiinteg,50,nxdiv,0.0,0.0,0,
     -       'Fitting polynomial',18,linwid,iop(24),iout)
          end if
        end if
        if (numplot .gt. 0) then
          write (iout,1187) plotname(numplot)(1:lplotname(numplot)),
     -      filenames(31)(1:namlens(31))
          call fileclose(iplot,0,iop(24),iout)
        end if
      else
        write (iout,2202)
        inperr=inperr+1
      end if
      return
1187  format(' Convergence plot for ',a,' is written to file ',a)
2202  format(' ***** ERROR: convergence plot requires a minimum of two',
     -  ' blocks to run')
2203  format(' ***** ERROR: ',a,' convergence can only be plotted in',
     -  ' the ',a,' ensemble')
2216  format(' ***** ERROR: free-energy quadrature was not run - can ',
     -  'not plot free-energy coonvergence')
2265  format(' ***** ERROR: B parameter can only be plotted for ',
     -  'process control tuning runs')
      end
      subroutine plotconv(iplot,x,y1,y2,n,xmn,xdv,nxdv,ymn,ydv,nydv,
     -  title,ntit,linwid,plotsym,iprt,iout)
c#    MMC routine 237/a lstmod: 03/03/08
      dimension x(n),y1(n),y2(n)
      character*(*) title
      character*1 plotsym
      ix0=100
      iy0=90
      ixwid=600
      iyhgt=480
      icharsize=11
      isymsize=11
      if (linwid .gt. 1) then
        isymsize=icharsize*linwid
         write (iplot,1015) linwid
      end if
      call psheader(iplot,title,ntit,0,0,612,792,1)
      write (iplot,1001) icharsize
      write (iplot,1016) ix0+300,iy0-40
      write (iplot,1004) 'nMC'
      write (iplot,1002) ix0+100,iy0+iyhgt+10
      write (iplot,1007) title(1:ntit),plotsym
      write (iplot,1014)
      write (iplot,1008)
      write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
c     Find Y range
      ymin=y1(1)
      ymax=y1(1)
      do i=1,n
        if (ymin .gt. y1(i)) ymin=y1(i)
        if (ymin .gt. y2(i)) ymin=y2(i)
        if (ymax .lt. y1(i)) ymax=y1(i)
        if (ymax .lt. y2(i)) ymax=y2(i)
      end do
      if (nxdv .gt. 0) then
        xmin=xmn
        xdiv=xdv
        nx=nxdv
        xmax=xmin+nx*xdiv
      else
        xmin=0.0
        xmax=x(n)
        nx=10
        xdiv=xmax/10.0
      end if
      if (nydv .gt. 0) then
        ymin=ymn
        ydiv=ydv
        ny=nydv
        ymax=ymin+ydiv*ny
      else
        ny=10
        ydiv=(ymax-ymin)/ny
      end if
      ly=alog10(abs(ymin))
c     Draw ticks, write axis values
      if (ymin .ne. 0.0) then
c       Plot initial value too
        iymin=0
      else
        iymin=1
      end if
      do i=iymin,ny
        write (iplot,1012)
        write (iplot,1002) ix0,iy0+i*iyhgt/nx
        write (iplot,1003) 5,0
        write (iplot,1011)
        write (iplot,1002) ix0-70,iy0-5+i*iyhgt/ny
        if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
        if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
      end do
      write (iplot,1011)
      if (xmin .ne. 0.0) then
c       Plot initial value too
        ixmin=0
      else
        ixmin=1
      end if
      do i=ixmin,nx
        write (iplot,1012)
        write (iplot,1002) ix0+i*ixwid/10,iy0
        write (iplot,1003) 0,5
        write (iplot,1011)
        write (iplot,1002) ix0-30+i*ixwid/10,iy0-20
        ix=xmin+i*xdiv
        write (iplot,1013) ix
      end do
      write (iplot,1011)
c     Plot graphs
      write (iplot,1001) isymsize
      if (ymax .gt. ymin) then
        yfac=iyhgt/(ymax-ymin)
      else
        yfac=0.0
      end if
      do i=1,n
        if (x(i) .ge. xmin .and. x(i) .le. xmax .and.
     -      y1(i) .ge. ymin .and. y1(i) .le. ymax) then
          ix=ix0+ixwid*x(i)/(xmax-xmin)
          iy=iy0+yfac*(y1(i)-ymin)
          write (iplot,1002) ix-3,iy-3
          write (iplot,1004) plotsym
        end if
      end do
      write (iplot,1012)
      iprev=0
      do i=1,n
        if (x(i) .ge. xmin .and. x(i) .le. xmax .and.
     -      y2(i) .ge. ymin .and. y2(i) .le. ymax) then
          ix=ix0+ixwid*x(i)/(xmax-xmin)
          iy=iy0+yfac*(y2(i)-ymin)
          if (iprev .eq. 0) then
            write (iplot,1002) ix,iy
            iprev=1
          else
            write (iplot,1009) ix,iy
          end if
        else
          iprev=0
        end if
      end do
      write (iplot,1011)
      write (iplot,1099)
      if (iprt .gt. 0) write (iout,2001) (int(x(i)),y1(i),y2(i),i=1,n)
      return
1001  format('/Helvetica findfont',/,i3,' scalefont',/,'setfont')
1002  format(i4,i4,' moveto')
1003  format(i5,i5,' rlineto')
1004  format('(',a,') show')
1005  format('(',f10.2,') show')
1006  format('(',e10.4,') show')
1007  format('(Convergence plot for ',a,2x,a1,': block average) show ')
1008  format('( : cumulative average) show')
1009  format(i4,i4,' lineto')
1010  format('% Drawing of graph boundaries',/,'newpath',/,
     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('stroke')
1012  format('newpath')
1013  format('(',i10,') show')
1014  format('10 5 rmoveto',/,'(_____) show',/,'0 -5 rmoveto')
1015  format(i2,' setlinewidth')
1016  format('612 0 translate',/,'90 rotate',/,
     -  i4,i4,' moveto')
1099  format('%%Trailer',/,'showpage')
2001  format(i11,2e14.6)
      end
      subroutine plotpolyfit(iplot,y,n,nxdv,ymn,ydv,nydv,title,ntit,
     -  linwid,iprt,iout)
c#    MMC routine 238 lstmod: 03/03/08
      dimension y(n)
      character*(*) title
      ix0=100
      iy0=90
      ixwid=600
      iyhgt=480
      icharsize=11
      isymsize=11
      if (linwid .gt. 1) then
        isymsize=icharsize*linwid
         write (iplot,1015) linwid
      end if
      write (iplot,1001) icharsize
      write (iplot,1016) ix0+300,iy0-40
      write (iplot,1004) 'Coupling palameter'
      write (iplot,1002) ix0+100,iy0+iyhgt+10
      write (iplot,1007) title(1:ntit)
      write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
c     Find Y range
      ymin=y(1)
      ymax=y(1)
      do i=1,n
        if (ymin .gt. y(i)) ymin=y(i)
        if (ymax .lt. y(i)) ymax=y(i)
      end do
      xmin=0.0
      xmax=1.0
      nx=10
      if (nxdv .gt. 0) nx=nxdv
      xdiv=xmax/float(nx)
      if (nydv .gt. 0) then
        ymin=ymn
        ydiv=ydv
        ny=nydv
        ymax=ymin+ydiv*ny
      else
        ny=10
        ydiv=(ymax-ymin)/ny
      end if
      ly=alog10(abs(ymin))
c     Draw ticks, write axis values
      if (ymin .ne. 0.0) then
c       Plot initial value too
        iymin=0
      else
        iymin=1
      end if
      do i=iymin,ny
        write (iplot,1012)
        write (iplot,1002) ix0,iy0+i*iyhgt/nx
        write (iplot,1003) 5,0
        write (iplot,1011)
        write (iplot,1002) ix0-70,iy0-5+i*iyhgt/ny
        if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
        if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
      end do
      write (iplot,1011)
      do i=1,nx
        write (iplot,1012)
        write (iplot,1002) ix0+i*ixwid/nx,iy0
        write (iplot,1003) 0,5
        write (iplot,1011)
        write (iplot,1002) ix0-30+i*ixwid/10,iy0-10
        x=xmin+i*xdiv
        write (iplot,1013) x
      end do
      write (iplot,1011)
c     Plot graph
      write (iplot,1001) isymsize
      if (ymax .gt. ymin) then
        yfac=iyhgt/(ymax-ymin)
      else
        yfac=0.0
      end if
      do i=1,n
        if (y(i) .ge. ymin .and. y(i) .le. ymax) then
          ix=ix0+float(ixwid*i)/float(n)
          iy=iy0+yfac*(y(i)-ymin)
          write (iplot,1002) ix-3,iy-3
          write (iplot,1004) 'o'
        end if
      end do
      write (iplot,1012)
      write (iplot,1011)
      write (iplot,1099)
      if (iprt .gt. 0) write (iout,2001) (0.02*i,y(i),i=1,n)
      return
1001  format('/Helvetica findfont',/,i3,' scalefont',/,'setfont')
1002  format(i4,i4,' moveto')
1003  format(i5,i5,' rlineto')
1004  format('(',a,') show')
1005  format('(',f10.2,') show')
1006  format('(',e10.4,') show')
1007  format('(',a,') show ')
1010  format('% Drawing of graph boundaries',/,'newpath',/,
     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('stroke')
1012  format('newpath')
1013  format('(',f5.3,') show')
1015  format(i2,' setlinewidth')
1016  format('612 0 translate',/,'90 rotate',/,
     -  i4,i4,' moveto')
1099  format('%%Trailer',/,'showpage')
2001  format(f8.5,e14.6)
      end
      subroutine devsum(n,rnorm,dvsm,grad,igrad)
c#    MMC routine 239 lstmod: 03/20/01
c*****Computes the sum of relative deviation squares and gradients
      real*8 rnorm,grad
      dimension rnorm(n),grad(n)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      common /eval/ nfceva,kount
      real*8 dgm,dpav,devsm,dpbzavg,dnpmp
      dimension dpav(#WG),nfismd(#WG)
      nfceva=nfceva+1
c     Compute the newly normalized probability distribution
      do k=kclst1,kclst2
        nfismd(k)=nfisum(k)
        if (nfismd(k) .eq. 0) nfismd(k)=1
        dpav(k)=0.d0
      end do
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        k0=-ifrst+kstart(i)
        do kk=ifrst,ilst
          dpav(k0+kk)=dpav(k0+kk)+rnorm(ii-istrdl)*
     -      dble(pikl(kk)*float(nfikl(kk)))/dfloat(nfismd(k0+kk))
        end do
      end do
      do k=kclst1,kclst2
        pbzavg(k)=dpav(k)
        if (dpav(k) .eq. 0.d0) pbzavg(k)=pbzavg(k-1)
      end do
c     Make sure zeroed out norms don't leave 0's in pbzavg
      k=kclst1
      do while (k .lt. kclst2)
        if (pbzavg(k) .lt. rlsqmxi) then
c         Zero found - find zero stretch limit
          kz2=k
          do while (pbzavg(kz2) .lt. rlsqmxi .and. kz2 .le. kclst2)
            kz2=kz2+1
          end do
c         Fill in pbzavg from k to kz1
          if (k .eq. kclst1 .and. kz2 .gt. kclst2) then
            pbfill=1.0
          else if (k .eq. kclst1) then
            pbfill=pbzavg(kz2)
          else if (kz2 .gt. kclst2) then
            pbfill=pbzavg(k-1)
          else
            pbfill=(pbzavg(k-1)+pbzavg(kz2))/2.0
          end if
          do kk=k,kz2-1
            pbzavg(kk)=pbfill
          end do
          k=kz2+1
        else
          k=k+1
        end if
      end do
c     Compute devsum
      devsm=0.d0
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        k0=-ifrst+kstart(i)
        do kk=ifrst,ilst
          devsm=devsm+(float(nfikl(kk))/
     -     float(nfksum(i)))*((rnorm(ii-istrdl)*pikl(kk)-
     -       dble(pbzavg(k0+kk)))/dble(pbzavg(k0+kk)))**2
        end do
      end do
      if (igrad .eq. 1) then
c       Compute the gradient
        do mmm=istr1,istr21
          m=ixiter(mmm)
          dgm=0.d0
          mfrst=ifirst(m)
          mlst=ilast(m)
          mstrt=kstart(m)
          km0=-mfrst+mstrt
c         Compute i=m contribution
          do mm=mfrst,mlst
            dgm=dgm+dble((float(nfikl(mm))/float(nfksum(m)))*
     -        dble(pikl(mm))*(rnorm(mmm-istrdl)*pikl(mm)-
     -        dble(pbzavg(km0+mm)))/dble(pbzavg(km0+mm))**2)
          end do
          do ii=istr1,istr2
            i=ixiter(ii)
            ifrst=ifirst(i)
            ilst=ilast(i)
            istrt=kstart(i)
            k0=-ifrst+istrt
            kmdel=mfrst-ifrst-(mstrt-istrt)
            idelst=istrt-mstrt
            idells=idelst-(ifrst-mfrst)+(ilst-mlst)
            if (idelst .lt. 0) ifrst=ifrst-idelst
            if (idells .gt. 0) ilst=ilst-idells
            if (ifrst .le. ilst) then
              do kk=ifrst,ilst
                dnpmp=rnorm(ii-istrdl)*pikl(kk)-
     -            dble(pbzavg(k0+kk))
                dpbzavg=dble(pbzavg(k0+kk))
                dgm=dgm-(float(nfikl(kk))/float(nfksum(i)))*
     -            ((float(nfikl(kmdel+kk))/float(nfismd(k0+kk)))*
     -            dble(pikl(kmdel+kk)))*
     -            (dnpmp*dnpmp/dpbzavg**3+dnpmp/dpbzavg**2)
              end do
            end if
          end do
          grad(mmm-istrdl)=dgm*2.0
        end do
      end if
      dvsm=devsm
      return
      end
      subroutine linopt(ierr,iout,MYRANK)
c#    MMC routine 240 lstmod: 07/26/12
c*****Linear optimization (minimize absolute deviations)
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),wfact(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      real*8 aid,aioffd,gisum
      common /wwork/ gisum(#WG),ami(#W2)
      dimension indx(#WI),vv(#WI)
c     wfact takes the place of pbzavi in the common block
c     Prepare gisum
      do k=kclst1,kclst2
        gisum(k)=0.d0
      end do
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        k=kstart(i)-1
        do kk=ifrst,ilst
          k=k+1
          nfikkk=nfikl(kk)
          gisum(k)=gisum(k)+dfloat(nfikkk)/dfloat(nfksum(i))
        end do
      end do
c     Prepare the coefficient matrix
      mi=0
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        istrt=kstart(i)
        do mm=istr1,istr21
          m=ixiter(mm)
          aid=0.d0
          aioffd=0.d0
          if (m .eq. i) then
c           Diagonal contribution
            do kk=ifrst,ilst
              nfikkk=nfikl(kk)
              aid=aid+dble(wfact(kk-ifrst+istrt))*
     -            (dfloat(nfikkk)/dfloat(nfksum(i)))*pikl(kk)**2
            end do
          end if
          mfrst=ifirst(m)
          mlst=ilast(m)
          mstrt=kstart(m)
          if (istrt .le. mstrt) then
c           Iteration i starts before iteration m
            if (mstrt-istrt .le. ilst-ifrst) then
c             Overlap between iterations i and m is found, start from mfrst
              ml=min0(mlst,mfrst+(ilst-ifrst)-(mstrt-istrt))
              ik=ifrst-1+(mstrt-istrt)
              k=mstrt-1
              do mk=mfrst,ml
                ik=ik+1
                k=k+1
                nfikik=nfikl(ik)
                nfikmk=nfikl(mk)
                if (nfisum(k) .ne. 0)
     -            aioffd=aioffd+dble(wfact(k)*pikl(mk)*pikl(ik))*
     -            (dfloat(nfikik)*dfloat(nfikmk)/dfloat(nfisum(k)))*
     -            (gisum(k)/dfloat(nfisum(k))-1.d0/dfloat(nfksum(i))-
     -             1.d0/dfloat(nfksum(m)))
              end do
            end if
          else
c           Iteration m starts before iteration i, start from ifrst
            if (istrt-mstrt .le. mlst-mfrst) then
c             Overlap between iterations i and m is found, start from ifrst
              il=min0(ilst,ifrst+(mlst-mfrst)-(istrt-mstrt))
              mk=mfrst-1+(istrt-mstrt)
              k=istrt-1
              do ik=ifrst,il
                mk=mk+1
                k=k+1
                nfikik=nfikl(ik)
                nfikmk=nfikl(mk)
                if (nfisum(k) .ne. 0)
     -            aioffd=aioffd+dble(wfact(k)*pikl(mk)*pikl(ik))*
     -              (dfloat(nfikik)*dfloat(nfikmk)/dfloat(nfisum(k)))*
     -              (gisum(k)/dfloat(nfisum(k))-1.d0/dfloat(nfksum(i))-
     -               1.d0/dfloat(nfksum(m)))
              end do
            end if
          end if
          mi=mi+1
          ami(mi)=aid+aioffd
        end do
      end do
c     Multiply last column with -1 to get rhs
      mi1=mi-nvars+1
      irhs=istr1-1
      do m=mi1,mi
        irhs=irhs+1
        rnrmo2(irhs)=-ami(m)
      end do
c     Solve the linear equation system
c     L-U decomposition routine from Numerical Recipes
      call ludcmp(ami,nvars,nvars,indx,d,vv,ierr,iout,MYRANK)
      call lubksb(ami,nvars,nvars,indx,vv)
      do i=1,nvars
        rnrmo2(istr1-1+i)=vv(i)
      end do
      rnrmo2(istr2)=1.0
      return
      end
      subroutine linopw(ierr,beta,iout,MYRANK)
c#    MMC routine 241 lstmod: 07/26/12
c*****Linear optimization (minimize absolute deviations at the pmf level)
c     based on the optimizer written at the probability level
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      common /wwork/ gisum(#WG),ami(#W2)
      real*8 aij,aii,rhsp,drwpk,gisum
      dimension rhs(#WI),indx(#WI),vv(#WI),drwpk(#WG)
      do k=kclst1,kclst2
        drwpk(k)=0.d0
      end do
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        k=kstart(i)-1
        do kk=ifrst,ilst
          k=k+1
          drwpk(k)=drwpk(k)+dfloat(nfikl(kk))*wikl(kk)
        end do
c        if (MYRANK .eq. 0) write (6,7700) i,(wikl(kk),kk=ifrst,ilst)
c7700    format(' Iter=',i2,' wk=',(8e12.5))
      end do
c     Prepare the coefficient matrix and the right hand side
      irhs=0
      ia=0
      do ii=istr1,istr21
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        istrt=kstart(i)
        k=istrt-1
c       Calculate r(p,k),w(p,k) and diagonal contribution
        aii=0.d0
        rhsp=0.d0
        do kk=ifrst,ilst
          k=k+1
          if (nfisum(k) .gt. 0) rhsp=rhsp+
     -        dfloat(nfikl(kk))*(wikl(kk)-drwpk(k)/dfloat(nfisum(k)))
        end do
        irhs=irhs+1
        rhs(irhs)=rhsp
        do mm=istr1,istr21
          m=ixiter(mm)
          aij=0.d0
c         Diagonal contribution
          if (m .eq. i) aij=-nfksum(i)
          mfrst=ifirst(m)
          mlst=ilast(m)
          mstrt=kstart(m)
          if (istrt .le. mstrt) then
c           Iteration i starts before iteration m
            if (mstrt-istrt .le. ilst-ifrst) then
c             Overlap between iterations i and m is found, start from mfrst
              ml=min0(mlst,mfrst+(ilst-ifrst)-(mstrt-istrt))
              k=mstrt-1
              ik=ifrst+(mstrt-istrt)-1
              do mk=mfrst,ml
                ik=ik+1
                k=k+1
                if (nfisum(k) .ne. 0) aij=aij+
     -            dfloat(nfikl(mk))*dfloat(nfikl(ik))/dfloat(nfisum(k))
              end do
            end if
          else
c           Iteration m starts before iteration i, start from ifrst
            if (istrt-mstrt .le. mlst-mfrst) then
c             Overlap between iterations i and m is found, start from ifrst
              il=min0(ilst,ifrst+(mlst-mfrst)-(istrt-mstrt))
              mk=mfrst+(istrt-mstrt)-1
              k=istrt-1
              do ik=ifrst,il
                mk=mk+1
                k=k+1
                if (nfisum(k) .ne. 0) aij=aij+
     -            dfloat(nfikl(mk))*dfloat(nfikl(ik))/dfloat(nfisum(k))
              end do
            end if
          end if
          ia=ia+1
          ami(ia)=aij
        end do
      end do
c     Solve the linear equation system
      nvar=istr2-istr1
C@DB      if (MYRANK .eq. 0) write (6,1213) (rhs(i),i=1,nvar)
C@DB      if (MYRANK .eq. 0) write (6,1214) (ami(i),i=1,ia)
C@DB1213  format(' rhs=',9e10.3)
C@DB1214  format(' --a=',9e10.3)
c     L-U decomposition routine from numerical recipes
      call ludcmp(ami,nvar,nvar,indx,d,vv,ierr,iout,MYRANK)
      call lubksb(ami,nvar,nvar,indx,rhs)
c     Solution in rhs - move it to rnrm2 and switch back to factors for rnrmo2
c      if (MYRANK .eq. 0) write (6,1213) (rhs(i),i=1,nvar)
      do ii=istr1,istr21
        rnrm2(ii)=rhs(ii-istr1+1)
        rnrmo2(ii)=exp(-beta*rhs(ii-istr1+1))
      end do
      rnrm2(istr2)=0.0
      rnrmo2(istr2)=1.0
      return
      end
      subroutine ludcmp(a,n,np,indx,d,vv,ierr,iout,MYRANK)
c#    MMC routine 242 lstmod: 07/26/12
c*****L-U decomposition from Numerical Recipes
      parameter (tiny=1.0e-20)
      dimension a(np,np),indx(n),vv(n)
      ierr=0
      d=1.
      do i=1,n
        aamax=0.
        do j=1,n
          if (abs(a(i,j)).gt.aamax) aamax=abs(a(i,j))
        end do
        if (aamax.eq.0.) then
          if (MYRANK .eq. 0) write (iout,*) 'Singular matrix in ludcmp.'
          ierr=1
          return
        end if
        vv(i)=1./aamax
      end do
      do j=1,n
        if (j .gt. 1) then
          do i=1,j-1
            sum=a(i,j)
            if (i .gt. 1)then
              do k=1,i-1
                sum=sum-a(i,k)*a(k,j)
              end do
              a(i,j)=sum
            end if
          end do
        end if
        aamax=0.
        imax=1
        do i=j,n
          sum=a(i,j)
          if (j.gt.1)then
            do k=1,j-1
              sum=sum-a(i,k)*a(k,j)
            end do
            a(i,j)=sum
          end if
          dum=vv(i)*abs(sum)
          if (dum.ge.aamax) then
            imax=i
            aamax=dum
          end if
        end do
        if (j.ne.imax)then
          do k=1,n
            dum=a(imax,k)
            a(imax,k)=a(j,k)
            a(j,k)=dum
          end do
          d=-d
          vv(imax)=vv(j)
        end if
        indx(j)=imax
        if (j.ne.n)then
          if (a(j,j).eq.0.)a(j,j)=tiny
          dum=1./a(j,j)
          do i=j+1,n
            a(i,j)=a(i,j)*dum
          end do
        end if
      end do
      if (a(n,n).eq.0.)a(n,n)=tiny
      return
      end
      subroutine lubksb(a,n,np,indx,b)
c#    MMC routine 243 lstmod: 04/26/95
c*****Back-substitution from Numerical Recipes
      dimension a(np,np),indx(n),b(n)
      ii=0
      do i=1,n
        ll=indx(i)
        sum=b(ll)
        b(ll)=b(i)
        if (ii.ne.0)then
          do j=ii,i-1
            sum=sum-a(i,j)*b(j)
          end do
        else if (sum.ne.0.) then
          ii=i
        end if
        b(i)=sum
      end do
      do i=n,1,-1
        sum=b(i)
        if (i.lt.n)then
          do j=i+1,n
            sum=sum-a(i,j)*b(j)
          end do
        end if
        b(i)=sum/a(i,i)
      end do
      return
      end
      function wdevsm(istr1,istr2,kclst1,kclst2,beta)
c#    MMC routine 244 lstmod: 02/22/94
c*****Calculate absolute deviation squares at the PMF level
c     and calculate the new probability distribution pbzavg
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,wdev,grad
      common /nrmfac/ rnrmo2(#WI),wdev(#WI),grad(#WI),nvars
      real*8 sum,gisum
      common /wwork/ gisum(#WG),ami(#W2)
c     Calculate the mean on the individual PMF's
      do k=kclst1,kclst2
        gisum(k)=0.d0
      end do
c      write (6,7711) (wdev(kk),kk=istr1,istr2)
c7711  format(' wdevsm wdev:',(8e12.5))
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        k=kstart(i)-1
        do kk=ifrst,ilst
          k=k+1
          gisum(k)=gisum(k)+dfloat(nfikl(kk))*(wikl(kk)+wdev(ii))
        end do
      end do
      do k=kclst1,kclst2
        if (nfisum(k) .gt. 0) gisum(k)=gisum(k)/dfloat(nfisum(k))
        gisumk=gisum(k)
        pbzavg(k)=exp(-beta*gisumk)
      end do
c     Calculate deviation squares
      sum=0.d0
      nsum=0
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)
        ilst=ilast(i)
        k=kstart(i)-1
        nsum=nsum+nfksum(i)
        do kk=ifrst,ilst
          k=k+1
          sum=sum+dfloat(nfikl(kk))*(gisum(k)-wikl(kk)-wdev(ii))**2
        end do
      end do
      wdevsm=sum/dfloat(nsum)
      return
      end
      subroutine linsmp(beta)
c#    MMC routine 245 lstmod: 03/14/96
c*****Matching by intervals - no optimization (van Eijck et al.)
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      common /wwork/ gisum(#WG),ami(#W2)
      real*8 drwpk,gisum
      dimension drwpk(#WG)
      do k=kclst1,kclst2
        drwpk(k)=0.d0
        gisum(k)=0.d0
      end do
      do ii=istr1,istr2
        i=ixiter(ii)
        ifrst=ifirst(i)+1
        ilst=ilast(i)
        k=kstart(i)
        do kk=ifrst,ilst
          k=k+1
c         Get the weighted averages of delta w into drwpk first
c         for weight, use the smaller of the two endpoints
          nfac=min0(nfikl(kk),nfikl(kk-1))
          drwpk(k)=drwpk(k)+(wikl(kk)-wikl(kk-1))*nfac
          gisum(k)=gisum(k)+nfac
        end do
      end do
      drwpk(kclst1)=0.0
c     Get the PMF from the delta w's into drwpk
      kcls11=kclst1+1
      do k=kcls11,kclst2
        if (gisum(k) .eq. 0.d0) then
          drwpk(k)=drwpk(k-1)
        else
          drwpk(k)=drwpk(k-1)+drwpk(k)/gisum(k)
        end if
      end do
c     Convert the w(r)'s into p(r)
      do k=kclst1,kclst2
        drwpkk=drwpk(k)
        pbzavg(k)=exp(-beta*drwpkk)
      end do
      return
      end
      subroutine clstru(iout,isetac,rnrmo1,MYRANK)
c#    MMC routine 246 lstmod: 07/27/12
c*****Update the cluster description, place the iteration
c     contiguous with its cluster
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      dimension iover(5)
      nover=0
      il=kstart(iterws)
      iu=il+(ilast(iterws)-ifirst(iterws))
      do j=1,nsets
        if (iu .ge. limgr1(j) .and. il .le. limgr2(j)) then
          nover=nover+1
          iover(nover)=j
        end if
      end do
      if (nover .eq. 0) then
c-------New class found
        nsets=nsets+1
        if (nsets .gt. 5) then
          if (MYRANK .eq. 0) write (iout,1000)
          call datprt(2)
        end if
        limgr1(nsets)=il
        limgr2(nsets)=iu
c       Move set to right place, if necessary
        do is=1,nsets
          if (limgr1(is) .gt. il) go to 110
        end do
c       OK as last set
        isetac=nsets
        limit1(nsets)=iterw
        limit2(nsets)=iterw
        return
c       Insert iteration in the middle as the is-th.
110     iterac=limit1(is)
        call shift1(limgr1,is,nsets)
        call shift1(limgr2,is,nsets)
        call shift1(limit1,is,nsets)
        call shift1(limit2,is,nsets)
        iit=limit1(is+1)
        call movite(iit,is)
        isetac=is
        limit1(is)=iterac
        limit2(is)=iterac
      else if (nover .eq. 1) then
c-------Overlap with one class only
        isetac=iover(1)
        limgr1(isetac)=min0(limgr1(isetac),il)
        limgr2(isetac)=max0(limgr2(isetac),iu)
        if (rnrmo1 .gt. 0.0) then
c         Renormalize initial guess by rnrmo1
          istr1=limit1(isetac)
          istr2=limit2(isetac)
          do k=istr1,istr2
            rnrmo2(k)=rnrmo2(k)/rnrmo1
          end do
        end if
        if (isetac .ge. nsets) then
c         No move of iteration
          limit2(nsets)=iterw
        else
          iit=limit1(isetac+1)
          limit2(isetac)=limit2(isetac)+1
          call movite(iit,isetac)
        end if
      else
c-------Overlap with several classes
        isetac=iover(1)
        if (rnrmo1 .gt. 0.0) then
c         Renormalize all the classes
          do i=1,nover
            rno1=opt1st(iover(i),iout,MYRANK)
            do j=istr1,istr2
              rnrmo2(j)=rnrmo2(j)/rno1
            end do
          end do
        end if
        limgr1(isetac)=min0(il,limgr1(isetac))
        limgr2(isetac)=max0(iu,limgr2(iover(nover)))
        if (iover(nover) .ge. nsets) then
c         Last sets were concatenated
          limit2(isetac)=iterw
          nsets=nsets-nover+1
        else
          is1=iover(nover)+1
          limit2(isetac)=limit2(iover(nover))+1
          do i=is1,nsets
            limit1(i-nover+1)=limit1(i)
            limit2(i-nover+1)=limit2(i)
            limgr1(i-nover+1)=limgr1(i)
            limgr2(i-nover+1)=limgr2(i)
          end do
          iit=limit1(isetac+1)
          call movite(iit,isetac)
          nsets=nsets-nover+1
        end if
      end if
      return
1000  format(' ***** ERROR: number of clusters is > 5')
      end
      function opt1st(iset,iout,MYRANK)
c#    MMC routine 247 lstmod: 07/27/12
c*****Compute the 1-step optimized norm based on the iset-th cluster
c     iset=0 means all the previous iterations
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      real*8 gisum
      common /wwork/ gisum(#WG),ami(#W2)
      if (iset .gt. 0) then
c       Pick up the limits for this set
        istr1=limit1(iset)
        istr2=limit2(iset)
        istr21=istr2-1
        istrdl=istr1-1
        nvars=istr2-istr1
        kclst1=limgr1(iset)
        kclst2=limgr2(iset)
        call trnsfrd(rnrm2,rnrmo2(istr1),nvars+1)
        call devsum(nvars+1,rnrm2,dvsm,grad,0)
      else
        kclst1=kgamn
        kclst2=kgamx
      end if
      nf0ksm=0
      nf1ksm=0
      do k=kclst1,kclst2
        nf0ksm=nf0ksm+nfismo(k)
        nf1ksm=nf1ksm+(nfisum(k)-nfismo(k))
      end do
      rnumer=0.0
      rdenom=0.0
      do k=kclst1,kclst2
        if (nfisum(k) .gt. 0) then
          rnf1k=float(nfisum(k)-nfismo(k))
          rnf0k=float(nfismo(k))
          fac=rnf0k*rnf1k*(float(nf0ksm)*rnf0k+float(nf1ksm)*rnf1k)/
     -        float(nfisum(k))**2
          rnumer=rnumer+fac*pbzavi(k)*pbzavg(k)
          rdenom=rdenom+fac*pbzavi(k)**2
        end if
      end do
      opt1st=1.0
      if (rdenom .ne. 0.0 .and. rnumer .ne. 0.0) opt1st=rnumer/rdenom
      if (iout .gt. 0 .and. MYRANK .eq. 0)
     -   write (iout,3010) rnumer,rdenom
3010  format(' rnumer,denom=',2e12.5)
      return
      end
      subroutine shift1(ia,i1,i2)
c#    MMC routine 248 lstmod: 02/13/92
c*****Shift the data up in array ia from i1 to i2-1 by 1
c     and move data at i2 into the space made
      dimension ia(i2)
      iai2=ia(i2)
      i2m1=i2-1
      do j=i1,i2m1
        i=i2-j+i1
        ia(i)=ia(i-1)
      end do
c     Move data on top into the space opened up
      ia(i1)=iai2
      return
      end
      subroutine shift1r(ra,i1,i2)
c#    MMC routine 249 lstmod: 04/13/97
c*****Shift the data up in array ra from i1 to i2-1 by 1
c     and move data at i2 into the space made
      real*8 ra
      dimension ra(i2)
      rai2=ra(i2)
      i2m1=i2-1
      do j=i1,i2m1
        i=i2-j+i1
        ra(i)=ra(i-1)
      end do
c     Move data on top into the space opened up
      ra(i1)=rai2
      return
      end
      subroutine scrnit(iopscr,isetac,nitdel,nsubmn,ngovmn,diffmx,
     -  nwitdl,beta,iopnrm,nwwarn,iout,MYRANK)
c#    MMC routine 250 lstmod: 07/26/12
c*****Screen iterations
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      real*8 gisum
      common /wwork/ gisum(#WG),ami(#W2)
c     iopscr=0 : screen iterations for "contradictory" distributions
c     iopscr=1 : drop the first (original order) nwitdl iterations
c                if nwitdl>0; reinstate dropped iters if nwitdl<0.
c     ngovmn: each pair of iterations is examined if at least
c     ngovmn grids overlap.
c     diffmx: violation occurs if the overlap index is greater than diffmx.
c     nsubmn: the iteration is rejected if more than (nsubov-1)/nsubmn+1
c     violations found when the iteration overlaps with nsubov subsequent
c     iterations.
c     iterws is the number of iterations saved in nfikl, pikl.
      nitdel=0
      call zeroiti(iterix,0,iterws)
      do itr=1,iterw
        iterix(ixiter(itr))=itr
      end do
      if (iopscr .eq. 1 .and. nwitdl .lt. 0) then
c       Reinstate dropped iterations
        do itr=1,iterws
          if (iterix(itr) .eq. 0) then
            iterw=iterw+1
            iterix(itr)=iterw
            ixiter(iterw)=itr
            rnrmo2(iterw)=rnrmo2(iterw-1)
          end if
        end do
        if (iterw .ne. iterws) then
          if (MYRANK .eq. 0) write (iout,9002) iterw,iterws
          call datprt(2)
        end if
        if (MYRANK .eq. 0) write (iout,9003)
      else
c       Screen or drop iterations
        iterw1=iterws-1
        do itr1=1,iterw1
          if (iterix(itr1) .ne. 0) then
            ifrst=ifirst(itr1)
            ilst=ilast(itr1)
            istrt=kstart(itr1)
            idelit=0
            if (iopscr .eq. 1) then
c             Screen for contradiction
              nsubov=0
              nsubdf=0
              itr11=itr1+1
              do itr2=itr11,iterws
                if (iterix(itr2) .gt. 0) then
                  novl=0
                  avgn=0.0
                  avgsn=0.0
                  wsum=0.0
                  mfrst=ifirst(itr2)
                  mlst=ilast(itr2)
                  mstrt=kstart(itr2)
                  if (istrt .le. mstrt) then
c                   Iteration i starts before iteration m
                    if (mstrt-istrt .le. ilst-ifrst) then
c                     Overlap between iters i & m is found, start from mfrst
                      ml=min0(mlst,mfrst+(ilst-ifrst)-(mstrt-istrt))
                      ik=ifrst-1+(mstrt-istrt)
                      do mk=mfrst,ml
                        ik=ik+1
                        if (nfikl(ik)*nfikl(mk) .gt. 0) then
                          rn=alog(pikl(ik)/pikl(mk))
                          rnik=nfikl(ik)
                          rnmk=nfikl(mk)
                          w=(nfikl(ik)+nfikl(mk))/(rnik/rnmk+rnmk/rnik)
                          novl=novl+1
                          avgn=avgn+w*rn
                          avgsn=avgsn+w*rn*rn
                          wsum=wsum+w
                        end if
                      end do
                    end if
                  else
c                   Iteration m starts before iteration i, start from ifrst
                    if (istrt-mstrt .le. mlst-mfrst) then
c                     Overlap between iters i & m is found, start from ifrst
                      il=min0(ilst,ifrst+(mlst-mfrst)-(istrt-mstrt))
                      mk=mfrst-1+(istrt-mstrt)
                      do ik=ifrst,il
                        mk=mk+1
                        if (nfikl(ik)*nfikl(mk) .gt. 0) then
                          rn=alog(pikl(ik)/pikl(mk))
                          rnik=nfikl(ik)
                          rnmk=nfikl(mk)
                          w=(nfikl(ik)+nfikl(mk))/(rnik/rnmk+rnmk/rnik)
                          novl=novl+1
                          avgn=avgn+w*rn
                          avgsn=avgsn+w*rn*rn
                          wsum=wsum+w
                        end if
                      end do
                    end if
                  end if
                  if (novl .ge. ngovmn) then
                    nsubov=nsubov+1
                    sdovlp=sqrt(abs(avgsn/wsum-(avgn/wsum)**2))
     -                /sqrt(float(novl))
                    if (sdovlp .ge. diffmx) then
                      nsubdf=nsubdf+1
                      if (nsubdf .gt. (nsubov-1)/nsubmn+1) then
c                       Delete iteration itr1 (outside itr2 loop)
                        if (MYRANK .eq. 0) write (iout,9000) itr1
                        idelit=1
                        go to 1000
                      end if
                    end if
                  end if
                end if
              end do
            end if
1000        if (itr1 .le. nwitdl .or. idelit .eq. 1) then
c             Drop iteration if original iteration number is <= nwitdel
c             or it was found contardicting earlier ones
              if (itr1 .le. nwitdl .and. MYRANK .eq. 0)
     -          write (iout,9001) itr1
              nitdel=nitdel+1
              iterw=iterw-1
              iter11=iterix(itr1)
              do itr=iter11,iterw
                rnrmo2(itr)=rnrmo2(itr+1)
                ixiter(itr)=ixiter(itr+1)
              end do
              iterix(itr1)=0
              do itr=itr1,iterws
                if (iterix(itr) .gt. iter11) iterix(itr)=iterix(itr)-1
              end do
              k0=-ifrst+istrt
              do kk=ifrst,ilst
                nfismo(k0+kk)=nfismo(k0+kk)-nfikl(kk)
                nfisum(k0+kk)=nfisum(k0+kk)-nfikl(kk)
              end do
            end if
          end if
        end do
      end if
      if (nitdel .eq. 0) return
c     Save rnrmo2 into grad in the original order
      do itr=1,iterw
        grad(ixiter(itr))=rnrmo2(itr)
      end do
c     Update cluster information due to deletions/restorations
      kgamn=#WG
      kgamx=1
      nsets=0
      iterw=0
c     Save iterws as it will have to be used as loop control variable
      itrwss=iterws
      do iterws=1,itrwss
        if (iterix(iterws) .ne. 0) then
          iterw=iterw+1
          rnrmo2(iterw)=grad(iterws)
          ixiter(iterw)=iterws
          kgimn=kstart(iterws)
          kgimx=kgimn+ilast(iterws)-ifirst(iterws)
          if (kgamn .gt. kgimn) kgamn=kgimn
          if (kgamx .lt. kgimx) kgamx=kgimx
          if (nsets .gt. 0) then
            call clstru(iout,isetac,0.0,MYRANK)
          else
c           First iteration kept, set up cluster info.
            nsets=1
            limit1(1)=1
            limit2(1)=1
            limgr1(1)=kgimn
            limgr2(1)=kgimx
            isetac=1
          end if
        end if
      end do
c     Regenerate the probability distribution
      do iset=1,nsets
        istr1=limit1(iset)
        istr2=limit2(iset)
        istr21=istr2-1
        istrdl=istr1-1
        kclst1=limgr1(iset)
        kclst2=limgr2(iset)
        nvars=istr2-istr1
        call devsum(nvars+1,rnrmo2(limit1(iset)),dvsm,grad,0)
      end do
      iterws=itrwss
      if (MYRANK .eq. 0) write (iout,9004)
      rldv=1.e-2
      if (iopscr .eq. 0) return
      if (iopnrm .eq. -3) then
c         Matching at every point (van Eijck et al.'s way)
          call linsmp(beta)
      else if (iopnrm .eq. -2) then
        call linopw(ier,beta,iout,MYRANK)
      else if (iopnrm .eq. -1) then
        call linopt(ier,iout,MYRANK)
      else
        call nlnmin(2,rldv,nwwarn,iout,MYRANK)
      end if
      return
9000  format(' +++++ Iteration',i4,' is dropped (',
     -  'insufficient correlation with succeeding iterations)')
9001  format(' +++++ Iteration',i4,' is dropped as requested')
9002  format(' ***** ERROR: did not restore the right number of',
     -  ' iterations ',2i6)
9003  format(' +++++ All dropped iterations have been restored',
     -  ' as requested and screening has been turned off')
9004  format(/,' Preliminary minimization',/)
      end
      subroutine movite(iit,is)
c#    MMC routine 251 lstmod: 04/13/97
c*****Put the estimate from this iteration with its cluster
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      call shift1(ixiter,iit,iterw)
      call shift1r(rnrmo2,iit,iterw)
c     Update limit1,2 to reflect iteration inserted in the middle
      is1=is+1
      do i=is1,nsets
        limit1(i)=limit1(i)+1
        limit2(i)=limit2(i)+1
      end do
      return
      end
      subroutine datprt(istop)
c#    MMC routine 252 lstmod: 02/24/21
c*****Prints the date and the time, summaries of errors/warnings
C@EF      use iflport
      common /timing/ ireset_tim,ncount_st,iday_st,month_st,iexit,nmcrun
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /griderror/ ngriderr,nhbgriderr,igridprint,griderrmax
      character*12 today
      common /today_date/ ltoday,today
c     C@ EF : Intel Fortran code
c     C@ AB : Absoft Fortran code
c     C@ G7 : Gnu G77 Fortran code
c     C@ G9 : Gnu G95 Fortran code
c     C@ UG : SGI IRIX Fortran code
c     C@ HP : Hewlett-Packard Fortran code
c     C@ AX : IBM AIX code
c     C@ UX : Generic Unix code
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_TIM/ mpi_time,mpi_time_st(64),mpi_start
C@DM      dimension mpi_time_x(64),ihostsc(64)
C@DM      character*80 hosts(64)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /oldio/ ifold(10),ifsaved
      dimension timeout(2)
C@AB      dimension idayspm(12)
c     INTEL compiler: on Linux  only, requires -Vaxlib compilation option
      integer idtvalue(8),lmonths(12)
C@AB      character*8 date_dat
C@AB      character*10 time_dat
C@AB      character*5 zone_dat
C@EF      character*8 date_dat
C@EF      character*10 time_dat
C@EF      character*5 zone_dat
      character*80 host,pwd
C@G7      character*3 mon
C@G7      character*24 adate
C@G7      external fdate
C@G7      external etime
C@G9      character*8 date_dat
C@G9      character*10 time_dat
C@G9      character*5 zone_dat
C@GF      character*8 date_dat
C@GF      character*10 time_dat
C@GF      character*5 zone_dat
C@UG      character*24 fdate,datestring
C@UG      external fdate
C@AX      character*24 fdate_
C@AX      external fdate_
C@HP      character*24 fdate
C@HP      external fdate
      character*5 months(12)
      data months/'Jan.','Feb.','March','April','May','June',
     -   'July','Aug.','Sep.','Oct.','Nov.','Dec.'/
      data lmonths /4,4,5,5,3,7*4/
C@AB      data idayspm /31,28,31,30,31,30,31,31,30,31,30,31/
      call zeroiti(idtvalue,0,8)
      ltoday=0
      ief=0
C@EF      ief=1
      iab=0
C@AB      iab=1
      ig95=0
C@G9      ig95=1
      igf=0
C@G9      igf=1
      ihost=0
      ipath=0
      timeout(2)=0.0
c     istop = 0: continue
c     istop = 1: normal stop
c     istop > 1: add to inperr istop-1; abnormal stop
c     istop < 0: abnormal stop
      if (istop .gt. 1) inperr=inperr+istop-1
C@DM      if (MYRANK .eq. 0) then
      write (iout,1010)
c     Print time and date
      host(1:8)='UNKNOWN '
      pwd(1:8)='UNKNOWN '
C@UX      if (icompopt(10)+icompopt(11)+icompopt(13)+icompopt(16) .eq. 0)
C@UX     -  call systemcall('date',4,iout,filenames(30),namlens(30))
C@UG      write (iout,1008) fdate()
C@UG      write (datestring,1000) fdate()
C@UG      today(1:6)=datestring(5:10)
C@UG      today(7:11)=datestring(20:24)
C@UG      ltoday=11
C@AX      write (iout,1008) fdate_()
C@G7      call fdate(adate)
C@G7      read (adate,1012) mon,iday,ihour,imin,isec,iyear
C@G7      write (iout,1018) mon,iday,iyear
C@G7      write (iout,1011) ihour,imin,isec
C@G7      write (today,1002) mon,iday,iyear
C@G7      ltoday=12
      if (ief+iab+ig95+igf .gt. 0) then
C@EF        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
C@AB        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
C@G9        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
C@GF        call date_and_time(date_dat,time_dat,zone_dat,idtvalue)
        write (iout,1009) months(idtvalue(2))(1:lmonths(idtvalue(2))),
     -    idtvalue(3),idtvalue(1)
        write (iout,1011) idtvalue(5),idtvalue(6),idtvalue(7)
        write (today,1001) idtvalue(2),idtvalue(3),idtvalue(1)
        ltoday=10
        do ic=1,ltoday
          if (today(ic:ic).eq. ' ') today(ic:ic)='0'
        end do
      end if
c     Print host name and directory
C@UX      if (icompopt(10)+icompopt(13)+icompopt(20)+icompopt(24).eq.0) then
C@UX        call systemcall('" Running on Unix node "`hostname`',34,
C@UX     -    iout,filenames(30),namlens(30))
C@UX        call systemcall('" Current Unix directory: "`pwd`',32,
C@UX     -    iout,filenames(30),namlens(30))
C@UX      end if
C@DM      end if
C@AB      call getenv('HOST',host)
C@AB      call getenv('PWD',pwd)
C@AB      ihost=1
C@AB      ipath=1
C@UG      call getenv('HOST',host)
C@UG      call getenv('PWD',pwd)
C@UG      ihost=1
C@UG      ipath=1
C@G7      call getenv('HOST',host)
C@G7      call getenv('PWD',pwd)
C@G7      ihost=1
C@G7      ipath=1
C@G9      call getenv('HOST',host)
C@G9      call getenv('PWD',pwd)
C@G9      ihost=1
C@G9      ipath=1
C@GF      call hostnm(host)
C@GF      call getcwd(pwd)
C@GF      ihost=1
C@GF      ipath=1
C@EF      istat=hostnam(host)
C@EF      ihost=1
      if (ihost .eq. 1) then
        ihostc=1
        call nextblank(host,ihostc,0)
      end if
C@DM      if (MYRANK .eq. 0) then
      if (ihost .eq. 1) write (iout,1014) host(1:ihostc-1)
      if (ipath .eq. 1) then
        ic=1
        call nextblank(pwd,ic,0)
        write (iout,1017) pwd(1:ic-1)
      end if
c     Print CPU time
      ttime=0.0
C@UG      ttime=etime(timeout)
C@HP      ttime=etime(timeout)
C@G7      ttime=etime(timeout)
C@G9      call cpu_time(ttime)
C@GF      call cpu_time(ttime)
C@EF      call cpu_time(ttime)
C@AB      call system_clock(ncount,ncountsec,maxcount)
C@AB      timeout(2)=0.0
C@AB      if (ireset_tim .eq. 1) then
C@AB        ireset_tim=0
C@AB        ncount_st=ncount
C@AB        itotsec=0
C@AB        if (mod(idtvalue(1),4) .eq. 0) idayspm(2)=29
C@AB        iday_st=idtvalue(3)
C@AB        month_st=idtvalue(2)
C@AB        ndays=0
C@AB      else
C@AB        iday0=iday_st
C@AB        iday1=idtvalue(3)
C@AB        ndays=iday1-iday0
C@AB        if (ndays .lt. 0) ndays=ndays+idayspm(month_st)
C@AB        ttime=float(ncount-ncount_st+ndays*maxcount)/float(ncountsec)
C@AB        if (iday0 .gt. iday1) ndays=ndays-1
C@AB      end if
C@AX      call cpu_time(ttime)
      ietime=ttime
      if (ttime .gt. 0.5) then
        call secstodays(ietime,isecs,imins,ihours,idays)
        if (timeout(2) .eq. 0.0)
     -    write (iout,1007) idays,ihours,imins,isecs
        if (timeout(2) .gt. 0.0)
     -    write (iout,1006) idays,ihours,imins,isecs,timeout(2)
C@AB        if (ndays .gt. 0) write (iout,1019)
        if (nmcrun .ge. nrecd .and. nrecd .gt. 0) then
c         Print checkpoint file saving frequency
          nsavedone=nmcrun/nrecd
          ietime=ttime
          call secstodays(ietime,isecs,imins,ihours,idays)
          write (iout,1016) idays,ihours,imins
          nwarn0=nwarn
          if (nsavedone .gt. 0) then
             ckptime=(ttime/float(nsavedone))/60.0
            if (ckptime .gt. 60.0) then
              write (iout,1020) ' long',ckptime
              nwarn=nwarn+1
            else if (ckptime .lt. 2.0) then
              write (iout,1021) ckptime
              nwwarn=nwwarn+1
            else if (ckptime .lt. 6.0) then
              write (iout,1020) ' short',ckptime
              nwarn=nwarn+1
            end if
          else if (ttime .gt. 900.0) then
            ckptime=ttime/60.0
            write (iout,1025) ckptime
          end if
          if (nwarn .gt. nwarn0) then
            write (iout,1022) nrecd
          else
            write (iout,1023) nrecd,ckptime
          end if
          write (iout,1024)
        end if
      end if
c     Call the Unix ps command to find out the CPU time used (assuming
c     that the program name contains the string mmc)
c     Generic Unix
      if (icompopt(24) .eq. 0 .and. icompopt(11) .eq. 0) then
C@NDC@UX        call systemcall('"MMC process:";ps |grep mmc|grep -v grep',40,
C@NDC@UX     -    iout,filenames(30),namlens(30))
      end if
C@DM      end if
C@DM      mpi_time=MPI_WTIME()
C@DM      if (MYRANK .gt. 0) then
C@DM        call MPI_send(mpi_time,1,MPI_INTEGER,0,10+MYRANK,MPI_COMM_WORLD,
C@DM     -    ierr)
C@DM      else
C@DM        mpi_time_x(1)=mpi_time
C@DM        do icpu=2,NUMNOD
C@DM          call MPI_recv(mpi_time_x(icpu),1,MPI_INTEGER,icpu-1,10+icpu-1,
C@DM     -      MPI_COMM_WORLD,MPI_stat,ierr)
C@DM          if (mpi_start .eq. 1) mpi_time_st(icpu)=mpi_time_x(icpu)
C@DM        end do
C@DM        if (mpi_start .eq. 1) mpi_time_st(1)=mpi_time_x(1)
C@DM      end if
C@DM      if (ihost .eq. 1) then
C@DMc       Gather node names used to run
C@DM        if (MYRANK .gt. 0) then
C@DM          call MPI_send(ihostc,1,MPI_INTEGER,0,10+MYRANK,MPI_COMM_WORLD,
C@DM     -      ierr)
C@DM        else
C@DM          do icpu=2,NUMNOD
C@DM            call MPI_recv(ihostsc(icpu),1,MPI_INTEGER,icpu-1,10+icpu-1,
C@DM     -        MPI_COMM_WORLD,MPI_stat,ierr)
C@DM          end do
C@DM        end if
C@DM        if (MYRANK .gt. 0) then
C@DM          call MPI_send(host,ihostc,MPI_CHARACTER,0,10+MYRANK,
C@DM     -      MPI_COMM_WORLD,ierr)
C@DM        else
C@DM          do icpu=2,NUMNOD
C@DM            call MPI_recv(hosts(icpu),ihostsc(icpu),MPI_CHARACTER,
C@DM     -        icpu-1,10+icpu-1,MPI_COMM_WORLD,MPI_stat,ierr)
C@DM          end do
C@DM          hosts(1)=host
C@DM          ihostsc(1)=ihostc
C@DM        end if
C@DM      else
C@DM        do icpu=1,NUMNOD
C@DM          ihostsc(icpu)=1
C@DM          hosts(icpu)=' '
C@DM        end do
C@DM      end if
C@DM      if (MYRANK .eq. 0 .and. mpi_start .eq. 0) then
C@DM        do icpu=1,NUMNOD
C@DM          ite=mpi_time_x(icpu)-mpi_time_st(icpu)
C@DM          call secstodays(ite,isecs,imins,ihours,idays)
C@DM          write (iout,1015) icpu-1,hosts(icpu)(1:ihostsc(icpu)),
C@DM     -      idays,ihours,imins,isecs
C@DM        end do
C@DM      end if
C@DM      mpi_start=0
      if (istop .ne. 0) then
C@DM        if (MYRANK .eq. 0) then
        if (ifsaved .eq. 1) call trnsfi(ifiles,ifold,10)
        iexit=1
        do i=1,10
          call fileclose(ifiles(i),0,1,iout)
        end do
        if (ntopwwarn .gt. 0) write (iout,2003)
        if (ngriderr .gt. 0) then
          write (iout,2004) ' ',ngriderr
          write (iout,2005) griderrmax
          nwwarn=nwwarn+1
        end if
        if (nhbgriderr .gt. 0) then
          write (iout,2004) ' hydrogen-bond ',nhbgriderr
          nwwarn=nwwarn+1
        end if
        if (nwarn .gt. 0) write (iout,2000) '-----',nwarn,'WARNING'
        if (nchng .gt. 0) write (iout,2000) '>>>>>',nchng,'OVERRIDE'
        if (nwwarn .gt. 0) write (iout,2000) '=====',nwwarn,
     -    'STRONG WARNING'
        if (inperr .gt. 0) then
          write (iout,2000) '*****',inperr,'ERROR'
          write (iout,2001)
        end if
        if (numdiscr .gt. 0) write (iout,1013) 'found',numdiscr
        if (nfixtry .gt. 0) write (iout,1013) 'fixed',nfixtry
        if (ndiffign .gt. 0) write (iout,1013) 'ignored',ndiffign
        if (istop .eq. 1 .and. numdiscr-nfixtry-ndiffign .le. 0 .and.
     -      inperr .eq. 0) then
          write (iout,2002) 'Normal',nmc
        else
          write (iout,2002) 'ABNORMAL',nmc
          call gatherckpfiles(iout,ifiles(1),ifiles(6),iop(24))
        end if
C@DM        end if
C@DM        call MPI_finalize(ierr)
C@DM        if (iop(24) .gt. 2) write (ioutdb,3000) MYRANK
        stop
      end if
      iexit=1
      return
C@UG1000  format(a)
1001  format(i2,'/',i2,'/',i4)
C@G71002  format(a3,' ',i2,', ',i4)
1006  format(' CPU time:',i5,' days, ',i3,' hours,',i3,
     -  ' minutes,',i3,' seconds (system time=',f9.2,' seconds)')
1007  format(' CPU time:',i5,' days, ',i3,' hours,',i3,
     -  ' minutes,',i3,' seconds')
C@UG1008  format(' Date: ',a)
C@AX1008  format(' Date: ',a)
1009  format(' Date: ',a,i3,', ',i4)
1010  format(1x)
1011  format(' Time:',i5,' hours,',i3,' minutes,',i3,' seconds')
C@G71012  format(4x,a3,4(1x,i2),1x,i4)
1013  format(' !!!!! Discrepancies were ',a,i5,' times in this run')
1014  format(' Unix hostname: ',a)
C@DM1015  format(' CPU #',i5,1x,a,' time:',i5,' days, ',i3,' hours,',i3,
C@DM     -  ' minutes,',i3,' seconds')
1016  format(' Checkpoint file was saved after running ',i2,' days',i3,
     -  ' hours and',i3,' minutes')
1017  format(' Unix directory: ',a)
C@G71018  format(' Date: ',a3,1x,i2,', ',i4)
C@AB1019  format(' NOTE: days included in CPU time are elapsed days',/,
C@AB     -  '      and do not include extra months')
1020  format(' ----- WARNING: Checkpoint file saving interval is too',a,
     -  ' (',f6.1,' minutes)')
1021  format(' ===== STRONG WARNING: Checkpoint file saving interval ',
     -  'is very short (',f6.1,' minutes)')
1022  format(' Checkpoint file saving frequency=',i9,' MC steps')
1023  format(' Checkpoint file was saved at every',i9,' MC step, ',
     -  'requiring',f7.1,' minutes')
1024  format(' The CHKP key can override the default saving frequency')
1025  format(' ----- WARNING: Checkpoint file was not saved in ',f6.1,
     -  ' minutes')
2000  format(1x,a5,' at least ',i6,1x,a,' messages were issued')
2001  format(7x,'any ERROR or WARNING message after the first ERROR ',
     -  'message may be the consequence of previous ERRORs')
2002  format(1x,a,' termination at nMC=',i10)
2003  format(' MMC determines the molecular topology of the solute by',
     -  ' establishing the solute bond list based on interatomic ',
     -  ' distances.',/,
     -  ' Missing or extra bonds generally result in STRONG WARNINGs ',
     -  'about split molecules and atoms outside their molecule range.',
     -  /,' Such messages can originate from',/,
     -  ' (a) incorrect order of solute atoms (read by the SLTA key).',/
     -  '     Solution: rearrange the solute atoms in the solute list',
     -  ' and in the coordinate file, if any (read by the CNFG key).',/,
     -  ' (b) incorrect coordinates for some of these solute atoms.',/,
     -  '     Solution: fix the coordinates.',/,
     -  ' (c) some bonds are stretched beyond the bond threshold',
     -  ' assumed by MMC for that type of pair.'/,
     -  '     Solution #1: use the MAKB key to establish that bond;',/,
     -  '     Solution #2: use the MODA key to increase the covalent',
     -  ' radius of the atom(s)',/,
     -  ' (d) some nonbonded atoms are within the bond threshold',
     -  ' assumed by MMC for that type of pair.'/,
     -  '     Solution #1: use the BRKB key to break that bond.',/,
     -  '     Solution #2: use the MODA key to increase the covalent',
     -  ' radius of the atom(s)',//,
     -  ' Clues to the location of the missing and extra bonds are in',
     -  ' these WARNING messages and',/,
     -  '     in WARNINGs about atoms without bonds and hydrogens with',
     -  ' more than one bond.',/,
     -  ' Start checking messages saying Bond **** - **** is suspect ',
     -  'and use the BRKB key to correct',/,
     -  ' Also, there is likely to be a list of bonds MMC assumed in ',
     -  'the outout file; if not, use the BNDL key.',/,
     -  ' To find the molecule numbers MMC assigned to the solute',
     -  ' look at the full solute list printed after the input'/,
     -  '     - this list can be forced by the key OUTP REPT.',/,
     -  ' The FCGA key, that partitons the solute into chemical groups',
     -  ' can also pinpoint topology errors ',/,
     -  '     - look for atoms marked with VERR or ????.'//,
     -  ' For solute molecules without active torsions the topology',
     -  ' generation, and hence the WARNINGs, can be bypassed by the ',
     -  'MOLD key.',//
     -  ' Note also that one topology error can result in several ',
     -  'WARNINGs and ERRORs.')
2004  format(' ===== STRONG WARNING Number of coordinates outside the',
     -  a,'grid map (in this run)=',i9)
2005  format(' ===== STRONG WARNING Largest deviation from map=',f8.3,
     -  ' A')
C@DM3000  format(' MPI in datprt - exiting: MYRANK=',i3)
      end
      subroutine gatherckpfiles(iout,ichkp,ichkpx,iverbos)
c#    MMC routine 252/a lstmod: 11/28/07
c*****Saves checkpoint file(s) on the permament disk spaces
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*80 scratchpath
      common /localdisk/ lscratchpath,scratchpath
      common /option/ iop(200),idebug(200)
      character*80 filename1,filename6,filename01,filename06
      if (lscratchpath .eq. 0) return
      if (filenames(1)(1:lscratchpath) .ne. scratchpath(1:lscratchpath))
     -  return
      if (ifilstat(1) .ne. 0) then
        filename01=filenames(1)
        lfilename01=namlens(1)
        lfilename1=lfilename01-lscratchpath
        filename1(1:lfilename1)=filename01(lscratchpath+1:lfilename01)
        filenames(1)=filename1
        namlens(1)=lfilename1
        call findnewunit(ichkpw,0,iout)
        open(unit=ichkpw,status='new',file=filename1(1:lfilename1),
     -    form='UNFORMATTED',iostat=ios)
        if (ios .eq. 0) then
          if (iverbos .gt. 0)
     -      write (iout,2040) filename1(1:lfilename1),'new',ichkpw
        else
          open(unit=ichkpw,status='old',file=filename1(1:lfilename1),
     -       form='UNFORMATTED',iostat=ios)
          if (ios .eq. 0) then
            if (iverbos .gt. 0)
     -        write (iout,2040) filename1(1:lfilename1),'old',ickhpw
          else
            write (iout,2039) ' ',filename1(1:lfilename1)
            stop
          end if
        end if
        call csave(ichkpw,0,inperr,9)
        write (iout,2038) ' ',filename1(1:lfilename1)
        call fileclose (ichkpw,0,iop(24),iout)
        call fileclose (ichkp,1,iop(24),iout)
        filenames(1)=filename01
        namlens(1)=lfilename01
      end if
      if (iop(162)+iop(176)+iop(144)+iop(172)+iop(178) .gt. 0 .and.
     -    ifilstat(6) .ne. 0) then
        filename06=filenames(6)
        lfilename06=namlens(6)
        lfilename6=lfilename06-lscratchpath
        filename6(1:lfilename6)=filename06(lscratchpath+1:lfilename06)
        filenames(6)=filename6
        namlens(6)=lfilename6
        call findnewunit(ichkpxw,0,iout)
        open(unit=ichkpxw,status='new',file=filename6(1:lfilename6),
     -    form='UNFORMATTED',iostat=ios)
        if (ios .eq. 0) then
          if (iverbos .gt. 0)
     -      write (iout,2040) filename1(1:lfilename6),'new',ichkpxw
        else
          open(unit=ichkpxw,status='old',file=filename6(1:lfilename6),
     -       form='UNFORMATTED',iostat=ios)
          if (ios .eq. 0) then
            if (iverbos .gt. 0)
     -        write (iout,2040) filename1(1:lfilename6),'old',ichkpxw
          else
            write (iout,2039) ' proximity ',filename6(1:lfilename6)
            stop
          end if
        end if
        call csavepx(ichkpxw,0,iskipfail,29)
        write (iout,2038) ' proximity analysis ',filename6(1:lfilename6)
        call fileclose (ichkpxw,0,iop(24),iout)
        call fileclose (ichkpx,1,iop(24),iout)
        filenames(6)=filename06
        namlens(6)=lfilename06
      end if
      return
2038  format(' Permanent',a,'checkpoint file is saved on file ',a)
2039  format(' ***** ERROR: could not open permanent',a,
     -  'checkpoint file ',a)
2040  format(' Checkpoint file ',a,' (',a,') opened on unit ',i3)
      end
      subroutine secstodays(iitime,isecs,imins,ihours,idays)
c#    MMC routine 253 lstmod: 10/21/05
c*****Obtains day, hour minute info from seconds
      ietime=iitime
      isecs=mod(ietime,60)
      ietime=ietime/60
      imins=mod(ietime,60)
      ietime=ietime/60
      ihours=mod(ietime,24)
      idays=ietime/24
      return
      end
      subroutine systemcall(arg,lena,iout,file,lenf)
      character*(*) arg,file
c#    MMC routine 253/a lstmod: 04/19/05
c*****Makes a system call
      character*132 line
      line(1:11)='(echo;echo '
      line(12:11+lena)=arg(1:lena)
      len=11+lena+1
      line(len:len)=')'
      if (iout .gt. 6) then
        line(len+1:len+4)=' >> '
        line(len+4:len+4+lenf)=file(1:lenf)
        len=len+4+lenf
      end if
C@UX      call system(line(1:len))
C@UR      call system(line(1:len))
      return
      end
      subroutine plot(x,y,y2,n,y00,yd,y200,y2d,ny,iprtref,iprt,
     -  ntit,nt2,itit,isam12,iroundtyp1,iroundtyp2)
c#    MMC routine 254 lstmod: 07/17/16
c*****Primitive plotter on printer for 2 functions of the same variable
      dimension x(n),y(n),y2(n)
      dimension nline(50),nline2(50),line(50,20),line2(50,20),xx(11)
      character*1 icharl,isp,isym,isym2,isym12
      dimension icharl(100)
      character*(*) itit
      character*80 ident
      common /title/ nlident,ident(2)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
c     x,y,y2: x and the y coordinates of the 2 functions to be plotted
c     n: number of points; ny: number of lines;
c     y00,yd: y scale minimum and unit, yd=0 => program finds them
c     y2oo,y2d: same as yoo,yd, but for the 2nd function
c     iprt: if iprt=iprtref or iprt=4, print the function values;
c     itit: array containing the title; ntit: number of characters in itit
c     if isam12 > 0, the two functions are to be plotted on the sam scale,
c     determined from the first one, unless scales are given explicitely.
      data isp/' '/,isym/'*'/,isym2/'o'/,isym12/'@'/
      if (n .lt. 2) return
      write (iout,5002) (ident(ic),ic=1,nlident)
      write (iout,5008) itit(1:nt2),itit(nt2+1:ntit)
      write (iout,5006)
      if (ny .gt. 50 .or. ny .lt. 2) ny=50
      y0=y00
      ydiv=yd
      y20=y200
      y2div=y2d
      nx=100
      call zeroiti(nline,0,ny)
      call zeroiti(nline2,0,ny)
      x0=x(1)
      xdiv=(x(n)-x0)/float(nx-1)
      if (ydiv .eq. 0.0) then
        ymin=y(1)
        ymax=ymin
        y2min=y2(1)
        y2max=y2min
        do i=1,n
          if (y(i) .lt. ymin) ymin=y(i)
          if (y(i) .gt. ymax) ymax=y(i)
          if (y2(i) .lt. y2min) y2min=y2(i)
          if (y2(i) .gt. y2max) y2max=y2(i)
        end do
        if (iroundtyp1 .eq. 0) then
          y0=ymin-(ymax-ymin)*0.01
          ydiv=(ymax-y0)/float(ny-1)
          if (ydiv .eq. 0.0) ydiv=1.0
        else if (iroundtyp1 .eq. 1) then
c         Round up to nearest 2/20/200 etc
          call round2(y0,ny,ymax,ydiv)
        else
          write (iout,1000) 1,iroundtyp1
          inperr=inperr+1
          return
        end if
        if (ydiv .eq. 0.0) ydiv=1.0
        if (isam12 .eq. 0) then
          if (iroundtyp2 .eq. 0) then
            y20=y2min-(y2max-y2min)*0.01
            y2div=(y2max-y20)/float(ny-1)
            if (y2div .eq. 0.0) y2div=1.0
          else if (iroundtyp2 .eq. 1) then
c           Round up to nearest 2/20/200 etc
            call round2(y20,ny,y2max,y2div)
          else if (iroundtyp2 .eq. 2) then
c           Correlation decay
            if (y2min .gt. 0.99) then
              y20=0.99
              y2div=0.0002
            elseif (y2min .gt. 0.95) then
              y20=0.95
              y2div=0.001
            elseif (y2min .gt. 0.8) then
              y20=0.8
              y2div=0.004
            else if (y2min .gt. 0.5) then
              y20=0.5
              y2div=0.01
            else if (y2min .gt. 0.0) then
              y20=0.0
              y2div=0.02
            else
              y20=-0.25
              y2div=0.025
            end if
          else
            write (iout,1000) 2,iroundtyp2
            inperr=inperr+1
            return
          end if
        else
c         Set second scale equal to first
          y20=y0
          y2div=ydiv
        end if
      end if
      do i=1,n
        ix=(x(i)-x0)/xdiv+1
        if (ix .ge. 1 .and. ix .le. nx) then
          if (y(i) .ne. 0.0) then
            iy=(y(i)-y0)/ydiv+1
            if (iy .ge. 1 .and. iy .le. ny) then
              nline(iy)=nline(iy)+1
              line(iy,nline(iy))=ix
              if (nline(iy) .eq. 20) then
c               Drop every second point
                nl2=nline(iy)/2
                nline(iy)=nl2
                do j=1,nl2
                  line(iy,j)=line(iy,2*j)
                end do
              end if
            end if
          end if
          iy=(y2(i)-y20)/y2div+1
          if (iy .ge. 1 .and. iy .le. ny) then
            nline2(iy)=nline2(iy)+1
            line2(iy,nline2(iy))=ix
            if (nline2(iy) .eq. 20) then
c             Drop every second point
              nl2=nline2(iy)/2
              nline2(iy)=nl2
              do j=1,nl2
                line2(iy,j)=line2(iy,2*j)
              end do
            end if
          end if
        end if
      end do
      do i=1,ny
        ii=ny-i+1
        ry=y0+(ii-1)*ydiv
        ry2=y20+(ii-1)*y2div
        do j=1,nx
          icharl(j)=isp
        end do
        do j=1,nline(ii)
          icharl(line(ii,j))=isym
        end do
        do j=1,nline2(ii)
          liniij=line2(ii,j)
          if (icharl(liniij) .eq. isp) then
              icharl(liniij)=isym2
          else if (icharl(liniij) .eq. isym) then
c           Collect overlapping points
            icharl(liniij)=isym12
          end if
        end do
        if (mod(ii,5) .ne. 1) write (iout,5001) (icharl(k),k=1,nx)
        if (mod(ii,5) .eq.1) write (iout,5000) ry,(icharl(k),k=1,nx),ry2
      end do
      write (iout,5003)
      do i=1,11
        xx(i)=10*(i-1)*xdiv+x0
      end do
      write (iout,5004) (xx(i),i=1,11)
      if (iprt .ne. iprtref .and. iprt .ne. 4) return
      if (ny .gt. 30) then
        write (iout,5002) (ident(ic),ic=1,nlident)
        write (iout,5008) itit(1:nt2),itit(nt2+1:ntit)
      end if
      write (iout,5005) isym,isym2
      do i=1,n
        if (y(i) .ne. 0.0 .or. y2(i) .ne. 0.0)
     -    write (iout,5007) i,x(i),y(i),y2(i)
      end do
      return
1000  format(' ***** PROGRAM ERROR: invalid rounding code for axis ',
     -  i1,':',i2)
5000  format(e12.4,'+',100a1,'+',e12.4)
5001  format(12x,'+',100a1,'+')
5002  format(1x,a80)
5003  format(13x,10('+',9('-')),'+')
5004  format(6x,11e10.3,//)
5005  format(15x,'x',19x,a1,19x,a1)
5006  format(//)
5007  format(i5,3e20.6)
5008  format(1x,a,4x,a)
      end
      subroutine btchmn(npts,nskp,nintvl,xcum,ucum,inam,iout,noprt,sd2i)
c#    MMC routine 255 lstmod: 05/02/13
c*****Computes error bound with the method of batch means
      real*8 xcum,ucum,denom
      dimension xcum(npts),ucum(npts),u(#MI)
      dimension nmncrt(20,20),nmxcrt(20,20)
      character*8 inam
      character*12 uncorr,corr,high,low,decide
      data uncorr/'Uncorrelated'/,corr/'Correlated  '/,
     -  high/' >>>        '/,low/' ???        '/
c     Minimum critical values for correlation test:
      data nmncrt/20*0,
     -  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     -  0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
     -  0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
     -  0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
     -  0, 0, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6,
     -  0, 0, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6,
     -  0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7,
     -  0, 0, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8,
     -  0, 0, 2, 3, 3, 4, 5, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9,
     -  0, 0, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9,
     -  0, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9,10,10,
     -  0, 2, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,10,
     -  0, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 9, 9,10,10,10,11,11,
     -  0, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,11,12,
     -  0, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 9,10,10,11,11,11,12,12,
     -  0, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 9,10,10,11,11,11,12,12,13,
     -  0, 2, 3, 4, 5, 5, 6, 7, 8, 8, 9, 9,10,10,11,11,12,12,13,13,
     -  0, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9,10,10,11,11,12,12,13,13,13,
     -  0, 2, 3, 4, 5, 6, 6, 7, 8, 9, 9,10,10,11,12,12,13,13,13,14/
c     Maximum critical values for correlation test:
      data nmxcrt/60*0,
     -  0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     -  0, 0, 0, 9,10,10,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     -  0, 0, 0, 9,10,11,12,12,13,13,13,13, 0, 0, 0, 0, 0, 0, 0, 0,
     -  0, 0, 0, 0,11,12,12,12,14,14,14,14,15,15,15, 0, 0, 0, 0, 0,
     -  0, 0, 0, 0,11,12,13,13,14,15,15,16,16,16,16,17,17,17,17,17,
     -  0, 0, 0, 0, 0,13,14,14,15,16,16,16,17,17,18,18,18,18,18,18,
     -  0, 0, 0, 0, 0,13,14,15,16,16,17,17,18,18,18,19,19,19,20,20,
     -  0, 0, 0, 0, 0,13,14,15,16,17,17,18,19,19,19,20,20,20,21,21,
     -  0, 0, 0, 0, 0,13,14,16,16,17,18,19,19,20,20,21,21,21,22,22,
     -  0, 0, 0, 0, 0, 0,15,16,17,18,19,19,20,20,21,21,22,22,23,23,
     -  0, 0, 0, 0, 0, 0,15,16,17,18,19,20,20,21,22,23,23,23,23,24,
     -  0, 0, 0, 0, 0, 0,15,16,18,18,19,20,21,22,22,23,23,24,24,25,
     -  0, 0, 0, 0, 0, 0, 0,17,18,19,29,21,21,22,23,23,24,25,25,25,
     -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,23,24,25,25,26,26,
     -  0, 0, 0, 0, 0, 0, 0,17,18,19,20,21,22,23,24,25,25,26,26,27,
     -  0, 0, 0, 0, 0, 0, 0,17,18,29,21,22,23,23,24,25,26,26,27,27,
     -  0, 0, 0, 0, 0, 0, 0,17,18,20,21,22,23,25,25,26,26,27,27,28/
      if (noprt .eq. 0) write (iout,1001) inam,npts,nskp,nintvl
      sd2i=0.0
      if (npts-nskp .lt. 2) return
      nbl=nintvl
      do il=1,10
        ndfac=2**(il-1)
        if (nskp .eq. 0) then
          u(1)=ucum(ndfac)/xcum(ndfac)
        else
          denom=xcum(ndfac+nskp)-xcum(nskp)
          if (denom .eq. 0.d0) then
            u(1)=0.d0
          else
            u(1)=(ucum(ndfac+nskp)-ucum(nskp))/denom
          end if
        end if
        npts0=(npts-nskp)/ndfac
        do ib=2,npts0
          denom=xcum(ndfac*ib+nskp)-xcum(ndfac*(ib-1)+nskp)
          if (denom .eq. 0.d0) then
            u(ib)=0.d0
          else
            u(ib)=(ucum(ndfac*ib+nskp)-ucum(ndfac*(ib-1)+nskp))/denom
          end if
        end do
        call var(u,npts0,sd2,nup,ndown,nrun)
        if (il .eq. 1) sd2i=sd2
        if (ndown .gt. 20 .or. nup .gt. 20) then
          decide=high
        else if (ndown .eq. 0 .or. nup .eq. 0) then
          decide=low
        else if (nmxcrt(ndown,nup) .eq. 0 .or.
     -           nmncrt(ndown,nup) .eq. 0) then
          decide=low
        else if (nrun .lt. nmncrt(ndown,nup) .or.
     -           nrun .gt. nmxcrt(ndown,nup)) then
          decide=corr
        else
          decide=uncorr
        end if
        if (noprt .eq. 0) write (iout,1002)
     -    inam,amin1(9999.9999,sd2),nbl,nup,ndown,nrun,decide
c       Double the blocksize
        nbl=nbl*2
        npts0=npts0/2
        if (npts0 .le. 2) return
      end do
      return
1001  format(/,1x,a8,' Number of block averages saved=',i4,
     -  ' Number of block skipped=',i4,' block size=',i9,' MC steps')
1002    format(1x,a8,' 2*sd=',f10.4,' block size=',i9,
     -    ' nup=',i3,' ndown=',i3,' nrun=',i3,2x,a12)
      end
      subroutine var(a,n,sd2,nup,ndown,nrun)
c#    MMC routine 256 lstmod: 01/22/04
c*****Computes the variance for the method of batch means
      dimension a(n),rs(#MI)
      real*8 av,sd,ai
      sd=0.0d0
      av=0.0d0
      do i=1,n
        ai=a(i)
        av=av+ai
        sd=sd+ai**2
      end do
      sd=dsqrt(dabs(sd/dfloat(n)-(av/dfloat(n))**2)/dfloat(n-1))
      sd2=2.0*sd
c     Find the median
      call trnsfr(rs,a,n)
      n2=n/2+1
      do i=1,n2
        r=rs(i)
        jm=i
        do j=i,n
          if (rs(j) .gt. r) then
            r=rs(j)
            jm=j
          end if
        end do
        rs(jm)=rs(i)
        rs(i)=r
      end do
      rmed=rs(n2)
      if (mod(n,2) .eq. 0) rmed=(rs(n2)+rs(n2-1))/2.0
      nup=0
      ndown=0
      nrun=1
      rp=a(1)-rmed
      do i=2,n
        if (rp*(a(i)-rmed) .le. 0.0) nrun=nrun+1
        if (rp .gt. 0.0) nup=nup+1
        if (rp .le. 0.0) ndown=ndown+1
        rp=a(i)-rmed
      end do
      if (mod(n,2) .eq. 1) nrun=nrun-1
      if (rp .gt. 0.0) nup=nup+1
      if (rp .le. 0.0) ndown=ndown+1
      return
      end
      subroutine blockfromcum(bl,cum,xcum,n)
c#    MMC routine 257 lstmod: 03/20/01
c*****Extract block averages from cumulative sum
      real*8 cum,xcum,denom
      dimension bl(n),cum(n),xcum(n)
      if (n .lt. 1) return
      if (xcum(1) .eq. 0.d0) bl(1)=0.d0
      if (xcum(1) .ne. 0.d0) bl(1)=cum(1)/xcum(1)
      do i=2,n
        denom=xcum(i)-xcum(i-1)
        if (denom .eq. 0.d0) bl(i)=bl(i-1)
        if (denom .ne. 0.d0) bl(i)=(cum(i)-cum(i-1))/denom
      end do
      return
      end
      subroutine skipblock(cum,nskip,nblock)
c#    MMC routine 258 lstmod: 08/11/99
      real*8 cum,cum0
      dimension cum(nblock)
c*****Subtract the first nskip block from the cumulative sums
      cum0=cum(nskip)
      do ib=nskip+1,nblock
        cum(ib-nskip)=cum(ib)-cum0
      end do
      return
      end
      subroutine lincm2(c,mcdim,ncdim,n,m,cpl0,cpl1)
c#    MMC routine 259 lstmod: 04/21/97
c*****Prepares the cpl0 and cpl1 linear combinations of the 2
c     solute data in c. Atomindex runs through rows
      dimension c(mcdim,ncdim),cdiffi(3),cdiffj(3)
c     Compute c(i) and c(j) as c0+cpl*(c1-c0)
      do i=1,n
        j=i+n
        do k=1,m
c         Compute cpl*(c1-c0) first
          cdiffi(k)=cpl0*(c(k,j)-c(k,i))
          cdiffj(k)=cpl1*(c(k,j)-c(k,i))
          c(k,j)=c(k,i)+cdiffj(k)
          c(k,i)=c(k,i)+cdiffi(k)
        end do
      end do
      return
      end
      subroutine lincm3(c,mcdim,ncdim,n,m,cpl0,cpl1)
c#    MMC routine 260 lstmod: 10/08/86
c*****Prepares the cpl0 and cpl1 linear combinations of the 2
c     solute data in c. Atomindex runs through columns
      dimension c(mcdim,ncdim),cdiffi(3),cdiffj(3)
c     compute c(i) and c(j) as c0+cpl*(c1-c0)
      do i=1,n
        j=i+n
        do k=1,m
c         Compute cpl*(c1-c0) first
          cdiffi(k)=cpl0*(c(j,k)-c(i,k))
          cdiffj(k)=cpl1*(c(j,k)-c(i,k))
          c(j,k)=c(i,k)+cdiffj(k)
          c(i,k)=c(i,k)+cdiffi(k)
        end do
      end do
      return
      end
      subroutine fmfpt(funct,n,nfunct,x,f,g,est,eps,limit,ier,h,maxh)
c#    MMC routine 261 lstmod: 01/29/09
c*****Fletcher-Powell minimizer retyped from IBM library
      real*8 x,g
      dimension h(maxh),x(n),g(n)
      common /eval/ nfceva,kount
      real*8 t,dx,dy,hnrm,gnrm,ambda,alfa,z,dalfa,w,aaa
      external funct
      data kl /0/,z /0.0/
      call funct(nfunct,x,f,g,1)
      ier=0
      kount=0
      n2=n+n
      n3=n2+n
      n31=n3+1
1     k=n31
      do j=1,n
        h(k)=1.0
        nj=n-j
        if (nj .le. 0) go to 5
        do l=1,nj
          kl=k+l
          h(kl)=0.0
        end do
        k=kl+1
      end do
5     kount=kount+1
      oldf=f
      do j=1,n
        h(n+j)=g(j)
        h(n2+j)=x(j)
      end do
      do j=1,n
        k=j+n3
        t=0.0
        l1=j-1
        if (l1 .eq. 0) go to 910
        do l=1,l1
          t=t-g(l)*h(k)
          k=k+n-l
        end do
910     k0=k-j
        do l=j,n
          t=t-g(l)*h(k0+l)
        end do
        h(j)=t
      end do
c      write (6,1002) kount,oldf
c1002  format(' iter=',i4,' f=',e12.5)
      dy=0.0
      hnrm=0.0
      gnrm=0.0
      do j=1,n
        hnrm=hnrm+abs(h(j))
        gnrm=gnrm+dabs(g(j))
        dy=dy+h(j)*g(j)
      end do
      if (dy .ge. 0.0) go to 57
      if (hnrm/gnrm-eps .le. 0.0) go to  57
      fy=f
      alfa=2.0*(est-f)/dy
      ambda=1.0
      if (alfa .le. 0.0) go to 15
      if (alfa-ambda .ge. 0.0) go to 15
      ambda=alfa
15    alfa=0.0
16    fx=fy
      dx=dy
      do i=1,n
        x(i)=x(i)+ambda*h(i)
      end do
      call funct(nfunct,x,f,g,1)
c      write (6,1000) f,fx,fy,ambda
c1000  format(' line search f,fx,fy=',3e12.5,' ambda=',f8.5)
      fy=f
      dy=0.0
      do i=1,n
        dy=dy+g(i)*h(i)
      end do
      if (dy .eq. 0.0) go to 36
      if (dy .gt. 0.0) go to 22
      if (fy-fx .ge. 0.0) go to 22
      ambda=ambda+alfa
      alfa=ambda
      if (hnrm*ambda-1.e10 .le. 0.0) go to 16
      ier=2
      return
22    t=0.0
23    if (ambda .eq. 0.0) go to 36
      z=3.0*(fx-fy)/ambda+dx+dy
      alfa=dmax1(dabs(z),dabs(dx),dabs(dy))
      dalfa=z/alfa
      dalfa=dalfa*dalfa-dx/alfa*dy/alfa
      if (dalfa .lt. 0.0) go to 58
      w=alfa*sqrt(dalfa)
      alfa=(dy+w-z)*ambda/(dy+2.0*w-dx)
      do i=1,n
        x(i)=x(i)+(t-alfa)*h(i)
      end do
      call funct(nfunct,x,f,g,1)
      aaa=t-alfa
c      write (6,1001) f,fx,fy,aaa
c1001  format(' cubc search f,fx,fy=',3e12.5,' ambda=',f8.5)
      if (f-fx .gt. 0.0) go to 28
      if (f-fy .le. 0.0) go to 36
28    dalfa=0.0
      do i=1,n
        dalfa=dalfa+g(i)*h(i)
      end do
      if (dx .ge. 0.0) go to 33
      if (f-fx .lt. 0.0) go to 32
      if (f-fx .gt. 0.0) go to 33
      if (dx-dalfa .eq. 0.0) go to 36
32    fx=f
      dx=dalfa
      t=alfa
      ambda=alfa
      go to 23
33    if (fy-f .ne. 0.0) go to 35
      if (dy-dalfa .eq. 0.0) go to 36
35    fy=f
      dy=dalfa
      ambda=ambda-alfa
      go to 22
36    do j=1,n
        k=n+j
        h(k)=g(j)-h(k)
        k=n+k
        h(k)=x(j)-h(k)
      end do
      if (oldf-f+eps .lt. 0.0) go to 51
      ier=0
      if (kount-n .lt. 0) go to 42
      t=0.0
      z=0.0
      do j=1,n
        k=n+j
        w=h(k)
        k=k+n
        t=t+abs(h(k))
        z=z+w*h(k)
      end do
      if (hnrm-eps .gt. 0.0) go to 42
      if (t-eps .le. 0.0) go to 56
42    if (kount-limit .ge. 0) go to 50
      alfa=0.0
      do j=1,n
        k=j+n3
        w=0.0
        l1=j-1
        if (l1 .ne. 0) then
          do l=1,l1
            w=w+h(n+l)*h(k)
            k=k+n-l
          end do
        end if
        k0=k-j
        do l=j,n
          w=w+h(n+l)*h(k0+l)
        end do
        alfa=alfa+w*h(n+j)
        h(j)=w
      end do
      if (z .eq. 0.0 .or. alfa .eq. 0.0) go to 1
      k=n31
      do l=1,n
        kl=n2+l
        do j=l,n
          nj=n2+j
          h(k)=h(k)+h(kl)*h(nj)/z-h(l)*h(j)/alfa
          k=k+1
        end do
      end do
      go to 5
50    ier=1
      return
51    do j=1,n
        k=n2+j
        x(j)=x(j)-h(k)
      end do
      go to 57
58    do j=1,n
        x(j)=h(n2+j)
      end do
57    call funct(nfunct,x,f,g,1)
      if (gnrm-eps .le. 0.0) go to 55
      if (ier .lt. 0) go to 56
      ier=-1
      go to 1
55    ier=0
56    return
      end
      subroutine bestoverlay(c,iatno,nat,index1,index2,natov,atwsuminp,
     -  c1,cc1,cc2,atw1,LEVTEST,iout,TOLERANCE,maxat)
c#    MMC routine 261/a lstmod: 01/05/2013
c*****Kabsch algorithm for structural superimposition (from Simulaid)
      dimension c(3,nat),iatno(maxat),index1(natov),index2(natov),
     -  c1(3,nat),cc1(3,maxat),cc2(3,maxat),atw1(maxat)
      common /overlay/ covref(3,#ST),rangerad,ixovref(#ST),
     -  icrefok,ixrefok,irangetyp,novuse
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      real*8 atwsuminp,atwsum,sm,r(3,3),dcom1(3),dcom2(3)
c     For the atoms in covref1(index1(i)), c(index2(i)) get the best fit
c     using the algorithm of Kabasch, Acta Cryst, A32, p922 (1976).
c     covref is assumed to be the reference structure.
c     cc1,cc2 are used for temporary storage
      dimension ijk(3,2),rr(3,3),rot(3,3),com1(3),com2(3),
     -  a(3,3),b(3,3),rmu(3),diag(3),offdiag(3)
      data iz /0/,inz /0/,atwsum /0.d0/
c     print *,'BESTOVERLAY natov,maxat,nat=',natov,maxat,nat
      ijk(1,1)=2
      ijk(1,2)=3
      ijk(2,1)=1
      ijk(2,2)=3
      ijk(3,1)=1
      ijk(3,2)=2
      devmax=0.0
      if (nat .eq. 1) return
c     Move both sets into COM frame
      do k=1,3
        dcom1(k)=0.d0
        dcom2(k)=0.d0
      end do
      do i=1,natov
        atw1(i)=aw(iatno(index1(i)))
        do k=1,3
          cc1(k,i)=covref(k,index1(i))
          cc2(k,i)=c(k,index2(i))
          dcom1(k)=dcom1(k)+atw1(i)*cc1(k,i)
          dcom2(k)=dcom2(k)+aw(iatno(index2(i)))*cc2(k,i)
        end do
        if (LEVTEST .gt. 1) write (iout,7291) i,index1(i),index2(i),
     -    atw1(i),(cc1(k,i),k=1,3),(cc2(k,i),k=1,3)
7291    format(' i=',i5,' ix1,2=',2i6,' atw=',f8.3,
     -    ' cc1=',3f12.7,' cc2=',3f12.7)
      end do
      if (atwsuminp .eq. 0.d0) then
        atwsum=0.d0
        do i=1,natov
          atwsum=atwsum+atw1(i)
        end do
      else
        atwsum=atwsuminp
      end if
      do k=1,3
        com1(k)=dcom1(k)/atwsum
        com2(k)=dcom2(k)/atwsum
      end do
      if (LEVTEST .gt. 0) write (iout,1001) atwsum,com1,com2
      do i=1,natov
        do k=1,3
          cc1(k,i)=cc1(k,i)-com1(k)
          cc2(k,i)=cc2(k,i)-com2(k)
        end do
      end do
c     Calculate coordinate sums - Numerical recipes starts arrays from 1!!
      do k=1,3
        do l=1,3
          r(k,l)=0.d0
          do i=1,natov
            r(k,l)=r(k,l)+atw1(i)*cc1(k,i)*cc2(l,i)
          end do
          r(k,l)=r(k,l)/atwsum
        end do
      end do
      do k=1,3
        do l=1,3
          sm=0.d0
          do m=1,3
            sm=sm+r(m,k)*r(m,l)
          end do
          rr(k,l)=sm
        end do
      end do
      if (LEVTEST .gt. 0) then
        write (iout,1000) "r",r
        write (iout,1000) "rr",rr
      end if
c     Find the eigenvectors a and eigenvalues mu of rr
      call tred2(rr,3,3,diag,offdiag)
      call tqli(diag,offdiag,3,3,rr,iout,ifail)
      do k=1,3
        do l=1,3
          A(k,l)=rr(l,k)
        end do
      end do
c     The rows of the matrix a are the eigenvectors
c     Calculate rotation matrix (U in Kabasch's notation)
      nz=0
      do k=1,3
        if (abs(diag(k)) .gt. TOLERANCE) then
          rmu(k)=sqrt(abs(diag(k)))
        else
          rmu(k)=0.0
          nz=nz+1
        end if
      end do
      if (LEVTEST .gt. 0) write (iout,*) "mu=",rmu
      do k=1,3
        if (rmu(k) .lt. TOLERANCE) then
          iz=k
        else
          do l=1,3
            sm=0.0
            do m=1,3
              sm=sm+r(l,m)*a(k,m)
            end do
            b(k,l)=sm/rmu(k)
          end do
          inz=k
        end if
      end do
      if (LEVTEST .gt. 0) write (iout,*) "nz=",nz
      if (nz .eq. 1) then
c       Planar molecule: a(iz)=a(inz)xa(jnz), same for b
         a(iz,1)=a(ijk(iz,1),2)*a(ijk(iz,2),3)-
     -     a(ijk(iz,1),3)*a(ijk(iz,2),2)
         a(iz,2)=a(ijk(iz,1),3)*a(ijk(iz,2),1)-
     -     a(ijk(iz,1),1)*a(ijk(iz,2),3)
         a(iz,3)=a(ijk(iz,1),1)*a(ijk(iz,2),2)-
     -     a(ijk(iz,1),2)*a(ijk(iz,2),1)
         b(iz,1)=b(ijk(iz,1),2)*b(ijk(iz,2),3)-
     -     b(ijk(iz,1),3)*b(ijk(iz,2),2)
         b(iz,2)=b(ijk(iz,1),3)*b(ijk(iz,2),1)-
     -     b(ijk(iz,1),1)*b(ijk(iz,2),3)
         b(iz,3)=b(ijk(iz,1),1)*b(ijk(iz,2),2)-
     -     b(ijk(iz,1),2)*b(ijk(iz,2),1)
      else if (nz .eq. 2) then
c       Linear molecules
c       First set the iz-th components to nonparalel to the inz-th
        do k=1,3
          a(iz,k)=0.0
          b(iz,k)=0.0
        end do
        if (abs(a(inz,1)) .lt. TOLERANCE) then
          a(iz,1)=rmu(inz)
        else if (abs(a(inz,2)) .ge. TOLERANCE) then
          a(iz,1)= -a(inz,1)
        else
          a(iz,2)=rmu(inz)
        end if
        if (abs(b(inz,1)) .lt. TOLERANCE) then
          b(iz,1)=rmu(inz)
        else if (abs(b(inz,2)) .ge. TOLERANCE) then
          b(iz,1)= -b(inz,1)
        else
          b(iz,2)=rmu(inz)
        end if
        if (iz .eq. ijk(inz,1)) then
          jz=ijk(inz,2)
        else
          jz=ijk(inz,1)
        end if
c       a(jz)=a(inz)xa(iz)
        a(jz,1)=a(ijk(jz,1),2)*a(ijk(jz,2),3)-
     -    a(ijk(jz,1),3)*a(ijk(jz,2),2)
        a(jz,2)=a(ijk(jz,1),3)*a(ijk(jz,2),1)-
     -    a(ijk(jz,1),1)*a(ijk(jz,2),3)
        a(jz,3)=a(ijk(jz,1),1)*a(ijk(jz,2),2)-
     -    a(ijk(jz,1),2)*a(ijk(jz,2),1)
        b(jz,1)=b(ijk(jz,1),2)*b(ijk(jz,2),3)-
     -    b(ijk(jz,1),3)*b(ijk(jz,2),2)
        b(jz,2)=b(ijk(jz,1),3)*b(ijk(jz,2),1)-
     -    b(ijk(jz,1),1)*b(ijk(jz,2),3)
        b(jz,3)=b(ijk(jz,1),1)*b(ijk(jz,2),2)-
     -    b(ijk(jz,1),2)*b(ijk(jz,2),1)
c       a(iz)=a(inz)xa(jz)
        a(iz,1)=a(ijk(iz,1),2)*a(ijk(iz,2),3)-
     -    a(ijk(iz,1),3)*a(ijk(iz,2),2)
        a(iz,2)=a(ijk(iz,1),3)*a(ijk(iz,2),1)-
     -    a(ijk(iz,1),1)*a(ijk(iz,2),3)
        a(iz,3)=a(ijk(iz,1),1)*a(ijk(iz,2),2)-
     -    a(ijk(iz,1),2)*a(ijk(iz,2),1)
        b(iz,1)=b(ijk(iz,1),2)*b(ijk(iz,2),3)-
     -    b(ijk(iz,1),3)*b(ijk(iz,2),2)
        b(iz,2)=b(ijk(iz,1),3)*b(ijk(iz,2),1)-
     -    b(ijk(iz,1),1)*b(ijk(iz,2),3)
        b(iz,3)=b(ijk(iz,1),1)*b(ijk(iz,2),2)-
     -    b(ijk(iz,1),2)*b(ijk(iz,2),1)
      end if
      if (LEVTEST .gt. 0) then
        write (iout,*) "diag: ",diag
        write (iout,*) "mu: ",rmu
      end if
      if (LEVTEST .gt. 0) then
        write (iout,1000) "a",a
        write (iout,1000) "b",b
      end if
      do k=1,3
        do l=1,3
          sm=0.0
          do m=1,3
            sm=sm+b(m,k)*a(m,l)
          end do
          rot(k,l)=sm
        end do
      end do
      if (LEVTEST .gt. 0) write (iout,1000) "rot",rot
      call trans_rot(rot,c,com2,c1,nat,-1.0,0)
      call trans_rot(rot,c1,com1,c1,nat,+1.0,1)
      return
1000  format(' BESTOV ',a,/,(3f12.7))
1001  format(' BESTOV atwsum=',e15.7,' com1=',3f12.7,' com2=',3f12.7)
      end
      subroutine tqli(d,e,n,np,z,iout,ifail)
c#    MMC routine 261/c lstmod: 10/22/2013
c*****Subroutine from Numerical Recipes
      dimension d(np),e(np),z(np,np)
      ifail=0
      if (n.gt.1) then
        do i=2,n
          e(i-1)=e(i)
        end do
        e(n)=0.
        do l=1,n
          iter=0
1         do m=l,n-1
            dd=abs(d(m))+abs(d(m+1))
c           IF (ABS(E(M))+DD.EQ.DD) GO TO 2
c           MM 10/21/2004
            if (e(m) .eq. 0.0) go to 2
            if (dd .ne. 0.0) then
c             if (abs(e(m))/dd .lt. 1.e-25) go to 2
              if (abs(e(m))/dd .lt. 1.e-15) go to 2
            end if
          end do
          m=n
2         if (m.ne.l) then
c           if (iter.eq.300)pause 'Too many iterations'
            if (iter.eq.300) then
              write (iout,*) 'ERROR: too many iterations in TQLI'
              ifail=1
              return
            end if
            iter=iter+1
            g=(d(l+1)-d(l))/(2.*e(l))
c           R=SQRT(G**2+1.)
            r=sqrt1(g)
            g=d(m)-d(l)+e(l)/(g+sign(r,g))
            s=1.
            c=1.
            p=0.
            do i=m-1,l,-1
              f=s*e(i)
              b=c*e(i)
              if (abs(f).ge.abs(g)) then
                c=g/f
c               R=SQRT(C**2+1.)
                r=sqrt1(c)
                e(i+1)=f*r
                s=1./r
                c=c*s
              else
                s=f/g
c               R=SQRT(S**2+1.)
                r=sqrt1(s)
                e(i+1)=g*r
                c=1./r
                s=s*c
              end if
              g=d(i+1)-p
              r=(d(i)-g)*s+2.*c*b
              p=s*r
              d(i+1)=g+p
              g=c*r-b
              do k=1,n
                f=z(k,i+1)
                z(k,i+1)=s*z(k,i)+c*f
                z(k,i)=c*z(k,i)-s*f
              end do
            end do
            d(l)=d(l)-p
            e(l)=g
            e(m)=0.
            go to 1
          end if
        end do
      end if
      return
      end
      subroutine tred2(a,n,np,d,e)
c#    MMC routine 261/b lstmod: 01/07/2013
c*****Subroutine from Numerical Recipes
      dimension a(np,np),d(np),e(np)
      if (n.gt.1) then
        do i=n,2,-1
          l=i-1
          h=0.
          scale=0.
          if (l.gt.1) then
            do k=1,l
              scale=scale+abs(a(i,k))
            end do
            if (scale.eq.0.) then
              e(i)=a(i,l)
            else
              do k=1,l
                a(i,k)=a(i,k)/scale
                h=h+a(i,k)**2
              end do
              f=a(i,l)
              g=-sign(sqrt(h),f)
              e(i)=scale*g
              h=h-f*g
              a(i,l)=f-g
              f=0.
              do j=1,l
                a(j,i)=a(i,j)/h
                g=0.
                do k=1,j
                  g=g+a(j,k)*a(i,k)
                end do
                if (l.gt.j) then
                  do k=j+1,l
                    g=g+a(k,j)*a(i,k)
                  end do
                end if
                e(j)=g/h
                f=f+e(j)*a(i,j)
              end do
              hh=f/(h+h)
              do j=1,l
                f=a(i,j)
                g=e(j)-hh*f
                e(j)=g
                do k=1,j
                  a(j,k)=a(j,k)-f*e(k)-g*a(i,k)
                end do
              end do
            end if
          else
            E(I)=A(I,L)
          end if
          d(i)=h
        end do
      end if
      d(1)=0.
      e(1)=0.
      do i=1,n
        l=i-1
        if (d(i).ne.0.) then
          do j=1,l
            g=0.
            do k=1,l
              g=g+a(i,k)*a(k,j)
            end do
            do k=1,l
              a(k,j)=a(k,j)-g*a(k,i)
            end do
          end do
        end if
        d(i)=a(i,i)
        a(i,i)=1.
        if (l.ge.1) then
          do j=1,l
            a(i,j)=0.
            a(j,i)=0.
          end do
        end if
      end do
      return
      end
      function sqrt1(x)
c#    MMC routine 261/d lstmod: 01/04/2013
c*****Avoid overflow for large x - just ignore the +1
      if (abs(x) .lt. 1.e+10) then
        sqrt1=sqrt(x**2+1.0)
      else
        sqrt1=x+0.5
      end if
      return
      end
      subroutine mrgsrt(iout,indexx,value,n,ifa,ila,itemp,temp,maxt)
c#    MMC routine 262 lstmod: 10/17/97
c*****Sort the indexx and value array in the order of increasing value(i)
      dimension indexx(n),value(n)
      dimension ifa(maxt),ila(maxt),itemp(maxt),temp(maxt)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      if (n .eq. 1) return
      if (n .gt. maxt) then
        if (MYRANK .eq. 0) write (iout,1000) n
        return
      end if
c     Individual intervals consist of single elements
      nn=n
      call indexit(ifa,1,n,0)
      call indexit(ila,1,n,0)
c     Merge pairs of intervals
11    nnpair=nn/2
      l=1
      do i=1,nnpair
        call mergelst(indexx,value,ifa(l),ila(l),ifa(l+1),ila(l+1),
     -    itemp,temp,maxt)
        ifa(i)=ifa(l)
        ila(i)=ila(l+1)
        l=l+2
      end do
      if (2*nnpair .ne. nn) then
c       Take care of last (odd) interval
        call mergelst(indexx,value,ifa(nnpair),ila(nnpair),ifa(nn),
     -    ila(nn),itemp,temp,maxt)
        ila(nnpair)=ila(nn)
      end if
      nn=nnpair
      if (nn .gt. 1) go to 11
      return
1000  format(' ***** ERROR: mrgsrt working array length ',i6,' exceeds',
     -  ' input length:',i5,/,' Recompile with increased value of ',
     -  '# UV')
      end
      subroutine mergelst(indexx,value,m1,m2,n1,n2,ires,res,maxt)
c#    MMC routine 263 lstmod: 06/23/97
c*****Merge two sets for the sorting
      dimension indexx(maxt),value(maxt),ires(maxt),res(maxt)
c     i,j: counters for the first and second part, resp.
c     k: counter for the merged array
      i=m1
      j=n1
      k=1
20    if (i .le. m2 .and. j .le. n2) then
c       Pick value from first or second part, depending on value
        if (value(i) .le. value (j)) then
          res(k)=value(i)
          ires(k)=indexx(i)
          i=i+1
          go to 40
        end if
        res(k)=value(j)
        ires(k)=indexx(j)
        j=j+1
40      k=k+1
        go to 20
      end if
      if (i .le. m2) then
c       Leftover in the first part
        do l=i,m2
          res(k)=value(l)
          ires(k)=indexx(l)
          k=k+1
        end do
      end if
      if (j .le. n2) then
c       Leftover in the second part
        do l=j,n2
          res(k)=value(l)
          ires(k)=indexx(l)
          k=k+1
        end do
      end if
c     Move back merged data into index, value
      k=0
      do l=m1,n2
        k=k+1
        indexx(l)=ires(k)
        value(l)=res(k)
      end do
      return
      end
      subroutine nlnmin(iopmin,rldvmx,nwwarn,iout,MYRANK)
c#    MMC routine 264 lstmod: 07/26/12
c*****Performs the necessary minimizing to get the normalization factors
c     iopmin=1: only one-step minimization
c     iopmin=2: non-linear n-step minimization
c     iopmin=3: non-linear n-step minimization without new initial guess
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 rnrmo2,rnrm2,grad
      common /nrmfac/ rnrmo2(#WI),rnrm2(#WI),grad(#WI),nvars
      common /clslim/ istr1,istr2,istr21,istrdl,kclst1,kclst2
      real*8 gisum
      common /wwork/ gisum(#WG),ami(#W2)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /eval/ nfceva,kount
      dimension center(#WI)
      real*8 dlmxi
      external devsum
      ntrouble=0
      if (iopmin .eq. 3) go to 200
c     Generate iteration center
      do it=1,iterw
        wsum=0.0
        csum=0.0
        itr=ixiter(it)
        ifrst=ifirst(itr)
        ilst=ilast(itr)
        k0=-ifrst+kstart(itr)
        do kk=ifrst,ilst
          k=kk+k0
          wsum=wsum+nfikl(kk)
          csum=csum+cpl(k)*nfikl(kk)
        end do
        center(it)=csum/wsum
      end do
      call mrgsrt(iout,ixiter,center,iterw,indexx,indexn,ixnear,cv1,
     -  #UV)
c     Do 1-step optimized matchings successively
      do k=kclst1,kclst2
        nfisum(k)=0
        pbzavg(k)=0.0
        nfismo(k)=0
      end do
      do it=istr1,istr2
        itr=ixiter(it)
        ifrst=ifirst(itr)
        ilst=ilast(itr)
        k0=-ifrst+kstart(itr)
        do kk=ifrst,ilst
          k=kk+k0
          pbzavi(k)=pikl(kk)
          nfisum(k)=nfismo(k)+nfikl(kk)
        end do
        rnrmo2(it)=opt1st(0,0,MYRANK)
        do k=1,#WG
          nfismo(k)=nfisum(k)
        end do
        do kk=ifrst,ilst
          k=kk+k0
          if (nfisum(k) .gt. 0) pbzavg(k)=pbzavg(k)+
     -      rnrmo2(it)*dble(pikl(kk)*float(nfikl(kk))/
     -      float(nfisum(k)))
        end do
      end do
      if (iopmin .eq. 1) return
c     Redo the n-step optimization too
200   call trnsfrd(rnrm2,rnrmo2(istr1),nvars+1)
c     Non-linear optimization (minimize relative deviations)
      call devsum(nvars+1,rnrm2,dvsm,grad,1)
      if (MYRANK .eq. 0) write (iout,2019) dvsm
c     Solve the minimization problem
      eps=dvsm*8.0*rldvmx
c     Use numerical minimizer for nonlinear optimization.
      lmt=200*(1+float(iterw)/float(2*#WI))
      ntight=0
214   ntight=ntight+1
      nfceva=0
      call fmfpt(devsum,nvars,nvars+1,rnrm2,dvsm,grad,0.0,eps,lmt,ier,
     -  ami,#W2)
      if (MYRANK .eq. 0) then
        write (iout,2020) dvsm,eps,nfceva
        if (ier .eq. 0) write (iout,2017) kount
        if (ier .eq. 1) write (iout,2004) kount
        if (ier .eq. -1) write (iout,2005) kount
      end if
c     Check for nonpositive or too small norm
      dlmxi=1000.0d0/dpsqmx
      trouble=0.0
      do i=1,nvars
        if (rnrm2(i) .le. 0.0d0) then
          itr=ixiter(istr1+i-1)
          if (MYRANK .eq. 0)
     -      write (iout,2001) itr,rnrm2(i),'nonpositive',trouble
          rnrm2(i)=trouble
          ntrouble=ntrouble+1
        else if (rnrm2(i) .le. dlmxi) then
          if (MYRANK .eq. 0)
     -      write (iout,2001) itr,rnrm2(i),'too small',trouble
          rnrm2(i)=trouble
          ntrouble=ntrouble+1
        end if
      end do
      call devsum(nvars+1,rnrm2,dvsm,grad,1)
      if (eps .gt. dvsm*rldvmx .and. eps .gt. 1.e-3 .and. ntight .le. 5)
     -  then
c       Tighten eps, double iteration limit and repeat
        eps=eps/10.0
        lmt=lmt*2
        go to 214
      end if
      call trnsfrd(rnrmo2(istr1),rnrm2,nvars)
      if (ntrouble .gt. 0) then
        nwwarn=nwwarn+ntrouble
        if (MYRANK .eq. 0) write (iout,2002)
      end if
      return
2001  format(' ===== STRONG WARNING: the normalization constant of ',
     -  'iteration ',i4,' (',e10.3,') is ',a,' - it is set to',e10.3)
2002  format(10x,'If the normalization constant error is recurrent, ',
     -  'reduce the coupling parameter range for the calculation')
2004  format(' ----- WARNING: Minimum not reached in ',i5,' iterations')
2005  format(' ----- WARNING: Gradient failure after',i5,' iterations')
2017  format(' Minimum reached in',i5,' iterations')
2019  format(' Relative deviation square sum with initial guess=',e12.5)
2020  format(' Relative deviation square sum after minimizing=',e12.5,
     -  ' with eps=',e10.3,' using',i5,' function evaluations')
      end
      subroutine checkcpl(icplp,c,crmslt,nslt0,iclslt,isltmv,cplpar,
     -  nerr,maxtry,MYRANK)
c#    MMC routine 265 lstmod: 07/26/12
c*****Check 3rd slt against cplpar, find cplpar, if needed
      dimension c(3,#ST),crmslt(3),iclslt(#ST),isltmv(#ST)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension crm2new(3),eulernew(3),cnew(3,#ST),crmpmf0new(3)
      character*1 lxyz
      common /names/ lxyz(3)
      if (MYRANK .gt. 0) return
      n1=nslt0
      n2=2*nslt0
      n3=3*nslt0
      itry=0
      if (iop(18) .eq. 4) then
        do it=1,ntorpmf
          dihang(it)=dihangl(c(1,iquata(it,1)),c(1,iquata(it,2)),
     -      c(1,iquata(it,3)),c(1,iquata(it,4)),iop(24)-1,iout)
        end do
      end if
      if (iop(18) .eq. 3)
     -  call cofms(c,crm2new,iclslt,n2+1,n3,0,wmol)
100   if (icplp .eq. 0 .or. itry .gt. 0) then
c       Establish the value of cplpar
        if (itry. eq. 0) cplpar=0.0
        if (iop(18) .lt. 3) then
          do i=1,n1
            do k=1,3
              if (abs(c(k,i)-c(k,n1+i)) .gt. 0.01) then
                  cplpar=(c(k,n2+i)-c(k,i))/(c(k,n1+i)-c(k,i))
                go to 210
              end if
            end do
          end do
210       write (iout,1004) filenames(2)(1:namlens(2)),cplpar
        else if (iop(18) .eq. 3) then
c         Translate/rotate case
          do k=1,3
            if (abs(crm2nd0(k)-crm2nd1(k)) .gt. 0.01) then
              cplpar=(crm2new(k)-crmslt(k)-crm2nd0(k))/
     -          (crm2nd1(k)-crm2nd0(k))
              go to 220
            end if
          end do
220       write (iout,1004) filenames(2)(1:namlens(2)),cplpar
        else if (iop(18) .eq. 4) then
          do id=1,ntorpmf
            deld=dihang(id)-dih0(id)
            cplpar=deld/deldih(id)
c??         For out-of-range lambda, check if other way is not better
            if (cplpar .lt. 0.0) then
              cplpos=cplpar+pi2/abs(deldih(id))
              if (cplpos .le. 1.0 .or. cplpos-1.0 .lt. -cplpar)
     -          cplpar=cplpos
            else if (cplpar .gt. 1.0) then
              cplneg=cplpar-pi2/abs(deldih(id))
              if (-cplneg .lt. cplpar-1.0) cplpar=cplneg
            end if
            da0=dih0(id)*rdtodg
            da01=deldih(id)*rdtodg
            daact=dihang(id)*rdtodg
          end do
          write (iout,1001) filenames(2)(1:namlens(2)),
     -     cplpar,da0,da01,daact
        else
          cplpar=0.0
          do k=1,3
            if (cdpmf(k) .eq. 0.0 .and.
     -          crm2nd1(k)-crm2nd0(k) .ne. 0.0) then
              cplpar=(c(k,icent1)-crm2nd0(k))/(crm2nd1(k)-crm2nd0(k))
              go to 230
            end if
          end do
          write (iout,1008)
          inperr=inperr+1
230       do k=1,3
            crmpmf0new(k)=cplpar*crm2nd1(k)+(1.0-cplpar)*crm2nd0(k)
            crmpmf(k)=c(k,icent1)-crmpmf0new(k)
          end do
          write (iout,1004) filenames(2)(1:namlens(2)),cplpar
        end if
      end if
      if (icplp  .gt. 0 .and. iop(24) .gt. 0)
     -  write (iout,1007) filenames(2)(1:namlens(2)),cplpar
c     Check if 3rd solute is really at cplpar
      nerr=0
      if (iop(18) .lt. 3) then
        do i=1,n1
          if (isltmv(n2+i) .eq. 0) then
            do k=1,3
              diff=abs(c(k,n2+i)-(1.0-cplpar)*c(k,i)-cplpar*c(k,n1+i))
              if (diff .gt. 0.01) then
                write (iout,1000) i,lxyz(k),diff
                nerr=nerr+1
              end if
            end do
          end if
        end do
      else if (iop(18) .eq. 3) then
c       Translate-rotate
c       Combine Euler angles, generate rotation matrix
        eulernew(1)=cplpar*euler2nd(1)
        eulernew(3)=cplpar*euler2nd(3)
        eulernew(2)=acoscheck(1.0+abs(cplpar)*eulercos2,iout,'CHKCPL')
        if (euler2nd(2)*cplpar .lt. 0.0) eulernew(2)=-eulernew(2)
        call eulertorot(ort2nd,eulernew(1),eulernew(2),eulernew(3))
        call rot_trans(ort2nd,rlcsec,crm2new,cnew,nslt0)
        do i=n2+1,n3
          ddi=(c(1,i)-cnew(1,i-n2))**2+
     -      (c(2,i)-cnew(2,i-n2))**2+
     -      (c(3,i)-cnew(3,i-n2))**2
          if (ddi .gt. 0.0001) then
            ddi=sqrt(ddi)
            ia=i-n2
            write (iout,1005) ia,ddi
            nerr=nerr+1
          end if
        end do
      else if (iop(18) .eq. 4) then
        do it=1,ntorpmf
          dacpl=dih0(it)+cplpar*deldih(it)
          diff=abs(dacpl-dihang(it))*rdtodg
          if (idebug(55) .gt. 0) write (iout,2200) cplpar,dacpl*rdtodg,
     -      dihang(it)*rdtodg,dih0(it)*rdtodg,dih1(it)*rdtodg
          if (diff .gt. 0.1 .and.
     -        (diff .lt. pi2-0.1 .or. diff .gt. pi2+0.1)) then
            nerr=nerr+1
            da0=dihangl(c(1,iquata(it,1)-n2),c(1,iquata(it,2)-n2),
     -        c(1,iquata(it,3)-n2),c(1,iquata(it,4)-n2),iop(24),iout)*
     -        rdtodg
            da1=dihangl(c(1,n1+iquata(it,1)-n2),c(1,n1+iquata(it,2)-n2),
     -        c(1,n1+iquata(it,3)-n2),c(1,n1+iquata(it,4)-n2),
     -        iop(24),iout)*rdtodg
            da01=dihang(it)*rdtodg
            if (itry .eq. 0) then
              write (iout,1002) it,cplpar,diff,da0,da1,da01
              nwarn=nwarn+1
            end if
            if (itry .gt. 0)
     -        write (iout,1003) it,cplpar,diff,da0,da1,da01
          end if
        end do
      else
        do k=1,3
          crmpmf0new(k)=c(k,icent1)-crmpmf(k)
          diff=abs(crmpmf0new(k)-(1.0-cplpar)*crm2nd0(k)-
     -         cplpar*crm2nd1(k))
          if (diff .gt. 0.01) then
            write (iout,1006) lxyz(k),diff
            if (idebug(55) .gt. 0) write (iout,2201) crmpmf,crmpmf0new,
     -        icent1,(c(kk,icent1),kk=1,3),crm2nd0,crm2nd1
            nerr=nerr+1
          end if
        end do
      end if
      if (nerr .eq. 0) return
      itry=itry+1
      if (itry .lt. maxtry) go to 100
      inperr=inperr+1
      return
1000  format(' ***** ERROR: solute atom',i4,1x,a1,
     -  ' contradicts the coupling parameter by',f8.3)
1001  format(' The coupling parameter has been established from the',
     -  ' coordinates on file ',a,' as',f10.5,/,6x,' based on ',
     -  ' initial torsion=',f10.3,' Torsion range=',f10.3,
     -  ' Actual torsion angle=',f10.3,' deg')
1002  format(' ----- WARNING: torsion angle',i4,
     -  ' contradicts the coupling parameter (',f8.3,') by',f8.3,' deg',
     -  /,6x,'Initial, final and actual torsion angles=',3f10.3,' deg')
1003  format(' ***** ERROR: torsion angle',i4,
     -  ' contradicts the coupling parameter (',f8.3,') by',f8.3,' deg',
     -  /,6x,'Initial, final and actual torsion angles=',3f10.3,' deg',
     -  '  - fixing attempt has failed')
1004  format(' The coupling parameter has been established from the',
     -  ' coordinates on file ',a,' as',f10.5)
1005  format(' ***** ERROR: coordinates of atom',i5,' of the ',
     -  '2nd rotated part contradict the coupling parameter by ',f9.4)
1006  format(' ***** ERROR: ',a1,'-component of the center of mass',
     -  ' contradicts the coupling parameter by',f8.3)
1007  format(6x,'The couplig parameter read from file ',a,'=',f8.5)
1008  format(' ***** ERROR: Could not determine the coupling ',
     -  'parameter value')
2200  format(' CHECKCPL: cplpar,dacpl,dihang=',3f12.5,
     -  ' dih0,dih1=',2f12.5)
2201  format(' CHECKCPL: crmpmf=',3f10.5,' crmpmf0new=',3f10.5,
     -  ' c(',i4,')=',3f10.5,/,' crm2nd0=',3f10.5,' crm2nd1=',3f10.5)
      end
      subroutine zeroit(a,n)
c#    MMC routine 266 lstmod: 09/30/97
c*****Fill up a real array with zeros
      dimension a(n)
      do i=1,n
        a(i)=0.0
      end do
      return
      end
      subroutine zeroiti(ia,n0,n)
c#    MMC routine 267 lstmod: 06/27/97
c*****Fill up an integer array with zeros from n0+1 to n
      dimension ia(n)
      do i=n0+1,n
        ia(i)=0.0
      end do
      return
      end
      subroutine zeroitd(a,n)
c#    MMC routine 268 lstmod: 12/30/97
c*****Fill up a real*8 array with zeros
      real*8 a
      dimension a(n)
      do i=1,n
        a(i)=0.d0
      end do
      return
      end
      subroutine indexit(ix,if,il,incr)
c#    MMC routine 269 lstmod: 09/17/01
c*****Fill up an integer array with its index
      dimension ix(il)
      do i=if,il
        ix(i)=i+incr
      end do
      return
      end
      subroutine arrdiff(diff,a1,a2,n)
c#    MMC routine 270 lstmod: 09/30/97
c*****Set diff=a1-b1
      dimension diff(n),a1(n),a2(n)
      do i=1,n
        diff(i)=a1(i)-a2(i)
      end do
      return
      end
      subroutine darrdiff(diff,a1,a2,n)
c#    MMC routine 271 lstmod: 11/27/00
c*****Set diff=a1-b1
      real*8 diff,a1,a2
      dimension diff(n),a1(n),a2(n)
      do i=1,n
        diff(i)=a1(i)-a2(i)
      end do
      return
      end
      subroutine arrsum(sum,a1,a2,n)
c#    MMC routine 272 lstmod: 05/22/98
c*****Set sum=a1+b1
      dimension sum(n),a1(n),a2(n)
      do i=1,n
        sum(i)=a1(i)+a2(i)
      end do
      return
      end
      subroutine arrsumd(sum,a1,a2,n)
c#    MMC routine 273 lstmod: 11/17/98
c*****Set sum=a1+b1
      real*8 sum,a1,a2
      dimension sum(n),a1(n),a2(n)
      do i=1,n
        sum(i)=a1(i)+a2(i)
      end do
      return
      end
      function arrdist(a1,a2)
c#    MMC routine 274 lstmod: 03/29/00
c*****arrdist= sum(ai-bi)**2
      dimension a1(3),a2(3)
      arrdist=(a1(1)-a2(1))**2+(a1(2)-a2(2))**2+(a1(3)-a2(3))**2
      return
      end
      function darrdists(a1,a2)
c#    MMC routine 275 lstmod: 11/08/00
c*****darrdist= sum(ai-bi)**2
      real*8 x,darrdists
      dimension a1(3),a2(3)
      darrdists=0.d0
      do k=1,3
        x=a1(k)-a2(k)
        darrdists=darrdists+x*x
      end do
      return
      end
      function darrdist(a1,a2)
c#    MMC routine 276 lstmod: 10/03/00
c*****darrdist= sum(ai-bi)**2
      real*8 a1,a2,darrdist
      dimension a1(3),a2(3)
      darrdist=(a1(1)-a2(1))**2+(a1(2)-a2(2))**2+(a1(3)-a2(3))**2
      return
      end
      subroutine arrdistsd(a1,a2,dist,dist2)
c#    MMC routine 277 lstmod: 03/29/00
c*****arrdist= sum(ai-bi)**2
      real*8 dist,dist2,x,y,z
      dimension a1(3),a2(3)
      x=a1(1)-a2(1)
      y=a1(2)-a2(2)
      z=a1(3)-a2(3)
      dist2=x*x+y*y+z*z
      dist=dsqrt(dist2)
      return
      end
      subroutine avstdev_n(usum,uusum,n,uavg,std)
c#    MMC routine 278/a lstmod: 05/10/11
c*****Return average and standard deviation from sum(u) and sum(u*u)
      real*8 usum,uusum,uav,uuav
      uav=usum/n
      uavg=uav
      uuav=uusum/n
      std=dsqrt(dabs(uuav-uav*uav))
      return
      end
      subroutine avstdev_r(usum,uusum,rnsum,uavg,std)
c#    MMC routine 278/a lstmod: 05/10/11
c*****Return average and standard deviation from weigted sum(u) and sum(u*u)
      real*8 usum,uusum,rnsum,uav,uuav
      uav=usum/rnsum
      uavg=uav
      uuav=uusum/rnsum
      std=dsqrt(dabs(uuav-uav*uav))
      return
      end
      subroutine avgsdlim(usum,uusum,rnsum,d9,r9,avg,sdev)
c#    MMC routine 279 lstmod: 05/10/11
c*****Calculate SD and avoid excessive values
      real*8 usum,uusum,rnsum,av,avav,d9,avg
      av=usum/rnsum
      if (av .gt. d9) av=d9
      avg=av
      avav=uusum/rnsum
      if (avav .gt. d9) avav=d9
      sdev=dsqrt(dabs(avav-av*av))
      if (sdev .gt. r9) sdev=r9
      return
      end
      function bondthresh2(ian1,ian2)
c#    MMC routine 280 lstmod: 12/02/03
c*****The bond-threshold square for atomic numbers ian1 and ian2
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      bondthresh2=amax1(ramax2(ian1),ramax2(ian2))
      if (ian1+ian2 .gt. 2 .and. (ian1 .eq. 1 .or. ian2 .eq. 1))
     -  bondthresh2=bondthresh2/1.3
      return
      end
      subroutine rngplt(iout)
c#    MMC routine 281 lstmod: 12/02/03
c*****Plot ranges covered by the adaptive umbrella sampling iterations
      character*80 ident
      common /title/ nlident,ident(2)
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      common /sweep/ nsweep,nlast,nswavg,nswav2,minswp,maxswp,
     -  nswpit(#WI),nswrep(#WI)
      real*8 gisum
      common /wwork/ gisum(#WG),ami(#W2)
      character*4 idelsm
      character*1 linech(50),linecc(50),iup9(9),idown9(9)
      data iup9/'1','2','3','4','5','6','7','8','9'/
      data idown9/'a','b','c','d','e','f','g','h','i'/
      write (iout,1000)
      write (iout,1005) (ident(ic),ic=1,nlident)
      write (iout,*)
      nswavg=0
      nswav2=0
      maxswp=0
      minswp=1000000
      ngrdav=0
      ngrdav2=0
      maxgrd=0
      mingrd=1000000
      kdv=d0cpl/g0cpl
      call zeroiti(iterix,0,iterws)
      do itr=1,iterw
        iterix(ixiter(itr))=itr
      end do
      kfmin=#WG
      klmax=0
c     Find lowest sampled grid
      do it=1,iterws
        itr=iterws-it+1
        kf=kstart(itr)+kdv
        if (kfmin .gt. kf) kfmin=kf
        kl=kf+ilast(itr)-ifirst(itr)
        if (klmax .lt. kl) klmax=kl
      end do
      do it=1,iterws
        itr=iterws-it+1
        idelsm='    '
        if (iterix(itr) .eq. 0) idelsm=' x  '
        kf=kstart(itr)+kdv
        kl=kf+ilast(itr)-ifirst(itr)
        do k=1,50
          linecc(k)=' '
          linech(k)=' '
        end do
        if (kf .gt. 0) linech(kf-kfmin+1)='*'
        if (kf .lt. kl) then
          kf1=kf+1
          iold=ifirst(itr)
          insum=0
          do k=kf,kl
            if (k .ge. 1 .and. k .le. 50-1+kfmin) then
              insum=insum+nfikl(iold)
              k0=k-kfmin+1
              rat=1.0
              if (pikl(iold) .gt. 0.0 .and. pikl(iold+1) .gt. 0.0)
     -          rat=pikl(iold)/pikl(iold+1)
              if (rat .lt. 1.0) rat=1.0/rat
              if (rat .gt. 4.99) then
                idif=9
              else
                idif=(rat-1.0)*2.0+1.0
              end if
              if (pikl(iold+1) .gt. pikl(iold)) linech(k0)=iup9(idif)
              if (pikl(iold+1) .le. pikl(iold)) linech(k0)=idown9(idif)
            end if
            iold=iold+1
          end do
c         Calculate and print number distribution
          iold=ifirst(itr)
          do k=kf,kl
            if (k .ge. 1 .and. k .le. 50-1+kfmin) then
              k0=k-kfmin+1
              ix=float(30*nfikl(iold))/float(insum)+1
              if (ix .gt. 9) ix=9
              linecc(k0)=iup9(ix)
            end if
            iold=iold+1
          end do
        end if
        write (iout,1001) itr,linech,idelsm,nswpit(itr),nswrep(itr),
     -    iterz(itr),linecc,itr
c       Accumulate nsweep,ngrds
        nsw=nswpit(itr)
        nswavg=nswavg+nsw
        nswav2=nswav2+nsw*nsw
        if (minswp .gt. nsw) minswp=nsw
        if (maxswp .lt. nsw) maxswp=nsw
        ngrds=kl-kf+1
        ngrdav=ngrdav+ngrds
        ngrdav2=ngrdav2+ngrds*ngrds
        if (mingrd .gt. ngrds) mingrd=ngrds
        if (maxgrd .lt. ngrds) maxgrd=ngrds
      end do
      write (iout,1002) (g0cpl*(kk-1),kk=kfmin,kfmin+50,10),
     -  (g0cpl*(kk-1),kk=kfmin,kfmin+50,10)
      if (klmax-kfmin .ge. 50) write (iout,1003) (klmax-kfmin-49)
      avgswp=float(nswavg)/float(iterws)
      av2swp=float(nswav2)/float(iterws)
      av2swp=av2swp-avgswp**2
      sdswp=0.0
      if (av2swp .gt. 0.0) sdswp=sqrt(av2swp)
      avggrd=float(ngrdav)/float(iterws)
      av2grd=float(ngrdav2)/float(iterws)
      av2grd=av2grd-avggrd**2
      sdgrd=0.0
      if (av2grd .gt. 0.0) sdgrd=sqrt(av2grd)
      write (iout,1004) avggrd,sdgrd,mingrd,maxgrd,
     -  avgswp,sdswp,minswp,maxswp
      return
1000  format(/,15x,' Coupling parameter control function',30x,
     -  'Sampling frequency plot (3% increment)',/,
     -  ' Numbers: increasing probability',
     -  ' (x marks dropped iterations)',/,
     -  ' Letters: decreasing probability (ratio increment=0.5)',/)
1001  format(i4,3x,50a1,a4,3i3,6x,50a1,i5)
1002  format(7x,'+',5(9('-'),'+'),15x,'+',5(9('-'),'+'),/,
     -  6(5x,f5.3),' nsw nr nz ',6(f5.3,5x))
1003  format(' ----- WARNING: Last ',i4,' coupling parameter grids',
     -  ' did not fit on the plots (at most 50 grids are plotted)')
1004  format(5x,'<Grids covered/iter>=',f4.1,' SD=',f4.1,' range: ',
     -  i3,' - ',i3,'   <Number of sweeps/iter>=',f4.1,' SD=',f4.1,
     -  ' range: ',i3,' - ',i3,/)
1005  format(1x,a80)
      end
      subroutine dvpslt(c,cic)
c#    MMC routine 282 lstmod: 03/08/01
c*****Accumulates the contributions to the derivatives of the energy
c     with respect to the solute parameters.
      dimension c(3,#NA),cic(3,27)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      real*8 rij1i,rij6i,rij6ii,rij12i
      nsltdv=nsltdv+1
      do is=istf,nstta
        do iss=1,nslv
          rij6i=0.0d0
          rij12i=0.0d0
          rij1i=0.0d0
          do iw=2,nmolec
            rij2=0.0
c           If iop(43)>0, then this does not work, because iopbst will also
c           depend of the group the solute atom belongs to !!!
            do k=1,3
              rij2=rij2+
     -          (c(k,is)-c(k,ic00+iw*nslv+iss)-cic(k,iopbst(iw)))**2
            end do
            rij6ii=1.d0/dble(rij2*rij2*rij2)
            rij6i=rij6i+rij6ii
            rij12i=rij12i+rij6ii*rij6ii
            rij1i=rij1i+1.d0/dble(sqrt(rij2) )
          end do
          df1(is,iss)=df1(is,iss)+rij1i
          df6(is,iss)=df6(is,iss)-rij6i
          df12(is,iss)=df12(is,iss)+rij12i
          de1(is,iss)=de1(is,iss)+etoto*rij1i
          de6(is,iss)=de6(is,iss)-etoto*rij6i
          de12(is,iss)=de12(is,iss)+etoto*rij12i
          ds1(is,iss)=ds1(is,iss)+tesi(1)*rij1i
          ds6(is,iss)=ds6(is,iss)-tesi(1)*rij6i
          ds12(is,iss)=ds12(is,iss)+tesi(1)*rij12i
        end do
      end do
      return
      end
      subroutine dvpsltfin
c#    MMC routine 283 lstmod: 10/07/98
c*****Calculates the contributions to the derivatives of the energy and free
c     energy with respect to the solute parameters.
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      if (nsltdv .eq. 0) return
      write (iout,2000) 'SENSITIVITY ANALYSIS'
      us=uslt/(ucsmid+ucsmvv+ucsmmv)
      u=usum/(ucsmid+ucsmvv+ucsmmv)
      write (iout,1035)
      do is=1,nstta
        do iss=1,nslv
c         Calculate averages
          d1isss=df1(is,iss)/dfloat(nsltdv)
          d6isss=df6(is,iss)/dfloat(nsltdv)
          d12isss=df12(is,iss)/dfloat(nsltdv)
          ds1isss=ds1(is,iss)/dfloat(nsltdv)
          ds6isss=ds6(is,iss)/dfloat(nsltdv)
          ds12isss=ds12(is,iss)/dfloat(nsltdv)
          de1isss=de1(is,iss)/dfloat(nsltdv)
          de6isss=de6(is,iss)/dfloat(nsltdv)
          de12isss=de12(is,iss)/dfloat(nsltdv)
c         Calculate derivatives w.r.t. c1,c6 and c12
          dec1=d1isss+beta*(u*d1isss-de1isss)
          dec6=d6isss+beta*(u*d6isss-de6isss)
          dec12=d12isss+beta*(u*d12isss-de12isss)
          dsc1=d1isss+beta*(us*d1isss-ds1isss)
          dsc6=d6isss+beta*(us*d6isss-ds6isss)
          dsc12=d12isss+beta*(us*d12isss-ds12isss)
          write (iout,1036) is,iss,dec1,dec6,dec12,dsc1,dsc6,dsc12
          if (iss .eq. 1) then
c           Calculate derivatives w.r.t. epsilon and sigma
c           Obtain the current epsilon and sigma values, eps and sig
            sig=(c12ji(is,1)/c6ji(is,1))**(1.0/6.0)
            eps=c6ji(is,1)**2/(4.0*c12ji(is,1))
            epss=eps**2/epsilonw
            if (iop(52) .eq. 0) then
              sigs=sig**2/sigmaw
            else
              sigs=2.0*sig-sigmaw
            end if
c           Geometric combination rules for epsilon in either case
            deeps=(dec6/sig**6+dec12/sig**12)*2.0*sqrt(epsilonw/epss)
            dseps=(dsc6/sig**6+dsc12/sig**12)*2.0*sqrt(epsilonw/epss)
            if (iop(52) .eq. 0) then
              desig=-(dec6*12.0*eps/(sigmaw**3*sigs**4)+
     -                dec12*16.0*eps/(sigmaw**6*sigs**7))*eps
              dssig=-(dsc6*12.0*eps/(sigmaw**3*sigs**4)+
     -                dsc12*16.0*eps/(sigmaw**6*sigs**7))*eps
            else
              desig=-(dec6*12.0*eps/sigmaw**7+
     -                dec12*24.0*eps/sigmaw**13)*eps
              dssig=-(dsc6*12.0*eps/sigmaw**7+
     -                dsc12*24.0*eps/sigmaw**13)*eps
            end if
            write (iout,2036) deeps,desig,dseps,dssig
          end if
        end do
      end do
      return
1035  format(/,' Derivatives of the total energy (E) and solute',
     -  ' binding energy (S) w.r.t. solute parameters ',/,
     -  ' Derivatives are calculated w.r.t. the coefficients of the',
     -  ' 1/r, 1/r**6 and 1/r**12 terms (c1, c6 and c12, resp.)',/
     -  ' and w.r.t. Lennard -Jones parameters epsilon and sigma',
     -  ' belonging to the solute assuming the first solvent site',
     -  ' to be the water oxygen (units: kcal and A)',/)
1036  format(' Solute site=',i5,'   Solvent site=',i5,/,' d(E)/d(c1)=',
     -  e12.5,' d(E)/d(c6)=',e12.5,' d(E)/d(c12)=',e12.5,/,
     -  ' d(S)/d(c1)=',e12.5,' d(S)/d(c6)=',e12.5,' d(S)/d(c12)=',e12.5)
2036  format('  d(E)/d(eps,o)=',e12.5,'   d(E)/d(sig,o)=',e12.5,/,
     -  '  d(S)/d(eps,o)=',e12.5,'   d(S)/d(sig,o)=',e12.5)
2000  format(1x,a,' RESULTS:')
      end
      subroutine linwgt(npf,rpf,apf,wpsmvn,ri,nmax,inperr,iout)
c#    MMC routine 284 lstmod: 03/03/08
c*****Prepares a set of interpolated weights on a grid of ri width
c     using the inputted values apfmv(i) at rpf(i)
      dimension apf(npf),rpf(npf),wpsmvn(nmax)
      data j1 /0/
      nnmax=rpf(npf)/ri+1
      if (nnmax .gt. nmax) then
        write (iout,1000) nnmax
        inperr=inperr+1
        return
      end if
      if (npf .le. 1) then
        write (iout,1001)
        inperr=inperr+1
        return
      end if
      j2=rpf(1)/ri
      do j=1,j2
        wpsmvn(j)=apf(1)
      end do
      do i=2,npf
        j1=j2+1
        j2=rpf(i)/ri+1
        www=apf(i-1)+(apf(i)-apf(i-1))/float(j2-j1+1)
        do j=j1,j2
          wpsmvn(j)=www*float(j-j1+1)
        end do
      end do
      do j=1,j1-1
        wpsmvn(j)=apf(1)
      end do
      do j=j2+1,nmax
        wpsmvn(j)=apf(npf)
      end do
      return
1000  format(' ***** ERROR: array for piecewise linear weight is ',
     -  'too short - increase # PG to ',i6)
1001  format(' ***** ERROR: interpolation needs at least two values')
      end
      subroutine putmol(natms,relcrd,crm,c,ort)
c#    MMC routine 285 lstmod: 08/31/95
c*****Put a molecule at  crm as c, with random orientation ort
      dimension relcrd(3,natms),c(3,natms),crm(3),ort(3,3)
      call ranort(ort)
      call rot_trans(ort,relcrd,crm,c,natms)
      return
      end
      subroutine ranort(r)
c#    MMC routine 286 lstmod: 10/10/90
c*****Generate an orientation matrix from the uniform distribution
c     from the 3 Euler angles
      real*8 rn
      dimension r(3,3),rn(3)
c     This subroutine prepares a random rotation matrix
c     eq(4-47) of Goldstein (r=a)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      call mmc_random(3,rn)
      fir=rn(1)*pi*2.0
      psr=rn(3)*pi*2.0
      cth=-1.0+2.0*rn(2)
      sth=sqrt(1.0-cth*cth)
      sfi=sin(fir)
      cfi=cos(fir)
      sps=sin(psr)
      cps=cos(psr)
      r(1,1)=cps*cfi-cth*sfi*sps
      r(2,1)=-sps*cfi-cth*sfi*cps
      r(3,1)=sth*sfi
      r(1,2)=cps*sfi+cth*cfi*sps
      r(2,2)=-sps*sfi+cth*cfi*cps
      r(3,2)=-sth*cfi
      r(1,3)=sth*sps
      r(2,3)=sth*cps
      r(3,3)=cth
      return
      end
      subroutine solvinout(inout,c,edgelin,edgerin)
c#    MMC routine 287 lstmod: 07/31/99
c*****Decide if a molec is in the innner or outer region
      dimension c(3) ,edgelin(3),edgerin(3)
      inout=1
      do k=1,3
        if (c(k) .lt. edgelin(k) .or. c(k) .gt. edgerin(k)) then
          inout=2
          return
        end if
      end do
      return
      end
      subroutine initinout(molinout,nmolinout,edgelinxyz,edgerinxyz,
     -  crm,mf,nmolec)
c#    MMC routine 288 lstmod: 10/20/05
c*****Initialize the count of molecules in and out of a rectangle
      dimension nmolinout(2),molinout(nmolec),crm(3,nmolec),
     -  edgelinxyz(3),edgerinxyz(3)
      nmolinout(1)=0
      nmolinout(2)=0
c     Assign in and out state for solvents
      do is=mf,nmolec
        call solvinout(molinout(is),crm(1,is),edgelinxyz,edgerinxyz)
        nmolinout(molinout(is))=nmolinout(molinout(is))+1
      end do
      return
      end
      subroutine initgrid(nmolec,rsphfac,rslv,nr,vsltgr,vol,
     -  c,crm,nmc,nopbc,nosolv,key,iverbin,LEVTESTin)
c#    MMC routine 289 lstmod: 02/01/22
c*****Initialize the grid cavity search arrays
      dimension c(3,#ST),crm(3,#MO)
      character*(*) key
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
C@I2      integer*2 ncover,i2test
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ),
     -  cgr(3,3)
      iverb=iverbin
      LEVTEST=LEVTESTin
      if (MYRANK .gt. 0) iverb=0
      if (MYRANK .gt. 0) LEVTEST=0
      if (iop(5) .eq. 5 .or. iop(5) .eq. 6) then
        ngfree=0
        if (MYRANK .eq. 0) write (iout,1005) key
        inperr=inperr+1
        return
      end if
c     Test for maximum number of free grids
      maxgfree=#CV
      i=2**15
      i2test=i
      if (i2test .lt. 0 .and. i .lt. #CV) then
        maxgfree=i-1
        nchng=nchng+1
        if (MYRANK .eq. 0) write (iout,1003) maxgfree
      end if
c     ngfree: number of uncovered grid points
c     igfree: list of uncovered gridpoints
c     ncover(i,j,k) : if > 0, the number of atoms covering that grid,
c                     if < 0, the location of that grid in igfree
c     ng3: total number of gridpoints (ngrid**3)
c     ng1,ng2: integer triple (i,j,k) is packed as (i-1)*ng2+(j-1)*ng1)+k
c     fltngr3: floating point equivalent of ng3
c     grid: distance between nearest gridpoints
c     e2g, e2gm: coordinates of two neighbour gridpoints between which
c     lies the cell wall.
c     Position of wall between two grids is scaled by ranshift (.5 means center)
c     rspupe2, rspume2: -e2g decremented, incremented by the cavity radius, rsp.
      rsphs=(rsphfac*diamslv)**2
      ng1=1024
      ng2=ng1*ng1
      ng3=ngrid(1)*ngrid(2)*ngrid(3)
      fltng3=float(ng3)
      do k=1,3
        grid(k)=gredge(k)/float(ngrid(k))
        grid2(k)=grid(k)/2.0
        e2gm(k)=-gredge(k)/2.0-ranshift(k)*grid(k)+gridcent(k)
        e2g(k)=e2gm(k)+grid(k)
      end do
      do i=1,ngrid(1)
        do j=1,ngrid(2)
          do k=1,ngrid(3)
            ncover(i,j,k)=0
          end do
        end do
      end do
      ixf=1
      iyf=1
      izf=1
      ngdrop=0
      if (iop(5) .gt. 0) then
c       Set the cover of grids outside the cell to one
        call make1dg0(e2gm(1),ngrid(1),grid(1),r2x,#GX)
        call make1dg0(e2gm(2),ngrid(2),grid(2),r2y,#GY)
        call make1dg0(e2gm(3),ngrid(3),grid(3),r2z,#GZ)
        do i=1,ngrid(1)
          do j=1,ngrid(2)
            do k=1,ngrid(3)
              cx=r2x(i)
              cy=r2y(j)
              cz=r2z(k)
              call pbcnd(cx,cy,cz,iop(5),iopt,r2)
              if (iopt .gt. 1) then
                ngdrop=ngdrop+1
                ncover(i,j,k)=999
              end if
            end do
          end do
        end do
      end if
      if (iverb .gt. 0) then
        write (iout,2040) ranshift,ngrid,ng3,ng3-ngdrop,grid,gredge
        if (iverb .gt. 1) write (iout,2042) e2gm,gridcent
        if (iop(76) .gt. 0)
     -    write (iout,2041) (edgelgr(k),edgergr(k),k=1,3)
        if (nmolec .gt. 1) write (iout,1006)
      end if
      iop5grid=iop(5)+10*nopbc
      nsltfr=ng3-ngdrop
      fltng3=float(nsltfr)
      nsltcv=0
c     For each solute atom, count the coverings of their grids
      call sltrad(rsphi,ianslt,nstta,rslv,nr,iop(62),rsltfac,rsphfac,1)
      if (idebug(155) .gt. 0) write (iout,1007)
     -  (ia,ianslt(ia),rsphi(ia),ia=1,nstta)
c     First, make sure all atoms are in the cell
      call trnsfr(zv,c,nstta3)
      if (iop(83) .gt. 0) call pbcvec(iop(5),1,nstta)
c     Now, zv contains all the reset atoms (if requested), otherwise the origs
      do ia=istf,nstta
        if (ianslt(ia) .gt. 1) then
          rsphsi=rsphi(ia)**2
          do k=1,3
            rspupe2(k)=rsphi(ia)+e2gm(k)
            rspume2(k)=rsphi(ia)-e2gm(k)
          end do
          call gridcopy(cgr,zv(1,ia),rsphi(ia),ngcop,iop5grid)
          do ig=1,ngcop
            call makegrid(cgr(1,ig),rspupe2,rspume2,
     -        r2x,r2y,r2z,igx,igy,igz,ngx,ngy,ngz)
            if (nopbc .eq. 1) then
              call nopbcgr(igx,ixf,ngx,cgr(1,ig),#GX)
              call nopbcgr(igy,iyf,ngy,cgr(2,ig),#GY)
              call nopbcgr(igz,izf,ngz,cgr(3,ig),#GZ)
            end if
            do i=ixf,ngx
              r2xs=r2x(i)
              do j=iyf,ngy
                r2ys=r2xs+r2y(j)
                if (r2ys .le. rsphsi) then
                  do k=izf,ngz
                    if (r2ys+r2z(k) .le. rsphsi) then
                      ic=igx(i)
                      jc=igy(j)
                      kc=igz(k)
                      if (ncover(ic,jc,kc) .eq. 0) nsltcv=nsltcv+1
                      ncover(ic,jc,kc)=ncover(ic,jc,kc)+1
                    end if
                  end do
                end if
              end do
            end do
          end do
        end if
      end do
      nsltfr=ng3-nsltcv-ngdrop
      if (iop(89) .eq. 1) fltng3=float(nsltfr)
c     Estimate the solute volume from the number of grids covered
      vsltgr=vol*float(nsltcv)/float(ng3-ngdrop)
      do k=1,3
        rspvpe2(k)=diamslv+e2gm(k)
        rspvme2(k)=diamslv-e2gm(k)
      end do
      if (nosolv .eq. 0) then
c       For each solvent molecule count the coverings of their grids
        do im=2,nmolec
          call gridcopy(cgr,crm(1,im),diamslv*rsphfac,ngcop,iop5grid)
          do ig=1,ngcop
              call makegrid(cgr(1,ig),rspvpe2,rspvme2,
     -        r2x,r2y,r2z,igx,igy,igz,ngx,ngy,ngz)
            if (nopbc .eq. 1) then
              call nopbcgr(igx,ixf,ngx,cgr(1,ig),#GX)
              call nopbcgr(igy,iyf,ngy,cgr(2,ig),#GY)
              call nopbcgr(igz,izf,ngz,cgr(3,ig),#GZ)
            end if
            do i=ixf,ngx
              r2xs=r2x(i)
              do j=iyf,ngy
                r2ys=r2xs+r2y(j)
                if (r2ys .le. rsphs) then
                  do k=izf,ngz
                    if (r2ys+r2z(k) .le. rsphs) then
                      ic=igx(i)
                      jc=igy(j)
                      kc=igz(k)
                      ncover(ic,jc,kc)=ncover(ic,jc,kc)+1
                    end if
                  end do
                end if
              end do
            end do
          end do
        end do
      end if
c     Count and collect the free sites
      ngfree=0
      do ic=1,ngrid(1)
        do jc=1,ngrid(2)
          do kc=1,ngrid(3)
            if (ncover(ic,jc,kc) .eq. 0) then
c             Free grid (cavity) found
              indx=(ic-1)*ng2+(jc-1)*ng1+kc
              ngfree=ngfree+1
              if (LEVTEST .gt. 2)
     -          write (iout,8791) ngfree,ic,jc,kc,e2gm(1)+ic*grid(1),
     -           e2gm(2)+jc*grid(2),e2gm(3)+kc*grid(3)
              if (ngfree .gt. maxgfree) go to 99
              ncover(ic,jc,kc)=-ngfree
              igfree(ngfree)=indx
            end if
          end do
        end do
      end do
      if (iverb .gt. 0) then
        if (nmc .eq. 0) write (iout,2050) rsphfac*diamslv*nr,nsltcv,
     -    nsltfr,vsltgr
        if (nmc .gt. 0) write (iout,2050) rsphfac*diamslv*nr,nsltcv,
     -    nsltfr,vsltgr,' ',nmc
        if (nmolec .gt. 1) write (iout,2060) ngfree
      end if
      if (ngfree .eq. 0) then
        if (MYRANK .eq. 0) write (iout,1002) diamslv
        nwwarn=nwwarn+1
      end if
      if (float(ngfree)/#CV.0 .gt. 0.9 .and.
     -     #CV .lt. #GX*#GY*#GZ) then
        if (MYRANK .eq. 0) write (iout,1004)
        nwarn=nwarn+1
      end if
      return
99    call checkdim(ifail,iout,inperr,'CV',ngfree,0,0,0)
      if (i2test .lt. 0 .and. MYRANK .eq. 0) write (iout,1000)
      call datprt(2)
1000  format(' Cavity capacity can also be increased if the ',
     -  'preprocessor variable I2 is set to "F"')
1002  format(' ===== STRONG WARNING: there are no cavities of radius ',
     - f5.2,' A - try running with smaller cavity radius')
1003  format(' >>>>> OVERRIDE: Number of free gridpoints is reduced ',
     -  'from #CV to',i8,/,' Recompile with the ',
     -  'preprocessor variable I2 set to "F"')
1004  format(' ----- WARNING: Free grid list is over 90% full ',/,
     -  ' run may abort due to filling up the list - recompile with ',
     -  ' larger # CV or run with coarser grid')
1005  format(' ***** ERROR: key ',a,' requires periodic boundary ',
     -  ' conditions (PBCN RECT or PBCN HEXG or PBCN FCC)')
1006  format(' Solvents will not be used for covering grids')
1007  format(' INITGRID:',/,(i5,' iatno=',i3,' R=',f8.5))
2040  format(' Initializing the covering grid with a shift of ',3f6.3,
     -  ' % of the gridsize',/,14x,'Number of grids: ',3i5,' Total # ',
     -  'of gridpoints=',i12,' # of gridpoints in the PBC cell=',i12,/,
     -  14x,'Gridsizes:',3f6.3,' A',/,14x,'Grid box edges=',3f10.5)
2041  format(' Grid is limited to X : [',f8.2,' - ',f8.2,'] ',
     -  ' Y : [',f8.2,' - ',f8.2,']  Z : [',f8.2,' - ',f8.2,']')
2042  format(' e2gm=',3f10.5,' gridcent=',3f10.5)
2050  format(' Using Rcav=',f6.2,' A, the solute covers',i8,
     -  ' gridpoints, leaving',i9,' gridpoints - Vol=',f12.1,a,
     -  'at Nmc=',i10)
2060  format(' Number of free gridpoints left after considering ',
     -  'the solvent=',i8)
8791  format(' INITGR cavity',i8,' ixyz=',3i4,' cg=',3f10.5)
      end
      subroutine makefullgrid(xyzmin,xyzmax,rsph,iout)
c#    MMC routine 289/a lstmod: 03/31/19
c*****Make a grid just around the solute
      dimension xyzmin(3),xyzmax(3)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      do k=1,3
        gredge(k)=2.0*rsph+xyzmax(k)-xyzmin(k)
        grid(k)=gredge(k)/float(ngrid(k))
        grid2(k)=grid(k)/2.0
        gridcent(k)=(xyzmax(k)+xyzmin(k))/2.0
        e2gm(k)=-gredge(k)/2.0-ranshift(k)*grid(k)+gridcent(k)
        e2g(k)=e2gm(k)+grid(k)
      end do
      write (iout,2000) rsph
      return
2000  format(' Created a grid encompassing the solute plus a layer ',
     -  'of',f5.2,' A')
      end
      subroutine gridcopy(cgr,c,diamslv,ngcop,iop5)
c#    MMC routine 290 lstmod: 06/08/07
c*****Create the periodic image list for cavity covering
      dimension cgr(3,3),c(3)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      ngcop=1
      call trnsfr(cgr,c,3)
      if (iop5 .eq. 4) then
        zr=edgexyz(2)-2.0*diamslv
        ya=abs(c(2))
        za=abs(c(3))
        if (za .gt. zr-ya/sq3) then
c         c is in the border zone
          zsign=c(3)/za
          if (za .gt. zr+c(2)/sq3) then
c           Two images - c is in two border band
            ngcop=3
            cgr(1,2)=c(1)
            cgr(1,3)=c(1)
            cgr(2,2)=c(2)+edgexyz(2)*sq3p2
            cgr(2,3)=c(2)-edgexyz(2)*sq3p2
            cgr(3,2)=c(3)-zsign*1.5*edgexyz(2)
            cgr(3,3)=c(3)+zsign*1.5*edgexyz(2)
          else if (ya .gt. edgexyz(2)*sq3) then
c           Two images - c is in two border band
            ngcop=3
            ysign=c(2)/ya
            cgr(1,2)=c(1)
            cgr(1,3)=c(1)
            cgr(2,2)=c(2)-ysign*edgexyz(2)*sq3p2
            cgr(3,2)=c(3)-zsign*1.5*edgexyz(2)
 
          else
c           Only one image
            ngcop=2
            ysign=c(2)/ya
            cgr(1,2)=c(1)
            cgr(2,2)=c(2)-ysign*edgexyz(2)*sq3p2
            cgr(3,2)=c(3)-zsign*1.5*edgexyz(2)
            cgr(2,3)=c(2)-ysign*edgexyz(2)*sq3
            cgr(3,3)=c(3)
          end if
        end if
      end if
      return
      end
      subroutine addcov(r,rsphs,rspvpe2,rspvme2,igcop)
c#    MMC routine 291 lstmod: 07/07/99
c*****Update grid data when a new atom is added
      dimension r(3),rspvpe2(3),rspvme2(3)
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /option/ iop(200),idebug(200)
      dimension r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ),
     -  cgr(3,3)
      ngfreeo=ngfree
      call gridcopy(cgr,r,sqrt(rsphs),ngcop,iop(5)*igcop)
      do ig=1,ngcop
        call makegrid(cgr(1,ig),rspvpe2,rspvme2,
     -    r2x,r2y,r2z,igx,igy,igz,ngx,ngy,ngz)
        do i=1,ngx
          r2xs=r2x(i)
          do j=1,ngy
            r2ys=r2xs+r2y(j)
            if (r2ys .le. rsphs) then
              do k=1,ngz
                if (r2ys+r2z(k) .le. rsphs) then
                  ic=igx(i)
                  jc=igy(j)
                  kc=igz(k)
                  if (ncover(ic,jc,kc) .gt. 0) then
                    ncover(ic,jc,kc)=ncover(ic,jc,kc)+1
                  else
c                   Grid was free
                    igdel=-ncover(ic,jc,kc)
                    indx=igfree(ngfree)
                    igfree(igdel)=indx
                    call unpackijk(indx,ng1,ix,iy,iz)
                    ncover(ix,iy,iz)=-igdel
                    igfree(ngfree)=igdel
                    ngfree=ngfree-1
                    ncover(ic,jc,kc)=1
                  end if
                end if
              end do
            end if
          end do
        end do
      end do
      return
      end
      subroutine adcslt(coor,nsltf,nsltl,ixslt,ianslt)
c#    MMC routine 292 lstmod: 07/09/98
c*****Recalculate the covered grid points when the solute is moved to a new
c     location
      dimension ixslt(nsltl),ianslt(#ST)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /option/ iop(200),idebug(200)
      dimension coor(3,#ST)
c     For each solute atom, count the coverings of their grids
      ngfreeo=ngfree
      if (iop(83) .eq. 0) then
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            rsphsi=rsphi(ia)**2
            do k=1,3
              rspupe2(k)=rsphi(ia)+e2gm(k)
              rspume2(k)=rsphi(ia)-e2gm(k)
            end do
            call addcov(coor(1,ia),rsphsi,rspupe2,rspume2,1)
          end if
        end do
      else
c       Reset to cell
        nats=0
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            nats=nats+1
            texng(nats)=rsphi(ia)**2
            call trnsfr(zv(1,nats),coor(1,ia),3)
          end if
        end do
        call pbcvec(iop(5),1,nats)
        do ia=1,nats
          rsphsi=texng(ia)
          do k=1,3
            rspupe2(k)=texng(ia)+e2gm(k)
            rspume2(k)=texng(ia)-e2gm(k)
          end do
          call addcov(zv(1,ia),rsphsi,rspupe2,rspume2,1)
        end do
      end if
      return
      end
      subroutine remcov(iout,r,rsphs,rspvpe2,rspvme2,igcop)
c#    MMC routine 293 lstmod: 07/07/99
c*****Update grid data when an atom is removed
      dimension r(3),rspvpe2(3),rspvme2(3)
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /option/ iop(200),idebug(200)
      dimension r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ),
     -  cgr(3,3)
      ngfreeo=ngfree
      call gridcopy(cgr,r,sqrt(rsphs),ngcop,iop(5)*igcop)
      do ig=1,ngcop
        call makegrid(cgr(1,ig),rspvpe2,rspvme2,
     -    r2x,r2y,r2z,igx,igy,igz,ngx,ngy,ngz)
        do i=1,ngx
          r2xs=r2x(i)
          do j=1,ngy
            r2ys=r2xs+r2y(j)
            if (r2ys .le. rsphs) then
              do k=1,ngz
                if (r2ys+r2z(k) .le. rsphs) then
                  ic=igx(i)
                  jc=igy(j)
                  kc=igz(k)
                  if (ncover(ic,jc,kc) .gt. 1) then
                    ncover(ic,jc,kc)=ncover(ic,jc,kc)-1
                  else if (ncover(ic,jc,kc) .eq. 1) then
c                   Grid became free
                    ngfree=ngfree+1
                    igfree(ngfree)=(ic-1)*ng2+(jc-1)*ng1+kc
                    ncover(ic,jc,kc)=-ngfree
                  end if
                end if
              end do
            end if
          end do
        end do
      end do
      if (ngfree .le. maxgfree) return
      call checkdim(ifail,iout,inperr,'CV',ngfree,0,0,0)
      call datprt(2)
      end
      subroutine rmcslt(iout,coor,nsltf,nsltl,ixslt,ianslt,istop)
c#    MMC routine 294 lstmod: 07/09/98
c*****Empty the previously covered grid points when the solute is moved
      dimension ixslt(nsltl),ianslt(#ST)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /option/ iop(200),idebug(200)
      dimension coor(3,#ST)
c     For each solute atom, count the coverings of their grids
      istop=0
      ngfreeo=ngfree
      if (iop(83) .eq. 0) then
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            rsphsi=rsphi(ia)**2
            do k=1,3
              rspupe2(k)=rsphi(ia)+e2gm(k)
              rspume2(k)=rsphi(ia)-e2gm(k)
            end do
            call remcov(iout,coor(1,ia),rsphsi,rspupe2,rspume2,1)
          end if
        end do
      else
c       Reset to cell
        nats=0
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            nats=nats+1
            texng(nats)=rsphi(ia)**2
            call trnsfr(zv(1,nats),coor(1,ia),3)
          end if
        end do
        call pbcvec(iop(5),1,nats)
        do ia=1,nats
          rsphsi=texng(ia)
          do k=1,3
            rspupe2(k)=texng(ia)+e2gm(k)
            rspume2(k)=texng(ia)-e2gm(k)
          end do
          call remcov(iout,zv(1,ia),rsphsi,rspupe2,rspume2,1)
        end do
      end if
      if (ngfree .le. maxgfree) return
      call checkdim(ifail,iout,inperr,'CV',ngfree,0,0,0)
      istop=1
      return
      end
      subroutine movcov(ro,rn,iout,c,crm,rsph2,rspuvpe2,rspuvme2)
c#    MMC routine 295 lstmod: 12/13/04
c*****Update grid data when an atom is moved
      dimension ro(3),rn(3),c(3,#NA),crm(3,#MO)
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /option/ iop(200),idebug(200)
      dimension rgd(3),ignew(3),igold(3)
      dimension r2xn(#GX),r2yn(#GY),r2zn(#GZ),
     -  r2xo(#GX),r2yo(#GY),r2zo(#GZ),igx(#GX),igy(#GY),igz(#GZ),
     -  igxo0(#GX),igyo0(#GY),igzo0(#GZ),igx0(#GX),igy0(#GY),igz0(#GZ),
     -  rspuvpe2(3),rspuvme2(3),cgro(3,3),cgrn(3,3)
      data ignew /1,0,0/,igold /1,0,0/
      if (idebug(50) .eq. 2) then
         call remcov(iout,ro,rsph2,rspuvpe2,rspuvme2,1)
         call addcov(rn,rsph2,rspuvpe2,rspuvme2,1)
         return
      end if
      call gridcopy(cgro,ro,sqrt(rsph2),ngcopo,iop(5))
      call gridcopy(cgrn,rn,sqrt(rsph2),ngcopn,iop(5))
c     Match up the copies so that images near each other are paired
      ngcop=max0(ngcopo,ngcopn)
      do ig=2,ngcop
        ignew(ig)=ig
        igold(ig)=ig
      end do
      if (ngcopn .gt. ngcopo) then
        if (ngcopn .eq. 3) then
          if (ngcopo .eq. 2) then
            if (cgro(2,2) .lt. 0) then
              igold(2)=0
              igold(3)=2
            else
              igold(3)=0
            end if
          else
            igold(2)=0
            igold(3)=0
          end if
        else
          igold(2)=0
        end if
      else if (ngcopo .gt. ngcopn) then
        if (ngcopo .eq. 3) then
          if (ngcopn .eq. 2) then
            if (cgrn(2,2) .lt. 0) then
              ignew(2)=0
              ignew(3)=2
            else
              ignew(3)=0
            end if
          else
            ignew(2)=0
            ignew(3)=0
          end if
        else
          ignew(2)=0
        end if
      end if
 
      do ig=1,ngcop
      ign=ignew(ig)
      igo=igold(ig)
 
      if (ign*igo .eq. 0) then
c       One image without pair
        no2=1
      else
        call makegrid2(cgrn(1,ign),cgro(1,igo),rspuvpe2,rspuvme2,
     -    r2xn,r2yn,r2zn,r2xo,r2yo,r2zo,igx,igy,igz,ngx,ngy,ngz,igx0,
     -    igy0,igz0,igxo0,igyo0,igzo0,imin,imax,jmin,jmax,kmin,kmax,no2)
      end if
      if (no2 .eq. 1 .or. idebug(50) .gt. 0) then
c       No intersection, just remove and add
        if (iop(63) .eq. 0) then
          if (igo .gt. 0)
     -      call remcov(iout,cgro(1,igo),rsph2,rspuvpe2,rspuvme2,0)
          if (ign .gt. 0)
     -      call addcov(cgrn(1,ign),rsph2,rspuvpe2,rspuvme2,0)
        else
          if (igo .gt. 0) then
c         --Remcov body including PS weight updates
          call makegrid(cgro(1,igo),rspuvpe2,rspuvme2,r2xo,r2yo,r2zo,
     -      igx,igy,igz,ngx,ngy,ngz)
          do i=1,ngx
            r2xs=r2xo(i)
            do j=1,ngy
              r2ys=r2xs+r2yo(j)
              if (r2ys .le. rsph2) then
                do k=1,ngz
                  if (r2ys+r2zo(k) .le. rsph2) then
                    ic=igx(i)
                    jc=igy(j)
                    kc=igz(k)
                    if (ncover(ic,jc,kc) .gt. 1) then
                      ncover(ic,jc,kc)=ncover(ic,jc,kc)-1
                    else
c                     Grid became free
                      ngfree=ngfree+1
                      if (ngfree .le. #PP) then
                        igfree(ngfree)=(ic-1)*ng2+(jc-1)*ng1+kc
                        ncover(ic,jc,kc)=-ngfree
c                       Obtain PS weight for this grid
                        rgd(1)=e2gm(1)+ic*grid(1)
                        rgd(2)=e2gm(2)+jc*grid(2)
                        rgd(3)=e2gm(3)+kc*grid(3)
c                       Obtain integer distance of this grid from PS center
                        idgrid=intgpsdis(iop(8),rgd,wpfidcen,rri,c,crm)
                        wpsgdnew=prfwgt(idgrid,wpsidn,iop(79))
                        wpsgdsum=wpsgdsum+wpsgdnew
                        wpsgd(ngfree)=wpsgdnew
                        if (ipsgd(ngfree) .eq. 0) ipsgd(ngfree)=npfsgd
                        do is=ipsgd(ngfree),npfsgd
                          wpfpsgd(is)=wpfpsgd(is)+wpsgdnew
                          limpsgd(is)=limpsgd(is)+1
                        end do
                      else
                        call checkdim(ifail,iout,inperr,'PP',ngfree,
     -                    0,0,0)
                        call datprt(2)
                      end if
                    end if
                  end if
                end do
              end if
            end do
          end do
          end if
          if (ign .gt. 0) then
c         --Addcov body including PS weight updates
          call makegrid(cgrn(1,ign),rspuvpe2,rspuvme2,
     -      r2xn,r2yn,r2zn,igx,igy,igz,ngx,ngy,ngz)
          do i=1,ngx
            r2xs=r2xn(i)
            do j=1,ngy
              r2ys=r2xs+r2yn(j)
              if (r2ys .le. rsph2) then
                do k=1,ngz
                  if (r2ys+r2zn(k) .le. rsph2) then
                    ic=igx(i)
                    jc=igy(j)
                    kc=igz(k)
                    if (ncover(ic,jc,kc) .gt. 0) then
                      ncover(ic,jc,kc)=ncover(ic,jc,kc)+1
                    else
c                     Grid was free
                      igdel=-ncover(ic,jc,kc)
                      indx=igfree(ngfree)
                      igfree(igdel)=indx
                      call unpackijk(indx,ng1,ix,iy,iz)
                      ncover(ix,iy,iz)=-igdel
                      igfree(ngfree)=igdel
                      ngfree=ngfree-1
                      ncover(ic,jc,kc)=1
c                     Remove weights from the list and sums
                      wpsgdold=wpsgd(igdel)
                      wpsgdsum=wpsgdsum-wpsgdold
                      do is=ipsgd(igdel),npfsgd
                        wpfpsgd(is)=wpfpsgd(is)-wpsgdold
                      end do
                      do is=ipsgd(igdel),ipsgd(ngfree)-1
                        wpfpsgd(is)=wpfpsgd(is)+wpsgd(ngfree)
                      end do
                      do is=ipsgd(ngfree),npfsgd
                        limpsgd(is)=limpsgd(is)-1
                      end do
                      wpsgd(igdel)=wpsgd(ngfree)
                    end if
                  end if
                end do
              end if
            end do
          end do
          end if
        end if
      else
c       Do intersection first
        do i=1,ngx
          r2xns=r2xn(i)
          r2xos=r2xo(i)
          do j=1,ngy
            r2yns=r2xns+r2yn(j)
            r2yos=r2xos+r2yo(j)
            if (r2yos .le. rsph2 .or. r2yns .le. rsph2) then
              do k=1,ngz
                r2zns=r2yns+r2zn(k)
                r2zos=r2yos+r2zo(k)
                if (r2zos .le. rsph2 .and. r2zns .gt. rsph2) then
                  ic=igx(i)
                  jc=igy(j)
                  kc=igz(k)
c                 Reduce cover
                  if (ncover(ic,jc,kc) .gt. 1) then
                    ncover(ic,jc,kc)=ncover(ic,jc,kc)-1
                  else
c                   Grid became free
                    ngfree=ngfree+1
                    igfree(ngfree)=(ic-1)*ng2+(jc-1)*ng1+kc
                    ncover(ic,jc,kc)=-ngfree
                    if (iop(63) .gt. 0) then
                      if (ngfree .le. #PP) then
c                       Obtain PS weight for this grid
                        rgd(1)=e2gm(1)+ic*grid(1)
                        rgd(2)=e2gm(2)+jc*grid(2)
                        rgd(3)=e2gm(3)+kc*grid(3)
c                       Obtain integer distance of this grid from PS center
                        idgrid=intgpsdis(iop(8),rgd,wpfidcen,rri,c,crm)
                        wpsgdnew=prfwgt(idgrid,wpsidn,0)
                        wpsgd(ngfree)=wpsgdnew
                        wpsgdsum=wpsgdsum+wpsgdnew
                        if (ipsgd(ngfree) .eq. 0) ipsgd(ngfree)=npfsgd
                        do is=ipsgd(ngfree),npfsgd
                          wpfpsgd(is)=wpfpsgd(is)+wpsgdnew
                          limpsgd(is)=limpsgd(is)+1
                        end do
                      else
                        call checkdim(ifail,iout,inperr,'PP',ngfree,
     -                    0,0,0)
                        call datprt(2)
                      end if
                    end if
                  end if
                else if (r2zos .gt. rsph2 .and. r2zns .le. rsph2) then
c                 Increase cover
                  ic=igx(i)
                  jc=igy(j)
                  kc=igz(k)
                  if (ncover(ic,jc,kc) .gt. 0) then
                    ncover(ic,jc,kc)=ncover(ic,jc,kc)+1
                  else
c                   Grid was free
                    igdel=-ncover(ic,jc,kc)
                    indx=igfree(ngfree)
                    igfree(igdel)=indx
                    call unpackijk(indx,ng1,ix,iy,iz)
                    ncover(ix,iy,iz)=-igdel
                    ncover(ic,jc,kc)=1
                    if (iop(63) .gt. 0) then
c                     Remove weights from the list and sums
                      wpsgdold=wpsgd(igdel)
                      wpsgdsum=wpsgdsum-wpsgdold
                      do is=ipsgd(igdel),npfsgd
                        wpfpsgd(is)=wpfpsgd(is)-wpsgdold
                      end do
                      do is=ipsgd(igdel),ipsgd(ngfree)-1
                        wpfpsgd(is)=wpfpsgd(is)+wpsgd(ngfree)
                      end do
                      do is=ipsgd(ngfree),npfsgd
                        limpsgd(is)=limpsgd(is)-1
                      end do
                      wpsgd(igdel)=wpsgd(ngfree)
                    end if
                    ngfree=ngfree-1
                  end if
                end if
              end do
            end if
          end do
        end do
c       Now do the truncated grids
        call makegrid(cgro(1,igo),rspuvpe2,rspuvme2,
     -    r2xo,r2yo,r2zo,igx,igy,igz,ngx,ngy,ngz)
        do i=1,ngx
          ixin=0
          if (igxo0(i) .ge. imin .and. igxo0(i) .le. imax) ixin=1
          r2xs=r2xo(i)
          do j=1,ngy
            iyin=0
            if (igyo0(j) .ge. jmin .and. igyo0(j) .le. jmax) iyin=1
            r2ys=r2xs+r2yo(j)
            if (r2ys .le. rsph2) then
              do k=1,ngz
                izin=0
                if (igzo0(k) .ge. kmin .and. igzo0(k) .le. kmax) izin=1
                if (ixin*iyin*izin .eq. 0) then
                    if (r2ys+r2zo(k) .le. rsph2) then
                    ic=igx(i)
                    jc=igy(j)
                    kc=igz(k)
                    if (ncover(ic,jc,kc) .gt. 1) then
                      ncover(ic,jc,kc)=ncover(ic,jc,kc)-1
                    else
c                     Grid became free
                      ngfree=ngfree+1
                      igfree(ngfree)=(ic-1)*ng2+(jc-1)*ng1+kc
                      ncover(ic,jc,kc)=-ngfree
                      if (iop(63) .gt. 0) then
                        if (ngfree .le. #PP) then
c                         Obtain PS weight for this grid
                          rgd(1)=e2gm(1)+ic*grid(1)
                          rgd(2)=e2gm(2)+jc*grid(2)
                          rgd(3)=e2gm(3)+kc*grid(3)
c                         Obtain integer distance of this grid from PS center
                          idgrid=intgpsdis(iop(8),rgd,wpfidcen,rri,
     -                      c,crm)
                          wpsgdnew=prfwgt(idgrid,wpsidn,0)
                          wpsgd(ngfree)=wpsgdnew
                          wpsgdsum=wpsgdsum+wpsgdnew
                          if (ipsgd(ngfree) .eq. 0) ipsgd(ngfree)=npfsgd
                          do is=ipsgd(ngfree),npfsgd
                            wpfpsgd(is)=wpfpsgd(is)+wpsgdnew
                            limpsgd(is)=limpsgd(is)+1
                          end do
                        else
                          call checkdim(ifail,iout,inperr,'PP',ngfree,
     -                      0,0,0)
                          call datprt(2)
                        end if
                      end if
                    end if
                  end if
                end if
              end do
            end if
          end do
        end do
        call makegrid(cgrn(1,ign),rspuvpe2,rspuvme2,
     -    r2xn,r2yn,r2zn,igx,igy,igz,ngx,ngy,ngz)
        do i=1,ngx
          ixin=0
          if (igx0(i) .ge. imin .and. igx0(i) .le. imax) ixin=1
          r2xs=r2xn(i)
          do j=1,ngy
            iyin=0
            if (igy0(j) .ge. jmin .and. igy0(j) .le. jmax) iyin=1
            r2ys=r2xs+r2yn(j)
            if (r2ys .le. rsph2) then
              do k=1,ngz
                izin=0
                if (igz0(k) .ge. kmin .and. igz0(k) .le. kmax) izin=1
                if (ixin*iyin*izin .eq. 0) then
                  if (r2ys+r2zn(k) .le. rsph2) then
                    ic=igx(i)
                    jc=igy(j)
                    kc=igz(k)
                    if (ncover(ic,jc,kc) .gt. 0) then
                      ncover(ic,jc,kc)=ncover(ic,jc,kc)+1
                    else
c                     Grid was free
                      igdel=-ncover(ic,jc,kc)
                      indx=igfree(ngfree)
                      igfree(igdel)=indx
                      call unpackijk(indx,ng1,ix,iy,iz)
                      ncover(ix,iy,iz)=-igdel
                      igfree(ngfree)=igdel
                      ngfree=ngfree-1
                      ncover(ic,jc,kc)=1
                      if (iop(63) .gt. 0) then
c                       Remove weights from the list and sums
                        wpsgdold=wpsgd(igdel)
                        wpsgdsum=wpsgdsum-wpsgdold
                        do is=ipsgd(igdel),npfsgd
                          wpfpsgd(is)=wpfpsgd(is)-wpsgdold
                        end do
                        do is=ipsgd(igdel),ipsgd(ngfree)-1
                          wpfpsgd(is)=wpfpsgd(is)+wpsgd(ngfree)
                        end do
                        do is=ipsgd(ngfree),npfsgd
                          limpsgd(is)=limpsgd(is)-1
                        end do
                        wpsgd(igdel)=wpsgd(ngfree)
                      end if
                    end if
                  end if
                end if
              end do
            end if
          end do
        end do
      end if
 
      end do
      if (ngfree .le. maxgfree) return
      call checkdim(ifail,iout,inperr,'CV',ngfree,0,0,0)
      call datprt(2)
      end
      subroutine movcovu(iout,cooro,coorn,nsltf,nsltl,ixslt,ianslt)
c#    MMC routine 296 lstmod: 08/06/99
c*****Recalculate the covered grid points when the solute is moved to a new
c     location
      dimension ixslt(nsltl),cooro(3,#ST),coorn(3,#ST),
     -  ianslt(#ST)
C@I2      integer*2 ncover
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /option/ iop(200),idebug(200)
      ngfreeoo=ngfree
c     For each solute atom, count the coverings of their grids
      if (iop(83) .eq. 0) then
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            do k=1,3
              rspupe2(k)=rsphi(ia)+e2gm(k)
              rspume2(k)=rsphi(ia)-e2gm(k)
            end do
            call movcov(cooro(1,ia),coorn(1,ia),iout,c,crm,
     -        rsphi(ia)**2,rspupe2,rspume2)
          end if
        end do
      else
c       Reset to cell
        nats=0
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            nats=nats+1
            texng(nats)=rsphi(ia)**2
            call trnsfr(zv(1,nats),cooro(1,ia),3)
          end if
        end do
        call pbcvec(iop(5),1,nats)
        call trnsfr(cgs,zv,3*nats)
        nats=0
        do iaa=nsltf,nsltl
          ia=ixslt(iaa)
          if (ianslt(ia) .gt. 1) then
            nats=nats+1
            call trnsfr(zv(1,nats),coorn(1,ia),3)
          end if
        end do
        call pbcvec(iop(5),1,nats)
        do ia=1,nats
          do k=1,3
            rspupe2(k)=texng(ia)+e2gm(k)
            rspume2(k)=texng(ia)-e2gm(k)
          end do
          call movcov(cgs(1,ia),zv(1,ia),iout,c,crm,texng(ia),
     -      rspupe2,rspume2)
        end do
      end if
      nsltfr=nsltfr+ngfree-ngfreeoo
      if (iop(89) .eq. 1) fltng3=float(nsltfr)
      return
      end
      subroutine covlim(r,imin,imax,jmin,jmax,kmin,kmax,rspp,rspm)
c#    MMC routine 297 lstmod: 12/14/96
c*****Determine the range of gridpoints to be checked around r
c     for which possible change in cover can occur
      dimension r(3),rspp(3),rspm(3)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      imin=int((r(1)-rspp(1))/grid(1))+1
      if (r(1) .lt. rspp(1)) imin=imin-1
      if (limgrl(1) .gt. 0 .and. imin .lt. 1) imin=1
      imax=int((r(1)+rspm(1))/grid(1))+0
      if (limgru(1) .gt. 0 .and. imax .gt. ngrid(1)) imax=ngrid(1)
      jmin=int((r(2)-rspp(2))/grid(2))+1
      if (r(2) .lt. rspp(2)) jmin=jmin-1
      if (limgrl(2) .gt. 0 .and. jmin .lt. 1) jmin=1
      jmax=int((r(2)+rspm(2))/grid(2))+0
      if (limgru(2) .gt. 0 .and. jmax .gt. ngrid(2)) jmax=ngrid(2)
      kmin=int((r(3)-rspp(3))/grid(3))+1
      if (r(3) .lt. rspp(3)) kmin=kmin-1
      if (limgrl(3) .gt. 0 .and. kmin .lt. 3) kmin=1
      kmax=int((r(3)+rspm(3))/grid(3))+0
      if (limgru(3) .gt. 0 .and. kmax .gt. ngrid(3)) kmax=ngrid(3)
      return
      end
      subroutine makegrid(r,rspp,rspm,r2x,r2y,r2z,igx,igy,
     -  igz,ngx,ngy,ngz)
c#    MMC routine 298 lstmod: 09/28/98
c*****Determine the  gridpoints to be checked around r
c     for which possible change in cover can occur
      dimension r(3),rspp(3),rspm(3),
     -  r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      call covlim(r,imin,imax,jmin,jmax,kmin,kmax,rspp,rspm)
      dx0=e2gm(1)-r(1)
      dy0=e2gm(2)-r(2)
      dz0=e2gm(3)-r(3)
      call make1dg(dx0,ngx,imin,imax,ngrid(1),grid(1),igx,r2x,#GX)
      call make1dg(dy0,ngy,jmin,jmax,ngrid(2),grid(2),igy,r2y,#GY)
      call make1dg(dz0,ngz,kmin,kmax,ngrid(3),grid(3),igz,r2z,#GZ)
      return
      end
C@PG      subroutine make_printprtgrid(rcut,c,e2gm,rspupe2,rspume2,
C@PG     -  r2x,r2y,r2z,ixf,iyf,izf,igx,igy,igz,ngx,ngy,ngz)
C@PGc#    MMC routine 298/a lstmod: 05/19/16
C@PGc*****set up the gri around point c
C@PG      dimension c(3),e2gm(3),rspupe2(3),rspume2(3),
C@PG     -  r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ)
C@PG      do k=1,3
C@PG        rspupe2(k)=rcut+e2gm(k)
C@PG        rspume2(k)=rcut-e2gm(k)
C@PG      end do
C@PG      call makegrid(c,rspupe2,rspume2,r2x,r2y,r2z,igx,igy,igz,
C@PG     -  ngx,ngy,ngz)
C@PG      call nopbcgr(igx,ixf,ngx,c(1),#GX)
C@PG      call nopbcgr(igy,iyf,ngy,c(2),#GY)
C@PG      call nopbcgr(igz,izf,ngz,c(3),#GZ)
C@PG      return
C@PG      end
      subroutine makegrid2(r,ro,rspp,rspm,r2x,r2y,r2z,r2xo,r2yo,r2zo,
     -  igx,igy,igz,ngx,ngy,ngz,igx0,igy0,igz0,igxo0,igyo0,igzo0,
     -  imin2,imax2,jmin2,jmax2,kmin2,kmax2,no2)
c#    MMC routine 299 lstmod: 09/28/98
c*****Determine the  gridpoints to be checked around r
c     for which possible change in cover can occur
      dimension r(3),ro(3),rspp(3),rspm(3),
     -  r2x(#GX),r2y(#GY),r2z(#GZ),r2xo(#GX),r2yo(#GY),r2zo(#GZ),
     -  igx(#GX),igy(#GY),igz(#GZ),igx0(#GX),igy0(#GY),igz0(#GZ),
     -  igxo0(#GX),igyo0(#GY),igzo0(#GZ)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      call covlim(r,imin,imax,jmin,jmax,kmin,kmax,rspp,rspm)
c     Difference grid - intersection
      call covlim(ro,imino,imaxo,jmino,jmaxo,kmino,kmaxo,rspp,rspm)
      no2=1
      imin2=max0(imin,imino)
      imax2=min0(imax,imaxo)
      if (imax2 .ge. imin2) then
        jmin2=max0(jmin,jmino)
        jmax2=min0(jmax,jmaxo)
        if (jmax2 .ge. jmin2) then
          kmin2=max0(kmin,kmino)
          kmax2=min0(kmax,kmaxo)
          if (kmax2 .ge. kmin2) no2=0
        end if
      end if
c     Don't continue if there is no intersection
      if (no2 .eq. 1) return
      call indexit(igx0,1,imax-imin+1,imin-1)
      call indexit(igy0,1,jmax-jmin+1,jmin-1)
      call indexit(igz0,1,kmax-kmin+1,kmin-1)
      call indexit(igxo0,1,imaxo-imino+1,imino-1)
      call indexit(igyo0,1,jmaxo-jmino+1,jmino-1)
      call indexit(igzo0,1,kmaxo-kmino+1,kmino-1)
      dx0=e2gm(1)-r(1)
      dy0=e2gm(2)-r(2)
      dz0=e2gm(3)-r(3)
      dxo0=e2gm(1)-ro(1)
      dyo0=e2gm(2)-ro(2)
      dzo0=e2gm(3)-ro(3)
      call make1dg2(dx0,dxo0,ngx,imin2,imax2,ngrid(1),grid(1),igx,
     -  r2x,r2xo,#GX)
      call make1dg2(dy0,dyo0,ngy,jmin2,jmax2,ngrid(2),grid(2),igy,
     -  r2y,r2yo,#GY)
      call make1dg2(dz0,dzo0,ngz,kmin2,kmax2,ngrid(3),grid(3),igz,
     -  r2z,r2zo,#GZ)
      return
      end
      subroutine make1dg(d0,ng,imin,imax,ngrid,grid,ig,r2,maxg)
c#    MMC routine 300 lstmod: 12/14/98
c*****Take care of one grid dimension
      dimension ig(maxg),r2(maxg)
      ng=0
      do i=imin,imax
        ng=ng+1
        ic=i
        if (ic .lt. 1) then
          ic=ic+ngrid
C@LL          if (ic .lt. 1) ic=ic+ngrid
        end if
        if (ic .gt. ngrid) then
        ic=ic-ngrid
C@LL        if (ic .gt. ngrid) ic=ic-ngrid
        end if
        ig(ng)=ic
        gr=d0+float(i)*grid
        r2(ng)=gr*gr
      end do
      return
      end
      subroutine make1dg2(d0,do0,ng,imin,imax,ngrid,grid,ig,
     -  r2,r2o,maxg)
c#    MMC routine 301 lstmod: 12/14/98
c*****Take care of one grid dimension
      dimension ig(maxg),r2(maxg),r2o(maxg)
      ng=0
      do i=imin,imax
        ng=ng+1
        ic=i
        if (ic .lt. 1) then
          ic=ic+ngrid
C@LL          if (ic .lt. 1) ic=ic+ngrid
        end if
        if (ic .gt. ngrid) then
        ic=ic-ngrid
C@LL        if (ic .gt. ngrid) ic=ic-ngrid
        end if
        ig(ng)=ic
        gr=d0+float(i)*grid
        r2(ng)=gr*gr
        gr=do0+float(i)*grid
        r2o(ng)=gr*gr
      end do
      return
      end
      subroutine make1dg0(d0,imax,grid,r2,maxg)
c#    MMC routine 302 lstmod: 10/14/98
c*****Take care of one grid dimension without PBC and without squaring
      dimension r2(maxg)
      do i=1,imax
        r2(i)=d0+float(i)*grid
      end do
      return
      end
      subroutine sltrad(rsphi,ianslt,nslt,rslv,nr,isltr,facw,facr,kexp)
c#    MMC routine 303 lstmod: 03/16/12
c*****Generate solute radii squares
      dimension rsphi(nslt),ianslt(nslt)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      if (isltr .eq. 0) then
        do ia=1,nslt
          rsphi(ia)=((facw*vdw(ianslt(ia))+facr*nr*rslv))**kexp
        end do
      else if (isltr .eq. 1) then
        do ia=1,nslt
          rsphi(ia)=(facw*sigslt(ia)*0.5+facr*nr*rslv)**kexp
        end do
      else
        do ia=1,nslt
          if (ianslt(ia) .eq. 1 .and. sigslt(ia) .gt.  1.0) then
            rsphi(ia)=(facw*0.5+facr*nr*rslv)**kexp
          else
            rsphi(ia)=(facw*sigslt(ia)*0.5+facr*nr*rslv)**kexp
          end if
        end do
      end if
      return
      end
      subroutine unpackijk(indx,ng1,ic,jc,kc)
c#    MMC routine 304 lstmod: 02/29/96
c*****Unpack three integers from (ic-1)*ng1^2+(jc-1)*ng1+kc
      ix1=indx-1
      indx1=ix1/ng1
      kc=indx-indx1*ng1
      ic=indx1/ng1
      jc=indx1-ic*ng1+1
      ic=ic+1
      return
      end
      subroutine volcha(uusfac,nfsslt,nfslww,ksltmn,ncor)
c#    MMC routine 305 lstmod: 06/11/21
c*****Perform an insertion or deletion attempt based on grid search
      real*8 uusfac
      dimension ncor(#MO)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      common /tpn/ edgexyz0(3),edge2xyz0(3),rinscr0(3),vol0,cic0(3,27),
     -  dex0(5),dey0(5),dez0(5),chexdx0(2),chexy0(2),dexhex0(5),vrange,
     -  volfac(3),vlam,vlamt,vvlmt,vvlmtx,vvlmty,vvlmtz,vvlmtxx,vvlmtyy,
     -  vvlmtzz,vvlmtyz,complfac,sqcomplfac,ixyzfreeze(3),iscaletyplast
      real*8 ediffsm,ediffsm2,expediffsm
      common /virtvolcha/ ediffsm,ediffsm2,expediffsm,ediffmn,ediffmx,
     -  volchaperc,volchafac(3),volchadiff(3),delvvol,delvarea
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /ecell/ cic(3,27),ncell
C@D1      common /eijtest/ eij(216,216)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
c     Temporary variables for new configuration
C@IB      real*8 tesiv,frctotv,trqtotv,tss12v,tss6v,tss1v,gbuupdv,
C@IB     -  gbuuptv
C@IB      dimension ncorv(#MO),tesiv(#MO),frctotv(3,#MO),
C@IB     -  trqtotv(3,#MO),frcsltv(3,#MO),trtsltv(3,#MO),
C@IB     -  trvsltv(3,#MO),texsltv(#MO),vrcsltv(3,#MO),
C@IB     -  tsindv(3,#MO),rcomisov(#MO),rijpsov(#MO),
C@IB     -  rphs0isov(#MS),nslvdsv(#MO),nslvdsidv(#MO),
C@IB     -  gbuupdv(#MM),gbuuptv(#TR),
C@IB     -  cv(3,#NA),crmv(3,#MO),ipxov(#MO)
      dimension edgexyzo(3),edge2xyzo(3),dexo(5),deyo(5),dezo(5),
     -  chexdxo(2),chexyo(2),dexhexo(5),cico(3,27)
      real*8 drno,esmslvo,exparg
C@IB      real*8 virialo,vsltsmo,esmslv
      dimension drno(3),volfacnew(3),scalefac(3),dxyzv(3)
C@IB      dimension virialo(3),vsltsmo(3)
      data dx /0.0/,dy /0.0/,dz /0.0/,dyz /0.0/,vlfrcyz /0.0/
      if (idebug(38) .gt. 0) then
        nosft=0
        if (iop(106) .gt. 0) nosft=mod(nvvchmc,nvvchrep)
        if (iop(71) .gt. 0) nosft=mod(nvchmc,nvchrep)
        if (nosft .eq. 0) then
          if (iop(13) .eq. 3) then
            call selftest(2,iop(94),nfail,-nmolec,0,0)
          else if (iop(13) .gt. 0) then
            call selftest(iop(13),iop(94),nfail,1,0,0)
          end if
        end if
      end if
      volold=vol
C@IB      if (iop(57)+iop(58) .gt. 0)
C@IB     -  call eism0(1,0,noverl,nfsslt,nfslww,ksltmn,ncorv,
C@IB     -    tesiv,frctotv,trqtotv,texsltv,vrcsltv,frcsltv,trtsltv,trvsltv,
C@IB     -    tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,
C@IB     -    nslvds,nslvdsid,gbuupd,gbuupt,esmslvo,c,crm,nmc)
      call mmc_random(1,drno)
      if (iop(72) .eq. 0) then
        iscaletyp=1
      else if (iop(72) .eq. 1) then
        iscaletyp=iscaletyplast+1
        ifound=0
        do while (ifound .eq. 0)
          if (iscaletyp .gt. 4) iscaletyp=2
          if (ixyzfreeze(iscaletyp-1) .eq. 0) then
            ifound=1
          else
            iscaletyp=iscaletyp+1
          end if
        end do
        iscaletyplast=iscaletyp
      else
        if (mod(nvchmc,2) .eq. 0) then
          iscaletyp=2
        else
          iscaletyp=5
        end if
      end if
      if (iop(71) .eq. 1) then
c       Uniform volume change
        dv=vrange*(drno(1)-0.5d0)
        volnew=vol+dv
      else if (iop(71) .eq. 2) then
c       Isotropic virial biased volume change
        vlfrc=-(virial(1)+virial(2)+virial(3))/(3.0*vol)-pressv+
     -    (nmolec-1+nsttm)/(beta*vol)
        sh2=2.0*sinh(vvlmt*vlfrc)
        cviso=sh2*vlamt/vlfrc
        exparg=-vvlmt*vlfrc
        dv=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrc
        if (idebug(38) .gt. 0) write (iout,2003) dv,vlfrc,sh2,cviso
        volnew=vol+dv
      else if (iop(71) .eq. 3) then
c       Anisotropic virial biased volume change
        if (iop(72) .eq. 0) then
c         All three directions sampled independently, in every move
          vlfrcx=edgexyz(2)*edgexyz(3)*(-virial(1)/(3.0*vol)-
     -      (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
          sh2=2.0*sinh(vvlmtx*vlfrcx)
          cviso=sh2*vlamt/vlfrcx
          exparg=-vvlmtx*vlfrcx
          dx=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcx
          volfacnew(1)=(edgexyz(1)+dx)/edgexyz0(1)
          call mmc_random(2,drno)
          vlfrcy=edgexyz(1)*edgexyz(3)*(-virial(2)/(3.0*vol)-
     -      (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
          sh2=2.0*sinh(vvlmty*vlfrcy)
          cviso=cviso*sh2*vlamt/vlfrcy
          exparg=-vvlmty*vlfrcy
          dy=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcy
          volfacnew(2)=(edgexyz(2)+dy)/edgexyz0(2)
          vlfrcz=edgexyz(1)*edgexyz(2)*(-virial(3)/(3.0*vol)-
     -      (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
          sh2=2.0*sinh(vvlmtz*vlfrcz)
          cviso=cviso*sh2*vlamt/vlfrcz
          exparg=-vvlmtz*vlfrcz
          dz=dlog(sh2*drno(2)+dexp(exparg))*vlamt/vlfrcz
          volfacnew(3)=(edgexyz(3)+dz)/edgexyz0(3)
        else if (iop(72) .eq. 1) then
c         x, y and z directions are sampled independently (one at time)
          call trnsfr(volfacnew,volfac,3)
          if (iscaletyp .eq. 2) then
            vlfrcx=edgexyz(2)*edgexyz(3)*(-virial(1)/(3.0*vol)-
     -        (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcx .lt. 0.0)
     -        vlfrcx=vlfrcx*complfac
            sh2=2.0*sinh(vvlmtxx*vlfrcx)
            cviso=sh2*vlamt/vlfrcx
            exparg=-vvlmtxx*vlfrcx
            dx=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcx
            volfacnew(1)=(edgexyz(1)+dx)/edgexyz0(1)
          else if (iscaletyp .eq. 3) then
            vlfrcy=edgexyz(1)*edgexyz(3)*(-virial(2)/(3.0*vol)-
     -        (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcy .lt. 0.0)
     -        vlfrcy=vlfrcy*complfac
            sh2=2.0*sinh(vvlmtyy*vlfrcy)
            cviso=sh2*vlamt/vlfrcy
            exparg=-vvlmtyy*vlfrcy
            dy=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcy
            volfacnew(2)=(edgexyz(2)+dy)/edgexyz0(2)
          else
            vlfrcz=edgexyz(1)*edgexyz(2)*(-virial(3)/(3.0*vol)-
     -        (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcz .lt. 0.0)
     -        vlfrcz=vlfrcz*complfac
            sh2=2.0*sinh(vvlmtzz*vlfrcz)
            cviso=sh2*vlamt/vlfrcz
            exparg=-vvlmtzz*vlfrcz
            dz=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcz
            volfacnew(3)=(edgexyz(3)+dz)/edgexyz0(3)
          end if
        else
c         Either x or y-z directions are sampled
          if (iscaletyp .eq. 2) then
            vlfrcx=edgexyz(2)*edgexyz(3)*(-virial(1)/(3.0*vol)-
     -        (pressv-(nmolec-1+nsttm)/(beta*vol))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcx .lt. 0.0)
     -        vlfrcx=vlfrcx*complfac
            sh2=2.0*sinh(vvlmtxx*vlfrcx)
            cviso=sh2*vlamt/vlfrcx
            exparg=-vvlmtxx*vlfrcx
            dx=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcx
            volfacnew(1)=(edgexyz(1)+dx)/edgexyz0(1)
            volfacnew(2)=volfac(2)
            volfacnew(3)=volfac(3)
          else
            vlfrcyz=edgexyz(1)*(-(virial(2)+virial(3))/(3.0*vol)-
     -        (pressv-(nmolec-1+nsttm)/(beta*vol))*2.0/3.0)
            if (iop(78) .gt. 0 .and. vlfrcyz .lt. 0.0)
     -        vlfrcyz=vlfrcyz*sqcomplfac
            sh2=2.0*sinh(vvlmtyz*vlfrcyz)
            cviso=sh2*vlamt/vlfrcyz
            exparg=-vvlmtyz*vlfrcyz
            dyz=dlog(sh2*drno(1)+dexp(exparg))*vlamt/vlfrcyz
            volfacnew(1)=volfac(1)
            volfacnew(2)=sqrt((vol/edgexyz(1)+dyz)/(vol0/edgexyz0(1)))
            volfacnew(3)=volfacnew(2)
          end if
        end if
        volnew=vol0*volfacnew(1)*volfacnew(2)*volfacnew(3)
        dv=volnew-vol
      end if
      if (iop(106) .eq. 0) then
        if (iscaletyp .eq. 1) then
c         Isotropic
          do k=1,3
            volfacnew(k)=(volnew/vol0)**(1.0/3.0)
          end do
        else if (iscaletyp .eq. 2) then
c         Along the x axis only (volfac1*volfac2*volfac3*vol0=volnew)
          volfacnew(1)=volnew/(vol0*volfac(2)*volfac(3))
          volfacnew(2)=volfac(2)
          volfacnew(3)=volfac(3)
        else if (iscaletyp .eq. 3) then
c         Along the y axis only (volfac1*volfac2*volfac3*vol0=volnew)
          volfacnew(1)=volfac(1)
          volfacnew(2)=volnew/(vol0*volfac(1)*volfac(3))
          volfacnew(3)=volfac(3)
        else if (iscaletyp .eq. 4) then
c         Along the z axis only (volfac1*volfac2*volfac3*vol0=volnew)
          volfacnew(1)=volfac(1)
          volfacnew(2)=volfac(2)
          volfacnew(3)=volnew/(vol0*volfac(1)*volfac(2))
        else if (iscaletyp .eq. 5) then
c         Isotropic along the Y and Z axes
          volfacnew(1)=volfac(1)
          volfacnew(2)=sqrt(volnew/(vol0*volfac(1)))
          volfacnew(3)=volfacnew(2)
        end if
        do k=1,3
          scalefac(k)=volfacnew(k)-volfac(k)
        end do
      else
c       Virtual volume change
        call trnsfr(scalefac,volchadiff,3)
        call trnsfr(volfacnew,volchafac,3)
      end if
      if (idebug(38) .gt. 0) then
        write (iout,2001) volfac,volfacnew
c       Recalculate old solvent eng sum for comparison
        esmslvo=0.d0
        do is=2,nmolec
          esmslvo=esmslvo+tesi(is)
        end do
        esmslvo=tesi(1)+(esmslvo-tesi(1))/2.0d0
      end if
c     Translate molecules
C@IB      if (iop(57) .gt. 0) then
C@IBc       Scale solute molecules around their center
C@IB        do im=1,nsttm
C@IB          call scalmol(scalefac,c(1,molcnt(im)),c(1,ifirstm(im)),
C@IB     -      cv(1,ifirstm(im)),ilastm(im)-ifirstm(im)+1)
C@IB        end do
C@IB      else
C@IB        call scalmol(scalefac,crm,c,cv,nstta)
C@IB      end if
C@IBc     Scale solute crm in any event
C@IB      call scalmol(scalefac,crm(1,1),crm,crmv,1)
C@IB      do is=2,nmolec
C@IB        call scalmol(scalefac,crm(1,is),c(1,ic01+is*nslv),
C@IB     -    cv(1,ic01+is*nslv),nslv)
C@IB        call scalmol(scalefac,crm(1,is),crm(1,is),crmv(1,is),1)
C@IB      end do
c     Scale and save PBC parameters
      rinscro=rinscr
      rinscr=amin1(rinscr0(1)*volfacnew(1),rinscr0(2)*volfacnew(2),
     -  rinscr0(3)*volfacnew(3))
      if (iop(7) .eq. 0) then
        if (rinscr*rinscr .lt. ctslts) then
          write (iout,2000) 'solute-solvent'
          call datprt(2)
        end if
      end if
      if (iop(54) .eq. 0) then
        if (rinscr*rinscr .lt. ctslvs) then
          write (iout,2000) 'solvent-solvent'
          call datprt(2)
        end if
      end if
      do ic=1,ncell
        do k=1,3
          cico(k,ic)=cic(k,ic)
          cic(k,ic)=cic0(k,ic)*volfacnew(k)
        end do
      end do
      do k=1,3
        edgexyzo(k)=edgexyz(k)
        edge2xyzo(k)=edge2xyz(k)
        edgexyz(k)=edgexyz0(k)*volfacnew(k)
        edge2xyz(k)=edge2xyz0(k)*volfacnew(k)
      end do
      do k=1,5
        dexo(k)=dex(k)
        deyo(k)=dey(k)
        dezo(k)=dez(k)
        dex(k)=dex0(k)*volfacnew(1)
        dey(k)=dey0(k)*volfacnew(2)
        dez(k)=dez0(k)*volfacnew(3)
      end do
      if (iop(5) .eq. 4) then
        do k=1,5
          dexhexo(k)=dexhex(k)
          dexhex(k)=dexhex0(k)*volfacnew(1)
        end do
        do k=1,2
          chexdxo(k)=chexdx(k)
          chexyo(k)=chexy(k)
          chexdx(k)=chexdx0(k)*volfacnew(2)
          chexy(k)=chexy0(k)*volfacnew(2)
        end do
      end if
C@IB      call trnsfrd(virialo,virial,3)
C@IB      call trnsfrd(vsltsmo,vsltsm,3)
C@IB      call eism0(0,1,noverl,nfsslt,nfslww,ksltmn,ncorv,
C@IB     -  tesiv,frctotv,trqtotv,texsltv,vrcsltv,frcsltv,trtsltv,trvsltv,
C@IB     -  tss12v,tss6v,tss1v,tsindv,rcomisov,rijpsov,rphs0isov,ipxov,
C@IB     -  nslvdsv,nslvdsidv,gbuupdv,gbuuptv,esmslv,cv,crmv,nmc)
C@EF        if (isnan(etotn)) etotn=realmx
      ediff=etotn-etoto
      if (iop(106) .gt. 0) then
c       Virtual change
        ediffsm=ediffsm+ediff
        ediffsm2=ediffsm2+ediff**2
        if (ediff .gt. edifmx) ediff=edifmx
        if (-ediff .gt. edifmx) ediff=-edifmx
        expediffsm=expediffsm+exp(-ediff*beta)
        nvvchmc=nvvchmc+1
        if (ediff .gt. ediffmx) ediffmx=ediff
        if (ediff .lt. ediffmn) ediffmn=ediff
        ivcacc=2
        go to 100
      else
c       Metropolis decision
        ivcacc=0
        if (ediff .gt. edifmx) ivcacc=2
        if (ediff*beta .lt. -rllnmx) ivcacc=1
        if (ivcacc .ne. 0) go to 100
        ivcacc=2
        vmet=exp((etoto-etotn)*beta-pvbeta*(volnew-vol))*
     -    (volnew/vol)**(nmolec-1+nsttm)
      end if
      if (idebug(38) .gt. 0) then
C@IB          write (iout,2005) 'slt-slt',ettnbn,ettnbo,(ettnbn-ettnbo)
C@IB          write (iout,2005) 'slt-slv',esmslv,esmslvo,(esmslv-esmslvo)
        efac=exp((etoto-etotn)*beta)
        pvfac=exp(pvbeta*(volnew-vol))
        vnfac=(volnew/vol)**(nmolec-1+nsttm)
        write (iout,2002) vmet,dv,pvbeta,etoto,etotn,efac,pvfac,vnfac
      end if
      if (iop(71) .eq. 2) then
        vlfrcn=-(virial(1)+virial(2)+virial(3))/(3.*volnew)-pressv+
     -    (nmolec-1+nsttm)/(beta*volnew)
        cvisn=2.0*vlamt/vlfrcn*sinh(vvlmt*vlfrcn)
        vmet=vmet*(cviso/cvisn)*exp(-dv*(vlfrc+vlfrcn)/vlamt)
        if (iop(38) .gt. 0)
     -    write (iout,2004) vlfrcn,vlfrc,cvisn,cviso,vmet
      else if (iop(71) .eq. 3) then
        if (iop(72) .eq. 0) then
          vlfrcxn=edgexyz(2)*edgexyz(3)*(-virial(1)/(3.0*volnew)-
     -      (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
          cvisn=2.0*vlamt/vlfrcxn*sinh(vvlmtx*vlfrcxn)
          vlfrcyn=edgexyz(1)*edgexyz(3)*(-virial(2)/(3.0*volnew)-
     -      (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
          cvisn=cvisn*2.0*vlamt/vlfrcyn*sinh(vvlmty*vlfrcyn)
          vlfrczn=edgexyz(1)*edgexyz(2)*(-virial(3)/(3.0*volnew)-
     -      (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
          cvisn=cvisn*2.0*vlamt/vlfrczn*sinh(vvlmtz*vlfrczn)
          vmet=vmet*(cviso/cvisn)*exp(-(dx*(vlfrcx+vlfrcxn)+
     -      dy*(vlfrcy+vlfrcyn)+dz*(vlfrcz+vlfrczn))/vlamt)
          if (iop(38) .gt. 0) write (iout,2006) vlfrcxn,vlfrcyn,vlfrczn,
     -      vlfrcx,vlfrcy,vlfrcz,cvisn,cviso,vmet
        else if (iop(72) .eq. 1) then
c         x, y and z directions are sampled independently
          if (iscaletyp .eq. 2) then
            vlfrcxn=edgexyz(2)*edgexyz(3)*(-virial(1)/(3.0*volnew)-
     -        (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcxn .lt. 0.0)
     -        vlfrcxn=vlfrcxn*complfac
            cvisn=2.0*vlamt/vlfrcxn*sinh(vvlmtxx*vlfrcxn)
            vmet=vmet*(cviso/cvisn)*exp(-dx*(vlfrcx+vlfrcxn)/vlamt)
          else if (iscaletyp .eq. 3) then
            vlfrcyn=edgexyz(1)*edgexyz(3)*(-virial(2)/(3.0*volnew)-
     -        (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcyn .lt. 0.0)
     -        vlfrcyn=vlfrcyn*complfac
            cvisn=2.0*vlamt/vlfrcyn*sinh(vvlmtyy*vlfrcyn)
            vmet=vmet*(cviso/cvisn)*exp(-dy*(vlfrcy+vlfrcyn)/vlamt)
          else
            vlfrczn=edgexyz(1)*edgexyz(2)*(-virial(3)/(3.0*volnew)-
     -        (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
            if (iop(78) .gt. 0 .and. vlfrczn .lt. 0.0)
     -        vlfrczn=vlfrczn*complfac
            cvisn=2.0*vlamt/vlfrczn*sinh(vvlmtzz*vlfrczn)
            vmet=vmet*(cviso/cvisn)*exp(-dz*(vlfrcz+vlfrczn)/vlamt)
          end if
        else
          if (iscaletyp .eq. 2) then
            vlfrcxn=edgexyz(2)*edgexyz(3)*(-virial(1)/(3.0*volnew)-
     -        (pressv-(nmolec-1+nsttm)/(beta*volnew))/3.0)
            if (iop(78) .gt. 0 .and. vlfrcxn .lt. 0.0)
     -        vlfrcxn=vlfrcxn*complfac
            cvisn=2.0*vlamt/vlfrcxn*sinh(vvlmtxx*vlfrcxn)
            vmet=vmet*(cviso/cvisn)*exp(-dx*(vlfrcx+vlfrcxn)/vlamt)
          else
            vlfrcyzn=edgexyz(1)*(-(virial(2)+virial(3))/(3.0*volnew)-
     -        (pressv-(nmolec-1+nsttm)/(beta*volnew))*2.0/3.0)
            if (iop(78) .gt. 0 .and. vlfrcyzn .lt. 0.0)
     -        vlfrcyzn=vlfrcyzn*sqcomplfac
            sh2=2.0*sinh(vvlmtyz*vlfrcyzn)
            cvisn=cviso*sh2*vlamt/vlfrcyzn
            vmet=vmet*(cviso/cvisn)*exp(-dyz*(vlfrcyz+vlfrcyzn)/vlamt)
          end if
        end if
      end if
      if (vmet .ge. 1.0) then
        ivcacc=1
      else
        call mmc_random(1,drno)
        if (vmet .gt. drno(1)) ivcacc=1
      end if
100   if (ivcacc .eq. 2) then
c       Rejected - restore PBC parameters
C@IB        call trnsfrd(virial,virialo,3)
C@IB        call trnsfrd(vsltsm,vsltsmo,3)
        rinscr=rinscro
        do ic=1,ncell
          do k=1,3
            cic(k,ic)=cico(k,ic)
          end do
        end do
        do k=1,3
          edgexyz(k)=edgexyzo(k)
          edge2xyz(k)=edge2xyzo(k)
        end do
        do k=1,5
          dex(k)=dexo(k)
          dey(k)=deyo(k)
          dez(k)=dezo(k)
        end do
        if (iop(5) .eq. 4) then
          do k=1,5
            dexhex(k)=dexhexo(k)
          end do
          chexdx(1)=chexdxo(1)
          chexdx(2)=chexdxo(2)
          chexy(1)=chexyo(1)
          chexy(2)=chexyo(2)
        end if
      else
c       Accepted
        nvchacc=nvchacc+1
        call trnsfr(volfac,volfacnew,3)
        vol=volnew
        if (vol .gt. vmax) vmax=vol
        if (vol .lt. vmin) vmin=vol
        vstep=vstep+abs(dv)
        do k=1,3
          dxyzv(k)=abs(edgexyz(k)-edgexyzo(k))
          if (dxyzv(k) .ne. 0.0) then
            vxstep(k)=vxstep(k)+dxyzv(k)
            nxstep(k)=nxstep(k)+1
          end if
        end do
c       Save current configuration into its real place
        estsco=estscn
        etoto=etotn
        ettnbo=ettnbn
C@IB        call trnsfr(c,cv,natoms*3)
C@IB        call trnsfr(cslto,cv,nstta3)
C@IB        call trnsfr(crm,crmv,nmol3)
C@IB        call trnsfrd(tesi,tesiv,nmolec)
C@IB        call trnsfr(texslt,texsltv,nmolec)
C@IBC@FR        call trnsfrd(frctot,frctotv,nmol3)
C@IBC@FR        call trnsfrd(trqtot,trqtotv,nmol3)
C@IBC@FR        call trnsfr(frcslt,frcsltv,nmol3)
C@IBC@FRC@TS        call trnsfr(trtslt,trtsltv,nmol3)
C@IBC@FR        call trnsfr(trvslt,trvsltv,nmol3)
C@IBC@FR        call trnsfr(vrcslt,vrcsltv,nmol3)
C@IB        call trnsfr(tsind,tsindv,nmol3)
C@IB        call trnsfr(rcomiso,rcomisov,nmolec)
C@IB        call trnsfr(rijpso,rijpsov,nmolec)
C@IB        call trnsfi(ipxo,ipxov,nmolec)
C@IB        call trnsfi(nslvds,nslvdsv,nmolec)
C@IB        call trnsfi(ncor,ncorv,nmolec)
C@IB        tss12=tss12v
C@IB        tss6=tss6v
C@IB        tss1=tss1v
C@IB        if (iop(41) .gt. 0) call trnsfi(nslvdsid,nslvdsidv,nmolec)
C@IB        if (iop(57) .gt. 0) call trnsfrd(gbuupd,gbuupdv,nsttm)
C@IB        if (iop(58) .gt. 0) call trnsfrd(gbuupt,gbuuptv,ntorgrp)
      end if
      if (iop(71) .gt. 0) then
c       (TPN) ensemble accumulators
        vsum=vsum+vol*uusfac
        vvsum=vvsum+vol*vol*uusfac
        enthalpy=etoto+pressv*vol
        hsum=hsum+enthalpy*uusfac
        hhsum=hhsum+enthalpy*enthalpy*uusfac
        exsum=exsum+edgexyz(1)*uusfac
        eysum=eysum+edgexyz(2)*uusfac
        ezsum=ezsum+edgexyz(3)*uusfac
        exsum_2=exsum_2+edgexyz(1)*edgexyz(1)*uusfac
        eysum_2=eysum_2+edgexyz(2)*edgexyz(2)*uusfac
        ezsum_2=ezsum_2+edgexyz(3)*edgexyz(3)*uusfac
        volav=vsum/ucsmvv
        call accumulate(uusfac,' ')
        nvchmc=nvchmc+1
        if (mod(nvchmc,nvchrep) .eq. 0)
     -    write (iout,1000) nvchmc,etoto,
     -      volnew,volold,volav,edgexyz(1),edgexyz(2),edgexyz(3),
     -      vmin,vmax,(float(nvchacc)/float(nvchmc))
      else
        nvvchmc=nvvchmc+1
        if (mod(nvvchmc,nvvchrep) .eq. 0)
     -    write (iout,1001) nvvchmc,etoto,ediff,ediffmn,ediffmx
      end if
      return
1000  format(' Nmcv=',i8,' E=',e12.5,' voln,o=',2f8.0,' <v>=',f12.2,/,
     -  ' ex=',f8.5,' ey=',f8.5,' ez=',f8.5,' volmn,mx=',2f8.0,
     -  ' VCHacc=',f5.2)
1001  format(' Nmcvv=',i5,' E=',e12.5,' Ediff=',e12.5,
     -  ' Ediff(min,max)=',2e12.5)
2000  format(' ***** ERROR: inscribed sphere radius became smaller ',
     -  'than the ',a,' cutoff during a volume change')
2001  format(' VOLCHA volfac=',3f9.6,' volfacnew=',3f9.6)
2002  format(' VOLCHA vmet,dv,pvbeta=',3e12.5,' etoto,n=',2e12.5,/,
     -  ' e,p,vfac=',3e12.5)
2003  format(' VOLCHA dv,vlfrc,sh2,cviso=',4e13.6)
2004  format(' VOLCHA volfrcn,o=',2e13.6,' cisn,o=',2e13.6,
     -  ' vmet=',e13.6)
C@IB2005  format(' VOLCHA ',a,' energy (new,old,diff)=',3e14.7)
2006  format(' VOLCHA volfrcnxyz=',3e13.6,' volfrcxyz=',3e13.6,
     -  ' cisn,o=',2e13.6,' vmet=',e13.6)
      end
      subroutine scalmol(scalefac,c0,c,cv,nat)
c#    MMC routine 306 lstmod: 12/05/97
c*****Perform the translation of a molecule for a volume change
      dimension scalefac(3),c0(3),c(3,nat),cv(3,nat)
      real*8 scfd,ccd,cvd
      dimension scfd(3),ccd(3),cvd(3)
      do k=1,3
        scfd(k)=scalefac(k)
        ccd(k)=scfd(k)*c0(k)
      end do
      do i=1,nat
        do k=1,3
          cvd(k)=c(k,i)+ccd(k)
          cv(k,i)=cvd(k)
        end do
      end do
      return
      end
      subroutine indlgr(uusfac,indel,isid,iaccid,istop)
c#    MMC routine 307 lstmod: 03/23/12
c*****Perform an insertion or deletion attempt based on grid search
      real*8 uusfac
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /ecell/ cic(3,27),ncell
C@D1      common /eijtest/ eij(216,216)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      common /cavprb/ ndistr(#MO),ninstr(#MO),nocavf(#MO),
     -  ndela,nran,ndlast,nmdlst,niddst,namin,namax
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 drcorr,tstepsum,tlstepsum,sltstepsum
      common /caccpt/ drcorr(50),tstepsum(#TR),tlstepsum(#LT),
     -  sltstepsum(#MM),tstepmax(#TR),tlstepmax(#LT),
     -  nrcorr(50),npckd(#MO),nmvd(#MO),nrtry(50),nracc(50),
     -  nmovacc,nmovtry,npmfacc,npmftry,npdsltacc,npdslttry,
     -  nptsltacc,nptslttry,nswapacc,nswaptry,nmv2stry,nmv2sacc,
     -  nspslttry,nspsltacc,nptatry(3,50),nptaacc(3,50),
     -  npdstacc(#MM),npdsttry(#MM),nswacc(#MM),nswtry(#MM),
     -  n2sacc(#MM),n2stry(#MM),nspstacc(#MM),nspsttry(#MM),
     -  nptstacc(#TR),nptsttry(#TR),nptloopacc(#LT),
     -  nptlooptry(#LT),idproxacc(4,#ST)
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      real*8 df1,df6,df12,de1,de6,de12,ds1,ds6,ds12
      common /psltdv/ df1(#DT,#SV),df6(#DT,#SV),df12(#DT,#SV),
     -  de1(#DT,#SV),de6(#DT,#SV),de12(#DT,#SV),ds1(#DT,#SV),
     -  ds6(#DT,#SV),ds12(#DT,#SV),nsltdv,iopbst(#DM),iopbso(#DM)
      real*8 e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      common /frind4/ e0o12,e0o6,e0o1,e1o12,e1o6,e1o1
      real*8 ue0ind,ue1ind,ue0ttnb,ue1ttnb,ue0innb,ue1innb,
     -  ue0t14,ue1t14,ue0tor,ue1tor
      common /frind5/ ue0ind(3),ue1ind(3),ue0ttnb(3),ue1ttnb(3),
     -  ue0innb(3),ue1innb(3),ue0t14(3),ue1t14(3),ue0tor(3),ue1tor(3)
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /frind3/ eone(3,#MO),etwo(3,#MO),etwon(3,#MO),
     -  eonen(3,#MO)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /cage/ delc(3,#MO),deln(3)
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /nn23/ n23
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      include "mpif.h"
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      dimension drno(6),drnxyz(3),rgd(3)
C@DM      real*8 tesiim_send,tesiim_recv
C@DMC@FR      real*8 ft_send(6),ft_recv(6)
C@DMC@FRc      dimension v_recv(3)
      real*8 ed1,ed2,est1,drno,drnxyz,tss1n
      real*8 uewold,uewnew
      data uewold /0.d0/,uewnew /0.d0/
      ed2=0.d0
      uuscor=1.0
      iaccid=0
      istop=0
      if (iop(88) .eq. 0) then
        if (mod(nmc/idfreq,2) .eq. 0) go to 40
      else
        call mmc_random(1,drno)
        if (drno(1) .lt. 0.5d0)  go to 40
      end if
      if (iop(79) .eq. 0) then
        if (nmolec .eq. (idsvfst-1)) return
      else
        if (nmolinoutgr(1) .eq. 0) return
      end if
c-----Try to *delete*
      indel=-1
      if (iop(63) .gt. 0) then
        call pfsel(isid,wpsidsum,wpsid,wpfpsid,limpsid,
     -    idsvfst,nmolec,npfsid)
        call mmc_random(1,drno)
      else
        call mmc_random(2,drno)
        if (iop(79) .eq. 0) then
          isid=drno(2)*(nmolec-idsvfst+1)+idsvfst
        else
          isid0=drno(2)*(nmolinoutgr(1)+1)
c         Find the isid-th solvent that is within the grid
          nw=0
          iw=idsvfst
          do while (iw .lt. nmolec .and. nw .lt. isid0)
            iw=iw+1
            if (molinoutgr(iw) .eq. 1) nw=nw+1
          end do
          isid=iw
        end if
      end if
C@DM      call MPI_Bcast(tesi(isid),1,MPI_DOUBLE_PRECISION,icpuslv(isid)-1,
C@DM     -  MPI_COMM_WORLD,ierr)
C@EF      if (isnan(tesi(isid))) tesi(isid)=realmx
      etotn=etoto-tesi(isid)
      den=tesi(isid)*beta-ba
      if (iop(53) .ge. 1) then
        uewold=tss1-uscpma*dfloat(nmolec-1)
        uewold=usmixp*dble(beta)*uewold
        uewnew=uewold-usmixp*dble(beta)*(tsindn(3,isid)-uscpma)
        den=den+uewnew-uewold
      end if
      if (iop(41) .eq. 1 .or. iop(41) .eq. 2) then
        call remcov(iout,crm(1,isid),rsphs,rspvpe2,rspvme2,1)
        if  (ngfree .eq. ngfreeo) then
c         No cavity was left - reject deletion
          den= -rllnmx
        else
          if (ngfree .gt. #CV) then
            if (MYRANK .eq. 0) write (iout,1002) 'CV'
            call datprt(1)
          end if
        end if
        pcav=float(ngfree)/fltng3
        if (pcav .eq. 0.0) pcav=1.0
      else
        pcav=1.0
      end if
      diffpcln=den-alog(pcav)
      if (iop(79) .eq. 0) then
        diffpcln=diffpcln+alog(float(nmolec-idsvfst+1))
      else
        diffpcln=diffpcln+alog(float(nmolinoutgr(1)))
      end if
c     diffpcln >= 0 results in sure acceptance
      if (diffpcln .lt. 0.0) then
        if (diffpcln .le. -rllnmx) then
          diffpc=0.0
        else
          diffpc=exp(diffpcln)
        end if
        if (diffpc .le. drno(1)) then
c         Deletion rejected, put back the cover removed
          if (iop(41) .eq. 1 .or. iop(41) .eq. 2)
     -      call addcov(crm(1,isid),rsphs,rspvpe2,rspvme2,1)
          isid=-isid
          uuscor=1.0
          if (iop(53) .ge. 2) uuscor=exp(-uewold)
          go to 54
        end if
      end if
c     Accept deletion
      iaccid=1
      ndaccp=ndaccp+1
c     Save Annealing history if box emptied
C@DM      if (MYRANK .eq. 0) then
      if (iop(129) .gt. 0) then
        if (iop(15) .gt. 0) then
          if (nmolec  .eq. 2) then
            if (iop(9) .eq. 0) then
              write (ihist,1006) ba
              call savcnfh(ihist,iout,0,1,8,1,c,crmgs,
     -          filenames(3),namlens(3),numrecprev(3),numrec(3),
     -          numframe,uusfac,#NA,#UV)
            end if
          end if
        end if
      end if
C@DM      end if
      if (iop(42) .gt. 0) then
C@DM        if (iop(42) .eq. 2) then
C@DMc         Get the proximity info for isid
C@DM          icpu=icpuslv(isid)
C@DM          if (MYRANK .eq. icpu-1) then
C@DM            call MPI_send(ipxo(isid),1,MPI_INTEGER,0,777,
C@DM     -       MPI_COMM_WORLD,ierr)
C@DM            call MPI_send(rijpso(isid),1,MPI_REAL,0,888,
C@DM     -       MPI_COMM_WORLD,ierr)
C@DM          end if
C@DM          if (MYRANK .eq. 0) then
C@DM            call MPI_recv(ipxo(isid),1,MPI_INTEGER,icpu-1,777,
C@DM     -        MPI_COMM_WORLD,MPI_stat,ierr)
C@DM            call MPI_recv(rijpso(isid),1,MPI_REAL,icpu-1,888,
C@DM     -        MPI_COMM_WORLD,MPI_stat,ierr)
C@DM          end if
C@DM        end if
C@DM        if (MYRANK .eq. 0) then
        if (iop(42) .eq. 1) write (iindel,4600) indel,isid-1,nmolec-1,
     -    nmc,cplpar,((crm(k,isid)),k=1,3)
        if (iop(42) .eq. 2) write (iindel,4600) indel,isid-1,nmolec-1,
     -    nmc,cplpar,((crm(k,isid)),k=1,3),ipxo(isid),sqrt(rijpso(isid))
C@DM        end if
        numrec(5)=numrec(5)+1
      end if
      if (pcav .ne. 1.0) ndela=1
c     nmdlst: the MC stepnumber for the last deletion
      nmdlst=nmc
      etoto=etotn
      nmolecdo=nmolec
      call engcha(ed1,ed2,est1,isid,tesi,c,crm,nmolecdo)
c     Update the total binding energy, force and torque arrays for deletion
C@FR        do k=1,3
C@FR          virial(k)=virial(k)-virscn(k)
C@FR          vsltsm(k)=vsltsm(k)-vrcslt(k,isid)
C@FR        end do
C@DM      if (iop(21) .ne. 3) then
C@FR        do k=1,3
C@FR          do i=1,nmolec
C@FR            frctot(k,i)=frctot(k,i)-frcn(k,i)
C@FR            trqtot(k,i)=trqtot(k,i)-trqn(k,i)
C@FR          end do
C@FR        end do
        do i=1,nmolec
          tesi(i)=tesi(i)-texn(i)
        end do
C@DM      else
C@DMc         Each processor should update its own segment
C@DM          do i=iflslv(1,myrank1),iflslv(2,myrank1)
C@DM            tesi(i)=tesi(i)-texn(i)
C@DMC@FR            do k=1,3
C@DMC@FR              frctot(k,i)=frctot(k,i)-frcn(k,i)
C@DMC@FR              trqtot(k,i)=trqtot(k,i)-trqn(k,i)
C@DMC@FR            end do
C@DM          end do
C@DMc         Each processor should update the solute contribution
C@DM          tesi(1)=tesi(1)-texn(1)
C@DMC@FR          do k=1,3
C@DMC@FR            frctot(k,1)=frctot(k,1)-frcn(k,1)
C@DMC@FRC@TS            trqtot(k,1)=trqtot(k,1)-trqn(k,1)
C@DMC@FR          end do
C@DM        end if
      if (rcomiso(isid) .lt. rinscs) estsco=estsco-texn(1)
c     Update the coordination number array
      if (nis(1) .lt. nfsslt) ncor(1)=ncor(1)-1
      do i=2,nmolec
        if (nis(i) .lt. nfslww) ncor(i)=ncor(i)-1
      end do
      if (iop(80) .gt. 0) then
        call solvinout(molinout(isid),crm(1,isid),edgelinxyz,edgerinxyz)
        nmolinout(molinout(isid))=nmolinout(molinout(isid))-1
      end if
      if (iop(79) .gt. 0) nmolinoutgr(1)=nmolinoutgr(1)-1
c     Update pref sampling sums and partial sums
      if (iop(12) .gt. 3) then
        wpsmvsum=wpsmvsum-wpsmv(isid)
        if (iop(21) .ne. 2) then
          do j=ipsmv(isid),npfsmv
            wpfpsmv(j)=wpfpsmv(j)-wpsmv(isid)
            if (limpsmv(j) .lt. nmolec) then
              jfirst=limpsmv(j)+1
              wpfpsmv(j)=wpfpsmv(j)+wpsmv(jfirst)
            end if
          end do
          do j=isid+1,nmolec
            wpsmv(j-1)=wpsmv(j)
          end do
        else
          do j=ipsmv(isid),npfsmv
            wpfpsmv(j)=wpfpsmv(j)-wpsmv(isid)
          end do
          do j=ipsmv(isid),ipsmv(nmolec)-1
            wpfpsmv(j)=wpfpsmv(j)+wpsmv(nmolec)
          end do
          wpsmv(isid)=wpsmv(nmolec)
        end if
        do j=ipsmv(nmolec),npfsmv
          limpsmv(j)=limpsmv(j)-1
        end do
      end if
      if (iop(63) .gt. 0) then
        wpsidsum=wpsidsum-wpsid(isid)
        if (iop(21) .ne. 2) then
          do j=ipsid(isid),npfsid
            wpfpsid(j)=wpfpsid(j)-wpsid(isid)
            if (limpsid(j) .lt. nmolec) then
              jfirst=limpsid(j)+1
              wpfpsid(j)=wpfpsid(j)+wpsid(jfirst)
            end if
          end do
          do j=isid+1,nmolec
            wpsid(j-1)=wpsid(j)
          end do
        else
          do j=ipsid(isid),npfsid
            wpfpsid(j)=wpfpsid(j)-wpsid(isid)
          end do
          do j=ipsid(isid),ipsid(nmolec)-1
            wpfpsid(j)=wpfpsid(j)+wpsid(nmolec)
          end do
          wpsid(isid)=wpsid(nmolec)
        end if
        do j=ipsid(nmolec),npfsid
          limpsid(j)=limpsid(j)-1
        end do
c       Obtain weights for new grid points and update grid weight sums
        do ig=ngfreeo+1,ngfree
          indx=igfree(ig)
          call unpackijk(indx,ng1,ix,iy,iz)
          rgd(1)=e2gm(1)+ix*grid(1)
          rgd(2)=e2gm(2)+iy*grid(2)
          rgd(3)=e2gm(3)+iz*grid(3)
c         Obtain integer distance of this grid from PS center
          idgrid=intgpsdis(iop(8),rgd,wpfidcen,rri,c,crm)
          wpsgdnew=prfwgt(idgrid,wpsidn,0)
          wpsgd(ig)=wpsgdnew
          wpsgdsum=wpsgdsum+wpsgdnew
          if (ipsgd(ig) .eq. 0) ipsgd(ig)=npfsgd
          do is=ipsgd(ig),npfsgd
            wpfpsgd(is)=wpfpsgd(is)+wpsgdnew
            limpsgd(is)=limpsgd(is)+1
          end do
        end do
      end if
      tss12=tss12-tsindn(1,isid)
      tss6=tss6-tsindn(2,isid)
      tss1=tss1-tsindn(3,isid)
      e0o=e0o-e01stn(1,isid)
      e1o=e1o-e01stn(2,isid)
      e0o12=e0o12-eonen(1,isid)
      e0o6=e0o6-eonen(2,isid)
      e0o1=e0o1-eonen(3,isid)
      e1o12=e1o12-etwon(1,isid)
      e1o6=e1o6-etwon(2,isid)
      e1o1=e1o1-etwon(3,isid)
      if (isid .lt. nmolec) then
        if (iop(21) .eq. 3) then
C@DMc         tesi values are correct only for the indices belonging to the
C@DMc          current CPU
C@DM          icpu_isid=icpuslv(isid)
C@DM          icpusend_min=icpu_isid+1
C@DM          icpurecv_min=icpu_isid
C@DM          if (myrank1 .ge. icpusend_min) then
C@DM            im=iflslv(1,myrank1)
C@DM            tesiim_send=tesi(im)
C@DM            call MPI_send(tesiim_send,1,MPI_DOUBLE_PRECISION,MYRANK-1,
C@DM     -        myrank1*isid,MPI_COMM_WORLD,ierr)
C@DMC@FR            call trnsfrd(ft_send,frctot(1,im),3)
C@DMC@FR            call trnsfrd(ft_send(4),trqtot(1,im),3)
C@DMC@FR            call MPI_send(ft_send,6,MPI_DOUBLE_PRECISION,MYRANK-1,
C@DMC@FR     -          2*myrank1*isid,MPI_COMM_WORLD,ierr)
C@DMC@FR            call MPI_send(vrcslt(1,im),3,MPI_REAL,MYRANK-1,
C@DMC@FR     -          3*myrank1*isid,MPI_COMM_WORLD,ierr)
C@DM          end if
C@DMc         Shift down the arrays
C@DM          lastcpuuse=icpuslv(nmolec)
C@DM          ism1=isid+1
C@DM          isa1=ic01+(isid+1)*nslv
C@DM          ism2=iflslv(2,lastcpuuse)
C@DM          isa2=nstta+nslv*(ism2-1)
C@DM          do k=1,3
C@DM            do im=ism1,ism2
C@DM              im1=im-1
C@DM              crm(k,im1)=crm(k,im)
C@DM              crm0(k,im1)=crm0(k,im)
C@DMC@FR              vrcslt(k,im1)=vrcslt(k,im)
C@DMC@FR              frcslt(k,im1)=frcslt(k,im)
C@DMC@FRC@TS              trvslt(k,im1)=trvslt(k,im)
C@DMC@FR              trtslt(k,im1)=trtslt(k,im)
C@DMC@FR              frctot(k,im1)=frctot(k,im)
C@DMC@FR              trqtot(k,im1)=trqtot(k,im)
C@DM              delc(k,im1)=delc(k,im)
C@DM            end do
C@DM            do ia=isa1,isa2
C@DM              c(k,ia-nslv)=c(k,ia)
C@DM            end do
C@DM          end do
C@DM          do k=1,3
C@DM            do l=1,3
C@DM              do im=ism1,ism2
C@DM                orient(k,l,im-1)=orient(k,l,im)
C@DM              end do
C@DM            end do
C@DM          end do
C@DM          do im=ism1,ism2
C@DM            im1=im-1
C@DM            tesi(im1)=tesi(im)
C@DM            texslt(im1)=texslt(im)
C@DM            rcomiso(im1)=rcomiso(im)
C@DM            do mx=1,3
C@DM              tsind(mx,im1)=tsind(mx,im)
C@DM              tsindn(mx,im1)=tsindn(mx,im)
C@DM            end do
C@DM            nslvds(im1)=nslvds(im)
C@DM            nslvdsid(im1)=nslvdsid(im)
C@DM            rijpso(im1)=rijpso(im)
C@DM            ipxo(im1)=ipxo(im)
C@DM            lstmvd(im1)=lstmvd(im)
C@DM            nrejis(im1)=nrejis(im)
C@DM            npckd(im1)=npckd(im)
C@DM            nmvd(im1)=nmvd(im)
C@DM            ncor(im1)=ncor(im)
C@DM            if (iop(82) .gt. 0) iopbst(im1)=iopbst(im)
C@DM          end do
C@DM          if (myrank1 .ge. icpurecv_min .and.
C@DM     -        myrank1 .lt. NUMNOD) then
C@DM            call MPI_recv(tesiim_recv,1,MPI_DOUBLE_PRECISION,MYRANK+1,
C@DM     -          (myrank1+1)*isid,MPI_COMM_WORLD,MPI_stat,ierr)
C@DMC@FR            call MPI_recv(ft_recv,6,MPI_DOUBLE_PRECISION,MYRANK+1,
C@DMC@FR     -          2*(myrank1+1)*isid,MPI_COMM_WORLD,MPI_stat,ierr)
C@DMC@FRc            call MPI_recv(v_recv,3,MPI_REAL,MYRANK+1,
C@DMC@FRc     -          3*(myrank1+1)*isid,MPI_COMM_WORLD,MPI_stat,ierr)
C@DM            im=iflslv(2,myrank1)
C@DM            tesi(im)=tesiim_recv
C@DMC@FR            call trnsfrd(frctot(1,im),ft_recv,3)
C@DMC@FR            call trnsfrd(trqtot(1,im),ft_recv(4),3)
C@DMC@FRc            call trnsfr(vrcslt(1,im),v_recv,3)
C@DM          end if
          if (iop(80) .gt. 0) then
            do im=isid,nmolec-1
              molinout(im)=molinout(im+1)
            end do
          end if
          if (iop(79) .gt. 0) then
            do im=isid,nmolec-1
              molinoutgr(im)=molinoutgr(im+1)
            end do
          end if
        else if (iop(21) .eq. 2) then
c         Move the nmolec-th molecule to the place of the isid-th
          call trnsfr(crm(1,isid),crm(1,nmolec),3)
          call trnsfr(crm0(1,isid),crm0(1,nmolec),3)
C@NN          call trnsfr(clstup(1,isid),clstup(1,nmolec),3)
          call trnsfr(delc(1,isid),delc(1,nmolec),3)
          call trnsfr(orient(1,1,isid),orient(1,1,nmolec),9)
          call trnsfr(c(1,ic01+isid*nslv),c(1,ic01+nmolec*nslv),nslv3)
          tesi(isid)=tesi(nmolec)
          texslt(isid)=texslt(nmolec)
          rcomiso(isid)=rcomiso(nmolec)
          do mx=1,3
            tsind(mx,isid)=tsind(mx,nmolec)
            tsindn(mx,isid)=tsindn(mx,nmolec)
          end do
          if (iop(30) .eq. 5 .or. iop(30) .eq. 6 .or.
     -        iop(30) .eq. 8) then
            e01st(1,isid)=e01st(1,nmolec)
            e01st(2,isid)=e01st(2,nmolec)
            eone(1,isid)=eone(1,nmolec)
            eone(2,isid)=eone(2,nmolec)
            eone(3,isid)=eone(3,nmolec)
            etwo(1,isid)=etwo(1,nmolec)
            etwo(2,isid)=etwo(2,nmolec)
            etwo(3,isid)=etwo(3,nmolec)
          end if
          nslvds(isid)=nslvds(nmolec)
          nslvdsid(isid)=nslvdsid(nmolec)
          rijpso(isid)=rijpso(nmolec)
          ipxo(isid)=ipxo(nmolec)
          lstmvd(isid)=lstmvd(nmolec)
          nrejis(isid)=nrejis(nmolec)
          npckd(isid)=npckd(nmolec)
          nmvd(isid)=nmvd(nmolec)
          ncor(isid)=ncor(nmolec)
          if (iop(82) .gt. 0) iopbst(isid)=iopbst(nmolec)
C@FR          do k=1,3
C@FR            vrcslt(k,isid)=vrcslt(k,nmolec)
C@FR            frcslt(k,isid)=frcslt(k,nmolec)
C@FRC@TS            trvslt(k,isid)=trvslt(k,nmolec)
C@FR            trtslt(k,isid)=trtslt(k,nmolec)
C@FR            frctot(k,isid)=frctot(k,nmolec)
C@FR            trqtot(k,isid)=trqtot(k,nmolec)
C@FR          end do
C@NN          call readbitc(mapbitv,nmolec,ibit1,1,nmolec,#VW,#MO,nbits)
C@NN          ibit1(isid)=0
C@NN          do iw=1,nmolmp
C@NN            mapbitv(iw,isid)=mapbitv(iw,nmolec)
C@NN          end do
C@NN          isw=(isid-1)/nbits+1
C@NN          isb=isid-(isw-1)*nbits
C@NN          do im=2,nmolec
C@NN            if (ibit1(im) .eq. 1) then
C@NNC@NL              mapbitv(isw,im)=mapbitv(isw,im) .or. ibiton(isb)
C@NNC@NA              mapbitv(isw,im)=ibset(mapbitv(isw,im),isb-1)
C@NN            else
C@NNC@NL              mapbitv(isw,im)=mapbitv(isw,im) .and. ibitof(isb)
C@NNC@NA              mapbitv(isw,im)=ibclr(mapbitv(isw,im),isb-1)
C@NN            end if
C@NN          end do
          if (iop(80) .gt. 0) molinout(isid)=molinout(nmolec)
          if (iop(79) .gt. 0) molinoutgr(isid)=molinoutgr(nmolec)
        else
c         iop(21) .lt. 2
c         Shift down molecular arrays to close gap (to maintain relative
c         ordering of indices)
          ism1=isid+1
          isa1=ic01+(isid+1)*nslv
C@D1          do im=ism1,nmolec
C@D1            im1=im-1
C@D1            do j=1,nmolec
C@D1              eij(im1,j)=eij(im,j)
C@D1            end do
C@D1          end do
C@D1          do im=ism1,nmolec
C@D1            im1=im-1
C@D1            do j=1,nmolec
C@D1              eij(j,im1)=eij(j,im)
C@D1            end do
C@D1          end do
          do k=1,3
            do im=ism1,nmolec
              im1=im-1
              crm(k,im1)=crm(k,im)
              crm0(k,im1)=crm0(k,im)
C@NN              clstup(k,im1)=clstup(k,im)
C@FR              vrcslt(k,im1)=vrcslt(k,im)
C@FR              frcslt(k,im1)=frcslt(k,im)
C@FRC@TS              trvslt(k,im1)=trvslt(k,im)
C@FR              trtslt(k,im1)=trtslt(k,im)
C@FR              frctot(k,im1)=frctot(k,im)
C@FR              trqtot(k,im1)=trqtot(k,im)
              delc(k,im1)=delc(k,im)
            end do
            do ia=isa1,natoms
              c(k,ia-nslv)=c(k,ia)
            end do
          end do
          do k=1,3
            do l=1,3
              do im=ism1,nmolec
                orient(k,l,im-1)=orient(k,l,im)
              end do
            end do
          end do
          do im=ism1,nmolec
            im1=im-1
            tesi(im1)=tesi(im)
            texslt(im1)=texslt(im)
            rcomiso(im1)=rcomiso(im)
            do mx=1,3
              tsind(mx,im1)=tsind(mx,im)
              tsindn(mx,im1)=tsindn(mx,im)
            end do
            if (iop(30) .eq. 5 .or. iop(30) .eq. 6 .or.
     -          iop(30) .eq. 8) then
              e01st(1,im1)=e01st(1,im1)
              e01st(2,im1)=e01st(2,im1)
              eone(1,im1)=eone(1,im)
              eone(2,im1)=eone(2,im)
              eone(3,im1)=eone(3,im)
              etwo(1,im1)=etwo(1,im)
              etwo(2,im1)=etwo(2,im)
              etwo(3,im1)=etwo(3,im)
            end if
            nslvds(im1)=nslvds(im)
            nslvdsid(im1)=nslvdsid(im)
            rijpso(im1)=rijpso(im)
            ipxo(im1)=ipxo(im)
            lstmvd(im1)=lstmvd(im)
            nrejis(im1)=nrejis(im)
            npckd(im1)=npckd(im)
            nmvd(im1)=nmvd(im)
            ncor(im1)=ncor(im)
            if (iop(82) .gt. 0) iopbst(im1)=iopbst(im)
          end do
C@NNc         Move the columns first - move by words
C@NN          do im=ism1,nmolec
C@NN            im1=im-1
C@NN            do iw=1,nmolmp
C@NN              mapbitv(iw,im1)=mapbitv(iw,im)
C@NN            end do
C@NN          end do
C@NNc         Move the rows up - do by bits
C@NN          do iw=1,nmolec
C@NN            call readbitc(mapbitv,iw,ibit1,1,nmolec,#VW,#MO,nbits)
C@NN            do im=ism1,nmolec
C@NN              im1=im-1
C@NN              imw=(im1-1)/nbits+1
C@NN              imb=im1-(imw-1)*nbits
C@NN              if (ibit1(im) .eq. 1) then
C@NNC@NL                mapbitv(imw,iw)=mapbitv(imw,iw) .or. ibiton(imb)
C@NNC@NA                mapbitv(imw,iw)=ibset(mapbitv(imw,iw),imb-1)
C@NN              else
C@NNC@NL                mapbitv(imw,iw)=mapbitv(imw,iw) .and. ibitof(imb)
C@NNC@NA                mapbitv(imw,iw)=ibclr(mapbitv(imw,iw),imb-1)
C@NN              end if
C@NN            end do
C@NN          end do
          if (iop(80) .gt. 0) then
            do im=isid,nmolec-1
              molinout(im)=molinout(im+1)
            end do
          end if
          if (iop(79) .gt. 0) then
            do im=isid,nmolec-1
              molinoutgr(im)=molinoutgr(im+1)
            end do
          end if
        end if
      else
        ndlast=ndlast+1
      end if
C@DM      if (iop(21) .eq. 3) then
C@DM        lastcpuuse=icpuslv(nmolec)
C@DM        iflslv(2,lastcpuuse)=iflslv(2,lastcpuuse)-1
C@DM        ncountslv(lastcpuuse)=ncountslv(lastcpuuse)-1
C@DM        ncountslv3(lastcpuuse)=ncountslv3(lastcpuuse)-3
C@DM        if (iflslv(2,lastcpuuse) .lt. iflslv(1,lastcpuuse)) then
C@DM          if (MYRANK .eq. 0 .and. iop(24) .gt. 0)
C@DM     -      write (iout,1004) lastcpuuse
C@DM        end if
C@DM      end if
      rcomiso(nmolec)=0.0
      do mx=1,3
        tsindo(mx,nmolec)=0.d0
        tsind(mx,nmolec)=0.d0
        delc(mx,nmolec)=0.d0
      end do
      nmolec=nmolec-1
      numsolv=numsolv-1
      uuscor=1.0
      if (iop(53) .ge. 2) uuscor=exp(-uewnew)
      nmol3=nmol3-3
      natoms=natoms-nslv
C@D1      call eijtst(eij,216,nmolec,isid,texn,tesi,3)
      go to 50
40    continue
c-----Try to *insert*
      indel=+1
c     Insert new molecule
      nitry=nitry+1
      ninstr(nmolec)=ninstr(nmolec)+1
      isid=nmolec+1
      nerr=0
      call checkdim(ifail,iout,nerr,'MO',isid,0,0,0)
      call checkdim(ifail,iout,nerr,'NA',natoms+nslv,0,1,0)
      if (nerr .gt. 0) then
        call csave(ichkp,0,iskipfail,1)
C@DM        if (MYRANK .eq. 0) then
          call fileopen(file,namlenf,filenames(27),namlens(27),27,0,
     -      99,99,0,iform(27),1,iversout,iout,icord,0)
          call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -      iop(47),iop(41),iop(90),iop(30),iop(24),filenames(27),
     -      namlens(27),iop(98),0,c)
          write (iout,1000)
C@DM        end if
          nminus=nmc-nrpt+1
          if (iop(4)+iop(111) .gt. 0)
     -      call wrapup(nminus,nmolec,c,orient,crm,nstta,nslv,iout)
          call disfin(nminus,c,orient,crm,orientsltm,crm0)
        call datprt(2)
      end if
      call mmc_random(2,drno)
      if (iop(41) .eq. 3 .or. ngfree .eq. 0) then
c       No Cavity bias or no free grid at the moment, do random insertion
        nran=nran+1
        nocavf(nmolec)=nocavf(nmolec)+1
        call ranpos(iop(5),crm(1,isid))
        pcav=1.0
        nfound=0
      else
c       Find a random free grid, insert
        if (iop(63) .gt. 0) then
c         Preferential sampling for insertion
          call pfsel(insx,wpsgdsum,wpsgd,wpfpsgd,limpsgd,
     -      1,ngfree,npfsgd)
        else
c         Find a random free grid
          insx=int(drno(1)*ngfree)+1
        end if
c       Insert
        indx=igfree(insx)
        call unpackijk(indx,ng1,ix,iy,iz)
        crm(1,isid)=e2gm(1)+ix*grid(1)
        crm(2,isid)=e2gm(2)+iy*grid(2)
        crm(3,isid)=e2gm(3)+iz*grid(3)
        pcav=float(ngfree)/fltng3
        if (iop(41) .eq. 2) then
c         Add random shift
          call mmc_random(3,drnxyz)
          do k=1,3
            drnxyzk=drnxyz(k)
            crm(k,isid)=crm(k,isid)-grid2(k)+drnxyzk*grid(k)
          end do
        end if
      end if
      nmolec=nmolec+1
      numsolv=numsolv+1
      nmol3=nmol3+3
      natoms=natoms+nslv
      call putmol(nslv,rlcslv,crm(1,nmolec),
     -  c(1,ic01+nmolec*nslv),orient(1,1,nmolec))
      tesi(nmolec)=0.d0
      do mx=1,3
        tsind(mx,nmolec)=0.0
        tsindn(mx,nmolec)=0.0
      end do
c     Update bitmap size, set all bits on in the bitmap
C@NN      nmolmp=(nmolec-1)/nbits+1
C@NN      do i=1,nmolmp
C@NN        mapbitv(i,nmolec)=iallon
C@NN      end do
      nmolecdo=nmolec
      call engcha(etotn,etoto,estscn,nmolec,tesi,c,crm,nmolecdo)
C@EF      if (isnan(tesiis)) tesiis=realmx
c     Update the total binding energy, force and torque arrays for deletion
      den=-tesiis*beta+ba
      if (iop(53) .ge. 1) then
        tss1n=tss1+tsindn(3,nmolec)
        uewnew=tss1n-uscpma*dfloat(nmolec-1)
        uewnew=usmixp*dble(beta)*uewnew
        uewold=uewnew-usmixp*dble(beta)*(tsindn(3,isid)-uscpma)
        den=den+uewnew-uewold
      end if
      diffpcln=den+alog(pcav)
      if (iop(79) .eq. 0) then
        diffpcln=diffpcln-alog(float(nmolec-idsvfst+1))
      else
        diffpcln=diffpcln-alog(float(nmolinoutgr(1)))
      end if
c     diffpcln >= 0 results in sure acceptance
      if (diffpcln .lt. 0.0) then
        if (diffpcln .le. -rllnmx) then
          diffpc=0.0
        else
          diffpc=exp(diffpcln)
        end if
        if (diffpc .lt. drno(2)) then
c         Reject insertion
          isid=-isid
          do mx=1,3
            tsind(mx,nmolec)=0.d0
            tsindn(mx,nmolec)=0.d0
          end do
          nmolec=nmolec-1
          numsolv=numsolv-1
          nmol3=nmol3-3
          natoms=natoms-nslv
          uuscor=1.0
          if (iop(53) .ge. 2) uuscor=exp(-uewold)
          go to 54
        end if
      end if
c     Accept insertion
      iaccid=1
      niaccp=niaccp+1
      if (iop(42) .gt. 0) then
C@DM        if (iop(42) .eq. 2) then
C@DMc         Get the proximity info for isid
C@DM          icpu=NUMNOD
C@DM          if (MYRANK .eq. icpu-1) then
C@DM            call MPI_send(ipxo(isid),1,MPI_INTEGER,0,717,
C@DM     -       MPI_COMM_WORLD,ierr)
C@DM            call MPI_send(rijpso(isid),1,MPI_REAL,0,818,
C@DM     -       MPI_COMM_WORLD,ierr)
C@DM          end if
C@DM          if (MYRANK .eq. 0) then
C@DM            call MPI_recv(ipxo(isid),1,MPI_INTEGER,icpu-1,717,
C@DM     -        MPI_COMM_WORLD,MPI_stat,ierr)
C@DM            call MPI_recv(rijpso(isid),1,MPI_REAL,icpu-1,818,
C@DM     -        MPI_COMM_WORLD,MPI_stat,ierr)
C@DM          end if
C@DM        end if
C@DM        if (MYRANK .eq. 0) then
        if (iop(42) .eq. 1) write (iindel,4600) indel,isid-1,nmolec-1,
     -      nmc,cplpar,((crm(k,isid)),k=1,3)
        if (iop(42) .eq. 2) write (iindel,4600) indel,isid-1,nmolec-1,
     -      nmc,cplpar,((crm(k,isid)),k=1,3),ipxis,sqrt(rijpsis)
C@DM        end if
        numrec(5)=numrec(5)+1
      end if
      niddst=niddst+dfloat(nmc-nmdlst)
      if (iop(41) .eq. 1 .or. iop(41) .eq. 2)
     -  call addcov(crm(1,isid),rsphs,rspvpe2,rspvme2,1)
      etoto=etotn
      do k=1,3
C@FR        virial(k)=virial(k)+virscn(k)
C@FR        vsltsm(k)=vsltsm(k)+vrsltn(k,nmolec)
C@FR        do i=1,nmolec
C@FR          frctot(k,i)=frctot(k,i)+frcn(k,i)
C@FR          trqtot(k,i)=trqtot(k,i)+trqn(k,i)
C@FR        end do
      end do
C@D1      call eijtst(eij,216,nmolec,isid,texn,tesi,1)
      do is=1,nmolec
        tesi(is)=tesi(is)+texn(is)
      end do
      do mx=1,3
        tsind(mx,nmolec)=tsindn(mx,nmolec)
      end do
      tesi(nmolec)=tesiis
C@D1      call eijtst(eij,216,nmolec,isid,texn,tesi,3)
      rcomiso(nmolec)=rijnis
      if (rcomiso(nmolec) .lt. rinscs) estsco=estsco+texn(1)
      tss12=tss12+tsindn(1,nmolec)
      tss6=tss6+tsindn(2,nmolec)
      tss1=tss1+tsindn(3,nmolec)
      uuscor=1.0
      if (iop(53) .ge. 2) uuscor=exp(-uewnew)
      do k=1,3
        frctot(k,isid)=frci(k)
        trqtot(k,isid)=trqi(k)
      end do
      call trnsfr(crm0(1,isid),crm(1,isid),3)
C@NN      call trnsfr(clstup(1,isid),crm(1,isid),3)
      lstmvd(isid)=nmc
      nrejis(isid)=0
      npckd(isid)=0
      nmvd(isid)=0
c     Should be zero but avoid the dividing by zero if something goes wrong
      delc(1,isid)=1.e-08
      delc(2,isid)=1.e-08
      delc(3,isid)=1.e-08
      if (nis(1) .lt. nfsslt) ncor(1)=ncor(1)+1
      if (iop(82) .gt. 0) iopbst(isid)=iopbso(isid)
      nmolo=nmolec-1
      ncr=1
      do i=2,nmolo
        if (nis(i) .lt. nfslww) then
          ncor(i)=ncor(i)+1
          ncr=ncr+1
        end if
      end do
      ncor(nmolec)=ncr
      if (iop(80) .gt. 0) then
        call solvinout(molinout(isid),crm(1,isid),edgelinxyz,edgerinxyz)
        nmolinout(molinout(isid))=nmolinout(molinout(isid))+1
      end if
      if (iop(79) .gt. 0) then
        molinoutgr(isid)=1
        nmolinoutgr(1)=nmolinoutgr(1)+1
      end if
C@NN      call checkdim(ifail,iout,inperr,'VW',nmolmp,0,0,0)
C@NN      if (iop(21) .eq. 1 .or. iop(21) .eq. 2) then
C@NN        do ii=2,isid-1
C@NN          i=isid+1-ii
C@NN          riijjv(i)=riijjv(i-1)
C@NN        end do
C@NN        riijjv(1)=0.0
C@NN        riijjv(isid)=0.0
C@NN      end if
C@NN      isw=(isid-1)/nbits+1
C@NN      isb=isid-(isw-1)*nbits
C@NN      do im=1,nmolo
C@NN        imw=(im-1)/nbits+1
C@NN        imb=im-(imw-1)*nbits
C@NN        if (riijjv(im) .le. rccmp2) then
C@NNC@NL          mapbitv(imw,isid)=mapbitv(imw,isid) .or. ibiton(imb)
C@NNC@NA          mapbitv(imw,isid)=ibset(mapbitv(imw,isid),imb-1)
C@NNC@NL          mapbitv(isw,im)=mapbitv(isw,im) .or. ibiton(isb)
C@NNC@NA          mapbitv(isw,im)=ibset(mapbitv(isw,im),isb-1)
C@NN        else
C@NNC@NL          mapbitv(imw,isid)=mapbitv(imw,isid) .and. ibitof(imb)
C@NNC@NA          mapbitv(imw,isid)=ibclr(mapbitv(imw,isid),imb-1)
C@NNC@NL          mapbitv(isw,im)=mapbitv(isw,im) .and. ibitof(isb)
C@NNC@NA          mapbitv(isw,im)=ibclr(mapbitv(isw,im),isb-1)
C@NN        end if
C@NN      end do
      call savsusvfull(nmolec,nmolec,texslt,vrcslt,frcslt,trtslt,trvslt,
     -  tss12,tss6,tss1,tsind)
c     Update pref weight info
      if (iop(12) .gt. 3) then
        wpsmv(nmolec)=prfwgt(nis(1),wpsmvn,0)
        wpsmvsum=wpsmvsum+wpsmv(nmolec)
        if (ipsmv(nmolec) .eq. 0) ipsmv(nmolec)=npfsmv
        do is=ipsmv(nmolec),npfsmv
          wpfpsmv(is)=wpfpsmv(is)+wpsmv(nmolec)
          limpsmv(is)=limpsmv(is)+1
        end do
      end if
      if (iop(63) .gt. 0) then
        wpsid(nmolec)=prfwgt(nslvdsid(nmolec),wpsidn,iop(79))
        wpsidsum=wpsidsum+wpsid(nmolec)
        if (ipsid(nmolec) .eq. 0) ipsid(nmolec)=npfsid
        do is=ipsid(nmolec),npfsid
          wpfpsid(is)=wpfpsid(is)+wpsid(nmolec)
          limpsid(is)=limpsid(is)+1
        end do
c       The elements of igfree over ngfree contain the location of the
c       deleted cavities
        do ig=ngfreeo,ngfree+1,-1
          igdel=igfree(ig)
          wpsgdsum=wpsgdsum-wpsgd(igdel)
          do is=ipsgd(igdel),npfsgd
            wpfpsgd(is)=wpfpsgd(is)-wpsgd(igdel)
          end do
          do is=ipsgd(igdel),ipsgd(ig)-1
            wpfpsgd(is)=wpfpsgd(is)+wpsgd(ig)
          end do
          do is=ipsgd(ig),npfsgd
            limpsgd(is)=limpsgd(is)-1
          end do
          wpsgd(igdel)=wpsgd(ig)
        end do
      end if
C@DM      lastcpuuse=icpuslv(nmolec-1)
C@DM      if (lastcpuuse .lt. NUMNOD) then
C@DM        if (iflslv(2,lastcpuuse) .eq. iflslv(1,lastcpuuse+1)-1) then
C@DM          lastcpuuse=lastcpuuse+1
C@DM          if (MYRANK .eq. 0 .and. iop(24) .gt. 0)
C@DM     -      write (iout,1004) lastcpuuse
C@DM        end if
C@DM      end if
C@DM      iflslv(2,lastcpuuse)=iflslv(2,lastcpuuse)+1
C@DM      icpuslv(nmolec)=lastcpuuse
C@DM      ncountslv(lastcpuuse)=ncountslv(lastcpuuse)+1
C@DM      ncountslv3(lastcpuuse)=ncountslv3(lastcpuuse)+3
c     Extremum updates for accepted insertion or deletion
50    if (etoto .gt. emax) then
        emax=etotn
        nemax=nmc/1000
      else if (etoto .lt. emin) then
        emin=etotn
        nemin=nmc/1000
      end if
      if (nmolec-1 .lt. namin) namin=nmolec-1
      if (nmolec-1 .gt. namax) namax=nmolec-1
      if (nmolec-1 .eq. nslvxp .and. iop(15) .gt. 0) then
C@DM        if (MYRANK .eq. 0) then
c       call savec(icord,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
c    -    iop(47),1,iop(90),iop(30),iop(24),filenames(2),namlens(2),
c    -    iop(98),0,c)
        write (iout,1001) nslvxp,nmc
        if (nslvxp .eq. 0) call extrap_ann_2(1,0,iout)
        if (iop(76) .gt. 0 .or. iop(129) .gt. 0) write (iout,1003) ba
C@DM      end if
        call csave(ichkp,0,iskipfail,1)
c       call datprt(1)
        istop=1
        return
      end if
c     Accumulator updates for accepted or rejected steps
54    nidmc=nidmc+1
      if (iop(22) .gt. 0) then
c       Accumulate acceptance ratio info
        if (isid .lt. 0) then
          iaccid=0
          isidabs=-isid
          if (indel .eq. 1) isidabs=isidabs-1
        else
          iaccid=1
          isidabs=isid
        end if
C@DM        icpu=icpuslv(isidabs)
C@DM        if (MYRANK .eq. icpu-1) then
          ipxid=0
          if (rijpso(isidabs) .le. rpxidlim2) ipxid=ipxo(isidabs)
C@DM          call MPI_send(ipxid,1,MPI_INTEGER,0,727,
C@DM     -      MPI_COMM_WORLD,ierr)
C@DM        end if
C@DM        if (MYRANK .eq. 0) then
C@DM          call MPI_recv(ipxid,1,MPI_INTEGER,icpu-1,727,
C@DM     -      MPI_COMM_WORLD,MPI_stat,ierr)
          if (ipxid .gt. 0) then
            if (indel .eq. 1) then
              if (iaccid .eq. 1)idproxacc(1,ipxid)=idproxacc(1,ipxid)+1
              idproxacc(2,ipxid)=idproxacc(2,ipxid)+1
            else
              if (iaccid .eq. 1)idproxacc(3,ipxid)=idproxacc(3,ipxid)+1
              idproxacc(4,ipxid)=idproxacc(4,ipxid)+1
            end if
          end if
C@DM        end if
      end if
      ndistr(nmolec)=ndistr(nmolec)+1
      call accumulate(uusfac,' ')
      if (iop(30) .gt. 3) then
        if (iop(30) .eq. 7) then
c         Update probability ratio us accumulators (iop(30) =  7).
          uwtav=uwtav+uwcplo
          igr=(cplpar-d0cpl)/g0cpl
          if (igr .lt. 1) igr=1
          if (igr .gt. #WG) igr=#WG
          dstcpl(igr)=dstcpl(igr)+uwcplo
          nfisum(igr)=nfisum(igr)+1
        else
c         Coulomb term umbrella sampling correction (iop(53)=3)
c         is allowed only for iop(30)=0
c         Accumulate free energy calculation sums (iop(30)=5,6 or 8)
          dele=e1o-e0o
c         Update min and max for (e1-e0)
          if (dele .le. de01mn) then
            de01mn=dele
            nm01mn=nmc
          else if (dele .ge. de01mx) then
            de01mx=dele
            nm01mx=nmc
          end if
          ue1=ue1+e1o
          ue0=ue0+e0o
          ue0ind(1)=ue0ind(1)+e0o12
          ue0ind(2)=ue0ind(2)-e0o6
          ue0ind(3)=ue0ind(3)+e0o1
          ue1ind(1)=ue1ind(1)+e1o12
          ue1ind(2)=ue1ind(2)-e1o6
          ue1ind(3)=ue1ind(3)+e1o1
          if (iop(30) .eq. 6) then
c           Accumulate exp(e(uspar1)-e(cplpar)) and exp(e(uspar0)-e(cplpar)) at
c           cplpar; e(uspar0), e(uspar1) at uspar0, uspar1, resp, with half us.
            deleb=(dele-delest)*beta
            expmax=alog(realmx/1.e+10)
            wschk=exp(amin1(expmax,-deleb*(uspar0-cplpar)))
            uus0=uus0+(e0o*uspr01+e1o*uspar0)*wschk
            uws0=uws0+wschk
            wschk=exp(amin1(expmax,-deleb*(uspar1-cplpar)))
            uus1=uus1+(e0o*uspr11+e1o*uspar1)*wschk
            uws1=uws1+wschk
          else if (iop(30) .eq. 8) then
c           Overlap ratio and perturbation method with explicite middle state
            dele0=tesi(1)-e0o-del0st
            dele1=e1o-tesi(1)-del1st
            if (dele0 .lt. -edifmx) dele0=edifmx
            if (dele1 .lt. -edifmx) dele1=edifmx
c           Accumulate the exponential sums:
            wschk0=exp(-dele0*beta)
            wschk1=exp(-dele1*beta)
            uws0=uws0+wschk0
            uws1=uws1+wschk1
c           Accumulate the us sums for &- and for &+ averages
            uus0=uus0+e0o*wschk0
            uus1=uus1+e1o*wschk1
c           Accumulate the energy distributions for overlap ratio calculations
            ig0=(dele0-gmor0k)/gdvork+1
            if (ig0 .lt. 1) ig0=1
            if (ig0 .gt. #OR) ig0=#OR
            norde0(ig0)=norde0(ig0)+1
            ig1=(dele1-gmor1k)/gdvork+1
            if (ig1 .lt. 1) ig1=1
            if (ig1 .gt. #OR) ig1=#OR
            norde1(ig1)=norde1(ig1)+1
          end if
        end if
      end if
c     Accumulate force and torque component squares for quantum correction
c     Not DONE
ccc        do k=1,3
ccc          fsmslv=fsmslv+frctot(k,isolv)**2/wpsmvnew
ccc          tsmslv(k)=tsmslv(k)+trqtot(k,isolv)**2/wpsmvnew
ccc        end do
ccc        wpsmvi=wpsmvi+1.0/wpsmvnew
      if (mod(nidmc,idrepf) .eq. 0) then
        paid=float(niaccp+ndaccp)/float(nidmc)
        rnav=rnsum/(ucsmid+ucsmmv)
        nmp=(nmolec-1)*indel
        if (MYRANK .eq. 0)
     -    write (iout,1007) nidmc,etotn,nmp,rnav,namin,namax,paid,
     -    ngfree,pcav,isid
      end if
      return
1000  format(' No space for insertion. Current configuration is saved',
     -  ' and the checkpoint file is updated')
1001  format(' Required number of solvent molecules (',i7,') have ',
     -  'been reached at Nmc=',i10)
1002  format(' ***** ERROR: number of free grids exceeds capacity (',
     -  '#PP) - redimension with larger maxcavps (#',a,')')
1003  format(' Current B parameter value=',f10.5)
C@DM1004  format(' ///// NOTE: Processor # ',i3,' run out of solvents')
C@DM1005  format(' ///// NOTE: Processor # ',i3,' is reactivated')
1006  format('REMARK SACP Last solvent at B=',f8.2)
1007  format(' Nidmc=',i10,' E=',e12.6,' N=',i6,' <N>=',f10.4,
     -  ' Nmn,Nmx=',2i6,' id acc=',f7.5,' ngf=',i9,
     -  ' Pcav=',f7.5,'  is=',i6)
4600  format(i3,2i6,i10,f6.3,3f13.3,i6,f10.2)
      end
      subroutine initwidom
c#    MMC routine 308 lstmod: 06/29/99
c*****Initialize Widom method calculation
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
       real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      do im=1,nmolwid
        do ig=1,ngrid(1)
          rncavx(ig)=0.d0
          ewmin(ig,im)=1.E+30
          ewmax(ig,im)=-1.E+30
          expesum(ig,im)=0.d0
        end do
      end do
      return
      end
      subroutine accuwidom(c,crm,nmolec,vol,ctslts,cutuus,
     -  edgex2,edgey2,edge2,ncnfpx,ifail)
c#    MMC routine 309 lstmod: 12/08/06
c*****Accumulate Widom method calculation
      dimension c(3,#NA),crm(3,#MO)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /liga/ ligand_start_molecule,last_slt_mol_g
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      real*8 efieldst0,efieldmst
      common /fieldenergy/ efieldst0,efieldmst(#MM),
     -  efieldsv(#MO),esltfldo(#ST),esltfldn(#ST)
      common /frind2/ crat6,crat1
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv(3,#UV),ab(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension cg(3),ort(3,3),crmx(3),gsumx(3),cpl0(3),cpl1(3)
      real*8 egslt,egslv,gsumx,gsum12,exparg
      data cpl0 /3*0.0/,cpl1 /3*0.0/
      crat1=1.0
      crat6=1.0
      call mmc_random(3,ranshift)
      do igt=1,nwgtry
        do k=1,3
          if (ishifttp(k) .eq. 1) ranshift(k)=0.5
          if (ishifttp(k) .eq. 2) ranshift(k)=float(igt)/float(nwgtry)
        end do
        call initgrid(nmolec,1.0,diamslv/2.0,1,vsltx,vol,
     -    c,crm,ncnfpx,0,0,'FREE WIDO',iop(24)-1,idebug(58)-1)
        do ig=1,ngfree
          call unpackijk(igfree(ig),ng1,ix,iy,iz)
          rncavx(ix)=rncavx(ix)+nwitry
          cg(1)=e2gm(1)+ix*grid(1)
          cg(2)=e2gm(2)+iy*grid(2)
          cg(3)=e2gm(3)+iz*grid(3)
          if (idebug(58) .gt. 2) then
            do is=2,nmolec
              call arrdiff(zv(1,is),cg,crm(1,is),3)
            end do
            call pbcvec(iop(5),2,nmolec)
            r2=100000.0
            do is=2,nmolec
              if (r2 .gt. riijjv(is)) then
                r2=riijjv(is)
                iss=is
              end if
            end do
            r2=sqrt(r2)
            write (iout,8754) ig,ix,iy,iz,cg,iss,r2,(crm(k,iss),k=1,3)
8754        format(i6,' ixyz=',3i4,' cg=',3f10.5,' iclose=',i4,
     -        ' d=',f10.5,' crm=',3f10.5)
            do ia=nstfa+1,nstta
              call arrdiff(zv(1,ia),cg,c(1,ia),3)
            end do
            call pbcvec(iop(5),nstfa+1,nstta)
            r2=100000.0
            do ia=nstfa+1,nstta
              if (r2 .gt. riijjv(ia)) then
                r2=riijjv(ia)
                iaa=ia
              end if
            end do
            if (nstta .gt. nstfa)
     -        write (iout,8755) ig,ix,iy,iz,cg,iaa,r2,(c(k,iaa),k=1,3)
8755        format(i6,' ixyz=',3i4,' cg=',3f10.5,' iclose=',i4,
     -        ' d=',f10.5,' c=',3f10.5)
          end if
          do im=1,nmolwid
            ifatw=ifirstm(im)
            ifatwc=ifatw
            if (ifdummy(im) .eq. 1) ifatwc=ifatwc-1
            ilatw=ilastm(im)
            natw=ilatw-ifatw+1
            natwc=ilatw-ifatwc+1
            do it=1,nwitry
              call putmol(natwc,rlcslt(1,ifatwc),cg,c(1,ifatwc),ort)
              if (idebug(58) .gt. 1)
     -          write (iout,1000)cg,(ia,(c(k,ia),k=1,3),ia=ifatwc,ilatw)
              egslv=0.d0
              do is=2,nmolec
                egslv=egslv+eslt(is,riijj,iop(2),ipfgr(im),ifatw,ilatw,
     -            nstsvgr(im),nslvggr(im),c(1,molcnt(im)),igrcnt(im),im,
     -            ioppbc,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
              end do
              call zeroitd(gbernew(ifatw),natw)
              call esltsltg(c,nmolwid+1,nsttm,ifirstm,ilastm,
     -          ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbenew,gbernew,1,
     -          istf,nstta,iclsltt,qslteps,im,0,0,gsum12,0,0,cpl1,cpl0,
     -          gsumx,gsumx,igrcnt,molcnt,crmx,iop(5),iop(65),indexx,
     -          ivopt,riijjv,cgs,cutuus,iop(127))
              egslt=0.d0
              do ia=ifatw,ilatw
                egslt=egslt+gbernew(ia)
              end do
              ew=egslt+egslv
              if (idebug(58) .gt. 1)
     -          write (iout,1001) ig,im,it,igt,egslt,egslv,ew
              if (ewmin(ix,im) .ge. ew) ewmin(ix,im)=ew
              if (ewmax(ix,im) .le. ew) ewmax(ix,im)=ew
              exparg=dble((ew-ew0(im))*beta)
              if (exparg .lt. dblnmx)
     -          expesum(ix,im)=expesum(ix,im)+dexp(-exparg)
            end do
          end do
        end do
        if (igt .lt. nwgtry) then
          do k=1,3
            ranshift(k)=ranshift(k)+1.d0/dfloat(nwgtry)
            if (ranshift(k) .gt. 1.d0) ranshift(k)=ranshift(k)-1.d0
          end do
        end if
      end do
      ifail=0
      do im=1,nmolwid
        ewminx=ewmin(1,im)
        do ix=2,ngrid(1)
          if (ewmin(ix,im) .lt. ewminx) ewminx=ewmin(ix,im)
        end do
        if (-(ewminx-ew0(im))*beta .gt. dblnmx) then
          ew0new=ewminx-(20.0-dblnmx)/beta
          write (iout,1002) im,ncnfpx,ew0new,ewminx
C@ND          call datprt(2)
          ifail=1
        end if
      end do
      if (idebug(58) .gt. 0) call disfinwidom(ncnfpx,molcnt)
      return
1000  format(' ACCUWIDOM cg=',3f10.5,' cghost=',/,(i4,3f10.5,i6,3f10.5))
1001  format(' ACCUWIDOM ',i6,3i3,' eslt,eslv,e=',3e13.5)
1002  format(' ***** ERROR: -(insertion energy-ew0)/kT is too large ',
     -  'for ghost molecule ',i2,' Structure ',i9,' Restart with ',
     -  'decreased ew0 after FREE WIDO',/,7x,'Suggested ew0 value=',
     -  f10.4,' (based on the lowest energy found,',f10.4,' kcal/mol)')
      end
      subroutine mpi_reducewidom
c#    MMC routine 310 lstmod: 11/27/04
c*****Accumulate Widom method calculation
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      real*8 rmpisum
C@DM      dimension rmpisum(#GX),rmpiminmax(#GX)
C@DM      call MPI_reduce(rncavx,rmpisum,ngrid(1),
C@DM     -  MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@DM      if (MYRANK .eq. 0) call trnsfrd(rncavx,rmpisum,ngrid(1))
C@DM      do im=1,nmolwid
C@DM        call MPI_reduce(expesum(1,im),rmpisum,ngrid(1),
C@DM     -    MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_reduce(ewmin(1,im),rmpiminmax,ngrid(1),
C@DM     -    MPI_REAL,MPI_MIN,0,MPI_COMM_WORLD,ierr)
C@DM        if (MYRANK .eq. 0) then
C@DM          call trnsfrd(expesum(1,im),rmpisum,ngrid(1))
C@DM          call trnsfr(ewmin(1,im),rmpiminmax,ngrid(1))
C@DM        end if
C@DM        call MPI_reduce(ewmax(1,im),rmpiminmax,ngrid(1),
C@DM     -    MPI_REAL,MPI_MAX,0,MPI_COMM_WORLD,ierr)
C@DM        if (MYRANK .eq. 0)
C@DM     -    call trnsfr(ewmax(1,im),rmpiminmax,ngrid(1))
C@DM      end do
      return
      end
      subroutine mpi_resetwidom
c#    MMC routine 311 lstmod: 01/27/05
c*****Reinitialize Widom method accumulators
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@DM      do im=1,nmolwid
C@DM        call zeroitd(rncavx,ngrid(1))
C@DM        call zeroitd(expesum(1,im),ngrid(1))
C@DM        call zeroit(ewmin(1,im),ngrid(1))
C@DM        call zeroit(ewmax(1,im),ngrid(1))
C@DM      end do
      return
      end
      subroutine disfinwidom(nconf,molcnt)
c#    MMC routine 312 lstmod: 12/10/06
c*****Prepare Widom method calculation results
      dimension molcnt(#MM)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /tdstate/ press,pressv,ba,temp,beta
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension rx(#GX),pcavx(#GX),chpot(#GX),nyz(#GX)
      real*8 eesum,rncavsum,eesuml,eesumm,eesumr,rncavsuml,
     -  rncavsumm,rncavsumr,rnls,rnms,rnrs,rns
      do im=1,nmolwid
        eesum=0.d0
        rncavsum=0.d0
        eesuml=0.d0
        rncavsuml=0.d0
        eesumm=0.d0
        rncavsumm=0.d0
        eesumr=0.d0
        rncavsumr=0.d0
        rnls=0.d0
        rnms=0.d0
        rnrs=0.d0
        nbulkgr=ngrid(1)*0.15
        nmidmin=ngrid(1)/2-ngrid(1)*0.10
        nmidmax=ngrid(1)/2+ngrid(1)*0.10
        write (iout,1000) im,fcglab(molcnt(im)),nconf
        call zeroit(chpot,ngrid(1))
        do ix=1,ngrid(1)
          nyz(ix)=ng3/ngrid(1)
          rx(ix)=e2gm(1)+ix*grid(1)
          if (ix .le. nbulkgr) then
            eesuml=eesuml+expesum(ix,im)
            rncavsuml=rncavsuml+rncavx(ix)
            rnls=rnls+dfloat(nyz(ix))*nconf*nwitry*nwgtry
          else if (ix .ge. ngrid(1)-nbulkgr) then
            eesumr=eesumr+expesum(ix,im)
            rncavsumr=rncavsumr+rncavx(ix)
            rnrs=rnrs+dfloat(nyz(ix))*nconf*nwitry*nwgtry
          end if
          if (ix .le. nmidmax .and. ix .gt. nmidmin) then
            eesumm=eesumm+expesum(ix,im)
            rncavsumm=rncavsumm+rncavx(ix)
            rnms=rnms+dfloat(nyz(ix))*nconf*nwitry*nwgtry
          end if
          eesum=eesum+expesum(ix,im)
          rncavsum=rncavsum+rncavx(ix)
          avcavx=rncavx(ix)/(nconf*nwitry*nwgtry)
          if (iop(5) .ne. 0) then
            do iy=1,ngrid(2)
              do iz=1,ngrid(3)
                if (ncover(ix,iy,iz) .ge. 999) nyz(ix)=nyz(ix)-1
              end do
            end do
          end if
          pcavx(ix)=avcavx/float(nyz(ix))
          if (rncavx(ix) .gt. 0.d0) then
            wcav=-alog(pcavx(ix))/beta
            chpot(ix)=ew0(im)+rllnmx
            if (expesum(ix,im) .gt. 0.d0) chpot(ix)=
     -        ew0(im)-dlog(expesum(ix,im)/rncavx(ix))/beta+wcav
            write (iout,1001) ix,rx(ix),avcavx,pcavx(ix),chpot(ix),
     -        wcav,ewmin(ix,im),ewmax(ix,im)
          else
            write (iout,1002) ix,rx(ix)
            chpot(ix)=0.0
            pcavx(ix)=0.0
          end if
        end do
        rns=dfloat(ng3)*dfloat(nconf*nwgtry*nwitry)
        call printrangecp(rncavsum,rns,eesum,ew0(im),rx(1),
     -    rx(ngrid(1)),1,beta,iout)
        call printrangecp(rncavsuml,rnls,eesuml,ew0(im),
     -    rx(1),rx(nbulkgr),0,beta,iout)
        call printrangecp(rncavsumm,rnms,eesumm,ew0(im),
     -    rx(nmidmin),rx(nmidmax),0,beta,iout)
        call printrangecp(rncavsumr,rnrs,eesumr,ew0(im),
     -    rx(ngrid(1)-nbulkgr),rx(ngrid(1)),0,beta,iout)
        if (iop(5) .ne. 1) write (iout,1005) nyz(1)
        call plot(rx,chpot,pcavx,ngrid(1),0.0,0.0,0.0,0.0,50,99,0,57,48,
     -    '*: -kT ln<exp(-E/kT)> - kT ln(pcav) (kcal/mol); O: p(cav)',
     -    0,0,1)
c       Double the gridsize
        ngxnew=ngrid(1)/2
        do ix=1,ngxnew
          rx(ix)=(rx(2*ix)+rx(2*ix-1))/2.0
          if (rncavx(2*ix)+rncavx(2*ix-1) .gt. 0.d0) then
            pcavx(ix)=(rncavx(2*ix)+rncavx(2*ix-1))/
     -        (nconf*nwitry*nwgtry)/float(nyz(2*ix)+nyz(2*ix-1))
            chpot(ix)=ew0(im)+rllnmx
            if (expesum(2*ix,im)+expesum(2*ix-1,im) .gt. 0.d0)
     -        chpot(ix)=ew0(im)-
     -          dlog((expesum(2*ix,im)+expesum(2*ix-1,im))/
     -          (rncavx(2*ix)+rncavx(2*ix-1)))/beta-alog(pcavx(ix))/beta
          else
            chpot(ix)=0.0
            pcavx(ix)=0.0
          end if
        end do
        write (iout,1004)
        call plot(rx,chpot,pcavx,ngxnew,0.0,0.0,0.0,0.0,50,99,0,57,48,
     -    '*: -kT ln<exp(-e/kT)> - kT ln(pcav) (kcal/mol); O: p(cav)',
     -    0,0,1)
      end do
      return
1000  format(' Widom method excess chemical potential calculation for ',
     -  'ghost molecule ',i2,' (',a,')  Number of configurations used=',
     -  i6)
1001  format(i5,' r=',f8.3,' <ncav>=',f8.2,' pcav=',f8.5,
     -  ' exc. ch. pot.=',e12.5,' w(cav)=',e12.5,
     -  ' ewmin=',e12.5,' emax=',e12.5)
1002  format(i5,' r=',f8.3,' <ncav>=0  pcav=0.0')
1004  format(' Concatenating neighbouring grids')
1005  format(' Number of y-z gridpoints per slab=',i6)
      end
      subroutine printrangecp(rncavsum,rns,eesum,ew0,rxmin,rxmax,ibulk,
     -  beta,iout)
c#    MMC routine 313 lstmod: 01/12/04
c*****Print chemical potential information
      real*8 rncavsum,rns,eesum
      if (rns .le. 0 .or. rncavsum .le. 0) then
        write (iout,1000) rxmin,rxmax
        return
      end if
      pcav=rncavsum/rns
      chpot=ew0-dlog(eesum/rncavsum)/beta-alog(pcav)/beta
      if (ibulk .eq. 1) then
        write (iout,1001) pcav,chpot
      else
        write (iout,1003) rxmin,rxmax,pcav,chpot
      end if
      return
1000  format(' In the range X=',f8.2,' to X=',f8.2,' no cavity was ',
     -  'found. Consider decreasing Rcav')
1001  format(' The overall probability  of finding a cavity=',f8.5,
     -  ' excess chemical potential=',e12.5,' kcal/mol')
1003  format(' In the range X=',f8.2,' to X=',f8.2,' the probability ',
     -  ' of finding a cavity=',f8.5,' excess chemical potential=',
     -  e12.5,' kcal/mol')
      end
      subroutine initaddwidom(c,esf14,vdwf14,cutuus,anginc,noreset,
     -  inperr,iout)
c#    MMC routine 313/a lstmod: 03/03/08
c*****Initialize Widom method calculation for adding a functional group
      dimension c(3,#NA)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /reactionfield/ epsrf,rccon
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv(3,#UV),ab(3,#UV)
      common /worksp/ l1(#NA),l2(#UV),noanchor(#UV),l4(#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      dimension c23(3),c2x(3)
C@TN      real*8 gsumself,gsumx
C@TN      dimension gsumx(3),crmpmf(3),cplx(3)
      real*8 torsensumn,torsensumo,torsenlig,eiljes,eiljes14,eiljesnb,
     - elljes,elljes14
      dimension torsenlig(#GX),elljes(#GX),elljes14(#GX)
      data taanchor /0.0/
      if (noreset .eq. 0) then
c       Get a list of non-anchor atoms of the ligand
        imanchor=iamolslt(ighanchor(nghanchor+1))
        call zeroiti(l4,0,ilastm(imanchor))
        iasubst=ighanchor(nghanchor+1)
        do ia=1,nghanchor+1
          call checklim(ifail,iout,inperr,ifirstm(imanchor),
     -      ilastm(imanchor),ighanchor(ia),1,'anchor index',12)
          if (l4(ighanchor(ia)) .gt. 0) then
            write (iout,1011) ia,ighanchor(ia)
            inperr=inperr+1
          end if
          l4(ighanchor(ia))=1
        end do
        do ia=1,nghdrop
          l4(ighdrop(ia))=-1
        end do
        nnoanchor=0
        do ia=ifirstm(imanchor),ilastm(imanchor)
          if (l4(ia) .eq. 0) then
            nnoanchor=nnoanchor+1
            noanchor(nnoanchor)=ia
          end if
        end do
        if (idebug(58) .gt. 0) then
          write (iout,1003) 'Anchor    ',(ighanchor(i),i=1,nghanchor+1)
          write (iout,1003) 'Non anchor',(noanchor(i),i=1,nnoanchor)
          write (iout,1003) 'Dropped   ',(ighdrop(i),i=1,nghdrop)
        end if
        if (nnoanchor+nghanchor+nghdrop .ne.
     -      ilastm(imanchor)-ifirstm(imanchor)) then
          write (iout,1002) nghanchor+1,nnoanchor,nghdrop,
     -      ilastm(imanchor)-ifirstm(imanchor)+1
          inperr=inperr+1
        end if
        if (iop(105) .eq. 1 .and. nnoanchor .gt. 0) then
          write (iout,1010)
          inperr=inperr+1
        end if
        itanchor=0
        do it=ifirstt(imanchor),ilastt(imanchor)
          if (iquata(it,3) .eq. ighanchor(nghanchor)) itanchor=it
        end do
        if (nwitry .gt. 1 .and. itanchor .eq. 0) then
          write (iout,1007)
          inperr=inperr+1
        end if
c       Establish group limits for the atoms forming the anchor list
        ngrpanchor=1
        ifgrpanchor(ngrpanchor)=1
        do ia=2,nghanchor+1
          if (igrslt(ighanchor(ia)) .ne. igrslt(ighanchor(ia)-1)) then
            ilgrpanchor(ngrpanchor)=ia-1
            ngrpanchor=ngrpanchor+1
            ifgrpanchor(ngrpanchor)=ilgrpanchor(ngrpanchor-1)+1
          end if
        end do
        ilgrpanchor(ngrpanchor)=nghanchor+1
        if (idebug(58) .gt. 0) write (iout,1006) ngrpanchor,
     -    (ifgrpanchor(ig),ilgrpanchor(ig),ig=1,ngrpanchor)
        egsltxmin=1.e+30
        egslvxmin=egsltxmin
        do im=1,nmolwid
          egsltmin(im)=egsltxmin
          egslvmin(im)=egsltxmin
          expsltsum(im)=0.d0
          expslvsum(im)=0.d0
          expnoslvsum(im)=0.d0
          expintrasum(im)=0.d0
          do igi=1,nwitry
            do igg=1,nwgtry
              ig=(igi-1)*nwitry+igg
              ewmin(ig,im)=egsltxmin
              ewmax(ig,im)=-egsltxmin
              expesum(ig,im)=0.d0
            end do
          end do
          if (nwitry .gt. 1 .and.
     -        iquata(ifirstt(im),3) .ne. ifirstm(im)-1+nghanchor) then
            write (iout,1005) 'main anchor',ifirstm(im)-1+nghanchor,
     -        'first',im
            inperr=inperr+1
          end if
          if (nwgtry .gt. 1 .and.
     -        iquata(ilastt(im),3) .ne. ifirstm(im)+nghanchor) then
            write (iout,1005) 'replacement',ifirstm(im)+nghanchor,
     -        'last',im
            inperr=inperr+1
          end if
          if (itorgrp(ifirstt(im)) .ne. itorgrp(ilastt(im))) then
            write (iout,1004) im
            inperr=inperr+1
          end if
        end do
        ang0i=0.0
        ang0g=0.0
      end if
      if (nwitry .gt. 1) taanchor=dihang(itanchor)
      angincradi=pi2/nwitry
      angincradg=pi2/nwgtry
      if (anginc .gt. 0) then
        ang0i=angincradi*anginc
        ang0g=angincradg*anginc
      end if
      do im=1,nmolwid
        ifatw=ifirstm(im)
        ifatw1=ifatw-1
        ilatw=ilastm(im)
        call arrdiff(c2x,c(1,ighanchor(nghanchor+1)),
     -    c(1,ighanchor(nghanchor)),3)
        call arrdiff(c23,c(1,ifatw1+nghanchor+1),c(1,ifatw1+nghanchor),
     -    3)
        facins(im)=sqrt(sclprd(c23,c23)/sclprd(c2x,c2x))
        nta=ilastt(im)-ifirstt(im)+1
        iti=ifirstt(im)
        itg=ilastt(im)
        do igi=1,nwitry
          if (im .eq. 1) then
c           Get the constant parts of the ligand energies
            torsenlig(igi)=0.d0
            egstfx(igi)=0.d0
            elljes(igi)=0.d0
            elljes14(igi)=0.d0
            if (nwitry .gt. 1) then
c             Generate the ligand conformation
              dihang(itanchor)=(igi-1)*angincradi+ang0i
              call gentor(itanchor,itanchor,dihang,c,itangindx,
     -          iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -          bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -          #TR,#ST)
              call diheng(torsenlig(igi),itorgrp(itanchor),torsensumo,
     -          torsen,torsennew,iop(127))
            end if
C@TN            call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,
C@TN     -        nbits,#NL,ifirstm(imanchor),ilastm(imanchor),iclsltt,
C@TN     -        qslteps,esf14,vdwf14,elljes(igi),elljes14(igi),l2,iuuon)
            if (nsttm .gt. nmolwid+1 .and. iop(57)+iop(58) .eq. 0) then
C@TN              call esltsltt(c,ighanchor,nstfm+1,nsttm,ifirstm,ilastm,
C@TN     -          ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,
C@TN     -          1,ngrpanchor,ifgrpanchor,ilgrpanchor,1,nghanchor+1,
C@TN     -          nghanchor+1,mapbitu,#UW,#ST,nbits,istf,nstta,
C@TN     -          iclsltt,qslteps,imanchor,0,0,cplx,cplx,gsumx,gsumx,
C@TN     -          igrslt,igrcnt,molcnt,crmpmf,gbenew,gbernew,gsumself,
C@TN     -          iop(5),iop(65),0,indexx,ivopt,riijjv,cgs,cutuus,
C@TN     -          iop(127),200,10)
              do ia=1,nghanchor+1
                egstfx(igi)=egstfx(igi)+gbernew(ighanchor(ia))
              end do
              if (idebug(58) .gt. 1) write (iout,1008) cutuus,
     -          (gbernew(ighanchor(ia)),ia=1,nghanchor+1)
            end if
            eintralig(igi)=elljes(igi)+elljes14(igi)+torsenlig(igi)
            if (idebug(58) .gt. 0) write (iout,1009) igi,torsenlig(igi),
     -        elljes(igi),elljes14(igi),egstfx(igi),eintralig(igi)
          end if
          do k=1,nghanchor
            call trnsfr(c(1,ifatw1+k),c(1,ighanchor(k)),3)
          end do
c         Generate the replacement atom (the end of the torsion bond)
          do k=1,3
            c(k,ifatw+nghanchor)=c(k,ifatw-1+nghanchor)+
     -        c2x(k)*facins(im)
          end do
          do igg=1,nwgtry
            ig=(igi-1)*nwitry+igg
            if (nta .eq. 2) then
              dihang(iti)=(igi-1)*angincradi+ang0i
              dihang(itg)=(igg-1)*angincradg+ang0g
            else if (nwitry .gt. 1) then
              dihang(iti)=(igi-1)*angincradi+ang0i
            else
              dihang(itg)=(igg-1)*angincradg+ang0g
            end if
            if (iop(105) .gt. 0)
     -        call inittor(ifirstt(im),ilastt(im),c,itangindx,
     -          iprecursor,nrot,irotlist,irotlinc,bond,bond2,angle,
     -          cangle,bond13,bond12,cangle13,bondf,bondproj,
     -          xfac13,xfac12,cangle40,bond420,idebug(23),iout,
     -          #TR,#ST)
            call gentor(ifirstt(im),ilastt(im),dihang,c,itangindx,
     -        iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -        bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -        #TR,#ST)
C@TN            call intrasums(c,nneig3,nneig4,ineig,mapbitu,#UW,#ST,
C@TN     -        nbits,#NL,ifirstm(im),ilastm(im),iclsltt,qslteps,
C@TN     -        esf14,vdwf14,eiljes,eiljes14,l2,iuuon)
c           eiljes+eiljes14 is the total intra energy of the fragment molecule
c           made up by the anchor and replacement atoms
c           Calculate the NB energy between the rotating part & the non-anchors
            eiljesnb=0.d0
            do iia=1,nnoanchor
              ia=noanchor(iia)
              do jja=1,nnexttormov(itangindx(iti))
                ja=irotlist(irotlinc(iti)+jja)
                rij2=arrdist(c(1,ia),c(1,ja))
                rij6=rij2*rij2*rij2
                rij12=rij6*rij6
C@NR                rij=sqrt(rij2)
                eng=c12tt(iclsltt(ia),iclsltt(ja))/rij12-
     -            c6tt(iclsltt(ia),iclsltt(ja))/rij6+
C@1R     -            (qslt(ia)*qslt(ja)/rij2)
C@NR     -            (qslt(ia)*qslt(ja)/rij)
C@RF     -            *(1.0+rij*rij2*rccon)
C@DD     -            *dd_ms_inter(rij)
                eiljesnb=eiljesnb+eng
              end do
            end do
            call diheng(torsensumn,itorgrp(ifirstt(im)),torsensumo,
     -        torsen,torsennew,iop(127))
            eintraghost(ig,im)=torsensumn+eiljes+eiljes14+eiljesnb
            if (idebug(58) .gt. 0) write (iout,1001) im,igi,igg,ig,
     -        torsensumn,eiljes,eiljes14,eiljesnb,eintraghost(ig,im)
          end do
        end do
      end do
      if (nwitry .gt. 1) then
c       Restore the ligand atoms that were rotated around
        dihang(itanchor)=taanchor
        call gentor(itanchor,itanchor,dihang,c,itangindx,
     -    iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -    bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -    #TR,#ST)
        do it=ifirstt(1),ilastt(nmolwid)
          dihang(it)=0.0
        end do
        do im=1,nmolwid
          call gentor(ifirstt(im),ilastt(im),dihang,c,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -      bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -      #TR,#ST)
        end do
      end if
      if (idebug(127) .gt. 0)
     -   write (iout,6433) (ia,(c(k,ia),k=1,3),ia=1,ilastm(nmolwid))
      return
1001  format(' INITADDWIDOM ghost',i3,' grids',2i4,i5,' Torsion=',e13.5,
     -  ' ljes,14,NB=',e13.5,2e14.5,' ei=',e12.5)
1002  format(' ***** PROGRAM ERROR: anchor (',i4,'), non-anchor (',
     -  i4,') and dropped (',i4,') atoms do not sum up to the atoms ',
     -  'in the ligand (',i5,')')
1003  format(1x,a,' atoms:',(25i5))
1004  format(' ***** ERROR: Torsions on Widom group',i3,' do not fall',
     -  ' into the same torsion group')
1005  format(' ***** ERROR: ',a,' atom ',i4,' is not the root of ',
     -  ' the ',a,' torsion on ghost',i3)
1006  format(' INITADDWIDOM',i3,' anchor groups limits:',10(2i3,2x))
1007  format(' ***** ERROR: no torsion is defined for the ligand atom',
     -  ' to be replaced')
1008  format(' cutuus=',f10.3,/,(' gbernew=',5e13.5))
1009  format(' INITADDWIDOM ligand grid',i4,' Torsion=',e13.5,
     -  ' elljes,14=',2e13.5,' egstfx=',e13.5,' ei=',e13.5)
1010  format(' ***** ERROR: all atoms of a flexible ligand have to be ',
     -  'anchor atoms')
1011  format(' ***** ERROR:',i4,'th anchor atom (',i6,') is a duplicte')
6433  format(' INITADDWIDOM Widom atoms ',i4,'=',3f10.5)
      end
      subroutine accuaddwidom(c,crm,nmolec,ctslts,
     -  cutuus,edgex2,edgey2,edge2,ncnfpx,ifail)
c#    MMC routine 313/b lstmod: 03/03/08
c*****Accumulate Widom method calculation for adding a functional group
      dimension c(3,#NA),crm(3,#MO)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /liga/ ligand_start_molecule,last_slt_mol_g
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /frind2/ crat6,crat1
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /tdstate/ press,pressv,ba,temp,beta
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv(3,#UV),ab(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension c2x(3)
C@TN      dimension crmpmf(3)
      dimension cplx(3),crmx(3)
      dimension gsumx(3),egsltx(#GX)
      real*8 egslt,egslv,egslvx,egsltx,gsumx,gsum12,exparg,expargslt,
     -  expargslv
C@TN      real*8 gsumself
      data taanchor /0.0/
      crat1=1.0
      crat6=1.0
c     Calculate the solute-solvent energy of the anchor and replacement atoms
      egslvx=0.d0
      iaanchor=ighanchor(nghanchor+1)
      iganchor=igrpf(iaanchor)
      imanchor=iamolslt(iaanchor)
      do ia=1,nghanchor+1
        do is=2,nmolec
          egslvx=egslvx+eslt(is,riijj,iop(2),ipfgr(iganchor),
     -      ighanchor(ia),ighanchor(ia),nstsvgr(iganchor),
     -      nslvggr(iganchor),c(1,molcnt(imanchor)),igrcnt(imanchor),
     -      imanchor,ioppbc,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
        end do
      end do
      if (idebug(58) .gt. 0) write (iout,1005) nghanchor,nmolec,egslvx
c     Establish the positions of the FCGs  first three atoms
      call arrdiff(c2x,c(1,ighanchor(nghanchor+1)),
     -  c(1,ighanchor(nghanchor)),3)
      angincradi=pi2/nwitry
      angincradg=pi2/nwgtry
      if (nwitry .gt. 1) taanchor=dihang(itanchor)
      do im=1,nmolwid
        ifatw=ifirstm(im)
        ilatw=ilastm(im)
        natw=ilatw-ifatw+1
        igr=igrpf(ifatw)
c       Copy the anchor atoms from the ligand
        do k=1,nghanchor
          call trnsfr(c(1,ifatw-1+k),c(1,ighanchor(k)),3)
        end do
c       Generate the replacement atom (the end of the torsion bond)
        do k=1,3
          c(k,ifatw+nghanchor)=c(k,ifatw-1+nghanchor)+c2x(k)*facins(im)
        end do
c       Generate the rest of the fc group at various angles
        nta=ilastt(im)-ifirstt(im)+1
        iti=ifirstt(im)
        itg=ilastt(im)
        do igi=1,nwitry
          if (im .eq. 1) then
c           Generate the ligand conformation
            if (nwitry .gt. 1) then
              dihang(itanchor)=(igi-1)*angincradi+ang0i
              call gentor(itanchor,itanchor,dihang,c,itangindx,
     -          iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -          bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -          #TR,#ST)
            end if
c           Calculate the solute-solute energy of the anchor & replacement atoms
            if (nsttm .gt. nmolwid+1 .and. iop(57)+iop(58) .gt. 0) then
C@TN              call esltsltt(c,ighanchor,nstfm+1,nsttm,ifirstm,ilastm,
C@TN     -          ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,
C@TN     -          1,ngrpanchor,ifgrpanchor,ilgrpanchor,1,nghanchor+1,
C@TN     -          nghanchor+1,mapbitu,#UW,#ST,nbits,istf,nstta,
C@TN     -          iclsltt,qslteps,imanchor,0,0,cplx,cplx,gsumx,gsumx,
C@TN     -          igrslt,igrcnt,molcnt,crmpmf,gbenew,gbernew,gsumself,
C@TN     -          iop(5),iop(65),0,indexx,ivopt,riijjv,cgs,cutuus,
C@TN     -          iop(127),200,10)
              egsltx(igi)=0.d0
              do ia=1,nghanchor+1
                egsltx(igi)=egsltx(igi)+gbernew(ighanchor(ia))
              end do
            else
              egsltx(igi)=egstfx(igi)
            end if
          end if
          do igg=1,nwgtry
            ig=(igi-1)*nwitry+igg
            if (nta .eq. 2) then
              dihang(iti)=(igi-1)*angincradi+ang0i
              dihang(itg)=(igg-1)*angincradg+ang0g
            else if (nwitry .gt. 1) then
              dihang(iti)=(igi-1)*angincradi+ang0i
            else
              dihang(itg)=(igg-1)*angincradg+ang0g
            end if
            call gentor(ifirstt(im),ilastt(im),dihang,c,itangindx,
     -        iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -        bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -        #TR,#ST)
            egslv=0.d0
            do is=2,nmolec
              egslv=egslv+eslt(is,riijj,iop(2),ipfgr(igr),ifatw,ilatw,
     -          nstsvgr(igr),nslvggr(igr),c(1,molcnt(im)),igrcnt(im),
     -          im,ioppbc,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
            end do
            if (idebug(58) .gt. 0) write (iout,1006) im,egslv
C@DB            if (idebug(58) .gt. 3) then
C@DB              gsum12=0.d0
C@DB              igr=igrpf(ifirstm(im))
C@DB              do ia=ifirstm(im),ilastm(im)
C@DB                do is=2,nmolec
C@DB                  gsum12=gsum12+eslt(is,riijj,iop(2),ipfgr(igr),ia,ia,
C@DB     -             nstsvgr(igr),nslvggr(igr),c(1,molcnt(im)),igrcnt(im),
C@DB     -             im,ioppbc,iop(43),c,crm,ctslts,edgex2,edgey2,edge2)
C@DB                end do
C@DB              end do
C@DB              write (iout,1004) im,egslv,gsum12
C@DB            end if
            egslt=0.d0
            if (nsttm .gt. nmolwid+1) then
              call zeroitd(gbernew(ifatw),natw)
              if (imanchor .gt. nmolwid+1)
     -          call esltsltg(c,nmolwid+1,imanchor-1,ifirstm,ilastm,
     -            ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbenew,gbernew,
     -            0,istf,nstta,iclsltt,qslteps,im,0,0,gsum12,0,0,cplx,
     -            cplx,gsumx,gsumx,igrcnt,molcnt,crmx,iop(5),iop(65),
     -            indexx,ivopt,riijjv,cgs,cutuus,iop(127))
              if (imanchor .lt. nsttm)
     -          call esltsltg(c,imanchor+1,nsttm,ifirstm,ilastm,
     -            ifgrmolslt,ilgrmolslt,ifgrslt,ilgrslt,gbenew,gbernew,
     -            0,istf,nstta,iclsltt,qslteps,im,0,0,gsum12,0,0,cplx,
     -            cplx,gsumx,gsumx,igrcnt,molcnt,crmx,iop(5),iop(65),
     -            indexx,ivopt,riijjv,cgs,cutuus,iop(127))
              do ia=ifatw,ilatw
                egslt=egslt+gbernew(ia)
              end do
              if (idebug(58) .gt. 2) write (iout,1003)
     -          cutuus,ctslts,(gbernew(ia),ia=ifatw,ilatw)
            end if
            ew=eintraghost(ig,im)-eintralig(igi)+(egslt-egsltx(igi))+
     -        (egslv-egslvx)
            if (idebug(58) .gt. 1) write (iout,1001)
     -        im,ig,igi,igg,eintraghost(ig,im),egslt,egslv,
     -        eintralig(igi),egsltx(igi),egslvx,ew
            if (ewmin(ig,im) .ge. ew) ewmin(ig,im)=ew
            if (ewmax(ig,im) .le. ew) ewmax(ig,im)=ew
            exparg=dble((ew-ew0(im))*beta)
            if (exparg .lt. dblnmx .and. -exparg .lt. dblnmx)
     -        expesum(ig,im)=expesum(ig,im)+dexp(-exparg)
c           Collect information on contributions
            if (egsltmin(im) .gt. egslt) egsltmin(im)=egslt
            if (egslvmin(im) .gt. egslv) egslvmin(im)=egslv
            if (egsltxmin .gt. egsltx(igi)) egsltxmin=egsltx(igi)
            if (egslvxmin .gt. egslvx) egslvxmin=egslvx
            if (nsttm .gt. nmolwid+1) then
              expargslt=dble((egslt-egsltx(igi))*beta)
              if (expargslt .lt. dblnmx .and. -expargslt .lt. dblnmx)
     -          expsltsum(im)=expsltsum(im)+dexp(-expargslt)
            else
              expargslt=0.d0
            end if
            expargslv=dble((egslv-egslvx)*beta)
            if (expargslv .lt. dblnmx .and. -expargslv .lt. dblnmx)
     -        expslvsum(im)=expslvsum(im)+dexp(-expargslv)
            expargslt=exparg-expargslt-expargslv
            if (expargslt .lt. dblnmx .and. -expargslt .lt. dblnmx)
     -        expintrasum(im)=expintrasum(im)+dexp(-expargslt)
            expargslv=exparg-expargslv
            if (expargslv .lt. dblnmx .and. -expargslv .lt. dblnmx)
     -        expnoslvsum(im)=expnoslvsum(im)+dexp(-expargslv)
          end do
        end do
      end do
      ifail=0
      do im=1,nmolwid
        ewminx=ewmin(1,im)
        do ig=2,nwitry
          if (ewmin(ig,im) .lt. ewminx) ewminx=ewmin(ig,im)
        end do
        if (-(ewminx-ew0(im))*beta .gt. dblnmx) then
          ew0new=ewminx-(20.0-dblnmx)/beta
          write (iout,1002) im,ncnfpx,ew0new,ewminx
C@ND          call datprt(2)
          ifail=1
        end if
      end do
      if (nwitry .gt. 1) then
c       Restore the ligand atoms that were rotated around
        dihang(itanchor)=taanchor
        call gentor(itanchor,itanchor,dihang,c,itangindx,
     -    iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -    bondf,bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -    #TR,#ST)
      end if
      if (idebug(58) .gt. 0) call disfinaddwidom(ncnfpx,molcnt)
      return
1001  format(' ACCUADDWIDOM ghost',i3,' grid',i4,' igi,igg=',2i4,/,
     -  ' G eintra,eslt,eslv=',3e12.5,' L: eintra,esltx,eslvx=',3e12.5,
     -  ' de=',e12.5)
1002  format(' ***** ERROR: -(insertion energy-ew0)/kT is too large ',
     -  'for ghost group ',i2,' Structure ',i9,' Restart with ',
     -  'decreased ew0 after FREE ADDW',/,7x,'Suggested ew0 value=',
     -  f10.4,' (based on the lowest energy found,',f10.4,' kcal/mol)')
1003  format(' cutuus,ctslts=',2f10.3,/,(' gbernew=',5e13.5))
C@DB1004  format(' ACCUADDWIDOM ghost',i3,' eslvg check eslvg=',
C@DB     -  e12.5,' check=',e12.5)
1005  format(' ACCUADDWIDOM nganchor,nmolec=',i4,i6,' eslvx=',e12.5)
1006  format(' ACCUADDWIDOM im=',i4,' eslvg=',e12.5)
      end
      subroutine disfinaddwidom(nconf,molcnt)
c#    MMC routine 313/c lstmod: 05/19/05
c*****Prepare Widom method calculation results
      dimension molcnt(#MM)
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      common /tdstate/ press,pressv,ba,temp,beta
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /option/ iop(200),idebug(200)
      dimension freng(#GX)
      real*8 eesum
      write (iout,1000)
      ndv=nconf*nwitry*nwgtry
      do im=1,nmolwid
        eesum=0.d0
        call zeroit(freng,nwitry*nwgtry)
        do ig=1,nwitry*nwgtry
          eesum=eesum+expesum(ig,im)
          freng(ig)=freng(ig)+expesum(ig,im)
        end do
        eesum=eesum/dfloat(ndv)
        frengbr=0.0
        if (eesum .gt. 0.d0) frengbr=ew0(im)-dlog(eesum)/beta
        write (iout,1001) fcglab(molcnt(im)),frengbr,nconf
        write (iout,1002) fcglab(molcnt(im)),egsltmin(im),egslvmin(im)
        sltsum=0.0
        if (expsltsum(im) .gt. 0.0) sltsum=-dlog(expsltsum(im)/ndv)/beta
        slvsum=0.0
        if (expslvsum(im) .gt. 0.0) slvsum=-dlog(expslvsum(im)/ndv)/beta
        write (iout,1003) fcglab(molcnt(im)),sltsum,slvsum
        sltsum=0.0
        if (expintrasum(im) .gt. 0.0)
     -    sltsum=-dlog(expintrasum(im)/ndv)/beta
        slvsum=0.0
        if (expnoslvsum(im) .gt. 0.0)
     -    slvsum=-dlog(expnoslvsum(im)/ndv)/beta
        write (iout,1004) fcglab(molcnt(im)),slvsum,sltsum
      end do
      write (iout,1005) egsltxmin,egslvxmin
      return
1000  format(/,' Widom method excess free energy calculation',/,
     -  ' ///// NOTE: the calculated free energy may not include the ',
     -  'intramolecular contributions of the anchor atoms since those',
     -  ' cancel',/)
1001  format(' Ghost group ',a,': Free energy of changing to the ',
     -  'ghost group=',e12.5,'  Number of configurations used=',i6)
1002  format(' Ghost group ',a,': Lowest solute and solvent energies=',
     -  e12.5,e13.5)
1003  format(' Ghost group ',a,': Free energy contributions from the ',
     -  'solute and solvent=',e12.5,e13.5)
1004  format(' Ghost group ',a,': Free energy contribution without the',
     -  ' solvent=',e12.5,' Intramolecular solute contribution=',e12.5)
1005  format(' Lowest ligand solute and solvent energies=',e12.5,e13.5)
      end
      subroutine initchim(nmolec,iout)
c#    MMC routine 314 lstmod: 12/21/05
c*****Initialize chimera method calculation
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /option/ iop(200),idebug(200)
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
C@NN      do j=1,nmolmp
C@NN        do i=1,nmolec
C@NN          mapbitv(j,i)=iallon
C@NN        end do
C@NN      end do
      if (iop(28) .le. 3) then
        kdim=iop(28)
        grid(kdim)=gredge(kdim)/float(ngrid(kdim))
        grid2(kdim)=grid(kdim)/2.0
        ngrids=ngrid(kdim)
      else
        incrgrid=nstfg
        ngrids=nsttg-incrgrid+1
        call checkdim(ifail,iout,inperr,'GX',ngrids,1,1,0)
        rnearchim2=rnearchim**2
      end if
      do im=1,nmolwid
        do ig=1,ngrids
          rncavx(ig)=0.d0
          ewmin(ig,im)=1.E+30
          ewmax(ig,im)=-1.E+30
          expesum(ig,im)=0.d0
        end do
      end do
      return
      end
      subroutine accuchim(c,crm,nmolec,nconf,ctslvs,cutuus,
     -  edgex2,edgey2,edge2)
c#    MMC routine 315 lstmod: 12/22/05
c*****Accumulate chimera method calculation
      dimension c(3,#NA),crm(3,#MO)
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /frind2/ crat6,crat1
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 gbenew,gbeold,gbernew,gberold,torsen,gbeg,torsennew
      common /parenst/ gbenew(#ST),gbeold(#ST),gbernew(#ST),
     -  gberold(#ST),torsen(#TR),torsennew(#TR),gbeg
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv(3,#UV),ab(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      dimension cg(3),ort(3,3),crmx(3),gsumx(3),cpl0(3),cpl1(3),rand(1)
      real*8 egslt,egslv,gsumx,gsum12,eo,en,escn,exparg
      data cpl0 /3*0.0/,cpl1 /3*0.0/,eo /0.d0/
      crat1=1.0
      crat6=1.0
      if (iop(160) .gt. 0) call zeroitd(tesi,nmolec)
      do iw=2,nmolec
        call trnsfr(cg,crm(1,iw),3)
        call solvinout(inout,cg,edgelgr,edgergr)
        if (inout .eq. 1) then
          if (iop(28) .eq. 4) then
            if (rijpso(iw) .le. rnearchim2) then
              ix=igrslt(ipxo(iw))-incrgrid
            else
              call randpx(1,rand)
              if (rand(1) .le. pfarchim) then
                ix=ngrids
              else
                inout=0
                ix=0
              end if
              if (idebug(58) .gt. 1) then
                rn2=100000.0
                do ia=nstfa+1,nstta
                  if (ianslt(ia) .gt. 1) then
                    r2=arrdist(c(1,ia),crm(1,iw))
                    if (r2 .lt. rn2) then
                      rn2=r2
                      ipxtest=ia
                    end if
                  end if
                end do
                write (iout,1002) iw,ipxo(iw),
     -            rijpso(iw),ix,inout,ipxtest,rn2
              end if
            end if
          end if
        end if
        if (inout .eq. 1) then
          if (iop(28) .le. 3) then
            ix=(cg(iop(28))-edgelgr(iop(28)))/grid(iop(28))+1
          end if
          rncavx(ix)=rncavx(ix)+nwitry
          if (iop(160) .eq. 0) then
            ewref=tesi(iw)
          else
            call engcha(en,eo,escn,iw,tesi,c,crm,nmolec)
            ewref=en
          end if
          do im=1,nmolwid
            ifatw=ifirstm(im)
            ifatwc=ifatw
            if (ifdummy(im) .eq. 1) ifatwc=ifatwc-1
            ilatw=ilastm(im)
            natw=ilatw-ifatw+1
            natwc=ilatw-ifatwc+1
            do it=1,nwitry
              call putmol(natwc,rlcslt(1,ifatwc),cg,c(1,ifatwc),ort)
              if (idebug(58) .gt. 1) write (iout,1000)
     -          cg,(ia,(c(k,ia),k=1,3),ia=ifatwc,ilatw)
              egslv=0.d0
              do is=2,iw-1
                egslv=egslv+eslt(is,riijj,iop(2),ipfgr(im),ifatw,ilatw,
     -            nstsvgr(im),nslvggr(im),c(1,molcnt(im)),igrcnt(im),im,
     -            ioppbc,iop(43),c,crm,ctslvs,edgex2,edgey2,edge2)
              end do
              do is=iw+1,nmolec
                egslv=egslv+eslt(is,riijj,iop(2),ipfgr(im),ifatw,ilatw,
     -            nstsvgr(im),nslvggr(im),c(1,molcnt(im)),igrcnt(im),im,
     -            ioppbc,iop(43),c,crm,ctslvs,edgex2,edgey2,edge2)
              end do
              call zeroitd(gbernew(ifatw),natw)
              call esltsltg(c,nmolwid+1,nsttm,ifirstm,ilastm,ifgrmolslt,
     -          ilgrmolslt,ifgrslt,ilgrslt,gbenew,gbernew,1,istf,nstta,
     -          iclsltt,qslteps,im,0,0,gsum12,0,0,cpl1,cpl0,gsumx,gsumx,
     -          igrcnt,molcnt,crmx,iop(5),iop(65),indexx,ivopt,riijjv,
     -          cgs,cutuus,iop(127))
              egslt=0.d0
              do ia=ifatw,ilatw
                egslt=egslt+gbernew(ia)
              end do
              ew=egslt+egslv
              if (idebug(58) .gt. 1)
     -          write (iout,1001) iw,im,ix,egslt,egslv,ew,ewref
              if (ewmin(ix,im) .ge. ew) ewmin(ix,im)=ew
              if (ewmax(ix,im) .le. ew) ewmax(ix,im)=ew
              exparg=dble((ew-ewref-ew0(im))*beta)
              if (exparg .lt. dblnmx .and. -exparg .lt. dblnmx)
     -          expesum(ix,im)=expesum(ix,im)+exp(-exparg)
            end do
          end do
        end if
      end do
      if (idebug(58) .gt. 0) call disfinchim(nconf,molcnt,ifgrslt)
      return
1000  format(' ACCUCHIM cg=',3f10.5,' cghost=',/,(i4,3f10.5,i6,3f10.5))
1001  format(' ACCUCHIM ',i6,2i3,' eslt,eslv,ew,ewref=',4e13.5)
1002  format(' ACCUCHIM iw=',i5,' ipxo=',i5,' rijpso=',f10.2,
     -  ' ix,inout=',i5,i2,' ipxtest=',i5,' r2test=',f10.2)
      end
      subroutine disfinchim(nconf,molcnt,ifgrslt)
c#    MMC routine 316 lstmod: 01/10/06
c*****Prepare Widom method calculation results
      dimension molcnt(#MM),ifgrslt(#GR)
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /limgrid/ edgelgr(3),edgergr(3),gridcent(3),nmolinoutgr(2),
     -  ncrossin,ncrossout,molinoutgr(#MO)
      common /tdstate/ press,pressv,ba,temp,beta
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      character*1 lxyz
      common /names/ lxyz(3)
      common /option/ iop(200),idebug(200)
      dimension rx(#GX),freng(#GX),freng1(#GX),avnslv(#GX)
      real*8 eesum,eesuml,eesumr,rnls,rnrs
      character*4 labres
      call zeroit(freng1,ngrids)
      frengb1=0.0
      if (iop(28) .le. 3) then
c       Distance grid
        do im=1,nmolwid
          eesum=0.d0
          rns=0.d0
          write (iout,1000) im,fcglab(molcnt(im)),nconf
          call zeroit(freng,ngrids)
          nbulkgr=ngrids/10
          eesuml=0.d0
          eesumr=0.d0
          rnls=0.d0
          rnrs=0.d0
          do ix=1,ngrids
            rx(ix)=edgelgr(iop(28))+ix*grid(iop(28))-grid(iop(28))/2.0
            if (ix .le. nbulkgr) then
              eesuml=eesuml+expesum(ix,im)
              rnls=rnls+rncavx(ix)
            else if (ix .ge. ngrid(iop(28))-nbulkgr) then
              eesumr=eesumr+expesum(ix,im)
              rnrs=rnrs+rncavx(ix)
            end if
            eesum=eesum+expesum(ix,im)
            rns=rns+rncavx(ix)
            avnslv(ix)=rncavx(ix)/(nconf*nwitry)
            if (rncavx(ix) .gt. 0.d0) then
              freng(ix)=ew0(im)
              if (expesum(ix,im) .gt. 0.d0)
     -          freng(ix)=ew0(im)-dlog(expesum(ix,im)/rncavx(ix))/beta
              write (iout,1001) ix,rx(ix),avnslv(ix),freng(ix),
     -          freng(ix)-freng1(ix),ewmin(ix,im),ewmax(ix,im)
            else
              write (iout,1002) ix,rx(ix)
              freng(ix)=0.0
            end if
          end do
          frengbl=ew0(im)-dlog(eesuml/rnls)/beta
          frengbr=ew0(im)-dlog(eesumr/rnrs)/beta
          frengb=ew0(im)-dlog(eesum/rns)/beta
          write (iout,1003) lxyz(iop(28)),rx(iop(28)),lxyz(iop(28)),
     -      rx(ngrid(iop(28))),frengb
          write (iout,1003) lxyz(iop(28)),rx(iop(28)),lxyz(iop(28)),
     -      rx(nbulkgr),frengbl
          write (iout,1003) lxyz(iop(28)),rx(ngrid(iop(28))-nbulkgr),
     -      lxyz(iop(28)),rx(ngrid(iop(28))),frengbr
          call plot(rx,freng,avnslv,ngrid(iop(28)),0.0,0.0,0.0,0.0,50,
     -      99,4,48,38,
     -      '*: -kT ln<exp(-(e-eW)/kT)> (kcal/mol); O: <nslv>',0,0,0)
          if (im .eq. 1) call trnsfr(freng1,freng,ngrids)
        end do
      else
c       Residue-proximity based grid
        rnavfs=0
        rns=0
        do ix=1,ngrids
          do im=1,nmolwid
            avnslv(ix)=rncavx(ix)/(nconf*nwitry)
            rns=rns+rncavx(ix)
            if (ix .eq. ngrids) then
              labres='BULK'
            else
              labres=labslt(1,ifgrslt(ix+incrgrid))
              if (im .eq. 1) rnavfs=rnavfs+avnslv(ix)
            end if
            if (expesum(ix,im) .gt. 0.d0) then
              freng(ix)=ew0(im)-dlog(expesum(ix,im)/rncavx(ix))/beta
              write (iout,1004) ix,labres,avnslv(ix),
     -         im,fcglab(molcnt(im)),freng(ix),
     -          freng(ix)-frengb1,ewmin(ix,im),ewmax(ix,im)
            end if
            if (im .eq. 1) frengb1=freng(ix)
          end do
        end do
        do im=1,nmolwid
          eesum=0.d0
          do ix=1,ngrids
            eesum=eesum+expesum(ix,im)
          end do
          frengb=ew0(im)-dlog(eesum/rns)/beta
          if (im .eq. 1) frengb1=frengb
          write (iout,1005) rnavfs,avnslv(ngrids)+rnavfs,frengb,
     -      frengb-frengb1
        end do
      end if
      return
1000  format(' Chimera method excess free energy calculation for ',
     -  'ghost molecule ',i2,' (',a,')  Number of configurations used=',
     -  i6)
1001  format(i5,' r=',f8.3,' <nslv>=',f8.2,' pseudo free eng=',e12.5,
     -  ' PSE relative to mol.1=',e12.5,' ewmin=',e12.5,' emax=',e12.5)
1002  format(i5,' r=',f8.3,' <nslv>=0')
1003  format(' In the range ',a,'=',f8.2,' to ',a,'=',f8.2,
     -  ' excess free energy=',e12.5,' kcal/mol')
1004  format(i5,' (',a,') <nslv>=',f8.1,' Ghost ',i2,' (',a,') PS FE=',
     -  e12.5,' PS FE - PS FE(1)=',e12.5,' ewmin=',e10.3,' emax=',e10.3)
1005  format(' < nslv(shell)>=',f8.2,' <nslv(tot)=',f8.2,' Combined ',
     -  'data pseudo free eng=',e12.5,' PSE relative to mol.1=',e12.5)
      end
      subroutine accumulate(uusfac,loopmark)
c#    MMC routine 317 lstmod: 01/29/09
c*****Collect main energy averages
      real*8 uusfac
      character*1 loopmark
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 ew0nb,teslt1,teslt1n,uwnb,uwnbn,uwnbmin,uwnbmax,
     -  etsincr
      common /nonboltz/ ew0nb,teslt1,teslt1n,
     -  uwnb,uwnbn,uwnbmin,uwnbmax,etsincr,tornbfac,repnbfac,slttmp,
     -  sltsltfac,signinfac,tsexp,tsfac
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 efieldst0,efieldmst
      common /fieldenergy/ efieldst0,efieldmst(#MM),
     -  efieldsv(#MO),esltfldo(#ST),esltfldn(#ST)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /torauc/ nmctorauc,ntorsaved,ntaucprint,nauc(#AU),
     -  tauc_timestep,tauc_min,torsave(#AU,#TR),auctor(#AU,#TR)
      common /expfit_tau/ ntaumax,ntaufit,aucsaved(#AU),ixt(#AU)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 virsum,uusf,uswsum,dmult,dnumsolv
      dnumsolv=nmolec-1
      uusfac=uuscor*uwnb*uwcplo
      uswsum=ucsmmv+ucsmid+ucsmvv
      uusf=dmax1(1.d0,uusfac)
      if (etoto .lt. dpmx/uusf) then
        usum=usum+etoto*uusfac
      end if
      if (etoto .lt. dpsqmx) then
        if (etoto*etoto .lt. dpmx/uusf)
     -    uusum=uusum+etoto*etoto*uusfac
      end if
      if (nstta .gt. 0) then
        uslt=uslt+tesi(1)*uusfac
        uuslt=uuslt+tesi(1)*tesi(1)*uusfac
        do im=1,nsttm
          uintranb(im)=uintranb(im)+eintranb(im)*uusfac
          uinter(im)=uinter(im)+gbuupd(im)*uusfac
          um14(im)=um14(im)+em14(im)*uusfac
          uuintranb(im)=uuintranb(im)+eintranb(im)**2*uusfac
          uuinter(im)=uuinter(im)+gbuupd(im)**2*uusfac
          uum14(im)=uum14(im)+em14(im)**2*uusfac
        end do
        tscum(1)=tscum(1)+tss12*uusfac
        tscum(2)=tscum(2)-tss6*uusfac
        tscum(3)=tscum(3)+tss1*uusfac
        if (iop(57)+iop(58) .gt. 0 .or. iop(30) .eq. 7) then
          uttnb=uttnb+ettnbo*uusfac
          uuttnb=uuttnb+ettnbo*ettnbo*uusfac
          uinnb=uinnb+einnbo*uusfac
          uuinnb=uuinnb+einnbo*einnbo*uusfac
        end if
        if (ntang .gt. 0) then
          uslt14=uslt14+es14o*uusfac
          uuslt14=uuslt14+es14o*es14o*uusfac
          uslttor=uslttor+eslttoro*uusfac
          uuslttor=uuslttor+eslttoro*eslttoro*uusfac
          if (itormov .gt. 0) then
            do id=ifdhgrlst(itormov),ildhgrlst(itormov)
              contrib=circadd(ta0(id),dihango(id),-1.0)
              tangav(id)=tangav(id)+(uswsum-dlastrot(id))*contrib
              tang2av(id)=tang2av(id)+(uswsum-dlastrot(id))*contrib**2
              sinsum(id)=sinsum(id)+
     -            sin(dihango(id))*(uswsum-dlastrot(id))
              cossum(id)=cossum(id)+
     -          cos(dihango(id))*(uswsum-dlastrot(id))
              ig=#TD.0*(dihango(id)+pi)/pi2+1
              if (ig .lt. 1) ig=1
              if (ig .gt. #TD) ig=#TD
              itangd(ig,id)=itangd(ig,id)+(nmc-lastrot(id))/nsltfreq
              dtangd(ig,id)=dtangd(ig,id)+(uswsum-dlastrot(id))
              lastrot(id)=nmc
              dlastrot(id)=uswsum
              if (loopmark .eq. 'L') then
c               Update loopmembers as well
                do itl=1,6
                  it=looplist(itl,id)
                  contrib=circadd(ta0(it),dihango(it),-1.0)
                  mult=nmc-lastrot(it)
                  dmult=(uswsum-dlastrot(it))
                  tangav(it)=tangav(it)+dmult*contrib
                  tang2av(it)=tang2av(it)+dmult*contrib**2
                  sinsum(it)=sinsum(it)+sin(dihango(it))*dmult
                  cossum(it)=cossum(it)+cos(dihango(it))*dmult
                  ig=#TD.0*(dihango(it)+pi)/pi2+1
                  if (ig .lt. 1) ig=1
                  if (ig .gt. #TD) ig=#TD
                  itangd(ig,it)=itangd(ig,it)+mult/nsltfreq
                  dtangd(ig,it)=dtangd(ig,it)+dmult
                  lastrot(it)=nmc
                  dlastrot(it)=uswsum
                end do
              end if
            end do
          end if
          if (iop(180) .gt. 0) then
            if (mod(nmc,nmctorauc) .eq. 0) then
              itorsaved=mod(ntorsaved,#AU)+1
              ntorsaved=ntorsaved+1
              do itt=1,min0(#AU,ntorsaved)
                nauc(itt)=nauc(itt)+1
              end do
              do it=1,ntang
c               Save torsion angles
                torsave(itorsaved,it)=dihango(it)
c               Calculate autocorrelation fuinction contributions
                cosit=cos(dihango(it))
                sinit=sin(dihango(it))
                do itt=1,min0(#AU,ntorsaved)
                  itt0=itorsaved-itt+1
                  if (itt0 .lt. 1) itt0=itt0+#AU
                  cositt=cos(torsave(itt0,it))
                  sinitt=sin(torsave(itt0,it))
                  auctor(itt,it)=auctor(itt,it)+
     -              cosit*cositt+sinit*sinitt
                end do
              end do
            end if
          end if
        end if
        if (iop(67) .gt. 0) then
          usltf=usltf+efieldst0*uusfac
          uusltf=uusltf+efieldst0*efieldst0*uusfac
          uslvf=uslvf+(efieldo-efieldst0)*uusfac
          uuslvf=uuslvf+(efieldo-efieldst0)*(efieldo-efieldst0)*uusfac
        end if
        if (iop(108) .gt. 0) then
          usltms=usltms+esmolo*uusfac
          uusltms=uusltms+esmolo*esmolo*uusfac
        end if
      end if
      rnsum=rnsum+dnumsolv*uusfac
      if (iop(41) .gt. 0) then
c       (TVmu) ensemble accumulators
        rnnsum=rnnsum+dnumsolv**2*uusfac
        unsum=unsum+etoto*dnumsolv*uusfac
        bsum=bsum+ba
        bbsum=bbsum+ba*ba
        virsum=virial(1)+virial(2)+virial(3)
C@FR        ufsum=ufsum+etoto*virsum*uusfac
C@FR        fnsum=fnsum+virsum*dnumsolv*uusfac
      end if
      if (iop(80) .gt. 0) then
        suminout(1)=suminout(1)+nmolinout(1)
        suminout(2)=suminout(2)+nmolinout(2)
        suminout2(1)=suminout2(1)+nmolinout(1)**2
        suminout2(2)=suminout2(2)+nmolinout(2)**2
      end if
      if (estsco .ne. 0.0) then
        estsca=estsca+estsco*uusfac
        estsaa=estsaa+estsco*estsco*uusfac
        estsua=estsua+tesi(1)*estsco*uusfac
        engout=(tesi(1)-estsco)-eout0
        if (abs(engout*beta) .lt. rllnmx) then
          expfac=exp(engout*beta)
        else if (estsco .lt. 0.0) then
          expfac=1.0/realmx
        else
          expfac=realmx
        end if
        if (alog(expfac)+dlog(dabs(estsco*uusfac)) .gt. rllnmx)
     -    expfac=realmx/(estsco*uusfac)
        einoxs=einoxs+estsco*uusfac*expfac
        eoutxs=eoutxs+uusfac*expfac
      else
        eoutxs=eoutxs+uusfac
      end if
C@FR      do k=1,3
C@FR        vircsm(k)=vircsm(k)+virial(k)*uusfac
C@FR      end do
      return
      end
      subroutine savec(icrd,iout,nwarn,c,natoms,nmolec,cplpar,edgexyz,
     -  ifrm,igce,ichseg,iopfe,iverb,filename,namlen,iatnamop,islvdat,
     -  cslvdat)
c#    MMC routine 318 lstmod: 04/23/07
c*****Write the configuration onto unit icrd (30+)
      dimension c(3,#NA),edgexyz(3),cslvdat(#MO)
      character*80 filename
      character*80 ident
      common /title/ nlident,ident(2)
      real*8 wpsmvsum,wpfpsmv
      common /prefsmv/ wpsmvsum,wpfpsmv(#PS),wpsmvn(#PG),
     -  wpsmv(#MO),rpfmv(9),apfmv(9),wpfmvcen(3),wpsmax,stiffmv,
     -  npfmv,npfsmv,limpsmv(#PS),ipsmv(#MO)
      real*8 wpsidsum,wpsgdsum,wpfpsid,wpfpsgd
      common /prefsid/ wpsidsum,wpsgdsum,wpfpsid(#PS),wpfpsgd(#PS),
     -  wpsidn(#PG),wpsid(#MO),wpsgd(#PP),rpfid(9),apfid(9),
     -  wpfidcen(3),stiffid,npfid,npfsid,npfsgd,
     -  limpsid(#PS),limpsgd(#PS),ipsid(#MO),ipsgd(#PP)
      common /fblam/ wfblam(#PG),rfblam(9),afblam(9),nfblam
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /fieldpot/ niparf,nrparf,niparm,nrparm,intf(10),intm(10),
     -  rf(10),rm(10)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      real*8 rstack,rix,rira,rirb
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
      dimension lfnam(5),ixr(4)
      character*15 fnam(5)
      character*4 segid
      data fnam /'MMC ascii      ','MMC binary     ',
     -  'MMC annotated a','PDB            ','Charmm CRD     '/
      data lfnam/12,6,15,3,10/
      iainc=0
      if (iopfe .ge. 1 .and. iopfe .le. 3) iainc=nstfa
      do i=1,4
        ixr(i)=rix(i)
      end do
      if (ifrm .eq. 1) then
        write (icrd) ifrm
c       Save in binary
        rewind icrd
        if (natoms .le. 0 .or. natoms .gt. #NA) then
          write (icrd) c
        else
          write (icrd) ((c(k,i-iainc),k=1,3),i=1,natoms-iainc)
        end if
        write (icrd) cplpar
        write (icrd) edgexyz
        write (icrd) nmolec-1,ixr,ixo
      else
c       Save in one of the alphanumeric formats
        write (icrd,1001) ifrm
        rewind icrd
        if (ifrm .eq. 2) then
          write (icrd,1001) natoms
        else if (ifrm .eq. 4) then
          write (icrd,1011) ident(1)(1:76),ident(2)(1:76),natoms
        end if
        if (nstta .gt. 0) then
          segid='CHRM'
          do ia=iainc+1,nstta
            if (ichseg .eq. 1) segid=fcglab(ia)(5:8)
            call writeat(ifrm,icrd,c(1,ia),ia,igrslt(ia),iamolslt(ia),
     -        labslt(2,ia),labslt(1,ia),segid,iatnam(ianslt(ia)),
     -        iatnamop,vdw(ianslt(ia)),qslt(ia))
          end do
          igrsltlast=igrslt(nstta)
        else
          igrsltlast=0
        end if
        segid='SOLV'
        do ia=nstta+1,natoms
          iw=(ia-nstta-1)/nslv+1
          iaw=mod(ia-nstta-1,nslv)+1
          if (islvdat .eq. 0) then
            call writeat(ifrm,icrd,c(1,ia),ia,igrsltlast+iw,0,
     -        labslv(iaw),namslv,segid,iatnam(ianslv(iaw)),
     -        iatnamop,vdw(ianslv(iaw)),qslv(iaw))
          else
            call writeat(ifrm,icrd,c(1,ia),ia,igrsltlast+iw,0,
     -        labslv(iaw),namslv,segid,iatnam(ianslv(iaw)),
     -        iatnamop,vdw(ianslv(iaw)),cslvdat(iw))
          end if
        end do
        if (ifrm .eq. 0 .or. ifrm .eq. 2) then
          write (icrd,1000) cplpar
          write (icrd,1000) edgexyz
          write (icrd,1001) nmolec-1,ixr,ixo
        end if
      end if
      if (iverb .gt. 0 .or. igce .gt. 0) write (iout,1002)
     -  filename(1:namlen),fnam(ifrm+1)(1:lfnam(ifrm+1)),nmc,nmolec-1,
     -  natoms
      if (iverb .gt. 0) then
        if (ifrm .eq. 3 .and. iatnamop .ne. 1) write (iout,1003)
        if (ifrm .eq. 4 .and. iatnamop .eq. 1) then
          write (iout,1004)
          nwarn=nwarn+1
        end if
      end if
      return
1000  format(3f15.9)
1001  format(i5,4i6,i10)
1002  format(' +++++ Configuration saved on file ',a,' in ',a,' ',
     -  'format at Nmc=',i10,' (',i5,' solvent molecules ',i6,' atoms)')
1003  format(' ///// NOTE: to use atomnames conforming to PDB ',
     -  'conventions insert the line PDBT REGU into the input file')
1004  format(' ----- WARNING: atomnames will be converted to conform ',
     -  ' to the PDB conventions - delete the line PDBT REGU to ',
     -  'prevent it')
1011  format(2('* = ',a,/),'*',/,i5)
      end
      subroutine writeat(ifrm,iconfw,cx,iat,ires,imol,atnam,resnam,
     -  segid,atname,iatnamop,vdw,q)
c#    MMC routine 319 lstmod: 03/02/01
c*****Write the descripton of one atom
      dimension cx(3)
      character*4 atnam,resnam,atname,segid
      character*1 charlist
      common /characters/ charlist(52)
      character*1 chainid
      character*4 atomnam
      if (ifrm .eq. 0) then
c       Simple ASCI
        write (iconfw,1000) cx
      else if (ifrm .eq. 2) then
c       Annotated ASCI
        write (iconfw,1002) atname,cx,ires,q
      else if (ifrm .eq. 3) then
c       PDB
        if (imol .eq. 0) chainid='W'
        if (imol .ne. 0) chainid=charlist(mod(imol-1,22)+1)
        call adjustpdbname(atnam,atomnam,iatnamop)
        write (iconfw,1003) iat,atomnam,resnam(1:3),chainid,ires,cx,
     -    vdw,q
      else if (ifrm .eq. 4) then
c       Charmm CRD
        write (segid,1005) imol
        if (imol .eq. 0) segid='CHRM'
        write (iconfw,1004) iat,ires,resnam,atnam,cx,segid,ires,q
      end if
      return
1000  format(3f15.9)
1002  format(a4,1x,3f15.6,i5,f10.5)
1003  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
1004  format(i5,i5,1x,a4,1x,a4,3f10.5,1x,a4,1x,i4,f10.5)
1005  format(i4)
      end
      subroutine findfg(n0,n,ian,indxfg,itypfg,nfg,iout,nwarn,
     -  nneiga,nneigh,ineig,maxneig)
c#    MMC routine 320 lstmod: 03/03/08
c*****Assigns the appropriate fg types to the solute atoms
      dimension ineig(maxneig,n),nneiga(n),nneigh(n)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /connatdat/ ramax(99),ramax2(99),nval(99)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /option/ iop(200),idebug(200)
      dimension ian(n),indxfg(n),itypfg(n)
      data ityp /0/
c     n : number of atoms in c
c     icl(i) : type af atom i
c     ian(i) : atomic number of atom i
c     nfg: number of functional groups found
c     itypfg(i): functional group type of atom i
c     indxfg(i): the i-th atom belongs to the indxfg(i)-th fcg
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      nfg=0
c     Check for "valence errors"
      nverr=0
      do i=n0,n
        itypfg(i)=0
        if (nneiga(i) .gt. nval(ian(i)) .and. nval(ian(i)) .gt. 0) then
          if (MYRANK .eq. 0) write (iout,1001) i,ian(i),nneiga(i),
     -      (ineig(j,i),j=1,nneiga(i))
          itypfg(i)=100
          indxfg(i)=0
          nverr=nverr+1
        end if
      end do
      nwarn=nwarn+nverr
c     Search for O and P first
      do i=n0,n
        if (ian(i) .eq. 8 .and. itypfg(i) .eq. 0) then
c         Oxygen found
          if (nneiga(i) .eq. 1 .and. ian(ineig(1,i)) .eq. 6) then
            inn1=ineig(1,i)
            nnn1=nneiga(inn1)
            noxy=0
            do j=1,nnn1
              if (ian(ineig(j,inn1)) .eq. 8 .and.
     -          nneiga(ineig(j,inn1)) .eq. 1) noxy=noxy+1
            end do
            if (noxy .eq. 2) then
c             COO- found typ=27
              nfg=nfg+1
              indxfg(inn1)=nfg
              itypfg(inn1)=27
              do j=1,nnn1
                in=ineig(j,inn1)
                if (ian(in) .eq. 8 .and. nneiga(in) .eq. 1 .and.
     -              itypfg(in) .eq. 0) then
                  indxfg(in)=nfg
                  itypfg(in)=27
                end if
              end do
            else
c             >C=O found,  typ=17
              nfg=nfg+1
              indxfg(i)=nfg
              indxfg(inn1)=nfg
              itypfg(i)=17
              itypfg(inn1)=17
            end if
          else if (nneiga(i) .eq. 2 .and. nneigh(i) .eq. 0) then
c           Ester oxygen found, typ=19 or 20 (for phospho ester)
            nfg=nfg+1
            indxfg(i)=nfg
            if (ian(ineig(1,i)) .ne. 15 .and. ian(ineig(2,i)) .ne. 15)
     -        itypfg(i)=19
            if (ian(ineig(1,i)) .eq. 15 .or. ian(ineig(2,i)) .eq. 15)
     -        itypfg(i)=20
          else if (nneiga(i) .eq. 2 .and. nneigh(i) .eq. 1) then
c           -OH found, typ=21
            nfg=nfg+1
            indxfg(i)=nfg
            itypfg(i)=21
            nn=nneiga(i)
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                indxfg(in)=nfg
                itypfg(in)=21
              end if
            end do
          end if
        else if (ian(i) .eq. 15 .and. itypfg(i) .eq. 0) then
c         Phosphorus found  (>PO2 : ityp 22)
          nfg=nfg+1
          indxfg(i)=nfg
          iong=0
          nn=nneiga(i)
          do j=1,nn
            in=ineig(j,i)
            if (ian(in) .eq. 8 .and. itypfg(in) .eq. 0 .and.
     -        nneiga(in) .eq. 1) then
              iong=iong+1
            end if
          end do
          if (iong .eq. 2) then
c           >PO2 found
            itypfg(i)=22
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 8 .and. itypfg(in) .eq. 0 .and.
     -          nneiga(in) .eq. 1) then
                indxfg(in)=nfg
                itypfg(in)=22
              end if
            end do
          else if (iong .eq. 4 .and. nn .eq. 4) then
c           PO4-- found
            itypfg(i)=31
            do j=1,nn
              in=ineig(j,i)
              indxfg(in)=nfg
              itypfg(in)=31
            end do
          else if (iong .eq. 3 .and. nn .eq. 4 .and.
     -      nneigh(i) .eq. 1) then
c           HPO3- found
            itypfg(i)=32
            do j=1,nn
              in=ineig(j,i)
              indxfg(in)=nfg
              itypfg(in)=32
            end do
          else
            itypfg(i)=99
          end if
        end if
      end do
c     Search for carbon and nitrogen next
      do i=n0,n
        if (ian(i) .eq. 6 .and. itypfg(i) .eq. 0) then
c         Unassigned carbon found
          nfg=nfg+1
          ityp=(10-(nneiga(i)*(nneiga(i)+1))/2)+nneigh(i)+1
          if (ityp .lt. 0) ityp=99
          indxfg(i)=nfg
          itypfg(i)=ityp
          nn=nneiga(i)
          if (nn .gt. 0) then
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                indxfg(in)=nfg
                itypfg(in)=ityp
              end if
            end do
          end if
        else if (ian(i) .eq. 7 .and. itypfg(i) .eq. 0) then
c         Unassigned nitrogen found
          nfg=nfg+1
          if (nneiga(i) .lt. 4)
     -      ityp=(6-(nneiga(i)*(nneiga(i)+1))/2)+nneigh(i)+11
c         Four neighbours, assumed to be positively charged
          if (nneiga(i) .eq. 4) ityp=23+nneigh(i)
          indxfg(i)=nfg
          itypfg(i)=ityp
          nn=nneiga(i)
          if (nn .gt. 0) then
            do j=1,nn
              in=ineig(j,i)
              if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                indxfg(in)=nfg
                itypfg(in)=ityp
              end if
            end do
          end if
        end if
      end do
c     Label hydrogens on carbonyl
      do i=n0,n
        if (itypfg(i) .eq. 0 .and. nneiga(i) .gt. 0) then
c         Hydrogen on a C=O is type 18
          if (ian(i) .eq. 1 .and. itypfg(ineig(1,i)) .eq. 17) then
            nfg=nfg+1
            indxfg(i)=nfg
            itypfg(i)=18
          end if
        end if
      end do
c     Search for -S- (type 28) and -SH (type 29)
      do i=n0,n
        if (itypfg(i) .eq. 0 .and. ian(i) .eq. 16) then
c         Sulphur found
          if (nneiga(i) .eq. 2) then
c           -S-, -SH or HSH found
            if (nneigh(i) .gt. 0) then
c             -SH or HSH found
              itp=28
              nfg=nfg+1
              indxfg(i)=nfg
              itypfg(i)=itp
              do ing=1,2
                in=ineig(ing,i)
                if (ian(in) .eq. 1 .and. itypfg(in) .eq. 0) then
                  indxfg(in)=nfg
                  itypfg(in)=itp
                end if
              end do
            else
c             -S- found
              nfg=nfg+1
              indxfg(i)=nfg
              itypfg(i)=29
            end if
          end if
        end if
      end do
c     Assign the single atom funcional groups
      do i=n0,n
        if (itypfg(i) .eq. 0) then
          ianfgi=ianfg(ian(i))
          if (ianfgi .gt. 0) then
c           If no neighbours, must be an ion
            if (nneiga(i) .eq. 0) ianfgi=ianfgi+1
            nfg=nfg+1
            indxfg(i)=nfg
            itypfg(i)=ianfgi
          end if
        end if
      end do
c     Label all unassigned atoms
      do i=n0,n
        if (itypfg(i) .eq. 0) then
          nfg=nfg+1
          indxfg(i)=nfg
          itypfg(i)=99
        end if
      end do
c     Assign unassigned valence error atoms
      do i=n0,n
        if (itypfg(i) .eq. 100 .and. indxfg(i) .eq. 0) then
          nfg=nfg+1
          indxfg(i)=nfg
        end if
      end do
      return
1001  format(' ----- WARNING: atom',i5,', atomic no=',i3,
     -    ' has',i3,' neighbours: ',15i5)
      end
      subroutine fcganal(iaf,ial,ierronly)
c#    MMC routine 321 lstmod: 12/30/04
c*****Do a functional group analysis from solute atoms iaf to ial
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      character*4 namfcg,namfcg0
      character*20 nmlfcg,nmlfcg0
      common /fcgnam/ igrdup(100),namfcg0(100),namfcg(100),
     -  nmlfcg0(100),nmlfcg(100)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*4 blank
      data blank /'    '/
      call findfg(iaf,ial,ianslt,indxfg,itypfg,nfg,iout,
     -  nwarn,nneiga,nneigh,ineig,#NL)
      call sortfg(nfg,iaf,ifgstr,indxfg,ifgaix,nfgmem,ifgtyp,itypfg,
     -  ixfg,ial,iout,inperr)
      ip=0
      nerrs=0
      do igg=1,nfg
        ig=ixfg(igg)
        if (ierronly .lt. 1  .or. ifgtyp(ig) .ge. 99) then
          if (ifgtyp(ig) .ge. 99) nerrs=nerrs+1
          ig1=ifgstr(ig)
          ig2=ig1+nfgmem(ig)-1
          do iat=ig1,ig2
            ip=ip+1
            iaa=ifgaix(iat)
            nna=nneig(iaa)
            write (iout,2080) ip,iaa,iatnam(ianslt(iaa)),
     -        namfcg0(ifgtyp(ig)),(ineig(in,iaa),
     -        iatnam(ianslt(ineig(in,iaa))),in=1,nna)
c           Check if fcg assigned for the atomtype matches found fcg
            ifc0=ifcnos(iclslt(iaa),iopslt(iaa))
            if (ifgtyp(ig) .lt. 98 .and.
     -          namfcg0(ifc0) .ne. blank) then
              if (ifgtyp(ig) .ne. ifc0) then
                write (iout,2082) namfcg0(ifgtyp(ig)),namfcg0(ifc0)
                nwarn=nwarn+1
              end if
            end if
          end do
          write (iout,2081) namfcg0(ifgtyp(ig))
        end if
      end do
      if (ierronly .gt. 0 .and. nerrs .eq. 0) write (iout,2083)
      return
2080  format(i6,' (',i5,1x,a4,')',2x,a4,' neighbours:',
     -  8(' (',i5,1x,a4,')'))
2081  format(' End of group ',a4,1x,100('.'))
2082  format(' ----- WARNING: functional group found (',a4,') is',
     -  ' different from functional group stored for this atom: ',a4)
2083  format(' No functional group errors were found')
      end
      subroutine nneiglist(c,n0,n,ian,iout,inperr,nwarn,nwwarn,nneig,
     -  nneiga,nneigh,ineig,maxneig)
c#    MMC routine 322 lstmod: 02/01/11
c*****Calculate neighbor list
      dimension nneig(n),ineig(maxneig,n),nneiga(n),nneigh(n)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /option/ iop(200),idebug(200)
      dimension ian(n),c(3,n)
c     c(1,i) : coordinates of atom i
c     n : number of atoms in c
c     ian(i) : atomic number of atom i
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension dc(3)
c     nneig(i) : number of neighbours of atom i
c     ineig(1,i) : list of neighbours of atom i
c     nneiga(i) : number of non pseudo atom neighbours of atom i
c     nneigh(i) : number of hydrogen neighbours of atom i
      nverr=0
c     Determine neighbour list, hydrogen neighbour number
      do i=n0,n
        nneig(i)=0
        nneigh(i)=0
        if (ian(i) .lt. 1 .or. ian(i) .gt. 99) then
          write (iout,1001) i,ian(i)
          ian(i)=1
          inperr=inperr+1
        end if
      end do
      if (nverr .gt. 0) write (iout,1002)
      n01=n0+1
      do i=n01,n
        i1=i-1
        do j=n0,i1
          ihyd=0
          if (ian(i) .eq. 1 .or. ian(j) .eq. 1) ihyd=1
          d2=arrdist(c(1,i),c(1,j))
          if (iop(2) .eq. 2) then
c           For crystal solute, see if bond can be made with an image
            call arrdiff(dc,c(1,i),c(1,j),3)
            call pbcnd(dc(1),dc(2),dc(3),iop(5),iopt,dc2)
            if (dc2 .lt. d2) d2=dc2
          end if
          if (d2 .lt. bondthresh2(ian(i),ian(j))) then
c           Bond found. Bonds to electron, charge or lone pair are not
c           saved in the 'real' atoms' list here.
            if (idummy(ian(i)) .eq. 1 .or. idummy(ian(j)) .eq. 0) then
              if (nneig(i) .lt. maxneig) then
                nneig(i)=nneig(i)+1
                ineig(nneig(i),i)=j
              else
                write (iout,1003) i,nneig(i),maxneig
                inperr=inperr+1
              end if
            end if
            if (idummy(ian(j)) .eq. 1 .or. idummy(ian(i)) .eq. 0) then
              if (nneig(j) .lt. maxneig) then
                nneig(j)=nneig(j)+1
                ineig(nneig(j),j)=i
              else
                write (iout,1003) j,nneig(j),maxneig
                inperr=inperr+1
              end if
            end if
            if (ian(i) .eq. 1) nneigh(j)=nneigh(j)+1
            if (ian(j) .eq. 1) nneigh(i)=nneigh(i)+1
            if (d2 .lt. 0.04) then
              write (iout,1006) '===== STRONG',i,j,sqrt(d2),
     -          (c(k,i),k=1,3),(c(k,j),k=1,3)
              nwwarn=nwwarn+1
            else if (d2 .lt. 0.16) then
              write (iout,1006) '-----',i,j,sqrt(d2),
     -          (c(k,i),k=1,3),(c(k,j),k=1,3)
              nwarn=nwarn+1
            end if
          end if
        end do
      end do
c     Save the non pseudo-atom neighbours for the real atoms
      do i=n0,n
        nneiga(i)=nneig(i)
      end do
c     Functional group search will not see the pseudo-atom neighbours
      do i=n0,n
        if (idummy(ian(i)) .eq. 1 .and. nneig(i) .gt. 0) then
c         Pseudo atom found
          nn=nneig(i)
          do in=1,nn
            ia=ineig(in,i)
            if (idummy(ian(ia)) .eq. 0) then
c             Add i to the neighbour list of ia
              nneig(ia)=nneig(ia)+1
              ineig(nneig(ia),ia)=i
            end if
          end do
        end if
      end do
      if (idebug(14) .gt. 0) then
        write (iout,1005) n0,n
        do ia=n0,n
          write (iout,1004) ia,ian(ia),(ineig(in,ia),in=1,nneig(ia))
        end do
      end if
      return
1001  format(' ***** PROGRAM ERROR atomic number of atom ',i5,
     -  ' is illegal:',i5)
1002  format(' Neighbour table redetermined due to valence errors')
1003  format(' ***** ERROR atom ',i4,' has too many neighbours:',
     -  i4,' (maximum allowed=',i4,')')
1004  format(' NNEIGLIST:',i5,' ian=',i3,(' in=',10i5))
1005  format(' NNEIGLIST: atom ,limits=',2i5)
1006  format(1x,a,' WARNING: solute atoms',i6,' and',i6,' are only ',
     -  f8.6,' A apart:',3f8.2,3x,3f8.2)
      end
      function idummy(ian)
c#    MMC routine 323 lstmod: 12/02/03
c*****Returns 1 for not real atoms (Dummy, q, LP, elec)
      idummy=0
      if (ian .eq. 88 .or. ian .eq. 89 .or. ian. eq. 90 .or.
     -    ian .eq. 99) idummy=1
      end
      subroutine sortfg(nfg,n0,ifgstr,indxfg,ifgaix,nfgmem,ifgtyp,
     -  itypfg,ixfg,n,iout,inperr)
c#    MMC routine 324 lstmod: 06/20/97
c*****Sort atoms and functional groups
      dimension nfgmem(n),ifgstr(n),ifgaix(n),ixfg(n),indxfg(n),
     -  ifgtyp(n),itypfg(n)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
c     nfgmem(i): number of atoms in fcg i
c     ifgstr(i): start of member list for fcg i in indxat
c     ifgtyp(i): the functional group type of the i-th fcg before sorting
c     ifgaix(i): the original index of the i-th atom in the atomlist
c     sorted by functional groups
c     ixfg(ig) : the ig-th functional group after sorting
c     Sort atoms by functional groups
      nmem=0
      do if=1,nfg
        ifgstr(if)=nmem+1
        do ia=n0,n
          if (indxfg(ia) .eq. if) then
            nmem=nmem+1
            ifgaix(nmem)=ia
          end if
        end do
        nfgmem(if)=nmem-ifgstr(if)+1
        if (nfgmem(if) .eq. 0) then
          if (MYRANK .eq. 0) write (iout,1000) if
          inperr=inperr+1
        else
          ifgtyp(if)=itypfg(ifgaix(ifgstr(if)))
        end if
      end do
c     Index (sort) fcg's by type
      nfgn=0
      do it=1,100
        do if=1,nfg
          if (ifgtyp(if) .eq. it) then
            nfgn=nfgn+1
            ixfg(nfgn)=if
          end if
        end do
      end do
      return
1000  format(' ***** PROGRAM ERROR: functional group ',i4,' has no ',
     -  'members')
      end
      subroutine fcgdef(n0,n,igrslt,molslt)
c#    MMC routine 325 lstmod: 05/19/03
c*****Input information about user-defined groups to replace default fcg's
      dimension igrslt(#ST),molslt(#ST)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      character*4 namfcg,namfcg0
      character*20 nmlfcg,nmlfcg0
      common /fcgnam/ igrdup(100),namfcg0(100),namfcg(100),
     -  nmlfcg0(100),nmlfcg(100)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*4 labfg4(2),shname
      character*8 labfg8
      character*80 line
      common /inpline/ line,lineno,icol
      call getint(ninpgrp,1,1,0)
      if (ninpgrp .gt. 98) then
        write (iout,2008) ninpgrp
        call datprt(2)
      end if
      call getint(ninpspecd,1,1,0)
      do i=1,98
        namfcg(i)='    '
        nmlfcg(i)='                    '
      end do
      do i=99,100
        namfcg(i)=namfcg0(i)
        nmlfcg(i)=nmlfcg0(i)
      end do
      irectx=11
c     Input short and long functional group names
      do i=1,ninpgrp
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1049,err=999) namfcg(i),nmlfcg(i),igrdup(i)
        if (iop(24) .gt. 0)
     -    write (iout,1349) i,namfcg(i),nmlfcg(i),igrdup(i)
      end do
      do is=n0,n
        itypfg(is)=99
        indxfg(is)=0
      end do
      irectx=12
c     Input functional group descriptions
      do i=1,ninpspecd
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1050,err=999) labfg4,labfg8,shname
        if (iop(24) .gt. 0) write (iout,1350) labfg4,labfg8,shname
        call namornum(shname,ifgrp,shname,4)
        if (ifgrp .eq. -1) then
c         Label was read - find the index
          ifgrp=1
          do while (namfcg(ifgrp) .ne. shname .and. ifgrp .le. ninpgrp)
            if (ifgrp .eq. ninpgrp) then
              write (iout,2007) shname
              inperr=inperr+1
            end if
            ifgrp=ifgrp+1
          end do
        end if
        if (ifgrp .lt. 1 .or. ifgrp .ge. 98) then
          write (iout,2000) ifgrp
          inperr=inperr+1
        else if (namfcg(ifgrp) .eq. '    ') then
          write (iout,2001)
          inperr=inperr+1
        end if
        nfound=0
        do is=n0,n
          nmatch=0
          do k=1,2
            if (labfg4(k) .eq. '    ') then
              nmatch=nmatch+1
            else
              ncharm=0
              do kk=1,4
                if (labfg4(k)(kk:kk) .eq. labslt(k,is)(kk:kk) .or.
     -              labfg4(k)(kk:kk) .eq. '*') ncharm=ncharm+1
              end do
              if (ncharm .eq. 4) nmatch=nmatch+1
            end if
          end do
          if (labfg8 .eq. '        ') then
            nmatch=nmatch+1
          else
            ncharm=0
            do kk=1,8
              if (labfg8(kk:kk) .eq. fcglab(is)(kk:kk) .or.
     -            labfg8(kk:kk) .eq. '*') ncharm=ncharm+1
            end do
            if (ncharm .eq. 10) nmatch=nmatch+1
          end if
          if (nmatch .eq. 3) then
            if (itypfg(is) .ne. 99) then
              write (iout,2006) is,itypfg(is),ifgrp
              nwarn=nwarn+1
            else
              itypfg(is)=ifgrp
              nfound=nfound+1
            end if
          end if
        end do
        if (nfound .eq. 0) then
          write (iout,2002) labfg4,labfg8,ifgrp
          nwarn=nwarn+1
        end if
      end do
      nfg=0
c     Assign fcg numbers to newly defined groups
      do is=n0,n
        if (itypfg(is) .ne. 99) then
c         Group element found
          if (indxfg(is) .eq. 0) then
c           New group
            nfg=nfg+1
            ifgtyp(nfg)=itypfg(is)
            if (igrdup(itypfg(is)) .eq. 0) then
c             All occurences form one group
              do iss=is,n
                if (itypfg(iss) .eq. itypfg(is)) indxfg(iss)=nfg
              end do
            else if (igrdup(itypfg(is)) .eq. 1) then
c             Separate groups will be formed for each residue
              iss=is
              do while (igrslt(iss) .eq. igrslt(is))
                if (itypfg(iss) .eq. itypfg(is)) indxfg(iss)=nfg
                iss=iss+1
              end do
            else
c             Separate groups will be formed for each solute molecule
              iss=is
              do while (igrslt(iss) .eq. molslt(is))
                if (itypfg(iss) .eq. itypfg(is)) indxfg(iss)=nfg
                iss=iss+1
              end do
            end if
          end if
        end if
      end do
c     Create one group of the unassigned atoms
      nundef=0
      do is=n0,n
        if (indxfg(is) .eq. 0) then
          indxfg(is)=nfg+1
          nundef=nundef+1
        end if
      end do
      if (nundef .gt. 0) then
        nfg=nfg+1
        ifgtyp(nfg)=99
      end if
      if (iop(24) .gt. 0) then
        do is=n0,n
          if (itypfg(is) .ne. 99) then
            write (iout,2004) is,(labslt(k,is),k=1,2),fcglab(is),
     -        itypfg(is),indxfg(is)
          end if
        end do
      end if
      call sortfg(nfg,n0,ifgstr,indxfg,ifgaix,nfgmem,ifgtyp,itypfg,
     -  ixfg,n,iout,inperr)
      if (idebug(94) .gt. 0) write (iout,2009) (ig,ixfg(ig),itypfg(ig),
     -  ifgtyp(ig),ifgstr(ig),indxfg(ig),ig=1,nfg)
      if (nundef .gt. 0) then
c       nfg=nfg-1
        write (iout,2005) nundef
        nwarn=nwarn+1
      end if
      return
999   call invalidform(iout,irectx)
1049  format(a4,1x,a20,i5)
1050  format(a4,1x,a4,1x,a8,1x,a4)
1349  format(i5,' rectype 11  : ',a4,1x,a20,i5)
1350  format(' rectype 12  : ',a4,1x,a4,1x,a8,1x,a4)
2000  format(' ***** ERROR: invalid functional group number:',i4)
2001  format(' ***** ERROR: undefined functional group number:',i4)
2002  format(' ----- WARNING: functional group defined but not used:',
     -  a4,'-',a4,'-',a10,1x,i4)
2004  format(i5,' Res/at=',2a4,' fcglab=',a,' fcgtype=',i2,
     -  ' fcgindex=',i5)
2005  format(' ----- WARNING: ',i5,' atoms remained undefined - they ',
     -  ' are gathered as the Unclassified group (????)')
2006  format(' ----- WARNING: ',i5,' atom is already in group ',i3,
     -  ' - attempt to include it in group ',i3,' is ignored')
2007  format(' ***** ERROR: functional group name is undefined:',a4)
2008  format(' ***** ERROR: maximum number of functional groups',
     -  ' (98) is exceeded: ',i4)
2009  format(' ig=',i4,' ixfg=',i4,' itypfg=',i4,' ifgtyp=',i4,
     -  ' ifgstr=',i5,' indxfg=',i4)
      end
      subroutine checkifbond(ibond,ia,ja,nneig,ineig,maxng,maxat)
c#    MMC routine 325/a lstmod: 05/17/05
c*****Returns ibond=1 if atoms ia and ja are bonded according to ineig
      dimension nneig(maxat),ineig(maxng,maxat)
      ibond=0
      do in=1,nneig(ia)
        if (ineig(in,ia) .eq. ja) ibond=1
      end do
      return
      end
      subroutine torsionsetup(molgopt,incrat,nfixbondtyp,ntbond,
     -  nflexring,ntordrop,nptd,naflxrange,iaflxrange,iaflxneig)
c#    MMC routine 326 lstmod: 04/11/2021
c*****Set up torsional degrees of freedoms
      character*4 ntbond
      dimension ntbond(2,20),iaflxrange(2,naflxrange),
     -  iaflxneig(2,naflxrange)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /toreng/ npft(#TR),ifpftd(9,#TR),ilpftd(9,#TR),
     -  torsinc(9,#TR),torcoef(#TA),phase(#TA),period(#TA)
      character*4 resnames
      common /gromostor/ ifres(200),ilres(200),resnames(200)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /grid_split/ isplit_of_orig(#ST),iorig_of_split(#ST),
     -  ir_split_orig(#ST),devmax_xyz(4,3),xyzflmin(3),xyzflmax(3)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),
     -  d02(#LT),d03(#LT),d12(#LT),d13(#LT),
     -  d14(#LT),d23(#LT),d24(#LT),d25(#LT),d34(#LT),d35(#LT),
     -  d36(#LT),d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),d79(#LT)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /gather/ indexx(#UV),indexn(#UV),idistroot(#UV),
     -  idistend(#UV),ivtm(#UV),
     -  crmgs(3,#UV),cgs(3,#HA),texng(#UV),
     -  frcng(3,#UV),trqng(3,#UV),trnisg(3,#UV),cv1(#UV),
     -  cv2(#UV),cv3(#UV),abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ idon(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*80 line
      common /inpline/ line,lineno,icol
      dimension itpused(11),nbskip(7),iamid(7),iatnew(7)
      parameter (MAXTORS=4000)
      character*6 tnames(4,MAXTORS)
      dimension torcoefd(MAXTORS),phased(MAXTORS),periodd(MAXTORS)
      real*8 wtorsum,wwtorsum,dst,d01
      character*4 resnam,atnam1,atnam2,atnam3,atnam4
      character*6 pflabaklb(4)
      data it0 /0/,itswap /0/,nptd0 /0/
c     write (iout,*) 'TORSIONSETUP ntorsinp=',ntorsinp
      ntorlim=0
      call zeroiti(iskew,0,#TR)
      if (incrat .ne. 0) write (iout,1129) incrat
      if (ntorsinp .gt. 0) then
c       Input actual torsion angle definitions
        call checkdim(ifail,iout,inperr,'TR',ntorsinp,1,1,0)
        ntdiffinp=0
        iatmoved=0
        iatlow=1
        if (iop(30) .eq. 1 .or. iop(30) .eq. 2 .or. iop(30) .ge. 7)
     -    iatlow=nstfa1+1
        iathigh=nsttainp
        l1(1)=1
        do it=1,ntorsinp
c         Atoms of torson angle
          irectx=24
c         The torsional rotation is around the ik-il bond.
c         Clockwise, if looking from ia,ik and keeping ia,ik,il fixed
c         The torsions belonging to the same itorgrp will be moved together,
          call getnextrec(inpt,iout,irectx,nwwarn)
          if (iop(116) .eq. 0) then
            read (line,1000,err=999) iik,iil,steploop(it),torstep(it),
     -        itorgrp(it),isense,wtors(it+1),deldih(it)
            if (iop(24) .gt. 1) write (iout,1348) iik,iil,steploop(it),
     -        torstep(it),itorgrp(it),isense,wtors(it+1),deldih(it)
          else
            read (line,1000,err=999) iik,iil,steploop(it),torstep(it),
     -        itorgrp(it),isense,wtors(it+1),deldih(it),
     -        targetang(it),iskew(it)
            if (iop(24) .gt. 1) write (iout,1348) iik,iil,steploop(it),
     -        torstep(it),itorgrp(it),isense,wtors(it+1),deldih(it),
     -        targetang(it),iskew(it)
            targetang(it)=targetang(it)/rdtodg
          end if
          if (iik*iil .eq. 0) then
            inperr=inperr+1
            write (iout,1109) it,iik,iil
          end if
          iik=iik+incrat
          iil=iil+incrat
          if (iop(61) .eq. 0) then
            ik=iik
            il=iil
          else
            ik=isplit_of_orig(iik)
            il=isplit_of_orig(iil)
          end if
          if (iop(58) .eq. 0) torstep(it)=0.0
          if (iop(58) .eq. 1) torstep(it)=torstep(it)/rdtodg
          steploop(it)=steploop(it)/rdtodg
          torstep(it)=torstep(it)*rngfac(1)
          if (iop(18) .ne. 4 .or. itorgrp(it) .ne. itorgrp(1))
     -      deldih(it)=deldih(it)/rdtodg
          steploop(it)=steploop(it)*rngfacl(1)
          if (wtors(it+1) .eq. 0.0) wtors(it+1)=1.0
          if (itorgrp(it) .eq. 0) then
            inperr=inperr+1
            write (iout,1107) it
          end if
c         Make sure group numbers are consecutive
          if (it .gt. 1) then
            l1(it)=l1(it-1)
            if (itorgrp(it) .ne. itorgrp(it-1)) l1(it)=l1(it)+1
          end if
          if (iop(18) .eq. 4 .and. itorgrp(it) .eq. 1) then
c           Torsion coupling, worry about range, sense
            if (deldih(it) .ne. 0.0) then
              ntdiffinp=ntdiffinp+1
              if (isense .ne. 0) then
                nwarn=nwarn+1
                write (iout,1108) it
              end if
            else if (isense .eq. +1) then
              deldih(it)=+999.0
            else if (isense .eq. -1) then
              deldih(it)=-999.0
            end if
          else
            if (deldih(it) .eq. 180.0) deldih(it)=0.0
            if (deldih(it) .ne. 0.0) ntorlim=ntorlim+1
          end if
          iquata(it,2) = ik
          iquata(it,3) = il
          inperr0=inperr
          do k=2,3
            ia=iquata(it,k)
            if (ia .lt. iatlow .or. ia .gt. iathigh) then
              if (iop(30) .ge. 7) then
                if (ia .ge. 1 .and. ia .le. nstfa0) then
                  iquata(it,k)=ia+nstfa1
                end if
              else
                write (iout,1110) ia,it,iatlow,iathigh,it
                inperr=inperr+1
              end if
            end if
          end do
c         Check if ik,il are bonded
          if (inperr .eq. inperr0) then
            call checkifbond(nbd,ik,il,nneig,ineig,#NL,#ST)
            if (nbd .eq. 0) then
c             No bond exists
              write (iout,1106) iik,iil,(labslt(k,ik),k=1,2),
     -          (labslt(k,il),k=1,2),it,
     -          sqrt(arrdist(cslt(1,ik),cslt(1,il)))
              inperr=inperr+1
            end if
          end if
          iri(it)=1
        end do
        if (iop(61) .gt. 0) write (iout,1128)
        ndiff=0
        do it=1,ntorsinp
          if (itorgrp(it) .ne. l1(it)) ndiff=ndiff+1
        end do
        if (ndiff .gt. 0) then
          write (iout,1206)
          nwarn=nwarn+1
          call trnsfi(itorgrp,l1,ntorsinp)
        end if
        if (nclone .gt. 0) then
c         Clone torsions
          do it=1,ntorsinp
            iquata(it,1)=icnew(iquata(it,2))
          end do
          nti=ntorsinp
          do it=nti,1,-1
            ic=-iquata(it,1)
            if (ic .gt. 0) then
c             Torsion on cloned molecule found
              it1=it
              do while (it1 .gt. 0)
                if (-iquata(it1,1) .eq. ic) then
                  iquata(it1,1)=0
                  it1=it1-1
                else
                  go to 110
                end if
              end do
110           it11=it1+1
c             Torsions it11- it are all on cloned molec ic
c             Find out the number of atoms to shift with the cloned molec ic
              ific=ifirstm(iamolslt(iquata(it,2)))
              ia=ific
              do while (ific .ne. icorig(ia) .and. ia .le. nstta)
                ia=ia+1
              end do
              if (ia .gt. nstta) then
                write (iout,1132) ic,ific
                icldif=0
              else
                icldif=ia-icorig(ia)
              end if
c             Make room
              itdiff=it-it1
              incr=(ncopcln(ic)-1)*itdiff
              ntorsinp=ntorsinp+incr
              call checkdim(ifail,iout,inperr,'TR',ntorsinp,1,1,0)
              if (ifail .gt. 0) return
              iadiff=ilastm(iamolslt(icldif+iquata(it,2)))-
     -               ifirstm(iamolslt(icldif+iquata(it11,2)))+1
              do itt=nti,it+1,-1
c               itorig(itt+incr)=itorig(itt)
                iquata(itt+incr,2)=iquata(itt,2)
                iquata(itt+incr,3)=iquata(itt,3)
                deldih(itt+incr)=deldih(itt)
                torstep(itt+incr)=torstep(itt)
                wtors(itt+incr+1)=wtors(itt+1)
                itorgrp(itt+incr)=itorgrp(itt)+
     -            (ncopcln(ic)-1)*(itorgrp(it)-itorgrp(it11)+1)
                iri(itt+incr)=1
                if (iop(116) .gt. 0) then
                  iskew(itt+incr+1)=iskew(itt+1)
                  targetang(itt+incr+1)=targetang(itt+1)
                end if
              end do
              nti=nti+(ncopcln(ic)-1)*(itorgrp(it)-itorgrp(it11)+1)
c             Now clone
              do id=1,ncopcln(ic)-1
                do itt=it11,it
c                 itorig(itt+id*itdiff)=-itorig(itt)
                  iquata(itt+id*itdiff,2)=iquata(itt,2)+iadiff*id+icldif
                  iquata(itt+id*itdiff,3)=iquata(itt,3)+iadiff*id+icldif
                  deldih(itt+id*itdiff)=deldih(itt)
                  torstep(itt+id*itdiff)=torstep(itt)
                  wtors(itt+id*itdiff+1)=wtors(itt+1)
                  itorgrp(itt+id*itdiff)=itorgrp(itt)+
     -                  id*(itorgrp(it)-itorgrp(it11)+1)
                  iri(itt+id*itdiff)=1
                  if (iop(116) .gt. 0) then
                    iskew(itt+id*itdiff+1)=iskew(itt+1)
                    targetang(itt+id*itdiff+1)=targetang(itt+1)
                  end if
                end do
              end do
              if (icldif .gt. 0) then
                do itt=it11,it
                  iquata(itt,2)=iquata(itt,2)+icldif
                  iquata(itt,3)=iquata(itt,3)+icldif
                end do
              end if
            else
c             Just update atomindices if needed
              if (icnew(iquata(it,2)) .gt. 0) then
                iquata(it,2)=icnew(iquata(it,2))
                iquata(it,3)=icnew(iquata(it,3))
              end if
            end if
          end do
          if (idebug(17) .gt. 0)
     -      write (iout,7877) (it,(iquata(it,k),k=2,3),itorgrp(it),
     -        deldih(it),torstep(it),steploop(it),it=1,ntorsinp)
7877      format(i6,i6,'-',i6,' itg=',i6,' del,step,steploop=',3f10.5)
        end if
        if (nsltcop .gt. 1 .and. nclone .gt. 0) then
          write (iout,1124)
          inperr=inperr+1
        end if
        if (nsltcop .eq. 2 .and. (iop(30) .eq. 5 .or. iop(30) .eq. 6)
     -    .or. nsltcop .eq. 3 .and. iop(30) .eq. 7) then
          if (nsltcop*ntorsinp .gt. #TR) then
            inperr=inperr+1
            write (iout,1115) nsltcop*ntorsinp,'TR'
            nsltcop=1
          end if
          do ic=2,nsltcop
            do ia=1,nstfa0
              iac=(ic-1)*nstfa0+ia
              if (iclslt(ia) .ne. iclslt(iac) .or. nneig(ia) .ne.
     -          nneig(iac) .or. nneig4(ia) .ne. nneig4(iac)) then
                write (iout,1117) ic,ia
                write (iout,1118) iclslt(ia),nneig(ia),nneig4(ia),
     -            ic,iclslt(iac),nneig(iac),nneig4(iac)
                inperr=inperr+1
              else
                do in=1,nneig4(ia)
                  if (ineig(in,ia)+iac-ia .ne. ineig(in,iac)) then
                    write (iout,1117) ic,ia
                    write (iout,1119) in,ineig(in,ia),ic,ineig(in,iac)
                    inperr=inperr+1
                  end if
                end do
              end if
            end do
            do it=1,ntorsinp
              itt=(ic-1)*ntorsinp+it
              iquata(itt,2)=iquata(it,2)+(ic-1)*nstfa0
              iquata(itt,3)=iquata(it,3)+(ic-1)*nstfa0
              deldih(itt)=deldih(it)
              torstep(itt)=torstep(it)*rngfac(ic)/rngfac(1)
              steploop(itt)=steploop(it)*rngfacl(ic)/rngfacl(1)
              wtors(itt+1)=wtors(it+1)
              ipftor(itt)=ipftor(it)
              itorgrp(itt)=itorgrp(it)+itorgrp((ic-1)*ntorsinp)
c             itorig(itt)=itt
              iri(itt)=1
            end do
          end do
          if (nsltcop*ntorsinp .le. #TR) then
            write (iout,1116)
            ntorsinp=nsltcop*ntorsinp
          end if
        else if (nsltcop .gt. 1) then
          inperr=inperr+1
          write (iout,1120) nsltcop
        end if
      else if (nfixbondtyp .gt. 0) then
        write (iout,1205) ((ntbond(k,i),k=1,2),' ',i=1,nfixbondtyp)
      end if
      imf=1
      if (iop(30) .eq. 1 .or. iop(30) .eq. 2) imf=nstfm0+1
      nloopbranchfound=0
      if (ntorsinp .eq. 0) then
        do im=1,nsttm
          moltused(im)=1
        end do
      else
        call zeroiti(moltused,0,nsttm)
        do it=1,ntorsinp
          if (iquata(it,2) .le. nstta)
     -      moltused(iamolslt(iquata(it,2)))=1
        end do
      end if
      ntoterr=0
      call zeroiti(maxbrlen,0,nsttm)
      do im=imf,nsttm
c       Obtain new atom order based on paths from the molecular center
        if (moltused(im) .eq. 1) then
          nerr=0
c         Check if all atoms in this molecule belong here
          do ia=ifirstm(im),ilastm(im)
            if (iamolslt(ia) .ne. im) nerr=nerr+1
          end do
          if (iop(85) .gt. 0) then
            call clstrs(ineig,nneig,l1,ifirstm(im),ilastm(im),l2,l3,l4,
     -        0,nofcls,indexx,iout,inperr,nww,0,#ST,#MM,#NL,1,1)
            if (nofcls .gt. 1) then
              write (iout,1160) nofcls
              inperr=inperr+1
              nerr=nerr+1
            end if
          end if
          ntoterr=ntoterr+nerr
          ie0=inperr
          if (nerr .eq. 0) then
            call topology(ifirstm(im),ilastm(im),nneig,ineig,ioldplace,
     -        newplace,molcnt(im),iparent,itangon,idistroot,idistend,
     -        idon,nnloop,l1,l2,loopmemat,l3,nflexring,maxbrlen(im),
     -        naflxrange,iaflxrange,iaflxneig,iout,inperr,nwwarn,
     -        #ST,#NL)
          else
            write (iout,1147) im,ifirstm(im),ilastm(im)
            if (ntopwwarn .gt. 0) write (iout,1126) ntopwwarn
            inperr=inperr+1
            moltused(im)=0
          end if
          ntoterr=ntoterr+(inperr-ie0)
        else
          if (iop(24) .gt. 0) write (iout,1148) im
          do ia=ifirstm(im),ilastm(im)
            newplace(ia)=ia
          end do
        end if
      end do
      if (ntoterr .eq. 0 .and. ntopwwarn .gt. 0) write (iout,1149)
      if (nfixbondtyp .gt. 0) then
c       Turn off bonds that are requested to be frozen
        do ia=1,nstta
          if (itangon(ia) .ne. 0) then
            iln=ia
            ikn=iparent(iln)
            il=ioldplace(iln)
            ik=ioldplace(ikn)
            if (idebug(35) .gt. 0)
     -        write (iout,1207) ia,il,ikn,pflabslt(ik),pflabslt(il)
            do ibl=1,nfixbondtyp
              if ((pflabslt(ik) .eq. ntbond(1,ibl) .and.
     -             pflabslt(il) .eq. ntbond(2,ibl)) .or.
     -            (pflabslt(ik) .eq. ntbond(2,ibl) .and.
     -             pflabslt(il) .eq. ntbond(1,ibl))) itangon(ia)=0
            end do
          end if
        end do
      end if
      write (iout,1123) nflexring
      do ia=1,nstta
        l1(ia)=itangon(ia)
        if (iop(91) .gt. 0 .and. itangon(ia) .lt. 0) itangon(ia)=1
      end do
      ndup=0
      if (ntorsinp .gt. 0) then
c       Make sure the torsion bond directions are from the center
        do it=1,ntorsinp
          ik=iquata(it,2)
          il=iquata(it,3)
          if (ik .le. nstta .and. il .le. nstta) then
            if (iparent(newplace(il)) .ne. newplace(ik) .or.
     -          iparent(newplace(il)) .eq. newplace(il)) then
              if (iop(18) .eq. 4 .and. itorgrp(it) .eq. 1)
     -          deldih(it)=-deldih(it)
              iquata(it,2)=il
              iquata(it,3)=ik
              ik=iquata(it,2)
              il=iquata(it,3)
            end if
          end if
        end do
c       Eliminate from the bond list all torsions that were not asked for
        nnonrot=0
        ntdel=0
        do it=1,ntorsinp
          il=iquata(it,3)
          jl=iquata(it,2)
c         Check for duplicate torsions
          idel=0
          iln=0
          do itt=1,it-1
            if (iquata(itt,2) .eq. il .and. iquata(itt,3) .eq. jl .or.
     -          iquata(itt,3) .eq. il .and. iquata(itt,2) .eq. jl) then
              write (iout,1113) il,jl,(labslt(k,il),k=1,2),
     -          (labslt(k,jl),k=1,2),'duplicate'
              nwwarn=nwwarn+1
              idel=1
              ndup=ndup+1
            end if
          end do
          if (nneig(il) .eq. 1 .or. nneig(jl) .eq. 1) then
            write (iout,1113) jl,il,(labslt(k,jl),k=1,2),
     -        (labslt(k,il),k=1,2),'terminal bond'
            nwwarn=nwwarn+1
            idel=1
          end if
          if (iop(61) .gt. 0) then
            if (il .gt. nstta .or. jl .gt. nstta) then
              write (iout,1100) ' ===== STRONG',jl,il,
     -          'involves the map atoms, will be ignored',
     -          it,(labslt(k,jl),k=1,2),(labslt(k,il),k=1,2)
              nwwarn=nwwarn+1
              idel=1
            end if
          end if
          if (idel .eq. 0) then
            iln=newplace(il)
            ilnpar=ioldplace(iparent(iln))
            if (itangon(iln) .eq. 0 .or.  ilnpar .ne. jl) then
              write (iout,1100) ' -----',jl,il,
     -          'not rotatable, will be ignored',
     -          it,(labslt(k,jl),k=1,2),(labslt(k,il),k=1,2)
              idel=1
              nnonrot=nnonrot+1
              write (iout,8954) il,jl,iln,ilnpar,itangon(iln)
8954          format(' il,jl=',2i6,' iln=',i6,' ilnpar=',i6,' iton=',i2)
            end if
          end if
          if (idel .gt. 0) then
            nwarn=nwarn+1
            ntdel=ntdel+1
            iquata(it,3)=0
          else
c           Confirm this torsion
            itangon(iln)=2
            if (loopmemat(il) .ne. 0 .and. torstep(it) .gt. 0.0) then
              write (iout,1100) ' -----',jl,il,
     -          'in a loop, simple torsion stepsize is set to zero',
     -          it,(labslt(k,jl),k=1,2),(labslt(k,il),k=1,2)
              nwarn=nwarn+1
              torstep(it)=0.0
            end if
          end if
        end do
        if (iop(85) .gt. 0 .and. nnonrot .gt. 0) write (iout,1161)
c       Remove all but the confirmed torsion bonds
        do ia=1,nstta
          if (itangon(ia) .gt. 0) itangon(ia)=itangon(ia)-1
        end do
        if (ntdel .gt. 0) then
c         Eliminate dropped bonds from iquata
          ntordrop=0
          do it=1,ntorsinp
            if (iquata(it,3) .eq. 0) then
              ntordrop=ntordrop+1
            else if (ntordrop .gt. 0) then
              do k=1,4
                iquata(it-ntordrop,k)=iquata(it,k)
              end do
              itorgrp(it-ntordrop)=itorgrp(it)
              deldih(it-ntordrop)=deldih(it)
              wtors(it-ntordrop)=wtors(it)
              torstep(it-ntordrop)=torstep(it)
              steploop(it-ntordrop)=steploop(it)
            end if
          end do
          ntorsinp=ntorsinp-ntordrop
          if (ntordrop .gt. 0) then
            if (ntorsinp .eq. 0) then
              write (iout,1150)
              write (iout,1151) 'all'
              inperr=inperr+1
            else
              write (iout,1125) ntorsinp,ntorsinp+ntordrop
              write (iout,1151) 'some'
            end if
            if (ntopwwarn .gt. 0) write (iout,1126) ntopwwarn
            if (ntorsinp .eq. 0) return
          end if
        end if
      end if
      if (ndup .gt. 0) then
        write (iout,1144)
        call datprt(2)
      end if
      imf=1
      if (iop(30) .eq. 3) then
c       addwidom type molecules do have torsions
        imf=nstfm0+1
        do ia=1,nstfa0
          ioldplace(ia)=ia
          newplace(ia)=ia
          iparent(ia)=ia
          itangon(ia)=0
        end do
      end if
      ntang0=0
      ntang=0
      ifirstt(1)=1
      natfx0=0
      do im=imf,nsttm
c       Obtain torsion list corresponding to the tree topology
        ifirstt(im)=ntang+1
        if (moltused(im) .eq. 1) then
          call torsion(ifirstm(im),ilastm(im),molcnt(im),iroots,
     -      natfx0,natfix(im),ioldplace,iparent,itangon,
     -      iprecursor,nnexttorat,nrot,irotlist,irotlinc,itangindx,
     -      itorsionroot,nneig,ineig,ntang0,ntang,idebug(20),iout,
     -      inperr,#TR,#ST,#NL)
        else
          nafix=ilastm(im)-ifirstm(im)+1
          call trnsfi(iroots(natfx0+1),ixislt(ifirstm(im)),nafix)
          natfix(im)=natfx0+nafix
        end if
        ilastt(im)=ntang
        natfx0=natfix(im)
        ntang0=ntang
      end do
c     Set itangon > 0 to the torsion number that it belongs to, with old order
      if (ntorsinp .eq. 0)
     -  call checkdim(ifail,iout,inperr,'TR',ntang,1,1,0)
      call zeroiti(l2,0,nstta)
      do ia=1,nstta
        l2(ia)=itangon(newplace(ia))
      end do
      call trnsfi(itangon,l2,nstta)
      do it=1,ntang
        ia=itangindx(it)
        if (itangon(ia) .eq. 0) then
          write (iout,1121) it
          inperr=inperr+1
        end if
        itangon(ia)=it
      end do
      if (ntorsinp .eq. 0) then
c       Group torsions in a default manner and save a 4-atom description
        ntangorg=ntang
        do it=1,ntang
          ib=itangindx(it)
          itorgrp(it)=iamolslt(ib)
          iquata(it,3)=ib
          iquata(it,4)=irotlist(irotlinc(it)+1)
          iquata(it,2)=iprecursor(1,ib)
          iquata(it,1)=iprecursor(2,iquata(it,3))
          numtorix(it)=it
          deldih(it)=0.0
          wtors(it+1)=1.0
          if (iop(58) .eq. 1) torstep(it)=defrot/rdtodg
          if (iop(58) .gt. 1) torstep(it)=defrot
c         For torsions in loop branches, set normal torsion stepsize to zero
          if (l1(newplace(ib)) .lt. 0 .or.
     -        idistend(ib) .gt. maxtorchain) torstep(it)=0.0
          steploop(it)=deflooprot/rdtodg
          iri(it)=1
        end do
        if (molgopt .eq. 0) then
c         Each molecule has one torsion group
          do it=1,ntang
            itorgrp(it)=iamolslt(itangindx(it))
          end do
        else if (molgopt .eq. 1) then
c         Each torsion is a torsion group
          call indexit(itorgrp,1,ntang,0)
        else if (molgopt .eq. 2) then
c         Each branch of the root is a torsion group
          itg=0
          do iaf=1,natfix(nsttm)
            if (itangon(iroots(iaf)) .gt. 0) then
c             Set all torsions moved by this torsion to the same group
              itg=itg+1
              it0=itangon(iroots(iaf))
              itorgrp(it0)=itg
              do iaa=1,nnexttorat(itangindx(it0))
                ia=irotlist(irotlinc(it0)+iaa)
                if (itangon(ia) .gt. 0) itorgrp(itangon(ia))=itg
              end do
            end if
          end do
          if (idebug(35) .gt. 0) then
            write (iout,7853) (it,itangindx(it),itorgrp(it),it=1,ntang)
            write (iout,7854) (itangon(ia),ia=1,nstta)
7853        format(i5,' itanginx=',i5,' itorgrp=',i4)
7854        format(' itangon=',/,(25i5))
          end if
        end if
      else if (ntang .ne. ntorsinp) then
        write (iout,1102) ntang,ntorsinp
        inperr=inperr+1
      end if
      if (ntang .eq. 0) then
c       No torsions left
        write (iout,1142)
        inperr=inperr+1
      end if
      call indexit(itorig,1,ntang,0)
      if (iop(69) .eq. 1) then
c       Set up itorig
        ntangorg=0
        do im=1,nsttm
          if (icorig(ifirstm(im)) .lt. 0) then
            if (ilastt(im)-ifirstt(im) .ne.
     -          ilastt(imorig)-ifirstt(imorig)) then
              write (iout,1145) im,ifirstt(im),ilastt(im),
     -          imorig,ifirstt(imorig),ilastt(imorig)
            end if
            isg=-1
          else
            it0=ntangorg
            ntangorg=ntangorg+ilastt(im)-ifirstt(im)+1
c           imorig is the solute molecule cloned into the im-th
            imorig=im
            isg=+1
          end if
          do it=ifirstt(im),ilastt(im)
            itorig(it)=isg*(it0+it-ifirstt(im)+1)
          end do
        end do
        write (iout,1157) ntang,ntangorg
        if (idebug(17) .gt. 0)
     -     write (iout,1146) (itorig(it),it=1,ntang)
      else
        ntangorg=ntang
      end if
      if (istune(3) .gt. 0) istune(3)=ntang
      if (istune(4) .gt. 0) istune(4)=ntang
c     Set torsion numtorix to point from old order (if any) to new order
      if (ntorsinp .eq. 0) then
        call indexit(numtorix,1,ntang,0)
      else
        do iti=1,ntorsinp
          do it=1,ntang
            if (itangindx(it) .eq. iquata(iti,3)) numtorix(iti)=it
          end do
        end do
      end if
c     Rearrange torsion list to the new order
      call grouplist(1,ntang,1,0,itorgrp,ntorgrp0,ifdhgrlst,ildhgrlst,
     -  1,#TR,'TR')
      call indexit(l3,1,ntang,0)
      nswap=1
      do while (nswap .gt. 0)
        nswap=0
        do it=2,ntang
          if (numtorix(it) .lt. numtorix(it-1)) then
            nswap=nswap+1
            call swapi(numtorix(it),numtorix(it-1))
            call swapi(l3(it),l3(it-1))
            call swapi(itorgrp(it),itorgrp(it-1))
            do k=1,4
              call swapi(iquata(it,k),iquata(it-1,k))
            end do
            call swapr(deldih(it),deldih(it-1))
            call swapr(torstep(it),torstep(it-1))
            call swapr(steploop(it),steploop(it-1))
            call swapr(wtors(it+1),wtors(it))
            if (iop(116) .gt. 0) then
              call swapr(targetang(it),targetang(it-1))
              call swapi(iskew(it),iskew(it-1))
            end if
          end if
        end do
      end do
c     Check if rearrangement is complete
      do it=1,ntang
        if (numtorix(it) .ne. it) then
          write (iout,1122) it,numtorix(it)
          inperr=inperr+1
        end if
      end do
c     Set out torsion group lists
c     Number of torsion groups: ntorgrp
c     Members of the itg-th torsion group are the torsions from
c     ifdhgrlst(itg) to ildhgrlst(itg)
      call grouplist(1,ntang,1,0,itorgrp,ntorgrp,ifdhgrlst,ildhgrlst,
     -  1,#TR,'TR')
      if (ntorgrp .ne. ntorgrp0) then
        write (iout,2024) ntorgrp0,ntorgrp
        nwwarn=nwwarn+1
      end if
      if (iop(18) .eq. 4) then
        if (ntorsinp .eq. 0) then
          write (iout,1105)
          inperr=inperr+1
        end if
        ntorgrpmf=1
        ntorpmf=ildhgrlst(1)
        itf=ntorpmf+1
      else if (iop(30) .eq. 3) then
        itf=ilastt(nstfm)+1
      else
        ntorpmf=0
        ntorgrpmf=0
        itf=1
      end if
c     From now on numtorix will point back to the original order
      call trnsfi(numtorix,l3,ntang)
c     Assign atoms ia and ib to for full torsion definition ia-ik-il-ib
      do it=1,ntang
        ipeptbb=0
        if (iop(84) .gt. 2) then
c         Make sure peptide BB torsions use all BB atoms
          resnam=labslt(1,iquata(it,2))
          atnam2=labslt(2,iquata(it,2))
          atnam3=labslt(2,iquata(it,3))
c         write (iout,8783) it,(iquata(it,k),k=2,3),resnam,atnam2,atnam2
c8783     format(i4,' IQ2,3=',2i4,' Rr',a,'| a1=',a,' a2=',a,'|')
          if ((atnam2 .eq. ' CA ' .or. atnam2 .eq. 'CA  ') .and.
     -        (atnam3 .eq. ' C  ' .or. atnam3 .eq. 'C   ')) then
            ipeptbb=1
c           Peptide bond (phi), make sure the torsions are BB torsions
            atnam1=labslt(2,iprecursor(2,iquata(it,3)))
            if (atnam1 .eq. ' N  ' .or. atnam1 .eq. 'N   ') then
c             Precursor is ok
              iquata(it,1)=iprecursor(2,iquata(it,3))
            else
              ia1=iquata(it,2)
              iquata(it,1)=0
              do in=1,nneig(ia1)
                ja=ineig(in,ia1)
                atnam1=labslt(2,ja)
                if (atnam1 .eq. ' N  ' .or. atnam1 .eq. 'N   ')
     -            iquata(it,1)=ja
              end do
              if (iquata(it,1) .eq. 0)
     -          iquata(it,1)=iprecursor(2,iquata(it,3))
            end if
            atnam4=labslt(2,irotlist(irotlinc(it)+1))
            if (atnam4 .eq. ' N  ' .or. atnam4 .eq. 'N   ') then
c             First is ok
              iquata(it,4)=irotlist(irotlinc(it)+1)
            else
              iquata(it,4)=0
              irlst1=irotlist(irotlinc(it)+1)
              do itt=2,nrot(it)
                ia4=irotlist(irotlinc(it)+itt)
                atnam4=labslt(2,ia4)
                if (atnam4 .eq. ' N  ' .or. atnam4 .eq. 'N   ') then
                  iquata(it,4)=ia4
                  irotlist(irotlinc(it)+1)=ia4
                  irotlist(irotlinc(it)+itt)=irlst1
                end if
              end do
              if (iquata(it,4) .eq. 0) iquata(it,4)=irlst1
            end if
          else if ((atnam2 .eq. ' N  ' .or. atnam2 .eq. 'N   ') .and.
     -        (atnam3 .eq. ' CA ' .or. atnam3 .eq. 'CA  ')) then
c           Peptide bond (psi), make sure the torsions are BB torsions
            ipeptbb=1
            atnam1=labslt(2,iprecursor(2,iquata(it,3)))
            if (atnam1 .eq. ' C  ' .or. atnam1 .eq. 'C   ') then
c             Precursor is ok
              iquata(it,1)=iprecursor(2,iquata(it,3))
            else
              ia1=iquata(it,2)
              iquata(it,1)=0
              do in=1,nneig(ia1)
                ja=ineig(in,ia1)
                atnam1=labslt(2,ja)
                if (atnam1 .eq. ' C  ' .or. atnam1 .eq. 'C   ')
     -            iquata(it,1)=ja
              end do
              if (iquata(it,1) .eq. 0)
     -          iquata(it,1)=iprecursor(2,iquata(it,3))
            end if
            atnam4=labslt(2,irotlist(irotlinc(it)+1))
            if (atnam4 .eq. ' C  ' .or. atnam4 .eq. 'C   ') then
c             First is ok
              iquata(it,4)=irotlist(irotlinc(it)+1)
            else
              iquata(it,4)=0
              irlst1=irotlist(irotlinc(it)+1)
              do itt=2,nrot(it)
                ia4=irotlist(irotlinc(it)+itt)
                atnam4=labslt(2,ia4)
                if (atnam4 .eq. ' C  ' .or. atnam4 .eq. 'C   ') then
                  iquata(it,4)=ia4
                  irotlist(irotlinc(it)+1)=ia4
                  irotlist(irotlinc(it)+itt)=irlst1
                end if
              end do
              if (iquata(it,4) .eq. 0) iquata(it,4)=irlst1
            end if
          end if
        end if
        if (ipeptbb .eq. 0) then
          iquata(it,1)=iprecursor(2,iquata(it,3))
          iquata(it,4)=irotlist(irotlinc(it)+1)
c         Make sure that the longest chain is followed
          maxlen=0
          ib=iquata(it,3)
          i4ok=0
          do in=1,nneig(ib)
            ina=ineig(in,ib)
            if (idistend(ina) .gt. maxlen .and.
     -          ina .ne. iquata(it,2)) then
              maxlen=idistend(ina)
              i4ok=ina
            end if
          end do
          if (i4ok .ne. iquata(it,4) .and. i4ok .gt. 0) then
            do itt=2,nrot(it)
              if (i4ok .eq. irotlist(irotlinc(it)+itt)) then
                irotlist(irotlinc(it)+itt)=iquata(it,4)
                irotlist(irotlinc(it)+1)=i4ok
              end if
            end do
            iquata(it,4)=i4ok
          end if
        end if
c       write (iout,7681) it,(labslt(2,iquata(it,k)),k=1,4)
c7681   format(i4,' IQUATA:',4(1x,a))
      end do
      do it=1,ntang
c       If the torsion bond includes the root, the precursor info may be wrong
        ing=1
        do while (iquata(it,1) .eq. iquata(it,2) .or.
     -            iquata(it,1) .eq. iquata(it,3))
          iquata(it,1)=ineig(ing,iquata(it,2))
          ing=ing+1
          if (ing .gt. 8) then
            write (iout,1111)
            inperr=inperr+1
            go to 108
          end if
        end do
      end do
c     maptors: array of labels for atoms affected by torsion
108   do i=1,nstta
        maptors(i)=0
      end do
      call zeroiti(looptyp,0,ntang)
c     call zeroiti(numsol,0,ntang)
      if (iop(91) .gt. 0) then
c       Establish loop descriptions
        nlooptyp=9
        call checkdim(ifail,iout,inperr,'LT',ntang,1,1,0)
c       Find the torsion number for all solute atoms with torsion
        call zeroiti(l2,0,nstta)
        do it=1,ntang
          l2(newplace(iquata(it,3)))=it
        end do
        call zeroiti(itparent,0,ntang)
        do it=1,ntang
c         Backtrack from this torsion until the root or an other torsion
          iaitn=iparent(newplace(iquata(it,3)))
          do while (iparent(iaitn) .ne. iaitn .and.
     -              itangon(ioldplace(iaitn)) .eq. 0)
            iaitn=iparent(iaitn)
          end do
          if (itangon(ioldplace(iaitn)) .gt. 0) itparent(it)=l2(iaitn)
c         itparent(it) is now the next torsion from it toward the root (parent)
          loopmem(it)=loopmemat(iquata(it,3))
c         loopmem(it) is the loopnumber for torsions within a flexible loop
        end do
        if (idebug(35) .gt. 0) write (iout,1153)
     -    (it,iquata(it,2),iquata(it,3),loopmem(it),itparent(it),
     -    it=1,ntang)
        call zeroiti(l2,0,ntang)
c       Gather the 6 consecutive torsions of a loop moved by looptyps
        do it=1,ntang
          itt=it
          ita=iquata(it,3)
          lend=idistend(ita)
          l4(1)=itt
          nmem=1
          itpar=itparent(itt)
          do while (nmem .lt. 6 .and. itpar .gt. 0)
            if (loopmemat(iquata(itt,3)) .eq.
     -          loopmemat(iquata(itpar,3))) then
c             loopmemat(ia) is listccfl in topology - the flexible loop number
c             Loops can not go through branches
              itt=itparent(itt)
              itpar=itparent(itt)
              nmem=nmem+1
              l4(nmem)=itt
            else
              itpar=-1
            end if
          end do
          if (itpar .gt. 0) then
            if (loopmemat(iquata(itt,3)) .ne.
     -          loopmemat(iquata(itpar,3))) itpar=-1
          end if
          if (itpar .gt. 0) then
            if (idebug(35) .gt. 1)
     -        write (iout,1154) it,itpar,(l4(7-i),i=1,6)
            itt=itpar
            if (steploop(itt) .ne. 0.0) then
c             Movable loop found with nonzero stepsize
              looptyp(itt)=1
c             Save this loop if the end of the chain is farther from its root
c             than an earlier found loop
              itta=iquata(itt,3)
              lendrootn=lend+iabs(idistroot(ita)-idistroot(itta))
              if (lendrootn .gt. l2(itt) .or. (lendrootn .eq. l2(itt)
     -            .and. looplist(6,itt) .lt. it)) then
                l2(itt)=lendrootn
                do iit=1,6
                  looplist(iit,itt)=l4(7-iit)
                end do
              end if
            end if
          end if
        end do
        do il1=1,ntang
          do il2=il1+1,ntang
            if (looptyp(il1)*looptyp(il2) .ne. 0) then
c             Check if loop starting at il1 and il2 form a branch
              call loopmatch(il1,il2,looplist,iquata,labslt,loopdel,
     -          iop(24),iout,ntang,nstta)
              if (loopdel .eq. 0)
     -          call loopmatch(il2,il1,looplist,iquata,labslt,loopdel,
     -            iop(24),iout,ntang,nstta)
              if (loopdel .gt. 0) then
c               Remove loop loopdel
                looptyp(loopdel)=0
                call zeroiti(looplist(1,loopdel),0,6)
              end if
            end if
          end do
        end do
        do it=1,ntang
          if (looptyp(it) .ne. 0) then
c           Ensure that all iquata(it,4) in a loop are on a bonded chain
            itprev=it
            do ilst=1,6
              if (ilst .gt. 1) itprev=looplist(ilst-1,it)
              itcurr=looplist(ilst,it)
              i3=iquata(itcurr,3)
              i3n=newplace(i3)
              i3pn=newplace(iquata(itprev,3))
              if (iquata(itcurr,3) .ne. iquata(itprev,4)) then
c               Find a predecessor of i3 whose parent is i4 and set
c               iquata(itprev,4) to it - also make the swap in irotlist
                if (newplace(iquata(itprev,3)) .eq. iparent(i3n)) then
c                 Set iquata(itprev,4) to iquata(itcurr,3)
                  i4ok=i3
                else
c                 Backtrack from i3 to i3p
                  do while (iparent(i3n) .ne. i3pn
     -              .and. iparent(i3n) .ne. 1)
                    i3n=iparent(i3n)
                  end do
                  i4ok=ioldplace(i3n)
                end if
                do itt=2,nrot(itprev)
                  if (irotlist(irotlinc(itprev)+itt) .eq. i4ok) then
c                   Swap 1 and itt
                    if (idebug(6) .gt. 0) write (iout,1137) i4ok,
     -                iquata(itprev,4),irotlist(irotlinc(itprev)+1),itt
                    irotlist(irotlinc(itprev)+itt)=
     -                irotlist(irotlinc(itprev)+1)
                    irotlist(irotlinc(itprev)+1)=i4ok
                    iquata(itprev,4)=i4ok
                  end if
                end do
                if (i4ok .ne. iquata(itprev,4)) then
                  irootfound=0
                  do iaf=1,natfix(nsttm)
                    if (iroots(iaf) .eq. i4ok) irootfound=1
                  end do
                  if (irootfound .eq. 1) then
                    iquata(itprev,4)=i4ok
                  else
                    write (iout,1136) itprev,i4ok,iquata(itprev,4)
                    inperr=inperr+1
                  end if
                end if
              end if
            end do
          end if
        end do
        if (idebug(35) .gt. 0) then
          do it=1,ntang
            if (looptyp(it) .ne. 0)
     -        write (iout,2012) it,(looplist(iit,it),
     -          (iquata(looplist(iit,it),k),k=1,4),iit=1,6)
          end do
        end if
c       Drop loops for loop types not implemented
        do it=1,ntang
          if (looptyp(it) .ne. 0) then
c           Count gaps, find gap atoms
            iatnew(1)=newplace(iquata(it,3))
            do k=1,6
              iatnew(k+1)=newplace(iquata(looplist(k,it),3))
            end do
            if (idebug(35) .gt. 0) write (iout,2014) it,iatnew
            nbskiptot=0
            k=7
            iamid(k)=0
            nbskip(k)=0
            do while (k .ge. 2)
              iatmid=iatnew(k)
              nbskip(k-1)=0
              do while (iparent(iatmid) .ne. iatnew(k-1))
                nbskip(k-1)=nbskip(k-1)+1
                iatmid=iparent(iatmid)
                nbskiptot=nbskiptot+1
              end do
              iamid(k-1)=ioldplace(iatmid)
              k=k-1
            end do
            looptyp(it)=0
            if (nbskiptot .eq. 0 .and.
     -          iquata(looplist(1,it),3) .eq. iquata(it,4)) then
c             Consecutive torsions
              looptyp(it)=1
            else if (nbskiptot .eq. 3) then
c             Tripeptide
              if (nbskip(2)+nbskip(4)+nbskip(6) .eq. 3 .and.
     -          nbskip(2)*nbskip(4)*nbskip(6) .eq. 1) then
c               Peptide bond, 3[-=-]
                looptyp(it)=2
              else if (nbskip(1)+nbskip(3)+nbskip(5) .eq. 3 .and.
     -          nbskip(1)*nbskip(3)*nbskip(5) .eq. 1) then
c               Peptide bond, 3[=--]
                looptyp(it)=3
              end if
            else if (nbskiptot .eq. 1) then
c             Consecutve bonds except for one intervening frozen one (proline)
              ltp=0
              do ib=1,6
                ltp=ltp+ib*nbskip(ib)
              end do
              looptyp(it)=3+ltp
            end if
c           Other types?
            if (idebug(35) .gt. 0)
     -        write (iout,2013) it,looptyp(it),(k,nbskip(k),iamid(k),
     -        ioldplace(iatnew(k)),iatnew(k),k=1,7)
          end if
        end do
c       Establish list of side-chain torsions
        ifsctlist(1)=1
        call zeroiti(ilsctlist,0,ntang)
        do it=1,ntang
          nsave=0
          if (looptyp(it) .ne. 0) then
c           Gather list of side-chain torsions
            do iii=1,nrot(it)
              iiia=irotlist(irotlinc(it)+iii)
              if (itangon(iiia) .ne. 0) then
                if (itangon(iiia) .ne. looplist(1,it)) then
c                 Side chain torsion found on iiia
                  isctlist(ifsctlist(it)+nsave)=itangon(iiia)
                  nsave=nsave+1
                end if
              end if
            end do
            do ii=1,5
              iit=looplist(ii,it)
              do iii=1,nrot(iit)
                iiia=irotlist(irotlinc(iit)+iii)
                if (itangon(iiia) .ne. 0) then
                  if (itangon(iiia) .ne. looplist(ii+1,it)) then
c                   Side chain torsion found on iiia
                    isctlist(ifsctlist(it)+nsave)=itangon(iiia)
                    nsave=nsave+1
                  end if
                end if
              end do
            end do
          end if
          if (nsave .gt. 0) ilsctlist(it)=ifsctlist(it)+nsave-1
          if (it .lt. ntang) ifsctlist(it+1)=ifsctlist(it)+nsave
        end do
        if (idebug(35) .gt. 0) then
          write (iout,2021)
          do it=1,ntang
            if (ilsctlist(it) .ge. ifsctlist(it)) write (iout,2018) it,
     -        (isctlist(ii),ii=ifsctlist(it),ilsctlist(it))
          end do
        end if
        call zeroiti(looptypcnt,0,nlooptyp)
        ntotloop=0
        do it=1,ntang
          if (looptyp(it) .gt. 0) then
            looptypcnt(looptyp(it))=looptypcnt(looptyp(it))+1
            ntotloop=ntotloop+1
          end if
        end do
      end if
      do it=itf,ntang
c       Set wtors->0 if both loop and simple torsions are disabled
        if (looptyp(it) .eq. 0 .and. (torstep(it) .eq. 0.0 .or.
     -      l1(newplace(iquata(it,3))) .lt. 0)) wtors(it+1)=999.99
      end do
      call zeroiti(l1,0,ntang)
      do it=itf,ntang
c       Mark torsions that are movable part of a loop
        if (looptyp(it) .gt. 0) then
          do itt=1,6
            l1(looplist(itt,it))=looplist(6,it)-1
          end do
        end if
      end do
      do it=itf,ntang
c       Keep only the non-driver torsions in the list
        if (looptyp(it) .gt. 0) l1(it)=0
      end do
c     Collect the set of atoms moved by a torsion group
c     The atoms moved by the torsions belonging to the torsion group itg
c     are stored in lsttorgrp between iftorgrp(itg) and iltorgrp(itg)
      ntors=0
      nlist=0
      nfail=0
      nfailg=0
      call trnsfi(nnexttormov,nnexttorat,nstta)
      do itg=1,ntorgrp
        it=ifdhgrlst(itg)
        if (wtors(it+1) .gt. 0.0 .or. l1(it) .gt. 0) then
          natsitg1=nnexttorat(itangindx(it))
          if (idebug(68) .eq. 0) then
            if (torstep(it) .eq. 0.0) then
              if (it .eq. ildhgrlst(itg) .and. looptyp(it) .gt. 0 .or.
     -           wtors(it+1) .eq.  0.0 .and. l1(it) .gt. 0) then
c               For torsions sampled in loop moves only limit the atom list used
c               for energy calculations to atoms moved by the loop
                if (l1(it) .eq. 0) then
                  it5=looplist(6,it)-1
                else
                  it5=l1(it)
                end if
                llastloop=irotlinc(it5)+nrot(it5)
                lmaxloop=irotlinc(it5)+
     -            nnexttorat(itangindx(it5))
c               Find the last member of this group
                iglast=igrslt(irotlist(llastloop))
                do while (iglast .eq. igrslt(irotlist(llastloop)) .and.
     -                    llastloop .lt. lmaxloop)
                  llastloop=llastloop+1
                end do
                if (llastloop .lt. lmaxloop) llastloop=llastloop-1
                natsitg1=llastloop-irotlinc(it)
                nnexttormov(itangindx(it))=natsitg1
              end if
            end if
          end if
c         The atoms of the first torsion (i.e., it) of the group are just copied
          call addtorlist(it,lsttorgrp,ntors,nlist,wtors,natsitg1,
     -      irotlist,irotlinc,maptors,iout,inperr,nfail,
     -       #TR,#TA,#ST)
        end if
        do it=ifdhgrlst(itg)+1,ildhgrlst(itg)
          call addtorlist(it,lsttorgrp,ntors,nlist,wtors,
     -      nnexttorat(itangindx(it)),irotlist,irotlinc,
     -      maptors,iout,inperr,nfail,#TR,#TA,#ST)
        end do
        if (iop(91) .gt. 0) then
          do it=ifdhgrlst(itg),ildhgrlst(itg)
            do ii=ifsctlist(it),ilsctlist(it)
              jt=isctlist(ii)
              call addtorlist(jt,lsttorgrp,ntors,nlist,wtors,
     -          nnexttorat(itangindx(jt)),irotlist,irotlinc,
     -          maptors,iout,inperr,nfail,#TR,#TA,#ST)
            end do
          end do
        end if
        if (iop(58) .gt. 0 .or. iop(18) .eq. 4) then
          do iaa=ntors+1,nlist
            ia=lsttorgrp(iaa)
            isltmv(ia)=2
            ia0=ia
            if (iop(30) .ge. 7) ia0=ia-nstfa1
c           For PMF calculations all copies move together
            if (nsltcp(iop(30)+1) .eq. 3) then
              if (nstfa0+ia0 .le. nstfa) isltmv(nstfa0+ia0)=2
              if (nstfa1+ia0 .le. nstfa) isltmv(nstfa1+ia0)=2
            end if
          end do
        end if
        indexx(itg)=nlist
        if (iop(65) .eq. 3 .or. iop(65) .eq. 4) then
c         When group PBC is used and group center is moved, use full group
c         First, gather list of groups appearing in this torsion group
          ngrps=0
          do ia=ntors+1,nlist
            igi=igrslt(lsttorgrp(ia))
            do ig=1,ngrps
              if (igi .eq. l2(ig)) go to 107
            end do
            ngrps=ngrps+1
            l2(ngrps)=igi
107         continue
          end do
c         Now, see if the groups used have their centers left unmoved
          do ig=1,ngrps
            do ia=ntors+1,nlist
              if (lsttorgrp(ia) .eq. igrcnt(l2(ig))) go to 111
            end do
            l2(ig)=0
111         continue
          end do
c         Finally, add the requested group elements to lsttorgrp
          do ig=1,ngrps
            if (l2(ig) .ne. 0) then
              nlist0=nlist
              do iag=ifgrslt(l2(ig)),ilgrslt(l2(ig))
                do iaa=ntors+1,nlist0
                  if (lsttorgrp(iaa) .eq. iag) go to 112
                end do
c               Group element not found, add
                nlist=nlist+1
                call checkdim(ifail,iout,inperr,'TA',nlist,1,0,nfail)
                if (ifail .eq. 1) nfail=nfail+1
                lsttorgrp(nlist)=iag
112             continue
              end do
            end if
          end do
        end if
        iftorgrp(itg)=ntors+1
        iltorgrp(itg)=nlist
        if (iop(112) .eq. 2) then
c         Add atoms to the list that are bonded to R-O-R type acceptors
c         if they are not on the list
          naddat=0
          do iaa=iftorgrp(itg),iltorgrp(itg)
            ia=lsttorgrp(iaa)
            do in=1,nneig(ia)
              ja=ineig(in,ia)
              if (ihbdonacc(ja) .eq. -2) then
c               R-O-R acceptor
                ifound=0
                do ii=iftorgrp(itg),iltorgrp(itg)+naddat
                  if (ja .eq. lsttorgrp(ii)) ifound=1
                end do
                if (ifound .eq. 0) then
                  naddat=naddat+1
                  lsttorgrp(iltorgrp(itg)+naddat)=ja
                end if
              end if
            end do
          end do
          ilhbtorgrp(itg)=iltorgrp(itg)+naddat
          nlist=nlist+naddat
          if (naddat .gt. 0) write (iout,2025) itg,naddat,
     -      (lsttorgrp(i),i=iltorgrp(itg)+1,ilhbtorgrp(itg))
        else
          ilhbtorgrp(itg)=iltorgrp(itg)
        end if
        ntors=nlist
      end do
      do it=itf,ntang
c       Set wtors->0 if it was set to 999.99 above
        if (wtors(it+1) .eq. 999.99) wtors(it+1)=0.0
      end do
c     Now find the torsion angle limits for each torsion group
      do itg=1,ntorgrp
c       First find the torsion range (in the new order) of this group
        iftmovtg(itg)=#TR
        iltmovtg(itg)=1
        do it=ifdhgrlst(itg),ildhgrlst(itg)
          if (iftmovtg(itg) .gt. it) iftmovtg(itg)=it
          if (iltmovtg(itg) .lt. it) iltmovtg(itg)=it
        end do
c       Now check if any of the co-rotated atoms bring in more
        im=iamolslt(iquata(ifdhgrlst(itg),4))
        itmax=iltmovtg(itg)
        do it=iltmovtg(itg)+1,ilastt(im)
          ia=itangindx(it)
c         See if the torsion atom of torsion it is a co-rotated atom
          do ja=iftorgrp(itg),indexx(itg)
            if (ia .eq. lsttorgrp(ja)) then
              itmax=it
              go to 113
            end if
          end do
113       continue
        end do
        iltmovtg(itg)=itmax
      end do
c     Now sort list of moved atoms
      do itg=1,ntorgrp
        if (iltorgrp(itg) .gt. iftorgrp(itg)) then
          do ii=iftorgrp(itg),iltorgrp(itg)
            cv1(ii-iftorgrp(itg)+1)=lsttorgrp(ii)
          end do
          call mrgsrt(iout,lsttorgrp(iftorgrp(itg)),cv1,
     -     iltorgrp(itg)-iftorgrp(itg)+1,l2,l3,l4,cv2,#UV)
        end if
      end do
      if (idebug(6) .ge. 1) write (iout,2020) (isltmv(i),i=1,nstta)
      ntormovgr=0
      do itg=1,ntorgrp
c       Sort torsion lists by solute group (shell sort)
        nsw=1
        nsw=iltorgrp(itg)-iftorgrp(itg)-1
        do while (nsw .gt. 0)
          nsw=0
          do ia=iftorgrp(itg)+1,iltorgrp(itg)
            if (igrslt(lsttorgrp(ia)) .lt. igrslt(lsttorgrp(ia-1))) then
              ixx=lsttorgrp(ia)
              lsttorgrp(ia)=lsttorgrp(ia-1)
              lsttorgrp(ia-1)=ixx
              nsw=1
            end if
          end do
        end do
c       Collect group limits within torsion groups
c       There are ntormovgr groups within the torsion groups. These groups
c       are generally subgroups of the solute groups. Each such subgroup i
c       has its atomlist in lsttorgrp between iftormovgra(i) and
c       iltormovgra(i). The subgroups belonging to a torsion group itg are
c       between iftormovgrgr(itg) and iltormovgrgr(itg).
        ntormovgr=ntormovgr+1
        call checkdim(ifail,iout,inperr,'TL',ntormovgr,1,0,nfailg)
        if (ifail .eq. 1) nfailg=nfailg+1
        iftormovgra(ntormovgr)=iftorgrp(itg)
        iftormovgrgr(itg)=ntormovgr
        if (iop(43) .gt. 0) then
c         Only split into groups when group cutoff is used!
          do ia=iftorgrp(itg)+1,iltorgrp(itg)
            if (igrslt(lsttorgrp(ia)) .gt. igrslt(lsttorgrp(ia-1))) then
              iltormovgra(ntormovgr)=ia-1
              ntormovgr=ntormovgr+1
              call checkdim(ifail,iout,inperr,'TL',ntormovgr,1,0,nfailg)
              if (ifail .eq. 1) nfailg=nfailg+1
              iftormovgra(ntormovgr)=ia
            end if
          end do
        end if
        iltormovgra(ntormovgr)=iltorgrp(itg)
        iltormovgrgr(itg)=ntormovgr
        if (iftormovgra(ntormovgr) .gt. iftormovgra(ntormovgr))
     -    iltormovgrgr(itg)=iltormovgrgr(itg)-1
      end do
c     Find the torsion group limits for each molecule and
c     Find the atom limits for the 1-4 neighbor for each torsion group and molec
      do im=1,nsttm
        nmtmn(im)=ntorgrp
        nmtmx(im)=0
      end do
      do itg=1,ntorgrp
        im=iamolslt(iquata(ifdhgrlst(itg),4))
        if (nmtmn(im) .gt. itg) nmtmn(im)=itg
        if (nmtmx(im) .lt. itg) nmtmx(im)=itg
      end do
c     Set pf call info for torsion groups
      call zeroiti(itpused,0,11)
      do itg=1,ntorgrp
c       Check if torsions of a group are on the same molecule or branch
        iat1=iquata(ifdhgrlst(itg),3)
        imoltg=iamolslt(iat1)
        iroottg=molcnt(imoltg)
        wtorg=wtors(ifdhgrlst(itg)+1)
        do it=ifdhgrlst(itg)+1,ildhgrlst(itg)
          wtorg=wtorg+wtors(it+1)
          iat=iquata(it,3)
          imolt=iamolslt(iat)
          if (imolt .ne. imoltg) then
            write (iout,1101) it,itg
            inperr=inperr+1
          else
            ipiat=ioldplace(iparent(newplace(iat)))
            do while (ipiat .ne. iat1 .and. ipiat .ne. iroottg)
              iat=ipiat
              ipiat=ioldplace(iparent(newplace(iat)))
            end do
          end if
          if (iat .eq. iroottg) then
            write (iout,2019) ifdhgrlst(itg),it
            nwwarn=nwwarn+1
          end if
        end do
        if (wtorg .gt. 0.0 .or. iop(58) .eq. 0) then
          do isg=iftormovgrgr(itg),iltormovgrgr(itg)
            ipft=iopslt(lsttorgrp(iftormovgra(isg)))
            itpused(ipft)=itpused(ipft)+1
            ipftor(isg)=ipfgr(igrslt(lsttorgrp(iftormovgra(isg))))
c           PF call type should be the same for all atoms in subgroup
            do ia=iftormovgra(isg),iltormovgra(isg)
              if (ipfgr(igrslt(lsttorgrp(ia))) .ne. ipftor(isg)) then
                write (iout,1204)
     -            ia,itg,isg,ipfgr(igrslt(lsttorgrp(ia))),ipftor(isg)
                inperr=inperr+1
              end if
            end do
          end do
        end if
      end do
c     For torsions in flexible loops, modify list of the list two members
c     of the last loop
      do it=1,ntang
        if (loopmem(it)*looptyp(it) .gt. 0) then
          if (looptyp(looplist(1,it)) .eq. 0) then
c           Immobilize last torsion completely
c           nrot(looplist(6,it))=0
            torstep(looplist(6,it))=0.0
            if (iop(24) .gt. 0) then
              write (iout,2023) it,loopmem(it),looplist(6,it)
            end if
          end if
        end if
      end do
      if (max0(nfail,nfailg) .gt. 0)
     -   write (iout,1130) 'TA',#TA+max0(nfail,nfailg)
      if (idebug(6) .ge. 1) then
        do im=1,nsttm
          write (iout,2004) im,(maptors(ia),ia=ifirstm(im),ilastm(im))
          write (iout,2005)im,ifirstt(im),ilastt(im),nmtmn(im),nmtmx(im)
        end do
        do itg=1,ntorgrp
          write (iout,2001) itg,ifdhgrlst(itg),ildhgrlst(itg),
     -      iftmovtg(itg),iltmovtg(itg)
          write (iout,2002) itg,iftorgrp(itg),iltorgrp(itg),
     -      (lsttorgrp(ia),ia=iftorgrp(itg),iltorgrp(itg))
          do isg=iftormovgrgr(itg),iltormovgrgr(itg)
            write (iout,2003) itg,isg,
     -        iftormovgra(isg),iltormovgra(isg),ipftor(isg),
     -        (lsttorgrp(ia),ia=iftormovgra(isg),iltormovgra(isg))
          end do
        end do
        do it=1,ntang
          write (iout,2011) it,irotlinc(it),newplace(itangindx(it)),
     -      nnexttormov(itangindx(it)),nrot(it),loopmem(it),
     -      (irotlist(irotlinc(it)+ia),ia=1,nrot(it))
          write (iout,2022)
     -     (isltmv(irotlist(irotlinc(it)+ia)),ia=1,nrot(it))
        end do
      end if
      if (iop(91) .gt. 0) then
c       Loop move setup check and constant calculations
c       Check for overlap of torsions with loops in a group
        do itg=1,ntorgrp
          if (ildhgrlst(itg)-ifdhgrlst(itg) .gt. 0) then
            do it=ifdhgrlst(itg)+1,ildhgrlst(itg)
              if (looptyp(it) .ne. 0) then
                do k=1,6
                  do itt=ifdhgrlst(itg),it-1
                    if (looptyp(itt) .eq. 0) then
                      if (looplist(k,it) .eq. itt) then
                        write (iout,1134) looplist(k,it),it,itt,itg
                        inperr=inperr+1
                      end if
                    else
                      do kk=1,6
                        if (looplist(k,it) .eq. looplist(kk,itt)) then
                          write (iout,1135) looplist(k,it),it,itt,itg
                          inperr=inperr+1
                        end if
                      end do
                    end if
                  end do
                end do
              end if
            end do
          end if
        end do
c       Calculate the pre-fixed quantities for torsion loops
        call zeroitd(dscis,ntang)
        call zeroitd(dstrans,ntang)
        call zeroitd(dflsmin,ntang)
        call zeroitd(dflsmax,ntang)
        do it=1,ntang
          if (looptyp(it) .gt. 0)
     -      call getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,i6,
     -        ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,looptyp(it),
     -        idebug(79),iout,'TORSIONSET',#TR,#LT)
          if (looptyp(it) .eq. 1) then
c           Consecutive bonds
            call arrdistsd(cslt(1,i0),cslt(1,i2),dst,d02(it))
            call arrdistsd(cslt(1,i1),cslt(1,i2),dst,d12(it))
            call arrdistsd(cslt(1,i1),cslt(1,i3),dst,d13(it))
            call arrdistsd(cslt(1,i2),cslt(1,i3),dst,d23(it))
            call arrdistsd(cslt(1,i2),cslt(1,i4),dst,d24(it))
            call arrdistsd(cslt(1,i3),cslt(1,i4),dst,d34(it))
            call arrdistsd(cslt(1,i3),cslt(1,i5),dst,d35(it))
            call arrdistsd(cslt(1,i4),cslt(1,i5),dst,d45(it))
            call arrdistsd(cslt(1,i4),cslt(1,i6),dst,d46(it))
            call arrdistsd(cslt(1,i5),cslt(1,i6),dst,d56(it))
            call arrdistsd(cslt(1,i0),cslt(1,i1),dst,d01)
            call d14minmaxct(d13(it),d01,d12(it),d02(it),d23(it),
     -        dscis(it+2),dstrans(it+2),dextol)
            call d14minmaxct(d46(it),d34(it),d45(it),d35(it),d56(it),
     -        dscis(it+5),dstrans(it+5),dextol)
              call arrdistsd(cslt(1,i0),cslt(1,i3),dst,d01)
              if (d01 .lt. dscis(it+2) .or. d01 .gt. dstrans(it+2))
     -          write (iout,1114) 1,4,it,it+2,d01,dst,
     -            dscis(it+2),dstrans(it+2),' ',i0,i1,i2,i3,i4,i5
              call arrdistsd(cslt(1,i3),cslt(1,i6),dst,d01)
              if (d01 .lt. dscis(it+5) .or. d01 .gt. dstrans(it+5))
     -          write (iout,1114) 1,4,it,it+5,d01,dst,
     -            dscis(it+5),dstrans(it+5),' ',i0,i1,i2,i3,i4,i5
            call d04maxex(d12(it),d13(it),d23(it),d24(it),d34(it),
     -        d35(it),d45(it),dflsmin(it),dflsmax(it),pi,dextol)
            call arrdistsd(cslt(1,i1),cslt(1,i5),dst,d01)
            if (d01 .lt. dflsmin(it) .or. d01 .gt. dflsmax(it)) then
              write (iout,1114) 1,5,it,it,d01,dst,
     -          dflsmin(it),dflsmax(it),' ',i0,i1,i2,i3,i4,i5
            else if (idebug(79) .gt. 1) then
              write (iout,1139) it,dflsmin(it),dflsmax(it),dsqrt(d01),
     -          dscis(it),dstrans(it)
            end if
          else if (looptyp(it) .eq. 2) then
c           Peptide bonds (-=-)
            call arrdistsd(cslt(1,ii0),cslt(1,ii2),dst,d02(it))
            call arrdistsd(cslt(1,ii0),cslt(1,ii3),dst,d03(it))
            call arrdistsd(cslt(1,ii1),cslt(1,ii2),dst,d12(it))
            call arrdistsd(cslt(1,ii1),cslt(1,ii3),dst,d13(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii3),dst,d23(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii4),dst,d24(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii4),dst,d34(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii5),dst,d35(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii6),dst,d36(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii5),dst,d45(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii6),dst,d46(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii6),dst,d56(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii7),dst,d57(it))
            call arrdistsd(cslt(1,ii6),cslt(1,ii7),dst,d67(it))
            call arrdistsd(cslt(1,ii6),cslt(1,ii8),dst,d68(it))
            call arrdistsd(cslt(1,ii6),cslt(1,ii9),dst,d69(it))
            call arrdistsd(cslt(1,ii7),cslt(1,ii8),dst,d78(it))
            call arrdistsd(cslt(1,ii7),cslt(1,ii9),dst,d79(it))
            if (idebug(71) .gt. 1) write (iout,2015) it,ii0,ii1,ii2,
     -        ii3,ii4,ii5,ii6,ii7,ii8,ii9,d02(it),d03(it),
     -        d12(it),d13(it),d23(it),d24(it),d34(it),d35(it),
     -        d36(it),d45(it),d46(it),d56(it),d57(it),d67(it),
     -        d68(it),d69(it),d78(it),d79(it)
            call d16maxex(d12(it),d23(it),d34(it),d45(it),d56(it),
     -        d13(it),d24(it),d35(it),d46(it),dflsmin(it),dflsmax(it),
     -        dextol)
            dxy=arrdist(cslt(1,ii1),cslt(1,ii6))
            dxyr=arrdist(cslt(1,ii3),cslt(1,ii8))
            call d16maxex(d78(it),d67(it),d56(it),d45(it),d34(it),
     -        d68(it),d57(it),d46(it),d35(it),dflsminr(it),dflsmaxr(it),
     -        dextol)
c           For double bonds, make sure backbone atoms are the first 2 in list
            call swaprot(nrot(looplist(1,it)),irotlinc(looplist(1,it)),
     -        irotlist,ii2)
            call swaprot(nrot(looplist(3,it)),irotlinc(looplist(3,it)),
     -        irotlist,ii5)
            call swaprot(nrot(looplist(5,it)),irotlinc(looplist(5,it)),
     -        irotlist,ii8)
          else if (looptyp(it) .eq. 3) then
c           Peptide bonds (=--)
            call arrdistsd(cslt(1,ii1),cslt(1,ii2),dst,d12(it))
            call arrdistsd(cslt(1,ii1),cslt(1,ii3),dst,d13(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii3),dst,d23(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii4),dst,d24(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii5),dst,d25(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii4),dst,d34(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii5),dst,d35(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii5),dst,d45(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii6),dst,d46(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii6),dst,d56(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii7),dst,d57(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii8),dst,d58(it))
            call arrdistsd(cslt(1,ii6),cslt(1,ii7),dst,d67(it))
            call arrdistsd(cslt(1,ii6),cslt(1,ii8),dst,d68(it))
            call arrdistsd(cslt(1,ii7),cslt(1,ii8),dst,d78(it))
            call arrdistsd(cslt(1,ii7),cslt(1,ii9),dst,d79(it))
            call d16maxex(d23(it),d34(it),d45(it),d56(it),d67(it),
     -        d24(it),d35(it),d46(it),d57(it),dflsmin(it),dflsmax(it),
     -        dextol)
            call d16maxex(d78(it),d67(it),d56(it),d45(it),d34(it),
     -        d68(it),d57(it),d46(it),d35(it),dflsminr(it),dflsmaxr(it),
     -        dextol)
            dxy=arrdist(cslt(1,ii2),cslt(1,ii7))
            dxyr=arrdist(cslt(1,ii3),cslt(1,ii8))
            if (idebug(71) .gt. 1) write (iout,2016) it,ii1,ii2,
     -        ii3,ii4,ii5,ii6,ii7,ii8,ii9,d02(it),d12(it),d13(it),
     -        d23(it),d24(it),d25(it),d34(it),d35(it),d45(it),d46(it),
     -        d56(it),d57(it),d58(it),d67(it),d68(it),d78(it),d79(it)
c           Four double bonds, make sure backbone atoms are the first 2 in list
            call swaprot(nrot(looplist(2,it)),irotlinc(looplist(2,it)),
     -        irotlist,ii4)
            call swaprot(nrot(looplist(4,it)),irotlinc(looplist(4,it)),
     -        irotlist,ii7)
          else if (looptyp(it) .gt. 3) then
c           Consecutive bonds with one frozen break (proline)
            call arrdistsd(cslt(1,ii0),cslt(1,ii1),dst,d01)
            call arrdistsd(cslt(1,ii0),cslt(1,ii2),dst,d02(it))
            call arrdistsd(cslt(1,ii0),cslt(1,ii3),dst,d03(it))
            call arrdistsd(cslt(1,ii1),cslt(1,ii2),dst,d12(it))
            call arrdistsd(cslt(1,ii1),cslt(1,ii3),dst,d13(it))
            call arrdistsd(cslt(1,ii1),cslt(1,ii4),dst,d14(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii3),dst,d23(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii4),dst,d24(it))
            call arrdistsd(cslt(1,ii2),cslt(1,ii5),dst,d25(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii4),dst,d34(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii5),dst,d35(it))
            call arrdistsd(cslt(1,ii3),cslt(1,ii6),dst,d36(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii5),dst,d45(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii6),dst,d46(it))
            call arrdistsd(cslt(1,ii4),cslt(1,ii7),dst,d47(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii6),dst,d56(it))
            call arrdistsd(cslt(1,ii6),cslt(1,ii7),dst,d67(it))
            call arrdistsd(cslt(1,ii5),cslt(1,ii7),dst,d57(it))
            if (looptyp(it) .eq. 4) then
              itswap=it
              iaswap=ii2
            else if (looptyp(it) .eq. 5) then
              itswap=looplist(1,it)
              iaswap=ii3
            else if (looptyp(it) .eq. 6) then
              itswap=looplist(2,it)
              iaswap=ii4
            else if (looptyp(it) .eq. 7) then
              itswap=looplist(3,it)
              iaswap=ii5
            else if (looptyp(it) .eq. 8) then
              itswap=looplist(4,it)
              iaswap=ii6
            else if (looptyp(it) .eq. 9) then
              itswap=looplist(5,it)
              iaswap=ii7
            end if
            call dxymaxex(d12(it),d23(it),d34(it),d45(it),d13(it),
     -        d24(it),d35(it),cslt(1,ii1),cslt(1,ii2),cslt(1,ii3),
     -        cslt(1,ii4),cslt(1,ii5),dflsmin(it),dflsmax(it),
     -        dextol,it,looptyp(it),iout,nwarn,inperr)
c           Calculate the limits for the loop propagated from the reverse
            if (looptyp(it) .eq. 4) then
              call d14minmaxct(d57(it),d24(it),d56(it),d46(it),d67(it),
     -          dflsminr(it),dflsmaxr(it),dextol)
              dxy=arrdist(cslt(1,ii2),cslt(1,ii5))
              dxyr=arrdist(cslt(1,ii3),cslt(1,ii6))
            else if (looptyp(it) .lt. 10) then
              call dxymaxex(d56(it),d45(it),d34(it),d23(it),d46(it),
     -          d35(it),d24(it),cslt(1,ii6),cslt(1,ii5),cslt(1,ii4),
     -          cslt(1,ii3),cslt(1,ii2),dflsminr(it),dflsmaxr(it),
     -          dextol,it,14-looptyp(it),iout,nwarn,inperr)
              if (looptyp(it) .eq. 5) then
                dxy=arrdist(cslt(1,ii1),cslt(1,ii5))
                dxyr=arrdist(cslt(1,ii3),cslt(1,ii6))
              else if (looptyp(it) .eq. 9) then
                dxy=arrdist(cslt(1,ii1),cslt(1,ii4))
                dxyr=arrdist(cslt(1,ii2),cslt(1,ii6))
              else
                dxy=arrdist(cslt(1,ii1),cslt(1,ii5))
                dxyr=arrdist(cslt(1,ii2),cslt(1,ii6))
              end if
            end if
            if (idebug(71) .gt. 1) write (iout,2017) it,ii0,ii1,ii2,
     -        ii3,ii4,ii5,ii6,ii7,d01,d02(it),d03(it),d12(it),d13(it),
     -        d14(it),d23(it),d24(it),d25(it),d34(it),d35(it),d45(it),
     -        d46(it),d47(it),d56(it),d57(it)
c           Four double bonds, make sure backbone atoms are the first 2 in list
            call swaprot(nrot(itswap),irotlinc(itswap),irotlist,iaswap)
          end if
          if (looptyp(it) .gt. 1) then
            ifail=0
c           if (dxy .lt. dflsmin(it) .or. dxy .gt. dflsmax(it) .or.
c    -        dxyr .lt. dflsminr(it) .or. dxyr .gt. dflsmaxr(it)) then
            if (dxy .lt. dflsmin(it) .or. dxy .gt. dflsmax(it)) then
              ifail=1
              write (iout,1156)
              inperr=inperr+1
            end if
            if (ifail .gt. 0 .or. idebug(79) .gt. 1) write (iout,1152)
     -        it,looptyp(it),dflsmin(it),dflsmax(it),dxy
c    -        it,looptyp(it),dflsmin(it),dflsmax(it),dxy,
c    -        dflsminr(it),dflsmaxr(it),dxyr
          end if
        end do
        if (iop(91) .gt. 0) then
c         Find torsion limits for atoms moved by a loop
          igtlast=0
          do itg=1,ntorgrp
            do it=ifdhgrlst(itg),ildhgrlst(itg)
              if (looptyp(it) .ne. 0) then
                igtlastt=igrslt(iquata(looplist(6,it),4))
                if (igtlastt .gt. igtlast) igtlast=igtlastt
                lasttorin=looplist(6,it)
                do inn=1,nneig(iquata(looplist(6,it),3))
                  in=ineig(inn,iquata(looplist(6,it),3))
                  if (itangon(in) .gt. lasttorin)
     -              lasttorin=itangon(in)
                end do
                lasttorinit(it)=lasttorin
              end if
            end do
          end do
        end if
        if (idebug(6) .gt. 0) then
          write (iout,2009) (ia,idistroot(ia),idistend(ia),ia=1,nstta)
          write (iout,2010) (it,iquata(it,3),itparent(it),looptyp(it),
     -    (looplist(k,it),k=1,6),lasttorinit(it),it=1,ntang)
        end if
      end if
      call findtangles(0,ntang,itangindx,iprecursor,nrot,irotlist,
     -  irotlinc,iquata,rlcslt,dihang,tangd,sindela,cosdela,1,0,
     -  idebug(21),iout,nwarn,inperr,#TR,#ST)
      natfx0=0
      do im=imf,nsttm
        if (moltused(im) .eq. 1)
     -    call findbdag(ifirstm(im),ilastm(im),rlcslt,bond,bond2,angle,
     -      cangle,bond13,bond12,angle13,cangle13,iprecursor,
     -      natfix(im)-natfx0,iroots(natfx0+1),idebug(22),inperr,iout,
     -      #ST)
        natfx0=natfix(im)
      end do
      call trnsfr(cangle0,cangle,nstta)
      call inittor(1,ntang,rlcslt,itangindx,iprecursor,nrot,irotlist,
     -  irotlinc,bond,bond2,angle,cangle,bond13,bond12,
     -  cangle13,bondf,bondproj,xfac13,xfac12,
     -  cangle40,bond420,idebug(23),iout,#TR,#ST)
c     If no torsion potential was read, return from here
      if (iop(126) .eq. 0) return
c     Set up torsion potential arrays
      nptd=0
      nptu=0
      ntordat=0
      do ipft=1,9
        if (itpused(ipft) .gt. 0 .and. lprmfil(ipft) .gt. 0) then
c         This pf was used for torsions
          nptu=nptu+1
          call readtors(prmfil(ipft),lprmfil(ipft),ipft,iopenok,
     -      ntordat,MAXTORS,torcoefd,phased,periodd,tnames)
          do it=1,ntang
            if (iopslt(iquata(it,4)) .eq. ipft .and.
     -        iopenok .eq. 0) then
              il=iquata(it,3)
              ik=iquata(it,2)
              ia=iquata(it,1)
              ib=iquata(it,4)
c             The corresponding torsion angle value is dihang(it)
              npfound=0
c             Find data limits for this type of bond
              if (ipft .ne. 7) then
                pflabaklb(2)=pflabslt(ik)
                pflabaklb(3)=pflabslt(il)
c               Charmm, Amber or Gromos - scan aggregate file
                imin=1
                do while (imin .le. ntordat .and.
     -                    nomatchlab(pflabaklb(2),pflabaklb(3),
     -                    tnames(2,imin),tnames(3,imin)) .eq. 1)
                  imin=imin+1
                end do
                imax=ntordat
                do while (imax .gt. 1 .and.
     -                    nomatchlab(pflabaklb(2),pflabaklb(3),
     -                    tnames(2,imax),tnames(3,imax)) .eq. 1)
                  imax=imax-1
                end do
                if (imax .eq. 1 .and.
     -             nomatchlab(pflabaklb(2),pflabaklb(3),
     -             tnames(2,imax),tnames(3,imax)) .eq. 0) imax=imax+1
                if (imax .lt. imin) then
                  if (wtors(it+1) .gt. 0) then
                    write (iout,1104) 'X   ',pflabaklb(2),pflabaklb(3),
     -                'X    ',it,numtorix(it)
                    inperr=inperr+1
                  else
                    write (iout,1158) 'X   ',pflabaklb(2),pflabaklb(3),
     -                'X    ',it,numtorix(it)
                    nwarn=nwarn+1
                  end if
                end if
              else
c               Gromacs - pick up residue
                resnam=labslt(1,il)
                pflabaklb(2)=labslt(2,ik)
                pflabaklb(3)=labslt(2,il)
                ires=1
                imin=1
                imax=0
                do while (ires .le. 200)
                  if (resnam .eq. resnames(ires)) then
                    imin=ifres(ires)
                    imax=ilres(ires)
                    ires=10000
                  else
                    ires =ires+1
                  end if
                end do
                if (imax .eq. 0) then
                  write (iout,1133) resnam
                  inperr=inperr+1
                end if
              end if
              t02=2.0*dihangl(cslt(1,ia),cslt(1,ik),cslt(1,il),
     -          cslt(1,ib),idebug(24),iout)
              npt=0
              do ink=1,nneig(ik)
                ia0=ineig(ink,ik)
                if (ia0 .ne. il) then
                  t1=dihangl(cslt(1,ia0),cslt(1,ik),cslt(1,il),
     -              cslt(1,ib),idebug(24),iout)
                  if (ipft .ne. 6 .and. ipft .ne. 7) then
                    pflabaklb(1)=pflabslt(ia0)
                  else
                    pflabaklb(1)=labslt(2,ia0)
                  end if
                  do inl=1,nneig(il)
                    ib0=ineig(inl,il)
                    if (ib0 .ne. ik) then
                      t2=dihangl(cslt(1,ia),cslt(1,ik),cslt(1,il),
     -                  cslt(1,ib0),idebug(24),iout)
                      if (ipft .ne. 6 .and. ipft .ne. 7) then
                        pflabaklb(4)=pflabslt(ib0)
                      else
                        pflabaklb(4)=labslt(2,ib0)
                      end if
                      npt=npt+1
                      if (npt .gt. 9) then
                        write (iout,1141) ik,il
                        inperr=inperr+1
                        npt=npt-1
                      end if
                      torsinc(npt,it)=t1+t2-t02
                      ifpftd(npt,it)=nptd+1
c                     Identify the potential here
                      ip=imin
                      imatch=0
                      do while (ip .le. imax .and. imatch .eq. 0)
                        iwildcrd=0
                        nptd0=nptd
                        do while (iwildcrd .eq. 0 .and. ip .le. imax)
                          imatch=0
                          nmatch=0
                          nmatchx=0
                          nmatchr=0
                          do k=1,4
                            if (pflabaklb(k) .eq. tnames(k,ip))
     -                          nmatch=nmatch+1
                            if (tnames(k,ip) .eq. 'X     ')
     -                        nmatchx=nmatchx+1
                            if (pflabaklb(k) .eq. tnames(5-k,ip))
     -                        nmatchr=nmatchr+1
                          end do
                          if (nmatch+nmatchx .eq. 4) imatch=1
                          if (nmatchr+nmatchx .eq. 4) imatch=-1
                          if (imatch .ne. 0) then
                            if (nmatchx .eq. 0) iwildcrd=1
                            nptd=nptd0+1
                            call checkdim(ifail,iout,inperr,'TA',
     -                        nptd,1,0,0)
                            torcoef(nptd)=torcoefd(ip)
                            period(nptd)=periodd(ip)
                            phase(nptd)=phased(ip)
                            if (ip .lt. imax) then
c                             Check for duplicate terms
                              do while (periodd(ip+1) .lt. 0.0)
                                ip=ip+1
                                nptd=nptd+1
                                call checkdim(ifail,iout,inperr,'TA',
     -                            nptd,1,0,0)
                                torcoef(nptd)=torcoefd(ip)
                                period(nptd)=-periodd(ip)
                                phase(nptd)=phased(ip)
                              end do
                            end if
                            if (ifail .gt. 0) then
                              newta=#TA*float(it)/float(ntang)
                              write (iout,1143) 'TA',newta
                              go to 101
                            end if
                            idup=nptd-nptd0
                            if (idebug(15) .gt. 0) then
                              tt0=t02*rdtodg
                              tt1=t1*rdtodg
                              tt2=t2*rdtodg
                              write (iout,2006) ia0,ia,ik,il,ib,ib0,
     -                          pflabaklb,npt,nptd,
     -                          ip,tt0,tt1,tt2,imatch*idup
                              if (idebug(15) .gt. 1) write (iout,2008)
     -                          (tnames(k,ip),k=1,4),nmatch,nmatchr,
     -                          nmatchx
                            end if
                          end if
                          ip=ip+1
                        end do
                      end do
                      if (nptd .eq. nptd0) then
                        if (ipft .ne. 6 .and. ipft .ne. 7) then
                          if (wtors(it+1) .gt. 0) then
                            write (iout,1104) pflabaklb,it,numtorix(it)
                            inperr=inperr+1
                          else
                            write (iout,1158) pflabaklb,it,numtorix(it)
                            nwarn=nwarn+1
                          end if
                        end if
                      else
                        npfound=npfound+1
                      end if
                      ilpftd(npt,it)=nptd
                    end if
                  end do
                end if
              end do
              npft(it)=npt
              if (npfound .eq. 0 .and.
     -            (ipft .eq. 6 .or. ipft .eq. 7)) then
                 if (wtors(it+1) .gt. 0) then
                   write (iout,1138) it,pflabaklb(2),pflabaklb(3)
                   inperr=inperr+1
                else
                   write (iout,1159) it,pflabaklb(2),pflabaklb(3)
                   nwarn=nwarn+1
                end if
              end if
            end if
          end do
        end if
      end do
101   if (nptu .eq. 0) then
        write (iout,1112)
        inperr=inperr+1
      end if
c??   do it=1,ntang
c??     ilpft(it)=npt
c??     if (it .lt. ntang) ifpft(it+1)=npt+1
c??   end do
      if (ntorpmf .gt. 0) then
c       PMF torsion setup
c       Initialize the torsion angles at the initial configuration
        write (iout,1203)
c       Check if unrotated atoms of the 1st and 2nd copy are identical
        difmax=0.0
        iadiff=1
c       impmf: molecule on which the PMF torsions are changed
        impmf=iamolslt(iquata(ifdhgrlst(1),1))
        do ia=1,nstfa0
          if (maptors(ia) .eq. 0) then
            diff=amax1(abs(cslt(1,ia)-cslt(1,nstfa0+ia)),abs(cslt(2,ia)-
     -        cslt(2,nstfa0+ia)),abs(cslt(3,ia)-cslt(3,nstfa0+ia)))
            if (difmax .gt. diff) then
              iadiff=ia
              difmax=diff
            end if
          end if
        end do
        if (difmax .gt. 0.001) then
          write (iout,1103) difmax,iadiff
          inperr=inperr+1
        end if
c       Move 1st copy into the place of the 3rd (lincmb will only affect
c       atoms that are rotated!)
        call trnsfr(cslt(1,nstfa1+1),cslt,3*nstfa0)
        do it=1,ntorpmf
c         Determine first configurations torsion angles
          dih0(it)=dihangl(cslt(1,iquata(it,1)-nstfa1),
     -      cslt(1,iquata(it,2)-nstfa1),cslt(1,iquata(it,3)-nstfa1),
     -      cslt(1,iquata(it,4)-nstfa1),idebug(24),iout)
        end do
        if (ntdiffinp .eq. 0) then
c         Initial and final conformations are complete
          do it=1,ntorpmf
c           Determine second configuration's torsion angles
            dih1(it)=dihangl(cslt(1,iquata(it,1)-nstfa0),
     -        cslt(1,iquata(it,2)-nstfa0),cslt(1,iquata(it,3)-nstfa0),
     -        cslt(1,iquata(it,4)-nstfa0),idebug(24),iout)
            if (idebug(55) .gt. 0) write (iout,*)'dih1=',dih1(it)*rdtodg
c           Establish angle range/sign
            if (deldih(it) .eq. +999.0) then
c             Clockwise rotation was requested
              deldih(it)=dih1(it)-dih0(it)
            else if (deldih(it) .eq. -999.0) then
c             Counterclockwise rotation was requested
              dih1(it)=dih1(it)-pi2
              deldih(it)=dih1(it)-dih0(it)
            else
c             Rotation in the shorter direction was requested
              deldih(it)=dih1(it)-dih0(it)
              write (iout,*) 'C DELDIH=',deldih(it)
              if (abs(deldih(it)) .gt. abs(deldih(it)-pi2)) then
                dih1(it)=dih1(it)-pi2
                deldih(it)=dih1(it)-dih0(it)
              end if
            end if
            if (abs(deldih(it)) .lt. 0.001) then
              write (iout,1155) it,dih0(it)*rdtodg,dih1(it)*rdtodg
              inperr=inperr+1
            end if
            if (idebug(55) .gt. 0) write (iout,*)
     -        'dih1=',dih1(it)*rdtodg,' deldih=',deldih(it)*rdtodg
          end do
        else
          do it=1,ntorpmf
            if (deldih(it) .eq. 0) then
              write (iout,1201) it
              inperr=inperr+1
            else
c             Generate 2nd configuration by rotating 1st with deldih(it)
              write (iout,1200) deldih(it),it
              deldih(it)=deldih(it)/rdtodg
            end if
            dih1(it)=dih0(it)+deldih(it)
          end do
          call gentor(ifirstt(impmf),ilastt(impmf),dih1,cslt,itangindx,
     -      iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,bondf,
     -      bondproj,bond,xfac13,xfac12,idebug(25),iout, #TR,#ST)
c         Gentor works on the 3rd copy
          call trnsfr(cslt(1,nstfa1+1),cslt(1,nstfa0+1),3*nstfa0)
          call trnsfr(cslt(1,nstfa1+1),cslt,3*nstfa0)
          call grelcd(cslt,rlcslt,iclslt,nstta,0)
        end if
      end if
c     Sum torsion weight for groups, check if a group sits on the same molec
      do itg=1,ntorgrp
        wtorsum=wtors(ifdhgrlst(itg)+1)
        m1=iamolslt(iquata(ifdhgrlst(itg),2))
        do it=ifdhgrlst(itg)+1,ildhgrlst(itg)
          m2=iamolslt(iquata(it,2))
          if (m1 .ne. m2) then
            write (iout,1131) itg,it,m2,ifdhgrlst(itg),m1
            inperr=inperr+1
          end if
          wtorsum=wtorsum+wtors(it+1)
        end do
        wtors(itg+1)=wtorsum
      end do
      call zeroiti(l1,1,nsttg)
      do it=1,ntang
        l1(igrslt(iquata(it,2)))=1
      end do
      if (iop(61) .gt. 0) then
        do ir=1,nsttg
          if (l1(ir) .eq. 0) then
            write (iout,1162) ir,
     -       ir_split_orig(iorig_of_split(ifgrslt(ir)))
            nwwarn=nwwarn+1
          end if
        end do
      end if
      if (idebug(36) .gt. 0) write (iout,2007)
     -  'individual, unnormalized',(wtors(i),i=1,ntorgrp+1)
c     Normalize the torsion weights
      wtorsum=0.d0
      wtors(1)=0.0
      do it=2,ntorgrp+1
        wtorsum=wtorsum+wtors(it)
      end do
      wwtorsum=0.d0
      do it=2,ntorgrp+1
        wtors(it)=wtors(it)/wtorsum
        wwtorsum=wwtorsum+wtors(it)
        wtors(it)=wwtorsum
      end do
c     Make sure that round-off errors don't bring w over 1.0
      it=ntorgrp
      do while (wtors(it) .gt. 1.0)
        wtors(it)=1.0
        it=it-1
      end do
      wtors(ntorgrp+1)=1.0
      if (iop(18) .eq. 4) wtors(2)=0.d0
      if (idebug(36) .gt. 0) write (iout,2007)
     -  'cumulative, normalized',(wtors(i),i=1,ntorgrp+1)
      call zeroit(wtlast,nsttm)
      write (iout,1127) MAXTORS,ntordat
      write (iout,1140) 'data','TA',nptd
      write (iout,1140) 'atom list','TA',iltorgrp(ntorgrp)
      return
999   call invalidform(iout,irectx)
1000  format(2i5,2f10.0,2i5,3f10.0,i5)
1100  format(a,' WARNING: bond ',i4,' - ',i4,' is ',a,
     -  ' - torsion ',i4,' (',a4,1x,a4,' - ',a4,1x,a4,')')
1101  format(' ***** ERROR: torsion',i5,' of torsion group',i5, ' is ',
     -  'not on the same molecule as the first torsion of the group')
1102  format(' ***** PROGRAM ERROR: number of torsions remaining (',i4,
     -  ') is different from the number of torsions inputted (',i4,')')
1103  format(' ***** ERROR: second copy of an unrotated atom ',
     -  ' differs from the first copy by ',f9.3,' A for atom ',i4)
1104  format(' ***** ERROR: no torsion parameters for ',3(a,' - '),a,
     -  ' (torsion ',i5,'; input index:',i5,')')
1105  format(' ***** ERROR: torsion PMF requires explicit torsion ',
     -  'angle specification')
1106  format(' ***** ERROR: No bond exists between atoms',2i5,
     -  ' (',a4,1x,a4,' - ',a4,1x,a4,') for torsion ',i3,
     -  ' (dist=',f5.2,' A)')
1107  format(' ***** ERROR: Torsion angle group identifier is ',
     -  'missing for torsion ',i4)
1108  format(' ----- WARNING: explicit sense data is overridden by ',
     -  ' torsion range value for torsion',i4)
1109  format(' ***** ERROR: torsion',i5,' torsion bond atomindex can ',
     -  'not be zero:',2i6)
1110  format(' ***** ERROR: atom',i5,' of torsion',i5,' is out of ',
     -  'the range permitted: ',i5,' - ',i5,' - torsion',i5,' will be ',
     -  'deleted')
1111  format(' ***** PROGRAM ERROR: endless loop in torsion definition')
1112  format(' ***** ERROR: no torsion potential library matching ',
     -  'the potentials used have been read - the PRMF key may be ',
     -  'missing')
1113  format(' ===== STRONG WARNING: bond ',i5,' - ',i5,' (',a4,1x,a4,
     -  ' - ',a4,1x,a4,') is a ',a,' - it will be ignored')
1114  format(' ***** ERROR: invalid ',i1,'-',i1,' limit, it,itct=',2i5,
     -  ' dij^2=',f12.6,' dij=',f12.6,' dij2min/max=',2f12.6,a,/,
     -  14x,'Atoms in the torsion loop: i0-i5=',6i6)
1115  format(' ***** ERROR: number of torsions after duplicating (',i3,
     -  ' exceeds capacity (#TR) - recompile with increased #',a2,
     -  ' (maxtors)')
1116  format(' Torsions have been copied to the other free energy ',
     -  'molecule(s)')
1117  format(' ***** ERROR: solute copy',i2,' is incompatible with the',
     -  ' first one when comparing atom ',i4)
1118  format(' - atom type or first or fourth neighbour numbers ',
     -  'differ. First copy: type=',i2,' nn=',i4,' nn4=',i2,
     -  ' copy No',i2,': type=',i2,' nn=',i4,' nn4=',i2)
1119  format(' - neighour list elements No',i3,' differ. First copy:',
     -  ' copy No',i3)
1120  format(' ***** ERROR: number of solute copies to generate=',i3,
     -  ' is incompatible with the free energy option used (if any)')
1121  format(' ***** PROGRAM ERROR: torsion ',i5,' points to an atom',
     -  ' marked notorsion')
1122  format(' ***** PROGRAM ERROR: after rearrangement torsion ',i5,
     -  ' points to ',i5)
1123  format(' Number of potentially flexible rings found=',i4)
1124  format(' ***** ERROR: cloning and multiplying the torsions set ',
     -  'are incompatible')
1125  format(' Number of torsions have been reduced to ',i5,' from ',i5)
1126  format(' This may be resulted from some of the',i4,' strong ',
     -  'warnings printed above related to the molecular topology')
1127  format(' Torsion parameter list is dimensioned to',i6,' used=',i6)
1128  format(' ///// NOTE: atom indices in the output for the TORD key',
     -  ' will refer to the new index of the atoms in the flexible',
     -  ' residues')
1129  format(' All atomnumbers defining a torsion will be incremented ',
     -  'by ',i5)
1130  format(7x,'The estimated value for #',a2,' is actually ',i9)
1131  format(' ***** ERROR: torsion group ',i5,' torsion ',i5,' is on ',
     -  'solute molecule ',i4,' while torsion ',i5,' is on solute',
     -  ' molecule ',i4)
1132  format(' ***** PROGRAM ERROR: Can not find the shift for the ',i3,
     -  '-th cloned molecule, original postion of the first atom:',i6)
1133  format(' ***** ERROR: no torsion parameters for residue ',a4)
1134  format(' ***** ERROR: torsion loop member ',i5,' of torsion ',i5,
     -  ' is incompatible with torsion group member',i6,' in group ',i4)
1135  format(' ***** ERROR: torsion ',i5,' is moved by torsion loops ',
     -  i4,' and ',i4,' in group ',i4)
1136  format(' ***** PROGRAM ERROR: could not adjust iquata(4) for ',
     -  'torsion ',i5,' i4ok,iquata(4)=',2i6)
1137  format(' Swapping i1=',i5,' iqprev(4)=',i5,' ilist(itt)=',i5,
     -  ' itt=',i2)
1138  format(' ***** ERROR: no torsion parameters at all for torsion',
     - i5,' around bond ',a4,' - ',a4)
1139  format(' TORSIONSETUP looptyp=1 it=',i5,' dflsmin/max=',2f10.5,
     -  ' d15=',f9.5,' dcis/trans=',2f10.5)
1140  format(' Torsion ',a,' arrays are dimensioned to #TA (',a2,
     -  ', maxtslt), used=',i6)
1141  format(' ***** ERROR: number of torsions on bond ',i6,' - ',i6,
     -  ' exceeds 9 - the common block toreng may have to be updated')
1142  format(' ***** ERROR: no torsions are generated')
1143  format(' Increase #',a2,' (maxtslt) above ',i6)
1144  format(' ***** ERROR: Duplicate torsions were found - run will',
     -  '  be stopped')
1145  format(' ***** PROGRAM ERROR: cloned solute molecule',i5,
     -  ' torsion range:',i4,' - ',i4,/,22x,'Does not match original ',
     -  'molecule',i5,' torsion range:',i4,' - ',i4)
1146  format(' TORSIONSETUP itorig:',20i5)
1147  format(' ***** ERROR: solute molecule',i5,' (atoms ',i5,' - ',i6,
     -  ') is incorrectly defined - see STRONG WARNINGS above')
1148  format(' Topology generation for molecule ',i4,' is skipped ',
     -  'since it does not have any active torsion')
1149  format(' +++++ The STRONG WARNINGs above about topology errors ',
     -  'can safely eliminated with the MOLD key since they do not ',
     -  'affect torsions')
1150  format(' ***** ERROR: no torsions were left')
1151  format(' - ',a,' input torsions were forbidden')
1152  format(' TORSIONSETUP it=',i4,' lt=',i2,' dxymin/max^2=',2f10.5,
     -  ' Curr=',f9.5,' A^2')
c    -  ' Curr=',f9.5,'  dxymin/maxr^2=',2f10.5,' Curr=',f9.5,' A^2')
1153  format(' TORSIONSETUP it=',i4,' bond:',2i5,' loopmem=',i2,
     -  ' itparent=',i4)
1154  format(' TORSIONSETUP it=',i4,' itpar=',i5,' putative loop:',6i5)
1155  format(' ***** ERROR: PMF torsion ',i2,': initial and final ',
     -  'torsion angles are the same:',2f12.5)
1156  format(' ***** ERROR: invalid loop distance limit')
1157  format(' Torsions have been cloned. New number of torsions=',
     -  i5,' original number of torsions=',i5)
1158  format(' ----- WARNING: no torsion parameters for ',3(a,' - '),
     -  a4,' (torsion ',i5,'; input index:',i5,')')
1159  format(' ----- WARNING: no torsion parameters at all for torsion',
     - i5,' around bond ',a4,' - ',a4)
1160  format(' ***** ERROR: user-defined molecule consists of',i3,
     -  ' fragments - this interferes with establishing the torsions',
     -  /,7x,'Either change the MOLD key to reflect all fragments or ',
     -  'use the MAKB to make the fragments connected')
1161  format(6x,'Note, that torsions involvong atoms in molecules ',
     -  'defined by the MOLD key are not allowed')
1162  format(' ===== STRONG WARNING: residue',i6,' original #:',i6,')',
     -  ' is declared flexible with the FLXR key but involves no ',
     -  'torsion')
 
1200  format(' Second solute conformation is generated by a ',f8.2,
     -  ' degree rotation of the torsion angle',i3)
1201  format(' ***** ERROR: torsion difference between the initial and',
     -  ' final states was given as zero for torsion',i4)
c1202  format(' ***** ERROR: torsion ,'i5,' is on a solute molecule ',
c     -  'affected by the PARD key - change LOOP LIMM to LOOP ALLM')
1203  format(' The initial state torsion angles were determined from ',
     -  'the solute copies given after the key SLTA',/,' The final ',
     -  'state torsion angles were determined by the torsion defined ',
     -  'after the key TORD')
1204  format(' ***** ERROR: atom ',i5,' in torsion group ',i3,
     -  ' subgroup ',i4,/,' has different potential call type (',i1,')',
     -  ' than the first atom in the subgroup (',i1,')')
1205  format(' The following bond-types will be held rigid: ',
     -  5(a4,'-',a4,2x,a),2(10(a4,'-',a4,2x,a)))
1206  format(' ----- WARNING: torsion group numbers were not ',
     -  'consecutive - group numbers have been reassigned')
1207  format(' TORSIONSETUP fix bond ia,il,ikn=',3i5,' pflab:',2a4)
1348  format(' rectype 24  : ',2i5,5x,2f10.4,2i5,3f10.5,i5)
2001  format(' TORSIONSETUP: Torsion grp',i5,' if,il=',2i6,
     -  ' iftmovtg,iltmovtg=',2i4)
2002  format(' TORSIONSETUP: Torsion grp',i5,' if,il=',2i6,/,
     -  (15x,'atom members=',20i5))
2003  format(' TORSIONSETUP: Torsion grp',i5,' subgr',i5,' if,il=',2i6,
     -  ' ipf=',i2,' atom members=',8i6,(/,40x,12i6))
2004  format(' TORSIONSETUP: im=',i5,' Torsion map:',90i1,/,(36x,90i1))
2005  format(' TORSIONSETUP: Molecule',i4,' torsion limits:',2i6,
     -  ' torsion group limits:',2i6)
2006  format(' TORSIONSETUP: Match ',6i5,4a5,' npt,nptd,ip=',3i4,
     -    ' t02,1,2=',3f9.4,' idup=',i2)
2007  format(' TORSIONSETUP: wtors (',a,'):',/,(1x,15f8.5))
2008  format(' TORSIONSETUP: Match param:',4a7,' nmatch,r,x=',3i3)
2009  format(' TORSIONSETUP: ia=',i5,' idroot=',i4,' idend=',i4)
2010  format(' TORSIONSETUP: it=',i5,' ia=',i5,' ipart=',i4,
     -  ' looptyp=',i1,' list=',6i5,' lasttorinit=',i5)
2011  format(' TORSIONSETUP: it=',i5,' irotlinc=',i5,' np(itx)=',i5,
     -  ' nnextormov=',i5,' nrot=',i5,' loopmem=',i3,/,
     -  (' irotlist=',15i6))
2012  format(' TORSIONSETUP: it=',i5,' torsion loop (?)',
     -  2(i6,' iq=',4i5),/,10x,4(i6,' iq=',4i5))
2013  format(' TORSIONSETUP: torsion=',i5,' looptyp=',i2,/,
     -  (i2,' nbskp=',i2,' mid=',i5,' iaold=',i5,' ianew=',i5))
2014  format(' TORSIONSETUP: it=',i5,' iatnew=',7i6)
2015  format(' TORSIONSETUP it=',i6,' i0-9=',10i5,/,
     -  ' d02,d03,d12,d13=',4f7.4,' d23,d24,d34,d35=',4f7.4,/,
     -  ' d36,d45,d46,d56=',4f7.4,
     -  ' d57,d67,d68,d69=',4f7.4,' d78,d79=',2f7.4)
2016  format(' TORSIONSETUP it=',i6,' i1-9=',9i5,/,
     -  ' d12,d13=',2f7.4,' d23,d24,d25,d35=',4f7.4,
     -  ' d34,d35,d45,d46=',4f7.4,/,' d56,d57,d58=',3f7.4,
     -  ' d67,d68=',2f7.4,' d78,d79=',2f7.4)
2017  format(' TORSIONSETUP it=',i6,' i0-7=',8i5,/,' d01-d03=',3f7.4,
     -  ' d12-d14=',3f7.4,' d23-d25=',3f7.4,' d34-d36=',3f7.4,/,
     -  ' d45-d47=',3f7.4,' d56,d57=',2f7.4)
2018  format(' Loop root it=',i4,' list:',20i4)
2019  format(' ===== STRONG WARNING: torsion group members ',2i4,
     -  ' are not on the same branch'/,5x,' - this results in ',
     -  'unnecessary extra work')
2020  format(' TORSIONSETUP isltmv=',100i1)
2021  format(' TORSIONSETUP side chain torsion list:')
2022  format(' isltmv=  ',15i6)
2023  format(' Torsion ',i4,' is the driver of the last loop in the ',
     -  'flexible ring ',i3,' - torsion ',i4,' is immobilized')
2024  format(' ===== STRONG WARNING: number of torsion groups ',
     -  'changed from',i5,' to',i5,' after rearranging torsion list')
2025  format(' Torsion group ',i4,' # or R-O-R acceptors added:',i3,
     -  ':',20i6)
      end
      subroutine addtorlist(it,lsttorgrp,ntors,nlist,wtors,nnext,
     -  irotlist,irotlinc,maptors,iout,inperr,nfail,maxtor,maxtl,maxslt)
c#    MMC routine 327 lstmod: 03/14/07
c*****For each successive torsion of the group, add atoms that are not
c     already on the list
c     (This should really be done on the sorted list !!)
      dimension lsttorgrp(maxtl),wtors(maxtor),irotlist(maxslt),
     -  irotlinc(maxslt),maptors(maxslt)
      if (wtors(it+1) .gt. 0.0) then
        do iaa=1,nnext
          itchk=irotlist(irotlinc(it)+iaa)
          do iit=ntors+1,nlist
            if (itchk .eq. lsttorgrp(iit)) go to 106
          end do
c         New atom, add to the list
          nlist=nlist+1
          maptors(itchk)=1
          call checkdim(ifail,iout,inperr,'TA',nlist,1,0,nfail)
          if (ifail .eq. 1) then
            nfail=nfail+1
            return
          end if
          lsttorgrp(nlist)=itchk
106       continue
        end do
      end if
      return
      end
      subroutine loopmatch(il1,il2,looplist,iquata,labslt,loopdel,
     -  iop24,iout,ntang,nslt)
c#    MMC routine 327/a lstmod: 05/06/15
c*****Match two loops to see if the form a branch
      dimension looplist(6,ntang),iquata(#TR,4)
      character*4 labslt(2,nslt)
      loopdel=0
      it1=looplist(1,il1)
      do i1=1,6
        if (looplist(i1,il2) .eq. it1) then
c         Match found - check if match persist for the rest
          do i2=i1+1,6
            if (looplist(i2,il2) .ne. looplist(i2-i1+1,il1)) then
c             Branch found
              it1=looplist(i2-i1+1,il1)
              it2=looplist(i2,il2)
              ia1=iquata(it1,3)
              ia2=iquata(it2,3)
              if (labslt(2,ia2) .eq. ' CB ' .or.
     -            labslt(2,ia2) .eq. 'CB  ') then
                loopdel=il2
              else
                loopdel=il1
              end if
              if (iop24 .gt. 1) write (iout,1000) il1,il2,
     -          it1,it2,ia1,(labslt(k,ia1),k=1,2),
     -          ia2,(labslt(k,ia2),k=1,2),loopdel
              return
            end if
          end do
        end if
      end do
      return
1000  format(' Branching loop pair found. Torsion origins:',2i6,/,
     -  10x,' Branching torsion pair:',2i6,
     -  ' Branch atoms:',2(i1,1x,a4,1x,a4),' Deleting loop',i6)
      end
      subroutine topology(n0,n,nneig,ineig,ioldplace,newplace,icenter,
     -  iparent,itangon,idistroot,idistend,idon,nnloop,listo,listccfr,
     -  listccfl,loopbot,nflexring,maxbrlen,naflxrange,iaflxrange,
     -  iaflxneig,iout,inperr,nwwarn,maxat,maxneig)
c#    MMC routine 328 lstmod: 05/07/20
c*****Set up the bond-tree structure and find rotatable bonds for atoms n0-n
      dimension nneig(maxat),ineig(maxneig,maxat),ioldplace(maxat),
     -  newplace(maxat),iparent(maxat),itangon(maxat),
     -  idistroot(maxat),idistend(maxat),nnloop(maxat),idon(maxat),
     -  listo(maxat),listccfr(maxat),listccfl(maxat),loopbot(maxat),
     -  iaflxrange(2,naflxrange),iaflxneig(2,naflxrange)
      common /option/ iop(200),idebug(200)
      dimension ibrl(6)
c     listo,listccfl,listccfr: temporary storage
c     See if this is a flexible segment
c     write (iout,*) 'TOPOLOGY N0,N=',n0,n,' ICENTER=',icenter
      iflx=0
      iafix2=0
      do is=1,naflxrange
c       write (iout,*) is,' IAFLXRANGE:',(iaflxrange(k,is),k=1,2)
        if (icenter .ge. iaflxrange(1,is) .and.
     -      icenter .le. iaflxrange(2,is)) then
          iflx=1
          if (icenter .eq. iaflxneig(1,is)) then
            if (iaflxneig(2,is) .gt. 0) iafix2=iaflxneig(2,is)
          else if (icenter .eq. iaflxneig(2,is)) then
            if (iaflxneig(1,is) .gt. 0) iafix2=iaflxneig(1,is)
          end if
        end if
      end do
100   do ia=n0,n
        idistroot(ia)=0
        idistend(ia)=0
        nnloop(ia)=nneig(ia)
        newplace(ia)=ia
        ioldplace(ia)=ia
      end do
c     In this part listo will contain the members of a loop found,
c     later used just as a switch.
c     listccfr and listccfl will contain the loopnumbers an atom belonngs,
c     for frozen (<7 torsion bonds) or flexible rings
c     Obtain distances from root/end
c     Obtain for each atom by its distance from its root, idistroot
      iparent(icenter)=icenter
      idistroot(icenter)=-1
      idon(n0)=icenter
c     This iparent is temporary - topology will reassign it
c     if (iafix2 .gt. 0) iparent(iafix2)=icenter
      if (iafix2 .gt. 0) then
c       Make icenter-iafix2 bond
        nneig(icenter)=nneig(icenter)+1
        nneig(iafix2)=nneig(iafix2)+1
        ineig(nneig(icenter),icenter)=iafix2
        ineig(nneig(iafix2),iafix2)=icenter
      end if
      ncurlevf=n0
      ncurlevl=n0
      nomore=0
      level=0
      do while (nomore .eq. 0)
        level=level+1
        nnextlev=0
        do ia=ncurlevf,ncurlevl
          iskiplast=0
          if (iflx .eq. 1 .and. idon(ia) .eq. icenter) iskiplast=1
          do in=1,nneig(idon(ia))
            nn=ineig(in,idon(ia))
            if (idistroot(nn) .eq. 0) then
              iparent(nn)=idon(ia)
              if (iskiplast .eq. 0 .or. in .lt. nneig(idon(ia))) then
                nnextlev=nnextlev+1
                idon(ncurlevl+nnextlev)=nn
                idistroot(nn)=level
              end if
            end if
          end do
        end do
        if (nnextlev .gt. 0) then
          ncurlevf=ncurlevl+1
          ncurlevl=ncurlevl+nnextlev
        else
          nomore=1
        end if
      end do
      if (ncurlevl .ne. n .and. iflx .eq. 1) then
c       Looks like open chain
c       write (iout,*) 'N0,N,NCURLEVL=',n0,n,ncurlevl
        iflx=0
        go to 100
      end if
      if (ncurlevl .ne. n) then
        write (iout,1003) ncurlevl,n0,n
        inperr=inperr+1
      end if
      idistroot(icenter)=0
      nflexring=0
c     Mark rings
      nfrozenring=0
c     do ia=n0,n
c       write (iout,7921) ia,idistroot(ia),(ineig(in,ia),in=1,nneig(ia))
c7921   format(i6,' IDISTROOT=',i3,' IN:',10i6)
c     end do
      call zeroiti(listccfr,n0-1,n)
      call zeroiti(listccfl,n0-1,n)
      call zeroiti(loopbot,n0-1,n)
      do ia0=n0,n
        ia=idon(ia0)
        if (loopbot(ia) .eq. 0) then
          irdia=idistroot(ia)
          nbr=0
          ipar1=0
          do in=1,nneig(ia)
            iaa=ineig(in,ia)
            if (idistroot(iaa) .le. irdia) then
              nbr=nbr+1
              ibrl(nbr)=iaa
              if (iaa .eq. iparent(ia)) ipar1=nbr
            end if
          end do
          nmem=0
c         Make sure parent is the first
          if (ipar1 .gt. 1) then
            ib1=ibrl(1)
            ibrl(1)=ibrl(ipar1)
            ibrl(ipar1)=ib1
          end if
          do ibr=2,nbr
c           Loop bottom was found
            ib1=ibrl(1)
            ib2=ibrl(ibr)
c           write (iout,*) 'LOOP BOTTOM:',ib1,ib2
            if (iparent(ib1) .ne. ib1 .or. iparent(ib2) .ne. ib2) then
              if (idistroot(ib1) .eq. idistroot(ib2) .and.
     -            idistroot(ib1) .lt. irdia) then
                listo(1)=ia
                listo(2)=ib1
                listo(3)=ib2
c               write (iout,*) 'LOOP BOTTOM:',ib1,ib2,ia
                nmem=3
                nba=1
              else
c               "Flat" bottom
                ib1=ia
                nmem=2
                listo(1)=ib1
                listo(2)=ib2
                nba=2
                loopbot(ib2)=1
              end if
              do while (iparent(ib1) .ne. iparent(ib2))
                ib1=iparent(ib1)
                ib2=iparent(ib2)
                listo(nmem+1)=ib1
                listo(nmem+2)=ib2
c               write (iout,*) 'LOOP BUILD :',ib1,ib2
                nmem=nmem+2
              end do
              nmem=nmem+1
              listo(nmem)=iparent(ib1)
              nflex=0
              do im=1,nmem
                if (listccfl(listo(im)) .ge. 0 .and.
     -              listccfr(listo(im)) .eq. 0) nflex=nflex+1
              end do
c             write (iout,8672) nflex,(listo(im),listccfl(listo(im)),
c    -          listccfr(listo(im)),im=1,nmem)
c8672         format('NFLEX=',i2,' mem,fl,fr:',(10(i5,2i2)))
              if (nflex .ge. 7) then
c               Flexible loop - mark listccfl with nflexring
                nflexring=nflexring+1
                do im=1,nmem
                  if (listccfl(listo(im)) .ge. 0)
     -              listccfl(listo(im))=nflexring
                end do
              else
c               Frozen ring - mark listccfr with nfrozenring
                nfr=0
                do im=1,nmem
                  if (listccfr(listo(im)) .gt. 0)
     -              nfr=listccfr(listo(im))
                end do
                if (nfr .eq. 0) then
                  nfrozenring=nfrozenring+1
                  nfr=nfrozenring
                end if
                do im=1,nmem
                  listccfr(listo(im))=nfr
                end do
              end if
              if (idebug(5) .gt. 2) then
                write (iout,7710) nmem,nba,(listo(im),im=1,nmem)
                write (iout,7709) 'listccfl',(listccfl(im),im=1,nmem)
                write (iout,7709) 'listccfr',(listccfr(im),im=1,nmem)
              end if
            end if
          end do
        end if
      end do
c     Generate new iparent list, still temporary; generate temporary idistroot
      if (iafix2 .gt. 0) then
c       Remove fake bond
        nneig(icenter)=nneig(icenter)-1
        nneig(iafix2)=nneig(iafix2)-1
      end if
      do i=n0,n
        idon(i)=1
        iparent(i)=-99
        if (idebug(5) .ge. 2) write
     -    (iout,7715) i,(ineig(j,i),j=1,nneig(i))
      end do
      ioldplace(n0)=icenter
      newplace(icenter)=n0
      idon(icenter)=0
      iparent(n0)=n0
      nfound=n0
      if (n .eq. n0) return
c     if (nneig(icenter) .lt. 2) then
c       write (iout,1000) icenter,nneig(icenter)
c       inperr=inperr+1
c     end if
      do in0=1,nneig(icenter)
c       Grow trees from icenter's neigs
        io=ineig(in0,icenter)
        if (idon(io) .eq. 1) then
          nfound=nfound+1
          iparent(nfound)=n0
          ioldplace(nfound)=io
          newplace(io)=nfound
          idon(io)=0
          lll=0
          ibranchroot=nfound
          kroot=ibranchroot
c         Start search  from kroot
          if (idebug(5) .ge. 2)
     -      write (iout,*) 'PREP Search started at root atom ',io
c         Move icenter to the end of the neighbour list
          nnio=nneig(io)
          call swapng(ineig,nnloop,io,icenter,nnio,1,maxat,maxneig)
          do while (kroot .gt. ibranchroot .or.
     -      (kroot .eq. ibranchroot .and. nnloop(io) .gt. 0))
c           There is unexplored branch left
            if (idebug(5) .gt. 2)
     -        write (iout,7711) 'PREP',kroot,nfound,io,nnloop(io)
            if (nnloop(io) .gt. 0) then
c             There is neighbour left at kroot
              icc=ineig(nnloop(io),io)
              if (idon(icc) .eq. 1) then
c               Unused neighbour, include
                nfound=nfound+1
                iparent(nfound)=kroot
                ioldplace(nfound)=icc
                newplace(icc)=nfound
                idon(icc)=0
                if (idebug(5) .gt. 2) write (iout,7712) 'PREP',kroot,
     -            ioldplace(kroot),nfound,icc,nnloop(io)
c               Move parent to the end of list
                nnicc=nneig(icc)
                call swapng(ineig,nnloop,icc,io,nnicc,1,maxat,maxneig)
                if (nneig(icc) .eq. 1) then
c                 End of a branch, terminal bond is not a torsion bond
                else
c                 Move kroot down
                  kroot=nfound
                end if
              end if
              nnloop(io)=nnloop(io)-1
              io=ioldplace(kroot)
            else
c             No more neighbour - move kroot back to next level
              kroot=iparent(kroot)
              io=ioldplace(kroot)
              lll=lll+1
              if (lll .gt. 4*(n-n0+1)) then
                write (iout,*) 'PROGRAM ERROR: looping'
                kroot= -1
              end if
            end if
          end do
        end if
      end do
      if (idebug(5) .ge. 1) then
        do ia=n0,n
          write (iout,7718) ia,ioldplace(iparent(newplace(ia)))
        end do
      end if
c     Obtain for each atom by its distance from the end of the longest chain,
c     idistend
      call zeroiti(listo,n0-1,n)
c     First, find the graph endpoints
      do ia=n0,n
        call validindex(n0,n,iparent,ia,iout,inperr,' parent3')
        listo(iparent(ia))=1
      end do
c     All unmarked atoms are endpoints
      do ia=n0,n
        if (listo(ia) .eq. 0) then
          id=0
          iaa=ia
          iaa_o=ioldplace(iaa)
          do while (iparent(iaa) .ne. iaa .and.
     -              id .ge. idistend(iaa_o))
            idistend(iaa_o)=id
            id=id+1
            call validindex(n0,n,iparent,iaa,iout,inperr,' parent4')
            iaa=iparent(iaa)
            iaa_o=ioldplace(iaa)
          end do
          if (iparent(iaa) .eq. iaa) idistend(iaa_o)=id
          if (idebug(5) .gt. 0) write (iout,7719) ioldplace(ia),
     -      iaa_o,idistend(iaa_o)
        end if
      end do
c     Sort the neighbour list to have nonincreasing idistend
      do ia=n0,n
        if (nneig(ia) .gt. 1) then
          do in=nneig(ia),2,-1
            do inn=1,in-1
              if (idistend(ineig(inn,ia)) .lt.
     -            idistend(ineig(in,ia)))
     -          call swapi(ineig(inn,ia),ineig(in,ia))
            end do
          end do
        end if
      end do
      if (idebug(5) .ge. 2) then
        do ia=n0,n
          write (iout,7713) ia,ioldplace(ia),newplace(ia),iparent(ia),
     -      ioldplace(iparent(ia)),idistroot(ia),idistend(ia),
     -      listccfr(ia),listccfl(ia)
        end do
      end if
c     nnloop (i) : copy of nneig (temporary storage)
c     Starting with an atom, the algorithm successively includes its
c     neighbours and then the neighbours of the atoms already on the list.
c     Once a branch is exhausted, it goes back to the list of included atoms
c     until an atom with unexplored neighbours is found.
c     ioldplace(i) is the original sequence number of the i-th atom after the
c     reordering and newplace(i) is the new location of the ith atom inputted.
c     iparent(i) is the last atom on the path from the icenter to i.
c     idon(i) : 1 - atom i is not accounted for; 0 - accounted for (inp order)
      do ia=n0,n
        nnloop(ia)=nneig(ia)
        itangon(ia)=1
        newplace(ia)=ia
        ioldplace(ia)=ia
      end do
      do i=n0,n
        idon(i)=1
        iparent(i)=-99
        if (idebug(5) .ge. 1) write
     -    (iout,7715) i,(ineig(j,i),j=1,nneig(i))
      end do
      ioldplace(n0)=icenter
      newplace(icenter)=n0
      idon(icenter)=0
      iparent(n0)=n0
      itangon(n0)=0
      nfound=n0
      if (n .eq. n0) return
      do in0=1,nneig(icenter)
c       Grow trees from icenter's neigs
        io=ineig(in0,icenter)
        if (idon(io) .eq. 1) then
          nfound=nfound+1
          iparent(nfound)=n0
          ioldplace(nfound)=io
          newplace(io)=nfound
          idon(io)=0
          lll=0
          if (nnloop(io) .eq. 1) itangon(nfound)=0
          ibranchroot=nfound
          kroot=ibranchroot
c         Start search  from kroot
          if (idebug(5) .ge. 2)
     -      write (iout,*) 'PROD Search started at root atom ',io
c         Move icenter to the end of the neighbour list
          nnio=nneig(io)
          call swapng(ineig,nnloop,io,icenter,nnio,1,maxat,maxneig)
          do while (kroot .gt. ibranchroot .or.
     -      (kroot .eq. ibranchroot .and. nnloop(io) .gt. 0))
c           There is unexplored branch left
            if (idebug(5) .gt. 2)
     -        write (iout,7711) 'PROD',kroot,nfound,io,nnloop(io)
            if (nnloop(io) .gt. 0) then
c             There is neighbour left at kroot
              icc=ineig(nnloop(io),io)
              if (idon(icc) .eq. 1) then
c               Unused neighbour, include
                nfound=nfound+1
                iparent(nfound)=kroot
                ioldplace(nfound)=icc
                newplace(icc)=nfound
                idon(icc)=0
                if (idebug(5) .gt. 2) write (iout,7720) 'PROD',kroot,
     -            ioldplace(kroot),nfound,io,icc,nnloop(io)
c               Move parent to the end of list
                nnicc=nneig(icc)
c               call swapng(ineig,nnloop,icc,io,nnicc,1,maxat,maxneig)
                if (nneig(icc) .eq. 1) then
c                 End of a branch, terminal bond is not a torsion bond
                  itangon(nfound)=0
                else
c                 Move kroot down
                  kroot=nfound
                end if
              else if (newplace(icc) .ne. iparent(newplace(io))) then
c               Neighbour is used - loop found
c               Remove loop-closing bond
                if (idebug(5) .gt. 1) write (iout,7717) io,icc
                nnlicc=nnloop(icc)
                call swapng(ineig,nnloop,icc,io,nnlicc,1,maxat,maxneig)
              end if
              nnloop(io)=nnloop(io)-1
              io=ioldplace(kroot)
            else
c             No more neighbour - move kroot back to next level
              kroot=iparent(kroot)
              io=ioldplace(kroot)
              lll=lll+1
              if (lll .gt. 4*(n-n0+1)) then
                write (iout,*) 'PROGRAM ERROR: looping'
                kroot= -1
              end if
            end if
          end do
        end if
      end do
      if (idebug(5) .ge. 2) then
        do iao=n0,n
          ia=newplace(iao)
          write (iout,7714) ia,iao,iparent(ia),ioldplace(iparent(ia)),
     -      itangon(ia),idistroot(ia),idistend(ia),listccfr(ia),
     -      listccfl(ia)
        end do
      end if
      icfrloop=0
      icflloop=0
c     Now record loop info in itangon
      do i=n0,n
        if (listccfr(ioldplace(i)) .gt. 0) then
c         Frozen loop
          if (listccfr(ioldplace(i)) .eq.
     -        listccfr(ioldplace(iparent(i)))) itangon(i)=0
          if (ioldplace(i) .eq. icenter)
     -      icfrloop=listccfr(ioldplace(i))
        end if
        if (listccfl(ioldplace(i)) .gt. 0 .and. itangon(i) .gt. 0) then
c         Flexible loop
          itangon(i)=-1
          if (ioldplace(i) .eq. icenter)
     -      icflloop=listccfl(ioldplace(i))
        end if
      end do
      if (icfrloop .gt. 0 .or.
     -    (icflloop .gt. 0 .and. iop(91) .eq. 0)) then
c       Center is in a frozen loop
        write (iout,1004) icenter
        nwwarn=nwwarn+1
      end if
c     Immobilize all (iop91=0) or just the branch points of flexible loops
      do i=n0,n
        if (itangon(i) .lt. 0) then
          io=ioldplace(i)
          nln=0
          do in=1,nneig(io)
            if (itangon(newplace(ineig(in,io))) .lt. 0) nln=nln+1
          end do
          if (nln .gt. 2 .or. iop(91) .eq. 0) then
            itangon(i)=0
c           itangon(iparent(i))=0
            if (nln .gt. 2)
     -        write (iout,7716) io,(ineig(in,io),in=1,nneig(io))
          end if
        end if
      end do
      itangon(newplace(icenter))=0
      do ia=n0,n
        if (ioldplace(ia) .le. 0 .or. newplace(ia) .lt. 0) then
          write (iout,1005) 'invalid pointer(s)',ia,newplace(ia),
     -      ioldplace(ia)
          inperr=inperr+1
        else if (ioldplace(newplace(ia)) .ne. ia) then
          write (iout,1005) 'inconsistent pointers',ia,newplace(ia),
     -      ioldplace(ia)
          inperr=inperr+1
        end if
        if (idistroot(ia) .gt. maxbrlen) maxbrlen=idistroot(ia)
      end do
      if (idebug(5) .ge. 1) then
        do ia=n0,n
          iao=ioldplace(ia)
          write (iout,7714) ia,iao,iparent(ia),ioldplace(iparent(ia)),
     -      itangon(ia),idistroot(ia),idistend(ia),listccfr(ia),
     -      listccfl(ia)
        end do
      end if
      if (nfound .ne. n) then
        write (iout,1001) nfound,n
        inperr=inperr+1
        do ia=n0,n
          if (newplace(ia) .eq. 0) write (iout,1002) i
        end do
      end if
      return
c1000  format(' ***** ERROR: Atom',i5,' has only',i2,' neighbours - ',
c     -  'can not be the topology center')
1001  format(' ***** PROGRAM ERROR:',i5,' atoms scanned instead of ',i5)
1002  format(6x,'Atom number with newplace=0:',i6)
1003  format(' ***** PROGRAM ERROR: number of root distances assigned=',
     -  i6,' n0,n=',2i8)
1004  format(' ===== STRONG WARNING: atom ',i5,', the topological ',
     -  'center chosen is in a frozen loop - you may want to specify a',
     -  ' different center')
1005  format(' ***** PROGRAM ERROR: ',a,' ia=',i5,
     -  ' newplace=',i5,' ioldplace=',i5)
7709  format(' TOPOLOGY: ',a,':',/(20i6))
7710  format(' TOPOLOGY: Loop nmem=',i4,' nbottom=',i1,/(20i6))
7711  format(' TOPOLOGY: ',a,' kroot=',i4,' nfd=',i4,' io=',i4,
     -  ' nnloop=',i4)
7712  format(' TOPOLOGY: ',a,' kroot(n/o)=',i4,i5,' nfound=',i6,
     -  ' io=',i6,' icc=',i6,' nnloop=',i4)
7713  format(' TOPOLOGY:',i5,' io=',i4,' in=',i4,' ipar(n/o)=',i4,i5,
     -  ' idroot=',i4,' idend=',i4,' lccfr/fl=',i4,i5)
7714  format(' TOPOLOGY: in=',i4,' io=',i4,' ipar(n/o)=',i4,i5,
     -  ' taon=',i2,' idroot=',i4,' idend=',i4,' lccfr/fl=',i4,i5)
7715  format(' TOPOLOGY: ia=',i4,' neigs: ',6i4)
7716  format(' TOPOLOGY: Branch point in flexible looop at atom',i6,
     -  ' (torsion removed) Neighbors:',8i7)
              write (iout,7716) io,(ineig(in,io),in=1,nneig(io)),io
7717  format(' TOPOLOGY: loop closing bond removed icc,io=',2i6)
7718  format(' TOPOLOGY: ia=',i7,' iparent=',i7)
7719  format(' TOPOLOGY: Backtracking from endpoint=',i7,' to=',i7,
     -  ' idistend=',i3)
7720  format(' TOPOLOGY: ',a,' kroot(n/o)=',i4,i5,' nfound=',i5,
     -  ' io=',i6,' icc=',i6,' nnloop=',i4)
      end
      subroutine validindex(n0,n,iarr,ia,iout,inperr,label)
c#    MMC routine 329 lstmod: 10/06/03
c*****Make sure an atomnumber related index is valid
      dimension iarr(n)
      character*8 label
      if (iarr(ia) .lt. n0 .or. iarr(ia) .gt. n) then
        write (iout,1006) ia,label,iarr(ia)
        inperr=inperr+1
        iarr(ia)=ia
      end if
      return
1006  format(' ***** PROGRAM ERROR: Atom',i5,' has invalid ',a,
     -  ' atom:',i9)
      end
      subroutine swapng(ing,nng,ia,in,iplace,idecr,maxat,maxneig)
c#    MMC routine 330 lstmod: 03/18/97
c*****Move atom in to be the iplace-th neighbour of atom ia,
      dimension ing(maxneig,maxat),nng(maxat)
c     Decrement ng count if idecr=1
C@DB      print *,'SWAPNG ia,in,idecr=',ia,in,idecr
      do i=1,nng(ia)
        if (i .ne. iplace) then
          if (ing(i,ia) .eq. in) then
            ing(i,ia)=ing(iplace,ia)
            ing(iplace,ia)=in
          end if
        end if
      end do
      if (idecr .eq. 1) nng(ia)=nng(ia)-1
      return
      end
      subroutine swapi(i1,i2)
c#    MMC routine 331 lstmod: 05/22/97
c*****Swap two integers
      ii=i1
      i1=i2
      i2=ii
      return
      end
      subroutine swapr(r1,r2)
c#    MMC routine 332 lstmod: 05/22/97
c*****Swap two reals
      rr=r1
      r1=r2
      r2=rr
      return
      end
      subroutine swaprot(nrot,irotlinc,irotlist,ii)
c#    MMC routine 333 lstmod: 03/25/02
      dimension irotlist(#ST)
      do it=3,nrot
        if (irotlist(irotlinc+it) .eq. ii) then
          call swapi(irotlist(irotlinc+2),irotlist(irotlinc+it))
          return
        end if
      end do
      return
      end
      subroutine torsion(n0,n,icenter,iroots,natfx0,natfx,ioldplace,
     -  iparent,itangon,iprecursor,nnext,nrot,irotlist,
     -  irotlinc,itangindx,itorsionroot,nneig,ineig,ntang0,ntang,
     -  LEVTEST,iout,inperr,maxtor,maxat,maxneig)
c#    MMC routine 334 lstmod: 02/03/20
c*****Find the rotatable bonds and the list of atoms each rotatable bond
c     moves directly
      dimension iroots(maxat),iparent(maxat),ioldplace(maxat),
     -  itangon(maxat),iprecursor(2,maxat),nnext(maxat),
     -  nrot(maxat),irotlist(maxat),irotlinc(maxat),itangindx(maxtor),
     -  itorsionroot(maxat),nneig(maxat),ineig(maxneig,maxat)
c     nnext(i) is the number of atoms affected (if any) by the
c     torsion angle around the bond ending at atom i (counted from the center).
c     iprecursor(1,i) and iprecursor(2,i) are the closer and farther torsion
c     bond atoms of the last torsion bond on the path from the center to atom i.
c     nrot(it) is the number of atoms to be rotated with the it-th torsion
c     stored in the array irotlist from irotlinc(it)+1,
c     itorsionroot(i) is the end of the torsion bond that directly rotates
c     atom i.
      ntang=ntang0
      do i=n0,n
        nnext(i)=0
c       Set precursors for each bond end
        call validindex(n0,n,iparent,i,iout,inperr,' parent1')
        i1=iparent(i)
        call validindex(n0,n,iparent,i1,iout,inperr,' parent2')
        call validindex(n0,n,ioldplace,i1,iout,inperr,'oldplace')
        iprecursor(1,ioldplace(i))=ioldplace(i1)
        iprecursor(2,ioldplace(i))=ioldplace(iparent(i1))
      end do
c     Special treatment of root precursors
      nroots=nneig(icenter)+1
      iroots(natfx0+1)=icenter
      if (nroots .gt. 1) iroots(natfx0+2)=ineig(1,icenter)
      if (nroots .lt. 3) then
        natfx=natfx0+nroots
        write (iout,1001) icenter
        inperr=inperr+1
        return
      end if
      do in0=3,nroots
        iroots(natfx0+in0)=ineig(in0-1,icenter)
        if (iprecursor(1,ineig(in0-1,icenter)) .eq. icenter)
     -    iprecursor(2,ineig(in0-1,icenter))=ineig(1,icenter)
      end do
      if (iprecursor(1,ineig(1,icenter)) .eq. icenter)
     -  iprecursor(2,ineig(1,icenter))=ineig(nroots-1,icenter)
      do i=n0,n
        io=ioldplace(i)
        matchroot=0
        do ir=1,nroots
          if (iroots(ir) .eq. io) matchroot=1
        end do
        if (matchroot .eq. 0 .or. iparent(i) .eq. n0) then
          ic=i
          nstep=0
          do while (iparent(ic) .ne. n0 .and. nstep .le. n-n0)
c           Backtrack to increment nnext
            ic=iparent(ic)
            ico=ioldplace(ic)
            nnext(ico)=nnext(ico)+1
            nstep=nstep+1
          end do
        end if
      end do
c     Scan the atoms to find the torsion moving that atom
c     natfx=natfx0
      natfx=natfx0+nroots
      do ia=n0,n
        iao=ioldplace(ia)
        ic=ia
        itorsionroot(iao)=0
        nstep=0
        do while (itangon(iparent(ic)) .eq. 0 .and. iparent(ic) .ne. n0
     -    .and. nstep .le. n-n0)
c         Backtrack to first torsion or root
          ic=iparent(ic)
          nstep=nstep+1
        end do
        if(iparent(ic) .ne. n0) itorsionroot(iao)=ioldplace(iparent(ic))
        if (itorsionroot(iao) .eq. 0) then
c         Check if not in the root set
          matchroot=0
          do i=1,nroots
            if (iroots(natfx0+i) .eq. iao) matchroot=1
          end do
          if (matchroot .eq. 0) then
            natfx=natfx+1
            iroots(natfx)=iao
          end if
        end if
      end do
      nrt=n0
      ndup=0
      do i0n=n0,n
c       Now collect torsion lists
        i0o=ioldplace(i0n)
        if (itangon(i0n) .ne. 0) then
c         Torsion bond found
          ntang=ntang+1
          itangindx(ntang)=i0o
          irotlinc(ntang)=nrt-1
          do ia=i0n+1,n
            iao=ioldplace(ia)
c           if (matchroot .eq. 0 .and. itorsionroot(iao) .eq. i0o) then
            if (itorsionroot(iao) .eq. i0o) then
c             Check if not in the root set
              do i=1,nroots
                if (iroots(natfx0+i) .eq. iao) ndup=ndup+1
              end do
c             Rotated atom found
              irotlist(nrt)=iao
              nrt=nrt+1
            end if
          end do
c         Keep torsion only if the torsion list is not empty
          if (nrt .gt. irotlinc(ntang)+1) then
            nrot(ntang)=nrt-1-irotlinc(ntang)
          else
            ntang=ntang-1
          end if
        end if
      end do
      if (nrt-ndup-n0+natfx-natfx0 .ne. n-n0+1) then
        write (iout,1000) nrt,ndup,natfx0,natfx,n0,n
        inperr=inperr+1
      end if
      if (LEVTEST .gt. 0) then
        write (iout,7713) natfx0,natfx,(iroots(i),i=natfx0+1,natfx)
        do i=n0,n
          write (iout,7711) i,iprecursor(1,i),iprecursor(2,i),nnext(i),
     -      itorsionroot(i),ioldplace(i),itangon(i),
     -      itangon(ioldplace(i))
        end do
        do it=ntang0+1,ntang
          write (iout,7712) it,itangindx(it),nrot(it),
     -      nnext(itangindx(it)),irotlinc(it),
     -      (irotlist(irotlinc(it)+ia),ia=1,nnext(itangindx(it)))
        end do
      end if
      return
1000  format(' ***** PROGRAM ERROR: not all rotated atoms are listed',
     -  ' nrt,natfx0,natfx=',3i4,' n0,n=',2i5)
1001  format(' ***** ERROR: center chosen (',i6,') needs more than one',
     -  ' neighbors for torsion setup')
7711  format(' TORSION: ',i4,' prec=',2i4,' nnext=',i4,' troot=',
     -      i4,' iold=',i4,' itaon(n/o)=',i2,i3)
7712  format(' TORSION: ',i4,' taix=',i4,' nrot=',i4,' nnext=',i4,
     -  ' inc=',i4,(' list=',25i5))
7713  format(' TORSION: natfx0,fx=',2i5,(' iroot=',10i4))
      end
      function itorsfind(iroot,ntang,iquata,iout,inperr,nowarn)
c#    MMC routine 335 lstmod: 04/06/08
c*****Find the torsion angle at atom iroot
      dimension iquata(#TR,4)
      it=0
      do itg=1,ntang
        if (iroot .eq. iquata(itg,3)) it=itg
      end do
      if (it .eq. 0 .and. nowarn .eq. 0) then
        write (iout,1000) iroot
        inperr=inperr+1
        it=1
      end if
      itorsfind=it
      return
1000  format(' ***** PROGRAM ERROR: No torsion found for atom',i5)
      end
      subroutine rot_trans_list(c0,c,n0,n,list,rot,disp,maxat,idbg,iout)
c#    MMC routine 336 lstmod: 06/19/97
c*****Rotate the n atoms in list from c0 to c by rot around atom 0,
c     displace them by disp from <0,0,0>
      dimension c0(3,maxat),c(3,maxat),list(maxat),rot(3,3),disp(3)
      if (idbg .gt. 0)
     -  write (iout,1000) (i,list(i),(c0(k,list(i)),k=1,3),i=n0,n)
      do i=n0,n
        do k=1,3
          c(k,list(i))=disp(k)+
     -      (rot(k,1)*c0(1,list(i))+rot(k,2)*c0(2,list(i))+
     -       rot(k,3)*c0(3,list(i)))
        end do
      end do
      return
1000  format(' TRANSROT i=',i5,' list=',i5,' c0=',3f10.5)
      end
C@SPLIT3
      subroutine findbdag(n1,n,c,bond,bond2,angle,cangle,bond13,bond12,
     -  angle13,cangle13,iprecursor,nlist,list,LEVTEST,inperr,iout,
     -  maxat)
c#    MMC routine 337 lstmod: 10/06/03
c*****Find the bond lengths and angles between each atom and its precursor(s)
      dimension c(3,maxat),bond(maxat),bond2(maxat),angle(maxat),
     -  cangle(maxat),bond13(maxat),bond12(maxat),angle13(maxat),
     -  cangle13(maxat),iprecursor(2,maxat),list(maxat)
c     bond(i) is the bond between atom i and its iprecursor,
c     cangle(i) is the cosine of the angle whose vertex is at the
c     precursor of atom i
      if (n-n1 .lt. 2) return
      do i=n1,n
        i2=iprecursor(1,i)
        i1=iprecursor(2,i)
        if (i1 .lt. n1 .or. i2 .lt. n1 .or.
     -      i1 .gt. n .or. i2 .gt. n) then
          write (iout,1000) i,i1,i2
          inperr=inperr+1
          return
        end if
        rr=0.0
        rr13=0.0
        r12=0.0
        r13=0.0
        do k=1,3
          dx=c(k,i)-c(k,i2)
          dy=c(k,i1)-c(k,i2)
          rr=rr+dx*dx
          r12=r12+dx*dy
          dx=c(k,i)-c(k,i1)
          rr13=rr13+dx*dx
          r13=r13-dy*dx
        end do
        bond2(i)=rr
        bond(i)=sqrt(rr)
        bond13(i)=sqrt(rr13)
        cangle(i)=r12
        cangle13(i)=r13
        if (LEVTEST .gt. 0) write (iout,7711) i,i1,i2,i,bond(i),
     -    bond13(i),r12,r13
      end do
c     Normalize the dot product to get the cosine
      do i=n1,n
        bond12(i)=bond(iprecursor(1,i))
      end do
      if (LEVTEST .gt. 0) write (iout,7712) (list(i),i=1,nlist)
      do i=n1,n
c       Don't calculate only for the center
        if (LEVTEST .gt. 0)
     -    write (iout,7713) i,bond(i),bond12(i),bond13(i)
        if (i .ne. list(1)) then
            if (iprecursor(1,i) .eq. list(1) .or.
     -        iprecursor(1,i) .ne. iprecursor(2,i)) then
c           bond12 is zero - define it here
            rr=arrdist(c(1,iprecursor(1,i)),c(1,iprecursor(2,i)))
            bond12(i)=sqrt(rr)
          end if
          cangle(i)=cangle(i)/(bond(i)*bond12(i))
          angle(i)=acoscheck(cangle(i),iout,'FINDBDAG')
          cangle13(i)=cangle13(i)/(bond12(i)*bond13(i))
          angle13(i)=acoscheck(cangle13(i),iout,'FINDBDAG')
          if (LEVTEST .gt. 0)
     -      write (iout,7714) iprecursor(2,i),iprecursor(1,i),i,
     -        cangle(i),cangle13(i)
        end if
      end do
      return
1000  format(' ***** PROGRAM ERROR: invalid precursors for atom ',i6,
     -  ' :',2i9)
7711  format(' FINDBDAG: ',i5,' i1,2,3=',3i6,' bond(i3)=',f6.3,
     -  ' bond13(i3)=',f6.3,' r12=',f6.3,' r13=',f6.3)
7712  format(' FINDBDAG: Roots ',20i5)
7713  format(' FINDBDAG: i3=',i4,' bind(i3)=',f6.2,' bond12(i3)=',f6.3,
     -  ' bond13(i3)=',f6.3)
7714  format(' FINDBDAG: i1,2,3=',3i6,' cangle(i3)=',f8.5,
     -  ' cangle13(i3)=',f8.5)
      end
      subroutine inittor(ntang1,ntang,c,itangindx,iprecursor,nrot,
     -  irotlist,irotlinc,bond,bond2,angle,cangle,bond13,bond12,
     -  cangle13,bondf,bondproj,xfac13,xfac12,cangle40,bond420,
     -  LEVTEST,iout,maxtor,maxat)
c#    MMC routine 338 lstmod: 10/24/20
c*****Initialize xfac13, xfac12 for torsion angle reconstruction of the molec
      dimension c(3,maxat),itangindx(maxtor),iprecursor(2,maxat),
     -  nrot(maxat),irotlist(maxat),irotlinc(maxat),bond(maxat),
     -  bond2(maxat),angle(maxat),cangle(maxat),bond13(maxat),
     -  bond12(maxat),angle13(maxat),cangle13(maxat),bondf(maxat),
     -  bondproj(maxat),xfac13(maxat),xfac12(maxat),cangle40(maxat),
     -  bond420(maxat)
      common /looptorsave/ bondo(#LS),bond2o(#LS),bond12o(#LS),
     -  bond13o(#LS),cangleo(#LS),cangle13o(#LS),bondfo(#LS),
     -  bondprojo(#LS),xfac12o(#LS),xfac13o(#LS),angleo(#LS),
     -  angle13o(#LS)
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpip2,dc1pc2,dc1pc4,dbond2,r23(3),cangle4,sangle4,
     -  bond42,dx,dk,rr
      dpip2=datan(1.d0)*2.d0
      do it=ntang1,ntang
        i3=itangindx(it)
        i2=iprecursor(1,i3)
        i1=iprecursor(2,i3)
        do k=1,3
          r23(k)=c(k,i3)-c(k,i2)
        end do
        if (LEVTEST .gt. 0) write (iout,7711)
     -    it,i1,i2,i3,bond(i3),bond12(i3),bond13(i3),cangle13(i3),
     -    nrot(it),irotlinc(it)
        do i=1,nrot(it)
          i4=irotlist(irotlinc(it)+i)
          if (i3 .eq. iprecursor(1,i4)) then
            bond4=bond(i4)
            bond42=bond2(i4)
            cangle4=cangle(i4)
            bondf(i4)=(bond(i3)-bond4*cangle(i4))/bond(i3)
            bondproj(i4)=sqrt(1.0-cangle(i4)**2)*bond4
          else
c           Calculate and save distance, angle to torsion root
            bond42=0.d0
            cangle4=0.d0
            do k=1,3
              dx=c(k,i4)-c(k,i3)
              bond42=bond42+dx*dx
              cangle4=cangle4-dx*r23(k)
            end do
            bond4=dsqrt(bond42)
            cangle4=cangle4/(bond4*bond(i3))
            bondf(i4)=(bond(i3)-bond4*cangle4)/bond(i3)
            rr=0.0
            do k=1,3
              dk=c(k,i2)+r23(k)*bondf(i4)
              dx=c(k,i4)-dk
              rr=rr+dx*dx
            end do
            bondproj(i4)=sqrt(rr)
            bond420(i4)=bond42
            cangle40(i4)=cangle4
          end if
          sangle4=dsqrt(1.d0-cangle4**2)
          if (bond(i2) .eq. 0.0) then
            b2=arrdist(c(1,i1),c(1,i2))
            dbond2=dsqrt(dble(b2))
          else
            dbond2=bond(i2)
          end if
c         dc1pc2=
c    -      (bond(i4)*dcos(angle(i4)-dpip2))/dcos(angle(i3)-dpip2)
          dc1pc2=(bond4*sangle4)/dcos(dble(angle(i3))-dpip2)
c         dc1pc4=bond(i3)+dc1pc2*dsin(dble(angle(i3))-dpip2)+
c    -      bond(i4)*dsin(dble(angle(i4))-dpip2)
          dc1pc4=bond(i3)+dc1pc2*dsin(dble(angle(i3))-dpip2)-
     -      bond4*cangle4
          xfac12(i4)=dc1pc2/dbond2
          xfac13(i4)=dc1pc4/bond(i3)
          if (LEVTEST .gt. 0)
     -       write (iout,7715) i4,bond4,bondf(i4),bondproj(i4),
     -         cangle40(i4),xfac12(i4),xfac13(i4)
c         if (LEVTEST .gt. 1) then
c           Consistency test
c           dev13=bond42-a*b-(b/a)+chfac*b*cangle13(i3)
c           dev12=bond2(i3)-bond13(i3)*bond13(i3)-
c    -        bond12(i3)*bond12(i3)+
c    -        2.0*bond12(i3)*bond13(i3)*cangle13(i3)
c           write (iout,7712) alpha,beta,gamma,a,b,chfac,dev13,dev12
c         end if
        end do
      end do
      return
7711  format(' INITTOR: it=',i5,' i1,2,3=',3i6,' b3=',f6.4,' b12=',
     -  f8.4,' b13=',f8.4,' ca13=',f6.4,' nr=',i2,' inc=',i5)
c7712 format(19x,'al=',f6.4,' be=',f6.4,' ga=',f6.4,' a=',f9.4,' b=',
c    -  f9.4,' chf=',f4.1,' Self test: dev13,12=',2e12.5)
7715  format(10x,'i4=',i5,' b4=',f6.4,' bf=',f6.4,' bp=',f6.4,
     -  ' c4=',f6.4,' xfac12,13=',2f10.5)
      end
      subroutine updatesc(itor1,itor2,loopnum,loopmem,itorsionroot,
     -  itangon,iquata,c,iprecursor,nrot,irotlist,irotlinc,
     -  bond,bond2,angle,cangle,bond13,bond12,angle13,cangle13,bondf,
     -  bondproj,xfac13,xfac12,cangle40,bond420,LEVTEST,iout,
     -  maxat,maxtor)
c#    MMC routine 339 lstmod: 10/24/20
c*****Reinitialize xfac13, xfac12 for torsion angle reconstruction of the molec
c     for the torsions involved with the driver torsion it
      dimension iquata(maxtor,6),loopmem(maxat),itorsionroot(maxat),
     -  itangon(maxat),
     -  c(3,maxat),iprecursor(2,maxat),
     -  nrot(maxat),irotlist(maxat),irotlinc(maxat),bond(maxat),
     -  bond2(maxat),angle(maxat),cangle(maxat),bond13(maxat),
     -  bond12(maxat),angle13(maxat),cangle13(maxat),bondf(maxat),
     -  bondproj(maxat),xfac13(maxat),xfac12(maxat),cangle40(maxat),
     -  bond420(maxat)
      common /looptorsave/ bondo(#LS),bond2o(#LS),bond12o(#LS),
     -  bond13o(#LS),cangleo(#LS),cangle13o(#LS),bondfo(#LS),
     -  bondprojo(#LS),xfac12o(#LS),xfac13o(#LS),angleo(#LS),
     -  angle13o(#LS)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
c     Update side chain torsion constants immediate to loops
      real*8 dpip2,dc1pc2,dc1pc4,dbond2
      dpip2=datan(1.d0)*2.d0
      do it=itor1,itor2
        i2=iquata(it,2)
        if (loopnum .eq. loopmem(itangon(itorsionroot(i2)))) then
c         Torsion precursor includes loop bond
          i1=iquata(it,1)
          i3=iquata(it,3)
          d12=arrdist(c(1,i1),c(1,i2))
          d13=bond13(i3)**2
          d23=bond2(i3)
          cangle13(i3)=0.5*(d12+d13-d23)/sqrt(d12*d13)
          angle13(i3)=acoscheck(cangle13(i3),iout,'UPDATESC3')
          if (LEVTEST .gt. 0) write (iout,7711) it,i1,i2,i3,
     -      bond(i3),bond2(i3),bond12(i3),bond13(i3),cangle(i3),
     -      cangle13(i3)
          do i=1,nrot(it)
            i4=irotlist(irotlinc(it)+i)
            if (i3 .eq. iprecursor(1,i4)) then
              bond4=bond(i4)
              bond42=bond2(i4)
              cangle4=cangle(i4)
            else
              bond42=bond420(i4)
              bond4=sqrt(bond42)
              cangle4=cangle40(i4)
            end if
            bondproj(i4)=sqrt(1.0-cangle4**2)*bond4
            bondf(i4)=(bond(i3)-bond4*cangle4)/bond(i3)
            xfac12o(i4)=xfac12(i4)
            xfac13o(i4)=xfac13(i4)
            if (bond(i2) .eq. 0.0) then
              b2=arrdist(c(1,i1),c(1,i2))
              dbond2=dsqrt(dble(b2))
            else
              dbond2=bond(i2)
            end if
            sangle4=dsqrt(1.d0-cangle4**2)
            dc1pc2=(bond4*sangle4)/dcos(dble(angle(i3))-dpip2)
            dc1pc4=bond(i3)+dc1pc2*dsin(dble(angle(i3))-dpip2)-
     -        bond4*cangle4
            xfac12(i4)=dc1pc2/dbond2
            xfac13(i4)=dc1pc4/bond(i3)
            if (LEVTEST .gt. 0) write (iout,7715) i4,bond4,
     -        bondf(i4),bondproj(i4),cangle4,xfac12(i4),
     -        xfac13(i4),xfac12o(i4),xfac13o(i4)
            if (LEVTEST .gt. 1 .and. chfac .ne. 0.0) then
c             Consistency test
              dev13=bond42-a*b-(b/a)+chfac*b*cangle13(i3)
              dev12=bond2(i3)-bond13(i3)*bond13(i3)-
     -          bond12(i3)*bond12(i3)+
     -          2.0*bond12(i3)*bond13(i3)*cangle13(i3)
              write (iout,7712) alpha,beta,gamma,a,b,chfac,
     -          dev13,dev12
            end if
          end do
        end if
      end do
      return
7711  format(' UPDATESC: it=',i5,' i1,2,3=',3i6,' b3=',f8.6,
     -  ' b2=',f8.6,' b12=',f8.6,' b13=',f8.6,' ca=',f8.6,' ca13=',f8.6)
7712  format(19x,'al=',f6.4,' be=',f6.4,' ga=',f6.4,' a=',f9.4,' b=',
     -  f9.4,' chf=',f4.1,' Self test: dev13,12=',2e12.5)
7715  format(10x,'i4=',i5,' b4=',f6.4,' bf=',f6.4,' bp=',f6.4,' c4=',
     -  f6.4,' xfac12,13=',2f10.6,' xfac12,13o=',2f10.6)
      end
      subroutine updateloop(itor,iquata,looplist,c,iprecursor,nrot,
     -  irotlist,irotlinc,bond,bond2,angle,cangle,bond13,bond12,angle13,
     -  cangle13,bondf,bondproj,xfac13,xfac12,cangle40,bond420,LEVTEST,
     -  iout,maxat,maxtor)
c#    MMC routine 340 lstmod: 10/24/20
c*****Reinitialize xfac13, xfac12 for torsion angle reconstruction of the molec
c     for the torsions involved with the driver torsion it
      dimension iquata(maxtor,6),looplist(6,maxtor),
     -  c(3,maxat),iprecursor(2,maxat),
     -  nrot(maxat),irotlist(maxat),irotlinc(maxat),bond(maxat),
     -  bond2(maxat),angle(maxat),cangle(maxat),bond13(maxat),
     -  bond12(maxat),angle13(maxat),cangle13(maxat),bondf(maxat),
     -  bondproj(maxat),xfac13(maxat),xfac12(maxat),cangle40(maxat),
     -  bond420(maxat)
      common /looptorsave/ bondo(#LS),bond2o(#LS),bond12o(#LS),
     -  bond13o(#LS),cangleo(#LS),cangle13o(#LS),bondfo(#LS),
     -  bondprojo(#LS),xfac12o(#LS),xfac13o(#LS),angleo(#LS),
     -  angle13o(#LS)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 dpip2,dc1pc2,dc1pc4,dbond2,r23(3),cangle4,sangle4,
     -  dbond42,dx,dk,rr
      data i4prec /0/,bond42 /0.0/,dbond42 /0.d0/
      dpip2=datan(1.d0)*2.d0
c     First just save the current values
      do itt=1,6
        it=looplist(itt,itor)
        i3=iquata(it,3)
        i2=iquata(it,2)
        i1=iquata(it,1)
        if (itt .lt. 6) then
          bond2o(i3)=bond2(i3)
          bondo(i3)=bond(i3)
          bond12o(i3)=bond12(i3)
        end if
        bond13o(i3)=bond13(i3)
        angleo(i3)=angle(i3)
        angle13o(i3)=angle13(i3)
        cangleo(i3)=cangle(i3)
        cangle13o(i3)=cangle13(i3)
        do i=1,nrot(it)
          i4=irotlist(irotlinc(it)+i)
          if (itt .lt. 6) then
            icalc=0
            if (i .eq. 1) then
c             Loop member, immediate to i3
              icalc=1
              bondo(i4)=bond(i4)
              bond2o(i4)=bond2(i4)
              bond12o(i4)=bond12(i4)
              bond13o(i4)=bond13(i4)
              cangleo(i4)=cangle(i4)
              bondprojo(i4)=bondproj(i4)
            else if (i4 .eq. iquata(looplist(itt+1,itor),3)) then
c             Loop member, not immediate to i3
c!            Will not work if rigid part of a loop can be longer than 2 atoms!
              icalc=2
              bondo(i4)=bond(i4)
              bond2o(i4)=bond2(i4)
              bond12o(i4)=bond12(i4)
              bond13o(i4)=bond13(i4)
              cangleo(i4)=cangle(i4)
              bondprojo(i4)=bondproj(i4)
              i4prec=iquata(looplist(itt+1,itor),2)
            else if (i3 .eq. iprecursor(1,i4)) then
c             Side chain, immediate to i3
              bond12o(i4)=bond12(i4)
              bond13o(i4)=bond13(i4)
            end if
            bondfo(i4)=bondf(i4)
          end if
          xfac12o(i4)=xfac12(i4)
          xfac13o(i4)=xfac13(i4)
        end do
      end do
c     Now calculate the new values
      do itt=1,6
        it=looplist(itt,itor)
        i3=iquata(it,3)
        i2=iquata(it,2)
        i1=iquata(it,1)
        d12=0.0
        d13=0.0
        d23=0.0
        do k=1,3
          r12=c(k,i2)-c(k,i1)
          r13=c(k,i3)-c(k,i1)
          r23(k)=c(k,i3)-c(k,i2)
          d12=d12+r12*r12
          d13=d13+r13*r13
          d23=d23+r23(k)*r23(k)
        end do
c       if (itt .eq. 1) d12=bond2(i2)
        if (itt .lt. 6) then
          bond2(i3)=d23
          bond(i3)=sqrt(d23)
        end if
        bond13(i3)=sqrt(d13)
        cangle(i3)=0.5*(d12+d23-d13)/sqrt(d12*d23)
        cangle13(i3)=0.5*(d12+d13-d23)/sqrt(d12*d13)
        angle(i3)=acoscheck(cangle(i3),iout,'UPDATELOOP3')
        angle13(i3)=acoscheck(cangle13(i3),iout,'UPDATELOOP13')
        if (LEVTEST .gt. 0) then
          if (LEVTEST .gt. 1)
     -      write (iout,7713) abs(bond13(i3)**2-bond2(i3)-bond12(i3)**2+
     -        2.0*bond(i3)*bond12(i3)*cangle(i3))/(2.0*bond13(i3)**2)
          write (iout,7711) itor,it,i1,i2,i3,bond(i3),bond2(i3),
     -      bond12(i3),bond13(i3),cangle(i3),cangle13(i3)
        end if
        do i=1,nrot(it)
          i4=irotlist(irotlinc(it)+i)
          if (itt .lt. 6) then
            icalc=0
            if (i .eq. 1) then
c             Loop member, immediate to i3
              icalc=1
            else if (i4 .eq. iquata(looplist(itt+1,itor),3)) then
c             Loop member, not immediate to i3
c!            Will not work if rigid part of a loop can be longer than 2 atoms!
              icalc=2
              i4prec=iquata(looplist(itt+1,itor),2)
            else if (i3 .eq. iprecursor(1,i4)) then
c             Side chain, immediate to i3
              bond12(i4)=bond(i3)
c             bond13(i4)=sqrt(arrdist(c(1,i4),c(1,i2)))
              bond13(i4)=sqrt(bond2(i3)+bond2(i4)-
     -          2.0*bond(i3)*bond(i4)*cangle(i4))
c             Use reference values for the rest
              bond4=bond(i4)
              bond42=bond2(i4)
              cangle4=cangle(i4)
            else
c             Side chain, not imediate to i3
              bond42=bond420(i4)
              bond4=sqrt(bond42)
              cangle4=cangle40(i4)
            end if
            if (icalc .gt. 0) then
c             Calculate distance and angle to torsion root
              dbond42=0.d0
              cangle4=0.d0
              do k=1,3
                dx=c(k,i4)-c(k,i3)
                dbond42=dbond42+dx*dx
                cangle4=cangle4-dx*r23(k)
              end do
              bond42=dbond42
              bond4=dsqrt(dbond42)
              cangle4=cangle4/(bond4*bond(i3))
              rr=0.0
              do k=1,3
                dk=c(k,i2)+r23(k)*bondf(i4)
                dx=c(k,i4)-dk
                rr=rr+dx*dx
              end do
              bondproj(i4)=sqrt(rr)
              if (icalc .eq. 1) then
                bond2(i4)=bond42
                bond(i4)=bond4
                bond12(i4)=bond(i3)
                bond13(i4)=sqrt(arrdist(c(1,i4),c(1,i2)))
              else
                bond2(i4)=arrdist(c(1,i4),c(1,i4prec))
                bond(i4)=sqrt(bond2(i4))
                bond12(i4)=bond(i4prec)
c???            d34=arrdist(c(1,i4),c(1,i2))
                d34=arrdist(c(1,i4),c(1,iprecursor(1,i4prec)))
                bond13(i4)=sqrt(d34)
                cangle(i4)=(bond2(i4)+bond2(i4prec)-d34)/
     -            (2.0*sqrt(bond2(i4)*bond2(i4prec)))
              end if
            end if
            bondf(i4)=(bond(i3)-bond4*cangle4)/bond(i3)
          else
            if (i3 .eq. iprecursor(1,i4)) then
c             Immediate to i3
              bond4=bond(i4)
              bond42=bond2(i4)
              cangle4=cangle(i4)
            else
c             Not imediate to i3
              bond42=bond420(i4)
              bond4=sqrt(bond42)
              cangle4=cangle40(i4)
            end if
          end if
          if (bond(i2) .eq. 0.0) then
            b2=arrdist(c(1,i1),c(1,i2))
            dbond2=dsqrt(dble(b2))
          else
            dbond2=bond(i2)
          end if
          sangle4=dsqrt(1.d0-cangle4**2)
          dc1pc2=(bond4*sangle4)/dcos(dble(angle(i3))-dpip2)
          dc1pc4=bond(i3)+dc1pc2*dsin(dble(angle(i3))-dpip2)-
     -      bond4*cangle4
          xfac12(i4)=dc1pc2/dbond2
          xfac13(i4)=dc1pc4/bond(i3)
          if (LEVTEST .gt. 0) write (iout,7715) i4,icalc,bond4,
     -      bondf(i4),bondproj(i4),cangle4,xfac12(i4),xfac13(i4),
     -      xfac12o(i4),xfac13o(i4)
          if (LEVTEST .gt. 1) then
c           Consistency test
            dev13=bond42-a*b-(b/a)+chfac*b*cangle13(i3)
            dev12=bond2(i3)-bond13(i3)*bond13(i3)-
     -        bond12(i3)*bond12(i3)+
     -        2.0*bond12(i3)*bond13(i3)*cangle13(i3)
            write (iout,7712) alpha,beta,gamma,a,b,chfac,icalc,
     -        dev13,dev12
          end if
        end do
      end do
      return
7711  format(' UPDATELOOP: itor,it=',2i5,' i1,2,3=',3i6,' b3=',f8.6,
     -  ' b2=',f8.6,' b12=',f8.6,' b13=',f8.6,' ca=',f8.6,' ca13=',f8.6)
7712  format(19x,'al=',f6.4,' be=',f6.4,' ga=',f6.4,' a=',f9.4,' b=',
     -  f9.4,' chf=',f4.1,' ic=',i1,' Self test: dev13,12=',2e12.5)
7713  format(10x,'Triangle check=',e10.3)
7715  format(10x,'i4=',i5,' ic=',i1,' b4=',f6.4,' bf=',f6.4,' bp=',f6.4,
     -  ' c4=',f6.4,' xfac12,13=',2f10.6,' xfac12,13o=',2f10.6)
      end
      subroutine restoreloop(itor,iquata,looplist,
     -  iprecursor,nrot,irotlist,irotlinc,bond,bond2,angle,cangle,
     -  bond13,bond12,angle13,cangle13,bondf,bondproj,xfac13,xfac12,
     -  LEVTEST,iout,maxat,maxtor,maxlooptor)
c#    MMC routine 341 lstmod: 04/04/13
c*****Restore the saved bond, angle and torsion related constants
c     for the torsions involved with the driver torsion it
      dimension iquata(maxtor,6),looplist(6,maxlooptor),
     -  iprecursor(2,maxat),nrot(maxat),irotlist(maxat),irotlinc(maxat),
     -  bond(maxat),bond2(maxat),angle(maxat),cangle(maxat),
     -  bond13(maxat),bond12(maxat),angle13(maxat),cangle13(maxat),
     -  bondf(maxat),bondproj(maxat),xfac13(maxat),xfac12(maxat)
      common /looptorsave/ bondo(#LS),bond2o(#LS),bond12o(#LS),
     -  bond13o(#LS),cangleo(#LS),cangle13o(#LS),bondfo(#LS),
     -  bondprojo(#LS),xfac12o(#LS),xfac13o(#LS),angleo(#LS),
     -  angle13o(#LS)
      do itt=1,6
        it=looplist(itt,itor)
        i3=iquata(it,3)
        i2=iquata(it,2)
        i1=iquata(it,1)
        if (itt .lt. 6) then
          bond2(i3)=bond2o(i3)
          bond(i3)=bondo(i3)
          bond12(i3)=bond12o(i3)
        end if
        bond13(i3)=bond13o(i3)
        angle(i3)=angleo(i3)
        angle13(i3)=angle13o(i3)
        cangle(i3)=cangleo(i3)
        cangle13(i3)=cangle13o(i3)
        if (LEVTEST .gt. 0) write (iout,7711) itor,it,i1,i2,i3,
     -    bond(i3),bond2(i3),bond12(i3),bond13(i3),cangle(i3),
     -    cangle13(i3)
        do i=1,nrot(it)
          i4=irotlist(irotlinc(it)+i)
          if (itt .lt. 6) then
            if (i .eq. 1) then
c             Loop member, immediate to i3
              bond(i4)=bondo(i4)
              bond2(i4)=bond2o(i4)
              bond12(i4)=bond12o(i4)
              bond13(i4)=bond13o(i4)
              cangle(i4)=cangleo(i4)
              bondproj(i4)=bondprojo(i4)
            else if (i4 .eq. iquata(looplist(itt+1,itor),3)) then
c             Loop member, not immediate to i3
c!            Will not work if rigid part of a loop can be longer than 2 atoms!
              bond(i4)=bondo(i4)
              bond2(i4)=bond2o(i4)
              bond12(i4)=bond12o(i4)
              bond13(i4)=bond13o(i4)
              cangle(i4)=cangleo(i4)
              bondproj(i4)=bondprojo(i4)
            else if (i3 .eq. iprecursor(1,i4)) then
c             Side chain, immediate to i3
              bond12(i4)=bond12o(i4)
              bond13(i4)=bond13o(i4)
            end if
            bondf(i4)=bondfo(i4)
          end if
          xfac12(i4)=xfac12o(i4)
          xfac13(i4)=xfac13o(i4)
          if (LEVTEST .gt. 0) write (iout,7715) i4,bond(i4),
     -      bondf(i4),bondproj(i4),cangle(i4),xfac12(i4),xfac13(i4)
        end do
      end do
      return
7711  format(' RESTORLOOP: itor,it=',2i5,' i1,2,3=',3i6,' b3=',f6.4,
     -  ' b2=',f6.4,' b12=',f6.4,' b13=',f6.4,' ca=',f6.4,' ca13=',f6.4)
7715  format(10x,'i4=',i5,' b4=',f6.4,' bf=',f6.4,' bp=',f6.4,' c4=',
     -  f6.4,' xfac12,13=',2f10.5)
      end
      subroutine torcontest(ntang,iquata,c,iprint,nfail,iout,
     -  maxat,maxtor)
c#    MMC routine 342 lstmod: 11/02/20
c*****Check the data used for torsion angle reconstruction of the molec
      dimension c(3,maxat),iquata(maxtor,4)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      real*8 dflsmin,dflsmax,dflsminr,dflsmaxr,dscis,dstrans,
     -  d02,d03,d12,d13,d14,d23,d24,d25,d34,d35,d36,d47,d45,d46,d56,
     -  d57,d58,d67,d68,d69,d78,d79
      common /loopdat/ dflsmin(#LT),dflsmax(#LT),dflsminr(#LT),
     -  dflsmaxr(#LT),dscis(#LT),dstrans(#LT),
     -  d02(#LT),d03(#LT),d12(#LT),d13(#LT),
     -  d14(#LT),d23(#LT),d24(#LT),d25(#LT),d34(#LT),d35(#LT),
     -  d36(#LT),d45(#LT),d46(#LT),d47(#LT),d56(#LT),d57(#LT),
     -  d58(#LT),d67(#LT),d68(#LT),d69(#LT),d78(#LT),d79(#LT)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      dimension r12(3),r13(3),r23(3)
      character*3 lab(2)
      data lab /'   ','***'/
      PI2=2.0*PI
      dpip2=atan(1.0)*2.0
      nfail=0
      do it=1,ntang
        if (iri(it) .gt. 1) then
          write (iout,1012) it,iri(it)
          nfail=nfail+1
         end if
        i3=itangindx(it)
        i2=iprecursor(1,i3)
        i1=iprecursor(2,i3)
        call arrdiff(r12,c(1,i1),c(1,i2),3)
        call arrdiff(r13,c(1,i1),c(1,i3),3)
        call arrdiff(r23,c(1,i3),c(1,i2),3)
        bnd232=arrdist(c(1,i2),c(1,i3))
        dbond2=abs(bond2(i3)-bnd232)/(2.0*bnd232)
        bnd23=sqrt(bnd232)
        dbond=abs(bond(i3)-bnd23)
        bnd122=arrdist(c(1,i1),c(1,i2))
        bnd12=sqrt(bnd122)
        dbond12=abs(bond12(i3)-bnd12)
        bnd132=arrdist(c(1,i1),c(1,i3))
        bnd13=sqrt(bnd132)
        dbond13=abs(bond13(i3)-bnd13)
        cang=sclprd(r12,r23)/(bnd12*bnd23)
        dcang=abs(cangle(i3)-cang)
        ang=acoscheck(cang,iout,'TORCONTEST-ang')
        dang=abs(angle(i3)-ang)*rdtodg
        cang13=sclprd(r12,r13)/(bnd12*bnd13)
        dcang13=abs(cangle13(i3)-cang13)
        ang13=acoscheck(cang13,iout,'TORCONTEST-ang13')
        dang13=abs(angle13(i3)-ang13)*rdtodg
        alpha=angle(i3)
        gamma=angle13(i3)
        devc=amax1(dcang13,dcang)
        deva=amax1(dang13,dang)
        nfail1=0
        devctol=0.075
        if (loopmemat(i3) .gt. 0) devctol=0.10
        dtr=abs(bond13(i3)**2-bond2(i3)-bond12(i3)**2+
     -    2.0*bond(i3)*bond12(i3)*cangle(i3))/(2.0*bond13(i3)**2)
        if (dtr .gt. d13tol .or. dbond12 .gt. d12tol .or.
     -    dbond2 .gt. d12tol .or. dbond13 .gt. d13tol .or.
     -    deva .gt. tortol .or. devc .gt. devctol) nfail1=1
        nfail=nfail+nfail1
        if (iprint .gt. 0 .or. nfail1 .gt. 0) then
          i4=irotlist(irotlinc(it)+1)
          write (iout,1003) it,i1,i2,i3,i4,dbond,dbond2,d12tol,dbond12,
     -      d12tol,dbond13,d13tol,dtr,d13tol,dang,dcang,dang13,dcang13,
     -      lab(nfail1+1)
          if (iprint .gt. 1) then
            write (iout,1001)
     -        bond(i3),bond12(i3),bond13(i3),alpha,gamma,cangle13(i3)
          end if
          scp_1=sclprd(r12,r13)
          call arrdiff(r12,cslt(1,i1),cslt(1,i2),3)
          call arrdiff(r23,cslt(1,i3),cslt(1,i2),3)
          scp0=sclprd(r12,r13)
          bnd122=arrdist(cslt(1,i1),cslt(1,i2))
          bnd232=arrdist(cslt(1,i2),cslt(1,i3))
          bnd12_0=sqrt(bnd122)
          bnd23_0=sqrt(bnd232)
          cang_0=sclprd(r12,r23)/(bnd12_0*bnd23_0)
          ang_0=rdtodg*acoscheck(cang_0,iout,'TORCONTEST-ang_0')
          write (iout,8793) i3,cang,cang_0,ang*rdtodg,ang_0,
     -      bnd12,bnd12_0,bond(i2),bnd23,bnd23_0,bond(i3)
8793      format(' i3=',i4,' cang, cang_0=',2f8.4,' ang, ang_0=',2f9.3,
     -      /,' bnd12,bnd12_0,bond(i2)=',3f8.4,/,
     -      ' bnd23,bnd23_0,bond(i3)=',3f8.4)
        end if
        if (nfail1 .gt. 0)  write (iout,1010) dcang13,cangle13(i3),
     -    cang13,dcang,cangle(i3),cang,bond12(i3),bond13(i3)
        do i=1,nrot(it)
          i4=irotlist(irotlinc(it)+i)
          nfail1=0
          if (i3 .eq. iprecursor(1,i4)) then
            bond4=bond(i4)
            bond42=bond2(i4)
            cangle4=cangle(i4)
            bnd42=arrdist(c(1,i3),c(1,i4))
            bnd4=sqrt(bnd42)
            dev2=abs(bond42-bnd42)
            dev=abs(bond4-bnd4)
            if (dev .gt. d12tol .or. dev2/(2.0*bnd232) .gt. d12tol)
     -        nfail1=1
          else
            bond42=0.0
            cangle4=0.0
            do k=1,3
              dx=c(k,i4)-c(k,i3)
              bond42=bond42+dx*dx
              cangle4=cangle4-dx*r23(k)
            end do
            bond4=sqrt(bond42)
            cangle4=cangle4/(bond4*bond(i3))
          end if
          sangle4=sqrt(1.0-cangle4**2)
          if (bond(i2) .eq. 0.0) then
            b2=arrdist(c(1,i1),c(1,i2))
            dbond2=dsqrt(dble(b2))
          else
            dbond2=bond(i2)
          end if
          dc1pc2=(bond4*sangle4)/dcos(dble(angle(i3))-dpip2)
          dc1pc4=bond(i3)+dc1pc2*dsin(dble(angle(i3))-dpip2)-
     -      bond4*cangle4
          xfac12n=dc1pc2/dbond2
          xfac13n=dc1pc4/bond(i3)
          devx12=abs(xfac12n-xfac12(i4))
          devx13=abs(xfac13n-xfac13(i4))
          if (amax1(devx12,devx13) .gt. 2.0*d12tol) nfail1=1
          if (iprint .gt. 0 .or. nfail1 .gt. 0) then
            if (i3 .eq. iprecursor(1,i4)) then
              write (iout,1000) i3,i4,iprecursor(1,i4),devx12,devx13,
     -          2.0*d12tol
              write (iout,1009) dev,dev2,lab(nfail1+1)
            else
              write (iout,1000) i3,i4,iprecursor(1,i4),devx12,devx13,
     -          2.0*d12tol,lab(nfail1+1)
            end if
            if (iprint .gt. 1)
     -        write (iout,1002) bond42,xfac12n,xfac13n,beta,a,b
          end if
          nfail=nfail+nfail1
        end do
      end do
      do it=1,ntang
        if (looptyp(it) .gt. 0) then
          call getloopatoms(it,iquata,looplist,i0,i1,i2,i3,i4,i5,i6,
     -      ii0,ii1,ii2,ii3,ii4,ii5,ii6,ii7,ii8,ii9,looptyp(it),
     -      iprint,iout,'TORCONTEST',#TR,#LT)
          if (looptyp(it) .eq. 1) then
            ii1=i1
            ii2=i2
            ii3=i3
            ii4=i4
            ii5=i5
            ii6=i6
          end if
          nfail12=0
          nfail13=0
          nfail138=0
          nfail129=0
          nfail139=0
          d12it=d12(it)
          d23it=d23(it)
          d34it=d34(it)
          d45it=d45(it)
          d56it=d56(it)
          dd12=abs(d12it-bond2(ii2))/sqrt(d12(it))
          dd23=abs(d23it-bond2(ii3))/sqrt(d23(it))
          dd34=abs(d34it-bond2(ii4))/sqrt(d34(it))
          dd45=abs(d45it-bond2(ii5))/sqrt(d45(it))
          dd56=abs(d56it-bond2(ii6))/sqrt(d56(it))
          devmax12=amax1(dd12,dd23,dd34,dd45,dd56)/2.0
          d13it=d13(it)
          d24it=d24(it)
          d35it=d35(it)
          d46it=d46(it)
          dd13=abs(d13it-bond13(ii3)**2)/sqrt(d13(it))
          dd24=abs(d24it-bond13(ii4)**2)/sqrt(d24(it))
          dd35=abs(d35it-bond13(ii5)**2)/sqrt(d35(it))
          dd46=abs(d46it-bond13(ii6)**2)/sqrt(d46(it))
          if (loopmem(it) .gt. 0 .and. looptyp(looplist(1,it)) .eq. 0)
     -      dd46=0.0
          devmax13=amax1(dd13,dd24,dd35,dd46)/2.0
          if (devmax12 .gt. d12tol) nfail12=1
          if (devmax13 .gt. d13tol) nfail13=1
          if (looptyp(it) .eq. 2 .or. looptyp(it) .eq. 3) then
            d67it=d67(it)
            d78it=d78(it)
            dd67=abs(d67it-bond2(ii7))/sqrt(d67(it))
            dd78=abs(d78it-bond2(ii8))/sqrt(d78(it))
            devmax129=amax1(dd67,dd78)/2.0
            d57it=d57(it)
            d68it=d68(it)
            d79it=d79(it)
            dd57=abs(d57it-bond13(ii7)**2)/sqrt(d57(it))
            dd68=abs(d68it-bond13(ii8)**2)/sqrt(d68(it))
            dd79=abs(d79it-bond13(ii9)**2)/sqrt(d79(it))
            devmax139=amax1(dd57,dd68,dd79)/2.0
            if (devmax129 .gt. d12tol) nfail129=1
            if (devmax139 .gt. d13tol) nfail139=1
          else if (looptyp(it) .gt. 3) then
            d57it=d57(it)
            dd57=abs(d57it-bond13(ii7)**2)/(2.0*sqrt(d57(it)))
            if (dd57 .gt. d12tol) nfail138=1
          end if
          nfaill=nfail12+nfail13+nfail138+nfail129+nfail139
          if (iprint .gt. 0 .or. nfaill .gt. 0) then
            write (iout,1005) it,dd12,dd23,dd34,dd45,dd56,
     -        lab(nfail12+1)
            write (iout,1006) it,dd13,dd24,dd35,dd46,lab(nfail13+1)
            if (looptyp(it) .gt. 3) then
              write (iout,1011) it,dd57,lab(nfail138+1)
            else if (looptyp(it) .gt. 1) then
              write (iout,1007) it,dd67,dd78,lab(nfail129+1)
              write (iout,1008) it,dd57,dd68,dd79,lab(nfail139+1)
            end if
          end if
          nfail=nfail+nfaill
        end if
      end do
      if (nfail .gt. 0) write (iout,1004)
      return
1000  format(10x,' i3,i4,iprec=',3i6,
     -  ' devxfac12=',e10.3,' devxfac13=',e10.3,' tol=',e10.3,1x,a)
1001  format(' b3=',f6.4,' b12=',f6.4,' b13=',f6.4,' al=',f6.4,
     -  ' ga=',f6.4,' ca13=',f6.4)
1002  format(' b42=',f10.5,' xfac12,13n=',2e15.5,
     -  ' be=',f6.4,' a=',f9.4,' b=',f9.4)
1003  format(' Torsion',i6,' ia1,ia2,ia3,ia4=',4i6,' db=',e10.3,
     -  ' db2,tol=',2e10.3,' db12,tol=',2e10.3,/,10x,
     -  ' db13,tol=',2e10.3,' dtr,tol=',2e10.3,' dang=',f10.5,
     -  ' dcang=',f9.5,' dang13=',f10.5,/,10x,' dcang13=',e10.3,1x,a)
1004  format(' ***** Discrepancy found in torsion data')
1005  format(' TORCONTEST it=',i5,' d12-bond: dd12,dd23,dd34,dd45,',
     -  'dd56=',5e10.3,1x,a)
1006  format(' TORCONTEST it=',i5,' d13-bond: dd13,dd24,dd35,dd46=',
     -  4e10.3,1x,a)
1007  format(' TORCONTEST it=',i5,' d12-bond: dd67,dd78=',2e10.3,1x,a)
1008  format(' TORCONTEST it=',i5,' d13-bond: dd57,dd68,dd79=',3e10.3,
     -  1x,a)
1009  format(56x,'dbnd,2(i4)=',2e10.3,1x,a)
1010  format(' dcang13=',f10.5,' cangle3(i3),cang13=',2f10.5,
     -  '    dcang=',f10.5,' cangle(i3),cang=',2f10.5,/,' bond12(i3)=',
     -  f9.5,' bond13(i3)=',f9.5)
1011  format(' TORCONTEST it=',i5,' d13-bond: dd57=',e10.3,1x,a)
1012  format(' Torsion',i6,' temporary increment (iri) > 1:',i3)
      end
      subroutine gentor(ntang0,ntang,dihang,c,itangindx,iprecursor,nrot,
     -  incrot,irotlist,irotlinc,sindela,cosdela,bondf,bondproj,
     -  xfac13,xfac12,bond,LEVTESTin,iout,maxtor,maxat)
c#    MMC routine 343 lstmod: 08/02/17
c*****Generate the coordinates of atoms affected by torsions
      dimension dihang(maxtor),c(3,maxat),itangindx(maxtor),
     -  iprecursor(2,maxat),nrot(maxat),incrot(maxat),irotlist(maxat),
     -  irotlinc(maxat),sindela(maxat),cosdela(maxat),bondf(maxat),
     -  bondproj(maxat),xfac13(maxat),xfac12(maxat),bond(maxat)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension c00(3),rba(3),r1(3),ex(3),ey(3),ax3(3),ax2(3)
      data cosa0 /0.0/,sina0 /0.0/
      LEVTEST=LEVTESTin
      if (MYRANK .gt. 0) LEVTEST=0
      if (LEVTEST .gt. 1) write (iout,*) 'ntang0,ntang=',ntang0,ntang
      do it=ntang0,ntang
        i3=itangindx(it)
        i2=iprecursor(1,i3)
        i1=iprecursor(2,i3)
        do k=1,3
          rba(k)=c(k,i3)-c(k,i2)
          ax3(k)=c(k,i3)-c(k,i2)
          ax2(k)=c(k,i1)-c(k,i2)
        end do
        if (LEVTEST .gt. 1) then
          write (iout,7712) rba,ax2,ax3
          rbas=0.0
          ax2s=0.0
          do k=1,3
            rbas=rbas+rba(k)**2
            ax2s=ax2s+ax2(k)**2
          end do
          write (iout,7714) abs(sqrt(rbas)-bond(i3)),
     -      abs(sqrt(ax2s)-bond(i2))
        end if
        if (LEVTEST .gt. 0) write (iout,7715) it,i1,i2,i3,
     -    i1,(c(k,i1),k=1,3),i2,(c(k,i2),k=1,3),i3,(c(k,i3),k=1,3),
     -    incrot(it),(irotlist(irotlinc(it)+i),i=1,nrot(it))
        if (incrot(it) .gt. 1) then
          cosa0=cos(dihang(it))
          sina0=sin(dihang(it))
        end if
      if (LEVTEST .gt. 1) write (iout,*) 'GENT it,incrot(it),nrot(it)=',
     -  it,incrot(it),nrot(it)
        do ir=incrot(it),nrot(it)
          i4=irotlist(irotlinc(it)+ir)
          do k=1,3
            c00(k)=c(k,i2)+(xfac13(i4)*ax3(k)+xfac12(i4)*ax2(k))
c           c00 is the tang=0 position of atom i4
          end do
c         Generate next atom, rotated by dihang(it)+tangd(i4)
          delfac=bondf(i4)
          do k=1,3
            r1(k)=c(k,i2)+rba(k)*delfac
            ex(k)=c00(k)-r1(k)
          end do
          call vprd(ex,rba,ey)
c         Product's norm should be the same as the norm of a
          enorm2=ey(1)*ey(1)+ey(2)*ey(2)+ey(3)*ey(3)
          if (enorm2 .gt. 1.e-8) then
            facc=bondproj(i4)/sqrt(enorm2)
            ey(1)=ey(1)*facc
            ey(2)=ey(2)*facc
            ey(3)=ey(3)*facc
          end if
          if (ir .eq. 1) then
            cosa0=cos(dihang(it))
            sina0=sin(dihang(it))
            cosa=cosa0
            sina=sina0
          else
c           Generate new sin and cos from addition formulae
            sina=sina0*cosdela(i4)+cosa0*sindela(i4)
            cosa=cosa0*cosdela(i4)-sina0*sindela(i4)
          end if
          do k=1,3
            c(k,i4)=r1(k)+cosa*ex(k)-sina*ey(k)
          end do
          if (LEVTEST .gt. 0) write (iout,7711) it,ir,i4,
     -      dihang(it)*rdtodg,xfac12(i4),xfac13(i4),i4,(c(k,i4),k=1,3)
          if (LEVTEST .gt. 1)  then
            write (iout,7713) delfac,bondproj(i4),
     -        r1,c00,sindela(i4),cosdela(i4),ex,ey,facc,sina,cosa
             write (iout,7718) i2,i4,ax2,ax3,(c(k,i2),k=1,3)
            if (i3 .eq. iprecursor(1,i4)) then
              bnd13=sqrt(arrdist(c(1,i2),c(1,i4)))
              bnd=sqrt(arrdist(c(1,i3),c(1,i4)))
              sc0=sclprd(ex,rba)
              write (iout,7716) bond(i4),abs(bnd-bond(i4)),sc0
            end if
          end if
        end do
      end do
      return
7711  format(9x,'it,ir=',2i4,' i4=',i4,' ta=',f10.5,
     -  ' xfac12,13=',2f10.6,' c(',i4,')=',3f9.5)
7712  format(' GENTOR: rba=',3f7.3,' ax2=',3f7.3,' ax3=',3f7.3)
7713  format(9x,'delfac=',f10.5,' bp4=',f10.5,' r1=',3f10.5,
     -  ' c00:',3f10.5,' sindela,cosdela=',2f9.6,/,9x,'ex=',3f7.3,
     -  ' ey=',3f7.3,' facc=',f7.4,' sina,cosa=',2f9.6)
7714  format(' GENTOR distance check rba:',e9.2,' ax2:',e9.2)
7715  format(' GENTOR: it=',i4,' i1-3=',3i5,' c',i4,'=',3f9.5,
     -  ' c',i4,'=',3f9.5,' c',i4,'=',3f9.5,/,
     -  (9x,'inc=',i5,' irotlist=',20i5))
7716  format(9x,'b24=',f10.5,' db24=',e10.3,' sc0=',e10.3)
7718  format(' i2=',i5,' i4=',i4,' ax2=',3f7.3,' ax3=',3f7.3,' c(i4)=',
     -  3f9.3)
      end
      subroutine findtangles(ntang0,ntang,itangindx,iprecursor,nrot,
     -  irotlist,irotlinc,iquata,c,dihang,tangd,sindela,cosdela,iscdel,
     -  icheck,LEVTEST,iout,nwarn,inperr,maxtor,maxat)
c#    MMC routine 344 lstmod: 12/26/21
c*****Find the torsion angle values in the molecule c
c     iscdel=0: just set the backbone torsions (simulation varaibles)
c     iscdel=>: set all torsion values and increments to be used in gentor
      dimension itangindx(maxtor),iprecursor(2,maxat),nrot(maxat),
     -  irotlist(maxat),irotlinc(maxat),iquata(maxtor,4),c(3,maxat),
     -  dihang(maxtor),tangd(maxat),sindela(maxat),cosdela(maxat)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*22 msg(4)
      data msg /'read with the SLTA key','read with the CNFG key',
     -          'translated to COM     ','used to regenerate    '/
      do it=ntang0+1,ntang
        i3=itangindx(it)
        i2=iprecursor(1,i3)
        i1=iprecursor(2,i3)
        if (i2 .ne. iquata(it,2) .or. i3 .ne. iquata(it,3)) then
          write (iout,1001) it,i1,i2,i3,(iquata(it,k),k=1,3)
          inperr=inperr+1
        else if (i1 .ne. iquata(it,1)) then
          write (iout,1002) it,iquata(it,1),i1
          nwarn=nwarn+1
          i1=iquata(it,1)
        end if
        nrotcalc=max0(1,nrot(it))
        if (icheck .gt. 0) then
          if (arrdist(c(1,i1),c(1,i2)) .lt. 1.e-4) then
             write (iout,1000) msg(icheck),i1,i2
             inperr=inperr+1
          end if
          if (arrdist(c(1,i2),c(1,i3)) .lt. 1.e-4) then
             write (iout,1000) msg(icheck),i1,i2
             inperr=inperr+1
          end if
          do i=1,nrotcalc
            i4=irotlist(irotlinc(it)+i)
            if (arrdist(c(1,i3),c(1,i4)) .lt. 1.e-4) then
              write (iout,1000) msg(icheck),i1,i2
              inperr=inperr+1
            end if
          end do
        end if
        i40=iquata(it,4)
        dihang(it)=dihangl(c(1,i1),c(1,i2),c(1,i3),c(1,i40),LEVTEST,
     -    iout)
        do i=1,nrotcalc
          i4=irotlist(irotlinc(it)+i)
          if (i4 .ne. i40) then
            tangi4=dihangl(c(1,i1),c(1,i2),c(1,i3),c(1,i4),LEVTEST,iout)
            if (iscdel .gt. 0) then
              tangd(i4)=tangi4-dihang(it)
             sindela(i4)=sin(tangd(i4))
             cosdela(i4)=cos(tangd(i4))
             if (LEVTEST .gt. 1)
     -         write (iout,7712) i1,i2,i3,i4,sindela(i4),cosdela(i4)
            end if
            if (LEVTEST .gt. 0) then
              t1=tangi4*rdtodg
              t2=tangd(i4)*rdtodg
              write (iout,7711) i1,i2,i3,i4,t1,t2
            end if
          end if
        end do
      end do
      return
1000  format(' ***** ERROR: in configuration ',a,' atoms ',i5,' and ',
     -  i5,' have the samme coordinates')
1001  format(' ***** PROGRAM ERROR: torsion',i6,' i1,i2,i3=',3i8,
     -  ' iquata1-3)=',3i8)
1002  format(' ----- WARNING: Leading atom of torsion ',i6,' (',i8,')',
     - ' is not the preursor (',i8,')')
7711  format(' FINDTANGLES: T(',4i5,')=',f8.2,' d=',f8.2)
7712  format(' FINDTANGLES: T(',4i5,') sindela(i4),cosdela(i4)=',2f10.6)
      end
      function dihangl(ai,aj,ak,al,LEVTEST,iout)
c#    MMC routine 345 lstmod: 08/20/02
c*****Returns the dihedral angle of atoms ai,aj,ak,al
      dimension ai(3),aj(3),ak(3),al(3)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension dij(3),dkj(3),dlk(3),dii(3),djj(3),cp(3)
      real*8 cosijk,cosjkl,cosijk1,cosjkl1,costa,rjk,rjk2,rij,rij2,
     -  rkl,rkl2,rik,rik2,rjl,rjl2,dcoszero
      data dcoszero/0.99999d0/
      call arrdistsd(ak,aj,rjk,rjk2)
      call arrdistsd(ai,aj,rij,rij2)
      call arrdistsd(ak,al,rkl,rkl2)
      if (LEVTEST .gt. 1) write (iout,7710) 1,ai,2,aj,3,ak,4,al
      if (LEVTEST .gt. 2) then
        write (iout,7711) rjk,rij,rkl
        call arrdistsd(ai,ak,rik,rik2)
        call arrdistsd(aj,al,rjl,rjl2)
        write (iout,7717) rik,rjl
      end if
      call arrdiff(dij,ai,aj,3)
      call arrdiff(dkj,ak,aj,3)
      call arrdiff(dlk,al,ak,3)
      cosijk1=sclprd(dij,dkj)
      cosjkl1=-sclprd(dlk,dkj)
      if (LEVTEST .gt. 3) write (iout,7712) cosijk1,cosjkl1
      cosijk=cosijk1/(rij*rjk)
      cosjkl=cosjkl1/(rkl*rjk)
      if (cosijk .lt. -dcoszero .or. cosijk .gt. dcoszero .or.
     -  cosjkl .lt. -dcoszero .or. cosjkl .gt. dcoszero) then
        if (LEVTEST .gt. 1) write (iout,7716) cosijk,cosjkl
        dihangl=0.d0
        return
      end if
      if (LEVTEST .gt. 3) write (iout,7713) cosijk,cosjkl
      costa=0.d0
      do k=1,3
        dii(k)=dij(k)-dkj(k)*cosijk1/rjk2
        djj(k)=dlk(k)+dkj(k)*cosjkl1/rjk2
        costa=costa+dii(k)*djj(k)
      end do
      costa=costa/(rij*rkl*sqrt((1.0-cosijk*cosijk)*
     -  (1.0-cosjkl*cosjkl)))
      if (LEVTEST .gt. 3) write (iout,7714) costa
      angle=dacoscheck(costa,iout,'DIHANGL')
c     Decide sign of the angle
      call vprd(dii,dkj,cp)
      if (cp(1)*djj(1)+cp(2)*djj(2)+cp(3)*djj(3) .gt. 0.0) angle= -angle
      if (LEVTEST .gt. 1) write (iout,7715) angle*rdtodg,costa
      dihangl=angle
      return
7710  format(' DIHANGL:',4(' c',i1,'=',f8.4,2f9.4))
7711  format(' DIHANGL: rjk=',f12.6,' rij=',f12.6,' rkl=',f12.6)
7712  format(' DIHANGL: cosijk1=',f9.5,' cosjkl1=',f9.5)
7713  format(' DIHANGL: cosijk=',f9.5,' cosjkl=',f9.5)
7714  format(' DIHANGL: costa=',f9.5)
7715  format(' DIHANGL: torsion=',f10.5,' cos(tors)=',f8.5)
7716  format(' DIHANGL: colinear atoms, torsion set to 0',
     -  ' cosijk,jkl=',2f10.5)
7717  format(' DIHANGL: rik=',f12.6,' rjl=',f12.6)
      end
      function dihangld(ai,aj,ak,al,LEVTEST,iout)
c#    MMC routine 346 lstmod: 07/31/07
c*****Returns the dihedral angle of atoms ai,aj,ak,al
      real*8 ai,aj,ak,al
      dimension ai(3),aj(3),ak(3),al(3)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension dij(3),dkj(3),dlk(3),dii(3),djj(3),cp(3)
      real*8 cosijk,cosjkl,cosijk1,cosjkl1,costa,rjk,rjk2,rij,rij2,cp,
     -  rkl,rkl2,dcoszero,dsclprd,darrdist,dij,dkj,dlk,dii,djj
      data dcoszero/0.99999d0/
      rjk2=darrdist(ak,aj)
      rij2=darrdist(ai,aj)
      rkl2=darrdist(ak,al)
      rjk=dsqrt(rjk2)
      rij=dsqrt(rij2)
      rkl=dsqrt(rkl2)
      if (LEVTEST .gt. 1) write (iout,7710) 1,ai,2,aj,3,ak,4,al
      call darrdiff(dij,ai,aj,3)
      call darrdiff(dkj,ak,aj,3)
      call darrdiff(dlk,al,ak,3)
      cosijk1=dsclprd(dij,dkj)
      cosjkl1=-dsclprd(dlk,dkj)
      if (LEVTEST .gt. 3) write (iout,7712) cosijk1,cosjkl1
      cosijk=cosijk1/(rij*rjk)
      cosjkl=cosjkl1/(rkl*rjk)
      if (cosijk .lt. -dcoszero .or. cosijk .gt. dcoszero .or.
     -  cosjkl .lt. -dcoszero .or. cosjkl .gt. dcoszero) then
        if (LEVTEST .gt. 1) write (iout,7716) cosijk,cosjkl
        dihangld=0.d0
        return
      end if
      if (LEVTEST .gt. 3) write (iout,7713) cosijk,cosjkl
      costa=0.d0
      do k=1,3
        dii(k)=dij(k)-dkj(k)*cosijk1/rjk2
        djj(k)=dlk(k)+dkj(k)*cosjkl1/rjk2
        costa=costa+dii(k)*djj(k)
      end do
      costa=costa/(rij*rkl*dsqrt((1.d0-cosijk*cosijk)*
     -  (1.d0-cosjkl*cosjkl)))
      if (LEVTEST .gt. 3) write (iout,7714) costa
      angle=dacoscheck(costa,iout,'DIHANGL')
c     Decide sign of the angle
      call dvprd(dii,dkj,cp)
      if (cp(1)*djj(1)+cp(2)*djj(2)+cp(3)*djj(3) .gt. 0.d0) angle=-angle
      if (LEVTEST .gt. 1) write (iout,7715) angle*rdtodg,costa
      dihangld=angle
      return
7710  format(' DIHANGL:',4(' c',i1,'=',f8.4,2f9.4))
7712  format(' DIHANGL: cosijk1=',f9.5,' cosjkl1=',f9.5)
7713  format(' DIHANGL: cosijk=',f9.5,' cosjkl=',f9.5)
7714  format(' DIHANGL: costa=',f9.5)
7715  format(' DIHANGL: torsion=',f10.5,' cos(tors)=',f8.5)
7716  format(' DIHANGL: colinear atoms, torsion set to 0',
     -  ' cosijk,jkl=',2f10.5)
      end
      function itranscis(c1,c2,c3,c4)
c#    MMC routine 346/a lstmod: 02/07/07
c*****Returns +1 or -1 for trans or cis  for the dihedral angle c1-c2-c3-c4
      real*8 c1,c2,c3,c4,dsclprd
      dimension c1(3),c2(3),c3(3),c4(3)
      real*8 d12,d32,d42,rnorm
      dimension d12(3),d32(3),d42(3),rnorm(3)
      do k=1,3
        d12(k)=c1(k)-c2(k)
        d32(k)=c3(k)-c2(k)
        d42(k)=c4(k)-c2(k)
      end do
      call dvprd(d12,d32,rnorm)
      itranscis=-1
      if (dsclprd(d42,rnorm) .gt. 0.d0) itranscis=+1
      return
      end
      function angleijk(c,n,i1,i2,i3,iout)
c#    MMC routine 347 lstmod: 05/03/05
c*****Calculates the c1-c2-c3 angle
      dimension c(3,n)
      d12=arrdist(c(1,i1),c(1,i2))
      d23=arrdist(c(1,i2),c(1,i3))
      d13=arrdist(c(1,i1),c(1,i3))
      if (d12*d23 .gt. 0.0) then
        cosangle=(d12+d23-d13)/(2.0*sqrt(d12*d23))
        angleijk=acoscheck(cosangle,iout,' ')
      else
        angleijk=0.0
      end if
      end
      function circadd(a0,a1,sign)
c#    MMC routine 348 lstmod: 11/03/99
c*****Returns the  a1+sign*a0 in the (-pi,+pi] range
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      circadd =a1+sign*a0
      if (circadd .gt. pi) circadd=circadd-pi2
      if (circadd .le. -pi) circadd=circadd+pi2
      return
      end
      subroutine regenerate(c,imol,itest,iout,nerr,devmax)
c#    MMC routine 349 lstmod: 15/08/08
c*****Regenerate a molecule from the torsion angle list
      dimension c(3,#NA)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /fixdeverr/ nfixtry,ndiffign,numdiscr,ngcortry,ngcorfail,
     -  igcorfail,nacortry,ntopwwarn
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /slfttolerance/ engtol,virtol,tortol,comtol,zmattol,
     -  cslttol,d12tol,d13tol,wsumtol,costol,tolr(10),told(10)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension ort(3,3),center(3),rcenter(3),ixrep3slt(3)
      real*8 d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,r234,deldij
      dimension r2(3),r3(3),r4(3),r5(3),r6(3),r7(3),r234(3,4,32)
      dimension d0(3),d1(3),d2(3),d3(3),d4(3),d5(3),d6(3),d7(3),d8(3),
     -  d9(3)
      nerr=0
      nrep3slt=0
      igcorfail=0
      if (itest .gt. 0 .or. iop(91) .gt. 0) then
        call trnsfr(cgs,c,nstta3)
        call trnsfr(texng,dihang,ntang)
        call trnsfr(cv1,tang,nstta)
       end if
      if (imol .eq. 0) then
        imf=1
        iml=nsttm
      else
        imf=imol
        iml=imol
      end if
      call findtangles(0,ntang,itangindx,iprecursor,nrot,irotlist,
     -  irotlinc,iquata,c,dihang,tangd,sindela,cosdela,0,4,idebug(21),
     -  iout,nwarn,inperr,#TR,#ST)
      im0=1
      do im=imf,iml
        if (ilastt(im)-ifirstt(im) .ge. 0) then
          if (im .gt. 1) im0=natfix(im-1)+1
c         Don't use solute center of mass, use molecule center instead
          call trnsfr(center,c(1,molcnt(im)),3)
          ifloop=0
          do it=ifirstt(im),ilastt(im)
            if (loopmem(it) .gt. 0) ifloop=1
            if (iri(it) .gt. 1) then
              iri(it)=1
              write (iout,1008) im,it,iri(it)
              nerr=nerr+1
            end if
          end do
          if (ifloop .eq. 0 .and.
     -        maxbrlen(im) .le. max0(100,idebug(116))) then
c           No flexible loop - regenerated from root
c           Shift rlcslt to be centered on the atom chosen as cneter
            call trnsfr(rcenter,rlcslt(1,molcnt(im)),3)
            do ia=ifirstm(im),ilastm(im)
              do k=1,3
                crmgs(k,ia)=rlcslt(k,ia)-rcenter(k)
              end do
            end do
            call getort(c(1,ifirstm(im)),center,
     -        iclslt(ifirstm(im)),rlcslt(1,ifirstm(im)),
     -        natfix(im)-im0+1,ort,0,iroots(im0),ifirstm(im)-1,linear,1,
     -        0,ixrep3slt,nrep3slt,ifail,idebug(29),iout,#NA)
            call rot_trans_list(crmgs,c,im0,natfix(im),iroots,ort,
     -        center,#ST,idebug(52),iout)
            call gentor(ifirstt(im),ilastt(im),dihang,c,itangindx,
     -        iprecursor,nrot,iri,irotlist,irotlinc,sindela,cosdela,
     -        bondf,bondproj,xfac13,xfac12,bond,idebug(25),
     -        iout,#TR,#ST)
          else if (ifloop .gt. 0) then
            call checkgeom(ifirstm(im),ilastm(im),c,rlcslt,nneig,ineig,
     -        iout,idebug(101)-1,d12tol,d13tol,nerr12,nerr13,devmax12,
     -        devmax13,devav12,devav13,#NL,imx12,jmx12,'in REGENE 1',
     -        11,#ST)
c           First fix flexible loop backbone
            iop91=iop(91)
            iop(91)=1
            do it=ifirstt(im),ilastt(im)
              if (loopmem(it)*looptyp(it) .gt. 0) then
                call gentor(it,it,dihang,c,itangindx,
     -            iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -            cosdela,bondf,bondproj,xfac13,xfac12,bond,
     -            idebug(25),iout,#TR,#ST)
                ibf=0
                call closeloop(r234,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,0.d0,
     -            0.d0,0.d0,0.d0,deldij,it,c,cslto,cslt,r2,r3,
     -            r4,r5,r6,r7,i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,
     -            ii5,ii6,ii7,ii8,ii9,'REGENERATE',1,1,ibf,nsol,isol,
     -            nosoltyp,neval,inperr,iout)
                if (nsol .gt. 0) then
                  if (looptyp(it) .eq. 1) then
                    do k=1,3
                      d2(k)=r234(k,2,1)
                      d3(k)=r234(k,3,1)
                      d4(k)=r234(k,4,1)
                    end do
                  end if
                  call saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -              it,looplist,iquata,c,looptyp,dihang,r2,r3,r4,r5,r6,
     -              r7,i0,i1,i2,i3,i4,i5,i6,ii2,ii3,ii4,ii5,ii6,
     -              ii7,idebug(63),iout)
c                 If torsions changed too much, restore original coordinates
                  dtmax=0.0
                  do itl=1,6
                    itt=looplist(itl,it)
                    d=amin1(abs(dihang(itt)-texng(itt)),
     -                      abs(dihang(itt)+pi2-texng(itt)),
     -                      abs(dihang(itt)-pi2-texng(itt)))*rdtodg
                    if (d .gt. dtmax) dtmax=d
                  end do
                  if (dtmax .gt. tortol) then
                    do k=1,3
                      d2(k)=cgs(k,ii2)
                      d3(k)=cgs(k,ii3)
                      d4(k)=cgs(k,ii4)
                      d5(k)=cgs(k,ii5)
                      d6(k)=cgs(k,ii6)
                      d7(k)=cgs(k,ii7)
                    end do
                    call saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -                it,looplist,iquata,c,looptyp,dihang,cgs(1,ii2),
     -                cgs(1,ii3),cgs(1,ii4),cgs(1,ii5),cgs(1,ii6),
     -                cgs(1,ii7),i0,i1,i2,i3,i4,i5,i6,ii2,ii3,
     -                ii4,ii5,ii6,ii7,idebug(63),iout)
                    if (iop(24) .gt. 1) write (iout,1004) it
                  else
                    if (looptyp(looplist(1,it)) .eq. 0) then
c                     Last loop found: regenerate the whole loop backbone and
                      do itl=1,6
                        itt=looplist(itl,it)
                        call gentor(itt,itt,dihang,c,itangindx,
     -                    iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -                    cosdela,bondf,bondproj,xfac13,xfac12,bond,
     -                    idebug(25),iout,#TR,#ST)
                      end do
c                     Restore the root of the last torsion
                      ik6=iquata(looplist(6,it),3)
                      call trnsfr(c(1,ik6),cgs(1,ik6),3)
                    end if
                  end if
                else
                  if (iop(24) .gt. 1) write (iout,1002) it,rdtodg*
     -              dihang(it),(rdtodg*dihang(looplist(k,it)),k=1,6)
                end if
              end if
            end do
            call checkgeom(ifirstm(im),ilastm(im),c,rlcslt,nneig,ineig,
     -        iout,idebug(101)-3,d12tol,d13tol,nerr12,nerr13,devmx12x,
     -        devmx13x,devav12,devav13,#NL,imx12x,jmx12x,'in REGENE 2',
     -        11,#ST)
c           Restore geometry if error accumulation worsened
            if (devmx12x .gt. devmax12 .or. devmx13x .gt. devmax13) then
              call trnsfr(c(1,ifirstm(im)),cgs(1,ifirstm(im)),
     -          3*(ilastm(im)-ifirstm(im)+1))
              call trnsfr(dihang(ifirstt(im)),texng(ifirstt(im)),
     -          (ilastt(im)-ifirstt(im)+1))
              call trnsfr(tang,cv1,nstta)
              if (iop(24) .gt. 0)
     -          write (iout,1003) im,devmx12x,devmx13x,devmax12,devmax13
              igcorfail=1
c             Restore loop member constants
              do it=ifirstt(im),ilastt(im)
                if (loopmem(it)*looptyp(it) .gt. 0) then
                  call updateloop(it,iquata,looplist,c,iprecursor,nrot,
     -              irotlist,irotlinc,bond,bond2,angle,cangle,bond13,
     -              bond12,angle13,cangle13,bondf,bondproj,xfac13,
     -              xfac12,cangle40,bond420,idebug(67),iout,#ST,#TR)
                end if
              end do
            end if
c           First, fix the sidechains
            do it=ifirstt(im),ilastt(im)
              if (loopmem(it) .eq. 0)
     -          call gentor(it,it,dihang,c,itangindx,
     -            iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -            cosdela,bondf,bondproj,xfac13,xfac12,bond,
     -            idebug(25),iout,#TR,#ST)
            end do
c           Now see the worst offense
            call checkgeom(ifirstm(im),ilastm(im),c,rlcslt,nneig,ineig,
     -        iout,idebug(101)-3,d12tol,d13tol,nerr12,nerr13,devmx12x,
     -        devmx13x,devav12,devav13,#NL,imx12x,jmx12x,'in REGENE 3',
     -        11,#ST)
            nfixt=0
            call zeroiti(l1,0,ilastt(im))
            do while (nfixt .le. ilastt(im)-ifirstt(im) .and.
     -                (devmx12x .gt. d12tol .or. devmx13x .gt. d13tol))
c             Try to reclose just the offending part
              it=0
              itx=itangon(itorsionroot(imx12x))
              jtx=itangon(itorsionroot(jmx12x))
              if (loopmem(itx) .gt. 0) then
                it=itx
              else if (loopmem(jtx) .gt. 0) then
                it=jtx
              else
                ia=imx12x
                call findlooptor(itx,it,ia,loopmem,iprecursor,itangon,
     -            itorsionroot,molcnt(im),#ST)
              end if
              itxx=it
c             itxx is the torsion moving the violating atom
c             Now find the nearest driver torsion moving this torsion
              ia=iquata(it,3)
              call findlooptor(it,itx,ia,loopmem,iprecursor,itangon,
     -          itorsionroot,molcnt(im),#ST)
              nlftry=0
              nf=6
              do k=1,6
                if (looplist(k,itx) .eq. itxx) nf=1
              end do
              nlftry=nlftry+nf
              if (l1(it) .eq. 1) then
                write (iout,1006) it
                it=0
              end if
              nsol=0
              do while (it .ne. 0 .and. nlftry .lt. 5 .and. nsol .eq. 0)
                call gentor(it,it,dihang,c,itangindx,
     -            iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -            cosdela,bondf,bondproj,xfac13,xfac12,bond,
     -            idebug(25),iout,#TR,#ST)
                ibf=0
                call closeloop(r234,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,0.d0,
     -            0.d0,0.d0,0.d0,deldij,it,c,cslto,cslt,r2,r3,
     -            r4,r5,r6,r7,i0,i1,i2,i3,i4,i5,i6,ii0,ii1,ii2,ii3,ii4,
     -            ii5,ii6,ii7,ii8,ii9,'REGENERATE',1,1,ibf,nsol,isol,
     -            nosoltyp,neval,inperr,iout)
                if (nsol .gt. 0) then
                  if (iop(24) .gt. 1) write (iout,1007) it
                  l1(it)=1
                  call saveloopsol(d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,
     -              it,looplist,iquata,c,looptyp,dihang,r2,r3,r4,r5,r6,
     -              r7,i0,i1,i2,i3,i4,i5,i6,ii2,ii3,ii4,ii5,ii6,
     -              ii7,idebug(63),iout)
                  call updateloop(it,iquata,looplist,c,iprecursor,nrot,
     -              irotlist,irotlinc,bond,bond2,angle,cangle,bond13,
     -              bond12,angle13,cangle13,bondf,bondproj,xfac13,
     -              xfac12,cangle40,bond420,idebug(67),iout,#ST,#TR)
c                 Regenerate the full backbone/side chains moved by this loop
                  call modloopinc(it,looptyp(it),iri,looplist,
     -              #ST,#LT,+1)
                  do itt=1,5
                    itfx=looplist(itt,it)
                    call gentor(itfx,itfx,dihang,c,itangindx,iprecursor,
     -                nrot,iri,irotlist,irotlinc,sindela,cosdela,bondf,
     -                bondproj,xfac13,xfac12,bond,idebug(25),iout,
     -                #TR,#ST)
                  end do
c                 Generate side chains too
                  do ii=ifsctlist(it),ilsctlist(it)
                    iit=isctlist(ii)
                    call updatesc(iit,iltmovtg(itorgrp(iit)),
     -                loopmem(it),loopmem,itorsionroot,itangon,iquata,
     -                c,iprecursor,nrot,irotlist,irotlinc,
     -                bond,bond2,angle,cangle,bond13,bond12,angle13,
     -                cangle13,bondf,bondproj,xfac13,xfac12,cangle40,
     -                bond420,idebug(108),iout,#ST,#TR)
                    call gentor(iit,iltmovtg(itorgrp(iit)),dihang,c,
     -                itangindx,iprecursor,nrot,iri,irotlist,irotlinc,
     -                sindela,cosdela,bondf,bondproj,xfac13,xfac12,
     -                bond,idebug(25),iout,#TR,#ST)
                  end do
c                 Restore nrot list increments
                  call modloopinc(it,looptyp(it),iri,looplist,
     -              #ST,#LT,-1)
                  call checkgeom(ifirstm(im),ilastm(im),c,rlcslt,nneig,
     -              ineig,iout,idebug(101)-3,d12tol,d13tol,nerr12,
     -              nerr13,devmx12x,devmx13x,devav12,devav13,#NL,imx12x,
     -              jmx12x,'in REGENE 4',11,#ST)
                else
                  if (iop(24) .gt. 0) write (iout,1002) it,rdtodg*
     -              dihang(it),(rdtodg*dihang(looplist(k,it)),k=1,6)
c                 Find precursor loop member
                  ia=iquata(it,3)
                  call findlooptor(it,itx,ia,loopmem,iprecursor,itangon,
     -              itorsionroot,molcnt(im),#ST)
c                 Check if itxx is a member of this loop
                  nf=6
                  if (loopmem(itx) .gt. 0) then
                    do k=1,6
                      if (looplist(k,itx) .eq. itxx) nf=1
                    end do
                  end if
                  nlftry=nlftry+nf
                  it=itx
                end if
              end do
              if (it .eq. 0) then
                if (nlftry .gt. 0) write (iout,1005)
                nfixt=#ST
              else
                nfixt=nfixt+1
c               Fix sidechains
                do it=ifirstt(im),ilastt(im)
                  if (loopmem(it) .eq. 0)
     -              call gentor(it,it,dihang,c,itangindx,
     -                iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -                cosdela,bondf,bondproj,xfac13,xfac12,bond,
     -                idebug(25),iout,#TR,#ST)
                end do
              end if
            end do
c           Now, fix sidechains
            do it=ifirstt(im),ilastt(im)
              if (loopmem(it) .eq. 0)
     -          call gentor(it,it,dihang,c,itangindx,
     -            iprecursor,nrot,iri,irotlist,irotlinc,sindela,
     -            cosdela,bondf,bondproj,xfac13,xfac12,bond,
     -            idebug(25),iout,#TR,#ST)
            end do
            iop(91)=iop91
          end if
        end if
      end do
      if (itest .gt. 0) then
        iaf=max0(nsltu,ifirstm(imf))
        ial=min0(nstta,ilastm(iml))
        if (iop(91) .gt. 0) then
c         Test coordinates
          devmax=0.0
          do ia=iaf,ial
            rr2=arrdist(c(1,ia),cgs(1,ia))
            if (rr2. gt. devmax) devmax=rr2
            if (rr2 .gt. cslttol) then
              rr2=sqrt(rr2)
              nerr=nerr+1
              write (iout,1000) ia,(cgs(k,ia),k=1,3),(c(k,ia),k=1,3),rr2
            end if
          end do
          devmax=sqrt(devmax)
          if (nerr. gt. 0) write (iout,1001) nerr,cslttol,devmax
        else
c         Check geometry
          call checkgeom(iaf,ial,c,rlcslt,nneig,ineig,iout,
     -      idebug(16)-1,d12tol,d13tol,nerr12,nerr13,devmax12,devmax13,
     -      devav12,devav13,#NL,imx12,jmx12,'in REGENERATE',13,#ST)
          nerr=nerr+nerr12+nerr13
          devmax=devmax12
        end if
        if (itest .gt. 1) call trnsfr(c,cgs,nstta3)
      end if
      return
1000  format(' Deviation in regenerating solute atom',i6,':',' org=',
     -  3f10.5,' new=',3f10.5,' dist=',f8.4,' A')
1001  format(' ***** Discrepancy found:',i6,' solute atom deviation**2',
     -  ' exceeds the tolerance (cslttol)',f9.6,' maximum deviation=',
     -  f8.5,' A')
1002  format(' Could not reclose the torsion loop driven by torsion',i6,
     -  ' t(it)=',f6.1,' t(loop)=',6f7.1,' deg')
1003  format(' Could not improve the backbone of solute molecule ',i4,
     -  ' - new devmax12,13=',2f10.5,' original devmax12,13=',2f10.5)
1004  format(' Reclosing of torsion loop ',i5,' changed too much ',
     -  ' - discarded')
1005  format(' Could not find a torsion loop affecting the worst ',
     -  'discrepancy')
1006  format(' Worst offender points to torsion',i5,', already dealt ',
     -  'with - fix attempt is aborted')
1007  format(' Torsion loop driven by torsion',i6,' was reclosed')
1008  format(' ***** Discrepancy found: solute molecule',i4,' torsion',
     -  i5,' temporary increment > 1:',i3)
      end
      subroutine findlooptor(itx0,itx,ia,loopmem,iprecursor,itangon,
     -  itorsionroot,molcent,maxat)
c#    MMC routine 350 lstmod: 06/11/04
c*****Finds the closest loopmember precursion torsion to itx0
      dimension loopmem(maxat),iprecursor(2,maxat),itangon(maxat),
     -  itorsionroot(maxat)
      itx=itx0
      do while ((loopmem(itx) .eq. 0 .or. itx .eq. itx0)
     -          .and. ia .ne. molcent)
        ia=iprecursor(1,ia)
        itx=itangon(itorsionroot(ia))
      end do
      itx0=itx
      return
      end
      subroutine ovrslt(ca,cb,na,nb,ixa,ixb)
c#    MMC routine 351 lstmod: 12/19/03
c*****Overlaps the molecule in cb with the one in ca as best as possible
      dimension ca(3,na),cb(3,nb),ixa(3),ixb(3)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      dimension o(3,3),c1(3,3),c2(3,3),cm1(3),cm2(3)
      if (nb .eq. 1) then
        do k=1,3
          cb(k,1)=ca(k,ixa(1))
        end do
      else if (nb .eq. 2) then
        ra2=0.0
        rb2=0.0
        do k=1,3
          cm1(k)=(ca(k,ixa(1))+ca(k,ixa(2)))/2.0
          cm2(k)=ca(k,ixa(1))-ca(k,ixa(2))
          ra2=ra2+cm2(k)**2
          rb2=rb2+(cb(k,ixb(1))-ca(k,ixb(2)))**2
        end do
        rfac=sqrt(rb2)/sqrt(ra2)/2.0
        do k=1,3
          cb(k,ixb(1))=cm1(k)+rfac*cm2(k)
          cb(k,ixb(2))=cm1(k)-rfac*cm2(k)
        end do
      else
        do k=1,3
          cm1(k)=0.0
          cm2(k)=0.0
        end do
        do k=1,3
          do i=1,3
            cm1(k)=cm1(k)+ca(k,ixa(i))
            cm2(k)=cm2(k)+cb(k,ixb(i))
          end do
          cm1(k)=cm1(k)/3.0
          cm2(k)=cm2(k)/3.0
        end do
        do i=1,3
          do k=1,3
            c1(k,i)=ca(k,ixa(i))-cm1(k)
            c2(k,i)=cb(k,ixb(i))-cm2(k)
          end do
        end do
        call ormat(o,c1,c2,na,0,linear,ifail)
        do i=1,nb
          do k=1,3
            cb(k,i)=cb(k,i)-cm2(k)
          end do
        end do
        call rot_trans(o,cb,cm1,cb,nb)
      end if
      return
      end
      subroutine wmatch(nruns,matchrun,ioplot,icrop,matchalg,numrun0)
c#    MMC routine 352 lstmod: 02/14/13
c*****Performs the matching of adaptive us runs
      dimension matchrun(#WM)
      character*80 file,filenames,filename1,filename2
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 ident
      common /title/ nlident,ident(2)
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /tdstate/ press,pressv,ba,temp,beta
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      real*8 wcplus
      common /wcpl/ wcplus(#WG),d0cpl,g0cpl,c0cplh,p0cplh,cplmin,cplmax,
     -  kp1mn,kp1mx,kp1zro,kp1one,kgimno,kgimxo,kgamn,kgamx,ktol,newlim
      real*8 dstcpl,dstcplsum,uwtav,uwtavo,upmftot,upmftv,upmftt,
     -  uwcplo,uwcpln,upmfin,upmftotsum,upmftvsum,upmfttsum
      common /cpldst/ uwtav,uwtavo,uwcplo,uwcpln,dstcpl(#WG),
     -  dstcplsum(#WG),upmftot(#WG),upmftv(#WG),upmftt(#WG),
     -  upmfin(#WG),upmftotsum(#WG),upmftvsum(#WG),upmfttsum(#WG),
     -  pbzavg(#WG),pbzavi(#WG),rndh(#WG),cpl(#WG),encfac(#WG),
     -  eincpl(#WG),nfisum(#WG),nfismo(#WG),nfisum_prev(#WG),nfksum(#WI)
      common /wadaptf/ ratmax,smplmx,faclim,fcenc1,fcenc2,encexp,rldvmx,
     -  diffmx,tolera,iopnrm,iopeql,iopenc,nitssk,nwtst,nsubmn,ngovmn,
     -  ngrcor,negitdel
      common /nstopt/ iterw,iterws,nsets,nitskp,limit1(5),limit2(5),
     -  limgr1(5),limgr2(5),ifirst(#WI),ilast(#WI),kstart(#WI),
     -  ixiter(#WI),iterix(#WI),iterz(#WI),pikl(#WS),wikl(#WS),
     -  nfikl(#WS)
      character*80 line
      common /inpline/ line,lineno,icol
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /oldio/ ifold(10),ifsaved
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension gwdp(1000),rnwdp(1000),ein(1000),wdp(1000),
     -  ifg(#WM),ilg(#WM),imf(#WM),iml(#WM),d0cplm(#WM),g0cplm(#WM),
     -  imatch(#WM),imin(#WM),imax(#WM),istar(#WM),lcpllab(#WM),
     -  optfac(#WM),y(102),z(102)
      character*150 paramprt
      character*100 pmftit,cplvar
      character*80 title1,title2
      character*39 fmt(3)
      character*4 labnrm(5),labenc(5),labint(2),labw
      character*3 cpllab(#WM)
      data wdp/1000*0.0/,imatch/#WM*0/,lcpllab /#WM*3/
      data pmftit /'Matched potential of mean force'/,lentit /31/
      data fmt/'(f7.2,i4,"*",2e11.4,i4,"*",e11.4)    ',
     -         '(f7.2,27x,i4,"*",2e11.4,i4,"*",e11.4)',
     -         '(f7.2,54x,i4,"*",2e11.4,i4,"*",e11.4)'/
      data imx /0/
      data labnrm/'GMOP','LNOW','LNOP','NLO0','NLO#'/
      data labenc/'NOBW','NONE','GLBE','ABDE','ABGL'/
      data labint/'LINR','EXPO'/
c     imin(i),imax(i): overlap limits between the i-th and i+1st run,
c                      in terms of the i-th.
c     imatch(i): grid index for matching for run i. i=1 <=> cplpar=0;
c                i=nruns+1 <=> cplpar=1 (for matchalg=1)
c     Number of runs to match, first chkpoint file unit no
c     if ioplot= 1 or 2, write w(r) segments on a .wmp file
c     if ioplot= 1 or 3,  generate Postscript plots in  a .wmp.ps file
c     if icrop = 1, write only the non-overlapping parts
c     matchalg = 1: Pick the best sampled point
c     matchalg = 2: Pick the factor that minimizes the weighted deviations
c     pldel1 and pldel2 will be added to w(lambda) and n(lambda) when written
c     on unit iwmatch. The first column will be r0+lambda*cx on unit iwmatch.
c     cplzero/igzero is the grid point where the PMF can be assumed to be 0
      numrun_sav=numrun
      iop24=iop(24)
      nitermin=1000000
      title1=ident(1)
      title2=ident(2)
      do im=1,#WM
        write (cpllab(im),1022) im
      end do
      call trnsfi(ifold,ifiles,10)
      ifsaved=1
      irectx=48
      call getnextrec(inpt,iout,irectx,nwwarn)
      read (line,1006,err=999) pldel1,pldel2,r0,cx,pmn,imatread,cplzero
      call lastchar(line,lc,80)
      if (iop24 .gt. 0) write (iout,1302)
     -   pldel1,pldel2,r0,cx,pmn,imatread,cplzero
      if (cx .eq. 0.0) cx=1.0
      if (r0 .eq. 0.0 .and. cx .eq. 1.0) then
        cplvar='Coupling parameter'
        lcplvar=18
      else
        if (lc .gt. 55) then
          ic=56
          call nextchar(line,ic,0,inpt,iout)
          lcplvar=lc-ic+1
          cplvar(1:lcplvar)=line(ic:lc)
        else
          lcplvar=0
        end if
      end if
      nr1=nruns+1
      if (imatread .gt. 0) then
c       Match points (optional)
        irectx=49
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999) (imatch(i),i=1,nr1)
        if (iop24 .gt. 0) write (iout,1303) (imatch(i),i=1,nr1)
        write (iout,1028)
      end if
      write (iout,1035)
      write (iout,1030)
      write (iout,1038)
      imf(1)=1
      ngtot=0
      do ir=1,nruns
c       For each run to match, gather the nonzero contributions
        call fileopen(file,namlenf,filenames(1),namlens(1),26,0,
     -      matchrun(ir),1,2,1,iop24,iversout,iout,ichkp,0)
        ifiles(1)=ichkp
        call crstr(0)
        call fileclose(ichkp,0,iverbos,iout)
        write (iout,1014) filenames(1)(1:namlens(1)),nmc,
     -    d0cpl,cplmin,cplmax,(ident(ic),ic=1,nlident)
        call fileclose(ichkp,0,iop24,iout)
        if (iterws .lt. nitermin) nitermin=iterws
        igf=1
        do while (rndh(igf)*pbzavg(igf) .eq. 0.0 .and. igf .lt. #WG)
          igf=igf+1
        end do
        igl=#WG
        do while (rndh(igl)*pbzavg(igl) .eq. 0.0 .and. igl .gt. 1)
          igl=igl-1
        end do
        if (igl .le. igf) then
          write (iout,1015) ir
          call datprt(2)
        else if (imf(ir)+igl-igf .gt. 1000) then
          write (iout,1011)
          call datprt(2)
        else
          do ig=igf,igl
            rnwdp(imf(ir)+ig-igf)=rndh(ig)
            gwdp(imf(ir)+ig-igf)=pbzavg(ig)/uwtav
            ein(imf(ir)+ig-igf)=eincpl(ig)
          end do
        end if
c       Remove the part outside the 0-1 lambda interval
        if (igf .lt. kp1zro) then
          igdiff=kp1zro-igf
          igf=kp1zro
          imf(ir)=imf(ir)+igdiff
        end if
        if (igl .gt. kp1one) then
          igdiff=igl-kp1one
          igl=kp1one
        end if
        ngtot=ngtot+igl-igf+1
        ifg(ir)=igf
        ilg(ir)=igl
        iml(ir)=imf(ir)+igl-igf
        imf(ir+1)=iml(ir)+1
        d0cplm(ir)=d0cpl
        g0cplm(ir)=g0cpl
      end do
      if (ngtot .gt. 1000) then
        write (iout,1021)
        call datprt(2)
      end if
      if (imatch(1) .eq. 0) imatch(1)=kp1zro
      if (imatch(nr1) .eq. 0) imatch(nr1)=kp1one
      optfac(1)=1.0
      if (nruns .eq. 1) then
        if (ifg(1) .gt. imatch(1)) imatch(1)=ifg(1)
      else
        do ir=2,nruns
c         Find the matching points between runs ir and ir-1
          imin(ir-1)=max0(ifg(ir),ifg(ir-1))
          imax(ir-1)=ilg(ir-1)
          if (imax(ir-1).lt. imin(ir-1)) then
            write (iout,1016) ir-1,ir,imax(ir-1),imin(ir-1)
          else if (matchalg .eq. 1) then
c           Find the best sampled match point
            rmax=0
            do ig=imin(ir-1),imax(ir-1)
              r=rnwdp(imf(ir-1)+(ig-ifg(ir-1)))*
     -          rnwdp(imf(ir)+(ig-ifg(ir)))
              if (iop24 .gt. 1) write (iout,1323) ig,r,
     -          rnwdp(imf(ir-1)+(ig-ifg(ir-1))),
     -          rnwdp(imf(ir)+(ig-ifg(ir)))
              if (r .gt. rmax) then
                rmax=r
                imat=ig
              end if
            end do
            write (iout,1017) ir-1,ir,
     -        ifg(ir-1),ilg(ir-1),ifg(ir),ilg(ir),imat
            if (imatch(ir) .eq. 0) imatch(ir)=imat
          else
c           Find the optimal factor
            ws=0.0
            fws=0.0
            do ig=imin(ir-1),imax(ir-1)
              w=rnwdp(imf(ir-1)+(ig-ifg(ir-1)))*
     -          rnwdp(imf(ir)+(ig-ifg(ir)))
              f=gwdp(imf(ir-1)+(ig-ifg(ir-1)))/
     -          gwdp(imf(ir)+(ig-ifg(ir)))
              ws=ws+w
              fws=fws+w*f
            end do
            optfac(ir)=fws/ws
            bestrat=10000.0
c           Find grid where the ratio is closest ot the optimal factor
            do ig=imin(ir-1),imax(ir-1)
              f=gwdp(imf(ir-1)+(ig-ifg(ir-1)))/
     -          gwdp(imf(ir)+(ig-ifg(ir)))
              rat=amax1(f/optfac(ir),optfac(ir)/f)
              if (rat .lt. bestrat) then
                bestrat=rat
                imat=ig
              end if
            end do
            if (imatch(ir) .eq. 0) imatch(ir)=imat
          end if
        end do
      end if
      if (imatch(1) .eq. 0) imatch(1)=imin(1)
      imin(nruns)=ilg(nruns)+1
      if (ilg(nruns) .lt. imatch(nr1) .or. imatch(nr1) .eq. 0)
     -  imatch(nr1)=ilg(nruns)
      imax(nruns)=imatch(nr1)
      nruns1=nruns-1
      i0=(-0.5*g0cplm(1)-d0cplm(1)+g0cplm(1)/2.0)/g0cplm(1)
      if (iop24 .gt. 1) then
        write (iout,1324)
        do ir=1,nruns
          write (iout,1320) ir,imf(ir),iml(ir),ifg(ir),ilg(ir),
     -      imin(ir),imax(ir),d0cplm(ir),cpl(ifg(ir)),cpl(ilg(ir))
          write (iout,1321) 'rnwdp',(rnwdp(ig),ig=imf(ir),iml(ir))
          write (iout,1321) 'gwdp ',(gwdp(ig),ig=imf(ir),iml(ir))
        end do
      end if
      nseg=(nruns-2)/3+1
      ns1=1
      do iseg=1,nseg
        ns2=min0(nruns,3*iseg)
        write (iout,1001) (j,j,j+1,j=ns1,ns2),ns2+1
        write (iout,1030)
        do irun=ns1,ns2
          if (irun .lt. nruns) then
            imn1=imin(irun)-1
          else
            imn1=imatch(nruns+1)
          end if
          do ir=i0,imn1
            ri=d0cplm(irun)+g0cplm(irun)/2.0+ir*g0cplm(irun)
            gwdppr=0.0
            if (ir .ge. ifg(irun) .and. ir .le.
     -        ifg(irun)+iml(irun)-imf(irun)+1) gwdppr=
     -          gwdp(imf(irun)+ir-ifg(irun))
            write (iout,fmt(mod(irun-1,3)+1)) ri,ir,gwdppr
          end do
          if (irun .lt. nruns) then
            imn=imin(irun)
            imx=min0(imax(irun),imax(irun+1))
            do ir=imn,imx
              ri=d0cplm(irun)+g0cplm(irun)/2.0+ir*g0cplm(irun)
              alpha=gwdp(imf(irun)+ir-ifg(irun))/
     -          gwdp(imf(irun+1)+ir-ifg(irun+1))
              write (iout,fmt(mod(irun-1,3)+1)) ri,ir,
     -          gwdp(imf(irun)+ir-ifg(irun)),
     -          alpha,ir,gwdp(imf(irun+1)+ir-ifg(irun+1))
            end do
          end if
          i0=imx+1
        end do
        ns1=ns2+1
        write (iout,1030)
      end do
      if (imatch(nruns+1) .eq. 0) call datprt(1)
      do ir=2,nruns
        if (matchalg .eq. 1 .or. matchalg .eq. 3) then
          fact=gwdp(imf(ir-1)+imatch(ir)-ifg(ir-1))/
     -      gwdp(imf(ir)+imatch(ir)-ifg(ir))
          write (iout,1004) ir,imatch(ir),fact
        else
          fact=optfac(ir)
          write (iout,1027) ir,fact
          fact=fact*optfac(ir-1)
          optfac(ir)=fact
        end if
        do ig=imf(ir),iml(ir)
          gwdp(ig)=gwdp(ig)*fact
        end do
      end do
      if (iop24 .gt. 1) then
        do ir=1,nruns
          write (iout,1322) ir,ifg(ir),ilg(ir),imatch(ir+1),
     -      (gwdp(ig),ig=imf(ir),iml(ir))
        end do
      end if
      if (ifg(1) .le. kp1zro .and. ilg(nruns) .ge. kp1one) then
        gwdp0=gwdp(kp1zro-ifg(1)+1)
        gwdp1=gwdp(imf(nruns)+kp1one-ifg(nruns)+1)
        write (iout,1031) gwdp0,gwdp1
        if (gwdp0*gwdp1 .ne. 0.0) then
          dela=alog(gwdp0/gwdp1)/beta
          if (fcintra .ne. 1.0) then
            eincorr=(eincpl(imatch(ir))-eincpl(kp1zro))*(1.0-fcintra)
            write (iout,1010) dela+eincorr,' ',eincorr
          else
            write (iout,1010) dela
          end if
        else
          write (iout,1002) 'Endpoint probability is zero'
        end if
        write (iout,1005) eincpl(kp1one)-eincpl(kp1zro)
      else
        write (iout,1002) 'The full lambda interval was not sampled'
      end if
      if (iop24 .gt. 1)  write (iout,1030)
      write (iout,*)
      if (iop(51) .gt. 0) call aus_params(iout,iop,0.0,0.0,nmcadp)
      write (iout,*)
c     Prepare plot of matched curves
      if (iop(51) .gt. 0) then
        write (paramprt,1019) cutslv,nmcadp,nitermin
        lentit2=38
        labw=labnrm(min0(iopnrm+4,5))
        if (iopnrm .gt. 0 .and. iopnrm .le. 9)
     -     write (labw(4:4),1026) iopnrm
        paramprt(1:lentit2+11)=paramprt(1:lentit2)//' Match:'//labw
        lentit2=lentit2+11
        labw=labenc(iopenc+2)
        paramprt(1:lentit2+13)=paramprt(1:lentit2)//' Promote:'//labw
        lentit2=lentit2+13
        labw=labint(iop(51))
        paramprt(1:lentit2+14)=paramprt(1:lentit2)//' Interpol:'//labw
        lentit2=lentit2+14
        if (fcintra .ne. 1.0) then
          write ( paramprt(1:lentit2+11),1025) 'fcint',fcintra
          lentit2=lentit2+11
        end if
        if (iopenc .gt. 1) then
          write (paramprt(lentit2+1:lentit2+13),1024) 1,fcenc1
          lentit2=lentit2+13
        end if
        if (iopenc .lt. 0 .or. iopenc .eq. 1 .or. iopenc .eq. 3) then
          write (paramprt(lentit2+1:lentit2+13),1024) 2,fcenc2
          lentit2=lentit2+13
          write (paramprt(lentit2+1:lentit2+13),1025) 'encexp',encexp
          lentit2=lentit2+13
        end if
      else
        write (paramprt,1023) cutslv
        lentit2=21
      end if
      ioutps=0
      iwmatch=0
      if (ioplot .gt. 0) then
        if (ioplot .eq. 1 .or. ioplot .eq. 3) then
          call fileopen(file,namlenf,filename1,namlen1,31,0,
     -      numrun0,1,0,0,iop24,iversout,iout,ioutps,0)
          iheadps=1
          write (iout,1018) 'plotted',filename1(1:namlen1)
        end if
        if (ioplot .eq. 1 .or. ioplot .eq. 2) then
          call fileopen(file,namlenf,filename2,namlen2,17,0,
     -      numrun0,1,0,0,iop24,iversout,iout,iwmatch,0)
          write (iout,1018) 'written',filename2(1:namlen2)
        end if
        write (iout,*)
      end if
      if (cplzero .ne. 0.0) then
        diffmin=1000.0
        do ig=kp1zro,kp1one
          diff=abs(cplzero-cpl(ig))
          if (diff .lt. diffmin) then
            igzero=ig
            diffmin=diff
          end if
        end do
      else
        igzero=0
      end if
      if (fcintra .ne. 1.0) write (iout,1036) fcintra
      if (matchalg .eq. 1) write (iout,1029) 'best sampled point'
      if (matchalg .eq. 2) write (iout,1029) 'best overlap of graphs'
      if (matchalg .eq. 3) write (iout,1029)
     -   'crossover point of the best overlap of graphs'
      if (igzero .ne. 0) write (iout,1037) cpl(igzero),igzero
      shiftzero=0.0
      wdpmin=1000.0
      wdpmax=-1000.0
      do ir=1,nruns
        do ig=imf(ir),iml(ir)
          if (gwdp(ig) .ne. 0.0) then
            wdp(ig)= -alog(gwdp(ig))/beta
          else if (ig .gt. imf(ir)) then
            wdp(ig)=wdp(ig-1)
          end if
c         Add the intra contribution to make wdp the full PMF
          if (fcintra .ne. 1.0)
     -      wdp(ig)=wdp(ig)+(1.0-fcintra)*ein(ig)
          if (wdp(ig) .lt. wdpmin) wdpmin=wdp(ig)
          if (wdp(ig) .ge. wdpmax) wdpmax=wdp(ig)
        end do
        if (igzero .gt. 0) then
          if (igzero .ge. ifg(ir) .and. igzero .le. ilg(ir)) shiftzero=
     -        wdp(imf(ir)+igzero-ifg(ir))-ein(imf(ir)+igzero-ifg(ir))
        end if
      end do
c     Shift wdp if igzero is given; find range of wdp
      if (shiftzero .ne. 0.0) then
        wdpmin=wdpmin-shiftzero
        wdpmax=wdpmax-shiftzero
        do ir=1,nruns
          do ig=imf(ir),iml(ir)
            wdp(ig)=wdp(ig)-shiftzero
          end do
        end do
        write (iout,1034) shiftzero
      end if
      if (iwmatch .gt. 0) then
        if (icrop .eq. 1) write (iout,1012)
        if (r0 .ne. 0.0 .or. cx .ne. 1.0) write (iout,1007) r0,cx
        if (pldel1+pldel2 .ne. 0.0) write (iout,1008) pldel1,pldel2
        if (pmn .gt. 0.0) write (iout,1009) pmn
        write (iout,1013)
        write (iout,1039) filename2(1:namlen2)
        write (iout,1033)
      end if
      call zeroit(y,#WG)
      call zeroit(z,#WG)
      wyzmin=1000.0
      wyzmax=-1000.0
      iggmin=#WG
      iggmax=0
      do ir=1,nruns
        do ig=imf(ir),iml(ir)
          igg=ig-imf(ir)+ifg(ir)
          xpl=cpl(igg)*cx+r0
          ypl=wdp(ig)+pldel1
          zpl=rnwdp(ig)+pldel2
          if (iwmatch .gt. 0) then
            if (rnwdp(ig) .gt. pmn .and. (icrop .eq. 0 .or.
     -        (igg .ge. imatch(ir) .and. igg .le. imatch(ir+1))))
     -        write (iwmatch,1020) xpl,ypl,zpl,ein(ig),
     -          ypl-ein(ig),ypl-(1.0-fcintra)*ein(ig)
          end if
          write (iout,1032) igg,cpl(igg),wdp(ig),ein(ig),
     -      wdp(ig)-ein(ig),wdp(ig)-(1.0-fcintra)*ein(ig)
          if (igg .ge. imatch(ir) .and. igg .le. imatch(ir+1)) then
c           Save a continuous plot of PMF, PMF-eintra
            eincpl(igg)=ein(ig)
            y(igg)=wdp(ig)
            z(igg)=wdp(ig)-eincpl(igg)
            if (amin1(y(igg),eincpl(igg),z(igg)) .lt. wyzmin)
     -        wyzmin=amin1(y(igg),eincpl(igg),z(igg))
            if (amax1(y(igg),eincpl(igg),z(igg)) .gt. wyzmax)
     -        wyzmax=amax1(y(igg),eincpl(igg),z(igg))
            if (igg .lt. iggmin) iggmin=igg
            if (igg .gt. iggmax) iggmax=igg
          end if
        end do
      end do
      ident(1)=title1
      ident(2)=title2
      call trnsfi(istar,imatch(2),nruns)
      istar(nruns)=0
      pmftit(lentit+1:67)=' (with intramolecular contributions)'
      lentit=lentit+36
c     pmftit(lentit+1:70)=' (without intramolecular contributions)'
c     lentit=lentit+39
      call get_engrange(wdpmin,wdpmax,y0,nydiv,ydiv)
      call plotn(cpl,wdp,#WG,1000,nruns,imf,iml,ifg,istar,ifg(1),
     -  ilg(nruns),y0,ydiv/10.0,10*nydiv,1,lentit,pmftit(1:lentit),iout)
      if (cx .ge. 10) then
        cpldiv=cx/5.0
        ncpldiv=5
      else
        ncpldiv=cx
        if (abs(cx-float(ncpldiv)) .gt. 0.01) ncpldiv=ncpldiv+1
        cpldiv=1.0
      end if
      numpage=1
      call plotnps(cpl,wdp,#WG,1000,nruns,imf,iml,ifg,r0,cx,
     -  0.0,cpldiv,ncpldiv,y0,ydiv,0.0,nydiv,0,lentit,pmftit(1:lentit),
     -  lentit2,paramprt,cplvar,lcplvar,cpllab,lcpllab,ioutps,iheadps,
     -  numpage,inperr,iout)
      call zeroiti(istar,0,nruns)
      if (iop(18) .eq. 4) then
        call plotn(cpl,ein,#WG,1000,nruns,imf,iml,ifg,istar,ifg(1),
     -    ilg(nruns),0.0,0.0,50,1,32,
     -    'Intramolecular energy (kcal/mol)',iout)
        call plotnps(cpl,wdp,#WG,1000,nruns,imf,iml,ifg,r0,cx,
     -    0.0,cpldiv,ncpldiv,0.0,0.0,0.0,10,0,32,
     -    'Intramolecular energy (kcal/mol)',lentit2,paramprt,cplvar,
     -    lcplvar,cpllab,lcpllab,ioutps,iheadps,numpage,inperr,iout)
      end if
      call plotn(cpl,rnwdp,#WG,1000,nruns,imf,iml,ifg,istar,ifg(1),
     -  ilg(nruns),0.0,0.0,50,1,23,'Frequencies of sampling',iout)
      call plotnps(cpl,rnwdp,#WG,1000,nruns,imf,iml,ifg,r0,cx,
     -  0.0,cpldiv,ncpldiv,0.0,0.0,999999.0,10,1,23,
     -  'Frequencies of sampling',lentit2,paramprt,cplvar,lcplvar,
     -  cpllab,lcpllab,ioutps,iheadps,numpage,inperr,iout)
c     Combine w(r), eintra(r) and w(r)-eintra(r)
      ng=iggmax-iggmin+1
      do k=1,3
        lcpllab(k)=3
        ifg(k)=iggmin
      end do
      imf(1)=1
      cpllab(1)='PMF'
      call trnsfr(gwdp,y(iggmin),ng)
      iml(1)=ng
      imf(2)=iml(1)+1
      cpllab(2)='EIN'
      call trnsfr(gwdp(imf(2)),eincpl(iggmin),ng)
      iml(2)=iml(1)+ng
      imf(3)=iml(2)+1
      cpllab(3)='WSW'
      call trnsfr(gwdp(imf(3)),z(iggmin),ng)
      iml(3)=iml(2)+ng
      call get_engrange(wyzmin,wyzmax,y0,nydiv,ydiv)
      call plotnps(cpl,gwdp,#WG,1000,3,imf,iml,ifg,r0,cx,
     -  0.0,cpldiv,ncpldiv,y0,ydiv,0.0,nydiv,1,36,
     -  'PMF and intramolecular contributions',lentit2,paramprt,cplvar,
     -  lcplvar,cpllab,lcpllab,ioutps,iheadps,numpage,inperr,iout)
      if (ioutps .gt. 0) close(ioutps)
      if (iwmatch .gt. 0) call fileclose(iwmatch,0,iop(24),iout)
      call trnsfi(ifiles,ifold,10)
      ifsaved=0
      numrun=numrun_sav
      iop(24)=iop24
      return
999   call invalidform(iout,irectx)
      return
1000  format(11i5)
1001  format(/,'   cpl ',3('      p(',i2,')     ',
     -  ' p(',i2,')/p(',i2,')'),'      p(',i2,')')
1002  format(1x,a,/,' - no free-energy estimate is calculated')
1004  format(' Matching factor of interval',i3,' at grid',i4,'=',e12.5)
1005  format(' Intramolecular contribution to the free energy=',f10.4)
1006  format(5f10.0,i5,f5.0)
1007  format(' On the .wmp file(s) the coupling parameter will be',
     -  ' transformed to ',f9.4,' + lambda * ',f9.4)
1008  format(' On the .wmp file(s) the PMF values will be incremented',
     -  ' by ',f9.4,' and the sampling frequencies by ',f9.5)
1009  format(' Gridpoints with sampling frequency below ',f9.6,' will ',
     -  'not be written on the .wmp file(s)=',f9.6)
1010  format(' The free energy difference including the full ',
     -  'intramolecular energy=',f12.6,' kcal/mol',a,/,
     -  ' The neglected intramolecular contribution=',f12.6)
1011  format(' ***** ERROR: too many runs to match - dimension the ',
     -  '1000-long arrays in subroutine wmatch longer')
1012  format(' Overlapping ranges will not be written to the .wmp ',
     -  'file(s)')
1013  format(' Potential of mean force will include the Lennard-Jones',
     -  ' and electrostatics intramolecular terms')
1014  format(' Checkpoint file name: ',a,
     -  ' Number of MC steps=',i10,' d0cpl=',f10.4,' cplmin,max=',2f6.2,
     -  /,2(1x,a80,/))
1015  format(' ***** ERROR: the ',i2,'-th checkpointfile has at most',
     -  ' one grid information')
1016  format(' Matching is impossible between runs ',i2,' and ',i2,
     -  ' - no overlap:',2i4)
1017  format(' Runs ',i2,' and ',i2,' do overlap: ',i3,' - ',i3,' and ',
     -  i3,' - ',i3,'; match point chosen:',i4)
1018  format(' Individual PMFs and sampling frequencies will be ',a,
     -  ' on file ',a)
1019  format('Rc=',f4.1,' A nmcadp=',i9,' nitermn=',i3)
1020  format(f12.6,' ',f12.6,' ',f10.8,3(' ',f12.6))
1021  format(' ***** ERROR: arrays gwdp and rnwdp in subroutine wmat ',
     -  'are too small - increase dimension to exceed ',i5)
1022  format('W',i2)
1023  format('Harmonic US Rc=',f4.1,' A')
1024  format(' fcenc',i1,'=',f5.1)
1025  format(1x,a,'=',f5.2)
1026  format(i1)
1027  format(' Matching factor of interval',i3,' optimized)=',e12.5)
1028  format(' ///// NOTE: matching algorithm will be ignored for ',
     -  'explicitly given matchpoints')
1029  format(' Matching of intervals is based on ',a)
1030  format(1x,129('-'))
1031  format(/,' Sampling probabilities at lambda= 0.0 and 1.0, resp.:',
     -  2f10.7)
1032  format(i5,1x,5f15.5)
1033  format(/,16x,'cpl           w(cpl)       eintra(cpl)   ',
     -  'wcpl(slv)     wcpl(samp)')
1034  format(' PMF curve will be shifted down by ',f6.2,' kcal/mol')
1035  format(/,20x,'Matching PMF curves generated for different ',
     -  'coupling parameter ranges',/)
1036  format(' During the US simulations the intramolecular ',
     -  'contributions were scled by a factor of ',f6.2)
1037  format(' The PMF value at coupling parameter value ',f5.3,
     -  ' (grid # ',i3,') will be set to zero and the curve shifted ',
     -  'accordingly')
1038  format(/,' Reading the checkpoint files fro the different ',
     -  'coupling parameter ranges')
1039  format(' The table below will be also written on the ',a,
     -  ' file (with the transformations described above)')
1302  format(' rectype 48:',5f10.5,i5,f5.2)
1303  format(' rectype 49:',11i5)
1320  format(' WMATCH run ',i2,' imf,iml=',2i5,' ifg,ilg=',2i4,
     -  ' imin,max=',2i4,' d0=',f8.4,' cpl limits=',2f8.4)
1321  format(' WMATCH ',a,':',(10e12.5))
1322  format(' WMATCH ',i3,' ifg,ilg=',2i4,' imatch=',i4,
     -  ' Matched g:',/,(10e12.5))
1323  format(' WMATCH ig=',i3,' r=',e12.5,' g1,2=',2e12.5)
1324  format(' The Boltzmann-probabilities and the sampling ',
     -  'frequencies obtained from the different runs:')
      end
      subroutine plotn(x,y,nxmax,nymax,nf,imf,iml,ifg,istar,n1,n2,
     -  y00,yd,nny,iprt,ntit,itit,iout)
c#    MMC routine 353 lstmod: 08/07/12
c*****Primitive plotter on printer for n functions of the same variable
      dimension x(nxmax),y(nymax),imf(nf),iml(nf),ifg(nf),istar(nf)
      character*80 ident
      common /title/ nlident,ident(2)
      character*1 page(100,50),nmbr(10)
      character*(*) itit
c     x,y(i,n): x and the y coordinates of the n-th functions to be plotted
c     n1,n2: plot from n1 to n2; ny: number of lines;
c     y00,yd: y scale minimum and unit, yd=0 => program finds them
c     iprt: if .ne. 0, print the function values;
c     itit: string containing the title; ntit: number of chars in itit
      character*12 plotnum
      real*8 wd
      dimension wd(1)
      data nmbr/'0','1','2','3','4','5','6','7','8','9'/
      if (n2-n1 .lt. 2) return
      ny=nny
      write (iout,5006)
      write (iout,5002) (ident(ic),ic=1,nlident)
      write (iout,5002) itit(1:ntit)
      if (ny .gt. 50 .or. ny .lt. 2) ny=50
      y0=y00
      ydiv=yd
      nx=100
      do i=1,nx
        do j=1,ny
          page(i,j)=' '
        end do
      end do
      x0=x(n1)
      xdiv=(x(n2)-x0)/float(nx-1)
      if (ydiv .eq. 0.0) then
        ymin=y(1)
        ymax=ymin
        do i=1,iml(nf)
          if (y(i) .lt. ymin) ymin=y(i)
          if (y(i) .gt. ymax) ymax=y(i)
        end do
        y0=ymin-(ymax-ymin)*0.01
        ydiv=(ymax-y0)/float(ny-1)
      end if
      do if=1,nf
        do ig=imf(if),iml(if)
          if (y(ig) .ne. 0.0) then
            ix=(x(ifg(if)+ig-imf(if))-x0)/xdiv+1
            if (ix .ge. 1 .and. ix .le. 100) then
              iy=(y(ig)-y0)/ydiv
              iy=ny-iy
              if (iy .ge. 1 .and. iy .le. ny) then
                if (page(ix,iy) .eq. ' ') then
                  page(ix,iy)=nmbr(mod(if-1,10)+1)
                  if (istar(if) .eq. ifg(if)+ig-imf(if)) page(ix,iy)='*'
                end if
              end if
            end if
          end if
        end do
      end do
      do i=1,ny
        ii=ny-i+1
        ry=y0+(ii-1)*ydiv
        if (mod(ii,5) .ne. 1) write (iout,5001) (page(k,i),k=1,nx)
        if (mod(ii,5) .eq. 1) write (iout,5000) ry,(page(k,i),k=1,nx),ry
      end do
      write (iout,5003)
      write (iout,5004) (10*(i-1)*xdiv+x0,i=1,11)
      if (iprt .gt. 0) then
        do if=1,nf
          write (plotnum,5005) if
          call print_cplw(x(ifg(if)),wd,y(imf(if)),2,iml(if)-imf(if)+1,
     -      plotnum,12,iout)
        end do
      end if
      return
5000  format(e12.4,'+',100a1,'+',e12.4)
5001  format(12x,'+',100a1,'+')
5002  format(1x,a)
5003  format(13x,10('+',9('-')),'+')
5004  format(6x,11e10.3,//)
5005  format(' Plot ',i2)
5006  format(//)
      end
      subroutine plotnps(x,y,nxmax,nymax,nf,imf,iml,ifg,r0,cx,
     -  x00,xd,nnx,y00,yd,yline,nny,iprt,ntit,tit,ntit2,tit2,xlab,lenx,
     -  fclab,lfclab,iplot,ihead,numpage,inperr,iout)
c#    MMC routine 354 lstmod: 11/05/12
c*****Postscript plot of n functions of the same variable
      dimension x(nxmax),y(nymax),imf(nf),iml(nf),ifg(nf),lfclab(nf)
      character*(*) xlab,fclab(nf),tit2
      character*80 ident
      common /title/ nlident,ident(2)
      character*(*) tit
c     nf: number of functions to be plotted
c     x: the x coordinates of the functions to be plotted
c     ifg(if): First value in x for the if-th function
c     imf(if), iml(if): Y {imf(if) - iml(if)} the value of the if-th function
c     r0,cx: x coordonate labels are transformed as r0+x(i)*cx
c     y00,yd: y scale minimum and unit, yd=0 => program finds them
c     iprt: if .ne. 0, print the function values;
c     tit: string containing the title; ntit: number of chars in tit
      real*8 wd
      dimension wd(1)
      character*18 plotnum
      if (iplot .eq. 0) return
      nx=nnx
      ny=nny
      if (iprt .gt. 0) then
        write (iout,5002)
        do if=1,nf
          write (plotnum,5005) if
          call print_cplw(x(ifg(if)),wd,y(imf(if)),2,iml(if)-imf(if)+1,
     -      plotnum,18,iout)
        end do
      end if
      ix0=100
      iy0=90
      ixwid=600
      iyhgt=480
      if (ihead .eq. 1) then
        call psheader(iplot,tit,ntit,0,0,612,792,1)
        ihead=0
      end if
      write (iplot,1001)
      if (numpage .gt. 0) then
         write (iplot,1017) numpage
         numpage=numpage+1
      end if
      if (nf .gt. 1) call rgbcolor(iplot,-1.0)
      write (iplot,1002) ix0+300-ntit*3,iy0+iyhgt+10
      write (iplot,1004) tit(1:ntit)
      write (iplot,1002) ix0+300,iy0-40
      iytit=iy0+iyhgt-15
      write (iplot,1002) ix0+10,iytit
      write (iplot,1004) ident(1)
      iytit=iytit-15
      call lastchar(ident(2),lc,80)
      if (lc .gt. 1) then
        write (iplot,1002) ix0+10,iytit
        write (iplot,1004) ident(2)
      end if
      if (ntit2 .gt. 0) then
        ixshift=0
        if (ntit2 .gt. 130) ixshift=50
        write (iplot,1002) ix0-ixshift,iy0-50
        write (iplot,1004) tit2(1:ntit2)
        iytit=iytit-15
      end if
      write (iplot,1010) ix0,iy0,ixwid,iyhgt,-ixwid
      if (lenx .gt. 0) then
        write (iplot,1002) ix0+300-lenx/5,iy0-30
        write (iplot,1004) xlab(1:lenx)
      end if
      iyhgt=iyhgt-40
      if (xd .eq. 0.0) then
        write (iout,5001)
        inperr=inperr+1
        return
      else
        xmin=x00
        xdiv=xd
        xmax=xmin+nx*xdiv
      end if
      if (yd .eq. 0.0) then
        ymin=y(1)
        ymax=ymin
        do i=1,iml(nf)
          if (y(i) .lt. ymin) ymin=y(i)
          if (y(i) .gt. ymax) ymax=y(i)
        end do
        ny=10
        ymin=ymin-(ymax-ymin)*0.01
        ydiv=(ymax-y00)/10.0
      else
        ymin=y00
        ydiv=yd
        ymax=ymin+ny*ydiv
      end if
c     Draw ticks, write axis values
      ly=alog10(abs(ydiv))
      do i=0,ny
        write (iplot,1008)
        write (iplot,1002) ix0,iy0+i*iyhgt/ny
        write (iplot,1003) 5,0
        write (iplot,1002) ix0-50,iy0-5+i*iyhgt/ny
        if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
        if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
        write (iplot,1002) ix0+ixwid,iy0+i*iyhgt/ny
        write (iplot,1003) -5,0
        write (iplot,1011)
        write (iplot,1002) ix0+ixwid+10,iy0-5+i*iyhgt/ny
        if (ly .lt. 7) write (iplot,1005) ymin+i*ydiv
        if (ly .ge. 7) write (iplot,1006) ymin+i*ydiv
      end do
      write (iplot,1011)
      do i=0,nx
        write (iplot,1008)
        write (iplot,1002) ix0+i*ixwid/nx,iy0
        write (iplot,1003) 0,5
        write (iplot,1011)
        write (iplot,1002) ix0-30+i*ixwid/nx,iy0-15
        write (iplot,1013) r0+i*xdiv
      end do
      write (iplot,1011)
c     Plot graphs
      if (ymax .gt. ymin) then
        yfac=iyhgt/(ymax-ymin)
      else
        yfac=0.0
      end if
      iyhgt=480
      iylab=iy0+iyhgt-15
      ixinc=max0(1,nx/15)
      do if=1,nf
        istarted=0
        if (nf .gt. 1) call rgbcolor(iplot,float(if-1)/float(nf-1))
        write (iplot,1016) 1+2*if
        write (iplot,1008)
        write (iplot,1002) ix0+3*ixwid/4,iylab
        write (iplot,1012) if
        write (iplot,1002) ix0+3*ixwid/4+15,iylab+4
        write (iplot,1003) ixwid/8,0
        write (iplot,1002) ix0+3*ixwid/4+ixwid/8+15,iylab
        write (iplot,1015) fclab(if)(1:lfclab(if))
        write (iplot,1011)
        iylab=iylab-15
        write (iplot,1008)
        do ig=imf(if),iml(if)
          if (y(ig) .ne. 0.0) then
            ix=ix0+cx*(x(ifg(if)+ig-imf(if))-xmin)*ixwid/(xmax-xmin)
            if (ix .ge. ix0 .and. ix .le. ix0+ixwid) then
              iy=iy0+yfac*(y(ig)-ymin)
              if (istarted .eq. 0) then
                write (iplot,1002) ix,iy
                istarted=1
              else
                write (iplot,1007) ix,iy
              end if
            end if
          end if
        end do
        write (iplot,1011)
      end do
      if (yline .ne. 999999.0) then
c       Draw a horizontal line at y=yline
        write (iplot,1018) 1
        write (iplot,1019)
        call rgbcolor(iplot,-1.0)
        write (iplot,1008)
        ix=ix0
        iy=iy0+yfac*(yline-ymin)
        write (iplot,1002) ix,iy
        write (iplot,1003) ixwid,0
        write (iplot,1011)
      end if
      if (nf .gt. 1) call rgbcolor(iplot,-1.0)
      write (iplot,1014)
      write (iplot,1099)
      return
1001  format('/Helvetica findfont',/,'11 scalefont',/,'setfont',/,
     -  '612 0 translate',/,'90 rotate')
1002  format(i5,i5,' moveto')
1003  format(i5,i5,' rlineto')
1004  format('(',a,') show')
1005  format('(',f10.3,') show')
1006  format('(',e10.4,') show')
1007  format(i5,i5,' lineto')
1008  format('newpath')
1010  format('% Drawing of graph boundaries',/,'newpath',/,
     -  i3,1x,i3,' moveto',/,i4,' 000 rlineto',/,'000 ',i4,' rlineto',/,
     -  i5,' 000 rlineto',/,'closepath',/,'stroke')
1011  format('stroke')
1012  format('(',i2,') show')
1013  format('(',f10.2,') show')
1014  format('-90 rotate',/,'-612 0 translate')
1015  format('( : ',a,') show')
1016  format('[',i3,' 3] 0 setdash')
1017  format('%%Page: 1',i3)
1018  format(i2,' setlinewidth')
1019  format('[] 0 setdash')
1099  format('showpage')
5001  format(' ***** PROGRAM ERROR: plotnps needs nonzero xdiv')
5002  format(1x,//,(1x,a))
5005  format(' Postcript plot ',i2)
c5005  format(' Plot ',i5,' xfirst=',e12.5,' xlast=',e12.5,' y=',/,
c     -  (10e13.6))
      end
      subroutine psheader(iout,title,ltitle,ix0,iy0,ixm,iym,npspages)
c#    MMC routine 354/a lstmod: 01/03/08
c*****Print a Postscript file header
      character*(*) title
      character*12 today
      common /today_date/ ltoday,today
      if (npspages .gt. 0) then
        write (iout,1000) title(1:ltitle)
        if (npspages .lt. 10) then
          write (iout,1021) npspages
        else if (npspages .lt. 10) then
          write (iout,1022) npspages
        else
          write (iout,1023) npspages
        end if
        write (iout,1030) ix0,iy0,ixm,iym
        if (ltoday .gt. 0) write (iout,1001) today(1:ltoday)
        write (iout,1040)
      end if
      return
1000  format('%!PS-Adobe-2.0 ',/,'%%Title: ',a,/,
     -  '%%Creator: MMC')
1001  format('%%CreationDate: ',a)
1021  format('%%Pages:',i1)
1022  format('%%Pages:',i2)
1023  format('%%Pages:',i3)
1030  format('%%BoundingBox:',4i8)
1040  format('%%EndComments')
      end
      subroutine get_engrange(emin,emax,y0,ndiv,div)
c#    MMC routine 354/b lstmod: 08/22/12
      imin=emin
      if (float(imin) .gt. emin) imin=imin-1
      y0=imin
      imax=emax
      if (float(imax) .lt. emax) imax=imax+1
      irange=imax-imin
      if (irange .le. 10) then
        div=1.0
        ndiv=irange
      else if (irange .le. 20) then
        div=2.0
        ndiv=irange/2+1
      else
        ndiv=5
        div=irange/ndiv
      end if
      return
      end
      subroutine rgbcolor(iout,frac)
c#    MMC routine 355 lstmod: 12/05/03
c*****Set the PS color to frac way on the rainbow scale (0<=frac<=1)
      if (frac .lt. 0.0) then
        red=0.0
        green=0.0
        blue=0.0
      else if (frac .le. 0.5) then
        red=2.0*(0.5-frac)
        green=2.0*frac
        blue=0.0
      else
        red=0.0
        green=2.0*(0.5-(frac-0.5))
        blue=2.0*(frac-0.5)
      end if
      write (iout,1000) red,green,blue
      return
1000  format(3f5.1,' setrgbcolor')
      end
      subroutine tiquad(reglist,svst,tiinteg,MYRANK)
c#    MMC routine 356 lstmod: 04/04/22
c*****Performs the TI quadrature with error estimates (3, 5 or 8 pts)
      character*4 reglist,svst
      dimension tiinteg(50)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /cplp358/ cpl358(8,3),cq358(8,3),ixcpl(8)
      character*80 line
      common /inpline/ line,lineno,icol
      common /option/ iop(200),idebug(200)
      real*8 tixsum,ticums,ticumtot
      dimension  tixsum(#MI,8),ticums(#MI,8),ticumtot(#MI)
      dimension tiblks(#MI,8),freeblk(#MI),sdsum(#MI),freecum(#MI),
     -  listruns(8),sdcomp(8),cq(8),cpl(8),sd2(#MI,8),
     -  y(10),polyl(10,10),ag(10),poly(10),imf(1),iml(1),ifg(1),
     -  istar(1),xp(10),yp(10),nskp(8),nblk(8),lengr(8),ptiexp0(3),
     -  ptiexpr(3),cplparray(50)
      character*8 inam
      character*80 ident
      common /title/ nlident,ident(2)
      data inam/'TI integ'/,nskp/8*0/
      data ifg/1/,istar/0/,imf/1/
c     Number of quadrature points
      ichkp0=ichkp
      call getint(nquad,1,1,5)
      iquad=ixcpl(nquad)
      if (iquad .eq. 0) then
        if (MYRANK .eq. 0) write (iout,2000) nquad
        call datprt(2)
      else
        call trnsfr(cpl,cpl358(1,iquad),nquad)
        call trnsfr(cq,cq358(1,iquad),nquad)
      end if
      if (MYRANK .eq. 0) write (iout,2001) nquad
      if (reglist .eq. 'DATA') then
c       Just read in the TI integrand
        do iq=1,nquad
          call getreal(y(iq),1,0.0)
          poly(iq)=0.0
        end do
        itrapread=0
      else
        if (reglist .eq. 'REGL') then
          call getint(numrunr,0,1,numrun)
          call getint(incrnumrun,0,1,1)
          do i=1,nquad
            listruns(i)=numrunr+(i-1)*incrnumrun
          end do
        else
          do i=1,nquad
            call getint(listruns(i),1,1,0)
          end do
        end if
        irectx=41
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,1000,err=999)
     -    ncread,nfac,iskipread,itrapread,nendread
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1302) ncread,nfac,iskipread,itrapread,nendread
        if (nfac .eq. 0) nfac=1
        if (iskipread .gt. 0) then
c         Number of blocks to skip at each quadrature points
          irectx=42
          call getnextrec(inpt,iout,irectx,nwwarn)
          read (line,1000,err=999) (nskp(i),i=1,nquad)
          if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -      write (iout,1303) (nskp(i),i=1,nquad)
        end if
        if (ncread .gt. 0) then
          if (ncread .gt. 8) then
            if (MYRANK .eq. 0) write (iout,2008) ncread
            inperr=inperr+1
            return
          end if
c         Descriptor
          irectx=43
          do it=1,2
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1003,err=999) ident(it)
            if (iop(24) .gt. 0) write (iout,1304) ident(it)
          end do
          nlident=2
          if (nfac .gt. 1 .and. MYRANK .eq. 0) write (iout,1016) nfac
        end if
c       Get integrand control functions
        nbmin=#MI
        nbmax=0
        iop24=iop(24)
        do iq=1,nquad
          if (ncread .eq. 0) then
            call getqd(svst,listruns(iq),1,tixsum(1,iq),ticums(1,iq),
     -        tiblks(1,iq),nblk(iq),ncntinr,cplpr,ptiexpr,iopfe)
             if (nblk(iq) .eq. 0) then
                if (MYRANK .eq. 0) write (iout,2009) iq
                inperr=inperr+1
              end if
            if (iq .eq. 1) then
              call trnsfr(ptiexp0,ptiexpr,3)
            else
              pdiff=arrdist(ptiexp0,ptiexpr)
              if (pdiff .gt. 0.0) then
                if (MYRANK .eq. 0) write (iout,2007) iq,ptiexpr,ptiexp0
                inperr=inperr+1
              end if
            end if
            if (nskp(iq) .gt. 0) then
              write (iout,1008) nskp(iq)
              if (nblk(iq)-nskp(iq) .lt. 1) then
                if (MYRANK .eq. 0) write (iout,1009)
                nchng=nchng+1
                nskp(iq)=0
              end if
            end if
            lengr(iq)=ncntinr
            if (iq .eq. 1) then
              nc0=ncntinr
            else if (nc0 .ne. ncntinr) then
              if (MYRANK .eq. 0) write (iout,1019) nc0,ncntinr
              nwarn=nwarn+1
            end if
          else
c           Number of blocks, length of a block, coupling par
            irectx=44
            iopfe=5
            call getnextrec(inpt,iout,irectx,nwwarn)
            read (line,1002,err=999) nblks,ncntinr,cplpr
            nblk(iq)=nblks
            lengr(iq)=ncntinr
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -        write (iout,1305) nblk(iq),ncntinr,cplpr
c           Cumulative averages (ncread/line)
            irectx=45
            if=1
            do while (if .le. nblk(iq))
              il=min0(nblk(iq),if+ncread-1)
              call getnextrec(inpt,iout,irectx,nwwarn)
              read (line,1001,err=999) (ticums(ib,iq),ib=if,il)
              if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -          write (iout,1306) (ticums(ib,iq),ib=if,il)
              if=il+1
            end do
            do ib=1,nblk(iq)
              ticums(ib,iq)=float(ib)*ticums(ib,iq)/float(nfac)
              tixsum(ib,iq)=ib
            end do
          end if
          if (nskp(iq) .gt. 0) then
            call skipblock(tixsum(1,iq),nskp(iq),nblk(iq))
            call skipblock(ticums(1,iq),nskp(iq),nblk(iq))
            if (iopfe .ne. 5) call trnsfr(tiblks(1,iq),
     -        tiblks(nskp(iq)+1,iq),nblk(iq)-nskp(iq))
            nblk(iq)=nblk(iq)-nskp(iq)
          end if
          if (abs(cplpr-cpl(iq)) .gt. 0.001) then
            if (MYRANK .eq. 0) write (iout,2004) iq,cplpr,cpl(iq)
            nwwarn=nwwarn+1
          end  if
        end do
        if (inperr .gt. 0) return
        if (ncread .eq. 0 .and. MYRANK .eq. 0) then
          if (iopfe .eq. 5) then
            if (svst .eq. 'ALL ') write (iout,2011)
            if (svst .eq. 'STSV') write (iout,2012) 'solvent'
            if (svst .eq. 'STST') write (iout,2012) 'solute'
          else
            if (svst .ne. 'ALL ') write (iout,2013)
            nchng=nchng+1
          end if
        end if
        nbmin=nblk(1)
        nbmax=nblk(1)
        lenmin=lengr(1)
        lenmax=lenmin
        do iq=2,nquad
          if (lengr(iq) .gt. lenmax) lenmax=lengr(iq)
          if (lengr(iq) .lt. lenmin) lenmin=lengr(iq)
          if (nbmin .gt. nblk(iq)) nbmin=nblk(iq)
          if (nbmax .lt. nblk(iq)) nbmax=nblk(iq)
        end do
        sd2ib=0.0
        mismatch=0
        ndfac=1
        if (lenmin .ne. lenmax .and. MYRANK .eq. 0) then
          write (iout,1020) lenmin,lenmax,nquad,(lengr(iq),iq=1,nquad)
          write (iout,1021) lenmax
          do iq=1,nquad
            if (mod(lenmax,lengr(iq)) .ne. 0) then
              write (iout,2006)
              mismatch=1
            else
              ndfac=lenmax/lengr(iq)
              nblk(iq)=nblk(iq)/ndfac
              do ib=1,nblk(iq)
                ticums(ib,iq)=ticums(ib*ndfac,iq)
                tixsum(ib,iq)=tixsum(ib*ndfac,iq)
              end do
              if (iopfe .ne. 5) then
                bavg=0.0
                do i=(ib-1)*ndfac+1,ib*ndfac
                  bavg=bavg+tiblks(i,iq)
                end do
                tiblks(ib,iq)=bavg/ndfac
              end if
            end if
          end do
        end if
        ncntinr=lenmax
        iop(24)=iop24
        do iq=1,nquad
          if (iopfe .eq. 5 .or. iop(30) .eq. 0) then
            call blockfromcum(tiblks(1,iq),ticums(1,iq),tixsum(1,iq),
     -        nblk(iq))
            if (nblk(iq) .gt. 1) then
              do ib=2,nblk(iq)
                call btchmn(ib,0,ncntinr,tixsum(1,iq),ticums(1,iq),inam,
     -            iout,1,sd2(ib,iq))
              end do
            end if
            sd2(1,iq)=0.0
          else
            call zeroit(sd2(1,iq),nblk(iq))
          end if
          if (nbmax .gt. nblk(iq)) then
c           Set unused block info to the last used block's value
            do ib=nblk(iq)+1,nbmax
              tiblks(ib,iq)=tiblks(nblk(iq),iq)
              ticums(ib,iq)=ticums(ib-1,iq)+tiblks(ib,iq)*tixsum(1,iq)
              tixsum(ib,iq)=tixsum(ib-1,iq)+tixsum(1,iq)
              sd2(ib,iq)=0.0
            end do
          end if
        end do
        if (iop(24) .gt. 1 .and. MYRANK .eq. 0) then
          write (iout,2005)
          do ib=1,nbmax
            write (iout,2010) ib,(tiblks(ib,iq),iq=1,nquad)
            write (iout,2010) ib,(ticums(ib,iq)/tixsum(ib,iq),
     -        iq=1,nquad)
            write (iout,2010) ib,(sd2(ib,iq),iq=1,nquad)
            write (iout,2010) ib,(tixsum(ib,iq),iq=1,nquad)
            write (iout,*)
          end do
        end if
        if (mismatch .eq. 0 .and. MYRANK .eq. 0) then
          do ib=1,nbmin
            freeblk(ib)=0.0
            freecum(ib)=0.0
            ticumtot(ib)=0.d0
            sdsum(ib)=0.0
            do iq=1,nquad
              freeblk(ib)=freeblk(ib)+cq(iq)*tiblks(ib,iq)
              freecum(ib)=freecum(ib)+cq(iq)*ticums(ib,iq)/tixsum(ib,iq)
              ticumtot(ib)=ticumtot(ib)+cq(iq)*ticums(ib,iq)
              sdsum(ib)=sdsum(ib)+cq(iq)*sd2(ib,iq)**2
            end do
            sdsum(ib)=sqrt(sdsum(ib))
            call btchmn(ib,0,ncntinr,tixsum,ticumtot,inam,iout,1,sd2ib)
            nmcib=ncntinr*ib
            write (iout,2003) ib,nmcib,freecum(ib),sdsum(ib),sd2ib
          end do
        else
          write (iout,1018)
          nwwarn=nwwarn+1
        end if
        fel=0.0
        sd2l=0.0
        do iq=1,nquad
          fel=fel+cq(iq)*ticums(nblk(iq),iq)/tixsum(nblk(iq),iq)
          sd2l=sd2l+cq(iq)*sd2(nblk(iq),iq)**2
        end do
        sd2l=sqrt(sd2l)
        write (iout,2002) fel,sd2l
        if (mismatch .eq. 0 .and. MYRANK .eq. 0)
     -    call btchmn(nbmin,0,ncntinr,tixsum,ticumtot,inam,iout,0,sd2ib)
        do iq=1,nquad
          sdcomp(iq)=ticums(nblk(iq),iq)/tixsum(nblk(iq),iq)
        end do
        if (MYRANK .eq. 0) write (iout,1017)
     -    (sdcomp(iq),sd2(nblk(iq),iq),iq=1,nquad)
c       Calculate cumulative averages, plot TI convergence
        do ib=1,nbmin
          xnmc(ib)=ib*ncntinr
          ufenmc(ib)=freeblk(ib)
          uf2nmc(ib)=freecum(ib)
        end do
        ncntrl=nbmin
        if (MYRANK .eq. 0)
     -    call plot(xnmc,freeblk,freecum,nbmin,0.0,0.0,0.0,0.0,50,2,2,
     -      53,52,
     -      'Free energy block and cumulative averages (kcal/mol) ',
     -      1,0,0)
c       Get best TI integrands
        do iq=1,nquad
          y(iq)=ticums(nblk(iq),iq)/tixsum(nblk(iq),iq)
          poly(iq)=0.0
        end do
      end if
c-----Compute the approximating polynomial of a Gaussian quadrature
c     x: containis the quadrature integrands
c     polyl(i,j): i-th coefficient of the polynomial of order
c     nord such that it is 1 at cpl(j) and 0 at cpl(k),k.ne. j.
c     poly(j): j-th coefficient of the approximating polynomial
c     of order nord
c     ag(j): the integral of polyl( ,j) from xmin to xmax.
      xmin=0.0
      xmax=1.0
      nord=nquad-1
      do i=1,nquad
c       Compute (cpl(i)-cpl(1) (cpl(i)-cpl(2)...
c                (cpl(i)-cpl(i-1)) (cpl(i)-cpl(i+1)..
        rden=1.0
        do j=1,nquad
          if (i .ne. j) rden=rden*(cpl(i)-cpl(j))
        end do
c       Prepare the polynomial product of (cpl-cpl(1)...
c                      (cpl-cpl(i-1)) (cpl-cpl(i+1))..
        do j=1,nquad
          polyl(j,i)=0.0
        end do
        polyl(1,i)=1.0
        do j=1,nquad
          if (i .ne. j) then
c           Multiply with (x-cpl(j))
            j1=j+1
            do k=1,nquad
              kn=nquad-k+1
              polyl(kn,i)=-polyl(kn,i)*cpl(j)
              if (kn .gt. 1) polyl(kn,i)=polyl(kn,i)+polyl(kn-1,i)
            end do
          end if
        end do
c       Normalize the polynomial
        do j=1,nquad
          polyl(j,i)=polyl(j,i)/rden
        end do
c       Integrate the polynomial
        ai=0.0
        do j=1,nquad
          ai=ai+polyl(j,i)/float(j)*(xmax**j-xmin**j)
        end do
        ag(i)=ai
c       Accumulate the total polynomial
        do j=1,nquad
          poly(j)=poly(j)+polyl(j,i)*y(i)
        end do
      end do
c     Plot the integrand on an even grid between 0.0 and 1.0
      nx=50
      xdiv=1.0/float(nx)
      do i=1,nx
        cplparray(i)=xdiv*(i-1)+xdiv/2.0
        tiinteg(i)=pol(poly,nord,cplparray(i))
      end do
      iml(1)=nx
      if (MYRANK .eq. 0)
     -  call plotn(cplparray,tiinteg,#MI,#MI,1,imf,iml,ifg,istar,1,nx,
     -    0.0,0.0,45,1,20,'fitting polynomial  ',iout)
      fxmin=pol(poly,nord,xmin)
      fxmax=pol(poly,nord,xmax)
      write (iout,1010) xmin,fxmin,xmax,fxmax
      write (iout,1011) (ag(i),i=1,nquad)
      write (iout,1012) (poly(i),i=1,nquad)
c-----Compute integral approximations
c     Gaussian integral
      gi=0.0
      do iq=1,nquad
        gi=gi+y(iq)*ag(iq)
      end do
      if (MYRANK .eq. 0) write (iout,1007) gi
      if (itrapread .gt. 0) then
c       Trapesoid rule integration
c       Integrand at the endpoints
        irectx=46
        call getnextrec(inpt,iout,irectx,nwwarn)
        read (line,3001,err=999) idef,ymin,ymax
        if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -    write (iout,1307) idef,ymin,ymax
        if (idef .eq. 0 .and. MYRANK .eq. 0) then
          write (iout,*)  ' In trapezoid integral'
          write (iout,*) ' fit to the endpoints p(0) and p(1) are used'
        end if
        xp(1)=xmin
        yp(1)=fxmin
        if (idef.ne.0) yp(1)=ymin
        do iq=1,nquad
          xp(iq+1)=cpl(iq)
          yp(iq+1)=y(iq)
        end do
        xp(nquad+2)=xmax
        yp(nquad+2)=fxmax
        if (idef.ne.0) yp(nquad+2)=ymax
        ti=0.0
        nquad1=nquad+1
        do iq=1,nquad1
          ti=ti+(yp(iq+1)+yp(iq))/2.0*(xp(iq+1)-xp(iq))
        end do
c       Paraboliod integration
c       Fit parabola over the points cpl(i),cpl(i+1),cpl(i+2) and use it
c       for the interval (cpl(i),cpl(i+1)) to integrate
        pari=0.0
        do i=1,nquad
c         Fit the parabola
          call parab(a,b,c,xp(i),yp(i))
c         Integrate the parabola from xp(i) to xp(i+1)
          pri=a*(xp(i+1)**2+xp(i+1)*xp(i)+xp(i)**2)/3.0+
     -      b*(xp(i+1)+xp(i))/2.0 + c
          pari=pari+pri*(xp(i+1)-xp(i))
        end do
c       Add last interval contribution
        pari=pari+(xp(nquad+2)-xp(nquad+1))*
     -    (a*(xp(nquad+2)**2+xp(nquad+2)*xp(nquad+1)+xp(nquad+1)**2)/3.0
     -    +b*(xp(nquad+2)+xp(nquad+1))/2.0 + c)
        if (MYRANK .eq. 0) write (iout,1013) ti,pari
        do ii=1,nendread
c         Integrate the gaussian polynomial over selected intervals
c         New endpoints
          irectx=47
          call getnextrec(inpt,iout,irectx,nwwarn)
          read (line,1001,err=999) xmin,xmax
          if (iop(24) .gt. 0 .and. MYRANK .eq. 0)
     -      write (iout,1308) xmin,xmax
          ai=0.0
          do iq=1,nquad
            ai=ai+poly(iq)/float(iq)*(xmax**iq-xmin**iq)
          end do
          if (MYRANK .eq. 0) write (iout,1014) xmin,xmax,ai
        end do
      end if
      return
999   call invalidform(iout,irectx)
      return
1000  format(8i5)
1001  format(6e12.6)
3001  format(i5,5f10.0)
1002  format(2i10,f10.0)
1003  format(a80)
1007  format(/,' Gaussian integral=',f12.5)
1008  format(1x,i4,' control function blocks will be skipped')
1009  format('>>>>> OVERRIDE: too many blocks are requested to',
     - ' be skipped - no skipping will be done')
1010  format(' p(',f6.2,')=',f15.5,'  p(',f6.2,')=',f15.5)
1011  format(/,' The quadrature coefficients=',/,(10f10.5))
1012  format(/,' The coefficients of the polynomial=',/,(10e12.5))
1013  format(' Trapesoid rule integral=',f12.5,/,
     -  ' Paraboloid integral=',f12.5)
1014  format(' The integral of the Gaussian polynomial between',
     -  f8.4,' and ',f8.4,' is',f12.5)
1016  format(' The integrands will be divided by ',i4)
1017  format(/,' The final contributions to the free energy=',/,
     - 4(4x,e12.5,' +/- ',e9.2))
1018  format(' ===== STRONG WARNING: could not calculate progressive',
     -  ' error estimates due to irreparable block length mismatch')
1019  format(' ----- WARNING: different control function block',
     -  ' sizes are used:',2i10,' matchup will be unbalanced')
1020  format(' Block length values are mismatched: min=',i8,' max=',i8,
     -  /,6x,'values at the ',i2,' quadrature points:',8i8)
1021  format(6x,'they are going to be adjusted, if possible, to ',i8)
2000  format(' ***** ERROR: program is not prepared for ',i3,
     -  '-point quadrature')
2001  format(' The number of quadrature points=',i4)
2002  format(/,' The free energy with all the data=',e12.5,' 2SD=',
     -  f10.4,' kcal/mol (from quadrature point errors)',/)
2003  format(1x,i3,' Nmc=',i10,' Free energy=',e12.5,' 2SD=',2f10.5,
     -  ' kcal/mol (from sum of SD squares and from free energy)')
2004  format(' ===== STRONG WARNING: the coupling parameter value for',
     -  ' quadrature point ',i2,' was ',f10.5,' instead of ',f10.5)
2005  format(/,' The free-energy integrand block averages:',/,
     -  ' The free-energy integrand cumulative averages:',/,
     -  ' The corresponding standard deviations:',/,
     -  ' The corresponding runlengths:',/)
2006  format(' Can not synchronize the data with ',
     -  'different blocksizes that are not multiple of each other')
2007  format(' ***** ERROR: TI exponent set for quadrature point ',i2,
     -  '(',3f5.2,') is different from the first set (',3f5.2,')')
2008  format(' ***** ERROR: number of integrand per line (',i2,') ',
     -  'exceeds limit (8)')
2009  format(' ***** ERROR: run ',i2,' is too short - it contains no',
     -  ' TI data')
2010  format(1x,i3,8f17.4)
2011  format(' Free energy values will include both solute-solvent and',
     -  ' solute-solute (if any) contributions')
2012  format(' Free energy values will include only the solute-',a,
     -  'contributions')
2013  format(' >>>>> OVERRIDE: for now separting solute and solvent ',
     -  'contributions works only for FREE TICA')
1302  format(' rectype 41:',5i5)
1303  format(' rectype 42:',8i5)
1304  format(' rectype 43:',a80)
1305  format(' rectype 44:',2i10,f10.5)
1306  format(' rectype 45:',5f12.5)
1307  format(' rectype 46:',i5,2f10.5)
1308  format(' rectype 47:',2f10.5)
      end
      subroutine getqd(svst,numrunr,irestore,tix,tisum,tiblk,nblk,
     -  ncntinr,cplpr,ptiexpr,iopfe)
c#    MMC routine 357 lstmod: 07/17/12
c*****Extract the quadrature value control function from checkpt file
      character*4 svst
      real*8 tix,tisum
      dimension tix(#MI),tisum(#MI),tiblk(#MI),ptiexpr(3)
      character*80 file,filenames,filename1
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /io/ inpt,iout,ifiles(10),ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 ident
      common /title/ nlident,ident(2)
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /tdstate/ press,pressv,ba,temp,beta
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      real*8 uwnmc,unmc,vnmc,ufenmc,uf2nmc,rnnmc,virnmc,uvvnmc
      common /cntrl/ uwnmc(#MI),unmc(#MI),vnmc(#MI),
     -  ufenmc(#MI),uf2nmc(#MI),rnnmc(#MI),virnmc(#MI),
     -  uvvnmc(#MI),xnmc(#MI),cvnmc(#MI),ncntrl,ncntrlskip,ncntrllim
      common /option/ iop(200),idebug(200)
      common /oldio/ ifold(10),ifsaved
      if (irestore .eq. 1) then
        call trnsfi(ifold,ifiles,10)
        ifsaved=1
        call fileopen(file,namlenf,filename1,namlen1,26,0,
     -        numrunr,1,2,1,iop(24),iversout,iout,ichkp,0)
        ifiles(1)=ichkp
        call crstr(0)
        call fileclose(ichkp,0,iverbos,iout)
        call trnsfi(ifiles,ifold,10)
        ifsaved=0
        iopfe=iop(30)
        if (iop(30) .ne. 5 .and.
     -      iop(30) .ne. 6 .and. iop(30) .ne. 8) then
          if (iop(30) .ne. 0 .or. kexp .eq. 0) then
            write (iout,1003)
            call datprt(2)
        end if
        end if
      end if
      nblk=ncntrl
      ncntinr=ncntin
      cplpr=cplpar
      call trnsfrd(tix,uwnmc,nblk)
      call zeroit(ptiexpr,3)
      if (iop(30) .eq. 0) then
c       TI run, coupling parameter factored into the temperature
        if (kexp .eq. 1) then
          call trnsfrd(tisum,unmc,nblk)
        else
          do i=1,nblk
            tisum(i)=unmc(i)*cplpar**(kexp-1)*float(kexp)/float(numsolv)
          end do
        end if
      else if (iop(30) .eq. 5) then
c       Creation/annihiliation TI
        if (irestore .eq. 1)
     -    write (iout,1000) filename1(1:namlen1),nmc,cplpar,ptiexp,
     -      (ident(ic),ic=1,nlident)
        if (svst .eq. 'SVST') then
          call trnsfrd(tisum,uf2nmc,nblk)
        else if (svst .eq. 'STST') then
          call darrdiff(tisum,ufenmc,uf2nmc,nblk)
        else
          call trnsfrd(tisum,ufenmc,nblk)
        end if
        call trnsfr(ptiexpr,ptiexp,3)
      else if (iop(30) .eq. 6) then
c       Finite difference integration
        cplparo=uspro0+cplpar*(uspro1-uspro0)
        if (irestore .eq. 1)
     -    write (iout,1004) filename1(1:namlen1),
     -    'half-umbrella sampling',nmc,cplparo,uspro0,uspro1,
     -    (ident(ic),ic=1,nlident)
        do ib=1,nblk
          tisum(ib)=(dlog(ufenmc(ib)/uwnmc(ib))/beta-
     -               dlog(uf2nmc(ib)/uwnmc(ib))/beta-
     -               delest*(uspar0-uspar1))/(uspro1-uspro0)
          if (ib .eq. 1) then
            tiblk(ib)=tisum(ib)
          else
            tiblk(ib)=(dlog((ufenmc(ib)-ufenmc(ib-1))/
     -        (uwnmc(ib)-uwnmc(ib-1)))/beta-
     -         dlog((uf2nmc(ib)-uf2nmc(ib-1))/
     -        (uwnmc(ib)-uwnmc(ib-1)))/beta-
     -        delest*(uspar0-uspar1))/(uspro1-uspro0)
          end if
        end do
      else
        if (irestore .eq. 1)
     -     write (iout,1004) filename1(1:namlen1),
     -    'explicit  middle state',nmc,cplparo,uspro0,uspro1,
     -    (ident(ic),ic=1,nlident)
        do ib=1,nblk
          tisum(ib)=(dlog(ufenmc(ib)/uwnmc(ib))/beta+
     -               dlog(uf2nmc(ib)/uwnmc(ib))/beta+
     -               del0st+del1st)/(uspro1-uspro0)
          if (ib .eq. 1) then
            tiblk(ib)=tisum(ib)
          else
            tiblk(ib)=(dlog((ufenmc(ib)-ufenmc(ib-1))/
     -        (uwnmc(ib)-uwnmc(ib-1)))/beta-
     -        dlog((uf2nmc(ib)-uf2nmc(ib-1))/
     -        (uwnmc(ib)-uwnmc(ib-1)))/beta+
     -        del0st+del1st)/(uspro1-uspro0)
          end if
        end do
      end if
      return
1000  format(' Checkpoint file name: ',a,' Number of MC steps=',i10,
     -  ' Coupling parameter=',f10.5,/,' TI exponents=',f6.2,
     -  ' (1/r**12)',f6.2,' (1/r**6)',f6.2,' (1/r)',/,2(1x,a80,/))
1003  format(' ***** ERROR: checkpoint file is not from',
     -  ' thermodynamic integration run')
1004  format(' Finite difference TI with ',a22,/,
     -  ' Checkpoint file name: ',a,' Number of MC steps=',i10,
     -  ' Middle coupling parameter=',f10.5,
     -  ' Limits=',2f8.3,/,2(1x,a80,/))
      end
      function pol(p,n,x)
c#    MMC routine 358 lstmod: 04/04/91
c*****Computes the substitution value of a polynomial p on order n at x
      dimension p(10)
      pp=0.0
      xp=1.0
      n1=n+1
      do i=1,n1
        pp=pp+p(i)*xp
        xp=xp*x
      end do
      pol=pp
      return
      end
      subroutine parab(a,b,c,x,y)
c#    MMC routine 359 lstmod: 04/04/91
c*****Fits a parabola ax^2+bx+c to the three points in x-y
      dimension x(3),y(3)
      xs1=x(1)*x(1)
      xs2=x(2)*x(2)
      xs3=x(3)*x(3)
      a=((y(1)-y(2))*(x(1)-x(3))-(y(1)-y(3))*(x(1)-x(2)))/
     -  ((xs1-xs2)*(x(1)-x(3))-(xs1-xs3)*
     -  (x(1)-x(2)))
      b=((y(1)-y(3))-a*(xs1-xs3))/(x(1)-x(3))
      c=y(1)-b*x(1)-a*xs1
      return
      end
      subroutine ovrrat(ick,ick1)
c#    MMC routine 360 lstmod: 03/14/96
c*****Performs the overlap ratio free energy calculations
      common /tdstate/ press,pressv,ba,temp,beta
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      dimension gor1(#OR),gor2(#OR),por1(#OR),por2(#OR),fe(#OR),w(#OR)
      real*8 wsum,fesum
      call getord(gor1,por1,grid1,eav1,rlam1,rnmc1,ick)
      call getord(gor2,por2,grid2,eav2,rlam2,rnmc2,ick1)
      write (iout,1005) eav1,eav2
      if (abs(grid1-grid2) .gt. 0.0001) then
        write (iout,1000) grid1,grid2
        call datprt(2)
      end if
      idel=(gor2(1)-gor1(1)+0.0001)/grid1
c     write (iout,1001) grid1,grid2,idel
      imin0=0
      imax0=-1
      wsum=0.d0
      fesum=0.d0
      pmax=0.0
      xmin=10.e+5
      xmax=-10.e+5
      do i=1,#OR
        fe(i)=9999.9
      end do
      nor=#OR-2
      do i1=2,nor
        i2=i1-idel
        if (i2 .ge. 1 .and. i2 .le. #OR) then
          if (por1(i1)+por2(i2) .gt. 0.0002) then
            if (xmin .gt. gor1(i1)) xmin=gor1(i1)
            if (xmax .lt. gor1(i1)) xmax=gor1(i1)
            if (xmin .gt. gor2(i2)) xmin=gor2(i2)
            if (xmax .lt. gor2(i2)) xmax=gor2(i2)
            if (pmax .lt. por1(i1)) pmax=por1(i1)
            if (pmax .lt. por2(i2)) pmax=por2(i2)
            w(i1)=por1(i1)*por2(i2)
            if (w(i1) .gt. 0.0) then
c             Check for crossing
              if ((por1(i1)-por2(i2))*(por1(i1-1)-por2(i1-1))
     -            .gt. 0.0) then
c               Crossing found, calculate the corresponding energy
                rnum1=por1(i1)-por2(i2)
                rnum2=por2(i2-1)-por1(i1-1)
                wl1=rnum1/(rnum1+rnum2)
                wl2=rnum2/(rnum1+rnum2)
                ecross=gor1(i1-1)*wl1+gor1(i1)*wl2
                write (iout,1006) gor1(i1-1),gor1(i1),ecross
              end if
c             Overlap found
              if (imin0 .eq. 0) imin0=i1
              imax0=i1
              fe(i1)=+gor1(i1)-(alog(por1(i1))-alog(por2(i2)))/beta
              wsum=wsum+w(i1)
              fesum=fesum+fe(i1)*w(i1)
            end if
          end if
        end if
      end do
      if (imax0 .lt. imin0) then
        write (iout,1004)
      else
        write (iout,1002)
     -    (gor1(i),por1(i),por2(i-idel),fe(i),w(i),i=imin0,imax0)
        f=fesum/wsum
        write (iout,1003) f
      end if
c     Plot the two probability distributions
      x0=xmax-7.50
      xdiv=1.0
      y0=0.0
      ydiv=0.05
      call round(f,0)
      f0=f-3.0
      fdiv=1.0
      nor=#OR-2
      call round(x0,0)
c     call round(xdiv,1)
c     call round(y0,3)
      gor1(nor+1)=x0
      gor1(nor+2)=xdiv
      gor2(nor+1)=x0
      gor2(nor+2)=xdiv
      por1(nor+1)=y0
      por1(nor+2)=ydiv
      por2(nor+1)=y0
      por2(nor+2)=ydiv
c     Eliminate 'empty' part of fe
      n=0
      do i=1,nor
        if (fe(i) .ne. 9999.9) then
          n=n+1
          fe(n)=fe(i)
          gor1(n)=gor1(i)
        end if
      end do
      gor1(n+1)=x0
      gor1(n+2)=xdiv
      fe(n+1)=f0
      fe(n+2)=fdiv
      return
1000  format(' ***** ERROR: the two gridsizes are different')
c1001  format(' Gridsizes=',2f10.4,' offset=',i3,/)
1002  format(/,' The free energy differences found:',/,
     - (' de=',e12.5,' p1,p2=',2e12.5,' dfe=',e12.5,' w=',e12.5))
1003  format(/,' The weighted average of free energy estimates=',e12.5)
1004  format(/,' No overlap between the two distributions')
1005  format(/,' Energy difference averages=',2e15.5)
1006  format(' Distribution crossing between',f10.4,' and',f10.4,
     -  ' at',f10.4,' kcal/mol')
      end
      subroutine getord(gor,por,grid,eav,rlam,rnmci,iunit)
c#    MMC routine 361 lstmod: 02/12/92
c*****Obtains data from the checkpoint file for overlap ratio calc
      dimension gor(#OR),por(#OR)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 ident
      common /title/ nlident,ident(2)
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /ovlrat/ gdvork,gmor0k,gmor1k,norde0(#OR),norde1(#OR)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      ichkp=iunit
      call crstr(0)
      if (iunit .eq. 10) isys=0
      if (iunit .eq. 11) isys=1
      rnmci=nmc/1000
      rlam=uspro0*(1.0-cplpar) + uspro1*cplpar
      write (iout,1100) isys,nmc,uspro0,uspro1,rlam,
     -  (ident(ic),ic=1,nlident)
      grid=gdvork
      eav=0.0
      if (isys .eq. 0) then
c       System 0
c       gmor1k=gmor1k+2.0*del1st
        nsum=0
        do i=1,#OR
          if (norde1(i) .eq. 1) norde1(i)=0
          nsum=nsum+norde1(i)
        end do
        pmax=0.0
        do i=1,#OR
          por(i)=float(norde1(i))/float(nsum)
          gor(i)=gmor1k+(i-1)*gdvork+gdvork/2.0
          eav=eav+gor(i)*por(i)
        end do
      else
c     System 1
        nsum=0
c       gmor0k=gmor0k+2.0*del0st
        do i=1,#OR
          nsum=nsum+norde0(i)
        end do
        pmax=0.0
        do i=1,#OR
          por(i)=float(norde0(i))/float(nsum)
          gor(i)=gmor0k+(i-1)*gdvork+gdvork/2.0
          eav=eav+gor(i)*por(i)
        end do
      end if
      return
1100  format(' *** Reading system',i2,' Nmc=',i10,
     -  '     coupling parameters at the endpoints=',2f10.4,/,
     -  '     Actual coupling parameter=',f10.4,2(/,1x,a80))
      end
      subroutine round(x,ndec)
c#    MMC routine 362 lstmod: 03/29/91
c*****Round down x to have ndec digits beyond the decimal point
      rfac=10**ndec
      x1=x*rfac
      intg=x1
      x=intg/rfac
      return
      end
      subroutine round2(y0,ny,ymax,ydiv)
c#    MMC routine 363 lstmod: 08/11/12
c*****Round up to 2/20/200 ... (for axis scale)
      y0=0.0
      if (ymax .gt. 0.0) then
        iexpo=alog10(ymax)
        if (ymax .lt. 1.0) iexpo=iexpo-1
        ym=ymax/10.0**iexpo
c       ym should be between 1 & 10
        im=ym/2
        ymm=2*(im+1)
        ydiv=10.0**iexpo*(ymm/float(ny))
      else
        ydiv=1.0
      end if
      return
      end
      subroutine readbitc(mapbit,ic,ibitx,nf,n,nbitmx,nmx,nbits)
c#    MMC routine 364 lstmod: 04/04/97
c*****Extract the ic-th column from mapbit into ibitx
      dimension mapbit(nbitmx,nmx),ibitx(n)
C@NL      logical mapbit,ixlog,mapb,ibiton1
C@NL      equivalence (ix,ixlog)
C@NL      equivalence (mapbi,mapb),(ione,ibiton1)
C@NL      data ione/1/
      nloops=(n-1)/nbits+1
      nloop1=(nf-1)/nbits+1
      do il=nloop1,nloops
c       Set loop limits so that inside loops can run in parallel
        ibdone=(il-1)*nbits
        itodo=ibdone+min0(nbits,n-ibdone)
C@NL        mapb=mapbit(il,ic)
C@NL        ixlog=mapb
C@NA        mapbi=mapbit(il,ic)
        do ib=ibdone+1,itodo
C@NL          ixlog=ixlog .and. ibiton1
C@NL          ibitx(ib)=ix
          ix=mapbi/2
C@NA          ibitx(ib)=mapbi-2*ix
          mapbi=ix
        end do
      end do
      return
      end
      subroutine readbitr(mapbit,ir,ibitx,if,il,nbitmx,nmx,nbits)
c#    MMC routine 365 lstmod: 02/07/96
c*****Extract the ic-th row from mapbit into ibitx
      dimension mapbit(nbitmx,nmx),ibitx(il)
C@NL      logical mapbit,ixlog,mapb,ibiton1
C@NL      equivalence (ix,ixlog),(mapbi,mapb),(ione,ibiton1)
C@NL      data ione/1/
      isw=(ir-1)/nbits+1
      isb1=ir-(isw-1)*nbits-1
      do i=if,il
C@NL        ixlog=mapbit(isw,i)
C@NA        ix=mapbit(isw,i)
        ix=ix/2**isb1
C@NL        ixlog=ixlog .and. ibiton1
C@NL        ibitx(i)=ix
C@NA        ix2=ix/2
C@NA        ibitx(i)=ix-2*ix2
      end do
      return
      end
      subroutine nn34list(nn,in,maxneig,ifs,n,n3,n4,LEVTEST,inperr,iout)
c#    MMC routine 366 lstmod: 09/02/97
c*****Determine a list of 1-3 neighbors and 1-4 neighbors from the connectivity
      dimension nn(n),in(maxneig,n),n3(n),n4(n)
c     First neigbors between 1 & nn(i), 2nd neighbors between nn(i)+1 & nn3(i)
c     and third neighbors between nn3(i)+1 & nn4(i) for atom i.
      much=0
      do i=ifs,n
c       Generate second neighbor list
        n3(i)=nn(i)
        do j1=1,nn(i)
          i1=in(j1,i)
          do j2=1,nn(i1)
            i2=in(j2,i1)
c           Use i2 only if different from i and its neighbors found so far
            if (i2 .ne. i) then
              do j3=1,n3(i)
                if (in(j3,i) .eq. i2) go to 111
              end do
c             Add i2 to the list
              n3(i)=n3(i)+1
              if (n3(i) .gt. maxneig) then
                much=much+1
                if (much .le. 10) write (iout,1000) i,maxneig,'1st+2nd'
              else
                in(n3(i),i)=i2
              end if
            end if
111         continue
          end do
        end do
c       Generate 3rd neighbor list (1-4 interactions)
        n4(i)=n3(i)
        if (n3(i) .gt. nn(i) .and. much .eq. 0) then
          do j1=nn(i)+1,n3(i)
            i1=in(j1,i)
            do j2=1,nn(i1)
              i2=in(j2,i1)
c             Use i2 only if different from i and its neighbors found so far
              if (i2 .ne. i) then
                do j3=1,n4(i)
                  if (in(j3,i) .eq. i2) go to 211
                end do
c               Add i2 to the list
                n4(i)=n4(i)+1
                if (n4(i) .gt. maxneig) then
                  much=much+1
                  if (much .le. 10)
     -               write (iout,1000) i,maxneig,'1st, 2nd+3rd'
                else
                  in(n4(i),i)=i2
                end if
              end if
211           continue
            end do
          end do
        end if
      end do
      if (much .gt. 0) then
        mx=0
        do i=ifs,n
          if (n4(i) .gt. mx) then
            mx=n4(i)
          end if
          if (n4(i) .gt. maxneig) n4(i)=maxneig
        end do
        write (iout,1001) mx
        inperr=inperr+1
      end if
      if (LEVTEST .gt. 0 .or. much .gt. 0) then
        do i=ifs,n
          write (iout,2000) i,nn(i),n3(i),n4(i),(in(j,i),j=1,n4(i))
        end do
      end if
      return
1000  format(' ***** ERROR: Atom ',i5,' has more than ',i3,1x,a,
     -  ' neighbors - recompile with increased nneig array')
1001  format(' Largest neighbor number seen=',i4)
2000  format(' NN34LIST: ',i5,' nn=',i2,' n3=',i2,' n4=',i2,' in=',18i5,
     -  42x,18i5)
      end
      subroutine grouplist(ifa,ila,igmin,incr,igrp,ngrp,ifgr,ilgr,noord,
     -  maxgr,igtyp)
c#    MMC routine 367 lstmod: 12/04/14
c*****Obtain the group limits and number of groups from the group id list
      dimension igrp(ila),ifgr(maxgr),ilgr(maxgr)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
c     Scan solute atoms from ifa to ila; group index of atom ifa-1: incr;
c     Expected group index for atom ifa: igmin;
c     group index found for atom ila: ngrp;
      character*2 igtyp
      character*12 label
c     write (6,*) 'GROUPLIST ifa,ila=',ifa,ila,igmin
      ifail=0
      if (igtyp .eq. 'GR') label='solute atom'
      if (igtyp .eq. 'TR') label='torsion    '
      nmjump=0
      if (ifa .le. ila) then
        ngrp=incr+1
        call checkdim(ifail,iout,inperr,igtyp,ngrp,0,0,0)
        ngrp0=min0(maxgr,ngrp)
        ifgr(ngrp0)=ifa
        nwrn=0
        if (igrp(ifa) .eq. 0) igrp(ifa)=igmin
        do i=ifa+1,ila
          if (igrp(i) .eq. 0) igrp(i)=igrp(i-1)
        end do
        if (igrp(ifa) .ne. igmin) then
          idelgr=igmin-igrp(ifa)
          if (igtyp .eq. 'GR' .and. iop(61) .eq. 0) then
            write (iout,1002) label,ifa,idelgr
            nchng=nchng+1
          end if
          do i=ifa,ila
            igrp(i)=igrp(i)+idelgr
          end do
        end if
        igrpprev=igrp(ifa)
        do i=ifa+1,ila
          if (igrp(i) .ne. igrpprev) then
c           New group
            if (igrp(i) .lt. igrpprev .and. noord .eq. 0) then
              write (iout,1000) label,i,igrp(i),label,igrpprev
              nwwarn=nwwarn+1
              nmjump=nmjump+1
            end if
            ilgr(ngrp0)=i-1
            ngrp=ngrp+1
            call checkdim(ifail,iout,inperr,igtyp,ngrp,0,0,0)
            ngrp0=min0(maxgr,ngrp)
            ifgr(ngrp0)=i
          end if
          igrpprev=igrp(i)
          igrp(i)=ngrp0
        end do
        ilgr(ngrp0)=ila
c       Check for skipping residues
        nch=0
        do ig=incr+1,ngrp0
          if (igrp(ifgr(ig)) .ne. ig) then
            do ia=ifgr(ig),ilgr(ig)
              igrp(ia)=ig
            end do
            nch=nch+1
          end if
        end do
        if (nch .gt. 0) then
          write (iout,1001) label
          nchng=nchng+1
        end if
      else
        ngrp=incr
      end if
      if (nmjump .gt. 0) then
         if ((ila-ifa+1)/nmjump .gt. 0.1) write (iout,1003)
      end if
      return
1000  format(' ===== STRONG WARNING: group number for ',a,i6,
     -  ':',i5,' is less than the group number of the previous ',a,':',
     -  i5)
1001  format(' >>>>> OVERRIDE: ',a,' group numbers have been changed ',
     -  'to ensure that they are consecutive')
1002  format(' >>>>> OVERRIDE: ',a,' group numbers starting at ',i5,
     -  ' have been incremented by ',i4)
1003  format(' The warnings above may be due to incorrect format of ',
     -  ' record tye 14 (solute atom description)')
      end
      subroutine checkpretrans(ifile,iout,inperr,nwarn)
c#    MMC routine 368 lstmod: 01/11/05
c*****Checks the .slt file for pretransformation information
      common /pretrans/ preshift(3),prerot(3,3),ipretrans
      character*80 line
      common /inpline/ line,lineno,icol
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      call unitmat(prerot,3)
      call zeroit(preshift,3)
      irec=0
      do while (irec .lt. 100)
C@DM        if (MYRANK .eq. 0) then
        ireadok=0
        read(ifile,1000,end=999) line
        ireadok=1
C@DM        end if
C@DM        call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(line,80,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
        if (ireadok .eq. 0) go to 999
        irec=irec+1
        icol=1
        do while (icol .lt. 40)
          if (line(icol:icol+3) .eq. 'TRRT' .or.
     -        line(icol:icol+3) .eq. 'RTTR') then
             ic=icol
             if (line(ic:ic) .eq. 'T') ipretrans=1
             if (line(ic:ic) .eq. 'R') ipretrans=2
             icol=icol+6
             if (line(ic+4:ic+4) .eq. 't') then
               do k=1,3
                 call getreal(preshift(k),1,0.0)
               end do
             else
               read(line(ic+5:ic+5),1001,err=888) irow
               do k=1,3
                 call getreal(prerot(irow,k),1,0.0)
               end do
             end if
             icol=41
           else
             icol=icol+1
           end if
        end do
      end do
999   if (MYRANK .eq. 0) rewind ifile
      call checkort(prerot,iout,inperr,nwarn,'pretransformation')
      return
888   write (iout,2000) line(ic+5:ic+5),ic,line
      inperr=inperr+1
      return
1000  format(a)
1001  format(i1)
2000  format(' ***** ERROR: invalid row number:',a1,' ic=',' line:',/,a)
      end
      subroutine unitmat(u,n)
c#    MMC routine 369 lstmod: 01/10/95
c*****Generate a unit matrix
      dimension u(n,n)
      do i=1,n
        do j=1,n
          u(i,j)=0.0
        end do
        u(i,i)=1.0
      end do
      return
      end
      subroutine checkort(ort,iout,inperr,nwarn,label)
c#    MMC routine 370 lstmod: 09/02/04
c*****Check if matrix is orthonormal
      dimension ort(3,3),unit(3,3)
      character*(*) label
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      call unitmat(unit,3)
      rrsum=0.0
      do i=1,3
        do j=1,3
          rr=unit(i,j)
          do k=1,3
            rr=rr-ort(i,k)*ort(j,k)
          end do
          rrsum=rrsum+abs(rr)
        end do
      end do
      if (rrsum .gt. 0.1) then
        if (MYRANK .eq. 0) write (iout,1000) '***** ERROR',label,rrsum
        inperr=inperr+1
      else if (rrsum .gt. 0.1) then
        if (MYRANK .eq. 0) write (iout,1000) '----- WARNING',label,rrsum
        nwarn=nwarn+1
      end if
      return
1000  format(1x,a,': sum of deviations from orthogonality of the ',a,
     -  ' matrix=',f9.5)
      end
      subroutine diheng(torseng,itormov,torsengo,torsen,torsennew,noeng)
c#    MMC routine 371 lstmod: 08/16/17
c*****Calculates the torsion energies for the torsion group itormov
      real*8 torseng,torsengo,torsen,torsennew
      dimension torsen(#TR),torsennew(#TR)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      real*8 evalnum,solnum
      common /loopmove/ evalnum,solnum,looptyp(#TR),loopmem(#TR),
     -  looplist(6,#LT),itparent(#LT),lasttorinit(#LT),
     -  ifsctlist(#LT),ilsctlist(#LT),isctlist(#LT),nsectry(9),
     -  d3tol,dijtol,d24tol,drevtol,dextol,dihpmtol,wloop,divr3,
     -  looptypcnt(9),nloopmtry,nloopctry(2,9),nloopacc,numnosol,
     -  nosoltyps(10,9,2),numrevrej,numrej0,irejtyp,nimptry(9,2),
     -  nimpfound(2,9,2),nsecact(3,9),nearpicked,numnearpicked,
     -  numnearacc,nlooptyp,ntotloop
      common /toreng/ npft(#TR),ifpftd(9,#TR),ilpftd(9,#TR),
     -  torsinc(9,#TR),torcoef(#TA),phase(#TA),period(#TA)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
C@DB      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      real*8 torsengit
      torseng=0.d0
      torsengo=0.d0
      if (noeng .gt. 1) return
      do it=ifdhgrlst(itormov),ildhgrlst(itormov)
        torsengit=0.d0
        do in=1,npft(it)
          ang=torsinc(in,it)+dihang(it)
C@DB          te=0.0
          do ipt=ifpftd(in,it),ilpftd(in,it)
C@DB          te=te+torcoef(ipt)*(1.0+cos(period(ipt)*ang-phase(ipt)))
C@DB          write (6,7888) ipt,torcoef(ipt),period(ipt),phase(ipt)
C@DB7888      format(' ipt=',i3,' torcoef,period,phase=',3e13.5)
            torsengit=torsengit+torcoef(ipt)*(1.0+cos(period(ipt)*ang-
     -        phase(ipt)))
          end do
C@DB          t1=rdtodg*dihang(it)
C@DB          t2=rdtodg*torsinc(in,it)
C@DB          t3=rdtodg*ang
C@DB          write (6,7877) it,in,t1,t2,t3,te
C@DB7877      format(' it,in=',2i3,' tang,inc,ang=',3f10.5,' eng=',e12.5)
        end do
        torsennew(it)=torsengit
        torseng=torseng+torsengit
        torsengo=torsengo+torsen(it)
        if (looptyp(it) .ne. 0) then
          do ntl=1,6
            itl=looplist(ntl,it)
            torsengit=0.d0
            do in=1,npft(itl)
              ang=torsinc(in,itl)+dihang(itl)
              do ipt=ifpftd(in,itl),ilpftd(in,itl)
                torsengit=torsengit+torcoef(ipt)*
     -            (1.0+cos(period(ipt)*ang-phase(ipt)))
              end do
            end do
            torsennew(itl)=torsengit
            torseng=torseng+torsengit
            torsengo=torsengo+torsen(itl)
          end do
        end if
      end do
      return
      end
      subroutine readtors(filename,len,ipft,iopenok,ntordat,maxtordat,
     -  torcoefd,phased,periodd,tnames)
c#    MMC routine 372 lstmod: 12/03/15
c*****Reads in the torsion parameters from the requisite parameter file
      character*80 filename
      dimension torcoefd(maxtordat),phased(maxtordat),periodd(maxtordat)
      character*6 tnames(4,maxtordat)
      common /toreng/ npft(#TR),ifpftd(9,#TR),ilpftd(9,#TR),
     -  torsinc(9,#TR),torcoef(#TA),phase(#TA),period(#TA)
      character*4 resnames
      common /gromostor/ ifres(200),ilres(200),resnames(200)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      character*80 line
      common /inpline/ line,lineno,icol
      character*4 name1
      character*11 name2
      character*80 filenamertp
      dimension grotor0(200),grotorc(200),multgro(200)
      character*7 pfn(10)
      character*2 xx
      data pfn /2*'       ',2*'Amber  ','Charmm ','Gromos ',
     -  'Gromacs',3*'       '/
      iop24=iop(24)
      iop(24)=iop(24)-1
      linenostdin=lineno
      lineno=1
      call findnewunit(iutor,0,iout)
      open(unit=iutor,status='old',file=filename(1:len),
     -  form='FORMATTED',iostat=iopenok)
      if (iopenok .ne. 0) then
        write (iout,1000) filename(1:len)
        inperr=inperr+1
        go to 9999
      else
        write (iout,1001) filename(1:len),pfn(ipft)
        do it=1,maxtordat
          do k=1,4
            tnames(k,it)='      '
          end do
        end do
      end if
      nfail=0
      if (ipft .eq. 3 .or. ipft. eq. 4) then
c       Amber
        call blankout(line,1,80)
        read (iutor,100,end=999) line
        call lastchar(line,ilc,80)
        write (iout,1002) line(1:ilc)
c       Skip until the 3rd blank line
        do i=1,3
          xx='xx'
          do while (xx .ne. '  ')
            read (iutor,101,end=999) xx
            lineno=lineno+1
          end do
        end do
        icol=1
        do while (icol .eq. 1)
          read (iutor,100,end=999) line
          lineno=lineno+1
          call nextchar(line,icol,0,iutor,iout)
          if (icol .eq. 1) then
c           Still torsion line
            ntordat=ntordat+1
            if (ntordat .gt. maxtordat) go to 998
            do k=1,4
              tnames(k,ntordat) (3:6)='    '
              tnames(k,ntordat)(1:2)=line((k-1)*3+1:(k-1)*3+2)
            end do
            icol=12
            if (line(12:16) .eq. '     ') then
              idivf=1
            else
              call getint(idivf,1,1,0)
            end if
            call getreal(torcoefd(ntordat),1,0.0)
            call getreal(phased(ntordat),1,0.0)
            call getreal(periodd(ntordat),1,0.0)
            icol=1
            torcoefd(ntordat)=(torcoefd(ntordat)/idivf)
            phased(ntordat)=phased(ntordat)/rdtodg
          end if
        end do
      else if (ipft .eq. 5 .or. ipft .eq. 8) then
c       Charmm or OPLS/Charmm
        read (iutor,100,end=999) line
        write (iout,1002) line
        do while (line(1:5) .ne. 'DIHED')
          read (iutor,100,end=999) line
          lineno=lineno+1
        end do
c       Torsion angle section found
        read (iutor,100,end=999) line
        lineno=lineno+1
        do while (line(1:3) .ne. 'IMP')
          icol=1
          call nextchar(line,icol,0,iutor,iout)
          if (icol .lt. 81) then
            if (line(icol:icol) .ne. '!') then
c             Non-comment line found
              ntordat=ntordat+1
              if (ntordat .gt. maxtordat) go to 998
              icol=1
              do k=1,4
                tnames(k,ntordat) (1:6)='      '
                call getname(tnames(k,ntordat),len1,1,6)
              end do
              call getreal(torcoefd(ntordat),1,0.0)
              call getint(multi,1,1,0)
              periodd(ntordat)=multi
              call getreal(phased(ntordat),1,0.0)
              icol=1
              nn=0
              if (ntordat .gt. 1) then
                do k=1,4
                  if (tnames(k,ntordat) .ne. tnames(k,ntordat-1))
     -              nn=nn+1
                end do
                if (nn .eq. 0) periodd(ntordat)=-periodd(ntordat)
              end if
              phased(ntordat)=phased(ntordat)/rdtodg
            end if
          end if
          read (iutor,100,end=999) line
          lineno=lineno+1
        end do
      else if (ipft .eq. 6) then
c       Gromos
        if (filename(len-6:len) .ne. 'bon.itp') then
          write (iout,1004)
          inperr=inperr+1
          go to 9999
        end if
c       Skip until '[ dihedraltypes ]'
601     ifc=1
        line(1:1)='*'
        do while (line(ifc:ifc+16) .ne. '[ dihedraltypes ]')
          read (iutor,100,end=600) line
          lineno=lineno+1
        end do
        do while (.true.)
          read (iutor,100,end=600) line
          lineno=lineno+1
          icol=1
          call nextchar(line,icol,0,inpt,iout)
          if (icol .gt. 72) go to 600
          if (line(icol:icol) .ne. ';') then
c           Torsion description found
            call getname(name1,len1,1,4)
            call getname(name2,len2,1,11)
            call getint(idtyp,1,1,0)
            if (idtyp .ne. 1) go to 601
            ntordat=ntordat+1
            if (ntordat .gt. maxtordat) go to 998
            tnames(2,ntordat)='      '
            tnames(3,ntordat)='      '
            tnames(2,ntordat)(1:len1)=name1(1:len1)
            tnames(3,ntordat)(1:len2)=name2(1:len2)
            tnames(1,ntordat)='X     '
            tnames(4,ntordat)='X     '
            call getreal(phased(ntordat) ,1,0.0)
            call getreal(torcoefd(ntordat),1,0.0)
            call getint(multi,1,1,0)
            periodd(ntordat)=multi
            phased(ntordat)=phased(ntordat)/rdtodg
            torcoefd(ntordat)=torcoefd(ntordat)/4.184
          end if
        end do
600     continue
      else if (ipft .eq. 7) then
c       Gromacs
c       File opened is the file defining torsion types
        if (filename(len-6:len) .ne. 'bon.itp') then
          write (iout,1004)
          inperr=inperr+1
          go to 9999
        end if
        ngrotyp=0
        call zeroiti(multgro,0,200)
        do while (.true.)
          read (iutor,100,end=700) line
          lineno=lineno+1
          icol=1
          call nextchar(line,icol,0,inpt,iout)
          if (line(icol:icol+6) .eq. '#define') then
            call nextblank(line,icol,0)
            call nextchar(line,icol,0,inpt,iout)
            if (line(icol:icol+2) .eq. 'gd_') then
              ngrotyp=ngrotyp+1
              icf=icol+3
              call nextblank(line,icol,0)
              ngt=0
              read(line(icf:icol-1),*,err=210) ngt
210           if (ngt .ne. ngrotyp) then
                write (iout,1005) ngrotyp,ngt,line
                nwarn=nwarn+1
              end if
              if (ngt .gt. 200) then
                inperr=inperr+1
                write (iout,1006)
              end if
              call getreal(grotor0(ngt),1,0.0)
              call getreal(grotorc(ngt),1,0.0)
              call getint(multgro(ngt),1,1,0)
              grotor0(ngt)=grotor0(ngt)/rdtodg
              grotorc(ngt)=grotorc(ngt)/4.184
            end if
          end if
        end do
700     close (iutor)
        call returnunit(iutor,iout)
        if (idebug(26) .gt. 0) then
          do it=1,200
            if (multgro(it) .ne. 0) write (iout,2002)
     -        it,grotor0(it)*rdtodg,grotorc(it),multgro(it)
           end do
        end if
c       Now open .rtp file
        filenamertp=filename
        filenamertp(len-6:len-2)='.rtp'
        lenrtp=len-3
        open(unit=iutor,status='old',file=filenamertp(1:lenrtp),
     -    form='FORMATTED',iostat=iopenok)
        if (iopenok .ne. 0) then
          write (iout,1000) filenamertp(1:lenrtp)
          inperr=inperr+1
          go to 9999
        else
          write (iout,1010) filenamertp(1:lenrtp)
        end if
        nres=0
        lineno=1
c       Find header
        name1=';'
        do while (name1(1:1) .ne. '[')
          read (iutor,100,end=300) line
          lineno=lineno+1
          icol=1
          call getname(name1,len1,1,4)
          call getname(name2,len2,1,11)
        end do
        if (name2 .ne. 'bondedtypes') then
          write (iout,1007)
          inperr=inperr+1
          go to 999
        end if
        name1=';'
        do while (name1(1:1) .ne. '[')
          read (iutor,100,end=300) line
          lineno=lineno+1
          icol=1
          call getname(name1,len1,0,4)
        end do
        do while (.true.)
c         Find next residue
          call getname(name2,len2,1,11)
          if (len2 .le. 4) then
c           Name must be a residue name
            nres=nres+1
            if (nres .gt. 200) then
              write (iout,1012)
              inperr=inperr+1
              go to 300
            end if
            resnames(nres)='    '
            resnames(nres)=name2(1:len2)
            ifres(nres)=ntordat+1
            do while (name2(1:9) .ne. 'dihedrals')
              name1=';'
              do while (name1(1:1) .ne. '[')
                read (iutor,100,end=300) line
                lineno=lineno+1
                icol=1
                call getname(name1,len1,0,4)
              end do
              call getname(name2,len2,1,11)
            end do
c           Dihedral list found, read in labels, get dihedral types
            name1=';'
            do while (name1(1:1) .ne. '[')
              read (iutor,100,end=300) line
              lineno=lineno+1
              icol=1
              call getname(name1,len1,0,4)
              if (name1(1:1) .ne. ';' .and. name1(1:1) .ne. '[') then
                icol=1
                ntordat=ntordat+1
                if (ntordat .gt. maxtordat) go to 998
                do k=1,4
                  tnames(k,ntordat)='    '
                  call getname(name1,len1,1,4)
                  if (name1(1:1) .eq. '-') then
c                   Drop leading dash
                    name2(1:len1-1)=name1(2:len1)
                    len1=len1-1
                    name1(1:len1)=name2(1:len2)
                  end if
                  if (len1 .gt. 4) len1=4
                  tnames(k,ntordat)(1:len1)=name1(1:len1)
                end do
                call getname(name2,len2,1,11)
                if (name2(1:3) .eq. 'gd_') then
                  read(name2(4:len2),*,err=980) idtyp
                  if (multgro(idtyp) .eq. 0) then
                    write (iout,1009) idtyp
                    inperr=inperr+1
                  else
                    torcoefd(ntordat)=grotorc(idtyp)
                    phased(ntordat)=grotor0(idtyp)
                    periodd(ntordat)=multgro(idtyp)
                  end if
                else
                  ntordat=ntordat-1
                  write (iout,1011) line
                  nwarn=nwarn+1
                end if
              end if
            end do
            ilres(nres)=ntordat
          else
c           Find next bracketed info
            name1=';'
            do while (name1(1:1) .ne. '[')
              read (iutor,100,end=300) line
              lineno=lineno+1
              icol=1
              call getname(name1,len1,0,4)
            end do
          end if
        end do
300     if (idebug(26) .gt. 0) write (iout,2001)
     -    (it,resnames(it),ifres(it),ilres(it),it=1,nres)
         ilres(nres-1)=ntordat
      else
        write (iout,1003)
        inperr=inperr+1
      end if
      if (idebug(26) .gt. 0) then
        write (iout,2000) (itd,(tnames(k,itd),k=1,4),
     -    torcoefd(itd),periodd(itd),phased(itd),itd=1,ntordat)
      end if
      go to 9999
980   write (iout,1008) lineno,line
      inperr=inperr+1
999   write (iout,1014)
      inperr=inperr+1
      go to 9999
998   write (iout,1013) maxtordat
      inperr=inperr+1
9999  close (iutor)
      call returnunit(iutor,iout)
      lineno=linenostdin
      iop(24)=iop24
      return
100   format(a80)
101   format(a2)
1000  format(' ***** ERROR: problem opening file:',a)
1001  format(' Parameter file ',a,' in ',a,' format has been opened')
1002  format(' Parameter file title: ',a)
1003  format(' ***** ERROR: torsion input for this potential',
     -  ' is not implemented yet')
1004  format(' ***** ERROR: torsion parameter file name given for ',
     -  'Gromacs does not end with bon.itp')
1005  format(' ----- WARNING: Gromacs torsion type list is out of ',
     -  'order i=',i4,' Gromacs type=',i4,' line read:'/,1x,a)
1006  format(' ***** ERROR: Gromacs dihedral types exceed 200 - update',
     -  ' the dimension in common block gromostor')
1007  format(' ***** ERROR: header [ bondtypes ] is missing from ',
     -  'Gromos .rtp file')
1008  format(' ***** ERROR: invalid Gromacs dihedral definition in ',
     -  'line',i5,':',/,a)
1009  format(' ***** ERROR: undefined Gromacs dihedral type :',i5)
1010  format(' Gromacs rtp file ',a,' has been opened')
1011  format(' ----- WARNING: Gromacs torsion type is missing from ',
     -  'the .rtp file, line read=',/,1x,a)
1012  format(' ***** ERROR: number of Gromacs residues in .rtp file ',
     -  'exceeds 200 - redimension subroutine readtors')
1013  format(' ***** ERROR: Maximum number of torsion parameters (',
     -  i6,') is exceeded - redimension the arrays tnames, etc')
1014  format(' ***** ERROR: Parameter file is too short')
2000  format(' READTORS: ',/,(i5,1x,4('|',a4),'=',' cf=',f10.5,
     -  ' per=',f4.1,' ph=',f10.5))
2001  format(' READTORS-Gromacs: ',/,(i5,' res ',a4,' first,last: ',
     -  2i4))
2002  format(' READTORS-Gromacs: torsiontype=',i5,' phase=',f10.5,
     -  ' coef=',f10.6,' multiplicity=',i2)
      end
      subroutine calcmap(rmap,nmap,edgemap,gridmapcent,cslt,qslt,
     -  ianslt,ineig,ifgrslt,ilgrslt,igrcnt,iatdslt,nsltgr,
     -  nsltgr_full,evdwlim,elstatmin,scalemap,gridmap,gridbuffer,iverb,
     -  iout,maxat,maxneig,maxmap)
c#    MMC routine 372/a lstmod: 11/30/20
c*****Read in a potential map
      dimension rmap(#GM,#GM,#GM,maxmap),gridmapcent(3),cslt(3,maxat),
     -  qslt(maxat),ianslt(maxat),ineig(maxneig,maxat),
     -  ifgrslt(nsltgr_full),ilgrslt(nsltgr_full),igrcnt(nsltgr_full),
     -  iatdslt(maxat)
      character*4 hbdonlab,hbacclab
      common /desolv_hbond_const/
     -  maxmaptyp,maxhbtyp,maptyphh,nospecterm,iopdesolv,ihbtypsltslt,
     -  ihbtypsltmap,naromc,iaromc(100),nhbexclude,ityphbexclude(20),
     -  ixdonacc(10,10),nhbdonaccp,nhbdontyp,nhbacctyp,nhbdonacctyp,
     -  iopdesolvself,ihbtypsltsltself,iexptheta,iexpomega,ihbsignslt,
     -  ihbsignmap,a_solv_par(7),v_solv_par(7),qk_par,gaussdist2,
     -  gaussdistlim,rminhb2,rmaxhb2,rmaxhb,cohhb12(100),cohhb10(100),
     -  ecocoef,ecopcoef,qpolarcarbmin,qsalthbdonmin,qsalthbaccmax,
     -  rminhbheavy2(100),hbdonlab(10),hbacclab(10),iatdatnos(10),
     -  max_atdtyp
      common /desolv_hbond_arr/ v_solv_slt(#ST),s_solv_slt(#ST),
     -  iatdtypslt(#ST),ipolarslt(#ST),ihbdonacc(#ST),
     -  iahbheavy(#ST),indexhb(#ST)
      common /mehler_ddd/ eps0_ddd,a_ddd,b_ddd,rlambda_ddd,rk_ddd,
     -  epsmin_ddd,rmin_ddd,rdiv_ddd,dd_ms(301),ngrid_ddd
      character*10 mapname
      common /engmapnames/ mapname(10)
      common /atd_lj_par/ c6(10,10),c12(10,10)
      common /option/ iop(200),idebug(200)
c     1: C 2: Car 3: N 4: O 5: P 6: S 7: H 8: H(O) : LP 10:E.S.
c     Meng variable:  pc   pa   pn   oc   pp   ps   ph   oh  lp
c     data mapfiles /'pc','pa','pn','po','pp','ps','ph','pd',2*'  '/
c     data ianatdtyp /7,4*0,1,3,4,6*0,5,6,84*0/
c      write (iout,9712) nmap,nsltgr,nsltgr_full,maxmap
c9712  format(' CALCMAP nap=',i3,' nsltgr,nsltgr_full=',2i5,' mxmap=',i4,
c     -  ' GM=#GM')
      if (scalemap .ne. 1.0) write (iout,1007) scalemap
      emax=10000.0
c     Constants of the electrostatics
      ep=4.00
      es=20.00
      micro=2
      stern=2.00000
      radd=2.00000
      rho=.75
      rhi=.25
      akp=.00
      aks=.10
      write (iout,1002) ep,es,akp,aks,micro,stern,radd
C     Coefficients of potentials
c     C-C
      c12(1,1)=2516582.4
      c6(1,1)=1228.8
c     C-N
      c12(1,3)=1198066.249
      c6(1,3)=861.634784
c     C-O
      c12(1,4)=820711.722
      c6(1,4)=754.059521
c     C-P
      c12(1,5)=580337.5
      c6(1,5)=244.3
c     C-S
      c12(1,6)=2905899.052
      c6(1,6)=1418.896022
c     C-H
      c12(1,7)=29108.222
      c6(1,7)=79.857949
c     N-N
      c12(3,3)=540675.281
      c6(3,3)=588.245
c     N-O
      c12(3,4)=357365.541
      c6(3,4)=505.677729
c     N-P
      c12(3,5)=281751.6
      c6(3,5)=173.0
c     N-S
      c12(3,6)=1383407.742
      c6(3,6)=994.930149
c     N-H
      c12(3,7)=10581.989
      c6(3,7)=48.932922
c     O-O
      c12(4,4)=230584.301
      c6(4,4)=429.49673
c     O-P
      c12(4,5)=195513.7
      c6(4,5)=152.4
c     O-S
      c12(4,6)=947676.268
      c6(4,6)=870.712934
c     O-H
      c12(4,7)=6035.457
      c6(4,7)=39.075098
c     P-P
      c12(5,5)=6025893.897
      c6(5,5)=2195.613
c     P-S
      c12(5,6)=670135.7
      c6(5,6)=282.2
c     P-H
      c12(5,7)=7392.4
      c6(5,7)=16.7
c     S-S
      c12(6,6)=3355443.2
      c6(6,6)=1638.4
c     S-H
      c12(6,7)=33611.28
      c6(6,7)=92.212017
c     H-H
      c12(7,7)=81.92
      c6(7,7)=2.56
c     Set aromatic carbon constants to carbon values H(O) constants to H values
      do i=1,8
        c6(2,i)=c6(1,i)
        c12(2,i)=c12(1,i)
        c6(8,i)=c6(7,i)
        c12(8,i)=c12(7,i)
      end do
      c6(2,2)=c6(1,1)
      c12(2,2)=c12(1,1)
      c6(1,2)=c6(1,1)
      c12(1,2)=c12(1,1)
c     Fill in redundant symmetric part
      do i=1,8
        do j=1,i-1
          c6(i,j)=c6(j,i)
          c12(i,j)=c12(j,i)
        end do
      end do
      av_solv_par_par=(a_solv_par(2)*v_solv_par(2)+
     -             a_solv_par(2)*v_solv_par(2))
      av_solv_pcr_par=(a_solv_par(1)*v_solv_par(2)+
     -             a_solv_par(2)*v_solv_par(1))
      av_solv_pcr_pcr=(a_solv_par(1)*v_solv_par(1)+
     -             a_solv_par(1)*v_solv_par(1))
C     Initialize potential maps to 0.
      pcr=0.
      do im=1,10
        do  k=1,nmap
          do  j=1,nmap
            do  i=1,nmap
              rmap(i,j,k,im)=0.0
            end do
          end do
        end do
      end do
      if (idebug(152) .eq. 1) then
        write (iout,*) 'DEBUG (1): all maps are set to zero'
        return
      end if
      gridmap=edgemap/nmap
      x0=gridmapcent(1)-edgemap/2.0
      y0=gridmapcent(2)-edgemap/2.0
      z0=gridmapcent(3)-edgemap/2.0
      xmin=x0-gridbuffer
      ymin=y0-gridbuffer
      zmin=z0-gridbuffer
      xmax=x0+edgemap+gridbuffer
      ymax=y0+edgemap+gridbuffer
      zmax=z0+edgemap+gridbuffer
      write (iout,1005) gridmapcent,gridmap,nmap
      if (gridbuffer .gt. 0.0) write (iout,1004) gridbuffer
      nsltused=0
      nsltgrused=0
      do ig=nsltgr+1,nsltgr_full
        iac=igrcnt(ig)
        if (cslt(1,iac) .gt. xmin .and.  cslt(1,iac) .lt. xmax .and.
     -      cslt(2,iac) .gt. ymin .and.  cslt(2,iac) .lt. ymax .and.
     -      cslt(3,iac) .gt. zmin .and.  cslt(3,iac) .lt. zmax) then
          nsltgrused=nsltgrused+1
          do ia=ifgrslt(ig),ilgrslt(ig)
            nsltused=nsltused+1
            do j=1,nmap
              gx=x0+(j-1)*gridmap
              dx=gx-cslt(1,ia)
              rx2=dx**2
              do k=1,nmap
                gy=y0+(k-1)*gridmap
                dy=gy-cslt(2,ia)
                rxy2=rx2+dy**2
                do l=1,nmap
                  gz=z0+(l-1)*gridmap
                  dz=gz-cslt(3,ia)
                  r2=rxy2+dz**2
                  r=sqrt(r2)
C@DD                  if (qslt(ia) .ne. 0.0) then
C@DDc                   Electrostatics: eps(r)=A+B/(1+K*exp(-lamda*B*r))
C@DD                    if (r .lt. 1.32) then
C@DD                      rmap(j,k,l,maxmap)=rmap(j,k,l,maxmap)+
C@DD     -                  332.0*qslt(ia)/(8.0*r)
C@DD                    else
C@DD                      rmap(j,k,l,maxmap)=rmap(j,k,l,maxmap)+
C@DD     -                  332.0*dd_ms_inter(r)*qslt(ia)/r
C@DD                    end if
C@DD                  end if
c                 L-J maps
                  r6=r2**3
                  r12=r6*r6
                  do im=1,7
                    if (iatdslt(ia) .gt. 0) then
                      elj=c12(iatdslt(ia),im)/r12-c6(iatdslt(ia),im)/r6
                      if (elj .gt. 0.0) elj=elj*emax/(elj+emax)
                      rmap(j,k,l,im)=rmap(j,k,l,im)+elj
                      if (im .eq. 4) rmap(j,k,l,8)=rmap(j,k,l,8)+elj
                    end if
                  end do
                  if (ianslt(ia) .eq. 6) then
                    q1=qslt(ia)
                    if (r2. le. 25.0 .and.
     -                  abs(q1) .lt. qpolarcarbmin) then
c                     Non-polar carbon - calculate desolvation terms
                      expr2=exp(-r2/gaussdist2)
                      if (iatdslt(ia) .eq. 1) then
c                       Non-aromatic carbon on the receptor
                        pcr=(av_solv_pcr_pcr+
     -                    qk_par*abs(q1)*v_solv_par(1))*expr2
                        par=(av_solv_pcr_par+
     -                    qk_par*abs(q1)*v_solv_par(2))*expr2
                        rlp=qk_par*v_solv_par(1)*expr2
                      else
c                       Aromatic carbon on the receptor
                        pcr=(av_solv_pcr_par+
     -                    qk_par*abs(q1)*v_solv_par(1))*expr2
                        par=(av_solv_par_par+
     -                    qk_par*abs(q1)*v_solv_par(2))*expr2
                        rlp=qk_par*v_solv_par(2)*expr2
                      end if
                      rmap(j,k,l,1)=rmap(j,k,l,1)+pcr
                      rmap(j,k,l,2)=rmap(j,k,l,2)+par
                      rmap(j,k,l,maxmap-1)=rmap(j,k,l,maxmap-1)+rlp
                    end if
                  else if (ianslt(ia) .eq. 1) then
                    if (r2 .le. 12.25) then
c                     Possible H-bonding terms
                      if (ihbdonacc(ia) .gt. 0) then
                        xx0=cslt(1,ineig(1,ia))
                        yy0=cslt(2,ineig(1,ia))
                        zz0=cslt(3,ineig(1,ia))
                        rxx2=(xx0-gx)**2+(yy0-gy)**2+(zz0-gx)**2
                        rhx2=(xx0-x0)**2+(yy0-y0)**2+(zz0-z0)**2
                        rhx=sqrt(rhx2)
                        cosc=(r2+rhx2-rxx2)/(2*r*rhx)
                        if (cosc .le. 0.0 .and. cosc .ge. 1.0) then
                          r10=r6*r2**2
                          ix4=ixdonacc(ihbdonacc(ia),2)
                          ix8=ixdonacc(ihbdonacc(ia),1)
                          rmap(j,k,l,4)=rmap(j,k,l,4)+
     -                     (cohhb12(ix4)/r12-cohhb10(ix4)/r10)*(-1*cosc)
                          rmap(j,k,l,8)=rmap(j,k,l,8)+
     -                     (cohhb12(ix8)/r12-cohhb10(ix8)/r10)*(-1*cosc)
                        end if
                      end if
                    end if
                  end if
                end do
              end do
            end do
          end do
        end if
      end do
      write (iout,1003) nsltused,nsltgrused
      do im=1,10
        emapmin=1.e+30
        emapmax=-emapmin
        do j=1,nmap
          do k=1,nmap
            do l=1,nmap
              if (rmap(j,k,l,im) .lt. emapmin) then
                jmin=j
                kmin=k
                lmin=l
                emapmin=rmap(j,k,l,im)
              else if (rmap(j,k,l,im) .gt. emapmax) then
                jmax=j
                kmax=k
                lmax=l
                emapmax=rmap(j,k,l,im)
              end if
              rmap(j,k,l,im)=rmap(j,k,l,im)*scalemap
              if (evdwlim .gt. 0.0) then
                if (rmap(j,k,l,im) .gt. evdwlim) rmap(j,k,l,im)=evdwlim
              end if
              if (im .eq. 10) then
                if (elstatmin .lt. 0.0) then
                  if (rmap(j,k,l,im) .lt. elstatmin)
     -              rmap(j,k,l,im)=elstatmin
                end if
              end if
            end do
          end do
        end do
        write (iout,1006) mapname(im),'Lowest energy:  ',
     -    jmin,kmin,lmin,emapmin
        write (iout,1006) mapname(im),'Highest energy: ',
     -    jmax,kmax,lmax,emapmax
        if (iverb .gt. 1) then
          do j=1,nmap,nmap-1
            do k=1,nmap,nmap-1
              do l=1,nmap,nmap-1
                write (iout,1006) mapname(im),' ',j,k,l,rmap(j,k,l,im)
              end do
            end do
          end do
          i=nmap/2
          write (iout,1006) mapname(im),'(center) ',i,i,i,rmap(i,i,i,im)
        end if
      end do
      if (idebug(152) .eq. 2) then
        write (iout,*) 'DEBUG (2): all maps are set to zero'
        write (iout,*) 'DEBUG (2): im,nmap=',im,nmap
        do im=1,10
          do  k=1,nmap
            do  j=1,nmap
              do  i=1,nmap
                rmap(i,j,k,im)=0.0
              end do
            end do
          end do
        end do
      end if
      return
1002  format(' Electrostatic energy map parameters:',/,
     -  ' Interior and solvent dielectric constants=',2f7.2,/,
     -  ' Interior and solvent Debeye kappas=',2f7.2,/,
     -  ' Parameters (micro,stern,radd):',i2,2f10.5)
1003  format(' Number of fixed atoms contributing to the maps=',i6,
     -  ', representing',i4,' residues')
1004  format(' Atoms in a box extended by ',f5.1,' A will contribute ',
     -  'to the energy maps')
1005  format(' Center of the gridmap=',3f8.3,/,' Gridsize=',f8.5,' A',
     -  /,' Number of gridpoints=',i5)
1006  format(1x,a,1x,a,' map(',i3,',',i3,',',i3,')=',e12.5)
1007  format(' Energy map has been multiplied by',f8.4)
      end
      subroutine readmap(filename,lfilename,rmap,nmap,evdwlim,scalemap,
     -  elstatmin,imap,iheader,gridmap,gridmapcent,iverb,inperr,must,
     -  nofile,nwarn,iout)
c#    MMC routine 372/a lstmod: 12/02/29
c*****Read in a potential map
      character*(*) filename
      dimension rmap(#GM,#GM,#GM),gridmapcent(3)
      character*40 title
      nofile=0
      open (90,file=filename(1:lfilename),form='unformatted',
     -  status='old',iostat=iopen)
      if (iopen .gt. 0) then
        if (must .eq. 0) then
          write (iout,1008) filename(1:lfilename)
        else
          write (iout,1000) filename(1:lfilename),'missing'
          inperr=inperr+1
        end if
        nofile=1
        return
      else if (iverb .gt. 0) then
        write (iout,1004) filename(1:lfilename)
      end if
      rewind 90
      if (iheader .eq. 1) then
c       Check sizes first
        read (90,end=998)
        read (90,end=998)
     -    title,nx,ny,nz,ep,es,micro,stern,radd,ho,hi2,akp,aks
        if (2*nx+1 .ne. nmap .or. 2*ny+1 .ne. nmap .or.
     -      2*nz+1 .ne. nmap) then
          write (iout,1001) nx,ny,nz,nmap
          nmap=2*nx+1
          write (iout,1011) nmap
          inperr=inperr+1
          return
        end if
      end if
      rewind 90
      read (90,end=999,err=999)
     -  (((rmap(i,j,k),i=1,nmap),j=1,nmap),k=1,nmap)
      if (iheader .eq. 1) then
c       Read header, check sizes
        read (90,end=998)
     -    title,nx,ny,nz,ep,es,micro,stern,radd,ho,hi2,akp,aks
        write (iout,1002) title,ep,es,akp,aks,ho,hi2,micro,stern,radd
        gridmap=hi2
        icentread=0
        read (90,end=888) gridmapcent
        write (iout,1009) gridmapcent
        icentread=1
888     if (icentread .eq. 0) then
          write (iout,1010)
          call zeroit(gridmapcent,3)
        end if
      end if
      evdwmin=1.e+30
      evdwmax=-evdwmin
      do j=1,nmap
        do k=1,nmap
          do l=1,nmap
            if (rmap(j,k,l) .lt. evdwmin) then
              jmin=j
              kmin=k
              lmin=l
              evdwmin=rmap(j,k,l)
            else if (rmap(j,k,l) .gt. evdwmax) then
              jmax=j
              kmax=k
              lmax=l
              evdwmax=rmap(j,k,l)
            end if
            rmap(j,k,l)=rmap(j,k,l)*scalemap
            if (evdwlim .gt. 0.0) then
              if (rmap(j,k,l) .gt. evdwlim) rmap(j,k,l)=evdwlim
            end if
            if (imap .eq. 10) then
              if (elstatmin .lt. 0.0) then
                if (rmap(j,k,l) .lt. elstatmin)
     -            rmap(j,k,l)=elstatmin
              end if
            end if
          end do
        end do
      end do
      if (scalemap .ne. 1.0)
     -  write (iout,1007) filename(1:lfilename),scalemap
      write (iout,1006) filename(1:lfilename),' Lowest energy:  ',
     -  jmin,kmin,lmin,evdwmin
      write (iout,1006) filename(1:lfilename),' Highest energy: ',
     -  jmax,kmax,lmax,evdwmax
      if (evdwmax .gt. evdwlim) then
        write (iout,1012) evdwlim
        nwarn=nwarn+1
      end if
      if (imap .eq. 10) then
        if (evdwmin .lt. elstatmin) then
          write (iout,1013) elstatmin
          nwarn=nwarn+1
        end if
      end if
      if (iverb .gt. 1) then
        do j=1,nmap,nmap-1
          do k=1,nmap,nmap-1
            do l=1,nmap,nmap-1
              write (iout,1006) ' ',' ',j,k,l,rmap(j,k,l)
            end do
          end do
        end do
        i=nmap/2
        write (iout,1006) filename(1:lfilename),' (center) ',
     -    i,i,i,rmap(i,i,i)
      end if
      close (unit=90)
      return
998   write (iout,1003) filename(1:lfilename)
      write (iout,1002) title,ep,es,akp,aks,ho,hi2,micro,stern,radd
      inperr=inperr+1
      return
999   write (iout,1000) filename(1:lfilename),'was not read properly'
      write (iout,1005) nmap
      inperr=inperr+1
      return
1000  format(' ***** ERROR: energy map file ',a,' is ',a)
1001  format(' ***** ERROR: energy map half sizes (',i4,2(',',i4),
     -  ') are incompatible with the input map size:',i4)
1002  format(' Electrostatic energy map read: ',a,/,
     -  ' Interior and solvent dielectric constants=',2f7.2,/,
     -  ' Interior and solvent Debeye kappas=',2f7.2,/,
     -  ' Grid sizes=',2f5.2,/,
     -  ' Parameters (micro,stern,radd):',i2,2f10.5)
1003  format(' ***** ERROR: energy map parameters in file ',a,
     -  ' are incomplete')
1004  format(' Energy map file ',a,' opened')
1005  format(' Dimension of the map being read=',i5)
1006  format(' File ',a,a,'map(',i3,',',i3,',',i3,')=',e12.5)
1007  format(' Energy map on file ',a,' has been multiplied by',
     -  f8.4)
1008  format(' ----- WARNING: energy map file ',a,' is missing')
1009  format(' Grid center coordinates: ',3f10.5,' A')
1010  format(' ///// NOTE: No grid center coordinates were found in ',
     -  'file ',a,/,' - <0,0,0> is assumed')
1011  format(7x,' The map size is reset to ',i4)
1012  format(' ----- WARNING: maximum energy was truncated to ',e12.5)
1013  format(' ----- WARNING: maximum electrostatic energy was ',
     -  'truncated to ',e12.5)
      end
      subroutine writemap(iuw,rmap,nmap,gridmap,iheader,gridmapcent)
c#    MMC routine 372/b lstmod: 01/27/11
c*****Write a potential map
      dimension rmap(#GM,#GM,#GM),gridmapcent(3)
      character*40 title
      data title /'Electrostatic map calculated with MMC   '/
      data ep /0/,es /0/,micro /0/,stern /0/,radd /0/,ho /0/,
     -  akp /0/,aks/0/
      write (iuw) (((rmap(i,j,k),i=1,nmap),j=1,nmap),k=1,nmap)
      if (iheader .eq. 1) then
        nx=(nmap-1)/2
        ny=(nmap-1)/2
        nz=(nmap-1)/2
        write (iuw)
     -    title,nx,ny,nz,ep,es,micro,stern,radd,ho,gridmap,akp,aks
        write (iuw) gridmapcent
      end if
      close (iuw)
      end
      function nomatchlab(pfl2,pfl3,tn2,tn3)
c#    MMC routine 373 lstmod: 11/08/01
c*****See if tn2-tn3 matches pfl2-pfl3 or X - X
      character*6 pfl2,pfl3,tn2,tn3
      nomatchlab=0
      if (((pfl2 .ne. tn2 .and. tn2 .ne. 'X     ') .or.
     -     (pfl3 .ne. tn3 .and. tn3 .ne. 'X     ')) .and.
     -    ((pfl3 .ne. tn2 .and. tn2 .ne. 'X     ') .or.
     -     (pfl2 .ne. tn3 .and. tn3 .ne. 'X     '))) nomatchlab=1
      return
      end
      subroutine grpsum(beg,iopd,iopt,ifrstd,ilastd,ngmind,ngmaxd,
     -  ifrstt,ilastt,ngmint,ngmaxt,ixstt,isltf,isltl,beggd,beggt,
     -  gsumtot)
c#    MMC routine 374 lstmod: 10/18/97
c*****Calculate sum of binding energies for a group
c     Gsumtot is the complete sum. Change in gsumtot = change in Eintra
      real*8 beg,beggd,beggt,gsumtot,gsum1
      dimension beg(#ST),ifrstd(#MM),ilastd(#MM),ifrstt(#TR),
     -  ilastt(#TR),ixstt(#TA),beggd(#MM),beggt(#TR)
      gsumtot=0.d0
      do ia=isltf,isltl
        gsumtot=gsumtot+beg(ia)
      end do
      ggsumd=0.d0
      if (iopd .gt. 0) then
        do ig=ngmind,ngmaxd
          gsum1=0.d0
          do iaa=ifrstd(ig),ilastd(ig)
            gsum1=gsum1+beg(iaa)
          end do
          beggd(ig)=gsum1
        end do
      end if
      if (iopt .gt. 0) then
        do ig=ngmint,ngmaxt
          gsum1=0.d0
          do iaa=ifrstt(ig),ilastt(ig)
            gsum1=gsum1+beg(ixstt(iaa))
          end do
          beggt(ig)=gsum1
        end do
      end if
      return
      end
      subroutine grpsum2(beg,iopt,ifrstd,ilastd,ngmind,ngmaxd,
     -  ifrstt,ilastt,ngmint,ngmaxt,ixstt,isltf,isltl,beggd,beggt,
     -  gsumtot1,gsumtot2)
c#    MMC routine 375 lstmod: 10/18/97
c*****Calculate sum of binding energies when two groups are moved (swap)
c     Gsumtot is the complete sum. Change in gsumtot = change in Eintra
c     This routine is not to be used for the initial energy calculation
      real*8 beg,beggd,beggt,gsumtot1,gsumtot2,gsum1
      dimension beg(#ST),ifrstd(#MM),ilastd(#MM),ifrstt(#TR),
     -  ilastt(#TR),ixstt(#TA),beggd(#MM),beggt(#TR)
      gsumtot2= -gsumtot1
      do i=isltf,isltl
        gsumtot2=gsumtot2+beg(i)
      end do
      do ig=ngmind,ngmaxd
        gsum1=0.d0
        do iaa=ifrstd(ig),ilastd(ig)
          gsum1=gsum1+beg(iaa)
        end do
        beggd(ig)=gsum1
      end do
      if (iopt .gt. 0) then
        do ig=ngmint,ngmaxt
          gsum1=0.d0
          do iaa=ifrstt(ig),ilastt(ig)
            gsum1=gsum1+beg(ixstt(iaa))
          end do
          beggt(ig)=gsum1
        end do
      end if
      return
      end
      subroutine compcheck2(dvalue1,dvalue2,value1,value2,ityp,devlim,
     -  nfail,nfail0,iout)
      real*8 dvalue1,dvalue2
c#    MMC routine 376 lstmod: 05/09/20
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
c*****Check for deviation limit and issue error msg
c     ityp = 1: tolerance is for relative deviation of real*8
c     ityp = 2: tolerance is for absolute deviation of real*8
c     ityp = 3: tolerance is for absolute deviation of real*8, in dvalue1
c     ityp = 4: tolerance is for relative deviation of real*4
c     ityp = 5: tolerance is for absolute deviation of real*4
c     ityp = 6: tolerance is for absolute deviation of real*4, in value1
      devlimuse=devlim
      valuse=0.0
      nfail0=0
      if (ityp .eq. 1) then
        rdev=deviat(dvalue1,dvalue2)
        adev=dabs(dvalue1-dvalue2)
        valuse=dabs(dvalue1)
      else if (ityp .eq. 2) then
        adev=dabs(dvalue1-dvalue2)
        valuse=dabs(dvalue1)
      else if (ityp .eq. 3) then
        adev=dabs(dvalue1)
        valuse=adev
      else if (ityp .eq. 4) then
        if (abs(value1)+abs(value2) .lt. 1.d-5) then
          rdev=abs(value1-value2)
        else
          rdev=abs(value1-value2)/(abs(value1)+abs(value2))
        end if
        adev=abs(value1-value2)
        valuse=abs(value1)
      else if (ityp .eq. 5) then
        adev=abs(value1-value2)
        valuse=abs(value1)
      else if (ityp .eq. 6) then
        adev=abs(value1)
        valuse=adev
      end if
c     For values less that 1.0 loosen tolerance by a factor of 10
      if (valuse .lt. 1.0) devlimuse=devlim*10.0
      if (mod(ityp,3) .eq. 1) then
c       Relative deviation check
        if (rdev .gt. devlimuse) then
          if (iout .gt. 0) write (iout,1088) rdev,devlimuse,adev,
     -      ' ',MYRANK
          nfail=nfail+1
          nfail0=1
        end if
      else
c       Absolute deviation check
        if (adev .gt. devlimuse) then
          if (iout .gt. 0) write (iout,1099) adev,devlimuse,
     -      ' ',MYRANK
          nfail=nfail+1
          nfail0=1
        end if
      end if
      return
1088  format(' ***** Discrepancy found: relative deviation=',e12.5,
     -  ' tolerance=',e12.5,' absolute deviation=',e12.5,
     -  a,' MYRANK=',i2)
1099  format(' ***** Discrepancy found: deviation=',e12.5,
     -  ' tolerance=',e12.5,a,' MYRANK=',i2)
      end
      subroutine engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolecdo)
c#    MMC routine 377 lstmod: 05/12/12
c*****Calls the energy update routine of iop(21), updates slt eng componts
      real*8 etotn,etoto,estscn,tesi
      dimension tesi(#MO),c(3,#NA),crm(3,#MO)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /trqij/ trixyz(3),trjxyz(3),cplcoef(3),nslttf(2),nslttl(2),
     -  ntorcop
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /ndist/ nis(#MO),ipxis,idistid,rijnis,rijpsis,rphs0is
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /option/ iop(200),idebug(200)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
C@DM      real*8 tesi_inp,tesi_out
C@DM      common /MPI_PERS/ tesi_inp(2),tesi_out(2)
C@DMC@FRc     Dimension reduced from 9 to 6 : virial calculations are dropped
C@DMC@FR      real*8 ftv_inp(6),ftv_out(6)
      tesiis=0.d0
C@FR      do k=1,3
C@FR        virscn(k)=0.d0
C@FR        frci(k)=0.d0
C@FR        trqi(k)=0.d0
C@FR      end do
C@ND      if (isolv .gt. 1 .or. iop(7) .ne. 1) then
C@ND        do is=1,nmolecdo
C@ND          texn(is)=0.0
C@ND          nis(is)=mxcslv
cC@NDC@FR          frcn(1,is)=0.0
cC@NDC@FR          frcn(2,is)=0.0
cC@NDC@FR          frcn(3,is)=0.0
cC@NDC@FR          trqn(1,is)=0.0
cC@NDC@FR          trqn(2,is)=0.0
cC@NDC@FR          trqn(3,is)=0.0
cC@NDC@FR          trqnis(1,is)=0.0
cC@NDC@FR          trqnis(2,is)=0.0
cC@NDC@FR          trqnis(3,is)=0.0
cC@NDC@FR          vrsltn(1,is)=0.0
cC@NDC@FR          vrsltn(2,is)=0.0
cC@NDC@FR          vrsltn(3,is)=0.0
C@ND        end do
C@NDC@FR        call zeroit(vrsltn,nmolecdo*3)
C@NDC@FR        call zeroit(frcn,nmolecdo*3)
C@NDC@FR        call zeroit(trqn,nmolecdo*3)
C@NDC@FR        call zeroit(trqnis,nmolecdo*3)
C@ND      end if
      if (isolv .eq. 1) then
c       Solute moved
        texn(1)=0.0
        estscn=0.d0
        do is=2,nmolec
          x=engslt(is,riijj,rijnis,riijps0,isprox,idistmv,idistid,
     -      c,crm(1,is),crm)
          rijpsn(is)=riijj
          ipxn(is)=isprox
          if (iop(92) .gt. 0) rphs0isn(is)=riijps0
          nis(is)=idistmv
          nslvdsidn(is)=idistid
          rcomisn(is)=rijnis
          if (rijnis .lt. rinscs) estscn=estscn+x
          if (riijj .le. ctslts) then
            tesiis=tesiis+dble(x)
            texn(is)=x
            tsindn(1,is)=xslt12
            tsindn(2,is)=xslt6
            tsindn(3,is)=xslt1
C@FR            do k=1,3
C@FR              frci(k)=frci(k)+frixyz(k)
C@FRC@TS              trqi(k)=trqi(k)+trixyz(k)
C@FR              trqn(k,is)=trjxyz(k)
C@FRC@TS              trqnis(k,is)=trixyz(k)
C@FR              frcn(k,is)=frjxyz(k)
C@FR              virscn(k)=virscn(k)+virc(k)
C@FR              vrsltn(k,is)=virc(k)
C@FR            end do
          else
            tsindn(1,is)=0.0
            tsindn(2,is)=0.0
            tsindn(3,is)=0.0
            texn(is)=0.0
          end if
        end do
      else
c       Solvent moved
        if (iop(119) .eq. 0) then
          if (iop(21) .eq. 0) then
c           Scalar computer version
            call eism1(isolv,nmolecdo,c,crm)
          else if (iop(21) .eq. 1) then
c           32-bit vector computer version
            call eisv1x(isolv,nmolecdo,c,crm)
          else if (iop(21) .eq. 2) then
c           Cray (64-bit computer)  version
            call eisv1y(isolv,nmolecdo,c,crm)
C@DM          else if (iop(21) .eq. 3) then
C@DMc           MPI (parallel) version
C@DM            call mpi_eism1(isolv,c,crm)
          end if
        else
C@DM          do is=1,nmolecdo
C@DM            texn(is)=0.0
C@DM            nis(is)=mxcslv
cC@DMC@FR            frcn(1,is)=0.0
cC@DMC@FR            frcn(2,is)=0.0
cC@DMC@FR            frcn(3,is)=0.0
cC@DMC@FR            trqn(1,is)=0.0
cC@DMC@FR            trqn(2,is)=0.0
cC@DMC@FR            trqn(3,is)=0.0
cC@DMC@FR            trqnis(1,is)=0.0
cC@DMC@FR            trqnis(2,is)=0.0
cC@DMC@FR            trqnis(3,is)=0.0
C@DM          end do
C@DMC@FR        call zeroit(frcn,nmolecdo*3)
C@DMC@FR        call zeroit(trqn,nmolecdo*3)
C@DMC@FR        call zeroit(trqnis,nmolecdo*3)
        end if
C@DM        if (iop(21) .eq. 3) then
C@DMc         Sum over processors the values for tesiisloc,virscn, frci,trqi
C@DMC@DB          write (6,7712) 'P0',isolv,tesiis,tesi(isolv)
C@DM          tesi_inp(1)=tesiis
C@DM          if (MYRANK .ne. icpuslv(isolv)-1) then
C@DM            tesi_inp(2)=0.d0
C@DM          else
C@DM            tesi_inp(2)=tesi(isolv)
C@DM          end if
C@DM          call MPI_Allreduce(tesi_inp,tesi_out,2,
C@DM     -      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DM          tesiis=tesi_out(1)
C@DM          tesi(isolv)=tesi_out(2)
C@DMC@FR          call trnsfrd(ftv_inp,frci,3)
C@DMC@FR          call trnsfrd(ftv_inp(4),trqi,3)
C@DMC@FR          call MPI_Allreduce(ftv_inp,ftv_out,6,
C@DMC@FR     -      MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DMC@FR          call trnsfrd(frci,ftv_out,3)
C@DMC@FR          call trnsfrd(trqi,ftv_out(4),3)
C@DMC@FRc          call trnsfrd(virscn,ftv_out(7),3)
C@DMC@DB          write (6,7712) 'P1',isolv,tesiis,tesi(isolv)
C@DM          if (iostat1 .gt. 0)
C@DM     -      write (ioutdb,*) 'engcha Reduce ERROR code=',iostat1
C@DM        end if
        if (nstta .gt. 0) then
          x=engslt(isolv,riijj,riijj0,rijps0,isprox,idistmv,idistid,
     -      c,crm(1,isolv),crm)
          rijpsis=riijj
          ipxis=isprox
          rphs0is=rijps0
          nis(1)=idistmv
          nslvdsidn(isolv)=idistid
          rijnis=riijj0
          if (riijj .le. ctslts) then
            tesiis=tesiis+dble(x)
            texn(1)=x
            tsindn(1,isolv)=xslt12
            tsindn(2,isolv)=xslt6
            tsindn(3,isolv)=xslt1
C@FR            do k=1,3
C@FRC@TS              trqn(k,1)=trixyz(k)
C@FR              trqnis(k,1)=trjxyz(k)
C@FR              frcn(k,1)=frixyz(k)
C@FR              frci(k)=frci(k)+frjxyz(k)
C@FR              trqi(k)=trqi(k)+trjxyz(k)
C@FR              virscn(k)=virscn(k)+virc(k)
C@FR              vrsltn(k,isolv)=virc(k)
C@FR            end do
          else
            tsindn(1,isolv)=0.
            tsindn(2,isolv)=0.
            tsindn(3,isolv)=0.
          end if
        end if
      end if
C@DM      if (iop(21) .lt. 3) then
        etotn=etoto+(tesiis-tesi(isolv))
C@DB        write (6,7712) 'NP',isolv,tesiis,tesi(isolv)
C@DB7712  format(1x,a,' isolv=',i5,' tesiis=',f12.6,' tesi(isolv)=',f12.6)
C@DM      else
C@DM        etotn=etoto+(tesiis-tesi(isolv))
C@DM      end if
      return
      end
      subroutine engold(iop21,iop119,isolv,texslt,vrcslt,frcslt,trtslt,
     -  trvslt,c,crm)
c#    MMC routine 378 lstmod: 05/12/12
c*****Calls the energy recalculating routine according to iop21
      dimension texslt(#MO),vrcslt(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),c(3,#NA),crm(3,#MO)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 tesiis
      common /slvenergy/ tesiis,texn(#MO),texo(#MO),
     -  e01st(2,#MO),e01stn(2,#MO),e01sto(2,#MO)
      real*8 frci,trqi,frcipo,trqipo
      common /frctrq/ frci(3),trqi(3),frcipo(3),trqipo(3),
     -  frco(3,#MO),frcn(3,#MO),trqo(3,#MO),
     -  trqn(3,#MO),trqnis(3,#MO),trqois(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      if (isolv .eq. 1) then
c       Solute moved - no recalculation at all
C@FR        do k=1,3
C@FR          virsco(k)=0.d0
C@FR          do is=2,nmolec
C@FR            virsco(k)=virsco(k)+vrcslt(k,is)
C@FR          end do
C@FR        end do
        call trnsfi(niso,nslvds,nmolec)
        call trnsfi(nslvdsid,nslvdsidn,nmolec)
        call trnsfr(texo,texslt,nmolec)
C@FR        call trnsfr(frco,frcslt,nmol3)
C@FR        call trnsfr(trqo,trvslt,nmol3)
      else
c       Solvent moved
cC@ND          do i=1,nmolec
cC@ND            texo(i)=0.0
cC@NDC@FR            frco(1,i)=0.0
cC@NDC@FR            frco(2,i)=0.0
cC@NDC@FR            frco(3,i)=0.0
cC@NDC@FR            trqo(1,i)=0.0
cC@NDC@FR            trqo(2,i)=0.0
cC@NDC@FR            trqo(3,i)=0.0
cC@ND          end do
C@ND        call zeroit(texo,nmolec)
C@NDC@FR        call zeroit(frco,nmol3)
C@NDC@FR        call zeroit(trqo,nmol3)
        texo(1)=texslt(isolv)
C@FR        do k=1,3
C@FR          virsco(k)=0.d0
C@FR          frco(k,1)=-frcslt(k,isolv)
C@FR          trqo(k,1)=trtslt(k,isolv)
C@FR        end do
        niso(1)=nslvds(isolv)
C@ND        do is=2,nmolec
C@ND          niso(is)=mxcslv
C@ND        end do
        nslvdsid(isolv)=nslvdsidn(isolv)
        if (iop119 .eq. 0) then
          if (iop21 .eq. 0) then
c           Scalar computer version
            call getegy(isolv,c,crm)
          else if (iop21 .eq. 1) then
c           32-bit vector computer version
            call getevx(isolv,c,crm)
          else if (iop21 .eq. 2) then
c           Cray (64-bit computer) version
            call getevy(isolv,c,crm)
C@DM          else if (iop21 .eq. 3) then
C@DMc           MPI-DM version
C@DM            call mpi_getegy(isolv,c,crm)
          end if
C@FR          do k=1,3
C@FR            virsco(k)=virsco(k)+vrcslt(k,isolv)
C@FR          end do
C@DM        else
cC@DM          do i=1,nmolec
cC@DM            texo(i)=0.0
cC@DMC@FR            frco(1,i)=0.0
cC@DMC@FR            frco(2,i)=0.0
cC@DMC@FR            frco(3,i)=0.0
cC@DMC@FR            trqo(1,i)=0.0
cC@DMC@FR            trqo(2,i)=0.0
cC@DMC@FR            trqo(3,i)=0.0
cC@DM          end do
C@DM        call zeroit(texo,nmolec)
C@DMC@FR        call zeroit(frco,nmol3)
C@DMC@FR        call zeroit(trqo,nmol3)
        end if
      end if
      return
      end
      subroutine eulertorot(r,fi,th,ps)
c#    MMC routine 379 lstmod: 04/05/95
c*****This subroutine prepares the rotation matrix from the 3 Euler angles
      dimension r(3,3)
c     See Eq(4-47) of Goldstein (R=A)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      sfi=sin(fi)
      cfi=cos(fi)
      sth=sin(th)
      cth=cos(th)
      sps=sin(ps)
      cps=cos(ps)
      r(1,1)=cps*cfi-cth*sfi*sps
      r(2,1)=-sps*cfi-cth*sfi*cps
      r(3,1)=sth*sfi
      r(1,2)=cps*sfi+cth*cfi*sps
      r(2,2)=-sps*sfi+cth*cfi*cps
      r(3,2)=-sth*cfi
      r(1,3)=sth*sps
      r(2,3)=sth*cps
      r(3,3)=cth
      return
      end
      subroutine rottoeuler(r,fi,th,ps)
c#    MMC routine 380 lstmod: 04/04/95
c*****This subroutine finds the 3 Euler angles from the rotation matrix
      dimension r(3,3),rr(3,3)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      cth=r(3,3)
      if (abs(r(1,2))+abs(r(1,3))+abs(r(2,3))+abs(r(3,1))+abs(r(3,2))+
     -    abs(r(2,1)) .lt. 1.e-4) then
c       Unit matrix, all Euler angles are zero
        fi=0.0
        th=0.0
        ps=0.0
      else if (abs(1.0-abs(cth)) .gt. 1.e-5) then
        th=acoscheck(cth,iout,'ROTTOEULER')
        sth=sqrt(1.0-cth**2)
        cps=r(2,3)/sth
        ps=acoscheck(cps,iout,'ROTTOEULER')
        cfi=-r(3,2)/sth
        fi=acoscheck(cfi,iout,'ROTTOEULER')
      else
         write (iout,*) 'PSI=0 case not coded. Choose an other Z axis'
      end if
c     Check
      call eulertorot(rr,fi,th,ps)
      dmax=0.0
      do i=1,3
        do j=1,3
          d=abs(r(i,j)-rr(i,j))
          if (d .gt. dmax) dmax=d
        end do
      end do
      write (iout,*) 'The precision of the Euler angle results=',dmax
      return
      end
C@D1      subroutine eijtst(eij,nd,n,is,e,be,ioptst)
C@D1c#    MMC routine 381 lstmod: 04/04/95
C@D1c*****Test the pair energy matrix and binding energies for consistency
C@D1      dimension eij(nd,nd),e(nd),be(nd)
C@D1      real*8 be,csum,rsum
C@D1      print *,'eijtst ioptst=',ioptst
C@D1      if (n .gt. nd) then
C@D1        print *,'ERROR: Nmolec is larger than nd in eijtst:',n,nd
C@D1        call datprt(2)
C@D1      end if
C@D1      if (ioptst .eq. 1) then
C@D1c       Save e into eij
C@D1        do i=1,n
C@D1          eij(i,is)=e(i)
C@D1          eij(is,i)=e(i)
C@D1        end do
C@D1      else if (ioptst .eq. 2) then
C@D1c       Compare e and eij
C@D1        nerr=0
C@D1        do im=1,n
C@D1          if (abs(e(im)-eij(im,is)) .gt. 0.00001) then
C@D1            nerr=nerr+1
C@D1            write (6,1010) im,is,eij(im,is),e(im)
C@D1          end if
C@D1          if (abs(e(im)-eij(is,im)) .gt. 0.00001) then
C@D1            nerr=nerr+1
C@D1            write (6,1011) is,im,eij(is,im),e(im)
C@D1          end if
C@D1        end do
C@D1        print *,'Number of eij,e comparison errors=',nerr
C@D1      else if (ioptst .eq. 3) then
C@D1c       Compare be and eij
C@D1        nerr=0
C@D1        do i=1,n
C@D1          csum=0.d0
C@D1          rsum=0.d0
C@D1          do j=1,n
C@D1            csum=csum+eij(j,i)
C@D1            rsum=rsum+eij(i,j)
C@D1          end do
C@D1          if (dabs(csum-be(i)) .gt. 0.00001) then
C@D1            nerr=nerr+1
C@D1            write (6,1012) i,csum,be(i)
C@D1          end if
C@D1          if (dabs(rsum-be(i)) .gt. 0.00001) then
C@D1            nerr=nerr+1
C@D1            write (6,1013) i,rsum,be(i)
C@D1          end if
C@D1        end do
C@D1        print *,'Number of be,eij comparison errors=',nerr
C@D1      end if
C@D1      if (ioptst .ge. 2) then
C@D1c       Check diagonal
C@D1        nerr=0
C@D1        do im=1,n
C@D1          if (abs(eij(im,im)) .gt. 0.00001) then
C@D1            nerr=nerr+1
C@D1            print *,'ERROR eij diagonal',im,' is nonzero:',eij(im,im)
C@D1          end if
C@D1        end do
C@D1        print *,'Number of diagonal errors=',nerr
C@D1      end if
C@D1      return
C@D11010  format('ERROR: i,is=',2i5,' eij,e=',2e13.5)
C@D11011  format('ERROR: is,i=',2i5,' eij,e=',2e13.5)
C@D11012  format('ERROR: i=',i5,' colsum, be=',2e13.5)
C@D11013  format('ERROR: i=',i5,' rowsum, be=',2e13.5)
C@D1      end
C@D2      subroutine printbit(mapbit,nbitmx,nmx,n,nbits,ibitx)
C@D2c#    MMC routine 382 lstmod: 04/04/95
C@D2c*****Print a bitmap
C@D2      dimension mapbit(nbitmx,nmx),ibitx(n)
C@D2      do ir=1,n
C@D2        call readbitc(mapbit,ir,ibitx,1,n,nbitmx,nmx,nbits)
C@D2        write (6,1000) ir,(ibitx(i),i=1,n)
C@D2      end do
C@D2      return
C@D21000  format(' BITMAP row ',i3,1x,100i1)
C@D2      end
C@D3      subroutine printdistm(crm,iop5,n)
C@D3c#    MMC routine 383 lstmod: 04/04/95
C@D3c*****Print a distance matrix for a set of points
C@D3      dimension crm(3,n),d(3),dij(100)
C@D3      if (n .gt. 100) then
C@D3        print *,'more than 100 molecs in printdistm'
C@D3        call datprt(2)
C@D3      end if
C@D3      do i=1,n
C@D3        do j=1,n
C@D3          call arrdiff(d,crm(1,i),crm(1,j),3)
C@D3          call pbcnd(d(1),d(2),d(3),iop5,iopt0,d2)
C@D3          dij(j)=sqrt(d2)
C@D3        end do
C@D3        write (6,1000) i,(crm(k,i),k=1,3)
C@D3        write (6,1001) i,(dij(j),j=1,n)
C@D3      end do
C@D3      return
C@D31000  format(' CRM i=',i3,(3f10.5))
C@D31001  format(' RIJ i=',i3,(12f8.3))
C@D3      end
      function deviat(do,dn)
c#    MMC routine 384 lstmod: 01/28/09
c*****Calculate relative deviation between do and dn
      real*8 do,dn
      if (dabs(do)+dabs(dn) .lt. 1.d-3) then
        deviat=do-dn
      else
        deviat=dabs(do-dn)/(dabs(do)+dabs(dn))
      end if
      return
      end
      subroutine setuppx(nmolec,newrfs,nockp)
c#    MMC routine 385 lstmod: 12/01/15
c*****Set up proximity analysis
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /h2olp/ om,sm,rmd2
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      character*4 labpr
      character*2 iaprt
      common /grplst/ ixprt(#ST),ilastg(#ST),labpr(2,#ST),
     -  iaprt(#ST)
      common /pxrdfdat/ gpxmx1(#GQ),gpxmn1(#GQ),gpxmx2(#GQ),
     -  gtmx1(#GQ),gtmn1(#GQ),rpxmx1(#GQ),rpxmn1(#GQ),
     -  rpxmx2(#GQ),rtmx1(#GQ),rtmn1(#GQ),gtmx2(#GQ),
     -  rtmx2(#GQ),volfs(#GQ),vol2fs(#GQ),rnvols(#GQ),
     -  rpxfar(#GQ),rtfar(#GQ),rkfrdf(#GQ),rksrdf(#GQ),
     -  vfrdf(#GQ),vsrdf(#GQ)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      common /frslvr/ fsrad(#AT,11)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension d(3)
      ifailsx=0
      call settol(nstta,nstfa,nmolec,iout)
      if (iop(162) .gt. 0) then
c       Set up proximity analysis-related stuff
        call checkdim(ifailsx,iout,inperr,'SX',nstta,0,0,0)
        if (iop(142)+iop(146)+iop(148) .gt. 0) then
          if (ifailsx .gt. 0) then
            inperr=inperr+1
            nsltpx1=1
            nsltpx2=#SX
            return
          end if
        end if
        if (iop(142) .lt. 2) then
          rripx2=0.0
          mxpxsltgrd=#RG
          mxpxwwgrd=#RG
          rgpxsltmax2=10000.0
          rgpxwwmax2=10000.0
          rpxnear2=1.0
        end if
c       Get stored first shell radii
        if (iop(167) .eq. 0) then
          nwrn=0
          do j=1,nstta
c           Built-in radii
            rfsl(j)=fsrad(iclslt(j),iopslt(j))
            if (rfsl(j) .eq. 0.0) then
              nwrn=nwrn+1
              if (iop(24) .gt. 1 .or. nwrn .le. 25 .and.
     -          MYRANK .eq. 0) write (iout,2000) j
              if (ianslt(j) .eq. 1 .and. sigmah .ne. 0.0) then
                rfsl(j)=(sigmah+sigpxa)/2.0
              else
                rfsl(j)=(sigslt(j)+sigpxa)/2.0
              end if
              if (iop(173) .eq. 0 .and. nwrn .le. 25 .and.MYRANK .eq. 0)
     -          write (iout,2001)
            end if
          end do
        else if (iop(167) .eq. 1) then
          do j=1,nstta
c           Sigma-based radii
            if (ianslt(j) .eq. 1 .and. sigmah .ne. 0.0) then
              rfsl(j)=(sigmah+sigpxa)/2.0
            else
              rfsl(j)=(sigslt(j)+sigpxa)/2.0
            end if
          end do
        else
c         RDF-based radii
          do ig=1,nsltpxgr
            ifst=1
            if (ig .gt. 1) ifst=ilastg(ig-1)+1
            do ia=ifst,ilastg(ig)
              rfsl(ixprt(ia))=rpxmn1(ig)
            end do
          end do
        end if
        numdef=0
        do j=1,nstta
          if (rfsl(j) .le. 0.0) then
            rfsl(j)=fsrad(iatnos(iclslt(j),iopslt(j)),10)
            numdef=numdef+1
          end if
          rfsl(j)=rfsl(j)*rfsfac+rfsadd
          rfsl2(j)=rfsl(j)**2
          r2fsl2(j)=(rfsl(j)+sigpxa)**2
        end do
        if (numdef .gt. 0) write (iout,2014) numdef
      end if
c     Default solvent partial molar volume
      rmd2=0.0
      do k=1,3
        rmd2=rmd2+(cslv(k,2)+cslv(k,3)-2.0*cslv(k,1))**2
      end do
      if (iop(26) .eq. 2) then
c       Determine om,sm for "lp" position from input slv geom
        rod2=arrdist(cslv(1,4),cslv(1,1))
        om=sqrt(rod2)
        sm=om/sqrt(rmd2)
      end if
c     rlslt1 contains the solute atoms, relative to the 1st atom.
      call trnsfr(d,cslt,3)
      do ia=1,nstta
        call arrdiff(rlslt1(1,ia),cslt(1,ia),d,3)
      end do
c     rlslv1 contains the solvent atoms, relative to the 1st atom.
      call trnsfr(d,cslv,3)
      do ia=1,nslv
        call arrdiff(rlslv1(1,ia),cslv(1,ia),d,3)
      end do
      if (idebug(130) .gt. 1) then
        call distmatprint(cslv,nslv,iout,'CSLV      ',10)
        call distmatprint(rlslv1,nslv,iout,'RLSLV1    ',10)
      end if
      nsltpx1=nsltpx1+nfadel
      nsltpx2=nsltpx2-nladel
      if (iop(162) .gt. 0) then
        call zeroiti(keeppx,0,nstta)
        if (iop(168) .gt. 1) then
c         Set the atoms to keep
          do ix=1,npxkeep
            do ia=ipxkeep(1,ix),ipxkeep(2,ix)
              keeppx(ia)=1
            end do
          end do
        else
          do ia=1,nstta
            keeppx(ia)=1
          end do
        end if
        if (iop(168) .eq. 1 .or. iop(168) .eq. 3) then
c         Drop the hydrogens
          do ia=1,nstta
             if (ianslt(ia) .eq. 1) keeppx(ia)=0
          end do
        end if
      end if
      if (iop(142)+iop(146)+iop(148)+iop(166)+iop(171)+iop(177)+nranpx
     -    .gt. 0) then
        call rdfgrp(nsltpx1,nsltpx2,nsltpxgr,indxrdf,indxfg,ixfg,nfg,
     -    icorig,keeppx)
        call getgrouplabels(nsltpxgr,nsltpx1,nsltpx2,iatnam,ianslt,
     -    labslt,indxrdf,iout,idebug(44))
c       Find the functional groups for the solute molecule
        nslt0=nstta
        if (nstfa0 .gt. 0) nslt0=nstfa0
        if (iop(25) .eq. 0) then
          call findfg(1,nslt0,ianslt,indxfg,itypfg,nfg,iout,
     -      nwarn,nneiga,nneigh,ineig,#NL)
          call sortfg(nfg,1,ifgstr,indxfg,ifgaix,nfgmem,ifgtyp,itypfg,
     -      ixfg,nslt0,iout,inperr)
          write (iout,2009) nfg
        end if
        if (iop(164) .eq. 1 .and. newrfs .eq. 1) then
c         Check if all RGF's are computed
          if (nsltpxgr .ne. nsltpx2-nsltpx1+1) then
             if (MYRANK .eq. 0) write (iout,2021)
            nwwarn=nwwarn+1
          end if
        end if
      else if (ifailsx .gt. 0) then
c       Program is not dimensioned for proximity distribution calc.
        nsltpxgr=1
        nsltpx1=1
        nsltpx2=1
        if (MYRANK .eq. 0) write (iout,2013) 'SX'
        nwarn=nwarn+1
      end if
      if (iop(94) .eq. 3) then
        if (MYRANK .eq. 0) write (iout,2015)
        nwwarn=nwwarn+1
      end if
      if (iop(163) .gt. 0 .and. iop(146)+iop(159) .eq. 0) then
        if (MYRANK .eq. 0) write (iout,2012)
        nwarn=nwarn+1
      end if
      if (nockp .eq. 0) call csavepx(ichkpx,0,iskipfail,6)
      return
2000  format(' ----- WARNING: built-in first shell radius for ',
     -  ' atom',i6,' is zero L-J sigma/2 will be used instead')
2001  format(' The key RMOD can be used to define built in first shell',
     -  ' radii')
2009  format(' Number of functional groups found=',i4)
2012  format(' ----- WARNING: Proximity information file will not ',
     -  'have the solute-solvent energy - use the PXBE key if ',
     -  'you need it')
2013  format(' ----- WARNING: Proximity distributons counters have ',
     -  'been al reset to 1 - increase #',a2,' to avoid it')
2014  format(' ----- WARNING: default (atom-based) first shell radius',
     -  ' was used for ',i5,' atoms')
2015  format(' ===== STRONG WARNING: last good checkpointfile saving ',
     -  'is not implemented for proximity analysis')
2021  format(' ===== STRONG WARNING: keeping the volume elements after',
     -  ' changing first shell radii is risky when RDFs are averaged')
      end
      subroutine initgenvol(ifrsdim,nsymdim,nsltpxgr,nsltpx1,nsltpx2,
     -  keep,newrfs)
c#    MMC routine 386 lstmod: 06/12/98
c*****Set up volume element calculation for proximity analysis
      common /option/ iop(200),idebug(200)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      if (keep .eq. 0) then
c       Initialize volume element accumulators
c       nrans: number of random points generated alltogether
c       nrnslt(1,i): accumulator for i-th volume element estimates.
        nrans=0
        do is=1,nsltpxgr
          do i=1,#RG
            nrnslt(i,is)=0
          end do
        end do
        do is=nsltpx1,nsltpx2
          nrnfs(is)=0
          nrn2fs(is)=0
        end do
        ndimgen=nsymdim
        kdel=ifrsdim-1
        if (3-kdel .lt. ndimgen) ndimgen=3-kdel
        ndim2p=2**ndimgen
        do k=1,3
          ntwop(k)=2**(k-1)
        end do
      else if (newrfs .eq. 1) then
c       Adjust first shell sums
        do is=nsltpx1,nsltpx2
          nrnfs(is)=0
          nlimfs=sqrt(rfsl2(is)+rripx2)+1
          n2limfs=sqrt(r2fsl2(is)+rripx2)+1
          do i=1,nlimfs
            nrnfs(is)=nrnfs(is)+nrnslt(i,is)
          end do
          nrn2fs(is)=nrnfs(is)
          do i=nlimfs+1,n2limfs
            nrn2fs(is)=nrn2fs(is)+nrnslt(i,is)
          end do
        end do
        newrfs=0
      end if
      return
      end
      subroutine genvol(nransn,nransw,ifwr,ilwr,maxpoints,rproxmax,
     -  iwrpx,c,crm)
c#    MMC routine 387 lstmod: 01/08/09
      dimension c(3,#NA),crm(3,#MO)
c*****Compute the uniform distribution volume elements
c     newold=1: start from fresh, newold=2: add more points
      real*8 dpmx,dpsqmx
      common /compid/ dpmx,dpsqmx,realmx,rlsqmx,rlsqmxi,rllnmx,dblnmx,
     -  edifmx,expmax,isize,lvec,lvc3
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /option/ iop(200),idebug(200)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /pbccns/ dex(5),dey(5),dez(5),chexdx(2),chexy(2),dexhex(5),
     -  et1,et2,et3,et4,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3,iaq
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      common /rangen/ xyzlim(3),xyzlm2(3),ixpxo
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  abx(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /nmbrsc/ sq2,sq3,sq5,sq3p2,threp2,sq2p3
      common /worksp/ idone(#NA),l2(#UV),l3(#UV),l4(#UV)
      dimension rno(3,128),kk(3,8),rk(3),cxyzlim(3)
      data r2max /0.0/
      if (nransn .eq. 0) return
      if (nrans+nransn .lt. 0) then
        write (iout,1003) nrans
        nwarn=nwarn+1
        nransn=0
        return
      end if
      if (iwrpx .gt. 0) then
        do i=ifwr,ilwr
          idone(i)=0
        end do
        r2max=rproxmax**2
      end if
      if (iop(5) .le. 5) then
        faciop5=xyzlm2(1)*xyzlm2(2)*xyzlm2(3)/vol
      else if (iop(5) .le. 7) then
        faciop5=1.9
      else
        faciop5=1.0
      end if
      nranlp=float((nransn-1)/lvec+1)*faciop5
      nrej=0
      if (iop(5) .eq. 5 .or. iop(5) .eq. 6) then
        call trnsfr(cxyzlim,xyzlim,3)
      else
        call arrdiff(cxyzlim,xyzlim,crm,3)
      end if
      do id=1,ndim2p
        do k=1,3
          kk(k,id)=1
        end do
        do jd=1,ndimgen
          kk(jd+kdel,id)=1-2*mod((id-1)/ntwop(jd),2)
        end do
      end do
      if (iop(5) .eq. 0) call zeroiti(indexx,0,lvec)
      do irl=1,nranlp
        call randpx(lvc3,rno)
        do ir=1,lvec
           crmgs(1,ir)=-cxyzlim(1)+xyzlm2(1)*rno(1,ir)
           crmgs(2,ir)=-cxyzlim(2)+xyzlm2(2)*rno(2,ir)
           crmgs(3,ir)=-cxyzlim(3)+xyzlm2(3)*rno(3,ir)
        end do
        if (iop(5) .eq. 1) then
c         FCC
          do i=1,lvec
            indexx(i)=1
            abx(i)=abs(crmgs(1,i))
            aby(i)=abs(crmgs(2,i))
            abz(i)=abs(crmgs(3,i))
            cv1(i)=amin1(abx(i),aby(i),abz(i))
            riijjv(i)=crmgs(1,i)**2+crmgs(2,i)**2+crmgs(3,i)**2
          end do
          do i=1,lvec
            if (riijjv(i) .gt. rinscs) then
              iopt=1
              if (cv1(i) .eq. abx(i))
     -          call clfn(crmgs(2,i),crmgs(3,i),edge2,0,16,18,iopt)
              if (cv1(i) .eq. aby(i))
     -          call clfn(crmgs(1,i),crmgs(3,i),edge2,4,14,18,iopt)
              if (cv1(i) .eq. abz(i))
     -          call clfn(crmgs(1,i),crmgs(2,i),edge2,8,14,16,iopt)
              indexx(i)=iopt
            end if
          end do
        else if (iop(5) .eq. 2) then
c         HCP
          do i=1,lvec
            dsx=crmgs(1,i)**2
            dsz=crmgs(3,i)**2
            sum=dsx+crmgs(2,i)**2+dsz
            iopt=1
            if (sum .gt. rinscs) then
              dax=abs(crmgs(1,i))
              if (dax .gt. edgex2) then
c               cell 2,3,4,9, or 12
                iopt=2
c               write (iout,*) 'cell 2,3,4,9, or 12'
              else
c               cell 1,3,4, 9 or 11
                dc2=crmgs(2,i)
                dax2=(dax-edgex2)**2
                if (dc2 .gt. 0.0) then
c                 Only the (+++) quadrant is to be consdered
c                 cell 1, 9 or 3
                  dax=abs(crmgs(1,i))
                  daz=abs(crmgs(3,i))
c                 Distances from hexagonal plane neighbours
                  day2=(dc2-edgsq3p2)**2
                  if (dax2+day2+dsz .lt. sum) then
c                   cell 3
                    iopt=2
c                   write (iout,*) 'cell 3 +'
                  else
                    daz1=(daz-edgsq2p3)**2
                    if (dsx+(dc2-edgpsq3)**2+daz1 .lt. sum) then
c                     cell 8
                      iopt=2
c                     write (iout,*) 'cell 8 +'
                    else
c                     Distances from face-touching upper neighbours
                      dax1=(dax-edgexa)**2
                      day4=(dc2+edgp2sq3)**2
                      if (dax2+day4+daz1 .lt. sum) then
c                       cell 9
                        iopt=2
c                       write (iout,*) 'cell 9 +'
                      end if
                    end if
                  end if
                else
c                 Only the (+-+) quadrant is to be consdered
c                 Distances from vertex-touching upper neighbours
c                 cell 1,4,9, or 11
                  daz=abs(crmgs(3,i))
                  day4=(dc2+edgp2sq3)**2
                  daz1=(daz-edgsq2p3)**2
                  if (dax2+day4+daz1 .lt. sum) then
c                   cell 9
                    iopt=2
c                   write (iout,*) 'cell 9 -'
                  else
c                   cell 1,4, or 11
                    day6=(dc2+edgsq3p2)**2
                    if (dax2+day6+dsz .lt. sum) then
c                     cell 4
c                     write (iout,*) 'cell 4 -'
                      iopt=2
                    else if (dsx+(dc2+edg2psq3)**2+daz1 .lt. sum) then
c                     cell 11
                      iopt=2
c                     write (iout,*) 'cell 11 -'
                    end if
                  end if
                end if
              end if
            end if
            indexx(i)=iopt
c           cx=crmgs(1,i)
c           cy=crmgs(2,i)
c           cz=crmgs(3,i)
c           call pbcnd(cx,cy,cz,7,ioptcheck,r2)
c           write (iout,8711) ioptcheck,(crmgs(k,i),k=1,3)
c8711        format(' PBCND ioptcheck=',i2,' crmgs=',3f10.5)
c           if (iopt .eq. 1 .and. ioptcheck .gt. 1 .or.
c    -          iopt .gt. 1 .and. ioptcheck .eq. 1)
c    -        write (iout,8722) 'HCP',(crmgs(k,i),k=1,3),ioptcheck,iopt
c8722  format(1x,a,' ERROR cxyz=',3f10.5,' ioptcheck,iopt=',2i4,a,
c    -  'dist2=',f10.4,' dist2_ck=',f10.4)
          end do
        else if (iop(5) .eq. 3) then
c         TOCT
          do i=1,lvec
            sum=crmgs(1,i)**2+crmgs(2,i)**2+crmgs(3,i)**2
            iopt=1
            if (sum .gt. rinscs) then
              ad1=abs(crmgs(1,i))
              ad2=abs(crmgs(2,i))
              ad3=abs(crmgs(3,i))
              dsum=ad1+ad2+ad3
              dmax=amax1(ad1,ad2,ad3)
              d1=-dmax*et1+et2
              d2=-dsum*et3+et4
              dminn=amin1(d1,d2)
              if (dminn .lt. 0.0) then
                sum=sum+dminn
                iopt=2
              end if
            end if
            indexx(i)=iopt
c           cx=crmgs(1,i)
c           cy=crmgs(2,i)
c           cz=crmgs(3,i)
c           call pbcnd(cx,cy,cz,7,ioptcheck,r2)
c           if (iopt .eq. 1 .and. ioptcheck .gt. 1 .or.
c    -          iopt .gt. 1 .and. ioptcheck .eq. 1)
c    -        write (iout,8722) 'TOCT',(crmgs(k,i),k=1,3),
c    -          ioptcheck,iopt,' ',sum,r2
          end do
        else if (iop(5) .eq. 4) then
c         HEXG
          do i=1,lvec
c           Work in the (+,+) quarter only
            x=abs(crmgs(2,i))
            y=abs(crmgs(3,i))
c           i2or3 : 1 if y>x/sqrt(3) (->cell 1 or 2); 0 otherwise(->cell 1 or 3)
            d2or3=y+x/sq3-edgea
            ic2or3=sign(1.0,d2or3)
            indexx(i)=2+ic2or3
          end do
        else if (iop(5) .eq. 5 .or. iop(5) .eq. 6) then
          do i=1,lvec
            riijjv(i)=crmgs(1,i)**2+crmgs(2,i)**2+crmgs(3,i)**2
            indexx(i)=1.0+sign(1.0,(riijjv(i)-rinscs))
          end do
        end if
        do ir=1,lvec
c         For rectangular cell, all points are used
          if (indexx(ir) .le. 1) then
            do id=1,ndim2p
              do k=1,3
                rk(k)=crmgs(k,ir)*kk(k,id)
              end do
              rsmin=1.e+5
              if (iop(2) .eq. 0) then
                if (iop(43) .eq. 0) then
                  do is=nsltpx1,nsltpx2
                    riijjv(is)=(rk(1)-c(1,is))**2+(rk(2)-
     -                c(2,is))**2+(rk(3)-c(3,is))**2
                  end do
                else
c                 Group-based cutoff, use pbc routines for dis calc
                  do is=nsltpx1,nsltpx2
                    zv(1,is)=rk(1)-c(1,is)
                    zv(2,is)=rk(2)-c(2,is)
                    zv(3,is)=rk(3)-c(3,is)
                  end do
                  call pbcvec(iop(5),nsltpx1,nsltpx2)
                end if
              else
c               Periodic solute
                do is=nsltpx1,nsltpx2
                  dx0=rk(1)-c(1,is)
                  riijjv(is)=amin1(dx0*dx0,(dx0-edgexa)**2,
     -              (dx0+edgexa)**2)+(rk(2)-c(2,is))**2+
     -              (rk(3)-c(3,is))**2
                end do
              end if
              if (iop(141) .gt. 0) then
                do is=nsltpx1,nsltpx2
                  riijjv(is)=riijjv(is)-rppxrad2(is)
                end do
              end if
              if (iop(168) .gt. 0) then
c               Drop requested atoms
                do is=nsltpx1,nsltpx2
                  if (keeppx(is) .eq. 0) riijjv(is)=100000.0
                end do
              end if
C@NV              call smin(riijjv,nsltpx1,nsltpx2,rsmin,iprox)
C@VC              call vmin(riijjv,nsltpx1,nsltpx2,rsmin,iprox)
              rsmin=rsmin+rppxrad2(iprox)
              if (rsmin .ge. rgpxsltmax2) then
                irmin=mxpxsltgrd
              else
                irmin=sqrt(rsmin*rripx2)+1
                if (rsmin .le. r2fsl2(iprox)) then
                  nrn2fs(iprox)=nrn2fs(iprox)+1
                  if (rsmin .le. rfsl2(iprox))
     -              nrnfs(iprox)=nrnfs(iprox)+1
                end if
              end if
              nrnslt(irmin,indxrdf(iprox))=
     -          nrnslt(irmin,indxrdf(iprox))+1
              if (iwrpx .gt. 0) then
                if (iprox .ge. ifwr .and. iprox .le. ilwr) then
                  if (idone(iprox) .le. maxpoints) then
                    if (rproxmax .eq. 0.0) r2max=rfsl2(iprox)
                    if (rsmin .le. r2max) then
                      write (1000+iprox,1002)
     -                  iatnam(ianslt(iprox)),rk,(nsttg+iprox)
                      idone(iprox)=idone(iprox)+1
                    end if
                  end if
                end if
              end if
            end do
          else
c           Eliminate points outside the cell
            nrej=nrej+1
          end if
        end do
      end do
      nransw=0
      if (iwrpx .gt. 0) then
        do i=ifwr,ilwr
          nransw=nransw+idone(i)
        end do
      end if
      nransnp=lvec*nranlp-nrej
      nrans=nrans+nransnp
      if (idebug(18) .gt. 0) then
        write (iout,1000) nransnp
        if (iop(5) .gt. 0) write (iout,1001) nrej
        if (idebug(18) .gt. 1) write (iout,1004) xyzlim,xyzlm2,faciop5,
     -    edgexa,edgex2,edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3
      end if
1000  format(i10,' random points actually generated')
1001  format(i10,' points generated outside the cell')
1002  format(a4,1x,3f15.5,i5,'      0.0')
1003  format(' ----- WARNING: No more random points generated to ',
     -  'avoid integer overflow. Current number=',i10)
1004  format(' xyzlim=',3f10.5,' xyzlm2=',3f10.5,' faciop5=',f8.4,/,
     -  '  edgexa,edgex2=',2f10.5,
     -  ' edgsq3p2,edgp2sq3,edgsq2p3,edgpsq3,edg2psq3=',5f10.5)
      return
      end
      subroutine vmin(r,n0,n,rmin,imin)
c#    MMC routine 388 lstmod: 08/07/95
c*****Vectorizable minimum search (written by Mahdavi at PSC)
      dimension r(n)
      rmin=r(n0)
      imin=n0
      n1=n0+1
      do i=n1,n
        rmin=amin1(rmin,r(i))
      end do
c     Now look through the list to find the minimum's location
      do i=n0,n
        if (rmin .eq. r(i)) go to 3
      end do
3     imin=i
      return
      end
      subroutine smin(r,n0,n,rmin,imin)
c#    MMC routine 389 lstmod:08/07/95
c*****Find the minimum and its location in an array (scalar mode)
      dimension r(n)
      imin=n0
      rmin=r(n0)
      n2=n0+1
      do i=n2,n
        if (rmin .gt. r(i)) then
          rmin=r(i)
          imin=i
        end if
      end do
      return
      end
      subroutine crstrpx(iokslave)
c#    MMC routine 390 lstmod: 04/05/08
c*****Restore proximity analysis common blocks
      real*8 d3,d4,d7,d14,d29,d33,d34
C@TS     -  ,d12,d13
      character*10 cmoddater,moddater
      dimension icompoptr(40),iasizer(70)
      character*2 optname,sizesym,c22
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      character*80 filename1
      character*4 c19,c21,c32
      character*20 c20
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /relcd1/ x1(3,#ST),x2(3,#SV)
      common /proxan/ d3(#DG,#GQ),d4(4,#SX),x5(3,#SX),x6(25),
     -  n1(#RG,#GQ),n2(#TG,#GQ),n3(5,#SX),n4(#LG,#GQ),
     -  n5(15,#GQ),n6(#GE,#GQ),n7(#VG,#GQ,#ND),n8(17)
      common /dipole/ x23(12),x24(17,#SX),n20(#SX)
      common /diffuse/ n23(#MD,#GQ),x25(#DC,#GQ),n24(#DC,#GQ),
     -   n25(#MD,#GQ),x26(#DC,#GQ),n26(#DC,#GQ),n27(#MD,#GQ),
     -   x27(#DC,#GQ),n28(#DC,#GQ),x28(9,#DC,#MD,#GQ)
      common /residt/ x36(2),n35,n36(#RC,#GQ,#MD)
      common /btchav/ d7(#MI,11),n9
      common /h2olp/ x8(3)
      common /fcgspec/ n10(7,#ST),n11
      common /fcgnam/ n22(100),c19(2,100),c20(2,100)
      common /grplst/ n12(2,#ST),c21(2,#ST),c22(#ST)
      common /volgen/ n13(#RG,#GQ),n14(2,#ST),n15
      common /twopow/ n16(6)
      common /rppxrad/ x10(#ST),n34(#ST),n37(201)
C@TS      common /sltfrc/ d12(2,3,#ST),d13(2,#TR)
      common /charmm/ d14(6),n17(2,20),n18(3),n21(#NA)
      common /hbbridge/ d29(4),d33(3,#SX),x30(6),n30(#SX),n31(5),
     -  c32(100)
      common /engdec/ d34(47,#DT),n32(4,#DT),n33(9),x35(5)
      if (MYRANK .gt. 0 .and. iokslave .eq. 0) then
        write (iout,*) 'CRSTRPX called from MYRANK=',MYRANK
        return
      end if
      iok=0
      filename1=filenames(6)
      lenfil1=namlens(6)
      rewind ichkpx
      read (ichkpx,end=120,err=111)
     -  x1,x2,d3,d4,x5,x6,d7,x8, x10,
C@TS     -  d12,d13,
     -  d14, c19,c20,c21,c22,x23,x24,x25,x26,x27,x28,d29,x30,
     -  c32,d33,d34,x35,x36
      iok=1
      go to 110
111   write (iout,1001) 'real',filename1(1:lenfil1)
110   read (ichkpx,end=120,err=121)
     -  ncompoptr,icompoptr,nasizer,iasizer,cmoddater,moddater,
     -  n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,
     -  n20,n21,n22,n23,n24,n25,n26,n27,n28, n30,n31,n32,n33,n34,
     -  n35,n36,n37
      iok=iok+1
      go to 120
121   write (iout,1001) 'integer',filename1(1:lenfil1)
      inperr=inperr+1
120   call compoptcheck(2,cmoddater,moddater,ncompoptr,icompoptr,
     -  nasizer,iasizer,filename1,lenfil1)
      if (iok .lt. 2) then
        write (iout,1000)
        call datprt(2)
      end if
      return
1000  format(' ***** ERROR: proximity analysis checkpoint file',
     -  ' is too short')
1001  format(' ***** ERROR: ',a,' record on proximity analysis ',
     -  'checkpoint file ',a,' is incomplete')
      end
      subroutine csavepx(ifile,ibuff,iskipfail,itypf)
c#    MMC routine 391 lstmod: 07/13/04
c*****Save proximity analysis common blocks
      real*8 d3,d4,d7,d14,d29,d33,d34
C@TS     -  ,d12,d13
      character*2 optname,sizesym,c22
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      character*4 c19,c21,c32
      character*20 c20
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /relcd1/ x1(3,#ST),x2(3,#SV)
      common /proxan/ d3(#DG,#GQ),d4(4,#SX),x5(3,#SX),x6(25),
     -  n1(#RG,#GQ),n2(#TG,#GQ),n3(5,#SX),n4(#LG,#GQ),
     -  n5(15,#GQ),n6(#GE,#GQ),n7(#VG,#GQ,#ND),n8(17)
      common /dipole/ x23(12),x24(17,#SX),n20(#SX)
      common /diffuse/ n23(#MD,#GQ),x25(#DC,#GQ),n24(#DC,#GQ),
     -   n25(#MD,#GQ),x26(#DC,#GQ),n26(#DC,#GQ),n27(#MD,#GQ),
     -   x27(#DC,#GQ),n28(#DC,#GQ),x28(9,#DC,#MD,#GQ)
      common /residt/ x36(2),n35,n36(#RC,#GQ,#MD)
      common /btchav/ d7(#MI,11),n9
      common /h2olp/ x8(3)
      common /fcgspec/ n10(7,#ST),n11
      common /fcgnam/ n22(100),c19(2,100),c20(2,100)
      common /grplst/ n12(2,#ST),c21(2,#ST),c22(#ST)
      common /volgen/ n13(#RG,#GQ),n14(2,#ST),n15
      common /twopow/ n16(6)
      common /rppxrad/ x10(#ST),n34(#ST),n37(201)
C@TS      common /sltfrc/ d12(2,3,#ST),d13(2,#TR)
      common /charmm/ d14(6),n17(2,20),n18(3),n21(#NA)
      common /hbbridge/ d29(4),d33(3,#SX),x30(6),n30(#SX),n31(5),
     -  c32(100)
      common /engdec/ d34(47,#DT),n32(4,#DT),n33(9),x35(5)
      rewind ifile
      write (ifile)
     -  x1,x2,d3,d4,x5,x6,d7,x8, x10,
C@TS     -  d12,d13,
     -  d14, c19,c20,c21,c22,x23,x24,x25,x26,x27,x28,d29,x30,
     -  c32,d33,d34,x35,x36
      write (ifile) ncompopt,icompopt,nasize,iasize,cpxmoddate,moddate,
     -  n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,
     -  n20,n21,n22,n23,n24,n25,n26,n27,n28, n30,n31,n32,n33,n34,
     -  n35,n36,n37
      iskipfail=0
      if (ibuff .gt. 0) then
        call skiptoend(itypf,ifile,1,0,iop(24)-1,iskipfail)
        if (iop(87) .gt. 0) then
          if (infopx .gt. 0)
     -      call skiptoend(8,infopx,0,1,iop(24)-1,iskipfail)
          if (ifldgpx .gt. 0)
     -      call skiptoend(10,ifldgpx,0,1,iop(24)-1,iskipfail)
        end if
      end if
      return
      end
      subroutine disinipx(nsltpx1,nsltpx2,rpxdivi,rpxwwdivi,rgpxsltmax,
     -  rgpxwwmax)
c#    MMC routine 392 lstmod: 04/09/13
c*****Clean all accumulators for proximity analysis
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /dipole/ dipslt(3),dipslt2,dipslv(3),dipslv2,
     -  dipsys(3),dipsys2,dipoleg(3,#SX),dipoleg2(#SX),
     -  Dipole(3,#SX),Dipole2(#SX),dipole0(3,#SX),dipole02(#SX),
     -  dipole1(3,#SX),dipole12(#SX),dipole22(#SX),npxww0(#SX)
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
C@NL      logical irtd
      common /residt/ timestep,aucmin,nzerosignore,irtd(#RC,#GQ,#MD)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      real*8 blkavs
      common /btchav/ blkavs(#MI,11),nblcks
C@TS      real*8 ftslt,ftslt2,trqbnd,trqbnd2
C@TS      common /sltfrc/ ftslt(3,#ST),ftslt2(3,#ST),
C@TS     -  trqbnd(#TR),trqbnd2(#TR)
C@NL      logical izerolog
C@NL      equivalence (izero,izerolog)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
c     ncnfpx: counter of analysed configurations
c     npxwws: counter of waters in first shell of slt atom is
c     newwnn: counter of near neighbours of included waters in
c             the proximity region of slt atom is
c     nwfspx: counter of waters included for water-water properties
c             in primary region of slt atom is
c     nwpx:   counter of waters in the primary region of slt atom is
c     ewwis:  accumulator of water-water pair energy for water pairs
c             within rceww, for waters in the proximity region of slt atom is
c     ewwnn:  accumulator of water-water pair energy for water pairs
c             within rfsww, for waters in the proximity region of slt atom is
c     befssm: accumulator for slt-water energies with waters in the
c             first shell of solute atom is
c     besm:   accumulator for slt-water energies with waters in the
c             primary region of solute atom is
c     nblcks: number of control function blocks accumulated.
      nsltresets=0
      nslvresets=0
      izero=0
      nblcks=0
      ncnfpx=0
      nmolsum=0
      if (iop(162) .gt. 0) then
        do is=nsltpx1,nsltpx2
          npxwws(is)=0
          newwnn(is)=0
          npxww0(is)=0
          ewwis(is)=0.d0
          ewwnn(is)=0.d0
          befssm(is)=0.d0
          besm(is)=0.d0
          Dipole2(is)=0.0
          dipoleg2(is)=0.0
          dipole02(is)=0.0
          dipole12(is)=0.0
          dipole22(is)=0.0
          do k=1,3
            Dipole(k,is)=0.0
            dipoleg(k,is)=0.0
            dipole0(k,is)=0.0
            dipole1(k,is)=0.0
          end do
          nwfspx(is)=0
          nw2fspx(is)=0
          nwpx(is)=0
        end do
      end if
      dipslt2=0.0
      dipslv2=0.0
      dipsys2=0.0
      do k=1,3
        dipslt(k)=0.0
        dipslv(k)=0.0
        dipsys(k)=0.0
      end do
c     ngoo(1,i),j: accumulator for i-th O-O proximity g(r), j-th type
c     ngrslt(1,i): accumulator for i-th slt-slv primary g(r)
c     ngtslt(1,i): accumulator for i-th total slt atom - slv g(r).
c     nxck(1,i): accumulator for i-th primary coordination no QCDF.
c     nxtd(1,i): accumulator for i-th primary frst shell dipole distr
c     tdavr(1,i): i-th accumulator for dipole angle as a fct of distance
c     from slt atom.
c     nsltev(1,i) i-th primary slt-slv pair energy QCDF accumulator.
      do is=1,#GQ
        do i=1,#DG
          tdavr(i,is)=0.0d0
        end do
      end do
      call zeroiti(ngoo,0,#GQ*#VG*nijgvvp)
      call zeroiti(ngrslt,0,#GQ*#VG)
      call zeroiti(ngtslt,0,#GQ*#TG)
      call zeroiti(nxck,0,#GQ*15)
      call zeroiti(nxtd,0,#GQ*#LG)
      call zeroiti(nsltep,0,#GQ*#GE)
      if (iop(144) .gt. 0) then
c       Initialize solute atom pair force calculation
c       ftslt(3,i) : force accumulator on solute atom i
C@TS        do j=1,#TR
C@TS          trqbnd(j)=0.d0
C@TS          trqbnd2(j)=0.d0
C@TS        end do
C@TS        do j=nsltpx1,nsltpx2
C@TS          do k=1,3
C@TS            ftslt(k,j)=0.d0
C@TS            ftslt2(k,j)=0.d0
C@TS          end do
C@TS        end do
      end if
      if (iop(30) .eq. 1) call initwidom
      if (iop(30) .eq. 2) call initchim(nmolec,iout)
      if (iop(30) .eq. 3)
     -  call initaddwidom(c,esf14,vdwf14,cutuus,0.0,0,inperr,iout)
      if (iop(30) .gt. 0 .and. iop(3) .gt. 8) then
        if (MYRANK .eq. 0) write (iout,1003)
        inperr=inperr+1
      end if
C@FG      if (iop(166) .gt. 0) call initfldgrd(nmolec,nfg,nsttm)
      if (iop(171) .gt. 0) then
        do ic=1,#RC
          do iw=1,#MD
            do is=1,#GQ
C@NA             irtd(ic,is,iw)=izero
C@NL             irtd(ic,is,iw)=izerolog
            end do
          end do
        end do
      end if
      if (iop(174) .gt. 0) call initengdec(ialast,inperr,iout)
      if (iop(176) .gt. 0) call zeroiti(itangd,0,#TR*#TD)
      if (iop(176) .gt. 0) call zeroitd(dtangd,#TR*#TD)
      if (iop(177) .gt. 0) call initdifc
      if (iop(178) .gt. 0) then
        hbridges=0.d0
        hbridges2=0.d0
        ebridges=0.d0
        ebridges2=0.d0
        call zeroitd(shb,#SX)
        call zeroitd(eshb,#SX)
        call zeroitd(eshb2,#SX)
      end if
      if (pmvslv .eq. 0.0) pmvslv=18.12004
      if (rpxdivi .gt. 0.0 .and. rpxwwdivi .gt. 0.0 .and.
     -    rpxdivi .ne. rpxwwdivi) then
        if (MYRANK .eq. 0) write (iout,1000) rpxdivi,rpxwwdivi
        inperr=inperr+1
      end if
      if (rgpxsltmax .ne. 0.0 .or. rgpxwwmax .ne. 0.0) then
c       Set proximity rdf parameters
        if (rpxdivi*rpxwwdivi .eq. 0) then
          rpxdiv=amax1(rpxdivi,rpxwwdivi)
        else
          rpxdiv=amin1(rpxdivi,rpxwwdivi)
          if (rpxdivi .ne. rpxwwdivi) then
            if (MYRANK .eq. 0) write (iout,1002) rpxdiv
            nchng=nchng+1
          end if
        end if
        rripx2=1/rpxdiv**2
        if (mxpxsltgrd .gt. #RG) then
          mxpxsltgrd=#RG
          rgpxsltmax=rpxdiv*mxpxsltgrd
          if (MYRANK .eq. 0) write (iout,1002) rgpxsltmax
          nwarn=nwarn+1
        end if
        if (mxpxsltgrd .gt. #TG .and. iop(143) .gt. 0) then
          mxpxsltgrd=#TG
          rgpxsltmax=rpxdiv*mxpxsltgrd
          if (MYRANK .eq. 0) write (iout,1002) rgpxsltmax
          nchng=nchng+1
        end if
        rgpxsltmax2=rgpxsltmax**2
        if (mxpxwwgrd .gt. #RG) then
          mxpxwwgrd=#RG
          rgpxwwmax=rpxdiv*mxpxwwgrd
          if (MYRANK .eq. 0) write (iout,1002) rgpxwwmax
          nwarn=nwarn+1
        end if
        rgpxwwmax2=rgpxwwmax**2
        if (iop(159)+iop(144)+iop(143)+iop(146) .gt. 0) then
c         Limit range to energy cutoff
          if (rgpxsltmax2 .gt. ctslts) then
            if (MYRANK .eq. 0)
     -        write (iout,1004) 'solute',sqrt(rgpxsltmax2),cutslt
            rgpxsltmax2=ctslts
            nchng=nchng+1
          end if
          if (rgpxwwmax2 .gt. ctslvs) then
            if (MYRANK .eq. 0)
     -        write (iout,1004) 'solvent',sqrt(rgpxwwmax2),cutslv
            rgpxwwmax2=ctslvs
            nchng=nchng+1
          end if
        end if
        mxpxsltgrd=rgpxsltmax/rpxdiv+1
        mxpxwwgrd=rgpxwwmax/rpxdiv+1
      end if
      return
1000  format(' ***** ERROR: rdf gridsizes for solute-solvent (',f6.3,
     -  ') and solvent-solvent (',f6.3,') differ')
1002  format(' >>>>> OVERRIDE: radial distribution range has been ',
     -  ' reduced to ',f6.2,' A due to small dimension of the program')
1003  format(' ***** ERROR: Widom-type free energy calculations need ',
     -  ' energy calculations - specify a potential library with SUPT')
1004  format(' >>>>> OVERRIDE: ',a,'-solvent radial distribution range',
     -  ' has been reduced from',f8.2,' to',f8.2,' (the energy cutoff)')
      end
      subroutine disperpx(orient,c,crm,texslt,ifailpx)
c#    MMC routine 393 lstmod: 01/23/09
c*****Update the accumulators
      dimension c(3,#NA),orient(3,3,#MO),crm(3,#MO),
     -  texslt(#MO)
      character*80 file,filenames,filename1
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /ecell/ cic(3,27),ncell
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /h2olp/ om,sm,rmd2
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
      common /dipole/ dipslt(3),dipslt2,dipslv(3),dipslv2,
     -  dipsys(3),dipsys2,dipoleg(3,#SX),dipoleg2(#SX),
     -  Dipole(3,#SX),Dipole2(#SX),dipole0(3,#SX),dipole02(#SX),
     -  dipole1(3,#SX),dipole12(#SX),dipole22(#SX),npxww0(#SX)
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),ddipl(3,#UV),dpxyzg(3,#UV),dipl(3,#UV),
     -  cv1(#UV),cv2(#UV),cv3(#UV),abx(#UV),aby(#UV),
     -  abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
C@TS      real*8 ftslt,ftslt2,trqbnd,trqbnd2
C@TS      common /sltfrc/ ftslt(3,#ST),ftslt2(3,#ST),
C@TS     -  trqbnd(#TR),trqbnd2(#TR)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),fslt(3),fslv(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /worksp/ iproxi(#NA),ixx(#UV),ixv(#UV),l4(#UV)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
      dimension z(3),ortslt(3,3),cslvo(3,#SV),
     -  d(3),ipxgr(#MO),dpxyz(3),dpxyz1(3),keycol(2)
C@TS      real*8 frot,fsltsum
C@TS      dimension fsltsum(3,#ST)
c     r2stsv(i): distance square of solvent under consideration from slt atom i
c     rij2v(i): r2stsv(i)-rppxrad2(i), e.g. the proximity criterion distance
c     This array is always integer*2, independent of the C@ I2 lines
      integer*2 ixpxi2(#MO)
!*$* ASSERT PERMUTATION(ixv)
!*$* ASSERT PERMUTATION(indxrdf)
!*$* ASSERT PERMUTATION(iproxi)
!*$* ASSERT PERMUTATION(ivtm)
!*$* ASSERT PERMUTATION(ipxgr)
!*$* ASSERT PERMUTATION(ixx)
cx    common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
cx    write (iout,*)'DISPERPX start MYRANK=',MYRANK,'ncnfpx=',ncnfpx
      ifailpx=0
      ncnfpx=ncnfpx+1
      nmolsum=nmolsum+nmolec
      iop5pbcv=iop(5)
      if (iop(5) .eq. 0) iop5pbcv=8
      igr0=nstfg0*(nsltcp(iop(30)+1)-1)
      do is=nsltpx1,nsltpx2
        ncorslt(is)=0
        ncor2slt(is)=0
      end do
      noprox=1
      if (iop(175) .gt. 0) call permutexyz(c,natoms,ixyz)
      if (iop(160) .eq. 1 .or. iop(160) .eq. 2) then
c       Create crm and orient if necessary
        call cofms(c,crm,ianslt,1,nstta,1,www)
        call getortslt(c,crm,rlcslt,orient,iclslt,nstfa,nstfa1,nstta,
     -    natoms,isltmv,ncnfpx,nwarn,inperr,iout)
        if (ncnfpx .eq. 1 .or. iop(13) .gt. 1 .or.
     -     (iop(30) .ge. 1 .and. iop(30) .le. 3) .or.
     -      iop(80)+iop(144)+iop(146)+iop(147)+iop(148)+iop(166) .gt. 0)
     -   then
c         Get all com's
          if (iop(26) .lt. 4) then
            call cofmsw(c(1,nstta+1),nslv,crm(1,2),nmolec-1)
          else
            do iw=2,nmolec
              call cofms(c(1,ic01+iw*nslv),crm(1,iw),ianslv,
     -          1,nslv,1,www)
            end do
          end if
        end if
        if (iop(80) .gt. 0) then
          call initinout(molinout,nmolinout,edgelinxyz,edgerinxyz,
     -      crm,2,nmolec)
          suminout(1)=suminout(1)+nmolinout(1)
          suminout(2)=suminout(2)+nmolinout(2)
          suminout2(1)=suminout2(1)+nmolinout(1)**2
          suminout2(2)=suminout2(2)+nmolinout(2)**2
        end if
      else
        if (iop(152) .eq. 1 .and. iop(144)+iop(166)+iop(174) .gt. 0)
     -    call trnsfr(ortslt,orient,9)
      end if
      if (ncnfpx .eq. 1 .or. iop(13) .gt. 1 .or. iop(30) .eq. 2 .and.
     -    iop(159) .eq. 0) then
c       Calculate solvent orientation matrices
        do iw=2,nmolec
          if (iop(26) .lt. 4) then
            call ortslv(c(1,ic01+iw*nslv),orient(1,1,iw),ifail)
          else
            call getort(c(1,ic01+iw*nslv),crm(1,iw),ianslv,rlcslv,
     -        nslv,orient(1,1,iw),(iw-2+1),ixislt,-1,linear,1,
     -        0,ixrep3,nrep3,ifail,idebug(29),iout,nslv)
          end if
          call ckortfail(ifail,'configuration to analyze',24,0,iw,
     -      0,inperr,iout)
        end do
      end if
      if (nslv .gt. 2) then
        if (ncnfpx .eq. 1 .or. iop(13) .gt. 1) then
          call checksolvents(iout,nmolec,orient,c,crm,ixislt,rlcslv,
     -      cslvo,ianslv,nslv,ixrep3,nrep3,ic00,ic01,nmc,0.0001,nxerr,
     -      noerr,#NA,#ST)
          inperr=inperr+nxerr+noerr
        end if
      end if
      call checkwayout(nmolec,nslv,islvrep,iop(5),iout,iop(24),
     -  nsltout,nslvout,nwwarn)
      if (nsltout .gt. 0) nsltresets=nsltresets+1
      if (nslvout .gt. 0) nslvresets=nslvresets+1
      if (nsltresets .eq. 10 .or. nslvresets .eq. 10 .and.
     -   iop(24) .gt. 1) then
        write (iout,1007) nmc
        nwarn=nwarn+1
        iop(24)=1
      end if
      if (iop(176) .gt. 0) then
c       Accumulate torsion angle distribution
        do it=1,ntang
c         Determine current configuration's torsion angles
          dih=dihangl(c(1,iquata(it,1)),c(1,iquata(it,2)),
     -      c(1,iquata(it,3)),c(1,iquata(it,4)),idebug(24),iout)
          sinsum(it)=sinsum(it)+sin(dih)
          cossum(it)=cossum(it)+cos(dih)
          ig=#TD.0*(dih+pi)/pi2+1
          if (ig .lt. 1) ig=1
          if (ig .gt. #TD) ig=#TD
          itangd(ig,it)=itangd(ig,it)+1
        end do
      end if
C@TS      if (iop(144) .gt. 0) call zeroitd(fsltsum,nstta3)
      if (iop(159) .gt. 0) call trnsfr(estsv,texslt,nmolec)
      if (((iop(144) .gt. 0 .and. iop(159) .eq. 0) .or.
     -      iop(143)+iop(146) .gt. 0) .and. nmolec .gt. 1) then
c-------Compute solute-solvent energies, forces, proximity indices
        noprox=0
        if (nsltpx2 .eq. 0) then
c         When no solute is present, all solvents have proximity index 1
          do iw=2,nmolec
            iproxi(iw)=1
          end do
        else
          call zeroit(virc,3)
          do iw=2,nmolec
             estsv(iw)=engslt(iw,riijj,riijj0,rij0,isprox,idistmv,
     -         idistid,c,crm(1,iw),crm)
C@TS            if (iop(144) .gt. 0) then
C@TS              do is=1,nstta
C@TS                do k=1,3
C@TS                  fsltsum(k,is)=fsltsum(k,is)+fcslt(k,is)
C@TS                end do
C@TS              end do
C@TS            end if
            do is=nsltpx1,nsltpx2
              rij2v(is)=r2stsv(is)-rppxrad2(is)
            end do
            if (iop(168) .gt. 0) then
c             Drop requested atoms
              do is=nsltpx1,nsltpx2
                if (keeppx(is) .eq. 0) rij2v(is)=100000.0
              end do
            end if
C@NV            call smin(rij2v,nsltpx1,nsltpx2,rsmin,iprox)
C@VC            call vmin(rij2v,nsltpx1,nsltpx2,rsmin,iprox)
            rmins(iw)=r2stsv(iprox)
            iproxi(iw)=iprox
            if (iop(145) .gt. 0) then
c             Make sure cci contains the PBC shifts
              if (iop(43) .eq. 0) then
                iopt=ivopt(iw)
              else
                iopt=indexx(igrpf(iprox)-igr0)
              end if
              do k=1,3
                cci(k,iw)=cic(k,iopt)
              end do
            end if
            if (iop(143) .gt. 0) then
c-------------Compute total g(r)
c             ixv is the radial grid for solvent iw, solute atom is
              do is=nsltpx1,nsltpx2
                if (r2stsv(is) .lt. rgpxsltmax2) then
                  ixv(is)=sqrt(r2stsv(is)*rripx2)+1
                else
                  ixv(is)=mxpxsltgrd
                end if
              end do
              do is=nsltpx1,nsltpx2
                ngtslt(ixv(is),indxrdf(is))=
     -            ngtslt(ixv(is),indxrdf(is))+1
              end do
            end if
          end do
          if (iop(144) .gt. 0) then
c-----------Accumulate conformational force contributions
            if (iop(152) .eq. 1) then
c             Transform the forces on the solute into local coordinate system
c             if the solute was rotated
C@TS              do is=1,nstta
C@TS                do k=1,3
C@TS                  frot=dble(ortslt(k,1))*fsltsum(1,is)+
C@TS     -              dble(ortslt(k,2))*fsltsum(2,is)+
C@TS     -              dble(ortslt(k,3))*fsltsum(3,is)
C@TS                  ftslt(k,is)=ftslt(k,is)+frot
C@TS                  ftslt2(k,is)=ftslt2(k,is)+frot**2
C@TS                end do
C@TS              end do
C@TS            else
C@TS              do is=1,nstta
C@TS                do k=1,3
C@TS                  ftslt(k,is)=ftslt(k,is)+fsltsum(k,is)
C@TS                  ftslt2(k,is)=ftslt2(k,is)+fsltsum(k,is)**2
C@TS                end do
C@TS              end do
C@TS              do it=1,ntang
C@TSc               Accumulate torques on torsion bonds
C@TS                call  torquebond(c,it,fsltsum,abstorque,nstta)
C@TS                trqbnd(it)=trqbnd(it)+abstorque
C@TS                trqbnd2(it)=trqbnd2(it)+abstorque**2
C@TS              end do
            end if
          end if
          if (iop(146) .gt. 0) then
c-----------Compute binding energy averages
            do iw=2,nmolec
              esltiw=estsv(iw)
              besm(iproxi(iw))=besm(iproxi(iw))+esltiw
              if (rmins(iw) .le. rfsl2(iproxi(iw))) then
                befssm(iproxi(iw))=befssm(iproxi(iw))+esltiw
                ipe=(esltiw-epmink)/epdivk+1.0
                if (ipe .lt. 1) ipe=1
                if (ipe .gt. 100) ipe=100
                nsltep(ipe,indxrdf(iproxi(iw)))=
     -            nsltep(ipe,indxrdf(iproxi(iw)))+1
              end if
            end do
          end if
        end if
      else
        if (iop(159) .eq. 0) call zeroit(estsv,nmolec)
      end if
c-----Compute Widom or chimera method contributions
      if (iop(30) .eq. 1) then
        call accuwidom(c,crm,nmolec,vol,ctslts,cutuus,
     -    edgex2,edgey2,edge2,ncnfpx,ifailwidom)
        ifailpx=ifailpx+ifailwidom
      else if (iop(30) .eq. 2) then
        call accuchim(c,crm,nmolec,ncnfpx,ctslvs,cutuus,
     -    edgex2,edgey2,edge2)
      else if (iop(30) .eq. 3) then
        if (iop(105) .eq. 1)
     -    call initaddwidom(c,esf14,vdwf14,cutuus,0.0,1,inperr,iout)
        call accuaddwidom(c,crm,nmolec,ctslts,cutuus,
     -    edgex2,edgey2,edge2,ncnfpx,ifail)
      end if
      if (iop(174) .gt. 0) then
c-------Accumulate energy decomposition
        call accuengdec
        numrecprev(10)=numrec(10)
      end if
      if (noprox .eq. 1 .and. iop(170) .eq. 0 .and. iop(162) .gt. 0)then
c-------Determine proximity indices if not done by energy calc
        call findprox(c,crm,nmolec,edgexa,iproxi,ixx,ixv,1,iop(168))
        noprox=0
      end if
      if (iop(170) .gt. 0 .and. iop(163) .gt. 0) then
c-------Read proximity indices and distances from the .pxi file
        if (iop(163) .eq. 1) then
          read (infopx,1000) nmolec1,nmcread,ncnfpxread,
     -      (iww,iproxi(iw),labslt2iw,igrsltiproxiiw,
     -      labslt1iw,rmins(iw),estsv(iw),iw=2,nmolec)
          do iw=2,nmolec
            rmins(iw)=rmins(iw)**2
          end do
        else
          if (iop(163) .eq. 2) then
            read (infopx) nmolec1,nmcread,ncnfpxread,
     -        (ixpxi2(iw),rmins(iw),estsv(iw),iw=2,nmolec)
          else
            read (infopx) nmolec1,nmcread,ncnfpxread,
     -        (ixpxi2(iw),rmins(iw),iw=2,nmolec)
          end if
c         Proximity indices were saved as integer*2
          do iw=2,nmolec
            iproxi(iw)=ixpxi2(iw)
          end do
        end if
        if (nmc .ne. nmcread .or. ncnfpx .ne. ncnfpxread) then
          write (iout,1003) nmc,nmcread,ncnfpx,ncnfpxread
          call datprt(2)
        end if
        noprox=0
      else if (nmolec .gt. 1 .and. (nstta-nstfa .gt. 1 .or.
     -  (iop(30) .ne. 1 .and. iop(30) .ne. 2))) then
c-------Check nearest approach
C@NV        call smin(rmins,2,nmolec,rsmin,iprox)
C@VC        call vmin(rmins,2,nmolec,rsmin,iprox)
        if (rsmin .lt. rpxnear2) then
          write (iout,1001) iprox-1,sqrt(rsmin),iproxi(iprox),
     -      ncnfpx,nmc,sqrt(rsmin)
          nwwarn=nwwarn+1
          call savepdb('PDB ',keycol,iconfpdb,iout,nsltpx1,nsltpx2,nslv,
     -      c,0,0,0,1,filename1,namlens1,nmc,2,file,namlenf,numrun,
     -      nwwarn,1,inperr,nwarn,nwwarn,12,0,nlwr,0,1,#NA)
          write (iout,1002) filename1(1:namlens1)
          if (idebug(41) .gt. 0) call datprt(1)
        end if
      end if
      if (iop(178) .gt. 0) then
c-------Calculate hydrogen-bonded bridges
        nhbb=0
        do iw=2,nmolec
          if (rmins(iw) .lt. 2.0*rxhmax2) then
            i0=nstta+nslv*(iw-2)
            nhb=0
            iadon=0
            iaacc=0
            ihacc=0
            rdon=0.0
            racc=0.0
            adon=0.0
            aacc=0.0
            do iaa=1,nhbanchor
              ia=ihbanchor(iaa)
              if (ianslt(ia) .eq. 1) then
                call checkforhbond(c,i0+iwo,ia,ineig(1,ia),natoms,
     -            rxhmax2,hbanglemin,ihb,ro2,oang,iout)
c               ro2=arrdist(c(1,ia),c(1,i0+iwo))
c               if (ro2 .lt. rxhmax2) then
c                 Distance ok, check angle
c                 oang=angleijk(c,natoms,i0+iwo,ia,ineig(1,ia),iout)
c                 if (oang .ge. hbanglemin) then
                if (ihb .eq. 1) then
                  nhb=nhb+1
                  iaacc=ia
                  racc=ro2
                  aacc=oang
                end if
c               end if
              else
                call checkforhbond(c,ia,i0+iwh1,i0+iwo,natoms,
     -            rxhmax2,hbanglemin,ihb,rh12,hang,iout)
c               rh12=arrdist(c(1,ia),c(1,i0+iwh1))
c               if (rh12 .lt. rxhmax2) then
c                 hang=angleijk(c,natoms,ia,i0+iwh1,i0+iwo,iout)
c                 if (hang .ge.  hbanglemin) then
                if (ihb .eq. 1) then
                  nhb=nhb+1
                  iadon=ia
                  ihacc=iwh1
                  rdon=rh12
                  adon=hang
c                 end if
                else
                  call checkforhbond(c,ia,i0+iwh2,i0+iwo,natoms,
     -              rxhmax2,hbanglemin,ihb,rh22,hang,iout)
c                 rh22=arrdist(c(1,ia),c(1,i0+iwh2))
c                 if (rh22 .lt. rxhmax2) then
c                   hang=angleijk(c,natoms,ia,i0+iwh2,i0+iwo,iout)
c                   if (hang .ge. hbanglemin) then
                  if (ihb .eq. 1) then
                    nhb=nhb+1
                    iadon=ia
                    ihacc=iwh2
                    rdon=rh22
                    adon=hang
                  end if
c                 end if
                end if
              end if
            end do
            if (nhb .gt. 0) then
              if (iop(144)+iop(146) .eq. 0) then
                esx=engslt(iw,riijj,riijj0,rij0,isprox,idistmv,idistid,
     -            c,crm(1,iw),crm)
              else
                esx=estsv(iw)
              end if
              if (idebug(96) .gt. 2-min0(2,nhb))
     -          write (iout,1004) nmc,nhb,iw,iadon,iaacc,ihacc,
     -            sqrt(racc),aacc*rdtodg,sqrt(rdon),adon*rdtodg,esx
              if (nhb .eq. 1) then
                ia=iadon+iaacc
                shb(ia)=shb(ia)+1
                eshb(ia)=eshb(ia)+esx
                eshb2(ia)=eshb2(ia)+esx**2
              else if (nhb .gt. 1) then
c               Bridge found
                nhbb=nhbb+1
                ebridges=ebridges+esx
                ebridges2=ebridges2+esx**2
              end if
            end if
          end if
        end do
        hbridges=hbridges+nhbb
        hbridges2=hbridges2+nhbb**2
        if (nhbb .gt. 0 .and. idebug(96) .gt. 2)
     -    call savepdb('PDB ',keycol,iconfpdb,iout,nsltpx1,nsltpx2,nslv,
     -      c,0,0,0,1,filename1,namlens1,nmc,1,file,namlenf,numrun,
     -      nwwarn,3,inperr,nwarn,nwwarn,12,0,nlwr,0,1,#NA)
      end if
      if (iop(166) .gt. 0) then
c-------Accumulate field-gradient contributions
        call accufldgrd(ncnfpx,iproxi,rmins,texng,dielc,nmolec)
        numrecprev(10)=numrec(10)
      end if
c     From here on, ixv will be 1 for solvents in the requested shell
      if (iop(162) .gt. 0) then
c       Label the waters to be used
        call zeroiti(ixv,0,nmolec)
        do iw=2,nmolec
          ipxgr(iw)=indxrdf(iproxi(iw))
          if (rmins(iw) .le. rsmxsq .and. rmins(iw) .ge. rsmnsq)
     -      ixv(iw)=1
        end do
      end if
      if (iop(145) .gt. 0) then
        do iw=2,nmolec
c---------Compute slv dipole orientation
          iw0=ic00+iw*nslv
          r11=c(1,iproxi(iw))-c(1,iw0+1)-cci(1,iw)
          r12=c(2,iproxi(iw))-c(2,iw0+1)-cci(2,iw)
          r13=c(3,iproxi(iw))-c(3,iw0+1)-cci(3,iw)
          r21=c(1,iw0+2)+c(1,iw0+3)-2.0*c(1,iw0+1)
          r22=c(2,iw0+2)+c(2,iw0+3)-2.0*c(2,iw0+1)
          r23=c(3,iw0+2)+c(3,iw0+3)-2.0*c(3,iw0+1)
          cth=(r11*r21+r12*r22+r13*r23)/sqrt((r11*r11+r12*r12+r13*r13)*
     -      rmd2)
          if (cth .gt. 1.0) cth=1.0
          if (cth .lt. -1.0) cth=-1.0
          rv(iw)=cth
        end do
      end if
c-----Compute primary coordination numbers
      if (iop(162) .gt. 0) then
        do iw=2,nmolec
          nwpx(iproxi(iw))=nwpx(iproxi(iw))+1
          rsmin=rmins(iw)
          if (rsmin .le. r2fsl2(iproxi(iw))) then
            ncor2slt(iproxi(iw))=ncor2slt(iproxi(iw))+1
            if (rsmin .le. rfsl2(iproxi(iw)))
     -        ncorslt(iproxi(iw))=ncorslt(iproxi(iw))+1
          end if
        end do
        do is=nsltpx1,nsltpx2
          nwfspx(is)=nwfspx(is)+ncorslt(is)
          nw2fspx(is)=nw2fspx(is)+ncor2slt(is)
        end do
        if (iop(142) .gt. 1 .or. iop(145) .gt. 0) then
c         Save in ivtm the distance grid indexx
          do iw=2,nmolec
            if (rmins(iw) .lt. rgpxsltmax2) then
              ivtm(iw)=sqrt(rmins(iw)*rripx2)+1
            else
              ivtm(iw)=mxpxsltgrd
            end if
          end do
        end if
      end if
c-----Compute primary g(r)
      if (iop(142)+iop(145) .gt. 1) then
        do iw=2,nmolec
          ngrslt(ivtm(iw),indxrdf(iproxi(iw)))=
     -      ngrslt(ivtm(iw),indxrdf(iproxi(iw)))+1
        end do
      end if
c-----Compute primary g(r), coordination numbers and dipole distributions
      if (iop(145) .gt. 0) then
        do iw=2,nmolec
          irmin=ivtm(iw)
          rsmin=rmins(iw)
          tdavr(ivtm(iw),indxrdf(iproxi(iw)))=
     -      tdavr(ivtm(iw),indxrdf(iproxi(iw)))+rv(iw)
          if (rsmin .le. rfsl2(iproxi(iw))) then
            ith=int(acoscheck(rv(iw),iout,'DISPERPX')*
     -          rdtodg*(#LG.0/180.0))+1
            if (ith .gt. #LG) ith=#LG
            nxtd(ith,indxrdf(iproxi(iw)))=
     -        nxtd(ith,indxrdf(iproxi(iw)))+1
          end if
        end do
      end if
c-----Residence time calculations
      if (iop(171) .gt. 0)
     -  call accurestim(nmolec,ncnfpx,navgpx,nsltpxgr,rmins,ipxgr,
     -  iproxi,rfsl2,r2fsl2,rtimlim,irtm,nmcpxo,'step    ',inperr,iout)
c-----Diffusion constant calculation
      if (iop(177) .gt. 0)
     -  call accudiffc(nmolec,nslv,islvrep,ic00,rmins,ipxgr,
     -    iop(5),dcgrid,rdc1,rdc2,rfsl2,r2fsl2,rgpxsltmax2,c)
c-----Dipole moment calculations - - written by Jian Sun
      if (iop(169) .gt. 0) then
c       Compute the dipole moment of: system, solute and solvent
        do k=1,3
          dpxyz(k)=0.0
          dpxyz1(k)=0.0
        end do
        do is=nsltpx1,nsltpx2
          do k=1,3
            dpxyz(k)=dpxyz(k)+c(k,is)*qslt(is)
          end do
        end do
        do k=1,3
          dipslt(k)=dipslt(k)+dpxyz(k)
          dipsys(k)=dipsys(k)+dpxyz(k)
        end do
        dipslt2=dipslt2+sclprd(dpxyz,dpxyz)
        do k=1,3
          dpxyz1(k)=dpxyz(k)
          dpxyz(k)=0.0
        end do
        do iw=2,nmolec
          iw0=ic00+iw*nslv
          do j=1,nslv
            do k=1,3
              dpxyz(k)=dpxyz(k)+c(k,iw0+j)*qslv(j)
            end do
          end do
        end do
        do k=1,3
          dipslv(k)=dipslv(k)+dpxyz(k)
          dipsys(k)=dipsys(k)+dpxyz(k)
          dpxyz1(k)=dpxyz1(k)+dpxyz(k)
        end do
        dipslv2=dipslv2+sclprd(dpxyz,dpxyz)
        dipsys2=dipsys2+sclprd(dpxyz1,dpxyz1)
        do is=nsltpx1,nsltpx2
          do k=1,3
            dpxyzg(k,is)=0.0
          end do
        end do
c       Calculate the dipole moment in the primary regions
        do iw=2,nmolec
          iw0=ic00+iw*nslv
          rsmin=rmins(iw)
          if (rmins(iw) .lt. rgpxsltmax2) then
            do j=1,nslv
              do k=1,3
                dpxyzg(k,ipxgr(iw))=dpxyzg(k,ipxgr(iw))+
     -            c(k,iw0+j)*qslv(j)
              end do
            end do
          end if
        end do
        do ig=1,nsltpxgr
          do k=1,3
            dipoleg(k,ig)=dipoleg(k,ig)+dpxyzg(k,ig)
          end do
        end do
        do ig=1,nsltpxgr
          dipoleg2(ig)=dipoleg2(ig)+sclprd(dpxyzg(1,ig),dpxyzg(1,ig))
        end do
c       Calculate the dipole moment within the first shell
        do ig=1,nsltpxgr
          do k=1,3
            dpxyzg(k,ig)=0.0
            dipl(k,ig)=0.0
          end do
        end do
        do iw=2,nmolec
          iw0=ic00+iw*nslv
          rsmin=rmins(iw)
          if (rsmin .le. rfsl2(iproxi(iw))) then
            do j=1,nslv
              do k=1,3
                dpxyzg(k,ipxgr(iw))=dpxyzg(k,ipxgr(iw))+
     -            c(k,iw0+j)*qslv(j)
              end do
            end do
          end if
          if (rsmin .le. r2fsl2(iproxi(iw))) then
            do j=1,nslv
              do k=1,3
                dipl(k,ipxgr(iw))=dipl(k,ipxgr(iw))+
     -            c(k,iw0+j)*qslv(j)
              end do
            end do
          end if
        end do
        do ig=1,nsltpxgr
          do k=1,3
            dipole0(k,ig)=dipole0(k,ig)+dpxyzg(k,ig)
            dipole1(k,ig)=dipole1(k,ig)+dipl(k,ig)
            ddipl(k,ig)=dipl(k,ig)-dpxyzg(k,ig)
          end do
        end do
        do ig=1,nsltpxgr
          dipole02(ig)=dipole02(ig)+sclprd(dpxyzg(1,ig),dpxyzg(1,ig))
          dipole12(ig)=dipole12(ig)+sclprd(dipl(1,ig),dipl(1,ig))
          dipole22(ig)=dipole22(ig)+sclprd(ddipl(1,ig),ddipl(1,ig))
        end do
c       Calculate the dipole moment in the defined regions
        do iw=2,nmolec
          if (ixv(iw) .gt. 0) npxww0(ipxgr(iw))=npxww0(ipxgr(iw))+1
        end do
        do i=1,nsltpxgr
          do k=1,3
            dipl(k,i)=0.0
          end do
        end do
        do iw=2,nmolec
          iw0=ic00+iw*nslv
          if (ixv(iw) .ne. 0) then
            do k=1,3
              do j=1,nslv
                dipl(k,ipxgr(iw))=dipl(k,ipxgr(iw))+qslv(j)*c(k,iw0+j)
              end do
            end do
          end if
        end do
        do ig=1,nsltpxgr
          do k=1,3
            Dipole(k,ig)=Dipole(k,ig)+dipl(k,ig)
          end do
          Dipole2(ig)=Dipole2(ig)+sclprd(dipl(1,ig),dipl(1,ig))
        end do
      end if
c-----Calculate solvent dipole direction distribution
      if (iop(111) .gt. 0 .and. iop(159) .eq. 0) then
        call accu_dipoledist(nstta,nslv,qslvdip,dipmomabs,dndipmom,
     -    exyzabc,c,nmolec,rdtodg,iout)
      end if
c-----Update first shell coord no and xc(k) QCDF counters from ncorslt
      if (iop(142) .gt. 1) then
        do is=nsltpx1,nsltpx2
          ncoris=ncorslt(is)+1
          if (ncoris .gt. 15) ncoris=15
          nxck(ncoris,indxrdf(is))=nxck(ncoris,indxrdf(is))+1
        end do
      end if
      if (iop(147)+iop(148) .gt. 0) then
c-------Compute solvent-solvent pair properties
c       Label the waters to be used
        nm1=nmolec-1
        do iw=2,nm1
          ipxi=iproxi(iw)
          ipxix=indxrdf(ipxi)*ixv(iw)
          if (indxrdf(iproxi(iw))*ixv(iw) .ne. 0)
     -       npxwws(iproxi(iw))=npxwws(iproxi(iw))+1
          i1=iw+1
          njw=0
          do jw=i1,nmolec
            if (indxrdf(iproxi(iw))+ixv(jw) .gt. 0) then
              njw=njw+1
              ixx(njw)=jw
            end if
          end do
          do jww=1,njw
            zv(1,jww)=crm(1,ixx(jww))-crm(1,iw)
            zv(2,jww)=crm(2,ixx(jww))-crm(2,iw)
            zv(3,jww)=crm(3,ixx(jww))-crm(3,iw)
          end do
          call pbcvec(iop5pbcv,1,njw)
          if (iop(147) .gt. 0) then
            if (nijgvv .eq. 0) then
c             COM-COM option
              do jww=1,njw
                jw=ixx(jww)
                ipxjx=ipxgr(jw)*ixv(jw)
                if (ipxix+ipxjx .gt. 0) then
                  if (riijjv(jww) .lt. rgpxwwmax2) then
                    id=sqrt(riijjv(jww)*rripx2)+1
                    if (ipxix .ne. 0)
     -                ngoo(id,ipxix,1)=ngoo(id,ipxix,1)+1
                    if (ipxjx .ne. 0)
     -                ngoo(id,ipxjx,1)=ngoo(id,ipxjx,1)+1
                  end if
                end if
              end do
            else
              do iv=1,nijgvv
                if (islvirep(iv) .eq. islvjrep(iv)) then
c                Atom-atom option - same atoms
                iw0=ic00+iw*nslv
                  do jww=1,njw
                    ipxjx=ipxgr(ixx(jww))*ixv(ixx(jww))
                    if (ipxix+ipxjx .gt. 0) then
                      jw0=ic00+ixx(jww)*nslv
                      do k=1,3
                        z(k)=c(k,jw0+islvjrep(iv))-
     -                    c(k,iw0+islvirep(iv))+cci(k,jww)
                      end do
                      rz2=z(1)*z(1)+z(2)*z(2)+z(3)*z(3)
                      if (rz2 .lt. rgpxwwmax2) then
                        id=sqrt(rz2*rripx2)+1
                        if (ipxix .ne. 0)
     -                    ngoo(id,ipxix,iv)=ngoo(id,ipxix,iv)+1
                        if (ipxjx .ne. 0)
     -                  ngoo(id,ipxjx,iv)=ngoo(id,ipxjx,iv)+1
                      end if
                    end if
                  end do
                else
c                 Atom-atom option - different atoms
                  iw0=ic00+iw*nslv
                  do jww=1,njw
                    jw=ixx(jww)
                    ipxjx=ipxgr(jw)*ixv(jw)
                    if (ipxix+ipxjx .gt. 0) then
                      jw0=ic00+jw*nslv
                      do k=1,3
                        z(k)=c(k,jw0+islvjrep(iv))-
     -                   c(k,iw0+islvirep(iv))+cci(k,jww)
                        d(k)=c(k,jw0+islvirep(iv))-
     -                    c(k,iw0+islvjrep(iv))+cci(k,jww)
                      end do
                      rz2=z(1)*z(1)+z(2)*z(2)+z(3)*z(3)
                      if (rz2 .lt. rgpxwwmax2) then
                        id=sqrt(rz2*rripx2)+1
                        if (ipxix .ne. 0)
     -                    ngoo(id,ipxix,iv)=ngoo(id,ipxix,iv)+1
                        if (ipxjx .ne. 0)
     -                    ngoo(id,ipxjx,iv)=ngoo(id,ipxjx,iv)+1
                      end if
                      rd2=d(1)*d(1)+d(2)*d(2)+d(3)*d(3)
                      if (rd2 .lt. rgpxwwmax2) then
                        id=sqrt(rd2*rripx2)+1
                        if (ipxix .ne. 0)
     -                    ngoo(id,ipxix,iv)=ngoo(id,ipxix,iv)+1
                        if (ipxjx .ne. 0)
     -                    ngoo(id,ipxjx,iv)=ngoo(id,ipxjx,iv)+1
                      end if
                    end if
                  end do
                end if
              end do
            end if
          end if
          do jww=1,njw
            jw=ixx(jww)
            ipxj=iproxi(jw)
            ipxjx=ipxgr(jw)*ixv(jw)
            if (iop(148)*(ipxix+ipxjx) .gt. 0) then
c             Pair energy calculation
              if (riijjv(jww) .le. rceww2) then
                ewwi=eww(iw,jw,ivopt(jww),cci(1,jww),cci(2,jww),
     -            cci(3,jww),riijjv(jww),c,crm)
                if (ipxix .ne. 0) ewwis(ipxi)=ewwis(ipxi)+dble(ewwi)
                if (ipxjx .ne. 0) ewwis(ipxj)=ewwis(ipxj)+dble(ewwi)
                if (riijjv(jww) .le. rfsww2) then
                  if (ipxix .ne. 0) newwnn(ipxi)=newwnn(ipxi)+1
                  if (ipxix .ne. 0) ewwnn(ipxi)=ewwnn(ipxi)+dble(ewwi)
                  if (ipxjx .ne. 0) newwnn(ipxj)=newwnn(ipxj)+1
                  if (ipxjx .ne. 0) ewwnn(ipxj)=ewwnn(ipxj)+dble(ewwi)
                end if
              end if
            end if
          end do
        end do
      end if
      if (iop(163) .gt. 0 .and. infopx .gt. 0 .and.iop(170) .eq. 0) then
        numrecprev(8)=numrec(8)
        if (idebug(98) .gt. 0) write (iout,1005) (nmolec-1),nmc,ncnfpx
        if (iop(163) .eq. 1) then
          write (infopx,1000) (nmolec-1),nmc,ncnfpx,
     -      (iw,iproxi(iw),labslt(2,iproxi(iw)),igrslt(iproxi(iw)),
     -      labslt(1,iproxi(iw)),sqrt(rmins(iw)),estsv(iw),iw=2,nmolec)
          numrec(8)=numrec(8)+nmolec
        else
c         Save proximity indices as integer*2
          do iw=2,nmolec
            ixpxi2(iw)=iproxi(iw)
          end do
          if (iop(163) .eq. 2) then
            write (infopx) (nmolec-1),nmc,ncnfpx,
     -        (ixpxi2(iw),rmins(iw),estsv(iw),iw=2,nmolec)
          else
            write (infopx) (nmolec-1),nmc,ncnfpx,
     -        (ixpxi2(iw),rmins(iw),iw=2,nmolec)
          end if
          numrec(8)=numrec(8)+1
        end if
      end if
      if (noprox .eq. 0) then
c       Check proximity array
        do iw=2,nmolec
          if (iproxi(iw) .lt. nsltpx1 .or. iproxi(iw) .gt. nsltpx2) then
            write (iout,1006) iw,iproxi(iw),nsltpx1,nsltpx2
            inperr=inperr+1
          end if
        end do
      end if
      if (iop(175) .gt. 0 .and. iop(159) .gt. 0)
     -  call permutexyz(c,natoms,ixyzinv)
      return
1000  format(' Number of solvents=',i6,' Nmc=',i10,
     -  ' Snapshot number=',i6,/,
     -  (' Solvent ',i6,' nearest solute atom:',i5,' (',a4,
     -  ') of residue ',i5,' (',a4,') dist=',f8.4,' A ',
     -  'solute-solvent eng=',f12.4,' kcal/mol'))
1001  format(' ===== STRONG WARNING: solvent ',i7,
     -  ' is too close to the solute ',/,' (',f5.3,' A from atom ',i5,
     -  ' in snapshot no ',i6,' Nmc=',i10,/,
     -  7x,'To stop when this occurs use',/,7x,'DBUG 1 41 1',/,
     -  7x,'or reduce rpxnear below',f6.3,' with the PXGR key to ',
     -  'eliminate this warning')
1002  format(' Suspect configuration saved in PDB format as ',a)
1003  format(' ***** ERROR: Nmc value=',i10,' read from .pxi=',i10,
     -  ' ncnfpx=',i6,' read from .pxi=',i6)
1004  format(' DISPERPX HBBR: nmc=',i10,' nhb=',i1,' iw,id,ia,iha=',4i5,
     -  ' ra=',f5.2,' anga=',f7.2,' rd=',f5.2,' angd=',f7.2,' e=',e12.5)
1005  format(' DISPERPX saving .pxi record nmolec-1,nmc,ncnfpx=',3i12)
1006  format(' ***** PROGRAM ERROR: Proximity index of molecule ',i5,
     -  '=',i9,' is out of the range [',i4,',',i6,']')
1007  format(' ----- WARNING: more than 10 structures had ',
     -  'molecules outside the cell. Output level has been reduced at',
     -  ' Nmc=',i9)
      end
      subroutine mpi_reducepx
c#    MMC routine 394 lstmod: 07/04/10
c*****Sum up the analysis results accumulated on each processor into the 0th
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /h2olp/ om,sm,rmd2
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
      common /dipole/ dipslt(3),dipslt2,dipslv(3),dipslv2,
     -  dipsys(3),dipsys2,dipoleg(3,#SX),dipoleg2(#SX),
     -  Dipole(3,#SX),Dipole2(#SX),dipole0(3,#SX),dipole02(#SX),
     -  dipole1(3,#SX),dipole12(#SX),dipole22(#SX),npxww0(#SX)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
C@TS      real*8 ftslt,ftslt2,trqbnd,trqbnd2
C@TS      common /sltfrc/ ftslt(3,#ST),ftslt2(3,#ST),
C@TS     -  trqbnd(#TR),trqbnd2(#TR)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
C@DMC@TS      real*8 fsum,tsum
C@DMC@TS      dimension fsum(3,#ST),tsum(#TR)
C@DM      real*8 suminoutsum
C@DM      dimension suminoutsum(2)
C@DM      dimension ngtsum(#TG),itdsum(#TD)
C@DM      if (iop(24) .gt. 2) write (ioutdb,*) 'mpi_reducepx MYRANK=',
C@DM     -  MYRANK,' ncnfpx,nmolsum=',ncnfpx,nmolsum
C@DM      call mpi_rangather_scatter(1,iout,iop(24),'RDPX')
C@DM      call MPI_reduce(ncnfpx,ncnfpxsum,1,MPI_INTEGER,MPI_SUM,0,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      if (MYRANK .eq. 0) ncnfpx=ncnfpxsum
C@DM      if (iop(24) .gt. 2) write (ioutdb,*) 'mpi_reducepx MYRANK=',
C@DM     -  MYRANK,' ncnfpx,nmolsum=',ncnfpx,nmolsum
C@DM      call MPI_reduce(nmolsum,nmolsumsum,1,MPI_INTEGER,MPI_SUM,0,
C@DM     -  MPI_COMM_WORLD,ierr)
C@DM      if (MYRANK .eq. 0) nmolsum=nmolsumsum
C@DM      if (iop(24) .gt. 2) write (ioutdb,*) 'mpi_reducepx MYRANK=',
C@DM     -  MYRANK,' ncnfpx,nmolsum=',ncnfpx,nmolsum
c         Accumulate torsion angle distribution
C@DM      if (iop(176) .gt. 0) then
C@DM        do it=1,ntang
C@DM         call MPI_reduce(itangd(1,it),itdsum,#TD,MPI_INTEGER,
C@DM     -     MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@DM          if (MYRANK .eq. 0)
C@DM     -      call trnsfi(itangd(1,it),itdsum,#TD)
C@DM        end do
C@DM      end if
c--------Acucmulate inside/outside sums
C@DM      if (iop(80) .gt. 0) then
C@DM        call MPI_reduce(suminout,suminoutsum,2,MPI_DOUBLE_PRECISION,
C@DM     -    MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@DM        if (MYRANK .eq. 0) call trnsfrd(suminout,suminoutsum,2)
C@DM      end if
c--------Acucmulate total g(r)
C@DM      if (iop(143) .gt. 0) then
C@DM        do is=nsltpx1,nsltpx2
C@DM          call MPI_reduce(ngtslt(1,indxrdf(is)),ngtsum,
C@DM     -      mxpxsltgrd,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@DM          if (MYRANK .eq. 0)
C@DM     -      call trnsfi(ngtslt(1,indxrdf(is)),ngtsum,mxpxsltgrd)
C@DM        end do
C@DM      end if
c---------Accumulate conformational force contributions
C@TSC@DM        if (iop(144) .gt. 0 .and. iop(152) .eq. 1) then
C@TSC@DM          call MPI_reduce(ftslt,fsum,nstta3,MPI_DOUBLE_PRECISION,
C@TSC@DM     -      MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@TSC@DM          if (MYRANK .eq. 0)
C@TSC@DM     -      call trnsfrd(ftslt,fsum,nstta3)
C@TSC@DM          call MPI_reduce(ftslt2,fsum,nstta3,MPI_DOUBLE_PRECISION,
C@TSC@DM     -      MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@TSC@DM          if (MYRANK .eq. 0)
C@TSC@DM     -      call trnsfrd(ftslt2,fsum,nstta3)
C@TSC@DM          call MPI_reduce(trqbnd,tsum,ntang,MPI_DOUBLE_PRECISION,
C@TSC@DM     -      MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@TSC@DM          if (MYRANK .eq. 0)
C@TSC@DM     -      call trnsfrd(trqbnd,tsum,ntang)
C@TSC@DM          call MPI_reduce(trqbnd2,tsum,ntang,MPI_DOUBLE_PRECISION,
C@TSC@DM     -      MPI_SUM,0,MPI_COMM_WORLD,ierr)
C@TSC@DM          if (MYRANK .eq. 0)
C@TSC@DM     -      call trnsfrd(trqbnd2,tsum,ntang)
C@TSC@DM        end if
 
c-----Compute Widom or chimera method contributions
      if (iop(30) .eq. 1) then
        call mpi_reducewidom
C      else if (iop(30) .eq. 2) then
C        call accuchim(c,crm,nmolec,ncnfpx,ctslvs,cutuus,
C     -  edgex2,edgey2,edge2)
      end if
 
C        if (iop(146) .gt. 0) then
Cc---------Compute binding energy averages
C          do iw=2,nmolec
C              nsltep(ipe,indxrdf(iproxi(iw)))=
C     -          nsltep(ipe,indxrdf(iproxi(iw)))+1
C            end if
C          end do
C        end if
C      end if
 
C      if (iop(174) .gt. 0) then
Cc-------Accumulate energy decomposition
C        call accuengdec
C      end if
 
C      if (iop(178) .gt. 0) then
Cc-------Calculate hydrogen-bonded bridges
C        do iw=2,nmolec
C                shb(ia)=shb(ia)+1
C                eshb(ia)=eshb(ia)+esx
C                eshb2(ia)=eshb2(ia)+esx**2
C
Cc               Bridge found
C                nhbb=nhbb+1
C                ebridges=ebridges+esx
C        end do
C        hbridges=hbridges+nhbb
C        hbridges2=hbridges2+nhbb**2
C      end if
 
C      if (iop(166) .gt. 0) then
Cc-------Accumulate field-gradient contributions
C        call accufldgrd(ncnfpx,iproxi,rmins,texng,dielc,nmolec)
C      end if
 
C      if (iop(145) .gt. 0) then
C        do iw=2,nmolec
Cc---------Compute slv dipole orientation
C          rv(iw)=cth
C        end do
C      end if
 
Cc-----Compute primary coordination numbers
C      if (iop(162) .gt. 0) then
C        do iw=2,nmolec
C          nwpx(iproxi(iw))=nwpx(iproxi(iw))+1
C            ncor2slt(iproxi(iw))=ncor2slt(iproxi(iw))+1
C             ncorslt(iproxi(iw))=ncorslt(iproxi(iw))+1
C        end do
C        do is=nsltpx1,nsltpx2
C          nwfspx(is)=nwfspx(is)+ncorslt(is)
C          nw2fspx(is)=nw2fspx(is)+ncor2slt(is)
C        end do
C      end if
 
Cc-----Compute primary g(r)
C      if (iop(142)+iop(145) .gt. 1) then
C        do iw=2,nmolec
C          ngrslt(ivtm(iw),indxrdf(iproxi(iw)))=
C     -      ngrslt(ivtm(iw),indxrdf(iproxi(iw)))+1
C        end do
C      end if
 
Cc-----Compute primary g(r), coordination numbers and dipole distributions
C      if (iop(145) .gt. 0) then
C        do iw=2,nmolec
C          tdavr(ivtm(iw),indxrdf(iproxi(iw)))=
C     -      tdavr(ivtm(iw),indxrdf(iproxi(iw)))+rv(iw)
C            nxtd(ith,indxrdf(iproxi(iw)))=
C     -        nxtd(ith,indxrdf(iproxi(iw)))+1
C          end if
C        end do
C      end if
 
Cc-----Residence time calculations
C      if (iop(171) .gt. 0)
C     -  call accurestim(nmolec,ncnfpx,navgpx,nsltpxgr,rmins,ipxgr,
C     -    iproxi,rfsl2,r2fsl2,rtimlim,irtm,nmcpxo,'step    ',
C     -    inperr,iout)
 
Cc-----Diffusion constant calculation
C      if (iop(177) .gt. 0)
C     -  call accudiffc(nmolec,nslv,islvrep,ic00,rmins,ipxgr,
C     -    iop(5),dcgrid,rdc1,rdc2,rfsl2,r2fsl2,rgpxsltmax2,c)
 
Cc-----Dipole moment calculations - - written by Jian Sun
C      if (iop(169) .gt. 0) then
Cc       Compute the dipole moment of: system, solute and solvent
C        do is=nsltpx1,nsltpx2
C        do k=1,3
C          dipslt(k)=dipslt(k)+dpxyz(k)
C          dipsys(k)=dipsys(k)+dpxyz(k)
C        end do
C        dipslt2=dipslt2+sclprd(dpxyz,dpxyz)
C        do k=1,3
C          dipslv(k)=dipslv(k)+dpxyz(k)
C          dipsys(k)=dipsys(k)+dpxyz(k)
C          dpxyz1(k)=dpxyz1(k)+dpxyz(k)
C        end do
C        dipslv2=dipslv2+sclprd(dpxyz,dpxyz)
C        dipsys2=dipsys2+sclprd(dpxyz1,dpxyz1)
C
Cc       Calculate the dipole moment in the primary regions
C        do ig=1,nsltpxgr
C          do k=1,3
C            dipoleg(k,ig)=dipoleg(k,ig)+dpxyzg(k,ig)
C          end do
C        end do
C        do ig=1,nsltpxgr
C          dipoleg2(ig)=dipoleg2(ig)+sclprd(dpxyzg(1,ig),dpxyzg(1,ig))
C        end do
Cc       Calculate the dipole moment within the first shell
C            do j=1,nslv
C              do k=1,3
C                dipl(k,ipxgr(iw))=dipl(k,ipxgr(iw))+
C     -            c(k,iw0+j)*qslv(j)
C              end do
C            end do
C          end if
C        end do
C        do ig=1,nsltpxgr
C          do k=1,3
C            dipole0(k,ig)=dipole0(k,ig)+dpxyzg(k,ig)
C            dipole1(k,ig)=dipole1(k,ig)+dipl(k,ig)
C            ddipl(k,ig)=dipl(k,ig)-dpxyzg(k,ig)
C          end do
C        end do
C        do ig=1,nsltpxgr
C          dipole02(ig)=dipole02(ig)+sclprd(dpxyzg(1,ig),dpxyzg(1,ig))
C          dipole12(ig)=dipole12(ig)+sclprd(dipl(1,ig),dipl(1,ig))
C          dipole22(ig)=dipole22(ig)+sclprd(ddipl(1,ig),ddipl(1,ig))
C        end do
Cc       Calculate the dipole moment in the defined regions
C        do iw=2,nmolec
C            do k=1,3
C              do j=1,nslv
C                dipl(k,ipxgr(iw))=dipl(k,ipxgr(iw))+qslv(j)*c(k,iw0+j)
C              end do
C            end do
C        end do
C        do ig=1,nsltpxgr
C          do k=1,3
C            Dipole(k,ig)=Dipole(k,ig)+dipl(k,ig)
C          end do
C          Dipole2(ig)=Dipole2(ig)+sclprd(dipl(1,ig),dipl(1,ig))
C        end do
C      end if
 
Cc-----Update first shell coord no and xc(k) QCDF counters from ncorslt
C      if (iop(142) .gt. 1) then
C        do is=nsltpx1,nsltpx2
C          nxck(ncoris,indxrdf(is))=nxck(ncoris,indxrdf(is))+1
C        end do
C      end if
 
C      if (iop(147)+iop(148) .gt. 0) then
Cc-------Compute solvent-solvent pair properties
Cc       Label the waters to be used
C        nm1=nmolec-1
C        do iw=2,nm1
C     -                ngoo(id,ipxix,1)=ngoo(id,ipxix,1)+1
C            if (iop(148)*(ipxix+ipxjx) .gt. 0) then
C                if (ipxix .ne. 0) ewwis(ipxi)=ewwis(ipxi)+dble(ewwi)
C                if (ipxjx .ne. 0) ewwis(ipxj)=ewwis(ipxj)+dble(ewwi)
C                if (riijjv(jww) .le. rfsww2) then
C                  if (ipxix .ne. 0) newwnn(ipxi)=newwnn(ipxi)+1
C                  if (ipxix .ne. 0) ewwnn(ipxi)=ewwnn(ipxi)+dble(ewwi)
C                  if (ipxjx .ne. 0) newwnn(ipxj)=newwnn(ipxj)+1
C                  if (ipxjx .ne. 0) ewwnn(ipxj)=ewwnn(ipxj)+dble(ewwi)
C            end if
C        end do
C      end if
      return
      end
      subroutine mpi_resetpx
c#    MMC routine 395 lstmod: 11/27/04
c*****Sum up the analysis results accumulated on each processor into the 0th
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /h2olp/ om,sm,rmd2
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
      common /dipole/ dipslt(3),dipslt2,dipslv(3),dipslv2,
     -  dipsys(3),dipsys2,dipoleg(3,#SX),dipoleg2(#SX),
     -  Dipole(3,#SX),Dipole2(#SX),dipole0(3,#SX),dipole02(#SX),
     -  dipole1(3,#SX),dipole12(#SX),dipole22(#SX),npxww0(#SX)
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
C@TS      real*8 ftslt,ftslt2,trqbnd,trqbnd2
C@TS      common /sltfrc/ ftslt(3,#ST),ftslt2(3,#ST),
C@TS     -  trqbnd(#TR),trqbnd2(#TR)
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
C@DM      if (iop(24) .gt. 2) write (ioutdb,*) 'mpi_resetpx MYRANK=',
C@DM     -  MYRANK,' ncnfpx,nmolsum=',ncnfpx,nmolsum
C@DM      ncnfpx=0
C@DM      nmolsum=0
c         Reste torsion angle distribution
C@DM      if (iop(176) .gt. 0) then
C@DM        do it=1,ntang
C@DM          call zeroiti(itangd(1,it),0,#TD)
C@DM        end do
C@DM      end if
c--------Reset inside/outside sums
C@DM      if (iop(80) .gt. 0) then
C@DM        call zeroitd(suminout,2)
C@DM      end if
c--------Reset total g(r)
C@DM      if (iop(143) .gt. 0) then
C@DM        do is=nsltpx1,nsltpx2
C@DM          call zeroiti(ngtslt(1,indxrdf(is)),0,mxpxsltgrd)
C@DM        end do
C@DM      end if
c---------Reset conformational force contributions
C@TSC@DM        if (iop(144) .gt. 0 .and. iop(152) .eq. 1) then
C@TSC@DM          call zeroitd(ftslt,nstta3)
C@TSC@DM          call zeroitd(ftslt2,nstta3)
C@TSC@DM          call zeroitd(trqbnd,ntang)
C@TSC@DM          call zeroitd(trqbnd2,ntang)
C@TSC@DM        end if
c-----Reset Widom or chimera method contributions
      if (iop(30) .eq. 1) then
        call mpi_resetwidom
C      else if (iop(30) .eq. 2) then
C        call accuchim(c,crm,nmolec,ncnfpx,ctslvs,cutuus,
C     -    edgex2,edgey2,edge2)
      end if
      return
      end
      subroutine findprox(c,crm,nmolec,edgexa,iproxi,ixx,ixv,igtot,iskp)
c#    MMC routine 396 lstmod: 10/05/06
c*****Calculate proximal distances and proximity indices, gtot(r)'s
      dimension c(3,#NA),crm(3,#MO),iproxi(#UV),
     -  ixx(#UV),ixv(#UV)
      common /ecell/ cic(3,27),ncell
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /option/ iop(200),idebug(200)
      dimension cmi(3)
c     When no solute is present, all solvents have proximity index 1
      if (nsltpx2 .eq. 0) then
        do iw=2,nmolec
          iproxi(iw)=1
        end do
      end if
c     First find the slt-slv distance of the right slv image
      if (iop(43) .eq. 0) then
c       Molecule-based cutoff
        do iw=2,nmolec
          zv(1,iw)=c(1,ic00+iw*nslv+islvrep)-crm(1,1)
          zv(2,iw)=c(2,ic00+iw*nslv+islvrep)-crm(2,1)
          zv(3,iw)=c(3,ic00+iw*nslv+islvrep)-crm(3,1)
        end do
      else
c       Group-based cutoff
c       For each water first find the nearest solute group
        do iw=2,nmolec
          do ig=1,nsttg
            zv(1,ig)=c(1,ic00+iw*nslv+islvrep)-c(1,igrcnt(ig))
            zv(2,ig)=c(2,ic00+iw*nslv+islvrep)-c(2,igrcnt(ig))
            zv(3,ig)=c(3,ic00+iw*nslv+islvrep)-c(3,igrcnt(ig))
          end do
          call pbcvec(iop(5),1,nsttg)
C@NV          call smin(riijjv,1,nsttg,rsmin,igprox)
C@VC          call vmin(riijjv,1,nsttg,rsmin,igprox)
          ixx(iw)=ivopt(igprox)
          ixv(iw)=igprox
        end do
        do iw=2,nmolec
          zv(1,iw)=c(1,ic00+iw*nslv+islvrep)-c(1,igrcnt(ixv(iw)))+
     -      cic(1,ixx(iw))
          zv(2,iw)=c(2,ic00+iw*nslv+islvrep)-c(2,igrcnt(ixv(iw)))+
     -      cic(2,ixx(iw))
          zv(3,iw)=c(3,ic00+iw*nslv+islvrep)-c(3,igrcnt(ixv(iw)))+
     -      cic(3,ixx(iw))
        end do
      end if
      if (iop(2) .eq. 1) then
        do iw=2,nmolec
          zv(1,iw)=0.0
        end do
      end if
      call pbcvec(iop(5),2,nmolec)
      do iw=2,nmolec
c       Find the proximal solute atom
        do k=1,3
          cmi(k)=c(k,ic00+iw*nslv+islvrep)+cci(k,iw)
        end do
        iprox=0
        rsmin=1.e+5
        if (iop(2) .eq. 0) then
          do is=nsltpx1,nsltpx2
            r2stsv(is)=(cmi(1)-c(1,is))**2+(cmi(2)-c(2,is))**2+
     -        (cmi(3)-c(3,is))**2
            rij2v(is)=r2stsv(is)-rppxrad2(is)
          end do
        else
c         Periodic solute
          do is=nsltpx1,nsltpx2
            dx0=cmi(1)-c(1,is)
            r2stsv(is)=amin1(dx0*dx0,(dx0-edgexa)**2,(dx0+edgexa)**2)+
     -        (cmi(2)-c(2,is))**2+(cmi(3)-c(3,is))**2
            rij2v(is)=r2stsv(is)-rppxrad2(is)
          end do
        end if
        if (iskp .gt. 0) then
c         Mark requested atoms to be distant
          do is=nsltpx1,nsltpx2
            if (keeppx(is) .eq. 0) rij2v(is)=100000.0
          end do
        end if
C@NV        call smin(rij2v,nsltpx1,nsltpx2,rsmin,iprox)
C@VC        call vmin(rij2v,nsltpx1,nsltpx2,rsmin,iprox)
        rmins(iw)=r2stsv(iprox)
        iproxi(iw)=iprox
        if (iop(143) .gt. 0 .and. igtot .gt. 0) then
c         Compute total g(r)
          do is=nsltpx1,nsltpx2
            if (r2stsv(is) .lt. rgpxsltmax2) then
              ixv(is)=sqrt(r2stsv(is)*rripx2)+1
            else
              ixv(is)=mxpxsltgrd
            end if
C@VC          end do
C@VC          do is=nsltpx1,nsltpx2
            ngtslt(ixv(is),indxrdf(is))=ngtslt(ixv(is),indxrdf(is))+1
          end do
        end if
      end do
      return
      end
      subroutine findprox0(c,nslt,cslv,iprox,rij,ih,namax)
c#    MMC routine 397 lstmod: 20/27/14
c*****Calculate proximal distances w/o PBC
      dimension c(3,namax),cslv(3),ih(namax)
      rij2min=100000.0
      do ia=1,nslt
        if (ih(ia) .ne. 1) then
          rij2=arrdist(c(1,ia),cslv)
          if (rij2 .lt. rij2min) then
            rij2min=rij2
            iprox=ia
          end if
        end if
      end do
      rij=sqrt(rij2min)
      return
      end
      subroutine lp(c,nslv,numsolv)
c#    MMC routine 398 lstmod: 01/26/05
c*****Determine the coordinates of the "lone pair" point on the HOH bisector.
c     Used by MCY, TIPS1, TIP4P, B-F.
      dimension c(3,nslv,#MO)
      common /h2olp/ om,sm,rmd2
      do iw=1,numsolv
        r71=(c(1,2,iw)+c(1,3,iw))-2.0*c(1,1,iw)
        r72=(c(2,2,iw)+c(2,3,iw))-2.0*c(2,1,iw)
        r73=(c(3,2,iw)+c(3,3,iw))-2.0*c(3,1,iw)
        c(1,4,iw)=sm*r71+c(1,1,iw)
        c(2,4,iw)=sm*r72+c(2,1,iw)
        c(3,4,iw)=sm*r73+c(3,1,iw)
      end do
      return
      end
      subroutine permutexyz(c,natoms,ixyz)
c#    MMC routine 400 lstmod: 01/15/99
      dimension c(3,natoms),ixyz(3),cc(3)
c     Permute coordinates
      do ia=1,natoms
        call trnsfr(cc,c(1,ia),3)
        do k=1,3
          c(ixyz(k),ia)=cc(k)
        end do
      end do
      return
      end
      subroutine checkfslt(c,crm,crm0,orient,orientsltm,dihang,
     -  iconfread,iop47read,iout,ichkp,ichkpx,ncnfpx,ntang,
C@TS     -  nslt,nmolec,nfrq,dx,
     -  ttype)
c#    MMC routine 401 lstmod: 05/19/16
c*****Check the solute forces by finite difference approximation
      dimension c(3,#NA),crm(3,#MO),crm0(3,#MO),
     -  orient(3,3,#MO),orientsltm(3,3,#MM),dihang(#TR)
      character*4 ttype
      common /atforc/ fcslt(3,#ST),fcislv(3,#SV),fcjslv(3,#SV)
C@TS      real*8 ftslt,ftslt2,trqbnd,trqbnd2
C@TS      common /sltfrc/ ftslt(3,#ST),ftslt2(3,#ST),
C@TS     -  trqbnd(#TR),trqbnd2(#TR)
      common /newtor/ ifirstt(#MM),ilastt(#MM),natfix(#MM),
     -  maxbrlen(#MM),itangindx(#TR),newplace(#ST),
     -  ioldplace(#ST),nnloop(#ST),itangon(#ST),
     -  iprecursor(2,#ST),nnexttorat(#ST),nnexttormov(#ST),
     -  iri(#ST),irotlist(#ST),irotlinc(#ST),nrot(#ST),
     -  itorsionroot(#ST),iroots(#ST),iparent(#ST),
     -  loopmemat(#ST),iftmovtg(#TR),iltmovtg(#TR),numtorix(#TR),
     -  sindela(#ST),cosdela(#ST),bond(#ST),bond2(#ST),
     -  bondf(#ST),bondproj(#ST),bond12(#ST),bond13(#ST),
     -  angle(#ST),cangle(#ST),angle13(#ST),cangle13(#ST),
     -  xfac13(#ST),xfac12(#ST),tang(#ST),tangd(#ST),
     -  cangle0(#ST),cangle40(#ST),bond420(#ST),ntdiffinp
      common /option/ iop(200),idebug(200)
C@TS      real*8 ft,ftt,es
C@TS      dimension ft(3)
C@TS      data ntest /0/
      if (ncnfpx .gt. 0) call csavepx(ichkpx,1,iskipfail,6)
      call inicac
      call findor(orient,orientsltm,c,crm,crm0,iconfread,iop47read)
      if (ttype .eq. 'FSTT')
     -  call gentor(1,ntang,dihang,c,itangindx,iprecursor,nrot,iri,
     -    irotlist,irotlinc,sindela,cosdela,bondf,bondproj,xfac13,
     -    xfac12,bond,idebug(25),iout,#TR,#ST)
      call csave(ichkp,1,iskipfail,1)
C@TS      call zeroitd(ftslt,3*nslt)
C@TS      es=0.d0
C@TS      do iw=2,nmolec
C@TS        es=es+engslt(iw,riijj,riijj0,rij0,isprox,idistmv,idistid,
C@TS     -    c,crm(1,iw),crm)
C@TS        do is=1,nslt
C@TS          do k=1,3
C@TS            ftslt(k,is)=ftslt(k,is)+fcslt(k,is)
C@TS          end do
C@TS        end do
C@TS      end do
C@TS      if (ttype .eq. 'FSLT') ntest=(nslt-1)/nfrq+1
C@TS      if (ttype .eq. 'FSTT') ntest=(ntang-1)/nfrq+1
C@TS      do itest=1,ntest
C@TS        is=(itest-1)*nfrq+1
C@TS        if (ttype .eq. 'FSLT') then
C@TS          call zeroitd(ft,3)
C@TS          do k=1,3
C@TS            cc=c(k,is)
C@TS            c(k,is)=c(k,is)+dx
C@TS            do iw=2,nmolec
C@TS              ft(k)=ft(k)+engslt(iw,riijj,riijj0,rij0,
C@TS     -          isprox,idistmv,idistid,c,crm(1,iw),crm)
C@TS            end do
C@TS            c(k,is)=cc
C@TS            ft(k)=-(ft(k)-es)/dx
C@TS          end do
C@TS          write (iout,1000) is,(ftslt(k,is),k=1,3),ft,dx
C@TS        else
C@TS          call torquebond(c,is,ftslt,trq,nslt)
C@TS          dihang(is)=dihang(is)+dx
C@TS          call gentor(1,ntang,dihang,c,itangindx,iprecursor,
C@TS     -      nrot,iri,irotlist,irotlinc,sindela,cosdela,bondf,
C@TS     -      bondproj,xfac13,xfac12,bond,idebug(25),iout,#TR,#ST)
C@TS          ftt=0.d0
C@TS          do iw=2,nmolec
C@TS            ftt=ftt+engslt(iw,riijj,riijj0,rij0,
C@TS     -        isprox,idistmv,idistid,c,crm(1,iw),crm)
C@TS          end do
C@TS          ftt=(ftt-es)/dx
C@TS          write (iout,1001) is,trq,ftt,dx
C@TS          call crstr(0)
C@TS        end if
C@TS      end do
      if (ncnfpx .gt. 0) call crstrpx(0)
      return
C@TS1000  format(' Solute atom',i6,' force=',3e12.5,
C@TS     -  ' -del Eslt/del x=',3e12.5,' del x=',f6.4,' A')
C@TS1001  format(' Torsion bond',i6,' torque=',e12.5,
C@TS     -  ' -del Eslt/del phi=',e12.5,' del phi=',f6.4,' rad')
      end
      subroutine checkfslv(c,crm,crm0,orient,orientsltm,etotn,etoto,
     -  estscn,iconfread,iop47read,iout,ichkp,nmc,nslv,nslt,nmolec,nfrq,
     -  dx,dphi)
c#    MMC routine 402 lstmod: 05/04/15
c*****Check the solvent forces by finite difference approximation
      real*8 etotn,etoto,estscn
      dimension c(3,#NA),crm(3,#MO),crm0(3,#MO),
     -  orient(3,3,#MO),orientsltm(3,3,#MM)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltereq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /option/ iop(200),idebug(200)
      real*8 esmslv,ftold,trold
      dimension ft(3),tt(3),ch(3)
      dimension ftold(3),trold(3)
      call inicac
      call findor(orient,orientsltm,c,crm,crm0,iconfread,iop47read)
      call eism0(1,0,noverl,nfsslt,nfslww,ksltmn,ncor,
     -  tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -  tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -  nslvdsid,gbuupd,gbuupt,esmslv,c,crm,nmc)
      write (iout,1001) etoto
      call csave(ichkp,0,iskipfail,1)
      ntest=(nmolec-2)/nfrq+1
      do itest=1,ntest
        isolv=(itest-1)*nfrq+2
        call trnsfrd(ftold,frctot(1,isolv),3)
        call trnsfrd(trold,trqtot(1,isolv),3)
        call zeroit(ft,3)
        do k=1,3
          phi=0.0
          call zeroit(ch,3)
          ch(k)=dx
          isolv=(itest-1)*nfrq+2
          natm3=3*nslv
          icsol1=nslt+(isolv-2)*nslv+1
          call deploy(orient,c,crm,ch,phi,k)
          call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolec)
          ft(k)=-(etotn-etoto)/dx
          call crstr(0)
          call zeroit(ch,3)
          phi=dphi
          isolv=(itest-1)*nfrq+2
          natm3=3*nslv
          icsol1=nslt+(isolv-2)*nslv+1
          call deploy(orient,c,crm,ch,phi,k)
          call engcha(etotn,etoto,estscn,isolv,tesi,c,crm,nmolec)
          tt(k)=-(etotn-etoto)/dphi
        end do
        write (iout,1000)
     -    (itest-1)*nfrq+2,' force',ftold,'x  ',ft,dx,'A'
        write (iout,1000)
     -    (itest-1)*nfrq+2,'torque',trold,'phi',tt,dphi,'rad'
      end do
1000  format(' Solvent',i6,1x,a,'=',3e12.5,' -del E/del ',a,'=',3e12.5,
     -  ' del=',f6.4,1x,a)
1001  format(' Total energy=',e15.8)
      return
      end
C@FG      subroutine initfldgrd(nmolec,nfg,nsttm)
C@FGc#    MMC routine 403 lstmod: 05/25/03
C@FGc*****Initialize field gradient contributions
C@FG      real*8 fguuacc,fguvacc,fgvuacc,fgvvacc,fgusacc,fgvsacc
C@FG      common /fieldgrad/
C@FG     -  fguuacc(6,#MM,#GQ),fguvacc(6,#MM,#GQ),
C@FG     -  fgusacc(6,#MM),fgvsacc(6,#MG),fgvuacc(6,#MG,#GQ),
C@FG     -  fgvvacc(6,#MG,#GQ),nusedfgr(#MO),
C@FG     -  fgruucut,fgruvcut,fgrvvcut,rproxfgmax,
C@FG     -  fgruucut2,fgruvcut2,fgrvvcut2,rproxfgmax2
C@FG      common /option/ iop(200),idebug(200)
C@FG        call zeroiti(nusedfgr,0,nmolec)
C@FG        do im=1,nsttm
C@FG          do ifg=1,nfg
C@FG            call zeroitd(fguuacc(1,im,ifg),6)
C@FG            call zeroitd(fguvacc(1,im,ifg),6)
C@FG          end do
C@FG          call zeroitd(fgusacc(1,im),6)
C@FG        end do
C@FG        if (iop(179) .gt. 0) then
C@FG          do is=2,nmolec
C@FG            do ifg=1,nfg
C@FG              call zeroitd(fgvuacc(1,is,ifg),6)
C@FG              call zeroitd(fgvvacc(1,is,ifg),6)
C@FG            end do
C@FG            call zeroitd(fgvsacc(1,is),6)
C@FG          end do
C@FG        end if
C@FG      return
C@FG      end
      subroutine accufldgrd(ncnfpx,iproxi,rmins,qsltep,dielc,nmolec)
c#    MMC routine 404 lstmod: 05/25/03
c*****Calculate field gradient contributions
      dimension iproxi(#UV),rmins(#MO),qsltep(#ST)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
C@FG      real*8 fguuacc,fguvacc,fgvuacc,fgvvacc,fgusacc,fgvsacc
      common /fieldgrad/
C@FG     -  fguuacc(6,#MM,#GQ),fguvacc(6,#MM,#GQ),
C@FG     -  fgusacc(6,#MM),fgvsacc(6,#MG),fgvuacc(6,#MG,#GQ),
C@FG     -  fgvvacc(6,#MG,#GQ),nusedfgr(#MO),
     -  fgruucut,fgruvcut,fgrvvcut,rproxfgmax,
     -  fgruucut2,fgruvcut2,fgrvvcut2,rproxfgmax2
      common /ecell/ cic(3,27),ncell
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      real*8 fgruu,fgruv,fgrvu,fgrvv,fgtot,fgslt
      dimension fgruu(6,#GQ),fgruv(6,#GQ),fgrvu(6,#GQ),
     -  fgrvv(6,#GQ),fgtot(6),fgslt(6),iproxst(#MM),
     -  fgusp(6,#GQ),fgvsp(6,#GQ),fgtotsp(6),fgsltsp(6)
      dimension z(3),cc(3),cpbc(3),qslvep(#SV)
      if (iop(166) .eq. 1 .or. iop(166) .eq. 3) then
        write (ifldgpx) ncnfpx,fgruucut,fgruvcut,fgrvvcut,rproxfgmax,
     -    movmolf,movmoll,nmolec,nfg
      else
        write (ifldgpx,1000) ncnfpx,fgruucut,fgruvcut,fgrvvcut,
     -    rproxfgmax,movmolf,movmoll,nmolec-1,nfg
      end if
      do ia=1,nstta
        qsltep(ia)=qslt(ia)/dielc
      end do
      do ia=1,nslv
        qslvep(ia)=qslv(ia)/dielc
      end do
c     Determine the moving solute molecules' proximity indices
      call zeroiti(iproxst,0,nsttm)
      if (movmoll-movmolf+1 .eq. nsttm) then
c       No non-moving solute - iproxst should refer to the molec itself
        do imc=movmolf,movmoll
          iproxst(imc)=imc
        end do
      else
        do imc=movmolf,movmoll
          call trnsfr(cc,c(1,molcnt(imc)),3)
          riijjmin=1.e+10
          do ia=1,nstta
            if ((iamolslt(ia) .lt. movmolf .or.
     -           iamolslt(ia) .gt. movmoll) .and.
     -        (iop(168) .eq. 0 .or. ianslt(ia) .ne. 1)) then
              call arrdiff(z,c(1,ia),cc,3)
              call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
              if (riijj .lt. riijjmin) then
                riijjmin=riijj
                iproxst(imc)=indxrdf(ia)
              end if
            end if
          end do
        end do
      end if
c     Calculate the field gradients at the site of each moving solute molecule
      do imc=movmolf,movmoll
        call trnsfr(cc,c(1,molcnt(imc)),3)
        call zeroitd(fgslt,6)
        do ifg=1,nfg
          call zeroitd(fgruu(1,ifg),6)
          call zeroitd(fgruv(1,ifg),6)
        end do
        if (iop(43) .eq. 0) then
          do im=1,nsttm
c           Calculate the field gradients at solute imc from molec im
            if (im .ne. imc) then
              call arrdiff(z,c(1,molcnt(im)),cc,3)
              call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
              if (riijj .lt. fgruucut2) then
                call arrdiff(cpbc,cc,cic(1,iopt),3)
                ifg=iproxst(im)
                if (ifg .eq. 0) then
                  do ia=ifirstm(im),ilastm(im)
                    call fgrdaccu(c(1,ia),cpbc,qsltep(ia),fgslt(1),
     -                fgslt(2),fgslt(3),fgslt(4),fgslt(5),fgslt(6))
                  end do
                else
                  do ia=ifirstm(im),ilastm(im)
                    call fgrdaccu(c(1,ia),cpbc,qsltep(ia),
     -                fgruu(1,ifg),fgruu(2,ifg),fgruu(3,ifg),
     -                fgruu(4,ifg),fgruu(5,ifg),fgruu(6,ifg))
                  end do
                end if
              end if
            end if
          end do
        else
          do ig=1,nsttg
            if (iamolslt(igrcnt(ig)) .ne. imc) then
              call arrdiff(z,c(1,igrcnt(ig)),cc,3)
              call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
              if (riijj .lt. fgruucut2) then
                call arrdiff(cpbc,cc,cic(1,iopt),3)
                ifg=iproxst(iamolslt(ifgrslt(ig)))
                if (ifg .eq. 0) then
                  do ia=ifgrslt(ig),ilgrslt(ig)
                    call fgrdaccu(c(1,ia),cpbc,qsltep(ia),fgslt(1),
     -                fgslt(2),fgslt(3),fgslt(4),fgslt(5),fgslt(6))
                  end do
                else
                  do ia=ifgrslt(ig),ilgrslt(ig)
                    call fgrdaccu(c(1,ia),cpbc,qsltep(ia),
     -                fgruu(1,ifg),fgruu(2,ifg),fgruu(3,ifg),
     -                fgruu(4,ifg),fgruu(5,ifg),fgruu(6,ifg))
                  end do
                end if
              end if
            end if
          end do
        end if
        do is=2,nmolec
c         Calculate the field gradient at solute molec imc from solvent is
          call arrdiff(z,c(1,ic00+is*nslv+islvrep),cc,3)
          call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
          if (riijj .lt. fgruvcut2) then
            call arrdiff(cpbc,cc,cic(1,iopt),3)
            ifg=indxrdf(iproxi(is))
            do ia=1,nslv
              call fgrdaccu(c(1,ic00+is*nslv+ia),cpbc,qslvep(ia),
     -          fgruv(1,ifg),fgruv(2,ifg),fgruv(3,ifg),
     -          fgruv(4,ifg),fgruv(5,ifg),fgruv(6,ifg))
            end do
          end if
        end do
c       Accumulate and sum contributions to the fg components on slt molec imc
        call trnsfrd(fgtot,fgslt,6)
C@FG        do ifg=1,nfg
C@FG          call arrsumd(fguuacc(1,imc,ifg),fguuacc(1,imc,ifg),
C@FG     -      fgruu(1,ifg),6)
C@FG          call arrsumd(fguvacc(1,imc,ifg),fguvacc(1,imc,ifg),
C@FG     -      fgruv(1,ifg),6)
C@FG          call arrsumd(fgtot,fgtot,fgruu(1,ifg),6)
C@FG          call arrsumd(fgtot,fgtot,fgruv(1,ifg),6)
C@FG        end do
C@FG        call arrsumd(fgusacc(1,imc),fgusacc(1,imc),fgslt,6)
        if (iop(166) .eq. 1) then
          do k=1,6
            fgtotsp(k)=fgtot(k)
            fgsltsp(k)=fgslt(k)
            do ifg=1,nfg
              fgusp(k,ifg)=fgruu(k,ifg)
              fgvsp(k,ifg)=fgruv(k,ifg)
            end do
          end do
          write (ifldgpx) imc,iproxst(imc),cc,fgtotsp,fgsltsp,
     -      ((fgusp(k,ifg),k=1,6),ifg=1,nfg),
     -      ((fgvsp(k,ifg),k=1,6),ifg=1,nfg)
        else if (iop(166) .eq. 3) then
          do k=1,6
            fgtotsp(k)=fgtot(k)
          end do
          write (ifldgpx) imc,iproxst(imc),cc,fgtotsp
        else if (iop(166) .eq. 2 .or. iop(166) .eq. 4) then
          write (ifldgpx,1001) 'Solute ',imc,iproxst(imc),cc
          write (ifldgpx,1002) fgtot
          if (iop(166) .eq. 2) then
            write (ifldgpx,1004) fgslt
            write (ifldgpx,1005) ((fgruu(k,ifg),k=1,6),ifg=1,nfg)
            write (ifldgpx,1006) ((fgruv(k,ifg),k=1,6),ifg=1,nfg)
          end if
        end if
      end do
c     Count and print the number of solvents used in this config.
      nusedslv=0
      do isv=2,nmolec
        if (rmins(isv) .le. rproxfgmax2) nusedslv=nusedslv+1
      end do
      if (iop(166) .eq. 1 .or. iop(166) .eq. 3) then
        write (ifldgpx) ncnfpx,nusedslv
      else
        write (ifldgpx,1010) ncnfpx,nusedslv
      end if
      if (iop(179) .eq. 0) then
        do isv=2,nmolec
          if (rmins(isv) .le. rproxfgmax2) then
C@FG            nusedfgr(isv)=nusedfgr(isv)+1
            call zeroitd(fgslt,6)
            do ifg=1,nfg
              call zeroitd(fgrvu(1,ifg),6)
              call zeroitd(fgrvv(1,ifg),6)
            end do
            call trnsfr(cc,c(1,ic00+isv*nslv+islvrep),3)
            if (iop(43) .eq. 0) then
              do im=1,nsttm
c               Calculate the field gradient at solvent isv from molec im
                call arrdiff(z,c(1,molcnt(im)),cc,3)
                call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
                if (riijj .lt. fgruvcut2) then
                  call arrdiff(cpbc,cc,cic(1,iopt),3)
                  ifg=iproxst(im)
                  if (ifg .eq. 0) then
                    do ia=ifirstm(im),ilastm(im)
                      call fgrdaccu(c(1,ia),cpbc,qsltep(ia),fgslt(1),
     -                  fgslt(2),fgslt(3),fgslt(4),fgslt(5),fgslt(6))
                    end do
                  else
                    do ia=ifirstm(im),ilastm(im)
                      call fgrdaccu(c(1,ia),cpbc,qsltep(ia),
     -                  fgrvu(1,ifg),fgrvu(2,ifg),fgrvu(3,ifg),
     -                  fgrvu(4,ifg),fgrvu(5,ifg),fgrvu(6,ifg))
                    end do
                  end if
                end if
              end do
            else
              do ig=1,nsttg
                call arrdiff(z,c(1,igrcnt(ig)),cc,3)
                call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
                if (riijj .lt. fgruvcut2) then
                  call arrdiff(cpbc,cc,cic(1,iopt),3)
                  ifg=iproxst(iamolslt(ifgrslt(ig)))
                  if (ifg .eq. 0) then
                    do ia=ifgrslt(ig),ilgrslt(ig)
                      call fgrdaccu(c(1,ia),cpbc,qsltep(ia),fgslt(1),
     -                  fgslt(2),fgslt(3),fgslt(4),fgslt(5),fgslt(6))
                    end do
                  else
                    do ia=ifgrslt(ig),ilgrslt(ig)
                      call fgrdaccu(c(1,ia),cpbc,qsltep(ia),
     -                  fgrvu(1,ifg),fgrvu(2,ifg),fgrvu(3,ifg),
     -                  fgrvu(4,ifg),fgrvu(5,ifg),fgrvu(6,ifg))
                    end do
                  end if
                end if
              end do
            end if
            do is=2,nmolec
c             Calculate the field gradient at solvent isv from solvent is
              if (is .ne. isv) then
                call arrdiff(z,c(1,ic00+is*nslv+islvrep),cc,3)
                call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
                if (riijj .lt. fgrvvcut2) then
                  ifg=indxrdf(iproxi(is))
                  call arrdiff(cpbc,cc,cic(1,iopt),3)
                  do ia=1,nslv
                    call fgrdaccu(c(1,ic00+is*nslv+ia),cpbc,qslvep(ia),
     -                fgrvv(1,ifg),fgrvv(2,ifg),fgrvv(3,ifg),
     -                fgrvv(4,ifg),fgrvv(5,ifg),fgrvv(6,ifg))
                  end do
                end if
              end if
            end do
c           Accumulate and sum contribs to the fg components on slv molec isv
C@FG            call trnsfrd(fgtot,fgslt,6)
C@FG            do ifg=1,nfg
C@FG              call arrsumd(fgvuacc(1,isv,ifg),fgvuacc(1,isv,ifg),
C@FG     -          fgrvu(1,ifg),6)
C@FG              call arrsumd(fgvvacc(1,isv,ifg),fgvvacc(1,isv,ifg),
C@FG     -          fgrvv(1,ifg),6)
C@FG              call arrsumd(fgtot,fgtot,fgrvu(1,ifg),6)
C@FG              call arrsumd(fgtot,fgtot,fgrvv(1,ifg),6)
C@FG            end do
C@FG            call arrsumd(fgvsacc(1,isv),fgvsacc(1,isv),fgslt,6)
            if (iop(166) .eq. 1) then
              do k=1,6
                fgtotsp(k)=fgtot(k)
                fgsltsp(k)=fgslt(k)
                do ifg=1,nfg
                  fgusp(k,ifg)=fgrvu(k,ifg)
                  fgvsp(k,ifg)=fgrvv(k,ifg)
                end do
              end do
              write (ifldgpx) isv,iproxi(isv),cc,fgtotsp,fgsltsp,
     -          ((fgusp(k,ifg),k=1,6),ifg=1,nfg),
     -          ((fgusp(k,ifg),k=1,6),ifg=1,nfg)
            else if (iop(166) .eq. 3) then
              do k=1,6
                fgtotsp(k)=fgtot(k)
              end do
              write (ifldgpx) isv,iproxi(isv),cc,fgtotsp
            else if (iop(166) .eq. 2 .or. iop(166) .eq. 4) then
              write (ifldgpx,1001) 'Solvent',isv,iproxi(isv),cc
              write (ifldgpx,1003) fgtot
              if (iop(166) .eq. 2) then
                write (ifldgpx,1004) fgslt
                write (ifldgpx,1005) ((fgrvu(k,ifg),k=1,6),ifg=1,nfg)
                write (ifldgpx,1006) ((fgrvv(k,ifg),k=1,6),ifg=1,nfg)
              end if
            end if
          end if
        end do
      end if
      return
1000  format(' Field gradient snapshot ',i5,/,
     -  ' Cutoffs for solute-solute, solute-solvent and ',
     -  'solvent-solvent:',3f8.2,' A',/,
     -  ' Solvent proxi cutoff=',f6.2,' A',/,
     -  ' Solute molecule range: ',2i5,/,
     -  ' Number of solvent molecules=',i8,
     -  ' Number of functional groups=',i4)
1001  format(1x,a,i5,' ipx=',i6,' c=',3f10.5)
1002  format(' fgtu11=',e12.5,' fgtu22=',e12.5,' fgtu33=',e12.5,
     -  ' fgtu12=',e12.5,' fgtu13=',e12.5,' fgtu23=',e12.5)
1003  format(' fgtv11=',e12.5,' fgtv22=',e12.5,' fgtv33=',e12.5,
     -  ' fgtv12=',e12.5,' fgtv13=',e12.5,' fgtv23=',e12.5)
1004  format(' fgst11=',e12.5,' fgst22=',e12.5,' fgst33=',e12.5,
     -  ' fgst12=',e12.5,' fgst13=',e12.5,' fgst23=',e12.5)
1005  format(' fgpu11=',e12.5,' fgpu22=',e12.5,' fgpu33=',e12.5,
     -   ' fgpu12=',e12.5,' fgpu13=',e12.5,' fgpu23=',e12.5)
1006  format(' fgpv11=',e12.5,' fgpv22=',e12.5,' fgpv33=',e12.5,
     -   ' fgpv12=',e12.5,' fgpv13=',e12.5,' fgpv23=',e12.5)
1010  format(' Snapshot ',i6,' Number of solvents used=',i6)
      end
      subroutine fgrdaccu(c,cref,q,fg11,fg22,fg33,fg12,fg13,fg23)
c#    MMC routine 405 lstmod: 10/16/00
c*****Accumulate field gradient contributions from one atom c at cref
      dimension c(3),cref(3)
      real*8 fg11,fg22,fg33,fg12,fg13,fg23
      rij2=arrdist(c,cref)
      zv1=c(1)-cref(1)
      zv2=c(2)-cref(2)
      zv3=c(3)-cref(3)
      rij=sqrt(rij2)
      qr=q/(rij*rij2*rij2)
      fg11=fg11+dble((rij2-3.0*zv1*zv1)*qr)
      fg22=fg22+dble((rij2-3.0*zv2*zv2)*qr)
      fg33=fg33+dble((rij2-3.0*zv3*zv3)*qr)
      fg12=fg12-dble(3.0*zv1*zv2*qr)
      fg13=fg13-dble(3.0*zv1*zv3*qr)
      fg23=fg23-dble(3.0*zv2*zv3*qr)
      return
      end
      subroutine disfinfldgrd(nmolec,nfg,nsttm,ncnfpx,movmolf,movmoll,
     -  iout)
c#    MMC routine 406 lstmod: 11/06/03
c*****Print field gradient resultss
C@FG      real*8 fguuacc,fguvacc,fgvuacc,fgvvacc,fgusacc,fgvsacc
      common /fieldgrad/
C@FG     -  fguuacc(6,#MM,#GQ),fguvacc(6,#MM,#GQ),
C@FG     -  fgusacc(6,#MM),fgvsacc(6,#MG),fgvuacc(6,#MG,#GQ),
C@FG     -  fgvvacc(6,#MG,#GQ),nusedfgr(#MO),
     -  fgruucut,fgruvcut,fgrvvcut,rproxfgmax,
     -  fgruucut2,fgruvcut2,fgrvvcut2,rproxfgmax2
      common /option/ iop(200),idebug(200)
      real*8 fgru,fgrv,fgtot
      dimension fgru(6),fgrv(6),fgtot(6),fgslt(6)
      do im=1,nsttm
        call zeroitd(fgtot,6)
        do k=1,6
C@FG          fgslt(k)=fgusacc(k,im)/dfloat(ncnfpx)
        end do
        do ifg=1,nfg
          do k=1,6
C@FG            fgru(k)=fguuacc(k,im,ifg)/dfloat(ncnfpx)
C@FG            fgrv(k)=fguvacc(k,im,ifg)/dfloat(ncnfpx)
C@FG            fgtot(k)=fgtot(k)+fgru(k)+fgrv(k)
          end do
          if (iop(166) .gt. 2) then
            write (iout,2127) 'Solute',im,ifg,'solute',ncnfpx
            write (iout,2128) fgru
            write (iout,2127) 'Solute',im,ifg,'solvent',ncnfpx
            write (iout,2128) fgrv
          end if
        end do
        if (iop(166) .gt. 2 .and. nsttm .gt. movmoll-movmolf+1) then
          write (iout,2129) 'Solute',ncnfpx
          write (iout,2128) fgslt
        end if
        write (iout,2126) 'Solute',im,ncnfpx
        write (iout,2128) fgtot
      end do
      if (iop(179) .eq. 0) then
        do is=2,nmolec
C@FG        if (nusedfgr(is) .gt. 0) then
C@FG            do k=1,6
C@FG              fgslt(k)=fgvsacc(k,im)/dfloat(ncnfpx)
C@FG            end do
            do ifg=1,nfg
              do k=1,6
C@FG                fgru(k)=fgvuacc(k,is,ifg)/dfloat(nusedfgr(is))
C@FG                fgrv(k)=fgvvacc(k,is,ifg)/dfloat(nusedfgr(is))
C@FG                fgtot(k)=fgtot(k)+fgru(k)+fgrv(k)
              end do
              if (iop(166) .gt. 2) then
C@FG                write (iout,2127) 'Solvent',is-1,ifg,
C@FG     -            'solute',nusedfgr(is)
C@FG                write (iout,2128) fgru
C@FG                write (iout,2127)
C@FG     -            'Solvent',is-1,ifg,'solvent',nusedfgr(is)
                write (iout,2128) fgrv
              end if
              if (iop(166) .gt. 2 .and.
     -            nsttm .gt. movmoll-movmolf+1) then
C@FG                write (iout,2129) 'Solvent',nusedfgr(is)
                write (iout,2128) fgslt
              end if
            end do
C@FG          end if
C@FG          write (iout,2126) 'Solvent',is-1,nusedfgr(is)
          write (iout,2128) fgtot
        end do
      end if
      return
2126  format(1x,a,' molecule ',i6,' Field gradients averaged over ',
     -  i5,' configurations:')
2127  format(1x,a,' molecule ',i6,' Field gradient contributions from ',
     -  'the ',i4,'-th ',a,' functional group averaged over ',
     -  i5,' configurations:')
2128  format(' fgxx=',e12.5,' fgyy=',e12.5,' fgzz=',e12.5,
     -  ' fgxy=',e12.5,' fgxz=',e12.5,' fgyz=',e12.5)
2129  format(1x,a,' molecule ',i6,' Field gradient contributions from ',
     -  'the non-mobile solut averaged over ',i5,' configurations:')
      end
      subroutine initengdec(nstta,inperr,iout)
c#    MMC routine 407 lstmod: 04/18/11
c*****Initialize energy decomposition accumulators
      real*8 eiess,ei12s,ei6s,eiRs,eies14s,ei614s,ei1214s,eiR14s,
     -  eiesws,ei6ws,ei12ws,eiRws,eiess2,ei12s2,ei6s2,eiRs2,eies14s2,
     -  ei614s2,ei1214s2,eiR14s2,eiesws2,ei6ws2,ei12ws2,eiRws2,
     -  eiessg2,ei12sg2,ei6sg2,eies14sg2,ei614sg2,ei1214sg2,
     -  gvesg2,gv6g2,gv12g2,nnbs2,ntvs2
      common /engdec/ eiess(#DT,2),ei12s(#DT,2),ei6s(#DT,2),
     -  eies14s(#DT,2),ei614s(#DT,2),ei1214s(#DT,2),
     -  eiesws(#DT),ei6ws(#DT),ei12ws(#DT),
     -  eiess2(#DT),ei12s2(#DT),ei6s2(#DT),
     -  eies14s2(#DT),ei614s2(#DT),ei1214s2(#DT),
     -  eiessg2(#DT,2),ei12sg2(#DT,2),ei6sg2(#DT,2),
     -  eies14sg2(#DT,2),ei614sg2(#DT,2),ei1214sg2(#DT,2),
     -  gvesg2(#DT),gv6g2(#DT),gv12g2(#DT),
     -  eiRws(#DT),eiR14s(#DT),eiRs(#DT),eiRs2(#DT),
     -  eiR14s2(#DT),eiesws2(#DT),ei6ws2(#DT),ei12ws2(#DT),
     -  eiRws2(#DT),nnbs2(#DT),ntvs2(#DT),
     -  n14s2(#DT),nnbs(#DT),n14s(#DT),ntvs(#DT),
     -  iexcludetyp,iafrst,ialast,igf,igl,
     -  iafrst2,ialast2,igf2,igl2,ctonnb,ctonnb2,ctdiff3,shfr,swr
      common /option/ iop(200),idebug(200)
c     Shift and switch factors set to one (only Charmm uses them)
      shfr=1.0
      swr=1.0
      call checkdim(ifailt,iout,inperr,'DT',nstta,0,0,0)
      if (ifailt .gt. 0) return
      if (iop(160) .eq. 3) return
      do i=1,nstta
        do j=1,2
          eiess(i,j)=0.d0
          ei12s(i,j)=0.d0
          ei6s(i,j)=0.d0
          eies14s(i,j)=0.d0
          ei614s(i,j)=0.d0
          ei1214s(i,j)=0.d0
          eiessg2(i,j)=0.d0
          ei12sg2(i,j)=0.d0
          ei6sg2(i,j)=0.d0
          eies14sg2(i,j)=0.d0
          ei614sg2(i,j)=0.d0
          ei1214sg2(i,j)=0.d0
        end do
        eiess2(i)=0.d0
        ei12s2(i)=0.d0
        ei6s2(i)=0.d0
        eies14s2(i)=0.d0
        ei614s2(i)=0.d0
        ei1214s2(i)=0.d0
        gvesg2(i)=0.d0
        gv6g2(i)=0.d0
        gv12g2(i)=0.d0
        eiRs(i)=0.d0
        eiR14s(i)=0.d0
        eiesws(i)=0.d0
        ei6ws(i)=0.d0
        ei12ws(i)=0.d0
        eiRws(i)=0.d0
        eiRs2(i)=0.d0
        eiR14s2(i)=0.d0
        eiesws2(i)=0.d0
        ei6ws2(i)=0.d0
        ei12ws2(i)=0.d0
        eiRws2(i)=0.d0
        nnbs(i)=0
        n14s(i)=0
        ntvs(i)=0
        nnbs2(i)=0.d0
        n14s2(i)=0
        ntvs2(i)=0.d0
      end do
      return
      end
      subroutine accuengdec
c#    MMC routine 408 lstmod: 03/03/08
c*****Initialize energy decomposition accumulators
      real*8 eiess,ei12s,ei6s,eiRs,eies14s,ei614s,ei1214s,eiR14s,
     -  eiesws,ei6ws,ei12ws,eiRws,eiess2,ei12s2,ei6s2,eiRs2,eies14s2,
     -  ei614s2,ei1214s2,eiR14s2,eiesws2,ei6ws2,ei12ws2,eiRws2,
     -  eiessg2,ei12sg2,ei6sg2,eies14sg2,ei614sg2,ei1214sg2,
     -  gvesg2,gv6g2,gv12g2,nnbs2,ntvs2
      common /engdec/ eiess(#DT,2),ei12s(#DT,2),ei6s(#DT,2),
     -  eies14s(#DT,2),ei614s(#DT,2),ei1214s(#DT,2),
     -  eiesws(#DT),ei6ws(#DT),ei12ws(#DT),
     -  eiess2(#DT),ei12s2(#DT),ei6s2(#DT),
     -  eies14s2(#DT),ei614s2(#DT),ei1214s2(#DT),
     -  eiessg2(#DT,2),ei12sg2(#DT,2),ei6sg2(#DT,2),
     -  eies14sg2(#DT,2),ei614sg2(#DT,2),ei1214sg2(#DT,2),
     -  gvesg2(#DT),gv6g2(#DT),gv12g2(#DT),
     -  eiRws(#DT),eiR14s(#DT),eiRs(#DT),eiRs2(#DT),
     -  eiR14s2(#DT),eiesws2(#DT),ei6ws2(#DT),ei12ws2(#DT),
     -  eiRws2(#DT),nnbs2(#DT),ntvs2(#DT),
     -  n14s2(#DT),nnbs(#DT),n14s(#DT),ntvs(#DT),
     -  iexcludetyp,iafrst,ialast,igf,igl,
     -  iafrst2,ialast2,igf2,igl2,ctonnb,ctonnb2,ctdiff3,shfr,swr
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /ecell/ cic(3,27),ncell
      real*8 uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /frind1/ uind12,uind6,uind1,uitot,xslt12,xslt6,xslt1
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
C@TNC@NL      logical mapbitu
C@TN      common /nneigtu/ mapbitu(#UW,#ST),nlastwt,nsltmp
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /sltslt/ c6tt(#UU,#UU),c12tt(#UU,#UU),
     -  c6tt14(#UU,#UU),c12tt14(#UU,#UU)
      common /esltcn/ islvtp(#SV),qji(#ST,2),c6ji(#ST,2),
     -  c12ji(#ST,2),qslteps(#ST),sigmaw,epsilonw
      common /genslv/ qvv(#GV,#GV),c6vv(#GV,#GV),c12vv(#GV,#GV),
     -  qtv(#GT,#GV),c6tv(#GT,#GV),c12tv(#GT,#GV),iclslv(#GV)
      common /gather/ ntermwi(#UV),ntermnbi(#UV),nterm14i(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  eiRw(#UV),eiR(#UV),eiR14(#UV),
     -  ei614(#UV,2),eies14(#UV,2),ei1214(#UV,2)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      real*8 eies,ei12,ei6,eiesw,ei12w,ei6w
      dimension eies(#DT,2),ei12(#DT,2),ei6(#DT,2),
     -  eiesw(#DT),ei12w(#DT),ei6w(#DT)
      dimension z(3)
      real*8 enges,eng6,eng12,engesw,eng6w,eng12w,engR,engR14,engRw,
     -  gtes,gt6,gt12,gtes14,gt614,gt1214,gtLJ,gves,gv6,gv12,gvLJ
      dimension gtes(2),gt6(2),gt12(2),gtes14(2),gt614(2),gt1214(2),
     -  gtLJ(2),
     -  enges(2),eng6(2),eng12(2),enges14(2),eng614(2),eng1214(2)
      character*5 inin
      common /interintra/ inin(2)
      data eng120 /0.0/,eng60 /0.0/,eng12140 /0.0/,eng6140 /0.0/
      if (iop(174) .eq. 2 .or. iop(160) .eq. 3) write (iout,1005)
      if (iop(174) .eq. 2) write (iout,2000) nmc
      if (idebug(48) .gt. 0) write (iout,3000) esf14,vdwf14
      do ig=igf,igl
        do i=1,2
          gtes(i)=0.d0
          gt6(i)=0.d0
          gt12(i)=0.d0
          gtes14(i)=0.d0
          gt614(i)=0.d0
          gt1214(i)=0.d0
          gtLJ(i)=0.d0
        end do
        gves=0.d0
        gv6=0.d0
        gv12=0.d0
        gvLJ=0.d0
        nnbgs=0
        n14gs=0
        ntvgs=0
        im=iamolslt(ifgrslt(ig))
c       Solute-solute terms
        if (iop(3) .eq. 5) then
c         Charmm
          do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
            if (idebug(48) .gt. 1)
     -        write (iout,3001) ig,ia,(c(k,ia),k=1,3)
            ntermnb=0
            do ja=1,nstta
              l1(ja)=1
            end do
            ifim=ifirstm(iamolslt(ia))
            ilim=ilastm(iamolslt(ia))
C@TN            call readbitc(mapbitu,ia,l1(ifim),1,ilim-ifim+1,
C@TN     -        #UW,#ST,nbits)
            if (iexcludetyp .eq. 2) then
c             Exclude interactions within the same group
              call zeroiti(l1,ifgrslt(ig)-1,
     -          ilgrslt(ig)-ifgrslt(ig)+1)
            else if (iexcludetyp .eq. 3) then
c             Exclude interactions within the same solute molecule
              call zeroiti(l1,ifirstm(im)-1,
     -          ilastm(im)-ifirstm(im)+1)
            end if
            if (iafrst2 .gt. 1) call zeroiti(l1,0,iafrst2-1)
            if (ialast2 .lt. nstta)
     -        call zeroiti(l1,ialast2,nstta-ialast2)
            if (idebug(48) .gt. 3)
     -        write (iout,3002) ia,(l1(ja),ja=1,nstta)
            l1(ia)=0
            do i=1,2
              enges(i)=0.d0
              eng6(i)=0.d0
              eng12(i)=0.d0
            end do
            engR=0.d0
            do ja=1,nstta
              if (l1(ja) .gt. 0) then
                do k=1,3
c                 z(k)=c(k,igrcnt(igrslt(ia)))-c(k,igrcnt(igrslt(ja)))
                  z(k)=c(k,ia)-c(k,ja)
                end do
                call pbcnd(z(1),z(2),z(3),iop(5),ioppbc,riijj)
                if (riijj .le. cutuus) then
                  igx=1
                  if (ig .eq. igrslt(ja)) igx=2
                  ntermnb=ntermnb+1
c                 rij2=0.0
c                 do k=1,3
c                   rij2=rij2+(c(k,ia)-c(k,ja)+cic(k,ioppbc))**2
c                 end do
                  rij2=riijj
                  rij6=rij2*rij2*rij2
                  rij12=rij6*rij6
                  rrc2=rij2/cutuus
                  rij=sqrt(rij2)
                  if (ctdiff3 .gt. 0.0) then
                    if (riijj .gt. ctonnb2) then
                      rijsw=sqrt(riijj)
                      swr=((cutuu-rijsw)**2*
     -                   (cutuu+2.0*rijsw-3.0*ctonnb))/ctdiff3
                    else
                      swr=1.0
                    end if
                  end if
                  shfr=1.0-2.0*rrc2+rrc2*rrc2
                  if (c6tt(iclsltt(ia),iclsltt(ja)) .ne. 0.0) then
                    eng120=swr*c12tt(iclsltt(ia),iclsltt(ja))/rij12
                    eng12(igx)=eng12(igx)+eng120
                    eng60=swr*c6tt(iclsltt(ia),iclsltt(ja))/rij6
                    eng6(igx)=eng6(igx)+eng60
                    sgmij=(c12tt(iclsltt(ia),iclsltt(ja))/
     -                    c6tt(iclsltt(ia),iclsltt(ja)))**(1./6.)
                    engR=engR+(eng120-eng60/02.)/sgmij
                  end if
                  enges(igx)=enges(igx)+shfr*qslt(ia)*qslt(ja)/rij
                  if (idebug(48) .gt. 2) then
                    enlj=+swr*(eng120-eng60)
                    enes=shfr*(qslt(ia)*qslt(ja)/rij)/dielc
                    write (iout,3003) ia,ja,ioppbc,rij,enLJ,enes,
     -                shfr,swr
                  end if
                end if
              end if
            end do
            do i=1,2
              eies(ia,i)=enges(i)/dielc
              ei12(ia,i)=eng12(i)
              ei6(ia,i)=eng6(i)
            end do
            eiR(ia)=engR*12.0
            ntermnbi(ia)=ntermnb
            if (iop(160) .ne. 3) then
              do i=1,2
                eiess(ia,i)=eiess(ia,i)+eies(ia,i)
                ei12s(ia,i)=ei12s(ia,i)+ei12(ia,i)
                ei6s(ia,i)=ei6s(ia,i)+ei6(ia,i)
              end do
              eiess2(ia)=eiess2(ia)+(eies(ia,1)+eies(ia,2))**2
              ei12s2(ia)=ei12s2(ia)+(ei12(ia,1)+ei12(ia,2))**2
              ei6s2(ia)=ei6s2(ia)+(ei6(ia,1)+ei6(ia,2))**2
              eiRs(ia)=eiRs(ia)+eiR(ia)
              eiRs2(ia)=eiRs2(ia)+dble(eiR(ia))**2
              nnbs(ia)=nnbs(ia)+ntermnb
              nnbs2(ia)=nnbs2(ia)+ntermnb**2
            end if
          end do
        else
c         Amber
c         Find out which groups will interact with atoms of group ig
          do igg=igf2,igl2
c           First calculate nearest group-group distance
            do k=1,3
              z(k)=c(k,igrcnt(ig))-c(k,igrcnt(igg))
            end do
            call pbcnd(z(1),z(2),z(3),iop(5),ioppbc,riijj)
            if (riijj .lt. cutuus) then
              l2(igg)=1
            else
              do iaa=ifgrslt(ig),ilgrslt(ig)
                do jaa=ifgrslt(igg),ilgrslt(igg)
                  rgg2=0.0
                  do k=1,3
                    rgg2=rgg2+(c(k,iaa)-c(k,jaa)+cic(k,ioppbc))**2
                  end do
                  if (rgg2 .lt. cutuus) then
                    l2(igg)=1
                    go to 200
                  end if
                end do
              end do
c             No atom-atom distance within cutoff - skip this group pair
              l2(igg)=0
            end if
200         continue
          end do
c         Now calculate wo cutoff between atoms of ig and igg (l2(igg)=1)
          do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
            if (idebug(48) .gt. 1)
     -        write (iout,3001) ig,ia,(c(k,ia),k=1,3)
            ntermnb=0
            do ja=1,nstta
              l1(ja)=1
            end do
            ifim=ifirstm(iamolslt(ia))
            ilim=ilastm(iamolslt(ia))
C@TN            call readbitc(mapbitu,ia,l1(ifim),1,ilim-ifim+1,
C@TN     -        #UW,#ST,nbits)
            if (iexcludetyp .eq. 2) then
c             Exclude interactions within the same group
              call zeroiti(l1,ifgrslt(ig)-1,
     -          ilgrslt(ig)-ifgrslt(ig)+1)
            else if (iexcludetyp .eq. 3) then
c             Exclude interactions within the same solute molecule
              call zeroiti(l1,ifirstm(im)-1,
     -          ilastm(im)-ifirstm(im)+1)
            end if
            if (iafrst2 .gt. 1) call zeroiti(l1,0,iafrst2-1)
            if (ialast2 .lt. nstta) call zeroiti(l1,ialast2,nstta)
            if (idebug(48) .gt. 3)
     -        write (iout,3002) ia,(l1(ja),ja=1,nstta)
            l1(ia)=0
            do i=1,2
              enges(i)=0.d0
              eng6(i)=0.d0
              eng12(i)=0.d0
            end do
            engR=0.d0
            do igg=igf2,igl2
              if (l2(igg) .eq. 1) then
                do ja=ifgrslt(igg),ilgrslt(igg)
                  if (l1(ja) .gt. 0) then
                    igx=1
                    if (ig .eq. igrslt(ja)) igx=2
                    ntermnb=ntermnb+1
                    rij2=0.0
                    do k=1,3
                      rij2=rij2+(c(k,ia)-c(k,ja)+cic(k,ioppbc))**2
                    end do
                    rij6=rij2*rij2*rij2
                    rij12=rij6*rij6
                    rij=sqrt(rij2)
                    if (c6tt(iclsltt(ia),iclsltt(ja)) .ne. 0.0) then
                      eng120=swr*c12tt(iclsltt(ia),iclsltt(ja))/rij12
                      eng12(igx)=eng12(igx)+eng120
                      eng60=swr*c6tt(iclsltt(ia),iclsltt(ja))/rij6
                      eng6(igx)=eng6(igx)+eng60
                      sgmij=(c12tt(iclsltt(ia),iclsltt(ja))/
     -                      c6tt(iclsltt(ia),iclsltt(ja)))**(1./6.)
                      engR=engR+(eng120-eng60/02.)/sgmij
                    end if
                    enges(igx)=enges(igx)+qslt(ia)*qslt(ja)/rij
                    if (idebug(48) .gt. 2) then
                      enlj=eng120-eng60
                      enes=(qslt(ia)*qslt(ja)/rij)/dielc
                      write (iout,3004) ia,ja,ioppbc,rij,enLJ,enes
                    end if
                  end if
                end do
              end if
            end do
            do i=1,2
              eies(ia,i)=enges(i)/dielc
              ei12(ia,i)=eng12(i)
              ei6(ia,i)=eng6(i)
            end do
            eiR(ia)=engR*12.0
            ntermnbi(ia)=ntermnb
            if (iop(160) .ne. 3) then
              do i=1,2
                eiess(ia,i)=eiess(ia,i)+eies(ia,i)
                ei12s(ia,i)=ei12s(ia,i)+ei12(ia,i)
                ei6s(ia,i)=ei6s(ia,i)+ei6(ia,i)
              end do
              eiess2(ia)=eiess2(ia)+(eies(ia,1)+eies(ia,2))**2
              ei12s2(ia)=ei12s2(ia)+(ei12(ia,1)+ei12(ia,2))**2
              ei6s2(ia)=ei6s2(ia)+(ei6(ia,1)+ei6(ia,2))**2
              eiRs(ia)=eiRs(ia)+eiR(ia)
              eiRs2(ia)=eiRs2(ia)+dble(eiR(ia))**2
              nnbs(ia)=nnbs(ia)+ntermnb
              nnbs2(ia)=nnbs2(ia)+ntermnb**2
            end if
          end do
        end if
c       1-4 contributions - same code for Charmm and Amber
        do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
c         enges14, eng614, eng1214: 1-6-12 components of intraslt 1-4 term
          do i=1,2
            enges14(i)=0.0
            eng614(i)=0.0
            eng1214(i)=0.0
          end do
          engR14=0.d0
          do ja=nneig3(ia)+1,nneig4(ia)
            jaa=ineig(ja,ia)
            igx=1
            if (ig .eq. igrslt(jaa)) igx=2
            rij2=arrdist(c(1,ia),c(1,jaa))
            rij6=rij2*rij2*rij2
            rij12=rij6*rij6
            rij=sqrt(rij2)
            rrc2=rij2/ctslts
            if (iop(3) .eq. 5) then
c             Charmm
              shfr=1.0-2.0*rrc2+rrc2*rrc2
            end if
            if (c6tt14(iclsltt(ia),iclsltt(jaa)) .ne. 0.0) then
              eng12140=c12tt14(iclsltt(ia),iclsltt(jaa))/rij12
              eng1214(igx)=eng1214(igx)+eng12140
              eng6140=c6tt14(iclsltt(ia),iclsltt(jaa))/rij6
              eng614(igx)=eng614(igx)+eng6140
              sgmij14=(c12tt14(iclsltt(ia),iclsltt(jaa))/
     -                c6tt14(iclsltt(ia),iclsltt(jaa)))**(1./6.)
              engR14=engR14+(eng12140-eng6140/2.)/sgmij14
            end if
            enges14(igx)=enges14(igx)+shfr*qslt(ia)*qslt(jaa)/rij
            if (idebug(48) .gt. 1) then
              enlj=vdwf14*(eng12140-eng6140)
              enes=esf14*shfr*(qslt(ia)*qslt(jaa)/rij)/dielc
              write (iout,3005) ia,jaa,ioppbc,rij,enlj,enes,shfr
            end if
          end do
          nterm14i(ia)=nneig4(ia)-nneig3(ia)
          do i=1,2
            eies14(ia,i)=enges14(i)*esf14/dielc
            ei614(ia,i)=eng614(i)*vdwf14
            ei1214(ia,i)=eng1214(i)*vdwf14
          end do
          eiR14(ia)=engR14*vdwf14*12.0
          if (iop(160) .ne. 3) then
            do i=1,2
              eies14s(ia,i)=dble(eies14s(ia,i))+dble(eies14(ia,i))
              ei614s(ia,i)=dble(ei614s(ia,i))+dble(ei614(ia,i))
              ei1214s(ia,i)=dble(ei1214s(ia,i))+dble(ei1214(ia,i))
            end do
            eies14s2(ia)=eies14s2(ia)+
     -        (dble(eies14(ia,1))+dble(eies14(ia,2)))**2
            ei614s2(ia)=ei614s2(ia)+
     -        (dble(ei614(ia,1))+dble(ei614(ia,2)))**2
            ei1214s2(ia)=ei1214s2(ia)+
     -        (dble(ei1214(ia,1))+dble(ei1214(ia,2)))**2
            eiR14s(ia)=eiR14s(ia)+eiR14(ia)
            eiR14s2(ia)=eiR14s2(ia)+dble(eiR14(ia))**2
            n14s(ia)=n14s(ia)+nterm14i(ia)
            n14s2(ia)=n14s2(ia)+nterm14i(ia)**2
          end if
        end do
c       Finally, the solute-solvent contributions
        if (iop(3) .eq. 5) then
c         Charmm
          do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
c           engesw,eng6w,eng12w: 1-6-12 components of the solute-water term
            engesw=0.d0
            eng6w=0.d0
            eng12w=0.d0
            engRw=0.d0
            ntermw=0
            do is=2,nmolec
              do k=1,3
c               z(k)=c(k,igrcnt(igrslt(ia)))-c(k,ic01+is*nslv)
                z(k)=c(k,ia)-c(k,ic01+is*nslv)
              end do
              call pbcnd(z(1),z(2),z(3),iop(5),ioppbc,riijj)
              if (riijj .le. ctslts) then
                uind1=0.0
                uind6=0.0
                uind12=0.0
                uindR=0.0
                do ja=1,nslv
                  rij2=arrdist(c(1,ia),c(1,ic00+is*nslv+ja))
                  rij6=rij2*rij2*rij2
                  rij12=rij6*rij6
                  rrc2=rij2/ctslts
                  shfr=1.0-2.0*rrc2+rrc2*rrc2
                  uind1=uind1+shfr*qtv(ia,ja)/sqrt(rij2)
                  if (c6tv(ia,ja) .ne. 0.0) then
                    uind60=c6tv(ia,ja)/rij6
                    uind6=uind6+uind60
                    uind120=c12tv(ia,ja)/rij12
                    uind12=uind12+uind120
                    sgmijw=(c12tv(ia,ja)/c6tv(ia,ja))**(1./6.)
                    uindR=uindR+(uind120-uind60/2.)/sgmijw
                  end if
                end do
                ntermw=ntermw+1
                engesw=engesw+uind1
                eng6w=eng6w+uind6
                eng12w=eng12w+uind12
                engRw=engRw+uindR
                if (idebug(48) .gt. 1) then
                  write (iout,3006) ia,is,ioppbc,sqrt(riijj),
     -              uind12-uind6,uind1,shfr
                end if
              end if
            end do
            ntermwi(ia)=ntermw
            eiesw(ia)=engesw/dielcau
            ei6w(ia)=eng6w
            ei12w(ia)=eng12w
            eiRw(ia)=engRw*12.0
            if (iop(160) .ne. 3) then
              eiesws(ia)=eiesws(ia)+eiesw(ia)
              ei6ws(ia)=ei6ws(ia)+ei6w(ia)
              ei12ws(ia)=ei12ws(ia)+ei12w(ia)
              eiRws(ia)=eiRws(ia)+eiRw(ia)
              eiesws2(ia)=eiesws2(ia)+eiesw(ia)**2
              ei6ws2(ia)=ei6ws2(ia)+ei6w(ia)**2
              ei12ws2(ia)=ei12ws2(ia)+ei12w(ia)**2
              eiRws2(ia)=eiRws2(ia)+dble(eiRw(ia))**2
              ntvs(ia)=ntvs(ia)+ntermwi(ia)
              ntvs2(ia)=ntvs2(ia)+ntermwi(ia)**2
            end if
          end do
        else
c         Amber
          do is=2,nmolec
c           First calculate nearest group-group distance and set l2
            l2(is)=1
            do k=1,3
              z(k)=c(k,igrcnt(ig))-c(k,ic00+is*nslv+islvrep)
            end do
            call pbcnd(z(1),z(2),z(3),iop(5),ioppbc,riijj)
            if (riijj .lt. ctslts) go to 400
            do iaa=ifgrslt(ig),ilgrslt(ig)
              do jaa=ic01+is*nslv,ic00+(is+1)*nslv
                rgg2=0.0
                do k=1,3
                  rgg2=rgg2+(c(k,iaa)-c(k,jaa)+cic(k,ioppbc))**2
                end do
                if (rgg2 .lt. ctslts) go to 400
              end do
            end do
c           No atom-atom distance within cutoff - skip this group pair
            l2(is)=0
400         continue
          end do
          do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
            engesw=0.d0
            eng6w=0.d0
            eng12w=0.d0
            engRw=0.d0
            ntermw=0
            do is=2,nmolec
              if (l2(is) .gt. 0) then
                uind1=0.0
                uind6=0.0
                uind12=0.0
                uindR=0.0
                do ja=1,nslv
                  rij2=arrdist(c(1,ia),c(1,ic00+is*nslv+ja))
                  rij6=rij2*rij2*rij2
                  rij12=rij6*rij6
                  rrc2=rij2/ctslts
                  uind1=uind1+shfr*qtv(ia,ja)/sqrt(rij2)
                  if (c6tv(ia,ja) .ne. 0.0) then
                    uind60=c6tv(ia,ja)/rij6
                    uind6=uind6+uind60
                    uind120=c12tv(ia,ja)/rij12
                    uind12=uind12+uind120
                    sgmijw=(c12tv(ia,ja)/c6tv(ia,ja))**(1./6.)
                    uindR=uindR+(uind120-uind60/2.)/sgmijw
                  end if
                end do
                ntermw=ntermw+1
                engesw=engesw+uind1
                eng6w=eng6w+uind6
                eng12w=eng12w+uind12
                engRw=engRw+uindR
                if (idebug(48) .gt. 1) then
                  write (iout,3006) ia,is,ioppbc,sqrt(riijj),
     -              uind12-uind6,uind1,shfr
                end if
              end if
            end do
            ntermwi(ia)=ntermw
            eiesw(ia)=engesw/dielcau
            ei6w(ia)=eng6w
            ei12w(ia)=eng12w
            eiRw(ia)=engRw*12.0
            if (iop(160) .ne. 3) then
              eiesws(ia)=eiesws(ia)+eiesw(ia)
              ei6ws(ia)=ei6ws(ia)+ei6w(ia)
              ei12ws(ia)=ei12ws(ia)+ei12w(ia)
              eiRws(ia)=eiRws(ia)+eiRw(ia)
              eiesws2(ia)=eiesws2(ia)+eiesw(ia)**2
              ei6ws2(ia)=ei6ws2(ia)+ei6w(ia)**2
              ei12ws2(ia)=ei12ws2(ia)+ei12w(ia)**2
              eiRws2(ia)=eiRws2(ia)+dble(eiRw(ia))**2
              ntvs(ia)=ntvs(ia)+ntermwi(ia)
              ntvs2(ia)=ntvs2(ia)+ntermwi(ia)**2
            end if
          end do
        end if
c       Calculate group sums and square sums
        do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
          do i=1,2
            gtes(i)=gtes(i)+eies(ia,i)
            gt6(i)=gt6(i)+ei6(ia,i)
            gt12(i)=gt12(i)+ei12(ia,i)
            gtes14(i)=gtes14(i)+eies14(ia,i)
            gt614(i)=gt614(i)+ei614(ia,i)
            gt1214(i)=gt1214(i)+ei1214(ia,i)
            gtLJ(i)=gtLJ(i)+
     -        ei12(ia,i)+ei1214(ia,i)-(ei6(ia,i)+ei614(ia,i))
          end do
          gves=gves+eiesw(ia)
          gv6=gv6+ei6w(ia)
          gv12=gv12+ei12w(ia)
          gvLJ=gvLJ+ei12w(ia)-ei6w(ia)
        end do
        gtes(2)=gtes(2)/2.d0
        gt6(2)=gt6(2)/2.d0
        gt12(2)=gt12(2)/2.d0
        gtes14(2)=gtes14(2)/2.d0
        gt614(2)=gt614(2)/2.d0
        gt1214(2)=gt1214(2)/2.d0
        do i=1,2
          eiessg2(ig,i)=eiessg2(ig,i)+gtes(i)**2
          ei6sg2(ig,i)=ei6sg2(ig,i)+gt6(i)**2
          ei12sg2(ig,i)=ei12sg2(ig,i)+gt12(i)**2
          eies14sg2(ig,i)=eies14sg2(ig,i)+gtes14(i)**2
          ei614sg2(ig,i)=ei614sg2(ig,i)+gt614(i)**2
          ei1214sg2(ig,i)=ei1214sg2(ig,i)+gt1214(i)**2
        end do
        gvesg2(ig)=gvesg2(ig)+gves**2
        gv6g2(ig)=gv6g2(ig)+gv6**2
        gv12g2(ig)=gv12g2(ig)+gv12**2
c       Finally, print the results
        if (iop(174) .eq. 2 .or. iop(160) .eq. 3) then
          do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
            write (iout,2001) ia,ig,
     -        eies(ia,1)+eies(ia,2),ei6(ia,1)+ei6(ia,2),
     -        ei12(ia,1)+ei12(ia,2),
     -        eies14(ia,1)+eies14(ia,2),ei614(ia,1)+ei614(ia,2),
     -        ei1214(ia,1)+ei1214(ia,2),
     -        ei12(ia,1)-ei6(ia,1)+ei12(ia,2)-ei6(ia,2)+ei614(ia,2)
            write (iout,2005) ia,ig,eiesw(ia),ei6w(ia),ei12w(ia),
     -        ei12w(ia)-ei6w(ia),ntermnbi(ia),nterm14i(ia),ntermwi(ia)
c           Calculate sigma of atom ia
            sgm=0.0
            if (c6tt(iclsltt(ia),iclsltt(ia)) .ne. 0.0)
     -        sgm=(c12tt(iclsltt(ia),iclsltt(ia))/
     -          c6tt(iclsltt(ia),iclsltt(ia)))**(1.0/6.0)
            write (iout,2001) ia,ig,eiR(ia)+eiR14(ia),eiRw(ia),sgm
            nnbgs=nnbgs+ntermnbi(ia)
            n14gs=n14gs+nterm14i(ia)
            ntvgs=ntvgs+ntermwi(ia)
          end do
          if (iop(174) .eq. 2 .or. iop(160) .eq. 3) then
c           Print group sum
            do i=1,2
              write (iout,2003) inin(i),ig,gtes(i),gt6(i),gt12(i),
     -          gtes14(i),gt614(i),gt1214(i),gtLJ(i)
            end do
            write (iout,2004) ig,gves,gv6,gv12,gvLJ,
     -        nnbgs,n14gs,ntvgs
          end if
        end if
      end do
      return
1005  format(' atomindex,groupindex,eNBes, eNBr6, ',
     -  'eNBr12, e14es, e14r6, e14r12, eNBLJ (slt-slt)',/,
     -  ' atomindex,groupindex,eNBes, eNBr6, eNBr12, ',
     -  ' eLJ (slt-slv) Nterm(NB,slt-slt), Nterm(14), ',
     -  'Nterm (slt-slv)',/,
     -  ' atomindex,groupindex,del eTslt/del sigma/(-12), ',
     -  'del eTslt14/del sigma/(-12), del eTslv/del sigma/(-12)')
2000  format (i10)
2001  format (i12,i8,2x,7e12.5)
2003  format (1x,a,' group:',i7,2x,7e12.5)
2004  format (' St-sv group:',i7,2x,4e12.5,3i6)
2005  format (i12,i8,2x,4e12.5,3i6)
3000  format(' ENGDEC esf14,vdwf14=',2f10.5)
3001  format(' ENGDEC ig,ia=',i4,i5,' c=',3f12.6)
3002  format(' ENGDEC ',i5,' l1=',/,(100i1))
3003  format(' ENGDEC NB ia,ja=',2i6,' ipbc=',i2,' rij=',
     -  f8.5,' e12-6,1=',2f12.5,' shfr,swr=',2f8.5)
3004  format(' ENGDEC NB ia,ja=',2i6,' ipbc=',i2,
     -  ' rij=',f8.5,' e12-6,1=',2f12.5)
3005  format(' ENGDEC 14 ia,jaa=',2i6,' ipbc=',i2,' rij=',f8.5,
     -  ' e12-6,1=',2f12.5,' shfr=',f8.5)
3006  format(' ENGDEC UV ia,is=',2i6,' ipbc=',i2,' rij=',f8.5,
     -  ' e12-6,1=',2e12.5,' shfr=',f8.5)
      end
      subroutine disfinengdec(ifgrslt,ilgrslt,nframe,iout)
c#    MMC routine 409 lstmod: 01/06/04
c*****Initialize energy decomposition accumulators
      dimension ifgrslt(#GR),ilgrslt(#GR)
      real*8 eiess,ei12s,ei6s,eiRs,eies14s,ei614s,ei1214s,eiR14s,
     -  eiesws,ei6ws,ei12ws,eiRws,eiess2,ei12s2,ei6s2,eiRs2,eies14s2,
     -  ei614s2,ei1214s2,eiR14s2,eiesws2,ei6ws2,ei12ws2,eiRws2,
     -  eiessg2,ei12sg2,ei6sg2,eies14sg2,ei614sg2,ei1214sg2,
     -  gvesg2,gv6g2,gv12g2,nnbs2,ntvs2
      common /engdec/ eiess(#DT,2),ei12s(#DT,2),ei6s(#DT,2),
     -  eies14s(#DT,2),ei614s(#DT,2),ei1214s(#DT,2),
     -  eiesws(#DT),ei6ws(#DT),ei12ws(#DT),
     -  eiess2(#DT),ei12s2(#DT),ei6s2(#DT),
     -  eies14s2(#DT),ei614s2(#DT),ei1214s2(#DT),
     -  eiessg2(#DT,2),ei12sg2(#DT,2),ei6sg2(#DT,2),
     -  eies14sg2(#DT,2),ei614sg2(#DT,2),ei1214sg2(#DT,2),
     -  gvesg2(#DT),gv6g2(#DT),gv12g2(#DT),
     -  eiRws(#DT),eiR14s(#DT),eiRs(#DT),eiRs2(#DT),
     -  eiR14s2(#DT),eiesws2(#DT),ei6ws2(#DT),ei12ws2(#DT),
     -  eiRws2(#DT),nnbs2(#DT),ntvs2(#DT),
     -  n14s2(#DT),nnbs(#DT),n14s(#DT),ntvs(#DT),
     -  iexcludetyp,iafrst,ialast,igf,igl,
     -  iafrst2,ialast2,igf2,igl2,ctonnb,ctonnb2,ctdiff3,shfr,swr
      character*5 inin
      common /interintra/ inin(2)
      real*8 eiesa,ei12a,ei6a,eiRa,eies14a,ei614a,ei1214a,eiR14a,
     -  eieswa,ei6wa,ei12wa,eiRwa,annb,an14,antv,eiese,ei12e,ei6e,eiRe,
     -  eies14e,ei614e,ei1214e,eiR14e,eieswe,ei6we,ei12we,eiRwe,dnframe
      real*8 gtes,gt6,gt12,gtes14,gt614,gt1214,gves,gv6,gv12,
     -  snnbg,sn14g,sntvg,gtes2,gt62,gt122,gtes142,gt6142,
     -  gt12142,gves2,gv62,gv122,ennbgs2,en14gs2,
     -  entvgs2
      dimension gtes(2),gt6(2),gt12(2),gtes14(2),gt614(2),gt1214(2),
     -  gtes2(2),gt62(2),gt122(2),gtes142(2),gt6142(2),gt12142(2)
      write (iout,1011)
      do ig=igf,igl
        do i=1,2
          gtes(i)=0.d0
          gt6(i)=0.d0
          gt12(i)=0.d0
          gtes14(i)=0.d0
          gt614(i)=0.d0
          gt1214(i)=0.d0
        end do
        gves=0.d0
        gv6=0.d0
        gv12=0.d0
        snnbg=0.d0
        sn14g=0.d0
        sntvg=0.d0
        gves2=0.d0
        gv62=0.d0
        gv122=0.d0
        ennbgs2=0.d0
        en14gs2=0.d0
        entvgs2=0.d0
        dnframe=dfloat(nframe)
        do ia=max0(iafrst,ifgrslt(ig)),min0(ialast,ilgrslt(ig))
          eiesa=(eiess(ia,1)+eiess(ia,2))/dnframe
          ei12a=(ei12s(ia,1)+ei12s(ia,2))/dnframe
          ei6a=(ei6s(ia,1)+ei6s(ia,2))/dnframe
          ei614a=(ei614s(ia,1)+ei614s(ia,2))/dnframe
          ei1214a=(ei1214s(ia,1)+ei1214s(ia,2))/dnframe
          eies14a=(eies14s(ia,1)+eies14s(ia,2))/dnframe
          eiese=dsqrt(dabs(eiess2(ia)/dnframe-eiesa**2))
          ei12e=dsqrt(dabs(ei12s2(ia)/dnframe-ei12a**2))
          ei6e=dsqrt(dabs(ei6s2(ia)/dnframe-ei6a**2))
          eies14e=dsqrt(dabs(eies14s2(ia)/dnframe-eies14a**2))
          ei614e=dsqrt(dabs(ei614s2(ia)/dnframe-ei614a**2))
          ei1214e=dsqrt(dabs(ei1214s2(ia)/dnframe-ei1214a**2))
          eiRa=eiRs(ia)/dnframe
          eiR14a=eiR14s(ia)/dnframe
          eieswa=eiesws(ia)/dnframe
          ei6wa=ei6ws(ia)/dnframe
          ei12wa=ei12ws(ia)/dnframe
          eiRwa=eiRws(ia)/dnframe
          eiRe=dsqrt(dabs(eiRs2(ia)/dnframe-eiRa**2))
          eiR14e=dsqrt(dabs(eiR14s2(ia)/dnframe-eiR14a**2))
          eieswe=dsqrt(dabs(eiesws2(ia)/dnframe-eieswa**2))
          ei6we=dsqrt(dabs(ei6ws2(ia)/dnframe-ei6wa**2))
          ei12we=dsqrt(dabs(ei12ws2(ia)/dnframe-ei12wa**2))
          eiRwe=dsqrt(dabs(eiRws2(ia)/dnframe-eiRwa**2))
          do i=1,2
            gtes(i)=gtes(i)+eiess(ia,i)/dnframe
            gt6(i)=gt6(i)+ei6s(ia,i)/dnframe
            gt12(i)=gt12(i)+ei12s(ia,i)/dnframe
            gtes14(i)=gtes14(i)+eies14s(ia,i)/dnframe
            gt614(i)=gt614(i)+ei614s(ia,i)/dnframe
            gt1214(i)=gt1214(i)+ei1214s(ia,i)/dnframe
          end do
          gves=gves+eieswa
          gv6=gv6+ei6wa
          gv12=gv12+ei12wa
          annb=dfloat(nnbs(ia))/dnframe
          an14=dfloat(n14s(ia))/dnframe
          antv=dfloat(ntvs(ia))/dnframe
          ennb=sqrt(dabs(nnbs2(ia)/dnframe-annb**2))
          en14=sqrt(dabs(dfloat(n14s2(ia))/dnframe-an14**2))
          entv=sqrt(dabs(ntvs2(ia)/dnframe-antv**2))
          snnbg=snnbg+annb
          sn14g=sn14g+an14
          sntvg=sntvg+antv
          ennbgs2=ennbgs2+ennb**2
          en14gs2=en14gs2+en14**2
          entvgs2=entvgs2+entv*2
          write (iout,1009) ia,ig,eiesa,eiese,ei6a,ei6e,ei12a,ei12e,
     -      eies14a,eies14e,ei614a,ei614e,ei1214a,ei1214e,
     -      eieswa,eieswe,ei6wa,ei6we,ei12wa,ei12we,
     -      eiRa,eiRe,eiR14a,eiR14e,eiRwa,eiRwe,
     -      annb,ennb,an14,en14,antv,entv
        end do
        gtes(2)=gtes(2)/2.d0
        gt6(2)=gt6(2)/2.d0
        gt12(2)=gt12(2)/2.d0
        gtes14(2)=gtes14(2)/2.d0
        gt614(2)=gt614(2)/2.d0
        gt1214(2)=gt1214(2)/2.d0
        do i=1,2
          gtes2(i)=eiessg2(ig,i)/dnframe
          gt62(i)=ei6sg2(ig,i)/dnframe
          gt122(i)=ei12sg2(ig,i)/dnframe
          gtes142(i)=eies14sg2(ig,i)/dnframe
          gt6142(i)=ei614sg2(ig,i)/dnframe
          gt12142(i)=ei1214sg2(ig,i)/dnframe
        end do
        gves2=dsqrt(dabs(gvesg2(ig)/dnframe-gves**2))
        gv62=dsqrt(dabs(gv6g2(ig)/dnframe-gv6**2))
        gv122=dsqrt(dabs(gv12g2(ig)/dnframe-gv12**2))
        do i=1,2
          write (iout,1010)
     -      inin(i),ig,gtes(i),dsqrt(dabs(gtes2(i)-gtes(i)**2)),
     -      gt6(i),dsqrt(dabs(gt62(i)-gt6(i)**2)),
     -      gt12(i),dsqrt(dabs(gt122(i)-gt12(i)**2)),
     -      inin(i),ig,gtes14(i),dsqrt(dabs(gtes142(i)-gtes14(i)**2)),
     -      gt614(i),dsqrt(dabs(gt6142(i)-gt614(i)**2)),
     -      gt1214(i),dsqrt(dabs(gt12142(i)-gt1214(i)**2))
        end do
        write (iout,1008)
     -    ig,gves,gves2,gv6,gv62,gv12,gv122,
     -    ig,snnbg,sqrt(ennbgs2),sn14g,sqrt(en14gs2),sntvg,sqrt(entvgs2)
      end do
      return
1009  format(' Atom',i6,' Res',i5,' EttesNB=',e12.5,' sd=',e9.2,
     -  ' Ett6NB=',e12.5,' sd=',e9.2,' Ett12NB=',e12.5,' sd=',e9.2,/,
     -  ' Ettes14=',e12.5,' sd=',e9.2,' Ett614=',e12.5,' sd=',e9.2,
     -  ' Ett1214=',e12.5,' sd=',e9.2,/,' Etves=',e12.5,' sd=',e9.2,
     -  ' Etv6=',e12.5,' sd=',e9.2,' Etv12=',e12.5,' sd=',e9.2,/,
     -  ' dEtt/dsig=',e12.5,' sd=',e9.2,' dEtt14/dsig=',e12.5,
     -  ' sd=',e9.2,' dEtv/dsig=',e12.5,' sd=',e9.2,' Nnb=',f9.1,
     -  ' sd=',f6.1,/,' N14=',f5.1,' sd=',f4.1,' Ntv=',f7.1,' sd=',f6.1)
1010  format(1x,a,' group ig=',i4,' Ettes=',e12.5,' sd=',e9.2,
     -  ' Ett6=',e12.5,' sd=',e9.2,' Ett12=',e12.5,' sd=',e9.2,/,
     -  1x,a,' group ig=',i4,' Ettes14=',e12.5,' sd=',e9.2,
     -  ' Ett614=',e12.5,' sd=',e9.2,' Ett1214=',e12.5,' sd=',e9.2)
1008  format(' Total group ig=',i4,' Etves=',e12.5,' sd=',e9.2,
     -  ' Etv6=',e12.5,' sd=',e9.2,' Etv12=',e12.5,' sd=',e9.2,/,
     -  ' Total group ig=',i4,' Nnb=',f9.1,
     -  ' sd=',e9.2,' N14=',f7.1,' sd=',e9.2,' Ntv=',f9.1,' sd=',e9.2)
1011  format(/,' Energy decomposition averages over the trajectory',/)
      end
      subroutine initdifc
c#    MMC routine 410 lstmod: 07/13/00
c*****Initialize diffusion constant accumulators
      common /diffuse/ istack1(#MD,#GQ),vac1(#DC,#GQ),
     -  inorm1(#DC,#GQ),istack2(#MD,#GQ),vac2(#DC,#GQ),
     -  inorm2(#DC,#GQ),istack(#MD,#GQ),vac(#DC,#GQ),
     -  inorm(#DC,#GQ),vx1(#DC,#MD,#GQ),vy1(#DC,#MD,#GQ),
     -  vz1(#DC,#MD,#GQ),vx2(#DC,#MD,#GQ),vy2(#DC,#MD,#GQ),
     -  vz2(#DC,#MD,#GQ),vx(#DC,#MD,#GQ),vy(#DC,#MD,#GQ),
     -  vz(#DC,#MD,#GQ)
c     Ncors<=#DC, Ngrid<=#DC(15A), without ngrid!
      do is=1,#GQ
        do i=1,#MD
          istack1(i,is)=-1
          istack2(i,is)=-1
          istack(i,is)=-1
        end do
        do i=1,#DC
          inorm1(i,is)=0
          inorm2(i,is)=0
          inorm(i,is)=0
          vac1(i,is)=0.0
          vac2(i,is)=0.0
          vac(i,is)=0.0
        end do
      end do
      return
      end
      subroutine accudiffc(nmolec,nslv,islvrep,ic00,rmins,
     -  ipxgr,iop5,dcgrid,rdc1,rdc2,rfsl2,r2fsl2,rgpxsltmax2,c)
c#    MMC routine 411 lstmod: 07/28/00
c*****Diffusion constant calculation - written by Jian Sun
      dimension rmins(#MO),ipxgr(#MO),
     -  rfsl2(#SX),r2fsl2(#SX),c(3,#NA)
      common /diffuse/ istack1(#MD,#GQ),vac1(#DC,#GQ),
     -  inorm1(#DC,#GQ),istack2(#MD,#GQ),vac2(#DC,#GQ),
     -  inorm2(#DC,#GQ),istack(#MD,#GQ),vac(#DC,#GQ),
     -  inorm(#DC,#GQ),vx1(#DC,#MD,#GQ),vy1(#DC,#MD,#GQ),
     -  vz1(#DC,#MD,#GQ),vx2(#DC,#MD,#GQ),vy2(#DC,#MD,#GQ),
     -  vz2(#DC,#MD,#GQ),vx(#DC,#MD,#GQ),vy(#DC,#MD,#GQ),
     -  vz(#DC,#MD,#GQ)
      itempmx=sqrt(rgpxsltmax2)/dcgrid+1
c     Loop over all solvent
      do iw=2,nmolec
        iw0=ic00+iw*nslv
        iw00=iw0+islvrep
        rsmin=rmins(iw)
        ipxg=ipxgr(iw)
c       Special grid index for difusion constant:itemp(iw)
        if (rmins(iw) .lt. rgpxsltmax2) then
          itemp=sqrt(rmins(iw)*dcgrid**2)+1            !rripx2==0.5*0.5
        else
          itemp=itempmx
        end if
        call accudifc0(iw,iw00,rsmin,ipxg,0.0,rfsl2(ipxg),istack1,
     -    inorm1,vac1,vx1,vy1,vz1,c,iop5)
        call accudifc0(iw,iw00,rsmin,ipxg,0.0,r2fsl2(ipxg),istack2,
     -    inorm2,vac2,vx2,vy2,vz2,c,iop5)
        call accudifc0(iw,iw00,rsmin,ipxg,rdc1,rdc2,istack,inorm,
     -    vac,vx,vy,vz,c,iop5)
      end do                                  !end loop over slv iw
      return
      end
      subroutine accudifc0(iw,iw00,rsmin,ipxg,rdc1,rdc2,istack,inorm,
     -  vac,vx,vy,vz,c,iop5)
c#    MMC routine 412 lstmod: 07/28/00
c*****Diffusion constant calculation - written by Jian Sun
      dimension istack(#MD,#GQ),inorm(#DC,#GQ),vac(#DC,#GQ),
     -  vx(#DC,#MD,#GQ),vy(#DC,#MD,#GQ),vz(#DC,#MD,#GQ),
     -  c(3,#NA)
      do ix=1,#GQ
        if (ix .ne. ipxg) then
          istack(iw,ix)=-1
        end if
      end do
      if (rsmin .ge. rdc1 .and. rsmin .le. rdc2) then   !defined region
        if (istack(iw,ipxg) .gt. 0) istack(iw,ipxg)=istack(iw,ipxg)+1
        if (istack(iw,ipxg) .lt. 0) istack(iw,ipxg)=1
      else
        istack(iw,ipxg)=-1
      end if
      istk=istack(iw,ipxg)
      if (istk .gt. 0) then
        if (istk .le. #DC) then                      !NCORS=#DC
          if (istk .gt. 1) then
            iprv=istk-1
            xd=c(1,iw00)-vx(iprv,iw,ipxg)
            yd=c(2,iw00)-vy(iprv,iw,ipxg)
            zd=c(3,iw00)-vz(iprv,iw,ipxg)
            call pbcnd(xd,yd,zd,iop5,iopt,rxyz)
            vx(istk,iw,ipxg)=vx(iprv,iw,ipxg)+xd
            vy(istk,iw,ipxg)=vy(iprv,iw,ipxg)+yd
            vz(istk,iw,ipxg)=vz(iprv,iw,ipxg)+zd
          else
            vx(istk,iw,ipxg)=c(1,iw00)
            vy(istk,iw,ipxg)=c(2,iw00)
            vz(istk,iw,ipxg)=c(3,iw00)
          end if
          do j=1,istk
            jc=istk-j+1
            vac(j,ipxg)=vac(j,ipxg)+
     -        (vx(jc,iw,ipxg)-vx(istk,iw,ipxg))**2+
     -        (vy(jc,iw,ipxg)-vy(istk,iw,ipxg))**2+
     -        (vz(jc,iw,ipxg)-vz(istk,iw,ipxg))**2
            inorm(j,ipxg)=inorm(j,ipxg)+1
          end do
        else        !istk > NSCOR
          ist=mod(istk-1,#DC)+1
          iprv=ist-1
          if (iprv .eq. 0) iprv=#DC
          xd=c(1,iw00)-vx(iprv,iw,ipxg)
          yd=c(2,iw00)-vy(iprv,iw,ipxg)
          zd=c(3,iw00)-vz(iprv,iw,ipxg)
          call pbcnd(xd,yd,zd,iop5,iopt,rxyz)
          vx(ist,iw,ipxg)=vx(iprv,iw,ipxg)+xd
          vy(ist,iw,ipxg)=vy(iprv,iw,ipxg)+yd
          vz(ist,iw,ipxg)=vz(iprv,iw,ipxg)+zd
          do j=1,ist
            jc=ist-j+1
            vac(j,ipxg)=vac(j,ipxg)+
     -        (vx(jc,iw,ipxg)-vx(ist,iw,ipxg))**2+
     -        (vy(jc,iw,ipxg)-vy(ist,iw,ipxg))**2+
     -        (vz(jc,iw,ipxg)-vz(ist,iw,ipxg))**2
            inorm(j,ipxg)=inorm(j,ipxg)+1
          end do
          js=ist+1
          do j=js,#DC
            vac(#DC+js-j,ipxg)=vac(#DC+js-j,ipxg)+
     -        (vx(j,iw,ipxg)-vx(ist,iw,ipxg))**2+
     -        (vy(j,iw,ipxg)-vy(ist,iw,ipxg))**2+
     -        (vz(j,iw,ipxg)-vz(ist,iw,ipxg))**2
            inorm(#DC+js-j,ipxg)=inorm(#DC+js-j,ipxg)+1
          end do
        end if
      end if
      return
      end
      subroutine disfindifc(nsltpxgr,iout,timestep,nfreq)
c#    MMC routine 413 lstmod: 07/28/00
c*****Print MSD for solvent diffusion constant
      common /diffuse/ istack1(#MD,#GQ),vac1(#DC,#GQ),
     -  inorm1(#DC,#GQ),istack2(#MD,#GQ),vac2(#DC,#GQ),
     -  inorm2(#DC,#GQ),istack(#MD,#GQ),vac(#DC,#GQ),
     -  inorm(#DC,#GQ),vx1(#DC,#MD,#GQ),vy1(#DC,#MD,#GQ),
     -  vz1(#DC,#MD,#GQ),vx2(#DC,#MD,#GQ),vy2(#DC,#MD,#GQ),
     -  vz2(#DC,#MD,#GQ),vx(#DC,#MD,#GQ),vy(#DC,#MD,#GQ),
     -  vz(#DC,#MD,#GQ)
      dimension vnorm(#DC)
      write (iout,2130)
c     TIMFAC=4.88882129D-02
      do ipx=1,nsltpxgr   !loop over each PX
        write (iout,2132)ipx,'first'
        do j=1,#DC
          vnorm(j)=0.0
          if (inorm1(j,ipx) .gt. 0) then
            vnorm(j)=1.0*inorm1(j,ipx)/inorm1(1,ipx)
            vac1(j,ipx)=vac1(j,ipx)/float(inorm1(j,ipx))
          end if
          t=(j-1)*timestep*nfreq
          write (iout,2133) t,vac1(j,ipx),inorm1(j,ipx)
        end do
        write (iout,2132) ipx,'second'
        do j=1,#DC
          vnorm(j)=0.0
          if (inorm2(j,ipx) .gt. 0) then
            vnorm(j)=1.0*inorm2(j,ipx)/inorm2(1,ipx)
            vac2(j,ipx)=vac2(j,ipx)/float(inorm2(j,ipx))
          end if
          t=(j-1)*timestep*nfreq
          write (iout,2133) t,vac2(j,ipx),inorm2(j,ipx)
        end do
        write (iout,2132) ipx,'explicitly defined'
        do j=1,#DC
          vnorm(j)=0.0
          if (inorm(j,ipx) .gt. 0) then
            vnorm(j)=1.0*inorm(j,ipx)/inorm(1,ipx)
            vac(j,ipx)=vac(j,ipx)/float(inorm(j,ipx))
          end if
          t=(j-1)*timestep*nfreq
          write (iout,2133) t,vac(j,ipx),inorm(j,ipx)
        end do
      end do
      return
2130  format(/,' Diffusion constant results:')
2132  format(/,' Proximity region ',i5,', ',a,' shell')
2133  format(' time:',E12.5,1X,' <(r-r0)**2>=',E12.5,' Ndata=',I12)
      end
      subroutine accurestim(nmolec,ncnfpx,navgpx,nsltpxgr,rmins,ipxgr,
     -  iproxi,rfsl2,r2fsl2,rtimlim,irtm,nmcpxo,mcmd8,inperr,iout)
c#    MMC routine 414 lstmod: 02/09/09
c*****Residence time calculations - written by Jian Sun/Monika Fuxreiter
      dimension rmins(#MO),ipxgr(#MO),iproxi(#MO),
     -  rfsl2(#SX),r2fsl2(#SX)
      character*8 mcmd8
C@NL      logical irtd
      common /residt/ timestep,aucmin,nzerosignore,irtd(#RC,#GQ,#MD)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      common /option/ iop(200),idebug(200)
      if (ncnfpx/nbits+1 .gt. #RC) then
        write (iout,1000) mcmd8,nmcpxo,ncnfpx,'RC',#RC
        call disfinrestim(ncnfpx,navgpx,nsltpxgr,nmolec,irtm,iop(171),
     -    nmcpxo,mcmd8,inperr,iout)
        iop(171)=0
      end if
      if (idebug(58) .gt. 0) call disfinrestim(ncnfpx,navgpx,nsltpxgr,
     -  nmolec,irtm,iop(171),nmcpxo,mcmd8,inperr,iout)
      icnfpx=(ncnfpx-1)/nbits+1
      ib=ncnfpx-(icnfpx-1)*nbits
      do iw=2,nmolec
        if (iop(171) .eq. 1) then
          r2=rfsl2(iproxi(iw))
        else if (iop(171) .eq. 2) then
          r2=r2fsl2(iproxi(iw))
        else
          r2=rtimlim
        end if
        ipxg=ipxgr(iw)
C@NL        if (rmins(iw) .lt. r2) then
C@NL          irtd(icnfpx,ipxg,iw)=irtd(icnfpx,ipxg,iw) .or. ibiton(ib)
C@NL        end if
C@NA        if (rmins(iw) .lt. r2) then
C@NA          irtd(icnfpx,ipxg,iw)=ibset(irtd(icnfpx,ipxg,iw),ib-1)
C@NA        end if
      end do
      return
1000  format(' ===== STRONG WARNING: residence time calculation is ',
     -  'aborted due to lack of space at ',a,'=',i9,/,
     -  7x,'Number of frames analyzed so far=',i6,/,
     -  7x,'Increase #',a2,' (current value=',i6,
     -  ') or reduce the frequency of analysis',/,
     -  ' Residence time data gathered so far will be saved now')
      end
      subroutine disfinrestim(ncnfpx,navgpx,nsltpxgr,nmolec,irtm,
     -  ishelltyp,nmcpxo,mcmd8,inperr,iout)
      character*8 mcmd8
c#    MMC routine 415 lstmod: 02/19/09
c*****Calculate autocorrelation functions - from code of Monika Fuxreiter
C@NL      logical irtd
      common /residt/ timestep,aucmin,nzerosignore,irtd(#RC,#GQ,#MD)
      common /expfit_tau/ ntaumax,ntaufit,aucsaved(#AU),ixt(#AU)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      common /option/ iop(200),idebug(200)
      parameter (MAXFRAME=32*#RC)
      parameter (MAXAUCTIM=MAXFRAME/2)
      dimension ipxrtd(MAXAUCTIM,#GQ),itd(MAXFRAME),
     -  itdallpx(MAXFRAME),rnorm(#GQ),lshells(3),nmcprint(100)
      character*14 label
      character*24 shells(3)
      data shells /'first shell             ',
     -   'first and second shell  ','shells with input radius'/
      data lshells /11,22,24/,ndebug /0/,icheck /0/,icheckstart /0/
      if (ishelltyp .eq. 0) return
      if (idebug(139) .gt. 0) then
        ndebug=min0(ncnfpx/idebug(139),100)
        do i=1,ndebug
          nmcprint(i)=i*idebug(139)+1
        end do
      end if
      rewind irtm
      ntaumax=ncnfpx/2
      call indexit(ixt,1,ntaumax,-1)
      timestepused=timestep*navgpx
      do ix=1,nsltpxgr+1
        call zeroiti(ipxrtd(1,ix),0,ntaumax)
      end do
      do iw=2,nmolec
        call zeroiti(itdallpx,0,ncnfpx)
        do ix=1,nsltpxgr
          idbprint=0
          call readbitc(irtd(1,ix,iw),1,itd,1,ncnfpx,#RC,1,nbits)
          if (idebug(148) .gt. 0) then
            do i=1,ncnfpx
              itd(i)=1
            end do
          end if
          if (nzerosignore .gt. 0) then
c           Fill in gaps of nzerosignore long zeros with ones
            if (itd(1) .eq. 1 .and. idebug(147) .gt. 0) then
              write (iout,2000) ix,iw,'before fill',(itd(i),i=1,ncnfpx)
              idbprint=1
            end if
            icheck=1
            icheckstart=icheck
            itdprev=itd(icheck)
            do while (icheck .lt. ncnfpx-1)
              do while (itd(icheck) .eq. itdprev .and.
     -                  icheck .lt. ncnfpx-1)
                icheck=icheck+1
              end do
              if (itdprev .eq. 0 .and.
     -            icheck-icheckstart .le. nzerosignore) then
c               Short enough zero stretch was found - fill it with ones
                do i=icheckstart,icheck-1
                  itd(i)=1
                end do
              end if
              icheckstart=icheck
              itdprev=itd(icheck)
            end do
            if (itd(1) .eq. 1 .and. idebug(147) .gt. 1)
     -        write (iout,2000) ix,iw,'after fill',(itd(i),i=1,ncnfpx)
          end if
          do icnfpx=1,ncnfpx
            itdallpx(icnfpx)=itdallpx(icnfpx)+itd(icnfpx)
          end do
          if (idebug(139)*(1-idbprint) .gt. 0) then
c         if (idebug(139)*(1-idbprint) .gt. 0 .and.
c    -        (ix .eq. 4 .or. ix .eq. 9)) then
            nclose=itd(1)
            do i=1,ndebug
              if (itd(nmcprint(i)) .eq. 1) nclose=nclose+1
            end do
            if (nclose .gt. 0)
     -        write (iout,2000) ix,iw,' ',(itd(i),i=1,ncnfpx)
          end if
          do j=1,ncnfpx
            kmax=min0(j+ntaumax-1,ncnfpx)
            if (itd(j) .eq. 1) then
              do k=j,kmax
                if (itd(k) .gt. 0) ipxrtd(k-j+1,ix)=ipxrtd(k-j+1,ix)+1
              end do
            end if
          end do
        end do
        do icnfpx=1,ncnfpx
          if (itdallpx(icnfpx) .gt. 1) then
            if (nzerosignore .eq. 0) then
              write (iout,1003) iw,icnfpx,itdallpx(icnfpx)
              inperr=inperr+1
            end if
            itdallpx(icnfpx)=1
          end if
        end do
        do j=1,ncnfpx
          if (itdallpx(j) .eq. 1) then
            kmax=min0(j+ntaumax-1,ncnfpx)
            do k=j,kmax
              if (itdallpx(k) .eq. 1)
     -          ipxrtd(k-j+1,nsltpxgr+1)=ipxrtd(k-j+1,nsltpxgr+1)+1
            end do
          end if
        end do
      end do
      write (iout,1004) shells(ishelltyp)(1:lshells(ishelltyp)),mcmd8,
     -  nmcpxo
      do ix=1,nsltpxgr+1
        rcoord=float(ipxrtd(1,ix))/float(ncnfpx)
        rnorm(ix)=1.0
        if (ipxrtd(1,ix) .ne. 0) rnorm(ix)=1.0/rcoord
        do itau=1,ntaumax
          aucsaved(itau)=
     -      rnorm(ix)*float(ipxrtd(itau,ix))/float(ncnfpx-itau+1)
        end do
        write (iout,1000) ixp,rcoord
        write (label,1005) ixp
        call fitexp(timestepused,ntaumax,aucmin,1,label,ihalf,tailavg,
     -    iout)
        write (iout,1006) label,ntaufit,tailavg,ihalf
        ixp=ix
        if (ix .eq. nsltpxgr+1) ixp=0
      end do
c     Write autocorrelation functions on the disk
      do itau=1,ntaumax
        write (irtm,1002) ixt(itau)*timestepused,
     -    (rnorm(ix)*float(ipxrtd(itau,ix))/float(ncnfpx-itau+1),
     -    ix=1,nsltpxgr+1)
      end do
      write (iout,1001) filenames(9)(1:namlens(9)),
     -  float(ntaufit)*timestepused,ncnfpx,aucmin
      return
1000  format(' PX group',i5,': <# of solvents>=',f8.2)
1001  format(/,' PX group 0 is the combination of all groups used',/,
     -  ' Residence autocorrelation functions have been written',
     -  ' on file ',a,/,
     -  ' Total time the autocorrelation was used for the fit=',f9.2,
     -  ' Number of structures used=',i8,/,
     -  ' Minimum autocorrelation for fit=',f6.4)
1002  format(f8.2,#GQf8.5)
1003  format(' ***** PROGRAM ERROR: composite autocorrelation input ',
     -  'for solvent',i6, 'at itau=',i4,' is greater than one:',i3)
1004  format(/,' Residence times in ',a,' at ',a,'=',i9)
1005  format('PX group',i5,':')
1006  format(1x,a,' # of AUC values used=',i6,
     -  ' <AUC> over the last 5%=',f6.3,' 0.5 first reached at term',i6)
2000  format(' DISFINRESTIM ix,iw=',2i6,1x,a,/,(' itd=',100i1))
      end
      subroutine fitexp(timestep,n,aucmin,imultiexp,label,ihalf,tailavg,
     -  iout)
c#    MMC routine 416/a lstmod: 02/02/09
c*****Fit an exponential to a(i),ixt(i), characterize the AUC function
      character*(*) label
      common /expfit_tau/ ntaumax,ntaufit,a(#AU),ixt(#AU)
      real*8 sum_ai,sum_ti_ai,sum_ti,sum_ti_2,devsum,devlogsum,
     -  devsumc,devlogsumc,devsum2
      real*8 xvar(8),grad(8)
c     Work array for minimizer
      dimension fmfp_ami(30)
      external gradexp
      nexp=2
      nvar=2*nexp+1
c     Eliminate zeros that are between non-zeros
      do i=2,n-1
        if (a(i) .eq. 0.0) then
          if (a(i-1) .ne. 0.0 .and. a(i+1) .ne. 0.0)
     -      a(i)=(a(i-1)+a(i+1))/2.0
        end if
      end do
      i=1
      sum_ai=0.d0
      sum_ti_ai=0.d0
      sum_ti=0.d0
      sum_ti_2=0.d0
      aprev=1.0
      ihalf=0
      do while (aprev .gt. aucmin .and. i .le. n)
        sum_ai=sum_ai+alog(a(i))
        sum_ti_ai=sum_ti_ai+alog(a(i))*ixt(i)
        sum_ti=sum_ti+ixt(i)
        sum_ti_2=sum_ti_2+ixt(i)**2
        aprev=a(i)
        if (a(i) .le. 0.5) then
          if (ihalf .eq. 0) ihalf=i
        end if
        i=i+1
      end do
      ntaufit=i-1
      if (ntaufit .gt. 1) then
        tau_1=-sum_ti_2/sum_ti_ai
        tau_c_inv=(ntaufit*sum_ti_ai-sum_ti*sum_ai)/
     -   (sum_ti**2-ntaufit*sum_ti_2)
        c_exp_log=-(sum_ai+tau_c_inv*sum_ti)/float(ntaufit)
        c_exp=exp(-c_exp_log)
        tau_c=1.0/tau_c_inv
        devsum=0.d0
        devlogsum=0.d0
        devsumc=0.d0
        devlogsumc=0.d0
        do i=1,ntaufit
          devsum=devsum+(a(i)-exp(-float(ixt(i))/tau_1))**2
          devlogsum=devlogsum+(alog(a(i))+float(ixt(i))/tau_1)**2
          devsumc=devsumc+(a(i)-c_exp*exp(-float(ixt(i))/tau_c))**2
          devlogsumc=devlogsumc+
     -      (alog(a(i))+c_exp_log+float(ixt(i))/tau_c)**2
        end do
        if (ntaufit .gt. 100) then
          if_last5pc=ntaufit*0.95
        else if (ntaufit .gt. 25) then
          if_last5pc=ntaufit-0.05*ntaufit
        else
          if_last5pc=ntaufit
        end if
        asum=0.0
        do i=if_last5pc,ntaufit
          asum=asum+a(i)
        end do
        tailavg=asum/(ntaufit-if_last5pc+1)
        nlast5pc=0.05*ntaufit
        dev=sqrt(devsum/float(ntaufit))
        devlog=sqrt(sngl(devlogsum)/float(ntaufit))
        devc=sqrt(devsumc/float(ntaufit))
        devlogc=sqrt(sngl(devlogsumc)/float(ntaufit))
        write (iout,1000)
     -    label,tau_1*timestep,dev,devlog,
     -    label,tau_c*timestep,devc,devlogc,c_exp
        if (imultiexp .gt. 0) then
c         Try non-linear fit for double exponentials
          xvar(1)=c_exp
          xvar(3)=tau_c_inv
          do k=2,nexp
            xvar(k)=0.d0
            xvar(nexp+k)=0.d0
          end do
          xvar(nvar)=0.d0
          maxiter=25000
          call fmfpt(gradexp,nvar,nvar,xvar,fitdev,grad,0.0,1.e-4,
     -      maxiter,ier,fmfp_ami,30)
          devsum2=0.d0
          do i=1,ntaufit
            expsum=0
            do k=1,nexp
              expsum=expsum+xvar(k)*exp(-xvar(nexp+k)*float(i-1))
            end do
            expsum=expsum+xvar(nvar)
            devsum2=devsum2+(a(i)-expsum)**2
          end do
          dev2=sqrt(devsum2/float(ntaufit))
          write (iout,1005) label,nexp,
     -      xvar(nvar),(k,xvar(k),1.d0/xvar(nexp+k),k=1,nexp)
          write (iout,1001) fitdev,dev2,(grad(k),k=1,2*nexp+1)
          if (ier .eq. 1) write (iout,1002) maxiter
          if (ier .lt. 0 .or. ier .gt. 1) write (iout,1003) ier
        end if
      else
        if (ntaufit .eq. 0) write (iout,1004) 'Empty region'
        if (ntaufit .eq. 1) write (iout,1004) 'To few data '
      end if
      return
1000  format(1x,a,' 1-exp fit, c=1     : Half time=',e9.2,' SD=',f6.3,
     -  ' SD(log)=',e9.2,/,1x,a,' 1-exp fit, fitted c: Half time=',e9.2,
     -  ' SD=',f6.3,' SD(log)=',e9.2,' Exp factor (~1)=',f9.2)
1001  format(22x,'Fit deviation from fmfp=',e9.2,'SD=',e9.2,
     -  ' Gradients: ',8e10.2)
1002  format(22x,'///// NOTE: minimizer iteration limit (',i8,
     -  ') is exceeded - fit is likely to be wrong')
1003  format(22x,'///// NOTE: minimizer problem (ier=',i3,')',
     -  ' - fit is likely to be wrong')
1004  format(1x,a)
1005  format(1x,a,i2,'-exp, fitted      :',' c0=',f9.5,2(' C(',i1,')=',
     -  f9.5,' Half time=',e9.2))
      end
      subroutine gradexp(nvar,xvar,devsum,grad)
c#    MMC routine 416/b lstmod: 04/23/23
c*****Calculate fit and gradient for the n/2 -exponential fit
      real*8 xvar(nvar),grad(nvar)
      common /expfit_tau/ ntaumax,ntaufit,aucsaved(#AU),ixt(#AU)
      real*8 devsumr8,expsum,dev,exptau(8)
c     auc(i-1) <- sum_k^nexp x_k*exp(-tau_k*(i-1))
c     xvar(1-nexp): c_k; xvar(nexp+k): tai_k
c     Maximum 4 terms for now
      nexp=nvar/2
      call zeroitd(grad,nvar)
      ntaulim=ntaufit
      devsumr8=0.d0
      do k=1,nexp
        if (xvar(nexp+k) .lt. 0.0)
     -     ntaulim=min0(ntaulim,int(-15.0/xvar(nexp+k)))
      end do
      do i=1,ntaulim
        expsum=0.0
        do k=1,nexp
          exptau(k)=exp(-xvar(nexp+k)*dfloat(i-1))
          expsum=expsum+xvar(k)*exptau(k)
        end do
        dev=(expsum-aucsaved(i))
        devsumr8=devsumr8+dev**2
        do k=1,nexp
          grad(k)=grad(k)+dev*exptau(k)
          grad(nexp+k)=grad(nexp+k)-dev*xvar(k)*exptau(k)*dfloat(i-1)
        end do
      end do
      do k=1,nvar
        grad(k)=grad(k)*2.d0
      end do
      devsum=devsumr8
c      print *,'nvar,ntaumax,ntaulim=',nvar,ntaumax,ntaulim,
c     -  ' devsum=',devsum
c      write (6,1000) 'xvar',(xvar(k),k=1,nvar)
c      write (6,1000) 'grad',(grad(k),k=1,nvar)
c1000  format(1x,a,'=',8e10.3)
      end
      subroutine echoprpx
c#    MMC routine 417 lstmod: 02/12/09
c*****Echoes proximity analysis input
      character*2 optname,sizesym
      character*10 sizename,moddate,cmoddate,cpxmoddate
      character*25 optlname
      character*38 sizelname
      common /compopt/ ncompopt,icompopt(40),nasize,iasize(70),
     -  rnbytyckp,rnbytypxc,rnbytyadd,optname(40),optlname(40),
     -  sizename(70),sizelname(70),sizesym(70),moddate,cmoddate,
     -  cpxmoddate
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      character*80 ident
      common /title/ nlident,ident(2)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /outsideden/ edgelinxyz(3),edgerinxyz(3),nmolinout(2),
     -  molinout(#MO)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
C@NL      logical irtd
      common /residt/ timestep,aucmin,nzerosignore,irtd(#RC,#GQ,#MD)
      common /torauc/ nmctorauc,ntorsaved,ntaucprint,nauc(#AU),
     -  tauc_timestep,tauc_min,torsave(#AU,#TR),auctor(#AU,#TR)
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
C@FG      real*8 fguuacc,fguvacc,fgvuacc,fgvvacc,fgusacc,fgvsacc
      common /fieldgrad/
C@FG     -  fguuacc(6,#MM,#GQ),fguvacc(6,#MM,#GQ),
C@FG     -  fgusacc(6,#MM),fgvsacc(6,#MG),fgvuacc(6,#MG,#GQ),
C@FG     -  fgvvacc(6,#MG,#GQ),nusedfgr(#MO),
     -  fgruucut,fgruvcut,fgrvvcut,rproxfgmax,
     -  fgruucut2,fgruvcut2,fgrvvcut2,rproxfgmax2
      real*8 eiess,ei12s,ei6s,eiRs,eies14s,ei614s,ei1214s,eiR14s,
     -  eiesws,ei6ws,ei12ws,eiRws,eiess2,ei12s2,ei6s2,eiRs2,eies14s2,
     -  ei614s2,ei1214s2,eiR14s2,eiesws2,ei6ws2,ei12ws2,eiRws2,
     -  eiessg2,ei12sg2,ei6sg2,eies14sg2,ei614sg2,ei1214sg2,
     -  gvesg2,gv6g2,gv12g2,nnbs2,ntvs2
      common /engdec/ eiess(#DT,2),ei12s(#DT,2),ei6s(#DT,2),
     -  eies14s(#DT,2),ei614s(#DT,2),ei1214s(#DT,2),
     -  eiesws(#DT),ei6ws(#DT),ei12ws(#DT),
     -  eiess2(#DT),ei12s2(#DT),ei6s2(#DT),
     -  eies14s2(#DT),ei614s2(#DT),ei1214s2(#DT),
     -  eiessg2(#DT,2),ei12sg2(#DT,2),ei6sg2(#DT,2),
     -  eies14sg2(#DT,2),ei614sg2(#DT,2),ei1214sg2(#DT,2),
     -  gvesg2(#DT),gv6g2(#DT),gv12g2(#DT),
     -  eiRws(#DT),eiR14s(#DT),eiRs(#DT),eiRs2(#DT),
     -  eiR14s2(#DT),eiesws2(#DT),ei6ws2(#DT),ei12ws2(#DT),
     -  eiRws2(#DT),nnbs2(#DT),ntvs2(#DT),
     -  n14s2(#DT),nnbs(#DT),n14s(#DT),ntvs(#DT),
     -  iexcludetyp,iafrst,ialast,igf,igl,
     -  iafrst2,ialast2,igf2,igl2,ctonnb,ctonnb2,ctdiff3,shfr,swr
      common /rfsavg/ iwrfs(#GQ),rkpdbmin,rkgrmin,r2kgrmin,rtkgrmin
      character*4 namfcg,namfcg0
      character*20 nmlfcg,nmlfcg0
      common /fcgnam/ igrdup(100),namfcg0(100),namfcg(100),
     -  nmlfcg0(100),nmlfcg(100)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      character*4 labpr
      character*2 iaprt
      common /grplst/ ixprt(#ST),ilastg(#ST),labpr(2,#ST),
     -  iaprt(#ST)
      Real*8 xtlabc
      common /charmm/ xtlabc(6),icntrlr(20),icntrlw(20),nfreatr,nfreatw,
     -  ichopen,ifree(#NA)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      character*1 lxyz
      common /names/ lxyz(3)
      character*6 fform(2)
      character*132 line
      data fform /'ascii ','binary'/
      write (iout,2000) (ident(ic),ic=1,nlident)
      if (iop(9) .eq. 10) write (iout,3391) filenames(3)(1:namlens(3))
      if (iop(9) .eq. 11) write (iout,3390) filenames(3)(1:namlens(3)),
     -  icntrlw(1),nfreatw
      if (iop(9) .eq. 10 .and. iop(161) .eq. 1 .or.
     -    iop(9) .eq. 11 .and. icntrlw(11) .eq. 2) write (iout,3392)
      if (natskip .ne. 0) then
        if (iop(9) .eq. 10 .or. iop(9) .eq. 11) then
          if (natskip .lt. 0) write (iout,3393) 'first',-natskip
          if (natskip .gt. 0) write (iout,3393) 'last',natskip
        else
          write (iout,3394) natskip
          nchng=nchng+1
        end if
      end if
      if (iop(175) .gt. 0) then
        if (iop(159) .gt. 0) then
          write (iout,1352)
          inperr=inperr+1
        else
          write (iout,1350) (lxyz(ixyz(k)),k=1,3)
        end if
        if (iop(5) .ne. 4) then
          write (iout,1351)
          nwarn=nwarn+1
        end if
      end if
      if (iop(153) .gt. 0) write (iout,0930)
     -  filenames(7)(1:namlens(7)),idistrpx
      if (iop(163) .gt. 0) then
        if (iop(170) .eq. 0) write (iout,1030) 'written on',
     -    filenames(8)(1:namlens(8)),fform(3-max0(2,iop(163))),infopx
        if (iop(170) .eq. 1) write (iout,1030) 'read from',
     -    filenames(8)(1:namlens(8)),fform(3-max0(2,iop(163))),infopx
        if (iop(163) .eq. 3) write (iout,1032)
      end if
      if (numsolv .lt. 1) then
        write (iout,2001)
        nwwarn=nwwarn+1
      end if
      if (iop(176) .eq. 1) then
        call checkdim(ifail,iout,inperr,'TD',2,0,0,0)
        if (ifail .eq. 0) then
          if (iop(160) .eq. 0) then
            iop(176)=0
            write (iout,2236)
            nchng=nchng+1
          else
            write (iout,2036) #TD
          end if
        end if
      end if
      if (iop(141) .eq. 0 .and. iop(162) .gt. 0) write (iout,3300)
      if (iop(141) .eq. 1) write (iout,3310)
      if (iop(141) .eq. 2) write (iout,3320) rqwmin,rqwmax
      if (iop(167) .eq. 0) then
        write (iout,3370)
        if (iop(173) .gt. 0) write (iout,3395)
      else if (iop(167) .eq. 1) then
        write (iout,3371) sigpxa
        if (sigmah .ne. 0.0) write (iout,3372) sigmah
      else if (iop(167) .eq. 2) then
        write (iout,3396)
      end if
      if (rfsfac .ne. 1.0 .or. rfsadd .ne. 0.0)
     -  write (iout,3378) rfsfac,rfsadd
      write (iout,3379) sigpxa
      if (iop(180) .gt. 0) write (iout,3369) nmctorauc,tauc_timestep,
     -  tauc_min,ntaucprint
      if (iop(171) .gt. 0) then
        write (iout,3373)
     -    timestep,'RC',navgpx,timestep*navgpx*#RC*nbits,aucmin
        call checkdim(ifail,iout,inperr,'MD',nmolec,0,0,0)
        if (iop(171) .eq. 1) write (iout,3374) 'first'
        if (iop(171) .eq. 2) write (iout,3374) 'first two'
        if (iop(171) .eq. 3) write (iout,3375) sqrt(rtimlim)
        if (nzerosignore .gt. 0) write (iout,3382) nzerosignore
      end if
      if (iop(177) .gt. 0) write (iout,3377)
     -  dcgrid,dcgrid*#DC,timestep,sqrt(rdc1),sqrt(rdc2)
      if (iop(172) .eq. 1) write (iout,3376) 'elements',
     -  rkgrmin,r2kgrmin,rtkgrmin
      if (iop(172) .eq. 2) write (iout,3376) 'potential types',
     -  rkgrmin,r2kgrmin,rtkgrmin
      if (iop(168) .eq. 1 .or. iop(168) .eq. 3) write (iout,3380)
      if (iop(168) .gt. 2)
     -  write (iout,3381) ((ipxkeep(k,i),k=1,2),i=1,npxkeep)
      write (iout,2029) pmvslt,pmvslv
      if (iop(69) .gt. 0) write (iout,6910)
      if (iop(25) .ge. 1) then
        write (iout,2510)
        if (iop(25) .gt. 1) write (iout,2511)
        do i=1,100
          if (namfcg(i) .ne. '    ')  then
            write (line,2512) i,namfcg(i),nmlfcg(i)
            if (igrdup(i) .eq. 1) write (line(51:132),100)
     -        ' Different residues will form distinct groups'
            if (igrdup(i) .eq. 2) write (line(51:132),100)
     -        ' Different solute molecules will form distinct groups'
            write (iout,100) line
          end if
        end do
      end if
      write (iout,2017) islvrep
      if (iop(178) .gt. 0) then
        write (iout,1380) rxhmax,hbanglemin*rdtodg
        if (iop(178) .eq. 1) write (iout,1381) ' '
        if (iop(178) .eq. 2) write (iout,1382)
        if (iop(178) .eq. 3) write (iout,1381) 'type'
        if (iop(178) .eq. 4) write (iout,1384) -qbmin,qbmin
        if (iop(178) .eq. 2 .or. iop(178) .eq. 3)
     -    write (iout,1388) (bridgeat(i),i=1,nbridgeat)
        if (iop(178) .eq. 1 .or. iop(24) .gt. 0)
     -   write (iout,1389) (ia,ihbanchor(ia),
     -     (labslt(k,ihbanchor(ia)),k=1,2),ia=1,nhbanchor)
      end if
C@FG      if (iop(166) .gt. 0) then
C@FG        write (iout,1260)
C@FG        if (mod(iop(166),2) .eq. 1) write (iout,1261) 'binary'
C@FG        if (mod(iop(166),2) .eq. 0) write (iout,1261) 'ascii'
C@FG        if (iop(166) .gt. 2) write (iout,1262)
C@FG        if (iop(179) .gt. 0) then
C@FG          write (iout,1390)
C@FG        else
C@FG          if (nmolec .gt. #MG) then
C@FG            write (iout,1392) 'MG',nmolec
C@FG            inperr=inperr+1
C@FG            iop(179)=0
C@FG          end if
C@FG        end if
C@FG      end if
      if (iop(174) .gt. 0) then
        write (iout,1007)
        if (iop(3) .eq. 5) then
          if (cutuu .eq. ctonnb) then
            write (iout,1011)
          else
            write (iout,1010) ctonnb,cutslt
            if (cutuu .lt. ctonnb) then
              write (iout,1013)
              inperr=inperr+1
            end if
          end if
        end if
        if (iop(174) .eq. 2) write (iout,1009)
        if (iop(26) .ne. 4 .and. nmolec .gt. 1) then
          write (iout,1002)
          inperr=inperr+1
        else if (iop(3) .lt. 3 .or. iop(3) .gt. 5) then
          write (iout,1003)
          inperr=inperr+1
        end if
        if (iexcludetyp .eq. 2) write (iout,1012) 'residue/group'
        if (iexcludetyp .eq. 3) write (iout,1012) 'solute molecule'
        if (iafrst .gt. 1 .or. ialast .lt. nstta) write (iout,1008)
     -    'The energy decomposition will be limited to',
     -    iafrst,ialast,igf,igl,iamolslt(iafrst),iamolslt(ialast)
        if (iafrst2 .gt. 1 .or. ialast2 .lt. nstta) write (iout,1008)
     -    'The list of atoms to interact with wil be limited to',
     -    iafrst2,ialast2,igf2,igl2,iamolslt(iafrst2),iamolslt(ialast2)
      end if
      if (iop(3) .gt. 9) then
c       Check for options requiring solute-solvent energy calculations
        if (iop(144) .gt. 0) then
          write (iout,9000) 'ATFR'
          inperr=inperr+1
        end if
        if (iop(146) .gt. 0) then
          write (iout,9000) 'PXBE'
          inperr=inperr+1
        end if
        if (iop(166) .gt. 0) then
          write (iout,9000) 'FLDG'
          inperr=inperr+1
        end if
      end if
      if (iop(144) .eq. 1) then
        write (iout,8410)
        if (iop(152) .le. 1)  write (iout,8411)
        if (iop(152) .eq. 2)  write (iout,8412)
      end if
      if (iop(166) .gt. 0) then
        write (iout,1061) filenames(10)(1:namlens(10)),fform(iop(166)),
     -    islvrep
C@FG        write (iout,2033) fgruucut,fgruvcut,fgrvvcut,rproxfgmax
        if (iop(26) .ne. 4) then
          write (iout,9002)
          inperr=inperr+1
        end if
      end if
      if (iop(169) .eq. 1) write (iout,2031)
      if (iop(148) .gt. 0) then
        if (iop(11) .eq. 7) write (iout,0600)
        if (iop(152) .eq. 0) write (iout,9200)
        if (iop(152) .eq. 1) write (iout,9201)
        if (iop(152) .eq. 2) write (iout,9202)
        write (iout,2025) rfsww
        write (iout,2008) rceww
      end if
      if (iop(162) .eq. 1) write (iout,1021)
      if (iop(162) .eq. 2) write (iout,1022)
      if (iop(162) .eq. 3) write (iout,1023) pmvslv
      if (iop(162) .eq. 4) write (iout,1024)
      if (iop(142) .gt. 1) then
        if (iop(149) .eq. 0) write (iout,2004)
        if (iop(149) .eq. 1) write (iout,2005)
        if (iop(149) .eq. 2) write (iout,2006)
        if (ndimgen .eq. 0) write (iout,2011)
        if (ndimgen .gt. 0) write (iout,2012) (lxyz(k+kdel),k=1,ndimgen)
        write (iout,2003) nrans
        if (iop(92) .gt. 0) write (iout,2014) edgexa
        if (iop(164) .eq. 1) write (iout,2019)
      end if
      if (iop(165) .eq. 1) write (iout,2021)
      if (iop(158) .eq. 2) write (iout,2022)
      if (iop(142) .gt. 1 .or. iop(143) .gt. 0)
     -  write (iout,2002) sqrt(rgpxsltmax2),rpxdiv,sqrt(rpxnear2)
      if (iop(146) .eq. 1 .and. #GE .gt. 1)
     -  write (iout,2010) epmink,epdivk
      if (iop(145) .gt. 0) write (iout,2035) (180.0/#LG.0),rpxdiv
      if (iop(147)+iop(148) .gt. 0) write (iout,2007) rsolmn,rsolmx
      if (iop(147) .gt. 0) then
        write (iout,2037)sqrt(rgpxwwmax2)
        do iv=1,nijgvv
          if (islvirep(iv)*islvjrep(iv) .eq. 0) then
            write (iout,9352)
            inperr=inperr+1
          end if
          write (iout,2026) islvirep(iv),islvjrep(iv)
        end do
        if (nijgvv .eq. 0) write (iout,2028)
      end if
      nsltp=nstta
      if (nfadel .gt. 0) write (iout,2032) 'first',nfadel
      if (nladel .gt. 0) write (iout,2032) 'last',nladel
      if (iop(142) .eq. 1) write (iout,2034)
      if (nsltpxgr .gt. 0) then
        if (nsltpxgr .lt. nsltpx2-nsltpx1+1) then
          write (iout,2015) nsltpxgr
          if (iop(142) .gt. 1 .or. iop(146)+iop(148) .gt. 0) then
            if (iop(158) .eq. 0) write (iout,2023)
            if (iop(158) .eq. 3) write (iout,2030)
          end if
        end if
      end if
c     Check g(r) group is the atomic no-s are the same
      nwarnp=0
      if (nsltpxgr .ne. 1) then
        do ig=1,nsltpxgr
          igl=ilastg(ig)
          if (ig .eq. 1) igf=1
          if (ig .gt. 1) igf=ilastg(ig-1)+1
          if (igl-igf .gt. 0) then
            iatref=ixprt(igf)
            ianref=ianslt(iatref)
            igf1=igf+1
            do igm=igf1,igl
              if (ianslt(ixprt(igm)) .ne. ianref) then
                if (nwarnp .le. 25) write (iout,2016) iatref,
     -            ixprt(igm),indxrdf(iatref),ianref,ianslt(ixprt(igm))
                nwarnp=nwarnp+1
              end if
            end do
          end if
        end do
      end if
      if (nwarnp .gt. 25) write (iout,2027) (nwarnp-25)
      nwarn=nwarn+nwarnp
      write (iout,2001) nmolec-1,natoms,nsltpx1,nsltpx2,nsltpxgr
      if (iop(160) .eq. 1 .or. iop(160) .eq. 2) write (iout,2009) npxmax
      if (iop(160) .eq. 2) write (iout,2020)
      write (iout,2013) navgpx,nranpx,npxres,nsavepx,nmcpxdsc,
     -  npxcntin,lumppr
      if (iop(5) .eq. 2) then
        write (iout,1001)
        inperr=inperr+1
      end if
c     Check run parameters against program limits
      if (iop(147) .gt. 0)
     -  call checkdim(ifail,iout,inperr,'VG',mxpxwwgrd,0,0,0)
      if (iop(142) .gt. 1)
     -  call checkdim(ifail,iout,inperr,'RG',mxpxsltgrd,0,0,0)
      if (iop(143) .gt. 0)
     -  call checkdim(ifail,iout,inperr,'TG',mxpxsltgrd,0,0,0)
      if (iop(145) .gt. 0)
     -  call checkdim(ifail,iout,inperr,'DG',mxpxsltgrd,0,0,0)
      if (iop(142) .ne. 2 .and.
     -  (iop(162) .eq. 2 .or. iop(162) .eq. 4)) then
          write (iout,1353)
          inperr=inperr+1
      end if
      return
100   format(a)
0600  format(' CNFG: Input configuration collected from history')
0930  format(' PXPL: Proximity distributions will also be written on',
     -  ' file ',a,' in alphanumeric form - unit number=',i6)
1001  format(' ***** ERROR: Hexagonal close packing (HCP) PBC does ',
     -  'not work with the analysis options for now')
1002  format(' ***** ERROR: energy decomposition only works with ',
     -  'SVPT GENL')
1003  format(' ***** ERROR: energy decomposition only works with ',
     -  'SUPT AM02 or SUPT AM94 or SUPT CHRM')
1007  format(' ENGL: Energy decomposition analysis')
1008  format(7x,a,/,12x,'solute atom range:    [',i6,',',i6,']',/,
     -  12x,'solute residue range  [',i5,',',i5,']',/,
     -  12x,'solute molecule range [',i5,',',i5,']',/)
1009  format(' ENGL: Analysis result on each structure will be printed')
1010  format(' ENGL: solute-solvent interactions will be smoothly ',
     -  'switched to zero in the interval [',f8.2,' - ',f8.2,' A ]')
1011  format(' ENGL: no switching function will be used ')
1012  format(' ENGL: non-bonded interaction within the same ',a,
     -  ' will be ignored')
1013  format(' ***** ERROR: switching function innner cutoff, cutonnb ',
     -  'exceeds solute-solvent cutoff')
1021  format(' PXCR: Bulk density is obtained from cell volume')
1022  format(' PXCR: Bulk density is obtained from considered primary ',
     -  'area volume')
1023  format(' PXCR: Bulk density is obtained from water experimental ',
     -  'data p.m.v.=',f10.5,' ml/mol')
1024  format(' Bulk density is obtained from primary RDFs')
1030  format(' PXWR: Proximity information will be ',a,' file ',a,' ',
     -  'in ',a,' format - unit number=',i6)
1032  format(' PXWR: Proximity information file will contain only the ',
     -  'proximity indeces and distances, but no energies')
C@FG1260  format(' FLDG: Field gradients will also be calculated')
C@FG1261  format(' FLDG: Field-gradient file format is ',a)
C@FG1262  format(' FLDG: Field-fradient file will not contain the group ',
C@FG     -  'contributions, only the total sums')
1350  format(' The X, Y, and Z axes will be permuted to ',3(a1,1x))
1351  format(' ----- WARNING: PXYZ key is essential only for hexagonal',
     -  ' prism cell (PBCN HEX)')
1352  format(' ***** ERROR: PXYZ key can not be used with analysis ',
     -  'concurrent with simulation')
1353  format(' ***** ERROR: without the PXGR **** PRIM key, only ',
     -  'PXCR TDEN or PXCR WDEN is valid')
1380  format(' Hydrogen bonded solute-water-solute bridges will be ',
     -  'calculated',/,5x,
     -  'Maximum X...H distance=',f5.2,' A minimum X...H-Y angle=',f8.2)
1381  format(' HBBR: Potential anchor',a,'list was specified by input')
1382  format(' HBBR: All protein backbone atoms will be potential ',
     -  'anchors')
1384  format(' HBBR: Solute atoms with q < ',f5.2,' or hydrogens with',
     -  ' q > ',f5.2,' will be potential anchors')
1388  format(' HBBR: Bridge atom names:',10('|',a4,'|',1x))
1389  format((' HBBR: Bridge atom list:',5(1x,2i6,1x,2a4)))
C@FG1390  format(' FLDG: Field gradient calculation is limited to the ',
C@FG     -  'solute molecule sites')
C@FG1392  format(' ***** ERROR: program is not dimensioned to calculate ',
C@FG     -  'field gradients at the solvent sites.',/,7x,'Increase ',a2,
C@FG     -  'to ',i5,' or use FLDG NOSV')
2000  format(2(/,1x,a80),/)
2001  format(/,' Number of solvent molecules=',i6,/,
     -  ' Number of atoms=',i8,/,' Solute atom range=',2i6,/,
     -  ' Number of rdfs and QCDFs=',i4)
2002  format(/,' PXGR: Range of primary radial distribution function=',
     -  f10.4,' A  grid size=',f6.4,' A',/,' PXGR: Strong Warnings ',
     -  'will be issued and a conformation will be saved ',
     -  'when a solvent is closer than ',f6.3,' A to the solute')
2003  format(' Total number of random points generated so far=',i10)
2004  format(' PXCR: Reference density for proximity RDFs is the total',
     -  ' density - no weighting')
2005  format(' PXCR: Reference density for proximity RDFs is the ',
     -  'density in the total primary area for each solute atom ',
     -  'environment')
2006  format(' PXCR: Reference density for proximity RDFs is the ',
     -  'density in the considered primary area for each solute atom ',
     -  'environment')
2007  format(' PXWW: Distribution functions are calculated only for ',
     -  ' waters in a concentric shell around the solute of radii',
     -  2f10.4,' A')
2008  format(' PXWW: Solvent energy cutoff radius=',f9.3,' A')
2009  format(' SCAN: Stop history file scan at stepnumber ',i10)
2010  format(' PCBE: Solute pair energy minimum and gridsize=',f8.2,
     -  f6.2,' kcal/mol')
2011  format(' SCAN: No symmetry related random points are generated')
2012  format(' SCAN: Symmetry related random points are generated ',
     -  'in the directions',3(1x,a1))
2013  format(' SCAN: Analysis at every ',i10,' step',/,
     -  ' SCAN: After each analysis ',i8,' random points are ',
     -  'generated',/,' SCAN: Results printed at every',i10,' step',/,
     -  7x,'Proximity checkpoint file is saved at every ',i10,' step',/,
     -  ' SCAN: Number of steps discarded=',i8,/,
     -  ' SCAN: Batch-mean error estimate block size=',i9,/,
     -  ' SCAN: Fcg error estimates are based on the ',i2,'-th lumped ',
     -  ' error estimates',/)
2014  format(' PBCN: Cube edge within which the random points will be ',
     -  'generated=',f9.5,' A')
2015  format(/,' Only ',i4,' atomic distribution functions will be ',
     -  'calculated',/,5x,'ixgr in the solute atom listing above will',
     -  ' tell  which distribution each atom contributes')
2016  format(' ----- WARNING: atoms',i5,' and',i5,' in',
     -  ' distribution group',i5,' have different atomic numbers:',2i3)
2017  format(' SLVA: Proximity analysis uses the ',i3,'th solvent atom',
     -  ' as solvent center')
2019  format(' VOLE: Volume element estimates are kept from previous ',
     -  ' calculations (unless the solute is changed)')
2020  format(' SCAN: Proximity information will be added to the ',
     -  'previous run result')
2021  format(' PXPA: Proximity regions without solvent will not be ',
     -  'printed')
2022  format(' PXPR: Functional-group based proximity tables will not ',
     -  'be printed')
2023  format(' PXPR: Both full and condensed proximity tables will be ',
     -  ' printed')
2025  format(' PXWW: Solvent first solvation shell radius=',f9.3,' A')
2026  format(' PXWW: Solvent-solvent g(r) will be obtained between ',
     -  'solvent atoms ',i4,' and ',i4)
2027  format(' ----- WARNING:',i6,' additional warning messages were ',
     -  'supressed')
2028  format(' PXWW: Solvent-solvent g(r) will be obtained between the',
     -  ' solvent center of masses')
2029  format(' PXCR: Partial molar volume of the solute and solvent=',
     -  2f12.4,' ml/mol')
2030  format(' PXPR: Full proximity table will be printed - table ',
     -  'condensed by functional groups will not be generated')
2031  format(' DIPC: Proximity dipole fluctuations will be calculated')
2032  format(' PXLM: The ',a,i6,' solute atoms will be exluded from ',
     -  'the proximity analysis')
C@FG2033  format(' FLDG: Field gradients will be calculated at moving ',
C@FG     -  'solute and solvent sites using the following cutoffs: ',/,
C@FG     -  ' Rc(solute-solute)=',f6.2,' A Rc(solute-solvent)=',f6.2,' A',
C@FG     -  ' Rc(solvent-solvent)=',f6.2,' A',/,' Solvent sites farther ',
C@FG     -  'than ',f6.2,' A from their proximal solute atom will not be ',
C@FG     -  'used')
2034  format(' PXGR: Only primary coordination numbers will be ',
     -  'calculated')
2035  format(' PXDP: Distribution of solute solvent dipole angle will ',
     -  'be calculated in the 0-180 degree range with ',f6.2,' deg ',
     -  'grids', /,' Mean solute-solvent dipole angle will be ',
     -  'calculated as a function of distance with ',f6.2,' A grids')
2036  format(' TAND: Solute torsion angle distributions will be ',
     -  'calculated using ',i3,' gridpoints')
2037  format(' PXWW: Solvent-solvent istribution function range=',
     -  f6.1,' A')
2236  format(' >>>>> OVERRIDE: TAND key is ignored - torsion angle ',
     -  'distribution is automaticaly calculated during the MC run')
2510  format(' FCGD: Functional group definition were defined by ',
     -  'input data')
2511  format(' FCGD: Inputted functional groups will be used to group ',
     -  'the calculated distribution functions')
2512  format(i4,' Short name:',a4,' Long name:',a20)
3300  format(/,' PXCR: The proximity regions are defined by the ',
     -  'bisectors')
3310  format(/,' PXCR: The proximity regions are defined by the',
     -  ' radical planes')
3320  format(' PXCR: The proximity regions are defined by the radical ',
     -  'planes using radii proportional to the absolute charges',/,
     -  '      Minimum and maximum radius:',2f8.2,' A')
3369  format(' TAUC: Torsion angle autocorrelations (AUC) will be ',
     -  'calculated',/,7x,'Frequency of savings=',i6,' steps ',
     -  'Time step=',i9,' AUC minimum for fit=',f8.5,
     -  ' Number of AUC to print=',i6)
3370  format(' RFSL: Built-in first shell radii are used')
3371  format(' RFSL: First shell radii: [SIGMA(solute)+',
     -  'SIGMA(solvent(=',f6.3,'))]/2')
3372  format(' SIGMA(hydrogens)=',f6.3,' A')
3373  format(' RTIM: Solvent residence times will be calculated,',/,
     -  7x,'Time step assumed=',f6.2,/,
     -  7x,'Maximum time (limited by the value of #',a2,' and the ',
     -  'trajectory sampling frequency (',i5,') =',f12.2,/
     -  7x,'Minimum autocorrelation function value for fit=',f6.4)
3374  format(' RTIM: Residence in ',a,' shells will be calculated')
3375  format(' RTIM: Residence within ',f6.2,' A shell will be ',
     -  'calculated')
3376  format(' Proximity RDF extrema avarages will be calculated over ',
     -  a,'.',/,5x,' RDF will b eignored if Kfs <',f4.1,' or K2sh <',
     -  f5.1,' or Ktot <',f5.1)
3377  format(' DIFC: Solvent diffusion constants will be calculated',/,
     -  7x,'Grid size=',f6.4,' A',/,5x,'Maximum distance=',f8.2,' A',/,
     -  7x,'Time step=',f6.2,/,
     -  7x,'Distance range for defined region= [',f6.2,',',f6.2,'] A')
3378  format(' RFSL: First shell radii are further multiplied by',
     -  f6.3,' and incremented (after multiplication) by',f6.3,' A')
3379  format(' RFSL: Second shell radii are obtained from the first ',
     -  'shell radii by incrementing with ',f6.3,' A')
3380  format(' PXCR: Hydrogens will be ignored for proximity  analysis')
3381  format(' PXCR: Solute atoms to be used for proximity analysis ',
     -  'are limited to the ranges ',5(i6,'-',i5),10(/,10(i6,'-',i5)))
3382  format(' RTIM: Streches of',i3,'-long outside marks will be ',
     -  'replaced by inside marks')
3390  format(' TRAJ: Scanning a Charmm trajectory file on file ',a,
     -  ' of ',i7,' configurations with ',i8,' free atoms')
3391  format(' TRAJ: Scanning an Amber trajectory file on file ',a)
3392  format(' TRAJ: Simulation cell information is read for each ',
     -  'structure')
3393  format(' TRAJ: After each configurations read, the ',a,i6,
     -  ' atoms will be ignored')
3394  format(' >>>>> OVERRIDE: can not skip atoms in an MMC ',
     -  'trajectory - natskip=',i6,' will be ignored')
3395  format(' ///// NOTE: built-in first shell radii have been ',
     -  'modified from input')
3396  format(' RFSL: First shell radii have been obtained ',
     -  'individually from the first minimum of the primary RDF')
6910  format(' Cloned solute molecules will contribute to the same ',
     -  'RDFs and QCDFs')
8410  format(' Solvent-averaged forces on the solute atoms will be ',
     -  ' calculated')
8411  format(' TRAJ: Forces will be in the local coordinate frame')
8412  format(' TRAJ: Forces will be in the global coordinate frame')
9000  format(' ***** ERROR: key ',a4,' can not be used when ',
     -  'no solute energy function is defined')
9002  format(' ***** ERROR: field-gradient calculation requires ',
     -  'general solvent')
9200  format(' TRAJ: Solute is rigid and not moved during the ',
     -  'simulation')
9201  format(' TRAJ: Solute is rigid but moved during the simulation')
9202  format(' TRAJ: Solute is flexible')
9352  format(' ***** ERROR: Solvent-solvent g(r) can not be ',
     -  'calculated between atoms and COM')
1061  format(' Field gradients will be calculated on the solvents',
     -  ' and written of file ',a,' in ',a,' form',/,5x,
     -  ' Gradients will be calulated at the ',i3,'-th solvent atom')
      end
      subroutine doublepxgrid(iout)
c#    MMC routine 418 lstmod: 10/27/98
c*****Doubles the proximity analysis grid size (to get smoother plots)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /option/ iop(200),idebug(200)
      if (nrans .gt. 0)
     -  call doublecount(nrnslt,#RG,#GQ,mxpxsltgrd,nsltpxgr)
      if (iop(142) .gt. 1)
     -  call doublecount(ngrslt,#RG,#GQ,mxpxsltgrd,nsltpxgr)
      if (iop(143) .gt. 0)
     -  call doublecount(ngtslt,#RG,#GQ,mxpxsltgrd,nsltpxgr)
      if (iop(147) .gt. 0) then
        do iv=1,nijgvv
          call doublecount(ngoo(1,1,iv),#VG,#GQ,mxpxwwgrd,nsltpxgr)
        end do
      end if
      if (iop(145) .gt. 0) then
        new=mxpxsltgrd/2
        do id=1,nsltpxgr
          do ig=1,new
            tdavr(ig,id)=tdavr(2*ig,id)+tdavr(2*ig-1,id)
          end do
        end do
      end if
      rpxdiv=2.0*rpxdiv
      rripx2=1/rpxdiv**2
      mxpxsltgrd=mxpxsltgrd/2
      mxpxwwgrd=mxpxwwgrd/2
      rgpxsltmax2=(rpxdiv*mxpxsltgrd)**2
      rgpxwwmax2=(rpxdiv*mxpxwwgrd)**2
      write (iout,1000) rpxdiv
      return
1000  format(' The radial grid for proximity analysis has been ',
     -  'doubled to ',f6.3,' A')
      end
      subroutine doublecount(idistr,maxg,maxd,ng,nd)
c#    MMC routine 419 lstmod: 10/27/98
c*****Doubles one integer array
      dimension idistr(maxg,maxd)
      new=ng/2
      do id=1,nd
        do ig=1,new
          idistr(ig,id)=idistr(2*ig,id)+idistr(2*ig-1,id)
        end do
      end do
      return
      end
      subroutine disfinpx(numrun,volav)
c#    MMC routine 420 lstmod: 02/14/18
c*****Prints the results of (proximity) analysis
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 ident
      common /title/ nlident,ident(2)
      real*8 suminout,suminout2
      common /inout/ suminout(2),suminout2(2)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      character*80 prmfil
      common /pfuse/ npfused(11),ipfmod(9),lprmfil(9),prmfil(9)
      character*4 ipf
      character*8 namh2o,nammcy
      character*32 namstp
      common /pfnames/ ipf(11),namstp(11),namh2o(9),nammcy(3)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      real*8 hbridges,hbridges2,ebridges,ebridges2,shb,eshb,eshb2
      character*4 bridgeat
      common /hbbridge/ hbridges,hbridges2,ebridges,ebridges2,
     -  shb(#SX),eshb(#SX),eshb2(#SX),hbmatmin,rxhmax,rxhmax2,
     -  hbanglemina,hbanglemin,qbmin,nhbanchor,ihbanchor(#SX),
     -  nbridgeat,iwo,iwh1,iwh2,bridgeat(100)
      common /rfsavg/ iwrfs(#GQ),rkpdbmin,rkgrmin,r2kgrmin,rtkgrmin
      common /dipole/ dipslt(3),dipslt2,dipslv(3),dipslv2,
     -  dipsys(3),dipsys2,dipoleg(3,#SX),dipoleg2(#SX),
     -  Dipole(3,#SX),Dipole2(#SX),dipole0(3,#SX),dipole02(#SX),
     -  dipole1(3,#SX),dipole12(#SX),dipole22(#SX),npxww0(#SX)
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      real*8 tangav,tang2av,sinsum,cossum,dtangd,dlastrot
      common /cdhdan/ sinsum(#TR),cossum(#TR),tangav(#TR),
     -  tang2av(#TR),dlastrot(#TR),dtangd(#TD,#TR),
     -  dihang(#TR),ta0(#TR),steploop(#TR),deldih(#TR),
     -  dih0(#TR),dih1(#TR),torstep(#TR),wtors(#TR),
     -  targetang(#TR),wskewinv,wskewstepmin,resumefac,rngfac(3),
     -  rngfacl(3),defrot,deflooprot,maxtorchain,ntorsinp,ntang,
     -  ntangorg,ntorpmf,ntorgrp,ntorgrpmf,nsltcop,ntorlim,iskewdr,
     -  iskewlp,iskewpr,iskew(#TR),maptors(#ST),
     -  iquata(#TR,4),ifdhgrlst(#TR),ildhgrlst(#TR),
     -  iftorgrp(#TR),iltorgrp(#TR),ilhbtorgrp(#TR),
     -  lsttorgrp(#TA),lastrot(#TR),itangd(#TD,#TR),
     -  iftormovgrgr(#TR),iltormovgrgr(#TR),iftormovgra(#TL),
     -  iltormovgra(#TL),itorgrp(#TR)
C@TS      real*8 ftslt,ftslt2,trqbnd,trqbnd2
C@TS      common /sltfrc/ ftslt(3,#ST),ftslt2(3,#ST),
C@TS     -  trqbnd(#TR),trqbnd2(#TR)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      character*4 labpr
      character*2 iaprt
      common /grplst/ ixprt(#ST),ilastg(#ST),labpr(2,#ST),
     -  iaprt(#ST)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /qljdat/ qh,qhh,qho,qoo,qqt5(5,5),alj6,alj66,blj12,blj122
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),rDipole2(#UV),rDipl2(#UV),
     -  rdpg2(#UV),r_dp0(#HA),r_dpg(#HA),r_dp1(#HA),
     -  rdp02(#UV),rdp0(3,#UV),rdp1(3,#UV),rdpg(3,#UV),
     -  rnmol(#UV),rnvol(#UV),rnmol1(#UV),rnvol1(#UV),
     -  dens(#UV),dens1(#UV)
      common /pbcdat/ ivopt(#UV),pvol(#UV),rDipole(3,#UV),
     -  rnmol2(#UV),rnvol2(#UV),dens2(#UV)
      common /pxrdfdat/ gpxmx1(#GQ),gpxmn1(#GQ),gpxmx2(#GQ),
     -  gtmx1(#GQ),gtmn1(#GQ),rpxmx1(#GQ),rpxmn1(#GQ),
     -  rpxmx2(#GQ),rtmx1(#GQ),rtmn1(#GQ),gtmx2(#GQ),
     -  rtmx2(#GQ),volfs(#GQ),vol2fs(#GQ),rnvols(#GQ),
     -  rpxfar(#GQ),rtfar(#GQ),rkfrdf(#GQ),rksrdf(#GQ),
     -  vfrdf(#GQ),vsrdf(#GQ)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      common /MPI_DM_ENG/ iflslv(2,64),iflsltg(2,64),ncountsslt(64),
C@DM     -  ndisplslt(64),ncountslv(64),ndisplslv(64),ncountslv3(64),
C@DM     -  ndisplslv3(64),icpuslv(#MO),icpuslt(#GR),mixupslt(#GR)
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      common /fcgdatpx/ fcgavg(101,12),sdev2(101,11),ndupfg(100),nfge
      character*4 namfcg
      character*20 nmlfcg
      common /fcgnam/ igrdup(100),namfcg(100,2),nmlfcg(100,2)
      character*1 lxyz
      common /names/ lxyz(3)
      dimension gdv(#RG),grd(#RG),grn(#RG),gr(#RG),rcoord(#RG),
     -  grt(#TG),rcoort(#TG),egr(#GE),rcoore(#GE),
     -  ndupgr(#GQ),npxwwg(#GQ),nwfspg(#GQ),nwpg(#GQ),
     -  tav(#DG),dg(#LG),xtd(#LG),sltep(#GE),xck(15),
     -  rpxnr(#GQ),rtnear(#GQ),groo(#RG,#ND),
     -  dpxmx(#GQ),dpxmn(#GQ),rdpxmx(#GQ),rdpxmn(#GQ),
     -  rdipsys(3),rdipslt(3),rdipslv(3),gdipc(180),
     -  rdp12(#ST),rdp22(#ST),rdp2(3,#ST),r_dp2(#ST),
     -  hbtav(100),hbtav2(100),ehbtav(100),ehbtav2(100),nhbt(100)
C@TS      dimension fsltt(3),fst(3),fssd(3)
      real*8 bs,bfss,r2kfss,rkfss,rks,vfss,rkden,pfss,rkw,ennww,
     -  beww,dnvolis,dnvolp,dnvolp1,dnvols,dnxck
      dimension dnxck(15)
      character*4 labgr,typname
      character*8 mcmd8
      character*15 perat
      character*9 nametyp
      character*34 cumul
      data dfac /1.0/,gfac /1.0/,dtp /0.0/,dtp1 /1.0/,bulkdens /0.0/,
     -  ndupfnd /0/
      perat='per solute atom'
      cumul='cumulative over contributing atoms'
      if (iop(9) .lt. 10) mcmd8='MC step '
      if (iop(9) .ge. 10) mcmd8='MD frame'
      call testconst(0,1,2,0.0,1.0,2.0,iout,nfail,1)
      if (nfail .gt. 0) call datprt(2)
      call checkint(nrans,'nrans',5,iout,nwwarn,inperr)
      call csavepx(ichkpx,1,iskipfail,6)
      write (iout,2006) mcmd8,nmcpxo,ncnfpx
      if (nsltresets .gt. 0) write (iout,2136) nsltresets,'solute'
      if (nslvresets .gt. 0) write (iout,2136) nslvresets,'solvent'
      if (iop(80) .gt. 0 .and. (iop(160) .eq. 1 .or. iop(160) .eq. 2))
     -  call denincalc(suminout,suminout2,ncnfpx,volin,volav,wmslv,
     -    wmmltona3,'Average',1,nmcpxo,0,0,iout)
      if (iop(178) .gt. 0) then
c       Hydrogen-bonded bridge results
        hbrav=hbridges/ncnfpx
        hbrav2=hbridges2/ncnfpx
        sd=sqrt(abs(hbrav2-hbrav**2))
        write (iout,2130) hbrav,sd
        if (hbrav .gt. 0.0) then
          eav=ebridges/hbridges
          eav2=ebridges2/hbridges
          sd=sqrt(abs(eav2-eav**2))
          write (iout,2131) eav,sd
        end if
        if (iop(178) .eq. 2 .or. iop(178) .eq. 3) then
c         Average over types
          call zeroiti(nhbt,0,nbridgeat)
          call zeroit(hbtav,nbridgeat)
          call zeroit(hbtav2,nbridgeat)
          call zeroit(ehbtav,nbridgeat)
          call zeroit(ehbtav2,nbridgeat)
        end if
        do iaa=1,nhbanchor
          ia=ihbanchor(iaa)
          hbav=shb(ia)/ncnfpx
          eav=0.0
          sd=0.0
          if (hbav .gt. 0.0) then
            eav=eshb(ia)/shb(ia)
            sd=sqrt(abs(eshb2(ia)/shb(ia)-eav**2))
          end if
          if (iop(178) .eq. 2 .or. iop(178) .eq. 3) then
c           Average over types
            ibt=0
            do it=1,nbridgeat
              if (bridgeat(it) .eq. labslt(2,ia)) ibt=it
            end do
            if (ibt .eq. 0) then
              write (iout,2133) labslt(2,ia)
              inperr=inperr+1
              ibt=100
            end if
            nhbt(ibt)=nhbt(ibt)+1
            hbtav(ibt)=hbtav(ibt)+hbav
            hbtav2(ibt)=hbtav2(ibt)+hbav**2
            ehbtav(ibt)=ehbtav(ibt)+eav
            ehbtav2(ibt)=ehbtav2(ibt)+eav**2
          end if
          write (iout,2132) ia,(labslt(k,ia),k=1,2),hbav,eav,sd
        end do
      end if
      if (iop(178) .eq. 2 .or. iop(178) .eq. 3) then
        do it=1,nbridgeat
          hbav=0.0
          sd=0.0
          if (nhbt(it) .gt. 0) then
            hbav=hbtav(it)/float(nhbt(it))
            ehbav=ehbtav(it)/float(nhbt(it))
            sd=sqrt(abs(hbtav2(it)/float(nhbt(it))-hbav**2))
            sde=sqrt(abs(ehbtav2(it)/float(nhbt(it))-ehbav**2))
            write (iout,2134) bridgeat(it),nhbt(it),hbav,sd,ehbav,sde
          else
            nfound=0
            do ia=1,nhbanchor
              if (bridgeat(it) .eq. labslt(2,ihbanchor(ia))) nfound=1
            end do
            if (nfound .gt. 0) write (iout,2135) bridgeat(it)
          end if
        end do
      end if
      idiaslv=rfsww/rpxdiv+1
      nearmn=100000
      do is=1,nsltpxgr
        gpxmx1(is)=0.0
        gpxmn1(is)=0.0
        gpxmx2(is)=0.0
        gtmx1(is)=0.0
        gtmn1(is)=0.0
        gtmx2(is)=0.0
        rpxmx1(is)=0.0
        rpxmn1(is)=0.0
        rpxmx2(is)=0.0
        rtmx1(is)=0.0
        rtmn1(is)=0.0
        rtmx2(is)=0.0
        rpxnr(is)=0.0
        rpxfar(is)=0.0
        rtnear(is)=0.0
        rtfar(is)=0.0
        rkfrdf(is)=0.0
        rksrdf(is)=0.0
        vsrdf(is)=0.0
        vfrdf(is)=0.0
        dpxmx(is)=0.0
        dpxmn(is)=0.0
        rdpxmx(is)=0.0
        rdpxmn(is)=0.0
        do k=1,3
          rDipole(k,is)=0.0
          rdpg(k,is)=0.0
          rdp0(k,is)=0.0
          rdp1(k,is)=0.0
          rdp2(k,is)=0.0
        end do
        rDipl2(is)=0.0
        rDipole2(is)=0.0
        rdpg2(is)=0.0
        rdp02(is)=0.0
        rdp12(is)=0.0
        rdp22(is)=0.0
      end do
      do k=1,3
        rdipsys(k)=0.0
        rdipslt(k)=0.0
        rdipslv(k)=0.0
      end do
      do is=nsltpx1,nsltpx2
        dens(is)=0.0
        dens1(is)=0.0
        dens2(is)=0.0
      end do
      if (iop(9) .eq. 1 .or. iop(9) .eq. 2)
     -  write (iout,2025) numrec(3),lstac
      if (iop(142) .gt. 1) write (iout,2005) nrans
      if (ncnfpx .eq. 0) return
      rnmolav=float(nmolsum)/float(ncnfpx)
      if (iop(155) .eq. 1) call echoprpx
      if (iop(41) .gt. 0) write (iout,2026) rnmolav-1
      if (iop(172)*iop(142) .gt. 0) then
c       Find atomindex of the first member of each rdf group
        do is=1,nsltpxgr
          do iss=nsltpx1,nsltpx2
            if (indxrdf(iss) .eq. is) then
              l2(is)=iss
              go to 3010
            end if
          end do
          write (iout,2016) is
          l2(is)=1
3010      continue
        end do
      else
        call indexit(l2,1,nsltpxgr,0)
      end if
      if (iop(142) .gt. 1 .or.
     -    iop(143)+iop(145)+iop(146)+iop(147)+iop(148) .gt. 0) then
        if (nsltpxgr .eq. nsltpx2-nsltpx1+1) then
          do is=nsltpx1,nsltpx2
            ndupgr(is)=1
            nwfspg(is)=nwfspx(is)
            npxwwg(is)=npxwws(is)
            nwpg(is)=nwpx(is)
          end do
        else
c         Calculate QCDF group multiplicity, group sums
          call zeroiti(ndupgr,0,nsltpxgr)
          call zeroiti(npxwwg,0,nsltpxgr)
          call zeroiti(nwfspg,0,nsltpxgr)
          call zeroiti(nwpg,0,nsltpxgr)
          do is=nsltpx1,nsltpx2
            isx=indxrdf(is)
            ndupgr(isx)=ndupgr(isx)+1
            npxwwg(isx)=npxwwg(isx)+npxwws(is)
            nwfspg(isx)=nwfspg(isx)+nwfspx(is)
            nwpg(isx)=nwpg(isx)+nwpx(is)
          end do
c         Avoid divide by zero for empty group
          do is=1,nsltpxgr
            if (ndupgr(is) .eq. 0) then
              ndupgr(is)=1
              npxwwg(is)=npxwws(is)
              nwfspg(is)=1
              nwpg(is)=1
            end if
          end do
        end if
        if (iop(153) .gt. 0) then
c         Write header info on idistrpx
          rewind idistrpx
          write (idistrpx,1002) nsltpxgr
          write (idistrpx,1003) ianslt(ixprt(1)),
     -      (ianslt(ixprt(ilastg(ig-1)+1)),ig=2,nsltpxgr)
          if (iop(25) .lt. 2) then
            write (idistrpx,1004) (labslt(k,ixprt(1)),k=1,2),
     -        ((labslt(k,ixprt(ilastg(ig-1)+1)),k=1,2),ig=2,nsltpxgr)
          else
            write (idistrpx,1004)
     -        namfcg(itypfg(ixprt(1)),2),labslt(2,ixprt(1)),
     -        (namfcg(itypfg(ixprt(ilastg(ig-1)+1)),2),
     -        labslt(2,ixprt(ilastg(ig-1)+1)),ig=2,nsltpxgr)
          end if
        end if
        maxdupis=0
        do is=1,nsltpxgr
          if (maxdupis .lt. ndupgr(is)) maxdupis=ndupgr(is)
        end do
        if (maxdupis .gt. 10) then
          write (iout,2031)
          do is=1,nsltpxgr
            ifs=0
            if (is .gt. 1) ifs=ilastg(is-1)
            call disthead('Atoms of distribution',21,ndupgr(is),
     -        ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
            write (iout,2024) (ixprt(ifs+j),iaprt(ifs+j),
     -        (labpr(k,ifs+j),k=1,2),j=1,ndupgr(is))
          end do
        end if
      end if
      mxpxsltgrd1=mxpxsltgrd-1
      if (iop(142) .lt. 2 .and. iop(143) .eq. 0) go to 400
      if (iop(156) .eq. 0) then
        do is=1,nsltpxgr
          if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
            do k=1,15
              dnxck(k)=nxck(k,is)
            end do
            cn=corn(dnxck,xck,15,0)/ndupgr(is)
            ifs=0
            if (is .gt. 1) ifs=ilastg(is-1)
            ndupis=ndupgr(is)
            call disthead('Coordination number distribution',32,
     -        ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
            write (iout,2015) (rfsl(indxrdf(ifs+j)),j=1,ndupis)
            if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -        iaprt(ifs+j),(labpr(k,indxrdf(ifs+j)),k=1,2),j=1,ndupis)
            write (iout,2038) xck
          end if
        end do
      end if
      if (nrans .gt. 0) then
c       Compute primary area densities dens(is) and overall primary density dtp
c       Suffix 1 refers to quantities for the considered primary regions
        nmolp=0
        dnvolp=0.d0
        nmolp1=0
        dnvolp1=0.d0
c       Find the first grid for each proximity region that is occupied and
c       the volume they enclose
        nranslts=0
        idense=0
        do is=1,nsltpxgr
c         Find the volume range first
          igmax=mxpxsltgrd
          do while (nrnslt(igmax,is) .eq. 0 .and. igmax .gt. 1)
            igmax=igmax-1
          end do
          ig=1
          do while (ngrslt(ig,is) .eq. 0 .and. ig .lt. igmax)
            nranslts=nranslts+nrnslt(ig,is)
            ig=ig+1
          end do
          l1(is)=ig
          if (ig .eq. mxpxsltgrd) idense=0
        end do
        if (idense .eq. 0) then
          write (iout,2034)
          nwarn=nwarn+1
        end if
        call checkint(nranslts,'nranslts',8,iout,nwwarn,inperr)
        volslt0=volav*float(nranslts)/(float(nrans)*float(ndim2p))
        write (iout,2027) volslt0
        ir1=sqrt(rsmnsq*rripx2)+1
        ir2=sqrt(rsmxsq*rripx2)+1
        ndupfnd=0
        do is=1,nsltpxgr
          nmolis=0
          dnvolis=0.d0
          dnvols=0.d0
          do i=l1(is),mxpxsltgrd1
            nmolis=nmolis+ngrslt(i,is)
            dnvolis=dnvolis+nrnslt(i,is)
            if (i. ge. ir1 .and. i .lt. ir2) dnvols=dnvols+nrnslt(i,is)
          end do
          if (nwpg(is) .gt. 0 .and. dnvolis .eq. 0.d0) then
            write (iout,2033) is
            nwwarn=nwwarn+1
          end if
          if (ndupgr(is) .gt. 1) ndupfnd=1
          rnmol2(is)=float(nmolis)/float(ncnfpx)
          rnmol1(is)=rnmol2(is)/ndupgr(is)
          rnvol2(is)=dnvolis/(float(nrans)*float(ndim2p))*volav
          rnvol1(is)=rnvol2(is)/float(ndupgr(is))
          nvol1=0
          nvol2=0
          igl=ilastg(is)
          igf=1
          if (is .gt. 1) igf=ilastg(is-1)+1
          do ia=igf,igl
            nvol1=nvol1+nrnfs(ia)
            nvol2=nvol2+nrn2fs(ia)
          end do
          call checkint(nvol2,'nvol2',5,iout,nwwarn,inperr)
          volfs(is)=float(nvol1)/(float(nrans)*float(ndim2p))*volav
          vol2fs(is)=float(nvol2)/(float(nrans)*float(ndim2p))*volav
          rnvols(is)=dnvols/(float(nrans)*float(ndim2p))*volav
          if (dnvolis .gt. 0.d0) then
            dens1(is)=rnmol1(is)/rnvol1(is)
            dens2(is)=rnmol2(is)/rnvol2(is)
          end if
          nmolp1=nmolp1+nmolis
          dnvolp1=dnvolp1+dnvolis
          nmolis=nmolis+ngrslt(mxpxsltgrd,is)
          dnvolis=dnvolis+nrnslt(mxpxsltgrd,is)
          rnmol(is)=float(nmolis)/float(ncnfpx*ndupgr(is))
          rnvol(is)=dnvolis/
     -      (float(nrans)*float(ndim2p*ndupgr(is)))*volav
          if (dnvolis .gt. 0.d0) dens(is)=rnmol(is)/rnvol(is)
          nmolp=nmolp+nmolis
          dnvolp=dnvolp+dnvolis
        end do
        anmolp=float(nmolp)/float(ncnfpx)
        anvolp=dnvolp/(float(nrans)*float(ndim2p))*volav
        dtp=anmolp/anvolp
        anmolp1=float(nmolp1)/float(ncnfpx)
        anvolp1=dnvolp1/(float(nrans)*float(ndim2p))*volav
        dtp1=anmolp1/anvolp1
        volfre=volav-pmvslt*1.e24/avogad
        if (iop(162) .eq. 1)
     -    bulkdens=(rnmolav-1.)/(volav-pmvslt*1.e24/avogad)
        if (iop(162) .eq. 2)
     -    bulkdens=anmolp1/(anvolp1-pmvslt*1.e24/avogad)
        if (iop(162) .eq. 3) bulkdens=avogad/(pmvslv*1.e24)
        if (iop(162) .eq. 4) bulkdens=(rnmolav-1.)/(volav-volslt0)
        gfac=float(nrans)*float(ndim2p)/(float(ncnfpx)*volav*bulkdens)
        ivolav=volav
        if (iop(142) .gt. 1 .and. nrans .lt. ivolav) then
          write (iout,2029)
          nwarn=nwarn+1
        end if
      else if (iop(142) .gt. 1) then
        write (iout,2028)
        inperr=inperr+1
        bulkdens=avogad/(pmvslv*1.e24)
      end if
      mxpxgrd=max0(mxpxsltgrd,mxpxwwgrd)
      do is=1,mxpxgrd
        grd(is)=rpxdiv*is-rpxdiv/2.0
        gdv(is)=float(ncnfpx)*4.0*pi*rpxdiv*grd(is)**2*bulkdens
      end do
      if (iop(156) .eq. 0) write (iout,2000) (grd(i),i=1,mxpxgrd)
      do is=1,nsltpxgr
        if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
          ifs=0
          if (is .gt. 1) ifs=ilastg(is-1)
          ndupis=ndupgr(is)
          if (iop(142) .gt. 1 .and. nrans .ne. 0 .and.
     -        nwpg(is) .ne. 0) then
c           Compute radial distribution fct
            do i=1,mxpxsltgrd1
              gr(i)=0.0
              if (nrnslt(i,is) .gt. 0)
     -          gr(i)=float(ngrslt(i,is))/float(nrnslt(i,is))*gfac
            end do
c           Compute the running coordination numbers
            isum=0
            do i=1,mxpxsltgrd1
              isum=isum+ngrslt(i,is)
              rcoord(i)=float(isum)/float(ncnfpx*ndupis)
            end do
            call checkint(isum,'isum/GR',7,iout,nwwarn,inperr)
c           Compute and print the estimates of volume elements
            do i=1,mxpxsltgrd1
              grn(i)=nrnslt(i,is)/
     -          (float(nrans)*float(ndim2p*ndupis))*volav
            end do
            if (iop(149) .eq. 0) then
c             No density weighting
              dfac=1.0
            else if (iop(149) .eq. 1) then
c             Weighting with total primary area density
              if (dens(is) .gt. 0.0) dfac=dtp/dens(is)
            else
c             Weighting with the considered primary area density
              if (dens1(is) .gt. 0.0) dfac=dtp1/dens1(is)
            end if
            if (dfac .ne. 0.0 .and. dfac .ne. 1.0) then
              do i=1,mxpxsltgrd1
                gr(i)=gr(i)*dfac
              end do
            end if
            call gext(1,mxpxsltgrd1,gr,+1,imx1)
            call gext(imx1,mxpxsltgrd1,gr,-1,imn1)
            call gext(imn1,mxpxsltgrd1,gr,+1,imx2)
            call nearst(mxpxsltgrd1,gr,inear,ifar)
            if (nearmn .gt. inear) then
              isnear=is
              nearmn=inear
            end if
            gpxmx1(is)=gr(imx1)
            gpxmn1(is)=gr(imn1)
            gpxmx2(is)=gr(imx2)
            rpxmx1(is)=grd(imx1)
            rpxmn1(is)=grd(imn1)
            rpxmx2(is)=grd(imx2)
            rpxnr(is)=grd(inear)
            rpxfar(is)=grd(ifar)
            rkfrdf(is)=rcoord(imn1)
            imn2=min0(mxpxsltgrd1,imn1+idiaslv)
            rksrdf(is)=rcoord(imn2)
            vsh=0.0
            do i=1,imn1
              vsh=vsh+grn(i)
            end do
            vfrdf(is)=vsh
            do i=imn1+1,imn2
              vsh=vsh+grn(i)
            end do
            vsrdf(is)=vsh
            if (iop(156) .eq. 0) then
              call disthead('Primary radial distribution function',36,
     -          ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) (gr(i),i=1,mxpxsltgrd1)
              write (iout,2002) grd(imx1),gr(imx1),grd(imn1),gr(imn1),
     -          grd(imx2),gr(imx2),grd(inear),grd(ifar)
              call disthead('Primary running coordination numbers',36,
     -          ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) (rcoord(i),i=1,mxpxsltgrd1)
              if (iop(157) .gt. 0) then
                call disthead('Volume element estimates',24,ndupgr(is),
     -            ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
                write (iout,2004) sqrt(rgpxsltmax2),rnvol1(is),cumul,
     -            rnvol2(is)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
                write (iout,2037) (grn(i),i=1,mxpxsltgrd1)
              end if
            end if
          else
            call zeroit(gr,mxpxsltgrd1)
            call zeroit(grn,mxpxsltgrd1)
            call zeroit(rcoord,mxpxsltgrd1)
          end if
          if (iop(143) .gt. 0) then
c         Print total g(r) and running coordination number
            isum=0
            do i=1,mxpxsltgrd
              isum=isum+ngtslt(i,is)
              rcoort(i)=float(isum)/float(ncnfpx*ndupis)
              grt(i)=float(ngtslt(i,is))/gdv(i)/float(ndupis)
            end do
            call gext(1,mxpxsltgrd1,grt,+1,imx1)
            call gext(imx1,mxpxsltgrd1,grt,-1,imn1)
            call gext(imn1,mxpxsltgrd1,grt,+1,imx2)
            call nearst(mxpxsltgrd1,grt,inear,ifar)
            if (nearmn .gt. inear) then
              isnear=is
              nearmn=inear
            end if
            gtmx1(is)=grt(imx1)
            gtmn1(is)=grt(imn1)
            gtmx2(is)=grt(imx2)
            rtmx1(is)=grd(imx1)
            rtmn1(is)=grd(imn1)
            rtmx2(is)=grd(imx2)
            rtnear(is)=grd(inear)
            rtfar(is)=grd(ifar)
            if (iop(156) .eq. 0) then
              call disthead('Total radial distribution function',34,
     -          ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) (grt(i),i=1,mxpxsltgrd1)
              write (iout,2002) grd(imx1),grt(imx1),grd(imn1),grt(imn1),
     -          grd(imx2),grt(imx2),grd(inear),grd(ifar)
              call disthead('Total running coordination numbers',34,
     -          ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) (rcoort(i),i=1,mxpxsltgrd1)
            end if
          else
            call zeroit(rcoort,mxpxsltgrd)
            call zeroit(grt,mxpxsltgrd)
          end if
          if (iop(153) .gt. 0) then
c           Write distributions to idistrpx for plot
            write (idistrpx,1005) is,mxpxsltgrd1,'gkr',ndupis
            write (idistrpx,1000) (grd(i),gr(i),rcoord(i),grt(i),
     -        rcoort(i),i=1,mxpxsltgrd1)
          end if
        end if
      end do
      if (nrans .gt. 0 .and. iop(156) .eq. 0) then
        do is=1,nsltpxgr
          dens(is)=dens(is)*wmslv*wmmltona3
          dens1(is)=dens1(is)*wmslv*wmmltona3
          dens2(is)=dens2(is)*wmslv*wmmltona3
        end do
        dtpgml=dtp*wmslv*wmmltona3
        write (iout,2007) 'occupied by the solvent',
     -    anvolp,anmolp,dtpgml
        write (iout,2008) (rnmol(is),is=1,nsltpxgr)
        write (iout,2009) (rnvol(is),is=1,nsltpxgr)
        write (iout,2010) (dens(is),is=1,nsltpxgr)
        dtpgml=dtp1*wmslv*wmmltona3
        write (iout,2007) 'considered (i.e., within the rdf range)',
     -    anvolp1,anmolp1,dtpgml
        write (iout,2011) perat,(rnmol1(is),is=1,nsltpxgr)
        write (iout,2012) perat,(rnvol1(is),is=1,nsltpxgr)
        write (iout,2013) perat,(dens1(is),is=1,nsltpxgr)
        if (ndupfnd .gt. 0) then
          write (iout,2011) cumul,(rnmol2(is),is=1,nsltpxgr)
          write (iout,2012) cumul,(rnvol2(is),is=1,nsltpxgr)
          write (iout,2013) cumul,(dens2(is),is=1,nsltpxgr)
        end if
      end if
      if (iop(169) .gt. 0) then
        do k=1,3
          rdipsys(k)=dipsys(k)/float(ncnfpx)
          rdipslt(k)=dipslt(k)/float(ncnfpx)
          rdipslv(k)=dipslv(k)/float(ncnfpx)
        end do
        rdipsys2=dipsys2/float(ncnfpx)
        rdipslt2=dipslt2/float(ncnfpx)
        rdipslv2=dipslv2/float(ncnfpx)
        do is=1,nsltpxgr
          do k=1,3
            rdpg(k,is)=dipoleg(k,is)/float(ncnfpx)
            rdp0(k,is)=dipole0(k,is)/float(ncnfpx)
            rdp1(k,is)=dipole1(k,is)/float(ncnfpx)
            rdp2(k,is)=(dipole1(k,is)-dipole0(k,is))/float(ncnfpx)
            rDipole(k,is)=Dipole(k,is)/float(ncnfpx)
          end do
          r_dpg(is)=sclprd(rdpg(1,is),rdpg(1,is))
          r_dp0(is)=sclprd(rdp0(1,is),rdp0(1,is))
          r_dp1(is)=sclprd(rdp1(1,is),rdp1(1,is))
          r_dp2(is)=sclprd(rdp2(1,is),rdp2(1,is))
          rDipl2(is)=sclprd(rDipole(1,is),rDipole(1,is))
          rdpg2(is)=dipoleg2(is)/float(ncnfpx)
          rdp02(is)=dipole02(is)/float(ncnfpx)
          rdp12(is)=dipole12(is)/float(ncnfpx)
          rdp22(is)=dipole22(is)/float(ncnfpx)
          rDipole2(is)=Dipole2(is)/float(ncnfpx)
        end do
        tmp=sclprd(rdipsys,rdipsys)
        write (iout,2122)
        write (iout,2123) 'solute+solvent',(rdipsys(k),k=1,3),tmp,
     -    rdipsys2,rdipsys2-tmp
        tmp=sclprd(rdipslt,rdipslt)
        write (iout,2123) 'solute only   ',(rdipslt(k),k=1,3),tmp,
     -    rdipslt2,rdipslt2-tmp
        tmp=sclprd(rdipslv,rdipslv)
        write (iout,2123) 'solvent only  ',(rdipslv(k),k=1,3),tmp,
     -    rdipslv2,rdipslv2-tmp
        write (iout,2117) sqrt(rgpxsltmax2)
        write (iout,2118) (is,(labslt(k,is),k=1,2),rdpg2(is),
     -    (rdpg(k,is),k=1,3),r_dpg(is),
     -    rdpg2(is)-r_dpg(is),rnvol2(is),is=1,nsltpxgr)
        write (iout,2113)
        write (iout,2118) (is,(labslt(k,is),k=1,2),rdp02(is),
     -    (rdp0(k,is),k=1,3),r_dp0(is),
     -    rdp02(is)-r_dp0(is),volfs(is),is=1,nsltpxgr)
        write (iout,2114)
        write (iout,2118) (is,(labslt(k,is),k=1,2),rdp12(is),
     -    (rdp1(k,is),k=1,3),r_dp1(is),
     -    rdp12(is)-r_dp1(is),vol2fs(is),is=1,nsltpxgr)
        write (iout,2115)
        write (iout,2118) (is,(labslt(k,is),k=1,2),rdp22(is),
     -    (rdp2(k,is),k=1,3),r_dp2(is),
     -    rdp22(is)-r_dp2(is),vol2fs(is)-volfs(is),is=1,nsltpxgr)
        write (iout,2116) rsolmn,rsolmx
        write (iout,2118) (is,(labslt(k,is),k=1,2),rDipole2(is),
     -    (rDipole(k,is),k=1,3),
     -    rDipl2(is),rDipole2(is)-rDipl2(is),rnvols(is),is=1,nsltpxgr)
      end if
c     Print solute pair-energy QCDF and running coordination no
400   if (iop(146) .eq. 0 .or. #GE .eq. 1 .or. iop(156) .gt. 0)
     -  go to 500
      do i=1,#GE
        egr(i)=epmink+i*epdivk-epdivk/2.0
      end do
      do is=1,nsltpxgr
        if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
          ifs=0
          if (is .gt. 1) ifs=ilastg(is-1)
          ndupis=ndupgr(is)
          if (nwfspg(is) .gt. 0) then
            do i=1,#GE
              sltep(i)=float(nsltep(i,is))/float(nwfspg(is))
            end do
            isum=0
            do i=1,#GE
              isum=isum+nsltep(i,is)
              rcoore(i)=float(isum)/float(ncnfpx)
            end do
            call checkint(isum,'isum/PE',7,iout,nwwarn,inperr)
            if (iop(156) .eq. 0) then
              write (iout,2014) is,epmink,epdivk
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) sltep
              call glims(epmink,epdivk,0,sltep,#GE,0.001,iout,' ')
              call disthead(
     -       'Running coordination number as a function of pair energy',
     -          56,ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,
     -          iout)
                if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -            iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) (rcoore(i),i=1,#GE)
            end if
            if (iop(153) .gt. 0) then
c             Write distributions on idistrpx to plot
              j=#GE
              write (idistrpx,1005) is,j,'xpe',ndupis
              do i=1,#GE
                write (idistrpx,1001) egr(i),sltep(i),rcoore(i)
              end do
            end if
          end if
        end if
      end do
500   if (iop(147) .gt. 0 .and.
     -  (iop(156) .eq. 0 .or. iop(153) .gt. 0)) then
        if (iop(142) .lt. 2 .and. iop(143) .eq. 0) then
c         Obtain bulk density and grd since it hasn't been computed yet
          do i=1,mxpxwwgrd
            grd(i)=rpxdiv*i-rpxdiv/2.0
          end do
          if (iop(162) .eq. 1)
     -      bulkdens=(rnmolav-1.)/(volav-pmvslt*1.e24/avogad)
          if (iop(162) .eq. 3) bulkdens=avogad/(pmvslv*1.e24)
        end if
c       Print g(o-o)'s
        do i=1,mxpxwwgrd
          gdv(i)=bulkdens*4.0*pi*rpxdiv*grd(i)**2
        end do
        mxpxwwgrd1=mxpxwwgrd-1
        do is=1,nsltpxgr
          if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
            if (npxwwg(is) .gt. 0) then
              do iv=1,nijgvvp
                dupfac=1.0
                if (islvirep(iv) .ne. islvjrep(iv)) dupfac=2.0
                do j=1,mxpxwwgrd1
                  groo(j,iv)=float(ngoo(j,is,iv))/float(npxwwg(is))/
     -              (dupfac*gdv(j))
                end do
                ifs=0
                if (is .gt. 1) ifs=ilastg(is-1)
                ndupis=ndupgr(is)
                if (iop(156) .eq. 0) then
                  write (iout,2042) is,islvirep(iv),islvjrep(iv)
                  if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -              iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
                  write (iout,2037) (groo(i,iv),i=1,mxpxwwgrd1)
                  call gext(1,mxpxwwgrd1,groo(1,iv),+1,imx1)
                  call gext(imx1,mxpxwwgrd1,groo(1,iv),-1,imn1)
                  call gext(imn1,mxpxwwgrd1,groo(1,iv),+1,imx2)
                  call nearst(mxpxwwgrd1,groo(1,iv),inear,ifar)
                  write (iout,2002) grd(imx1),groo(imx1,iv),grd(imn1),
     -              groo(imn1,iv),grd(imx2),groo(imx2,iv),grd(inear),
     -              grd(ifar)
                end if
                if (iop(153) .gt. 0) then
c                 Write distributions on idistrpx to plot
                  write (idistrpx,1010) is,mxpxwwgrd1,'gvv',nijgvvp
                  do i=1,mxpxwwgrd1
                    write (idistrpx,1001) grd(i),
     -                (groo(i,ivv),ivv=1,nijgvvp)
                  end do
                end if
              end do
            end if
          end if
        end do
      end if
      if (iop(145) .eq. 0) go to 800
      do i=1,#LG
        dg(i)=float((i-1)*#LG)/180.0+#LG/360.0
      end do
c     Print solute-water orientational correlations
      do is=1,nsltpxgr
        if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
          ifs=0
          if (is .gt. 1) ifs=ilastg(is-1)
          ndupis=ndupgr(is)
          call zeroit(tav,mxpxsltgrd)
          call zeroit(xtd,#LG)
          do i=1,mxpxsltgrd
            if (ngrslt(i,is) .ne. 0) then
              cosd=tdavr(i,is)/float(ngrslt(i,is))
              if (cosd .lt. -1.0) cosd=-1.0
              if (cosd .gt. +1.0) cosd=+1.0
              tav(i)=acoscheck(cosd,iout,'DISFINPX')*rdtodg
            end if
          end do
          call gext(1,mxpxsltgrd1,tav,+1,imx1)
          call gext(1,mxpxsltgrd1,tav,-1,imn1)
          dpxmx(is)=tav(imx1)
          rdpxmx(is)=grd(imx1)
          dpxmn(is)=tav(imn1)
          rdpxmn(is)=grd(imn1)
          if (iop(156) .eq. 0) then
            if (nwfspg(is) .gt. 0 .and. #LG .gt. 1) then
              do i=1,#LG
                xtd(i)=float(nxtd(i,is))/float(nwfspg(is))
              end do
              call disthead(
     -          'Near-neighbour dipole angle distribution [0 - 180]',
     -          40,ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,
     -          iout)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) xtd
              call glims(0.0,(180.0/#LG.0),0,xtd,#LG,0.001,iout,' ')
            end if
            if (nwpg(is) .gt. 0) then
            call disthead('Avg dipole angle as a function of distance',
     -        42,ndupgr(is),ixprt(ifs+1),is,iop(25),namfcg,itypfg,iout)
              if (ndupis .le. 10) write (iout,2024) (ixprt(ifs+j),
     -          iaprt(ifs+j),(labpr(k,ifs+j),k=1,2),j=1,ndupis)
              write (iout,2037) (tav(i),i=1,mxpxsltgrd1)
            end if
          end if
          if (iop(153) .gt. 0) then
c           Write distributions on idistrpx for plot
            write (idistrpx,1005) is,mxpxsltgrd1,'tav',ndupis
            write (idistrpx,1009) (grd(i),tav(i),i=1,mxpxsltgrd1)
            if (#LG .gt. 1) then
              write (idistrpx,1005) is,#LG,'xtd',ndupis
              write (idistrpx,1009) (dg(i),xtd(i),i=1,#LG)
            end if
          end if
        end if
      end do
800   if (iop(144) .gt. 0) then
c       Output of the forces on the solute atoms
C@TS        call zeroit(fsltt,3)
C@TS        do k=1,3
C@TS          do is=1,nstta
C@TS            fsltt(k)=fsltt(k)+ftslt(k,is)
C@TS          end do
C@TS        end do
C@TS        do k=1,3
C@TS          fsltt(k)=fsltt(k)/dfloat(ncnfpx)
C@TS        end do
C@TS        write (iout,2017) fsltt
C@TS        do is=1,nstta
C@TS          do k=1,3
C@TS            fst(k)=ftslt(k,is)/dfloat(ncnfpx)
C@TS            fssd(k)=ftslt2(k,is)/dfloat(ncnfpx)
C@TS            fssd(k)=sqrt(abs(fssd(k)-fst(k)**2))
C@TS          end do
C@TS          write (iout,2023) is,labslt(1,is),igrslt(is),
C@TS     -    labslt(2,is),(lxyz(k),fst(k),fssd(k),k=1,3)
C@TS        end do
C@TS        do it=1,ntang
C@TS          torque=trqbnd(it)/dfloat(ncnfpx)
C@TS          torque2=trqbnd2(it)/dfloat(ncnfpx)
C@TS          sd=sqrt(abs(torque2-torque**2))
C@TS          write (iout,2032) it,(iquata(it,k),
C@TS     -      (labslt(kk,iquata(it,k)),kk=1,2),k=2,3),torque,sd
C@TS        end do
      end if
      if (iop(111) .gt. 0 .and. iop(159) .eq. 0)
     -  call disfin_dipoledist(gdipc,dndipmom,nmc,numrun,rdtodg,
     -    iop(24),inperr,iout)
c     Calculate and write field gradient averages
      if (iop(166) .gt. 0)
     -   call disfinfldgrd(nmolec,nfg,nsttm,ncnfpx,movmolf,movmoll,iout)
      if (iop(174) .gt. 0 .and. iop(160) .ne. 3)
     -  call disfinengdec(ifgrslt,ilgrslt,ncnfpx,iout)
c     Calculate and write Widom or chimera calculation results
      if (iop(30) .eq. 1) call disfinwidom(ncnfpx,molcnt)
      if (iop(30) .eq. 2) call disfinchim(ncnfpx,molcnt,ifgrslt)
      if (iop(30) .eq. 3) call disfinaddwidom(ncnfpx,molcnt)
      if (iop(176) .gt. 0) then
        do id=1,ntang
          cvar=1.0-dsqrt(sinsum(id)**2+cossum(id)**2)/ncnfpx
          nzg=0
          do ig=1,#TD
            if (itangd(ig,id) .ne. 0) nzg=nzg+1
          end do
          write (iout,2125) id,(igrslt(iquata(id,ii)),iquata(id,ii),
     -      (labslt(k,iquata(id,ii)),k=1,2),ii=2,3),cvar,nzg,
     -      rdtodg*pi2/#TD.0,(itangd(ig,id),ig=1,#TD)
        end do
      end if
c-----Tabulated output, grouped by functional groups
      call crstrpx(0)
      if (iop(142)+iop(146)+iop(148) .gt. 0) then
c       Call tabulator routine to calculate fcg coordination numbers
c       to be used to scale the molecular error estimates to get fcg error est.
        call pxtabl(ipxt1,pxt1,ipxt2,pxt2,1,iop(24)-2,vfss,rkfss,rkden,
     -    r2kfss,bfss,pfss,rks,bs,rkw,ennww,beww,volav,0,nfgtyp,0,0,1,
     -    numrun)
        call errestpx(npxcntin,lumppr,nfgtyp)
        ifcgtabp=1
        if (iop(158) .eq. 2) ifcgtabp=0
        m1=-1
        if (idebug(45) .gt. 0) m1=0
        if (nsltpxgr .ge. nsltpx2-nsltpx1+1 .or. iop(158) .ge. 2) then
c         Tabulate all atoms
          call pxtabl(ipxt1,pxt1,ipxt2,pxt2,m1,1,vfss,rkfss,rkden,
     -      r2kfss,bfss,pfss,rks,bs,rkw,ennww,beww,volav,1,nfgtyp,0,0,
     -      ifcgtabp,numrun)
        else
c         Double tabulation (condensed atom list with orig fcg's)
          i2nd=0
          if (iop(158) .eq. 0 .or. iop(24) .gt. 1) then
            call pxtabl(ipxt1,pxt1,ipxt2,pxt2,m1,1,vfss,rkfss,rkden,
     -        r2kfss,bfss,pfss,rks,bs,rkw,ennww,beww,volav,1,nfgtyp,0,0,
     -        ifcgtabp,numrun)
            i2nd=1
          end if
          if (iop(158) .le. 1)
     -      call pxtabl(ipxt1,pxt1,ipxt2,pxt2,m1,1,vfss,rkfss,rkden,
     -        r2kfss,bfss,pfss,rks,bs,rkw,ennww,beww,volav,1,nfgtyp,1,
     -        i2nd,ifcgtabp,numrun)
        end if
        call crstrpx(0)
      end if
      if (iop(143) .gt. 0) then
c       Tabulate total g(r) peaks
        write (iout,2039) ident,mcmd8,nmcpxo,numrun
        do is=1,nsltpxgr
          if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
            ifst=1
            if (is .gt. 1) ifst=ilastg(is-1)+1
            labgr=iaprt(ifst)
            if (iop(25) .gt. 1) labgr=namfcg(is,2)
            write (iout,2040) is,labgr,(labpr(k,ifst),k=1,2),
     -        rtmx1(is),gtmx1(is),rtmn1(is),gtmn1(is),
     -        rtmx2(is),gtmx2(is),rtnear(is),rtfar(is)
          end if
        end do
      end if
      if (iop(142) .gt. 1) then
        pmvsv=pmvslv*1.e+24/avogad
c       Tabulate primary g(r) peaks
        write (iout,2046) ident,mcmd8,nmcpxo,numrun
        do is=1,nsltpxgr
          if (nwpg(is) .gt. 0 .or. iop(165) .eq. 0) then
            rfss=amin1(rpxmn1(is)+rfsww,#RG*rpxdiv)
            dfs=0
            dss=0
            if (vfrdf(is) .ne. 0.0) dfs=pmvsv*rkfrdf(is)/vfrdf(is)
            if (vsrdf(is) .ne. 0.0) dss=pmvsv*rksrdf(is)/vsrdf(is)
            ifst=1
            if (is .gt. 1) ifst=ilastg(is-1)+1
            labgr=iaprt(ifst)
            if (iop(25) .gt. 1) labgr=namfcg(is,2)
            write (iout,2040) is,labgr,(labpr(k,ifst),k=1,2),
     -        rpxmx1(is),gpxmx1(is),rpxmn1(is),gpxmn1(is),
     -        rpxmx2(is),gpxmx2(is),rpxnr(is),rpxfar(is),'  ',
     -        vfrdf(is),rkfrdf(is),dfs,rfss,vsrdf(is),rksrdf(is),dss
          end if
        end do
c       Print closest approach, print warning if necessary
        if (nearmn .lt. 100000) then
          write (iout,2021) grd(nearmn),isnear
          if (grd(nearmn) .lt. 1.5) then
            write (iout,2022)
            nwarn=nwarn+1
            if (grd(nearmn) .lt. 1.0) then
              write (iout,2030)
              nwwarn=nwwarn+1
            end if
          end if
        end if
        if (iop(172) .gt. 0) then
          if (iop(172) .eq. 1) then
c           Collect atomic numbers used
            call trnsfi(indexn,ianslt,nsltpx2)
            maxtyps=99
            write (iout,2044) 'elements'
            typname='atno'
          else
c           Collect atomtypes used
            do iss=nsltpx1,nsltpx2
              indexn(iss)=iclslt(iss)+4096*iopslt(iss)
            end do
            maxtyps=#AT
            write (iout,2044) 'potential types'
            typname='type'
          end if
          ntyps=0
          do ip=1,9
            if (npfused(ip) .gt. 0) then
              do it=1,maxtyps
                do is=1,nsltpxgr
                  if (indexn(l2(is)) .eq. it+4096*ip) then
                    ntyps=ntyps+1
                    indexx(ntyps)=it+4096*ip
                    go to 3011
                  end if
                end do
3011            continue
              end do
            end if
          end do
c         Calculate averages over elements
          nrdftot=0
          nametyp='         '
          do itt=1,ntyps
            itip=indexx(itt)
            if (iop(172) .eq. 1) then
              nametyp(1:4)=iatnam(itip)
            else
              ip=itip/4096
              it=mod(itip,4096)
              nametyp(1:6)=pflab(it,ip)
              if (pflab(it,ip)(6:6) .eq. ' ') then
                nametyp(6:9)=ipf(ip)
              else
                nametyp(7:9)=ipf(ip)(1:3)
              end if
            end if
            rmx1=0.0
            rmn1=0.0
            rmx2=0.0
            grmx1=0.0
            grmn1=0.0
            grmx2=0.0
            rmx1s=0.0
            rmn1s=0.0
            rmx2s=0.0
            grmx1s=0.0
            grmn1s=0.0
            grmx2s=0.0
            nrdf=0
            do is=1,nsltpxgr
              if (indexn(l2(is)) .eq. itip) then
                nrdf=nrdf+1
                rmx1=rmx1+rpxmx1(is)
                rmn1=rmn1+rpxmn1(is)
                rmx2=rmx2+rpxmx2(is)
                grmx1=grmx1+gpxmx1(is)
                grmn1=grmn1+gpxmn1(is)
                grmx2=grmx2+gpxmx2(is)
                rmx1s=rmx1s+rpxmx1(is)**2
                rmn1s=rmn1s+rpxmn1(is)**2
                rmx2s=rmx2s+rpxmx2(is)**2
                grmx1s=grmx1s+gpxmx1(is)**2
                grmn1s=grmn1s+gpxmn1(is)**2
                grmx2s=grmx2s+gpxmx2(is)**2
              end if
            end do
            if (nrdf .gt. 0) then
              rmx1=rmx1/nrdf
              rmn1=rmn1/nrdf
              rmx2=rmx2/nrdf
              grmx1=grmx1/nrdf
              grmn1=grmn1/nrdf
              grmx2=grmx2/nrdf
              rmx1s=sqrt(abs(rmx1s/nrdf-rmx1*rmx1))
              rmn1s=sqrt(abs(rmn1s/nrdf-rmn1*rmn1))
              rmx2s=sqrt(abs(rmx2s/nrdf-rmx2*rmx2))
              grmx1s=sqrt(abs(grmx1s/nrdf-grmx1*grmx1))
              grmn1s=sqrt(abs(grmn1s/nrdf-grmn1*grmn1))
              grmx2s=sqrt(abs(grmx2s/nrdf-grmx2*grmx2))
              write (iout,2045) typname,it,nametyp,rmx1,rmx1s,grmx1,
     -          grmx1s,rmn1,rmn1s,grmn1,grmn1s,rmx2,rmx2s,grmx2,grmx2s,
     -          nrdf
              nrdftot=nrdftot+nrdf
            end if
          end do
          if (nrdftot .ne. nsltpxgr) write (iout,2035) nrdftot
        end if
      end if
      if (iop(145) .gt. 0) then
c       Tabulate <dipole angle(r)> min and max
        write (iout,2041) ident,mcmd8,nmcpxo,numrun
        do i=1,nsltpxgr
          if (nwpg(i) .gt. 0 .or. iop(165) .eq. 0) then
            ifst=1
            if (i .gt. 1) ifst=ilastg(i-1)+1
            write (iout,2040) i,iaprt(ifst),(labpr(k,ifst),k=1,2),
     -        rdpxmx(i),dpxmx(i),rdpxmn(i),dpxmn(i)
          end if
        end do
      end if
c-----Residence time calculation, output (if any)
      call disfinrestim(ncnfpx,navgpx,nsltpxgr,nmolec,irtm,iop(171),
     -  nmcpxo,mcmd8,inperr,iout)
c-----Diffusion constant calculation, output
      if (iop(177) .gt. 0)
     -   call disfindifc(nsltpxgr,iout,timestep,navgpx)
c-----Sensitivity coefficient output (if not done by MMC)
      if (iop(82) .gt. 0 .and. iop(159) .eq. 0) call dvpsltfin
      return
1000  format(5f8.3)
1001  format(10f8.4)
1002  format(2i5)
1003  format(20i4)
1004  format(20a4)
1005  format(' is=',i4,' ngrids=',i4,1x,a3,1x,i4)
1010  format(' is=',i4,' ngrids=',i4,1x,a3,' ngvv=',i2)
1009  format(2f9.4)
2000  format(/,' Midpoints of the radial distribution function grid:',/,
     -  (1x,15f8.3))
 
2002  format(' First max: g(',f6.3,')=',f7.3,' first min: g(',f6.3,')=',
     -  f7.3,' Second max: g(',f6.3,')=',f7.3,'  nearest slv=',f6.2,
     -  ' range=',f7.2)
2004  format(' Total volume per region (within ',f6.2,' A)=',f10.3,' (',
     -  a,')=',f10.3,' A**3')
2005  format(' Number of random points=',i10)
2006  format(/,' Computation stopped. Last configuration analyzed was ',
     -  'at ',a,'=',i10,' number of configurations analysed=',i8)
2007  format(/,' The total volume ',a,'=',f10.3,' A**3',/,' The ',
     -  'average number of solvent molecules=',f10.3,
     -  '  Density=',f9.5,' g/ml')
2008  format(' Average number of solvent molecules in the total ',
     -  'primary areas=',/,(1x,10f12.4))
2009  format(' Volumes of the total primary areas=',
     -  /,(1x,10f12.4))
2010  format(' Densities in the total primary areas (g/ml)=',
     -  /,(1x,10f12.4))
2011  format(' Average number of solvent molecules in the considered ',
     -  'regions of the primary areas (',a,')=',/,(1x,10f12.4))
2012  format(' Volumes of the considered regions of the primary ',
     -  'areas (',a,', in A**3)=',/,(1x,10f12.4))
2013  format(' Densities in the considered regions of the primary ',
     -  'areas (',a,', g/ml)=',/,(1x,10f12.4))
2014  format(/,' Distribution of the solute-water near-neighbour',
     -  ' pair energies  *****',i4,' ***** :',/,
     -  ' minimum=',f10.4,' gridsize=',f10.4,' (kcal/mol)')
2015  format(' Rfsl=',12f4.1,/,(24f4.1))
2016  format(' ***** PROGRAM ERROR: did not find atomindex',i7)
C@TS2017  format(' Total solvent force on the solute :',3e13.5,//,
C@TS     -  ' Total solvent forces on the solute atoms (kcal/mol/A)=')
2021  format(/,' Shortest solute-solvent distance=',f8.3,' a found for',
     -  ' the',i4,'-th radial distribution function')
2022  format(' --- WARNING: solvent gets too close to the solute')
C@TS2023  format(i7,1x,a4,i6,1x,a4,3(' F',a1,'=',e12.5,' SD=',e8.2))
2024  format((1x,7('(',i4,1x,a2,1x,2a4,')')))
2025  format(' (record number=',i6,' stack number=',i4,')')
2026  format(' Average number of solvent molecules=',f10.4)
2027  format(' Estimate of the solute volume from primary rdfs=',f12.5,
     -  ' A**3')
2028  format(' ***** ERROR: Can not generate primary RDFs since no ',
     -  'random numbers were generated')
2029  format(' ----- WARNING: primary RDFs will be imprecise since too',
     -  ' few random numbers were generated')
2030  format(' ===== STRONG WARNING: solvent gets very close to the ',
     -  'solute')
2031  format(/,' List of solute atoms contributing to each ',
     -  'distribution:')
C@TS2032  format(' Torsion bond',i6,': Atom',i6,' (',a4,1x,a4,') - Atom',
C@TS     -  i6,' (',a4,1x,a4,') Torque=',e12.5,' SD=',e10.3)
2033  format(' ===== STRONG WARNING: total estimated volume is zero ',
     -  ' for non-empty group ',i3)
2034  format(' ----- WARNING: system appears to be far from liquid ',
     -  'density - solute volume estimate will be way too large')
2035  format(' The number of RDFs contributing to the averages=',i4)
2037  format(1x,15f8.3)
2038  format(1x,15f8.4)
2039  format(/,2(1x,a80,/),/,' Last ',a8,'=',i10,4x,
     -  ' Run no=',i3,' Total atomic g(r)',/,20x,
     -  '  Rmx1 g(Rmx1)  Rmn1 g(Rmn1)  Rmx2 g(Rmx2) Rnear  Range',/)
2040  format(i5,1x,a4,1x,2a4,8f7.2,a4,3x,2f7.2,f7.3,f7.2,f7.1,f7.2,f7.3)
2041  format(/,2(1x,a80,/),/,' Last ',a8,'=',i10,4x,
     -  ' Run no=',i3,' Average dipole angle as a function of r',/,
     -  20x,'   Rmx dp(Rmx)   Rmn dp(Rmn)  ',/)
2042  format(/,' Solvent-solvent radial distribution function for the',
     -  ' ***',i4,'-th primary region between solvent atoms',2i4,' :')
2044  format(' Averages over ',a,':',/,20x,'<Rmx1>',7x,'<g(Rmx1)>',6x,
     -  '<Rmn1>',7x,'<g(Rmn1)>',6x,'<Rmx2>',7x,'<g(Rmx2)>',6x,'Nrdf')
2045  format(1x,a4,'=',i3,1x,a9,6(f6.2,'+/-',f5.2),i4)
2046  format(/,2(1x,a80,/),/,' Last ',a8,'=',i10,4x,
     -  ' Run no=',i3,' Primary atomic g(r)',t84,' R(fsh)=Rmn1 ',
     -  t106,' R(shl)=R(fsh)+Rslv'/,20x,
     -  '  Rmx1 g(Rmx1)  Rmn1 g(Rmn1)  Rmx2 g(Rmx2) Rnear  Range',8x,
     -  '  Vfs     Kfs  Dfs      Rss   Vss    Kss    Dss',/)
2113  format(/,'Dipole moment and volume within first hydration shell')
2114  format(/,'Dipole moment and volume within the first two ',
     -  'hydration shells')
2115  format(/,'Dipole moment and volume difference between the ',
     -  'second and first hydration shells')
2116  format(/,'Dipole moment and volume in the ',f8.4,' - ',
     -  f8.4,' A range from the solute')
2117  format(/,'Dipole moment and volume within ',f8.5,
     -  ' A of the solute')
2118  format(19X,"<M^2>",5X,"Mx",7X,"My",7X,"Mz",5X,"<M>^2",
     -     1X,"<M^2>-<M>^2",1X,"Volume",
     -  /,(I5,1x,2a4,1x,6f9.3,f9.2))
2122  format(/,'Dipole moment in the system:',/,
     -  (22X,"Mx",8X,"My",8X,"Mz",7X,"<M>^2",8X,"<M^2>",5X,
     -     "<M^2>-<M>^2"))
2123  format(a14,3f10.3,3f13.3)
2125  format(' Torsion angle ',i5,' (Res ',i5,' Atom ',i6,1x,2a4,' - ',
     -  ' Res ',i5,' Atom ',i5,1x,2a4,')',/,' Circular variance=',f6.3,
     -  ' Number of nonempty grids=',i3,
     -  ' distribution (gridsize=',f5.1,' deg):',/,(6x,15i8))
2130  format(' Average number of hydrogen-bonded bridges=',f8.3,
     -  ' SD=',f7.3)
2131  format(' Average solute-solvent energy of bridge waters=',e12.5,
     -  ' SD=',e12.5,' kcal/mol')
2132  format(' Solute atom',i5,' (',2a4,') Average number of hydrogen ',
     -  'bonds=',f6.3,' mean energy=',e12.5,' SD=',e12.5,' kcal/mol')
2133  format(' ***** PROGRAM ERROR: anchor atom ',a4,' is not found in',
     -  ' the array bridgeat')
2134  format(' Atom type ',a4,' (',i3,' copies)',
     -  ' mean number of hydrogen bonds=',f5.3,' SD=',f5.3,
     -  ' mean energy=',e12.5,' SD=',e12.5)
2135  format(' Anchor atom type ',a4,' did not form any single ',
     -  'hydrogen bond')
2136  format(' ///// NOTE: ',i6,1x,a,' configurations had solute ',
     -  'molecules outside the simulation cell')
      end
      subroutine disthead(name,len,ndup,ifat,irdf,iop25,namfcg,ifg,iout)
c#    MMC routine 421 lstmod: 05/19/03
      character*(*) name
      character*4 namfcg
      character*132 line
      dimension namfcg(100,2),ifg(#ST)
      ig=ifg(ifat)
      nc=len+19
      write (line(1:nc),2000) name(1:len),irdf
      if (iop25 .lt. 2) then
        line(nc+1:nc+10)='functional'
        nc=nc+10
        write (line(nc+1:nc+13),2001) namfcg(ig,1)
      else
        line(nc+1:nc+4)='user'
        nc=nc+4
        write (line(nc+1:nc+13),2001) namfcg(ig,2)
      end if
      nc=nc+13
      if (ndup .gt. 1) then
        nc=nc-1
        write (line(nc+1:nc+28),2002) ndup
        nc=nc+28
      end if
      write (iout,2003) line(1:nc)
      return
2000  format(1x,a,' *****',i4,' ***** (')
2001  format(' group ',a4,'):')
2002  format(' averaged over ',i4,' regions:')
2003  format(/,a)
      end
      subroutine pxtabl(ipxt,pxt,ipxt0,pxt0,itabsav,iprint,vfss,rkfss,
     -  rkden,r2kfss,bfss,pfss,rks,bs,rkw,ennww,beww,volav,isdev,nfgtyp,
     -  icond,i2nd,ifcgtabp,numrun)
c#    MMC routine 422 lstmod: 04/05/07
c*****Tabulates proximity analysis by atoms, functional groups.
c     itabsav=1: save to pxt; =-1: restore from pxt;
c     itabsav=-2: save to pxt0 the data pxt-pxt0.
      dimension pxt(15,#SX),pxt0(15,#SX)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 ident
      common /title/ nlident,ident(2)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /rppxrad/ rppxrad2(#ST),keeppx(#ST),
     -  npxkeep,ipxkeep(2,100)
      common /rfsavg/ iwrfs(#GQ),rkpdbmin,rkgrmin,r2kgrmin,rtkgrmin
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /twopow/ ndimgen,ndim2p,kdel,ntwop(3)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      character*4 namfcg
      character*20 nmlfcg
      common /fcgnam/ igrdup(100),namfcg(100,2),nmlfcg(100,2)
      common /fcgdatpx/ fcgavg(101,12),sdev2(101,11),ndupfg(100),nfge
      real*8 blkavs
      common /btchav/ blkavs(#MI,11),nblcks
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      real*8 vfss,v2fss,rkfss,r2kfss,bfss,rks,bs,rnwws,rnpxws,
     -  bennws,bews,vfss0,v2fss0,rkfss0,r2kfss0,bfss0,rks0,bs0,
     -  rnwws0,rnpxws0,bennws0,bews0
      real*8 rkden,rkw,pfss,ennww,beww
      dimension indx1(100),indx2(100),rcfg(#ST)
      character*16 tablab(3)
      character*8 mcmd8
      character*4 openpx,closedpx,openpr,openprg
      character*132 line
      dimension ndpfgr(#ST)
      data tablab /'Full list       ','Condensed list  ',
     -             'Residue list    '/
      data openpx /' OP '/,closedpx /' CL '/
      data vfss0 /0.0/,rkfss0 /0.0/,v2fss0 /0.0/,r2kfss0 /0.0/,
     -  bfss0 /0.0/,rks0 /0.0/,bs0 /0.0/,rnwws0 /0.0/,rnpxws0 /0.0/,
     -  bennws0 /0.0/, bews0 /0.0/,vfsgs0 /0.0/,v2fsgs0 /0.0/,
     -  rfsgs0 /0.0/,r2fsgs0 /0.0/,bfsgs0 /0.0/,rgs0 /0.0/,bgs0 /0.0/,
     -  ewgs0 /0.0/,bewgs0 /0.0/,npxwwss0 /0.0/,newwnns0 /0.0/,
     -  ewwnnisis0 /0.0/,ewwisis0 /0.0/,nprint /0/,ifg /0/
      if (iop(9) .lt. 10) mcmd8='MC step '
      if (iop(9) .ge. 10) mcmd8='MD frame'
      if (ncnfpx .eq. 0) then
        write (iout,2024)
        nwwarn=nwwarn+1
        return
      end if
      pmvsv=pmvslv*1.e+24/avogad
      call zeroiti(iwrfs,0,nsltpxgr)
      if (iop(142) .lt. 2 .or. itabsav .eq. -2) then
        openpr='    '
        openprg='    '
      end if
c     First  produce the table by residues (original atom order)
      if (iprint .gt. 0 .and. i2nd .eq. 0) then
        write (iout,2031) ident,mcmd8,nmcpxo,ncnfpx,numrun,nblcks,
     -    tablab(3),rfsww,rceww,rsolmn,rsolmx,'ixrdf'
        vfss=0.d0
        v2fss=0.d0
        rkfss=0.d0
        r2kfss=0.d0
        bfss=0.d0
        rks=0.d0
        bs=0.d0
        rnwws=0.d0
        rnpxws=0.d0
        bennws=0.d0
        bews=0.d0
        if (itabsav .eq. -2) then
          vfss0=0.d0
          v2fss0=0.d0
          rkfss0=0.d0
          r2kfss0=0.d0
          bfss0=0.d0
          rks0=0.d0
          bs0=0.d0
          rnwws0=0.d0
          rnpxws0=0.d0
          bennws0=0.d0
          bews0=0.0
        end if
        do ig=nsltgru,nsttg
          openprg=closedpx
          vfsgs=0.0
          v2fsgs=0.0
          rfsgs=0.0
          r2fsgs=0.0
          bfsgs=0.0
          rgs=0.0
          bgs=0.0
          ewgs=0.0
          bewgs=0.0
          npxwwss=0
          newwnns=0
          if (itabsav .eq. -2) then
            vfsgs0=0.0
            v2fsgs0=0.0
            rfsgs0=0.0
            r2fsgs0=0.0
            bfsgs0=0.0
            rgs0=0.0
            bgs0=0.0
            ewgs0=0.0
            bewgs0=0.0
            npxwwss0=0
            newwnns0=0
          end if
          nprint=0
          do is=ifgrslt(ig),ilgrslt(ig)
            if (itabsav .ge. 0) then
              volfs=0.0
              if (nrans .gt. 0) volfs=
     -          float(nrnfs(is))/(float(nrans)*float(ndim2p))*volav
              vol2fs=0.0
              if (nrans .gt. 0) vol2fs=
     -          float(nrn2fs(is))/(float(nrans)*float(ndim2p))*volav
              rnwfpx=float(nwfspx(is))/float(ncnfpx)
              rnw2fpx=float(nw2fspx(is))/float(ncnfpx)
              bfssis=befssm(is)/float(ncnfpx)
              rnwpx=float(nwpx(is))/float(ncnfpx)
              besmis=besm(is)/float(ncnfpx)
c             Now calculate density-type quantities
              rkdens=0.0
              if (volfs .gt. 0.0) rkdens=pmvsv*rnwfpx/volfs
              r2kden=0.0
              if (vol2fs .gt. 0.0) r2kden=pmvsv*rnw2fpx/vol2fs
              pefspx=0.0
              if (nwfspx(is) .ne. 0) pefspx=bfssis/rnwfpx
c             Save solvent (water) accumulators into scalar
              newwnnis=newwnn(is)
              npxwwsis=npxwws(is)
              ewwnnisis=ewwnn(is)
              ewwisis=ewwis(is)
c             Compute water-water properties
              rkws=0.0
              if (npxwwsis .gt. 0)
     -          rkws=float(newwnnis)/float(npxwwsis)
              ewnnis=0.0
              if (newwnnis .gt. 0)
     -          ewnnis=ewwnnisis/float(newwnnis)
              bewwis=0.0
              if (npxwwsis .gt. 0)
     -          bewwis=ewwisis/float(npxwwsis)
              if (itabsav .eq. 1) then
c               Also, save data into table
                call movedat13(pxt(1,is),volfs,vol2fs,rnwfpx,rnw2fpx,
     -            rkdens,r2kden,bfssis,pefspx,rnwpx,besmis,rkws,ewnnis,
     -            bewwis,newwnnis,npxwwsis,1)
                ipxt=1
              end if
            else
c             Get data from the table
              call movedat13(pxt(1,is),volfs,vol2fs,rnwfpx,rnw2fpx,
     -          rkdens,r2kden,bfssis,pefspx,rnwpx,besmis,rkws,ewnnis,
     -          bewwis,newwnnis,npxwwsis,-1)
              ewwnnisis=ewnnis*float(newwnnis)
              ewwisis=bewwis*float(npxwwsis)
              if (ipxt .eq. 0) then
                write (iout,2023)
                call datprt(2)
              end if
              if (itabsav .eq. -2) then
c               Get 2nd data, take difference and save to pxt0
                if (ipxt0 .eq. 0) then
                  write (iout,2023)
                  call datprt(2)
                end if
                call movedat13(pxt0(1,is),volfs0,vol2fs0,rnwfpx0,
     -            rnw2fpx0,rkdens0,r2kden0,bfssis0,pefspx0,rnwpx0,
     -            besmis0,rkws0,ewnnis0,bewwis0,newwnnis0,npxwwsis0,-1)
                ewwnnisis0=ewnnis0*float(newwnnis0)
                ewwisis0=bewwis0*float(npxwwsis0)
                call arrdiff(pxt(1,is),pxt(1,is),pxt0(1,is),13)
              end if
            end if
            if (itabsav .gt. -2 .and. iop(142) .gt. 1) then
c             Decide if this atom will contribute to the rdf average
              if (rnwfpx .ge. rkgrmin .and. rnw2fpx .ge. r2kgrmin
     -          .and. rnwpx .ge. rtkgrmin) iwrfs(indxrdf(is))=1
            end if
            if (rnwpx-rnw2fpx .gt. 0.1) then
              openpr=openpx
            else
              openpr=closedpx
            end if
            if (openpr .eq. openpx) openprg=openpx
c           Collect sum for residue results
            vfsgs=vfsgs+volfs
            v2fsgs=v2fsgs+vol2fs
            rfsgs=rfsgs+rnwfpx
            r2fsgs=r2fsgs+rnw2fpx
            bfsgs=bfsgs+bfssis
            rgs=rgs+rnwpx
            bgs=bgs+besmis
            npxwwss=npxwwss+npxwwsis
            newwnns=newwnns+newwnnis
            call checkint(npxwwss,'npxwwss',7,iout,nwwarn,inperr)
            call checkint(newwnns,'newwnns',7,iout,nwwarn,inperr)
            ewgs=ewgs+ewwnnisis
            bewgs=bewgs+ewwisis
            if (itabsav .eq. -2) then
c             Accumulate reference state separately
              vfsgs0=vfsgs0+volfs0
              v2fsgs0=v2fsgs0+vol2fs0
              rfsgs0=rfsgs0+rnwfpx0
              r2fsgs0=r2fsgs0+rnw2fpx0
              bfsgs0=bfsgs0+bfssis0
              rgs0=rgs0+rnwpx0
              bgs0=bgs0+besmis0
              npxwwss0=npxwwss0+npxwwsis0
              newwnns0=newwnns0+newwnnis0
              ewgs0=ewgs0+ewwnnisis0
              bewgs0=bewgs0+ewwisis0
            end if
            if (keeppx(is) .gt. 0 .and.
     -         (iop(165) .eq. 0 .or. nwpx(is) .gt.  0)) then
              if (itabsav .eq. -2)
     -          call movedat13(pxt(1,is),volfs,vol2fs,rnwfpx,rnw2fpx,
     -            rkdens,r2kden,bfssis,pefspx,rnwpx,besmis,rkws,ewnnis,
     -            bewwis,newwnnis,npxwwsis,-1)
              nprint=nprint+1
              write (iout,2032) is,indxrdf(is),igrslt(is),
     -          iatnam(ianslt(is)),(labslt(k,is),k=1,2),rfsl(is),
     -          volfs,vol2fs,openpr,rnwfpx,rkdens,rnw2fpx,bfssis,pefspx,
     -          rnwpx,besmis,rkws,ewnnis,bewwis
            end if
          end do
c         Collect sum for molecule results
          vfss=vfss+vfsgs
          v2fss=v2fss+v2fsgs
          rkfss=rkfss+rfsgs
          r2kfss=r2kfss+r2fsgs
          bfss=bfss+bfsgs
          rks=rks+rgs
          bs=bs+bgs
          rnwws=rnwws+newwnns
          rnpxws=rnpxws+npxwwss
          bennws=bennws+ewgs
          bews=bews+bewgs
          if (itabsav .eq. -2) then
c           Accumulate reference state separately
            vfss0=vfss0+vfsgs0
            v2fss0=v2fss0+v2fsgs0
            rkfss0=rkfss0+rfsgs0
            r2kfss0=r2kfss0+r2fsgs0
            bfss0=bfss0+bfsgs0
            rks0=rks0+rgs0
            bs0=bs0+bgs0
            rnwws0=rnwws0+newwnns0
            rnpxws0=rnpxws0+npxwwss0
            bennws0=bennws0+ewgs0
            bews0=bews0+bewgs0
          end if
          rkgden=0.0
          if (vfsgs .gt. 0.0) rkgden=pmvsv*rfsgs/vfsgs
          r2kgden=0.0
          if (v2fsgs .gt. 0.0) r2kgden=pmvsv*r2fsgs/v2fsgs
          pfsgs=0.0
          if (rfsgs .gt. 0.0) pfsgs=bfsgs/rfsgs
          rkwgsp=0.0
          ewgsp=0.0
          bewgsp=0.0
          if (npxwwss .gt. 0) then
            rkwgsp=float(newwnns)/float(npxwwss)
            bewgsp=bewgs/float(npxwwss)
          end if
          if (newwnns .gt. 0) ewgsp=ewgs/float(newwnns)
          if (itabsav .eq. -2) then
c           Calculate differences (first for the ratios)
            if (vfsgs0 .gt. 0.0) rkgden=rkgden-pmvsv*rfsgs0/vfsgs0
            if (v2fsgs0 .gt. 0.0) r2kgden=r2kgden-pmvsv*r2fsgs/v2fsgs
            if (rfsgs0 .gt. 0.0) pfsgs=pfsgs-bfsgs0/rfsgs0
            if (npxwwss0 .gt. 0) then
              rkwgsp=rkwgsp-float(newwnns0)/float(npxwwss0)
              bewgsp=bewgsp-bewgs0/float(npxwwss0)
            end if
            if (newwnns0 .gt. 0) ewgsp=ewgsp-ewgs0/float(newwnns0)
            vfsgs=vfsgs-vfsgs0
            rfsgs=rfsgs-rfsgs0
            v2fsgs=v2fsgs-v2fsgs0
            r2fsgs=r2fsgs-r2fsgs0
            bfsgs=bfsgs-bfsgs0
            rgs=rgs-rgs0
            bgs=bgs-bgs0
          end if
          if (nprint .gt. 0) write (iout,2039) ig,labslt(1,ilgrslt(ig)),
     -      vfsgs,v2fsgs,openprg,rfsgs,rkgden,r2fsgs,bfsgs,pfsgs,rgs,
     -      bgs,rkwgsp,ewgsp,bewgsp
        end do
        if (nprint .gt. 0) then
c         Compute average/sum over the whole molecule
          rkdens=0.0
          if (vfss .gt. 0.d0) rkdens=pmvsv*rkfss/vfss
          pfss=0.0
          if (rkfss .gt. 0.d0) pfss=bfss/rkfss
          rkws=0.d0
          if (rnpxws .gt. 0.d0) rkws=rnwws/rnpxws
          ennwws=0.d0
          if (rnwws .gt. 0.d0) ennwws=bennws/rnwws
          bewws=0.d0
          if (rnpxws .gt. 0.d0) bewws=bews/rnpxws
          if (itabsav .eq. -2) then
c           Calculate differences
            if (vfss0 .gt. 0.d0) rkdens=rkdens-pmvsv*rkfss0/vfss0
            if (rkfss0 .gt. 0.d0) pfss=pfss-bfss0/rkfss0
            if (rnpxws0 .gt. 0.d0) rkws=rkws-rnwws0/rnpxws0
            if (rnwws0 .gt. 0.d0) ennwws=ennwws-bennws0/rnwws0
            if (rnpxws0 .gt. 0.d0) bewws=bewws-bews0/rnpxws0
            vfss=vfss-vfss0
            v2fss=v2fss-v2fss0
            rkfss=rkfss-rkfss0
            r2kfss=r2kfss-r2kfss0
            bfss=bfss-bfss0
            rks=rks-rks0
            bs=bs-bs0
          end if
          write (iout,2033) vfss,v2fss,rkfss,rkdens,
     -      r2kfss,bfss,pfss,rks,bs,rkws,ennwws,bewws
        end if
      end if
      if (ifcgtabp .eq. 0 .or. itabsav .eq. -2) go to 999
c     rcfg(i): fs radius of the hydrogen in the i-th fcg
c     indx1(i),indx2(i): start and end on the i-th fcg type in the
c     ordered fcg list
c     ndpfgr(i) is the multiplicity of the fcg group i after condensing
      do ig=1,nfg
        ndpfgr(ig)=1
      end do
      if (icond .eq. 0) go to 99
c     Condense the list based on g(r) condensation info.
      do ig=1,nfg
        igg=ixfg(ig)
        if (ndpfgr(igg) .gt. 0) then
          nmem=nfgmem(igg)
          npart=0
          do im=1,nmem
            ii=ifgaix(ifgstr(igg)+im-1)
            if (indxrdf(ii) .le. nsltpxgr) then
c             Contributing atom found
              npart=npart+1
c             Look through other fcg's to see if replica exist, mark it
              do ig1=1,nfg
                igg1=ixfg(ig1)
                if (ndpfgr(igg1)  .gt. 0 .and. ig .ne. ig1 .and.
     -              indxrdf(igg1) .le. nsltpxgr) then
                  nmem1=nfgmem(igg1)
                  do imem1=1,nmem1
                    if (indxrdf(ifgaix(ifgstr(igg1)+imem1-1)) .eq.
     -                  indxrdf(ii)) then
c                     Duplicate found
                      if (itypfg(ig) .ne. itypfg(ig1)) then
c                       Duplicates are in different fcg's then skip condensation
                        do ig2=1,nfg
                          ndpfgr(ig2)=1
                        end do
                        if (iprint .gt. 0) write (iout,2022) ii,
     -                    ifgaix(ifgstr(igg1)+imem1-1),indxrdf(ii),
     -                    itypfg(ig),itypfg(ig1)
                        if (i2nd .eq. 1) return
                        go to 99
                      end if
c                     When ndpfgr(i) is negative, it is  pointing to the first
c                     fcg of which this fcg (igg1) is a duplicate
                      ndpfgr(igg1)=-igg
                      ndpfgr(igg)=ndpfgr(igg)+1
                      go to 30
                    end if
                  end do
                end if
              end do
            end if
          end do
c         Drop this fcg if no g(r) contributions were made from it
          if (npart .eq. 0) ndpfgr(igg)=0
        end if
30      continue
      end do
c     Condense fcg list.
      do ig=1,nfg
        igg=ixfg(ig)
        if (ndpfgr(igg) .lt. 0) then
          ig1stg=-ndpfgr(igg)
          nzero=0
          nmem=nfgmem(igg)
          do im=1,nmem
            ii=ifgaix(ifgstr(igg)+im-1)
c           Find the member, i1, of fcg ig1st that corresponds to ii
            if (indxrdf(ii) .eq. 0) nzero=nzero+1
            nmem1=nfgmem(ig1stg)
            do jm1=1,nmem1
              ii1=ifgaix(ifgstr(ig1stg)+jm1-1)
              if (indxrdf(ii) .eq. indxrdf(ii1)) then
c               i1: slt atom in kept copy of the fcg belonging to atom ii
                i1=ii1
c               Now add up the duplicate contributions
                nrnfs(i1)=nrnfs(i1)+nrnfs(ii)
                nrn2fs(i1)=nrn2fs(i1)+nrn2fs(ii)
                befssm(i1)=befssm(i1)+befssm(ii)
                nwfspx(i1)=nwfspx(i1)+nwfspx(ii)
                nw2fspx(i1)=nw2fspx(i1)+nw2fspx(ii)
                nwpx(i1)=nwpx(i1)+nwpx(ii)
                besm(i1)=besm(i1)+besm(ii)
                newwnn(i1)=newwnn(i1)+newwnn(ii)
                ewwnn(i1)=ewwnn(i1)+ewwnn(ii)
                ewwis(i1)=ewwis(i1)+ewwis(ii)
                npxwws(i1)=npxwws(i1)+npxwws(ii)
                go to 41
              end  if
            end do
c           If it got here, then the atom ii had no counterpart
            write (iout,2021) ii,igg
41          continue
          end do
          if (nzero .gt. 1) then
            write (iout,2020) igg,nzero
            nwarn=nwarn+1
          end  if
        end  if
      end do
      if (idebug(90) .gt. 0) then
        write (iout,7001) nfg,'ifgtyp',(ifgtyp(i),i=1,nfg)
        write (iout,7001) nfg,'ifgtyp',(ndpfgr(i),i=1,nfg)
        write (iout,7002) nsltpx1,nsltpx2,'indxrdf',
     -    (indxrdf(i),i=nsltpx1,nsltpx2)
        write (iout,7002) nsltpx1,nsltpx2,'indxfg',
     -    (indxfg(i),i=nsltpx1,nsltpx2)
        write (iout,7002) nsltpx1,nsltpx2,'keeppx',
     -    (keeppx(i),i=nsltpx1,nsltpx2)
      end if
c     Now add up the accumulators.
      ndel=0
      do ig=1,nfg
        igg=ixfg(ig)
        if (ndpfgr(igg) .gt. 0) then
c         Keep this
          ixfg(ig-ndel)=ixfg(ig)
        else
c         Fcg was a duplicate, drop it
          ndel=ndel+1
        end if
      end do
      nfg=nfg-ndel
99    do ig=1,nfg
        rcfg(ig)=0.0
      end do
      call fndlim(iout,indx1,indx2,ndupfg,rcfg,ifgtyp,nfgtyp,
     -  ixfg,nfg)
      if (iop(151) .gt. 0) then
c       Find rcfg values
        do ig=1,nfg
          ifg=ixfg(ig)
          nifg=nfgmem(ifg)
          do i=1,nifg
            rcfg(ig)=rcfg(ig)+rfsl(ifgaix(ifgstr(ifg)+i-1))
          end do
        end do
c       Sort by rcfg within the fcg list
        do it=1,nfgtyp
          i1=indx1(it)+1
          i2=indx2(it)
          if (i1 .le. i2) then
            nswap=1
            do while (nswap .gt. 0)
              nswap=0
              do i=i1,i2
                if (rcfg(i) .lt. rcfg(i-1)) then
                  nswap=nswap+1
                  x=rcfg(i)
                  rcfg(i)=rcfg(i-1)
                  rcfg(i-1)=x
                  ix=ifgtyp(i)
                  ixfg(i)=ixfg(i-1)
                  ixfg(i-1)=ix
                end if
              end do
            end do
          end if
        end do
        call fndlim(iout,indx1,indx2,ndupfg,rcfg,ifgtyp,nfgtyp,ixfg,nfg)
      end if
      isdev2=isdev
      if (nblcks .le. 2) isdev2=0
c     Initialize molecular sum accumulators
      vfss=0.d0
      v2fss=0.d0
      rkfss=0.d0
      r2kfss=0.d0
      bfss=0.d0
      rks=0.d0
      bs=0.d0
      rnwws=0.d0
      rnpxws=0.d0
      bennws=0.d0
      bews=0.0
      na=0
      if (iprint .gt. 0) write (iout,2031) ident,mcmd8,nmcpxo,ncnfpx,
     -  numrun,nblcks,tablab(icond+1),rfsww,rceww,rsolmn,rsolmx,'index'
      do it=1,nfgtyp
        if (iprint .gt. 0) write
     -    (iout,2038) nmlfcg(ifgtyp(ixfg(indx1(it))),min0(2,iop(25)+1)),
     -    namfcg(ifgtyp(ixfg(indx1(it))),min0(2,iop(25)+1))
c       Initialize accumulators for identical functional group
        vfsggs=0.0
        v2fsggs=0.0
        rfsggs=0.0
        r2fsggs=0.0
        bfsggs=0.0
        pfsggs=0.0
        rggs=0.0
        bggs=0.0
        newwgg=0
        rkwggs=0.0
        ewggs=0.0
        bewggs=0.0
        i1=indx1(it)
        i2=indx2(it)
        noftyp=0
        noftnz=0
        nfstnz=0
        nwwgst=0
        npwgst=0
        do ig=i1,i2
          ifg=ixfg(ig)
          ncnfgd=ncnfpx*ndpfgr(ifg)
c         Initialize accumulators for individual fcg's
          vfsgs=0.0
          v2fsgs=0.0
          rfsgs=0.0
          r2fsgs=0.0
          bfsgs=0.0
          rgs=0.0
          bgs=0.0
          nwwgs=0
          npxwgs=0
          ewgs=0.0
          bewgs=0.0
          nn=nfgmem(ifg)
          openprg=closedpx
          nkeep=0
          do imem=1,nn
            na=na+1
            is=ifgaix(ifgstr(ifg)+imem-1)
            if (itabsav .ge. 0) then
              volfs=0.0
              if (nrans .gt. 0) volfs=float(nrnfs(is))/
     -          (float(nrans)*float(ndpfgr(ifg)*ndim2p))*volav
              vol2fs=0.0
              if (nrans .gt. 0) vol2fs=float(nrn2fs(is))/
     -          (float(nrans)*float(ndpfgr(ifg)*ndim2p))*volav
              rnwfpx=float(nwfspx(is))/ncnfgd
              rnw2fpx=float(nw2fspx(is))/ncnfgd
              bfssis=befssm(is)/ncnfgd
              rnwpx=float(nwpx(is))/ncnfgd
              besmis=besm(is)/ncnfgd
c             Now calculate density-type quantities
              rkdens=0.0
              if (volfs .gt. 0.0) rkdens=pmvsv*rnwfpx/volfs
              r2kden=0.0
              if (vol2fs .gt. 0.0) r2kden=pmvsv*rnw2fpx/vol2fs
              pefspx=0.0
              if (nwfspx(is) .ne. 0) pefspx=bfssis/rnwfpx
c             Save solvent (water) accumulators into scalar
              newwnnis=newwnn(is)
              npxwwsis=npxwws(is)
              ewwnnisis=ewwnn(is)
              ewwisis=ewwis(is)
c             Compute water-water properties
              rkws=0.0
              if (npxwwsis .gt. 0)
     -          rkws=float(newwnnis)/float(npxwwsis)
              ewnnis=0.0
              if (newwnnis .gt. 0)
     -          ewnnis=ewwnnisis/float(newwnnis)
              bewwis=0.0
              if (npxwwsis .gt. 0)
     -          bewwis=ewwisis/float(npxwwsis)
              if (itabsav .eq. 1) then
c               Also, save data into table
                call movedat13(pxt(1,is),volfs,vol2fs,rnwfpx,rnw2fpx,
     -            rkdens,r2kden,bfssis,pefspx,rnwpx,besmis,rkws,ewnnis,
     -            bewwis,newwnnis,npxwwsis,1)
                ipxt=1
              end if
            else
c             Get data from the table
              call movedat13(pxt(1,is),volfs,vol2fs,rnwfpx,rnw2fpx,
     -          rkdens,r2kden,bfssis,pefspx,rnwpx,besmis,rkws,ewnnis,
     -          bewwis,newwnnis,npxwwsis,-1)
                ewwnnisis=ewnnis*float(newwnnis)
                ewwisis=bewwis*float(npxwwsis)
            end if
c           Decide if this atom will contribute to the rdf average
            if (iop(142) .gt. 1) then
              if (rnwfpx .ge. rkgrmin .and. rnw2fpx .ge. r2kgrmin
     -            .and. rnwpx .ge. rtkgrmin) iwrfs(indxrdf(is))=1
            end if
            if (rnwpx-rnw2fpx .gt. 0.1) then
              openpr=openpx
            else
              openpr=closedpx
            end if
            if (openpr .eq. openpx) openprg=openpx
            if (keeppx(is) .gt. 0) then
              nkeep=nkeep+1
              if (iprint .gt. 0 .and.
     -            (iop(165) .eq. 0 .or. nwpx(is) .gt.  0))
     -          write (iout,2032) na,is,igrslt(is),
     -          iatnam(ianslt(is)),(labslt(k,is),k=1,2),rfsl(is),
     -          volfs,vol2fs,openpr,rnwfpx,rkdens,rnw2fpx,bfssis,pefspx,
     -          rnwpx,besmis,rkws,ewnnis,bewwis
            end if
c           Collect sum for fcg results
            vfsgs=vfsgs+volfs
            v2fsgs=v2fsgs+vol2fs
            rfsgs=rfsgs+rnwfpx
            r2fsgs=r2fsgs+rnw2fpx
            bfsgs=bfsgs+bfssis
            rgs=rgs+rnwpx
            bgs=bgs+besmis
            nwwgs=nwwgs+newwnnis
            npxwgs=npxwgs+npxwwsis
            call checkint(nwwgs,'nwwgs',5,iout,nwwarn,inperr)
            call checkint(npxwgs,'npxwgs',6,iout,nwarn,inperr)
            ewgs=ewgs+ewwnnisis
            bewgs=bewgs+ewwisis
c           Collect molecular property sums
            vfss=vfss+volfs*ndpfgr(ifg)
            v2fss=v2fss+vol2fs*ndpfgr(ifg)
            rkfss=rkfss+rnwfpx*ndpfgr(ifg)
            r2kfss=r2kfss+rnw2fpx*ndpfgr(ifg)
            bfss=bfss+bfssis*ndpfgr(ifg)
            rks=rks+rnwpx*ndpfgr(ifg)
            bs=bs+besmis*ndpfgr(ifg)
            rnwws=rnwws+dfloat(newwnn(is))
            rnpxws=rnpxws+dfloat(npxwws(is))
            bennws=bennws+ewwnn(is)
            bews=bews+ewwis(is)
          end do
          noftyp=noftyp+1
c         Computation of sums over the functional group. Note, that the
c         fcg averages are formed as ratios of sums, not averages of ratios
          rkgden=0.0
          if (vfsgs .gt. 0) rkgden=pmvsv*rfsgs/vfsgs
          r2kgden=0.0
          if (v2fsgs .gt. 0) r2kgden=pmvsv*r2fsgs/v2fsgs
          pfsgs=0.0
          if (rfsgs .gt. 0.0) pfsgs=bfsgs/rfsgs
          if (rfsgs .gt. 0.0) nfstnz=nfstnz+1
          if (rgs .gt. 0.0) noftnz=noftnz+1
          rkwgsp=0.0
          ewgsp=0.0
          bewgsp=0.0
          nwwgst=nwwgst+nwwgs
          npwgst=npwgst+npxwgs
          if (npxwgs .gt. 0) rkwgsp=float(nwwgs)/float(npxwgs)
          if (nwwgs .gt. 0) ewgsp=ewgs/nwwgs
          if (npxwgs .gt. 0) bewgsp=bewgs/float(npxwgs)
          if (nkeep .gt. 0 .and. iprint .gt. 0 .and. nn .gt. 1 .and.
     -      (iop(165) .eq. 0 .or. rgs .gt. 0.0)) then
               write (line,2034) vfsgs,v2fsgs,openprg,rfsgs,rkgden,
     -         r2fsgs,bfsgs,pfsgs,rgs,bgs,rkwgsp,ewgsp,bewgsp
              if (iop(25) .eq. 0) write (line(1:35),2040)
     -          namfcg(ifgtyp(ifg),1),noftyp
CSUN     -          noftyp,namfcg(ifgtyp(ifg),1)  !CSUN original one!
              if (iop(25) .gt. 0) write (line(1:35),2041)
     -          namfcg(ifgtyp(ifg),2),ig
              write (iout,2000) line(1:131)
          end if
c         Collect sums for average over identical fcg's
          vfsggs=vfsggs+vfsgs
          v2fsggs=v2fsggs+v2fsgs
          rfsggs=rfsggs+rfsgs
          r2fsggs=r2fsggs+r2fsgs
          bfsggs=bfsggs+bfsgs
          pfsggs=pfsggs+pfsgs
          rggs=rggs+rgs
          bggs=bggs+bgs
          if (npxwgs .gt. 0) newwgg=newwgg+1
          rkwggs=rkwggs+nwwgs
          ewggs=ewggs+ewgs
          bewggs=bewggs+bewgs
        end do
c       Compute and print average of identical fcg's
        vfsggs=vfsggs/noftyp
        v2fsggs=v2fsggs/noftyp
        rfsggs=rfsggs/noftyp
        r2fsggs=r2fsggs/noftyp
        rggden=0.0
        if (vfsggs .gt. 0.0) rggden=pmvsv*rfsggs/vfsggs
        r2ggden=0.0
        if (v2fsggs .gt. 0.0) r2ggden=pmvsv*r2fsggs/v2fsggs
        bfsggs=bfsggs/noftyp
        if (nfstnz .gt. 0) pfsggs=pfsggs/nfstnz
        rggs=rggs/noftyp
        bggs=bggs/noftyp
        if (npwgst .gt. 0) rkwggs=rkwggs/npwgst
        if (nwwgst .gt. 0) ewggs=ewggs/nwwgst
        if (npwgst .gt. 0) bewggs=bewggs/npwgst
        if (iprint .gt. 0 .and. noftyp .gt. 1) write (iout,2035)
     -    namfcg(ifgtyp(ifg),min0(2,iop(25)+1)),vfsggs,v2fsggs,rfsggs,
     -    rggden,r2fsggs,bfsggs,pfsggs,rggs,bggs,rkwggs,ewggs,bewggs
        call savfcg(vfsggs,rfsggs,rggden,r2fsggs,bfsggs,pfsggs,rggs,
     -    bggs,rkwggs,ewggs,bewggs,npwgst,it)
        if (iprint .gt. 0 .and. isdev2 .gt. 0) write (iout,2037)
     -    (sdev2(it,j),j=1,nfge)
      end do
c     Compute average/sum over the whole molecule
      rkdens=0.0
      if (vfss .gt. 0.d0) rkdens=pmvsv*rkfss/vfss
      pfsss=0.0
      if (rkfss .gt. 0.d0) pfsss=bfss/rkfss
      rkws=0.d0
      if (rnpxws .gt. 0.d0) rkws=rnwws/rnpxws
      ennwws=0.d0
      if (rnwws .gt. 0.d0) ennwws=bennws/rnwws
      bewws=0.d0
      if (rnpxws .gt. 0.d0) bewws=bews/rnpxws
      if (iprint .gt. 0) write (iout,2033) vfss,v2fss,rkfss,rkdens,
     -  r2kfss,bfss,pfss,rks,bs,rkws,ennwws,bewws
      if (iprint .gt. 0 .and. isdev2 .gt. 0) write (iout,2037)
     -  (sdev2(101,j),j=1,nfge)
      npxws=rnpxws
      svfss=vfss
      srkfss=rkfss
      sr2kfss=r2kfss
      sbfss=bfss
      srks=rks
      sbs=bs
      call savfcg(svfss,srkfss,rkdens,sr2kfss,sbfss,pfsss,srks,sbs,rkws,
     -  ennwws,bewws,npxws,101)
      beww=bewws
      pfss=pfsss
      ennww=ennwws
999   if (iop(148) .gt. 0) then
c       Compute average number of waters used for w-w interactions
        rnwws=0.d0
        do is=nsltpx1,nsltpx2
          rnwws=rnwws+npxwws(is)
        end do
        rnwws=rnwws/dfloat(ncnfpx)
        if (iprint .gt. 0) write (iout,2036) rnwws
      end if
      rkw=rkws
      rkden=rkdens
      return
2000  format(a)
2020  format(' ----- WARNING: functional group',i4,' has',i3,
     -  ' atoms that were unassigned to any g(r)')
2021  format(' ***** ERROR: atom',i5,' in functional group',i3,
     -  ' has no counterpart in the reference group')
2022  format(' ----- WARNING: atoms ',i5,' and ',i5,' are condensed',
     -  ' to rdf ',i5,' but they are from different functional group ',
     -  ' types:',i3,' and ',i3,/,' No condensation will be done.')
2023  format(' ***** PROGRAM ERROR: uninitialized proximity table')
2024  format(' ===== STRONG WARNING: tabulation was requested before ',
     -  'analysis')
2031  format(/,2(1x,a80,/),/,' Last ',a8,'=',i10,4x,
     -  '  Number of configurations analyzed=',i6,'  Run no=',i3,
     -  '  Number of control function blocks=',i4,/,
     -  41x,'First shell solute properties',22x,'Total slt props    ',
     -  'Solvent properties',/,
     -  1x,a16,87x,'Rfsw=',f5.2,' Rcbe=',f5.2,' A',/,
     -  96x,'Solute distance range: ',f5.2,'-',f5.2,' A',//
     -  7x,a5,' resi',16x,'rfs   vfs    v2fs      <K>  <K/V>    <2K>',
     -  '  <sltbe> <sltpe>    <K>  ','  <sltbe>',
     -  '  <Kw>','<nnwwpe>','  <bewwt>')
2032  format(3i5,1x,a4,2x,2a4,f6.2,f7.1,f7.0,a4,f6.2,f6.2,f8.1,f9.2,
     -  f7.2,f8.1,f10.2,f6.1,f8.3,f9.3)
2033  format(/,' Molecular sum/average: ',9x,
     -  2f8.0,4x,f7.2,f6.2,f8.1,f9.2,f7.2,f8.1,f10.2,f6.1,f8.3,f9.3)
2034  format(35x,':',f7.1,f7.0,a4,
     -  f6.2,f6.2,f8.1,f9.2,f7.2,f8.1,f10.2,f6.1,f8.3,f9.3)
2035  format(/,' Av (weighted)/sum over fcg   ',a4,' :',f7.1,f7.0,4x,
     -  f6.2,f5.2,f8.1,f10.2,f7.2,f8.1,f10.2,f6.1,f8.3,f9.3)
2036  format(/,' Average number of waters used for water-water',
     -  ' calculations=',f10.4)
2037  format(' Statistical uncertainty (+/- 2*sd):',1x,f6.1,11x,
     - f6.2,f6.2,f8.2,f9.2,f7.2,f8.1,f10.2,f6.1,f8.3,f9.3)
2038  format(/,1x,a20,' (',a4,')')
2039  format(' Av (weighted)/sum, res#',i4,' (',a4,'):',f7.1,f7.0,a4,
     -  f6.2,f6.2,f8.1,f9.2,f7.2,f8.1,f10.2,f6.1,f8.3,f9.3,/)
2040  format(' Totals for funct. grp. ',a4,' #',i3)
2041  format(' Totals for user group ',a4,' (',i3,')')
7001  format(' PXTABL nfg=',i5,1x,a,'=',/,(30i4))
7002  format(' PXTABL nsltpx1,2=',2i5,1x,a,'=',/,(30i4))
      end
      subroutine nearst(n,g,inear,ifar)
c#    MMC routine 423 lstmod: 05/01/98
      dimension g(n)
c*****Finds the location of the first and last nonzero element in g
      do i=1,n
        if (g(i) .ne. 0.0) then
          inear=i
          go to 100
        end if
      end do
      inear=n+1
100   do ii=1,n
        i=n-ii+1
        if (g(i) .ne. 0.0) then
          ifar=i
          return
        end if
      end do
      ifar=1
      return
      end
      subroutine savfcg(r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,i12,ityp)
c#    MMC routine 424 lstmod: 10/06/98
c*****Puts the fcg averages into the common block for error estimation
c     fcgavg(i,1): functional group averages for the i-th group.
      common /fcgdatpx/ fcgavg(101,12),sdev2(101,11),ndupfg(100),nfge
      fcgavg(ityp,1)=r1
      fcgavg(ityp,2)=r2
      fcgavg(ityp,3)=r3
      fcgavg(ityp,4)=r4
      fcgavg(ityp,5)=r5
      fcgavg(ityp,6)=r6
      fcgavg(ityp,7)=r7
      fcgavg(ityp,8)=r8
      fcgavg(ityp,9)=r9
      fcgavg(ityp,10)=r10
      fcgavg(ityp,11)=r11
      fcgavg(ityp,12)=i12
      return
      end
      subroutine movedat13(a,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,
     -  i1,i2,itofrom)
c#    MMC routine 425 lstmod: 05/18/98
c*****Move 13 reals and 2 integers into an array
      dimension a(15)
      if (itofrom .eq. 1) then
        a(1)=r1
        a(2)=r2
        a(3)=r3
        a(4)=r4
        a(5)=r5
        a(6)=r6
        a(7)=r7
        a(8)=r8
        a(9)=r9
        a(10)=r10
        a(11)=r11
        a(12)=r12
        a(13)=r13
        a(14)=i1
        a(15)=i2
      else
        r1=a(1)
        r2=a(2)
        r3=a(3)
        r4=a(4)
        r5=a(5)
        r6=a(6)
        r7=a(7)
        r8=a(8)
        r9=a(9)
        r10=a(10)
        r11=a(11)
        r12=a(12)
        r13=a(13)
        i1=a(14)
        i2=a(15)
      end if
      return
      end
      subroutine errestpx(npxcntin,lumppr,nfgtyp)
c#    MMC routine 426 lstmod: 01/09/04
c*****Compute and print error estimates on proximity analysis results
      real*8 blkavs
      common /btchav/ blkavs(#MI,11),nblcks
      common /fcgdatpx/ fcgavg(101,12),sdev2(101,11),ndupfg(100),nfge
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      dimension sd2(11),sd2p(11),prcter(11),a(#MI),icntix(11)
      data icntix /1,2,2,4,2,2,6,6,12,12,12/
c     icntix gives the property to use for weugting the contributions.
c     Note that the 12-th propert is collected just for this purpose.
      call zeroit(sdev2,101*nfge)
      call zeroit(sd2,nfge)
      if (nblcks .le. 2) return
      write (iout,2000)
      write (iout,2003)
      lenblk=npxcntin
      n=nblcks
      do nlump=1,6
        if (n .gt. 2) then
          lenblk=2*lenblk
          do i=1,11
            a(1)=blkavs(1,i)
            do ib=2,n
              a(ib)=ib*blkavs(ib*nlump,i)-(ib-1)*blkavs((ib-1)*nlump,i)
            end do
            call var(a,n,sd2(i),nup,ndown,nrun)
          end do
          if (nlump .le. lumppr) then
            call trnsfr(sd2p,sd2,nfge)
            lenbkp=lenblk
          end if
          write (iout,2001) lenblk,sd2
        end if
        n=n/2
      end do
      do j=1,nfge
        sdev2(101,j)=sd2p(j)
      end do
c     Estimate fcg errors by relative contributions
c     The contribution to the standard deviation (square) is proportional
c     to property icntix(i) (first shell volume, the first shell coord no
c     or 2nd shell coord no or total coord no  or the number of solvents
c     used for solvent-solvent property calculations
c     The percentage error is multiplied by sqrt(fractional contribution)
      do j=1,nfge
        prcter(j)=0.0
        if (fcgavg(101,j) .ne. 0.0) prcter(j)=abs(sd2p(j)/fcgavg(101,j))
      end do
      do i=1,nfgtyp
        do j=1,nfge
          jkno=icntix(j)
          sd2(j)=0.0
          if (fcgavg(i,jkno) .ne. 0.0)
     -      sdev2(i,j)=sqrt(abs(fcgavg(101,jkno)/fcgavg(i,jkno))/
     -             ndupfg(i))*abs(fcgavg(i,j))*prcter(j)
        end do
      end do
      return
2000  format(/,' Error estimates on molecular sums:')
2003  format(39x,' <V>  <K> <K/V>  <2K>   <sltbe>  <sltpe>',
     -  3x,'    <K>  ','  <sltbe>',
     -  3x,' <Kw>','  <nnwwpe>','  <bewwt>')
2001  format(' block size=',i9,' 2*sd=',10x,f6.1,f6.2,f5.2,f6.2,2f9.3,
     -  3x,2f9.3,3x,f5.2,f9.3,f10.3)
      end
      subroutine fndlim(iout,indx1,indx2,ndupfg,rcfg,
     -  ifgtyp,nfgtyp,ixfg,nfg)
c#    MMC routine 427 lstmod: 07/29/97
c*****Determine the index limits and multiplicities of the functional grp
c     groups (over which averages/sums will be formed)
      dimension indx1(100),indx2(100),ndupfg(100),rcfg(#ST)
      dimension ifgtyp(#ST),ixfg(#ST)
c     ndupfg: multiplicity of functional groups in the molecule.
c     nfgtyp: number of different fcgs present in the molecule
      itpold=ifgtyp(ixfg(1))
      rcfgol=rcfg(1)
      indx1(1)=1
      nfgtyp=1
      do ig=1,nfg
        if (itpold .ne. ifgtyp(ixfg(ig)) .or. rcfgol .ne. rcfg(ig))
     -    then
          if (nfgtyp .gt. 100) then
            write (iout,1000)
            call datprt(2)
          end if
          if (nfgtyp .gt. 1) indx1(nfgtyp)=indx2(nfgtyp-1)+1
          indx2(nfgtyp)=ig-1
          ndupfg(nfgtyp)=indx2(nfgtyp)-indx1(nfgtyp)+1
          rcfgol=rcfg(ig)
          itpold=ifgtyp(ixfg(ig))
          nfgtyp=nfgtyp+1
        end if
      end do
      if (nfgtyp .gt. 1) indx1(nfgtyp)=indx2(nfgtyp-1)+1
      indx2(nfgtyp)=nfg
      ndupfg(nfgtyp)=indx2(nfgtyp)-indx1(nfgtyp)+1
      return
1000  format(' ***** ERROR: number of identical functional group',
     -  ' sets is greater than 100',/,7x,'increase the dimensions of',
     -  ' the arrays sdev2,ndupfg,indx1,indx2,fcgavg')
      end
      subroutine getcnf(nslt,nslv,notmov,ndone,c,cplpar,lmnst)
c#    MMC routine 428 lstmod: 04/05/99
c*****Obtain a full configuration from the history file
c     notmov: >0, slt was moved, =0 , slt was not moved during the simulation
      dimension c(3,#NA)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /worksp/ idone(#NA),l2(#UV),l3(#UV),l4(#UV)
      ndone=0
      if (notmov .eq. 0) ndone=1
      call zeroiti(idone,0,nmolec)
      do while (ndone .lt. nmolec)
        if (lstac .eq. 250) then
          read (ihist,end=3) estac,cst,istc,nmcst,becpst
          lmnst=lmnst+1
          lstac=0
        end if
        lstac=lstac+1
        call trnsfr(c(1,nslt+(istc(lstac)-2)*nslv+1),cst(1,lstac),9)
        is=istc(lstac)
        if (iop(30) .eq. 7 .and. istc(lstac) .eq. 1)
     -    cplpar=becpst(lstac)
        if (idone(is) .eq. 0) then
          idone(is)=1
          ndone=ndone+1
        end if
      end do
      return
3     write (iout,2004) lmnst,nmcst(250)
2004  format(/,' History file too short in getc, number of records=',i6,
     -  ' nmcpx=',i9)
      return
      end
      subroutine randpx(n,rno)
c#    MMC routine 429 lstmod: 10/04/86
c*****Congruential random number generator, Forsythe's constants
      common /rangen/ xyzlim(3),xyzlm2(3),ixpxo
      dimension rno(n)
      do i=1,n
        iy=ixpxo*314159269+453806245
c       Eliminate bits over 31
        iy=ibclr(iy,31)
        rno(i)=float(iy)/2.1474836E+09
        ixpxo=iy
      end do
      return
      end
      subroutine cofmsw(c3,nslv,crm,nmolec)
c#    MMC routine 430 lstmod: 08/29/95
c*****Compute center of mass of all waters
      dimension c3(3,nslv,nmolec),crm(3,nmolec)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      awsum=aw(8)+aw(1)+aw(1)
      awo=aw(8)/awsum
      awh=aw(1)/awsum
      do iw=1,nmolec
        crm(1,iw)=c3(1,1,iw)*awo+(c3(1,2,iw)+c3(1,3,iw))*awh
        crm(2,iw)=c3(2,1,iw)*awo+(c3(2,2,iw)+c3(2,3,iw))*awh
        crm(3,iw)=c3(3,1,iw)*awo+(c3(3,2,iw)+c3(3,3,iw))*awh
      end do
      return
      end
      subroutine readcrd(c,icord,nmolec,nmol3,numsolv,natoms,nslt,
     -  nsltfe,nslv,cplpar,edgexyz,icplp,noranini,nopbcini,ireadbo,
     -  filename,namlen,isilent,iout,nwwarn,inperr)
c#    MMC routine 432 lstmod 05/08/20
c*****Read in a configuration from unit icord
      character*80 filename
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      dimension c(3,#NA),edgexyz(3)
      real*8 rstack,rix,rira,rirb
      character*80 line
      common /inpline/ line,lineno,icol
      common /seed/ rstack(64),rix(4),rira(4),rirb(4),ixo,ixmt,
     -  nseedread,irng
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /option/ iop(200),idebug(200)
      dimension edg(3),ixr(4)
      character*80 line123(3)
      iainc=0
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
        iainc=nsltfe
        call zeroit(c,3*iainc)
      end if
      call checkdim(ifail,iout,inperr,'NA',natoms,0,1,0)
      if (idebug(49) .gt. 0 .or. ifail .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,3000) 'start',filename(1:namlen),nmolec,natoms,
     -  nslt,iainc,nslv
      if (ireadbo .eq. 1 .and. iop(47) .ne. 3) then
        if (MYRANK .eq. 0) write (iout,2016)
        inperr=inperr+1
        return
      end if
      ifail=0
      icplp=0
      lineno0=lineno
      if (MYRANK .eq. 0) rewind icord
      nlfound=0
c     For MMC formats, get the extra info (cplpar, edge, numsolv, seed)
      if (iop(47) .eq. 1) then
C@DM        if (MYRANK .eq. 0) then
        ireadok=0
        read (icord)
        read (icord,end=9980) cpl
        read (icord,end=9980) edg
        read (icord,end=9980) numsolvr,ixr,ixor
        ireadok=1
9980    continue
C@DM        end if
C@DM        call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
        if (ireadok .eq. 0) then
          if (MYRANK .eq. 0) write (iout,2001) filename(1:namlen)
          call datprt(2)
        end if
C@DM        call MPI_Bcast(numsolvr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(ixr,4,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(ixor,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(cpl,1,MPI_REAL,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(edg,3,MPI_REAL,0,MPI_COMM_WORLD,ierr)
      else if (iop(47) .eq. 0 .or. iop(47) .eq. 2) then
c       Get the last three lines
        irectx=52
        call getnextrec(icord,iout,irectx,nwwarn)
        line123(1)=line
        call getnextrec(icord,iout,irectx,nwwarn)
        line123(2)=line
        call getnextrec(icord,iout,irectx,nwwarn)
        line123(3)=line
        nline=3
        do while (.true.)
          call getnextrec(icord,iout,irectx,nwwarn)
          if (irectx .lt. 0) go to 100
          call lastchar(line,lc,80)
          if (lc .gt. 1) then
            nline=nline+1
            line123(1)=line123(2)
            line123(2)=line123(3)
            line123(3)=line
          end if
        end do
100     read (line123(3)(1:39),1000,err=9930) numsolvr,ixr,ixor
      end if
      if (iop(47) .le. 2) natomsr=nslt-iainc+numsolvr*nslv
      if (MYRANK .eq. 0) rewind icord
      ia=0
      iresnoprev=0
      iresnoprev_ia=0
      nslvchk=0
      if (iop(47) .ge. 2) then
c       Read config - as many atoms as there are on the file
        if (iop(47) .eq. 2) then
c         Annotated ascii
          irectx=53
          call getnextrec(icord,iout,irectx,nwwarn)
          read (line,1000,err=9940) natomsr
          natsr=min0(natomsr,#NA)
          do iaa=1,natsr
            irectx=52
            call getnextrec(icord,iout,irectx,nwwarn)
            read (line,1003,err=9910) (c(k,iainc+iaa),k=1,3)
            ia=ia+1
          end do
        else if (iop(47) .eq. 3) then
c         PDB
          nrem=0
          line(1:3)='   '
          do while (line(1:3) .ne. 'END')
            irectx=51
            call getnextrec(icord,iout,irectx,nwwarn)
            if (irectx .lt. 0) go to 300
            if (line(1:4) .eq. 'ATOM' .or. line(1:6) .eq. 'HETATM') then
              ia=ia+1
              if (ia .le. #NA) then
                if (ireadbo .eq. 0) then
                  read (line(31:54),1005,err=9910) (c(k,iainc+ia),k=1,3)
                  read (line(23:26),1008,err=9910) iresno
                  if (iop(61) .eq. 0 .and. nslvchk .eq. 0) then
                    if (iresno .ne. iresnoprev) then
                      if (ia .gt. nslt+1 .and. iresnoprev .gt. 0) then
                        nslvr=ia-iresnoprev_ia
                        if (nslv .ne. nslvr) then
                          write (iout,2013) nslvr,nslv
                          nwwarn=nwwarn+1
                        end if
                        nslvchk=1
                      end if
                      iresnoprev_ia=ia
                      iresnoprev=iresno
                    end if
                  end if
                else
                  read (line(55:66),1007,end=9960) c(1,ia),c(2,ia)
                end if
              end if
            else if (iop(24) .gt. 1) then
              if (line(1:6) .eq. 'HEADER' .and. MYRANK .eq. 0)
     -          write (iout,1004) line
              if (line(1:6) .eq. 'REMARK') then
                nrem=nrem+1
                if (nrem .lt. 4 .and. MYRANK .eq. 0)
     -            write (iout,1004) line
              end if
            end if
          end do
300       natomsr=ia
          if (ia .eq. 0) then
            if (MYRANK .eq. 0) write (iout,2019) filename(1:namlen)
            call datprt(2)
          end if
        else
c         Charmm CRD
          line(1:1)='*'
          nstar=0
          irectx=54
          do while (line(1:1) .eq. '*')
            call getnextrec(icord,iout,irectx,nwwarn)
            nstar=nstar+1
          end do
          if (nstar .eq. 0) then
            write (iout,2020) filename(1:namlen)
            call datprt(2)
          end if
          read (line,*,err=9940) natomsr
          natsr=min0(natomsr,#NA)
          do iaa=1,natsr
            irectx=50
            call getnextrec(icord,iout,irectx,nwwarn)
            read (line(21:50),1006,err=9910) (c(k,iainc+iaa),k=1,3)
            read (line(06:10),1009,err=9910) iresno
            if (iresno .ne. iresnoprev .and. nslvchk .eq. 0) then
              if (ia .gt. nslt+1 .and. iresnoprev .gt. 0) then
                nslvr=ia-iresnoprev_ia
                if (nslv .ne. nslvr) then
                  write (iout,2013) nslvr,nslv
                  nwwarn=nwwarn+1
                end if
                nslvchk=1
              end if
              iresnoprev_ia=ia
              iresnoprev=iresno
            end if
            ia=ia+1
          end do
        end if
        numsolvr=(natomsr+iainc-nslt)/nslv
      else
c       Read natoms set in one of the simple MMC formats
        natsr=min0(natomsr,#NA)
        if (iop(47) .eq. 0) then
c         Simple alphanumeric
          do iaa=1,natsr
            irectx=52
            call getnextrec(icord,iout,irectx,nwwarn)
            if (irectx .lt. 0) go to 9999
            read (line,1001,err=9910) (c(k,iainc+iaa),k=1,3)
            ia=ia+1
          end do
        else if (iop(47) .eq. 1) then
c         Simple binary
C@DM          if (MYRANK .eq. 0) then
          ireadok=0
          read (icord,end=9870) ((c(k,iainc+ia),k=1,3),ia=1,natsr)
          ireadok=1
9870      continue
C@DM          end if
C@DM          call MPI_Bcast(ireadok,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
          if (ireadok .eq. 0) then
            if (MYRANK .eq. 0) write (iout,2003) natsr
            call datprt(2)
          end if
C@DM          call MPI_Bcast(c,3*natsr,MPI_REAL,0,MPI_COMM_WORLD,ierr)
        end if
      end if
      if (iop(97) .eq. 0 .and. iop(61) .eq. 0) then
c       Number of atoms must match input value
        if (natomsr .lt. natoms-iainc) then
          if (nmolec .eq. 0) then
            if (MYRANK .eq. 0)
     -        write (iout,2010) filename(1:namlen),natomsr,natoms-iainc
            inperr=inperr+1
          else
            if (MYRANK .eq. 0)
     -        write (iout,2011) filename(1:namlen),'less',
     -          natomsr,natoms-iainc
            nwwarn=nwwarn+1
          end if
          natoms=natomsr+iainc
          numsolv=(natoms-nslt)/nslv
c         print *,'natoms,nslt,nslv,numsolv=',
c    -      natoms,nslt,nslv,numsolv
          nmolec=numsolv+1
          nmol3=3*nmolec
        else if (natomsr .gt. natoms-iainc) then
          if (MYRANK .eq. 0)
     -      write (iout,2011) filename(1:namlen),'more',
     -        natomsr,natoms-iainc
          nwwarn=nwwarn+1
        end if
      else
        if (iop(61) .gt. 0) then
          natoms=natomsr
          numsolv=0
          nmolec=1
          nmol3=3
        else if (nmolec .eq. 0) then
c         Establish new values
          natoms=natomsr+iainc
          numsolv=(natoms-nslt)/nslv
c         print *,'natoms,nslt,nslv,numsolv=',
c    -      natoms,nslt,nslv,numsolv
          nmolec=numsolv+1
          nmol3=3*nmolec
          if (MYRANK .eq. 0 .and. isilent .eq. 0)
     -      write (iout,2004) filename(1:namlen),
     -        numsolvr,nslt,numsolvr,nslv,natoms
          call checkdim(ifail,iout,inperr,'MO',nmolec,1,0,0)
          call checkdim(ifail,iout,inperr,'NA',natoms,1,1,0)
        else
          numsolvr=(natomsr+iainc-nslt)/nslv
c         print *,'natomsr,iainc,nslt,nslv,numsolvr=',
c    -      natomsr,iainc,nslt,nslv,numsolvr
          if (numsolvr .ne. nmolec-1 .and. isilent .eq. 0) then
            write (iout,2017) filename(1:namlen),numsolvr,
     -        nmolec-1,numsolvr
            numsolv=numsolvr
            nmolec=numsolvr+1
            nmol3=3*nmolec
            natoms=nslt+numsolv*nslv
            nwwarn=nwwarn+1
          end if
        end if
      end if
      if (iop(30) .gt. 3 .or. iop(41) .gt. 0 .or. iop(71) .gt. 0) then
c       Check if last three records are ok
        miss3=0
        if (iop(47) .eq. 0 .and. nline .ne. natomsr+3) then
          if (MYRANK .eq. 0)
     -      write (iout,2012) filename(1:namlen),nline,natomsr,3
          miss3=1
        else if (iop(47) .eq. 2 .and. nline .ne. natomsr+4) then
          if (MYRANK .eq. 0)
     -      write (iout,2012) filename(1:namlen),nline,natomsr,4
          miss3=1
        else if (iop(47) .gt. 2) then
          miss3=1
        end if
        if (miss3 .eq. 1) then
          if (iop(47) .le. 2) then
            nwwarn=nwwarn+1
          end if
          if (iop(30) .gt. 3 .and. iop(30) .lt. 7 .and. MYRANK .eq. 0)
     -      write (iout,2015) 'coupling parameter','FREE'
          if (iop(30) .ge. 7 .and. MYRANK .eq. 0)
     -      write (iout,2018) filename(1:namlen)
          if (iop(71) .gt. 1 .and. MYRANK .eq. 0) write (iout,2015)
     -      'simulation cell parameters','PBCN'
        else
          icplp=1
          if (iop(30) .gt. 6) then
            read (line123(1)(1:15),1001,err=9970) cpl
            cplpar=cpl
            if (iop(24) .gt. 0 .and. MYRANK .eq. 0) write (iout,2014)
     -        'coupling parameter has',filename(1:namlen),cpl
           end if
          if (iop(71) .gt. 0) then
c           Regenerate cell information when volume description was found
            if (iop(47) .ne. 1)
     -        read (line123(2)(1:45),1001,err=9950) edg
            if (nopbcini .eq. 0) then
              if (MYRANK .eq. 0) write (iout,2014)
     -          'simulation cell parameters have',filename(1:namlen),edg
            if (edg(1) .eq. 0.0) then
              write (iout,2021)
              nwwarn=nwwarn+1
            else
              call initbc(iop(5),edg(1),edg(2),edg(3),iop(24),inpt,iout)
              call crorgn(edgexyz(1),edgexyz(2),edgexyz(3),iop(5),3)
            end if
            end if
          end if
        end if
      end if
      if (noranini .eq. 0 .and. iop(47) .le. 2) then
        if (ixor+ixr(1)+ixr(2)+ixr(3)+ixr(4) .gt. 0) then
          do i=1,4
            rix(i)=ixr(i)
          end do
          ixo=ixor
          call ranini(iout,0,0,iop(24))
          if (nseedread .gt. 0) then
             write (iout,2002)
            nwwarn=nwwarn+1
          end if
        end if
      end if
      if (iop(24) .gt. 0 .and. iop(97) .eq. 0 .and. MYRANK .eq. 0)
     -   write (iout,2009) filename(1:namlen),nmolec-1
      if (idebug(49) .gt. 0 .and. MYRANK .eq. 0) write (iout,3000)
     -  'end',filename(1:namlen),nmolec,natoms,nslt,iainc,nslv
      lineno=lineno0
      return
9910  if (MYRANK .eq. 0) write (iout,2007) ia,line
      call datprt(2)
9930  if (MYRANK .eq. 0) write (iout,2008)
     -   'number of solvent molecules and seeds',line
      call datprt(2)
9940  if (MYRANK .eq. 0) write (iout,2008) 'number of atoms',line
      call datprt(2)
9950  if (MYRANK .eq. 0) write (iout,2008) 'cell parameters',line
      call datprt(2)
9960  if (MYRANK .eq. 0) write (iout,2008) 'occupancy or B factor',line
      call datprt(2)
9970  if (MYRANK .eq. 0) write (iout,2008) 'coupling parameter',line
      call datprt(2)
9999  if (MYRANK .eq. 0) write (iout,2005) filename(1:namlen),natsr,ia
      if (ia .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,2006) (c(k,1),k=1,3),(c(k,ia),k=1,3)
      call datprt(2)
1000  format(i5,4i6,i10)
1001  format(3f15.0)
1003  format(5x,3f15.5)
1004  format(1x,a)
1005  format(3f8.0)
1006  format(3f10.0)
1007  format(2f6.0)
1008  format(i4)
1009  format(i5)
2001  format(' ***** ERROR: the last three records of the file ',a,
     -  ' are incomplete')
2002  format(' ===== STRONG WARNING: random number seeds read with the',
     -  ' SEED key earlier were superseded with the data just read',
     -  ' - put the SEED key after the CNFG key to avoid it')
2003  format(' ***** ERROR: MMC binary coordinate file is too short',
     -  'while trying to read',i9,' atoms')
2004  format(' Number of solvents established from file ',a,'=',i6,/,
     -  ' Number of resulting atoms:',i6,' + ',i6,' * ',i3,' = ',i7)
2005  format(' ***** ERROR: program is trying to read from file ',a,
     -  i6,' atoms but only ',i5,' atoms were found')
2006  format(' coordinates of the first atom=',3f12.5,/,
     -  ' coordinates of the last atom=',3f12.5)
2007  format(' ***** ERROR: invalid format for coordinates for atom ',
     -  i7,' line read:',/,a80)
2008  format(' ***** ERROR: invalid format for ',a,' line read:',/,
     -  a80)
2009  format(' Configuration read from file ',a,' with ',i6,
     -  ' solvent molecules')
2010  format(' ***** ERROR: number of atoms in the file ',a,
     -  ' (',i8,') is less than the required number (',i8,')')
2011  format(' ===== STRONG WARNING: file ',a,' has ',a,' atoms (',i8,
     - ') than required by the input data (',i8,')')
2012  format(' ===== STRONG WARNING: conflicting data on file ',a,':',/,
     -  7x,'The number of lines (',i7,') is not equal to the number of',
     -  ' atoms (',i7,') + ',i1)
2013  format(' ===== STRONG WARNING: Number of atoms/solvent in the ',
     -  'input structure (',i4,') contradicts the SLVA key (',i4,')')
2014  format(' The ',a,' been read from the file ',a,' as ',
     -  3f10.5)
2015  format(' The ',a,' will remain unchanged from the value ',
     -  'established by the ',a4,' key')
2016  format(' ***** PROGRAM ERROR: bond oreder read is only valid ',
     -  'with PDB input file')
2017  format(' ===== STRONG WARNING: number of solvents established ',
     -  ' from the file ',a,' (',i6,')',/,7x,'differs from the number ',
     -  'established previously (e.g., by the NSLV key) (',i6,')',/,
     -  7x,'The program will use ',i6,' unless it is overridden by a',
     -  ' trajectory frame')
2018  format(' Coupling parameter will be determined from the solute ',
     -  'coordinates on file ',a)
2019  format(' ***** ERROR: file ',a,' has no ATOM or HETATM record -',
     -  ' can not be a PDB file')
2020  format(' ***** ERROR: file ',a,' has no title line starting with',
     -  ' * - can not be a Charmm CRD file')
2021  format(' ----- WARNING: cell information is read as zero - the ',
     -  'cell specified by the PBCN key will be used')
3000  format(' READCRD ',a,' file:',a,' nmolec,natoms,nslt,iainc,nslv=',
     -  5i8)
      end
      subroutine findnats(iop47,icord,nslt,nslv,natoms,numsolv,
     -  nwarn,inperr,iout)
c#    MMC routine 432/a lstmod 05/21/10
      character*80 line
      natoms=0
      if (iop47 .eq. 0) then
c       MMC ASCII
        do while (.true.)
          read (icord,*,end=9900,err=9900) cx,cy,cz
          natoms=natoms+1
        end do
9900    continue
      else if (iop47 .eq. 1) then
c       MMC binary
        read (icord)
        read (icord,end=9910) cpl
        read (icord,end=9910) edg
        read (icord,end=9910) numsolvr,ixr,ixor
        natoms=nslt+numsolv*nslv
9910    continue
      else if (iop47 .eq. 2) then
c       MMC annnotated ASCII
        read (line,*,err=9920) natomsr
        natoms=natomsr
9920    continue
      else if (iop47 .eq. 3) then
c       PDB
        line(1:3)='   '
        do while (line(1:3) .ne. 'END')
          read (icord,1000,end=9930) line
          if (line(1:4) .eq. 'ATOM' .or. line(1:6) .eq. 'HETATM')
     -      natoms=natoms+1
        end do
9930    continue
      else if (iop47 .eq. 4) then
c       Charmm CRD
        line(1:1)='*'
        nstar=0
        do while (line(1:1) .eq. '*')
          read (icord,1000,end=9940) line
          nstar=nstar+1
        end do
        if (nstar .eq. 0) go to 9940
        read (line,*,err=9940) natomsr
9940    continue
      end if
      numsolv=(natoms-nslt)/nslv
      write (iout,2000) natoms,numsolv
      if (mod(natoms-nslt,nslv) .ne. 0) then
        write (iout,2001)
        mwarn=nwarn+1
      end if
      if (natoms .eq. 0) then
        write (iout,2002)
        mwarn=inperr+1
      end if
      return
1000  format(a)
2000  format(' The number of atoms established=',i6,
     -  ' number of solvents=',i6)
2001  format(' ----- WARNING: Number of solvent atoms is not divisible',
     -  ' by the number of atoms/solvent (',i4,')')
2002  format(' ***** ERROR: No atoms were found')
      end
      subroutine getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -  nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,
     -  incrun,ia0,c,incc,lmnst,uusfac,icpu0,nsvp,nopost)
c#    MMC routine 433 lstmod: 01/04/22
c*****Get the next configuration from the history file
      dimension c(3,#NA)
      real*8 uusfac
      character*80 file,filenames,line
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /overlay/ covref(3,#ST),rangerad,ixovref(#ST),
     -  icrefok,ixrefok,irangetyp,novuse
      common /bondmod/ nmake,imake(2,250),nbreak,ibreak(2,250),nhhb,nhrb
      real*8 gain,timeint,accsumtrans,accsumrot,accsumtor,accsumloop,
     -  accsumtransprev,accsumrotprev,accsumtorprev,accsumloopprev,
     -  stepsumtrans,stepsumrot,stepsumtor,stepsumloop,
     -  stepsumtranscumu,stepsumrotcumu,stepsumtorcumu,stepsumloopcumu,
     -  wsum,wstepsum,wsum1,wstepsum1
      common /steptune/ gain(4),timeint(4),wsum(4),wstepsum(4),wsum1(4),
     -  wstepsum1(4),accsumtrans(#MM),accsumtransprev(#MM),
     -  stepsumtrans(3,#MM),stepsumtranscumu(3,#MM),
     -  accsumrot(3,#MM),accsumrotprev(3,#MM),stepsumrot(3,#MM),
     -  stepsumrotcumu(3,#MM),accsumtor(#TR),accsumtorprev(#TR),
     -  stepsumtor(#TR),stepsumtorcumu(#TR),accsumloop(#LT),
     -  accsumloopprev(#LT),stepsumloop(#LT),stepsumloopcumu(#LT),
     -  targetacc(4),tunstpmn(4),tunstpmx(4),nmc_zeroacc(4),istune(4),
     -  istunestep(4),istunetyp(4),ntrantune(#MM),nrottune(3,#MM)
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 virial,virscn,virsco,vsltsm,vircsm
      common /force/ virial(3),virscn(3),virsco(3),vsltsm(3),vircsm(3),
     -  virc(3),frixyz(3),frjxyz(3),vrsltn(3,#MO),vrslto(3,#MO)
      common /frind8/ tsindo(3,#MO),tsindn(3,#MO)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      Real*8 xtlabc
      common /charmm/ xtlabc(6),icntrlr(20),icntrlw(20),nfreatr,nfreatw,
     -  ichopen,ifree(#NA)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      character*17 formatnames
      common /trajform/ formatnames(11)
      common /trajhead/ etoth,eslth,bparh,modelnumh,ietoth,ibparh
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      dimension edg(3)
      character*80 titline(32)
      character*4 iatn
      Real*8 uusfacd,etotod,tesi1d,tss12d,tss6d,tss1d
      real*8 atwsuminp
      ieof=0
      ifail=0
      iedgeread=0
      nsvp=3
      modelnumh=0
      ietoth=0
      ibparh=0
c     write (iout,*) 'GETCNFH nconnfail=',nconnfail
      if (iop(26) .eq. 4) nsvp=nslv
      uusfac=1.d0
      if (iop(121) .gt. 0) then
c       Superimposition
        atwsuminp=0.d0
        if (iop(121) .eq. 1 .and. icrefok .eq. 0) then
          call trnsfr(covref,c,3*nstta)
          icrefok=1
        end if
      end if
      if (idebug(132) .gt. 0) write (iout,2015) nslv,nsvp,incc,nopost
100   if (iop(9) .le. 2) then
c       Read the next configuration from the stack.
        lstac=lstac+1
        nmc=nmcst(lstac)
        etoto=estac(lstac)
        isolv=istc(lstac)
        icsol1=ic01+isolv*nslv
        if (isolv .eq. 1) icsol1=1
        if (iop(30) .eq. 7) then
c         If variable coupling parameter is used, save coupling parameter
          cplpar=becpst(lstac)
        else
c         Get solvent binding energy
          tesi(isolv)=becpst(lstac)
c         If iop(9)=2 get virial sum instead of solvent binding energy
          if (iop(9) .eq. 2) vsum=becpst(lstac)
        end if
        call trnsfr(c(1,icsol1),cst(1,lstac),9)
        if (lstac .ge. 250) then
          read (ihist,err=980,end=998) estac,cst,istc,nmcst,becpst
          lstac=0
          lmnst=lmnst+1
        end if
      else if (iop(9) .eq. 3) then
      else if (iop(9) .eq. 4 .or. iop(9) .eq. 5) then
c       Read configuration ASCII MMC trajectory
        lmnst=lmnst+1
        read (ihist,1003,end=998) line
        if (line(7:15) .ne. ' (n) nml=') then
          write (iout,2011) filenames(3)(1:namlens(3)),
     -      formatnames(iop(9)),' ',lmnst,' ',line
          go to 888
        end if
        read (line,1000,err=970)
     -    natomp,nmolecr,natomsr,ia0,ia1,nmc,cplpar
        if (idebug(56) .gt. 0) write (iout,2007)
     -    natomp,nmolecr,natoms,ia0,ia1,nmc,cplpar
        call setnmolec(iop(97),nmolecr,natomsr,numsolv,nmolec,natoms,
     -    nstta,nslv,incc,nmc,ifail,inperr,iout)
        if (ifail .gt. 0) go to 888
        if (iop(9) .eq. 4) then
c         ASCII, only coordinates
          do i=ia0,ia1
            lmnst=lmnst+1
            read (ihist,1003,end=999) line
            read (line,1011,err=971) (c(k,incc+i),k=1,3)
          end do
          do iw=2,nmolec
            do j=1,nsvp
              lmnst=lmnst+1
              read (ihist,1003,end=999) line
              read (line,1011,err=972) (c(k,ic00+iw*nslv+j),k=1,3)
            end do
          end do
        else
c         ASCII, Annotated with atomic symbols, residue number
          do i=ia0,ia1
            lmnst=lmnst+1
            read (ihist,1003,end=999) line
            read (line,1001,err=971) iatn,(c(k,incc+i),k=1,3),igrslts
          end do
          do iw=2,nmolec
            do j=1,nsvp
              lmnst=lmnst+1
              read (ihist,1003,end=999) line
              read (line,1001,err=972) iatn,
     -          (c(k,ic00+iw*nslv+j),k=1,3),igrsltiw
            end do
          end do
        end if
        lmnst=lmnst+1
        read (ihist,1003,end=999) line
        read (line,1004,err=973) et
        lmnst=lmnst+1
        read (ihist,1003,end=999) line
        read (line,1007,err=974) uusfac
        etoto=et
        if (iop(71) .gt. 0) then
          read (ihist,1003,end=999) line
          read (line,1008,err=975) edg
          iedgeread=1
          lmnst=lmnst+1
        end if
      else if (iop(9) .eq. 6) then
c       Read MMC binary format
        read (ihist,end=998,err=976) nwatr,natomsr,uusfacd,nmc,nidmc,
     -    niaccp,ndaccp,ia0,ia1,etotod,tesi1d,tss12d,tss6d,tss1d,cplpar
        uusfac=uusfacd
        etoto=etotod
        tesi(1)=tesi1d
        tss12=tss12d
        tss6=tss6d
        tss1=tss1d
        nmolecr=nwatr+1
        if (nmolecr/10 .gt. #MO .or. natomsr/10 .gt. #NA .or.
     -      nmolecr .lt. 0 .or. natomsr .lt. 0) then
          write (iout,2011) filenames(3)(1:namlens(3)),
     -      formatnames(iop(9))
          write (iout,2012) nwatr,natomsr
          go to 888
        end if
        call setnmolec(iop(97),nmolecr,natomsr,numsolv,nmolec,natoms,
     -    nstta,nslv,incc,nmc,ifail,inperr,iout)
        if (ifail .gt. 0) go to 888
        read (ihist,err=980,end=999) ((c(k,incc+j),k=1,3),j=ia0,ia1),
     -    (((c(k,nstta+(i-1)*nslv+j),k=1,3),j=1,nsvp),i=1,nwatr)
        lmnst=lmnst+2
        if (iop(71) .gt. 0) then
          read (ihist) edg
          call updatecell(edg,edgexyz,nmc,lmnst0,nwwarn,ifailu,inpt,
     -      iout)
          iedgeread=1
          lmnst=lmnst+1
        end if
        if (iop(107) .gt. 0) then
          read (ihist) istune
          lmnst=lmnst+1
          if (istune(1)+istune(2) .gt. 0) then
            read (ihist) stepsumtrans,stepsumrot
            lmnst=lmnst+1
          end if
          if (istune(3) .gt. 0) then
 
            read (ihist) (stepsumtor(it),it=1,istune(3))
            lmnst=lmnst+1
          end if
          if (istune(4) .gt. 0) then
            read (ihist) (stepsumloop(it),it=1,istune(4))
            lmnst=lmnst+1
          end if
        end if
      else if (iop(9) .eq. 7 .or. iop(9) .eq. 8) then
c       Read [MODEL/ENDMDL] PDB format
        lmnst=lmnst+1
        call blankout(line,1,80)
        read (ihist,1003,end=998) line
        natomp=0
        do while (line(1:6) .eq. 'REMARK' .or. line(1:5) .eq. 'MODEL')
          if (line(1:5) .eq. 'MODEL') then
            call lastchar(line,lc,80)
            read(line(6:lc),*,end=977,err=977) modelnumh
          else if (line(7:9) .eq. ' E=') then
            read (line(10:25),*) etoto
            etoth=etoto
            read (line(43:58),*) eslth
            ietoth=1
          else if (line(7:14) .eq. ' SACP B=') then
            read (line(15:23),*) bparh
            ibparh=1
          else if (line(7:9) .eq. ' n=') then
            read (line,1006,err=970) natomp,nmolecr,natomsr,ia0,ia1,
     -        nmc,cplpar
          end if
          call blankout(line,1,80)
          read (ihist,1003,end=998) line
          lmnst=lmnst+1
        end do
        if (iop(9) .eq. 8 .and. modelnumh .eq. 0) then
            write (iout,2011) filenames(3)(1:namlens(3)),
     -        formatnames(iop(9)),' ',lmnst,' ',line
            write (iout,*) 'REMARK MODEL record is missing'
            go to 888
        end if
        if (natomp .eq. 0) then
            write (iout,2011) filenames(3)(1:namlens(3)),
     -        formatnames(iop(9)),' ',lmnst,' ',line
            write (iout,*) 'REMARK n=dddddd m=dddddd record is missing'
            go to 888
        end if
c       if (iop(9) .eq. 8) then
c         if (line(1:6) .ne. 'MODEL') then
c           write (iout,2011) filenames(3)(1:namlens(3)),
c    -        formatnames(iop(9)),' ',lmnst,' ',line
c           go to 888
c         else
c           call lastchar(line,lc,80)
c           read(line(6:lc),*,end=977,err=977) modelnum
c         end if
c       end if
c       read (line,1006,err=970) natomp,nmolecr,natomsr,ia0,ia1,
c    -    nmc,cplpar
        call setnmolec(iop(97),nmolecr,natomsr,numsolv,nmolec,natoms,
     -    nstta,nslv,incc,nmc,ifail,inperr,iout)
        if (ifail .gt. 0) go to 888
        do while (line(1:6) .eq. 'REMARK')
          read (ihist,1003,end=999) line
          if (line(7:9) .eq. ' E=') read (line(10:25),*) etoto
          lmnst=lmnst+1
        end do
        do ia=ia0,ia1
          if (ia .gt. ia0) then
            line(1:3)='TER'
            do while (line(1:3) .eq. 'TER' .or. line(1:6) .eq. 'REMARK')
              lmnst=lmnst+1
              read (ihist,1003,end=999) line
              if (line(1:3) .eq. 'END') go to 999
            end do
          end if
          read (line,1005,err=971) (c(k,incc+ia),k=1,3)
        end do
        do im=1,nmolec-1
          do ia=1,nsvp
            line(1:3)='TER'
            do while (line(1:3) .eq. 'TER' .or. line(1:6) .eq. 'REMARK')
              lmnst=lmnst+1
              read (ihist,1003,end=999) line
            end do
            if (line(1:3) .eq. 'END') go to 999
            read (line,1005,err=972) (c(k,nstta+(im-1)*nslv+ia),k=1,3)
          end do
        end do
        if (line(1:3) .ne. 'END') read (ihist,1003,end=998)
        lmnst=lmnst+1
      else if (iop(9) .eq. 9) then
c       Read Charmm CRD files
        lmnst=lmnst+1
        read (ihist,1003,end=998) line
        if (line(1:6) .ne. '*     ') then
          write (iout,2011) filenames(3)(1:namlens(3)),
     -      formatnames(iop(9)),' ',lmnst,' ',line
          go to 888
        end if
        read (line,1006,err=970) natomp,nmolecr,natomsr,
     -    ia0,ia1,nmc,cplpar
        call setnmolec(iop(97),nmolecr,natomsr,numsolv,nmolec,natoms,
     -    nstta,nslv,incc,nmc,ifail,inperr,iout)
        if (ifail .gt. 0) go to 888
        do while (line(1:2) .eq. '* ')
          read (ihist,1003,end=999) line
          if (line(7:9) .eq. ' E=') read (line(10:25),*) etoto
          lmnst=lmnst+1
        end do
        read (line(1:5),1009) nacrd
        lmnst00=lmnst
        do ia=ia0,ia1
          lmnst=lmnst+1
          read (ihist,1003,end=999) line
          read (line,1010,err=971) (c(k,incc+ia),k=1,3)
        end do
        do im=1,nmolec-1
          do ia=1,nsvp
            lmnst=lmnst+1
            read (ihist,1003,end=999) line
            read (line,1010,err=972) (c(k,nstta+(im-1)*nslv+ia),k=1,3)
          end do
        end do
        if (lmnst-lmnst00 .ne. nacrd .and. nacrd .ne. 99999) then
          write (iout,2008) nacrd,lmnst-lmnst00,ia0,ia1,nsvp,nmolec
          ieof=1
          return
        end if
      else if (iop(9) .eq. 10) then
c       Read Amber trajectory file
        nsvp=nslv
        if (natskip .ge. 0) natsread=natoms+natskip-incc
        if (natskip .lt. 0) natsread=natoms-incc
        lmnst0=lmnst
301     read (ihist,1002,end=300) ((c(k,incc+i),k=1,3),i=1,natsread)
        lmnst=lmnst+(3*natsread-1)/10+1
        if (iop(161) .ge. 1) then
c         Read new box size
          lmnst=lmnst+1
          do i=1,80
            line(i:i)=' '
          end do
          read (ihist,1003,end=999) line
          read (line,1002,err=975) edg(1),edg(2),edg(3)
          if (line(25:32) .ne. '        ') then
            write (iout,2016) lmnst
            nwwarn=nwwarn+1
          end if
          if (iop(161) .eq. 1) iedgeread=1
        else
          if (c(1,incc+2)+c(2,incc+2)+c(3,incc+2)+c(1,incc+3)+
     -        c(2,incc+3)+c(3,incc+3) .eq. 0.0) then
            write (iout,2005) nmc
            nwwarn=nwwarn+1
          end if
        end if
        if (iedgeread .eq. 1) then
          call updatecell(edg,edgexyz,nmc,lmnst0,nwwarn,ifailu,inpt,
     -      iout)
          if (ifailu .gt. 0) go to 888
        end if
        if (natskip .lt. 0) then
c         Skip from the beginning
          do ia=1,natsread
            call trnsfr(c(1,incc+ia+natskip),c(1,incc+ia),3)
          end do
        end if
c       Shift the center from (ex/2,ey/2,ez/2) to (0,0,0) if needed
        xmin=10000.0
        xmax=-xmin
        do i=incc+1,natoms
          if (xmin .gt. c(1,incc+i)) xmin=c(1,incc+i)
          if (xmax .lt. c(1,incc+i)) xmax=c(1,incc+i)
        end do
        if (abs(xmax+xmin)/2.0 .gt. edge2xyz(1)*0.5) then
          if (lmnst0 .eq. 1) then
            write (iout,2009) 'will be'
            write (iout,2013) xmin,xmax,edge2xyz
          end if
c         Trajectory apparently was not centered
          do i=1,natoms
            call arrdiff(c(1,incc+i),c(1,incc+i),edge2xyz,3)
          end do
        else
          if (lmnst0 .eq. 1) write (iout,2009) 'appears to be already'
        end if
        if (iop(161) .ne. 2) then
c         Check/reset molecules outside the box
          do i=2,nmolec
            iw0=ic00+i*nslv
            do k=1,3
              if (c(k,iw0+1) .gt. edge2xyz(k)) then
                do j=1,nslv
                  c(k,iw0+j)=c(k,iw0+j)-edgexyz(k)
                end do
              else if (c(k,iw0+1) .lt. -edge2xyz(k)) then
                do j=1,nslv
                  c(k,iw0+j)=c(k,iw0+j)+edgexyz(k)
                end do
              end if
            end do
          end do
        end if
        nmc=nmc+1
        call checkconn(c,incc,nstta,nmc,ifail,nconnfail,nmake,
     -    nwwarn,iout)
        go to 500
c       Try opening the next trajectory file
300     call newhist(iop(24),iout,ihist,numrunh,nhstvers,iform(3),
     -    filenames(3),filenameh,namlenh,namlens(3),lmnst,nmc,nmchinc,
     -    incrun,iop(9),ialttraj,ieof)
        if (ieof .eq. 0) then
          read (ihist,1003,end=999) titline(1)
          lmnst=1
          write (iout,2000) ihist,titline(1)
          go to 301
        else
          return
        end if
      else if (iop(9) .eq. 11) then
c       Read Charmm trajectory file (based on a program by Leif Laaksonen)
        if (natskip .ge. 0) natsread=natoms+natskip-incc
        if (natskip .lt. 0) natsread=natoms-incc
401     if (nmc .gt. 0 .and. icntrlr(11) .eq. 2) then
          read (ihist,err=980,end=400) xtlabc
          edg(1)=xtlabc(1)
          edg(2)=xtlabc(3)
          edg(3)=xtlabc(6)
          call updatecell(edg,edgexyz,nmc,lmnst0,nwwarn,ifailu,inpt,
     -      iout)
          if (ifailu .gt. 0) go to 888
        end if
        if (icntrlr(9) .gt. 0 .and. nmc .gt. 0) then
          read(ihist,err=980,end=400) (c(1,incc+ifree(j)),j=1,nfreatr)
          read(ihist,err=980,end=999) (c(2,incc+ifree(j)),j=1,nfreatr)
          read(ihist,err=980,end=999) (c(3,incc+ifree(j)),j=1,nfreatr)
        else
          read(ihist,err=980,end=400) (c(1,incc+j),j=1,natsread)
          read(ihist,err=980,end=999) (c(2,incc+j),j=1,natsread)
          read(ihist,err=980,end=999) (c(3,incc+j),j=1,natsread)
        end if
        if (natskip .lt. 0) then
c         Skip from the beginning
          do ia=1,natsread
            call trnsfr(c(1,incc+ia+natskip),c(1,incc+ia),3)
          end do
        end if
        nmc=nmc+1
        lmnst=lmnst+3
        go to 500
400     call newhist(iop(24),iout,ihist,numrunh,nhstvers,iform(3),
     -    filenames(3),filenameh,namlenh,namlens(3),lmnst,nmc,nmchinc,
     -    incrun,iop(9),ialttraj,ieof)
        if (ieof .eq. 0)
     -    call opencharmm(ihist,inpt,iout,inperr,nwarn,nwwarn,natoms,
     -      nstta,nslv,nmolec,numsolv,ieof,ntitline,titline,numrec(3),
     -      edgexyz,incc)
        if (ieof .eq. 1) return
        write (iout,2000) ihist,(titline(i),i=1,ntitline)
        nmc=0
        go to 401
      end if
500   if (nopost .eq. 0) call postreadcnfh(c,ianslv,rlcslv,rlslt1,
     -  nstta,nsvp,nslv,nmolec,nmc,incc,0,nconnfail,inperr,iout)
      if (iop(121) .gt. 0) then
c       Superimposition setup
        if (icrefok .eq. 0) then
          if (iop(121) .eq. 2) then
            call trnsfr(covref,c,3*nstta)
            icrefok=1
          else
            write (iout,2017)
            call datprt(2)
          end if
        end if
        if (ixrefok .eq. 0) then
          if (irangetyp .eq. 0) then
            write (iout,2018)
            call datprt(2)
          else
c           Get the list of atoms proximal to atom # irangetyp
            if (irangetyp .gt. 0) then
              novuse=0
              do ia=1,nstta
                if (arrdist(c(1,irangetyp),c(1,ia)) .lt.
     -              rangerad**2) then
                  novuse=novuse+1
                  ixovref(novuse)=ia
                end if
              end do
              write (iout,2019) novuse,rangerad,irangetyp
              ixrefok=1
            end if
          end if
        end if
      end if
      return
c     Try to switch to new history file
998   call newhist(iop(24),iout,ihist,numrunh,nhstvers,iform(3),
     -  filenames(3),filenameh,namlenh,namlens(3),lmnst,nmc,nmchinc,
     -  incrun,iop(9),ialttraj,ieof)
      if (ieof .eq. 0) go to 100
      return
970   write (iout,2002) lmnst,nmc,'record header',line
      go to 997
971   write (iout,2002) lmnst,nmc,'a solute record',line
      go to 997
972   write (iout,2002) lmnst,nmc,'a solvent record',line
      go to 997
973   write (iout,2002) lmnst,nmc,'total energy',line
      go to 997
974   write (iout,2002) lmnst,nmc,'US factor',line
      go to 997
975   write (iout,2002) lmnst,nmc,'box information',line
      go to 997
976   write (iout,2001)
      if (iop(71) .eq. 0) write (iout,2003)
      if (iop(107) .eq. 0) write (iout,2004)
      go to 997
977   write (iout,2002) lmnst,nmc,'MODEL number',line
      go to 997
999   write (iout,2010) lmnst,nmc,line
      go to 997
980   write (iout,2006) lmnst,nmc
997   ieof=1
888   if (icpu0 .eq. 0) then
        call datprt(2)
      else
        inperr=inperr+1
        if (iop(26) .eq. 4) write (iout,2014)
        return
      end if
1000  format(i6,9x,i6,8x,i6,7x,2i6,5x,i9,4x,f8.0)
1001  format(a4,1x,3f15.5,i5)
1002  format(10f8.3)
1003  format(a80)
1004  format(19x,e16.6)
1005  format(30x,3f8.3)
1006  format(9x,i6,3x,i6,5x,i6,7x,2i6,5x,i9,4x,f8.0)
1007  format(8x,e13.8)
1008  format(9x,3f10.5)
1009  format(i5)
1010  format(20x,3f10.0)
1011  format(3f15.5)
2000  format(' Next trajectory file opened on unit',i4,
     -  (/,5x,'Title: ',a80))
2001  format(' ***** ERROR: incomplete header record in the history ',
     -  'file at nmc=',i10)
2002  format(' ***** ERROR in history file record no ',i6,' nmc=',i10,
     -  ' while reading ',a,/,' line read:',a80)
2003  format(7x,'If constant pressure ensemble run created this ',
     -  'trajectory, the IBEN key should be used again')
2004  format(7x,'If stepsize tuning was used for creating this ',
     -  'trajectory, the same STUN keys(s) should be used again')
2005  format(' ===== STRONG WARNING: second and third atom ',
     -  ' coordinates are zero at Nmc=',i10,/,' - looks like there is ',
     -  'box size information in the trajectory file.',
     -  ' You may need to use the BOX or BOXX key')
2006  format(' ***** ERROR: incomplete binary record on history file',
     -  ' record no=',i6,' nmc=',i10)
2007  format(i6,' (n) nml=',i6,' natoms=',i6,' ia0,1=',2i6,
     -  ' Nmc=',i9,' cp=',f8.6)
2008  format(' ***** ERROR: number of atoms in the CRD history file (',
     -  i7,') is different from the number of atoms read (',i7,')',/,
     -  ' first and last solute atom=',2i7,' number of atoms/solvent=',
     -  i4,' number of solvents=',i8)
2009  format(' +++++ Trajectory file ',a,' centered around (0,0,0)')
2010  format(' ***** ERROR: incomplete structure on history file  - ',
     -  'last record no ',i6,' nmc=',i10,' last line read:',/,7x,a80)
2011  format(' ***** ERROR: trajectory file ',a,' is not in ',a,
     -  ' format',a,'at record number ',i8,a,/,7x,'Last record read=',a)
2012  format(' The number of solvents, atoms recorded=',2i12)
2013  format(7x,'Range of X-coordinates: [',f10.5,',',f10.5,'], ',
     -  'box half edges=',3f10.5)
2014  format(7x,'If the trajectory file was written with a version ',
     -  'before Aug. 2006 then add to the input the line',/,
     -  7x,'DBUG 1 131 1')
2015  format(' GETCNFH nslv,nsvp=',2i4,' incc,nopost=',2i4)
2016  format(' ===== STRONG WARNING: box-size line in the trajectory ',
     -  'file contains more than three numbers in record no',i8,/,7x,
     -  '- number of molecules might be off or the file may not ',
     -  'contain box information')
2017  format(' ***** ERROR: No reference structure was read')
2018  format(' ***** ERROR: overlay atom selection is misssing')
2019  format(' Overlay setup:',i7,' atoms were found within',f7.2,' A',
     -  ' of solute atom',i7)
      end
      subroutine setnmolec(iop97,nmolecr,natomsr,numsolv,nmolec,natoms,
     -  nstta,nslv,incc,nmc,ifails,inperr,iout)
c#    MMC routine 434 lstmod: 12/10/13
      ifails=0
      if (iop97 .eq. 0) then
c       Number of molecules is assumed to be fixed
        if (nmolec .ne. nmolecr) then
          write (iout,1002) nmolec-1,nmolecr-1
          inperr=inperr+1
        end if
        if (nstta*nslv .gt. 0) then
          nsttachk=nstta-incc
          if (natomsr-(nmolecr-1)*nslv .ne. nsttachk) then
            write (iout,1000) nsttachk,natomsr-(nmolecr-1)*nslv,nmc
            inperr=inperr+1
          end if
        end if
      else
c       Update the number of molecules, atoms
        call checkdim(ifail,iout,ieof,'MO',nmolecr,1,0,0)
        ifails=ifails+ifail
        call checkdim(ifail,iout,ieof,'NA',natomsr,1,1,0)
        ifails=ifails+ifail
        if (ifails .eq. 0) then
          nmolec=nmolecr
          numsolv=nmolec-1
          natoms=natomsr
        else
          inperr=inperr+1
        end if
      end if
      return
1000  format(' ***** ERROR: Number of solute atoms (',i6,') differs ',
     -  'from the number (',i6,') on the history file at Nmc=',i10)
1002  format(' ***** ERROR: Number of solvents on history file (',i9,
     -  ') differs from the value set with NSLV (',i6,')',/,
     -  7x,'- drop the NSLV key to allow variable number of molecules')
      end
      subroutine newhist(iverbos,iout,ihist,numrun,nhstvers,iform3,
     -  filenames3,file,namlenf,namlens3,lmnst,nmc,nmchinc,incrun,iop9,
     -  ialttraj,ieof)
c#    MMC routine 435 lstmod: 09/16/14
c*****Try to open a new trajectory file as a continuation
      character*80 file,filenames3
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      write (iout,1000) filenames3(1:namlens3)
      nhstversn=nhstvers
      if (incrun .eq. 0) nhstversn=nhstvers+1
      numrunn=numrun
      if (incrun .eq. 1) numrunn=numrun+1
      ialttyp=ialttraj
      if (ialttraj .eq. 0) then
        if (iop9 .eq. 12) ialttyp=19
        if (iop9 .eq. 10) ialttyp=35
      end if
      call fileopen(file,namlenf,filenames3,namlens3,3,ialttyp,
     -  numrunn,-nhstversn,2,iform3,iverbos,iversout,iout,ihistn,1)
      if (ihistn .gt. 0) then
        call fileclose(ihist,0,iverbos,iout)
        ieof=0
        lmnst=0
        ihist=ihistn
        if (incrun .eq. 0) nhstvers=nhstversn
        if (incrun .eq. 1) numrun=numrunn
        nmchinc=nmchinc+nmc
        ifilstat(3)=-ihistn
      else
        ieof=1
      end if
      return
1000  format(' Finished reading file ',a,
     -  ' - trying to open the next version')
      end
      subroutine updatecell(edg,edgexyz,nmc,lmnst0,nwwarn,ifail,inpt,
     -  iout)
c#    MMC routine 436 lstmod: 09/23/14
c*****Update cell information with new cell sizes read
      dimension edg(3),edgexyz(3)
      common /option/ iop(200),idebug(200)
      common /oldedge/ exyzo(3),ionemessage
      ifail=0
      if (iop(5) .eq. 7) then
        write (iout,2012)
C@ND        call datprt(2)
C@DM        ifail=1
C@DM        return
      end if
      if (edg(1)*edg(2)*edg(3) .eq. 1.0) then
        if (ionemessage .eq. 0) then
          ionemessage=1
          write (iout,2013)
        end if
        return
      end if
      call initbc(iop(5),edg(1),edg(2),edg(3),iop(24),inpt,iout)
      call crorgn(edgexyz(1),edgexyz(2),edgexyz(3),iop(5),3)
      if (edg(1) .le. 0.0 .or. edg(2) .lt. 0.0 .or.
     -    edg(3) .le. 0.0) then
        write (iout,2010) nmc,edg
C@ND        call datprt(2)
C@DM        ifail=1
C@DM        return
      end if
      if (lmnst0 .gt. 1) then
        dmax=0.0
        do k=1,3
          rdev=abs(edgexyz(k)-exyzo(k))/edgexyz(k)
          if (rdev .gt. dmax) dmax=rdev
        end do
        if (rdev .gt. 0.2) then
          write (iout,2011) nmc,exyzo,edgexyz
          nwwarn=nwwarn+1
        end if
      end if
      call trnsfr(exyzo,edgexyz,3)
      return
2010  format(' ***** ERROR: invalid box size read at Nmc=',i10,':',
     -  3f10.4)
2011  format(' ===== STRONG WARNING: unphysically large change in the',
     -  ' box sizes at Nmc=',i10,':',/,' from ',3f10.3,' to',3f10.3)
2012  format(' ***** ERROR: can not use input PBC with Charmm or Amber',
     -  ' trajectory format')
2013  format(' ///// NOTE: All edge parameters are 1.0 - they will be ',
     -  'ignored')
      end
      subroutine checkconn(c,incc,n,nmc,ifail,nfail,nmake,
     -  nwwarn,iout)
c#    MMC routine 437 lstmod: 05/19/16
c*****Check connected atoms to guard against scrambling the frame
      dimension c(3,n)
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      ifail=0
      nww=0
      do ia=incc+1,n
        do in=1,nneig(ia)
          ing=ineig(in,ia)
          if (ing .gt. ia) then
            d2=arrdist(c(1,ia),c(1,ing))
            if (d2 .gt. 10.0) then
              if (nmake .eq. 0) then
                nww=nww+1
                if (nww .le. 25 .and. nfail .le. 10) then
                  write (iout,1000) ia,ineig(in,ia),sqrt(d2),nmc,
     -              (c(k,ia),k=1,3),(c(k,ing),k=1,3)
                else if (nfail .le. 10) then
                  write (iout,1001)
                end if
              else
                nww=nww+1
                if (nww .le. 25 .and. nfail .le. 10)
     -            write (iout,1003) ia,ineig(in,ia),sqrt(d2),nmc
              end if
            end if
          end if
        end do
      end do
      if (nww .gt. 0 .and. nfail .le. 10) then
        ifail=1
        write (iout,1002)
        nfail=nfail+1
      end if
      nwwarn=nwwarn+nww
      return
1000  format(' ===== STRONG WARNING: bonded atom pairs ',i6,i7,' are ',
     -  f5.2,' A apart at Nmc=',i10,' c=',3f7.1,' cng=',3f7.1)
1001  format(' Further messages of this kind are supressed')
1002  format(' Such errors indicate mismatch between .slt and ',
     -  '.hst files')
1003  format(' ===== STRONG WARNING: bonded atom pairs ',i6,i7,' are ',
     -  f5.2,' A apart at Nmc=',i10)
      end
      subroutine postreadcnfh(c,ianslv,rlcslv,rlslt1,nstta,nsvp,nslv,
     -  nmolec,nmc,incc,MYRANK,nconnfail,inperr,iout)
c#    MMC routine 437/a lstmod: 11/27/06
c*****Post-processing after a trajectory read
      dimension c(3,#NA),ianslv(nslv),rlcslv(3,nslv),rlslt1(3,nstta)
      common /bondmod/ nmake,imake(2,250),nbreak,ibreak(2,250),nhhb,nhrb
      common /option/ iop(200),idebug(200)
      dimension crmslv(3),cs1(3,3),orients(3,3)
      if (idebug(132) .gt. 0)
     -   write (iout,1001) nstta,nsvp,nslv,nmolec,nmc
C@DM     -  ,MYRANK
      if (iop(9) .le. 2 .and. nstta-incc .gt. 3) then
c       Recreate solute atoms if necessary
c       Determine solute orentation
        do j=1,3
          call arrdiff(cs1(1,incc+j),c(1,incc+j),c,3)
        end do
        call ormat(orients,rlslt1(1,incc+1),cs1,3,0,linear,ifail)
        call ckortfail(ifail,'input configuration',19,0,0,0,inperr,iout)
        do i=incc+4,nstta
          c(1,i)=c(1,1)+
     -      orients(1,1)*rlslt1(1,i)+orients(1,2)*rlslt1(2,i)+
     -      orients(1,3)*rlslt1(3,i)
          c(2,i)=c(2,1)+
     -      orients(2,1)*rlslt1(1,i)+orients(2,2)*rlslt1(2,i)+
     -      orients(2,3)*rlslt1(3,i)
          c(3,i)=c(3,1)+
     -      orients(3,1)*rlslt1(1,i)+orients(3,2)*rlslt1(2,i)+
     -      orients(3,3)*rlslt1(3,i)
         end do
      end if
      if (idebug(132) .gt. 1)
     -  write (iout,1002) (i,(c(k,i),k=1,3),i=1,nstta)
      call checkconn(c,incc,nstta,nmc,ieof,nconnfail,nmake,
     -  nwwarn,iout)
      if (nsvp .lt. nslv) then
c       Recreate additional solvent atoms
        do im=2,nmolec
          ifat=nstta+(im-2)*nslv+1
          call cofms(c(1,ifat),crmslv,ianslv,1,nsvp,1,wx)
          do j=1,3
            call arrdiff(cs1(1,j),c(1,ifat-1+j),crmslv,3)
          end do
          call ormat(orients,rlcslv,cs1,3,im-1,linear,ifail)
          if (idebug(132) .gt. 1 .or. idebug(132) .eq. 1 .and.
     -      (im .eq. 2 .or. im .eq. nmolec)) write (iout,1000)
     -      im,'before',((c(k,ifat-1+j),k=1,3),j=1,3)
          call rot_trans(orients,rlcslv,crmslv,c(1,ifat),nslv)
          if (idebug(132) .gt. 1 .or. idebug(132) .eq. 1 .and.
     -      (im .eq. 2 .or. im .eq. nmolec)) write (iout,1000)
     -      im,'after ',((c(k,ifat-1+j),k=1,3),j=1,nslv)
        end do
      end if
      return
1000  format(' Solvent',i5,1x,a,' extension:',(3(3f10.5,2x)))
1001  format(' POSTREADCNFH nstta,nsvp,nslv,nmolec,nmc=',i6,2i4,i6,i10
C@DM     -  ,' MYRANK=',i4
     -  )
1002  format(' c(',i6,')=',3f10.5)
      end
      subroutine opentraj(filename,namlen,nslt,nslv,nsvp,c,incc,nmolec,
     -  numsolv,natoms,nmcstart,cplpar,iskip1,lmnst,inoconwarn,uusfac,
     -  edgexyz,ieof,nconnfail)
c#    MMC routine 438 lstmod: 05/05/14
c*****Open a trajectory file for analysis
      character*80 filename
      dimension c(3,#NA),edgexyz(3)
      real*8 uusfac
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      character*80 filenameh
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      character*17 formatnames
      common /trajform/ formatnames(11)
      character*3 namunit
      common /extnames/ namunit(50)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /option/ iop(200),idebug(200)
      character*10 trname(3)
      character*80 titline
      common /trajtit/ ntitline,titline(32)
      data trname /'         ','for Amber ','for Charmm'/
      lmnst=0
      ieof=0
      iskip1=0
      nmc=0
      itrnam=max0(1,iop(9)-8)
      if (ifilstat(3) .ge. 0) then
        if (ifilstat(3) .eq. 0) write (iout,2006) filename(1:namlen),
     -    'is not open - use the TRAJ key to open it'
        if (ifilstat(3) .gt. 0) write (iout,2006) filename(1:namlen),
     -    ' is a new (empty) file'
        go to 1099
      end if
      if (ialttraj .ne. 0) write (iout,1009) namunit(ialttraj)
      if (incrun .eq. 0) write (iout,1010) 'version'
      if (incrun .eq. 1) write (iout,1010) 'run'
      rewind ihist
      if (iop(9) .eq. 11) then
c       Open Charmm trajectory
        call opencharmm(ihist,inpt,iout,inperr,nwarn,nwwarn,natoms,nslt,
     -    nslv,nmolec,numsolv,ieof,ntitline,titline,lmnst,edgexyz,incc)
        call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,nconnfail,
     -    nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,incrun,ia0,
     -    c,incc,lmnst,uusfac,0,nsvp,0)
        iskip1=1
        if (ieof .gt. 0) go to 1099
      else if (iop(9) .eq. 10) then
c       Open Amber trajectory
        if (nmolec .eq. 0) then
          write (iout,2007)
          inperr=inperr+1
        end if
        read (ihist,1000,end=1099) titline(1)
        lmnst=1
        if (iop(24) .gt. 0) write (iout,1002) titline(1)
        call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,nconnfail,
     -    nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,incrun,ia0,
     -    c,incc,lmnst,uusfac,0,nsvp,0)
        iskip1=1
        if (ieof .gt. 0) go to 1099
      else
c       Open MMC trajectory
        if (iop(9) .le. 2) then
c         Old TVN-MMC syntax
          if (iop(152) .eq. 2 .and. nslt .gt. 3) then
            write (iout,2003)
            ieof=1
            return
          end if
          lstac=0
          lmnst=1
          read (ihist,end=1099) estac,cst,istc,nmcst,becpst
          if (iconfread .eq. 0) then
            if (iop(152) .eq. 0) then
              write (iout,2001)
              ieof=1
            else
              if (inoconwarn .eq. 0) write (iout,2004)
              call getcnf(nslt-incc,nslv,iop(152),ndone,c(1,incc+1),
     -          cplpar,lmnst)
              iskip1=1
              if (ndone .lt. nmolec) then
                ieof=1
                write (iout,2005) filename(1:namlen)
              end if
            end if
          end if
        else
c         Snapshot syntaxes
          if (iconfread .eq. 0) then
            if (inoconwarn .eq. 0) write (iout,2004)
            if (iop(59) .gt. 0) then
              write (iout,2008) filename(1:namlen)
              go to 1099
            end if
            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -        nmchinc,incrun,ia0,c,incc,lmnst,uusfac,0,nsvp,0)
            iskip1=1
            if (ia0 .gt. 1) then
              write (iout,2002) ia0
              ieof=1
            end if
          else
            nmc=1
          end if
        end if
      end if
      nmcstart=nmc
      if (ieof .eq. 0 .and .iop(24) .gt. 0)
     -   write (iout,1003) formatnames(iop(9))
      if (ieof .gt. 0) inperr=inperr+1
      return
1099  write (iout,2000) filename(1:namlen),trname(max0(1,itrnam))
      inperr=inperr+1
      ieof=1
      return
1000  format(a80)
1002  format(' Amber trajectory file title:',a80)
1003  format(' History file opened - format: ',a)
2000  format(' ***** ERROR: Failed to initialize trajectory file ',a,
     -  ' ',a10)
2001  format(' ***** ERROR: Rigid and fixed solute SCAN RGFX) needs',
     - ' a configuration read by CNFG')
2002  format(' ***** ERROR: Trajectory file starts with atom ',i6,
     -  ' and no inital structure was specifed (CNFG key was not used)')
2003  format(' ***** ERROR: Variable solute with more than three ',
     -  'atoms can not be read with TRAJ ALL*')
2004  format(' Since no initial configuration was read in, the initial',
     -  ' configuration will be gathered from the trajectory file')
2005  format(' ***** ERROR: Failed to gather a configuration from the ',
     -  'file ',a)
2006  format(' ***** ERROR: trajectory file ',a,1x,a)
2007  format(' ***** ERROR: number of solvent molecules is unknown',/,
     -  7x,'You can specify it either with the NSLV or the CNFG key')
2008  format(' ***** ERROR: trajectory file ',a,' does not carry a ',
     -  'full configuration - you need to read one with the key CNFG')
1009  format(' Alternative trajectory extension: ',a)
1010  format(' Subsequent trajectory segments (if needed) are searched',
     -  ' by increasing the ',a,' number')
      end
      subroutine writeheader(iotyp,ihist,iout,natoms,nstta,ntitle,
     -  trtitle,nmcrec,nmcmax,nmcskip,isltmv,nslv,nrec,iopcellw,edgexyz,
     -  ifilt,nowrite)
      character*80 trtitle
      dimension trtitle(ntitle),edgexyz(3)
c#    MMC routine 439 lstmod: 12/05/12
c*****Initialize (if any) a trajectory
      Real*8 xtlabc
      common /charmm/ xtlabc(6),icntrlr(20),icntrlw(20),nfreatr,nfreatw,
     -  ichopen,ifree(#NA)
      common /option/ iop(200),idebug(200)
      dimension isltmv(#ST)
      if (iotyp .eq. 5 .and. natoms .gt. 99999) then
        write (iout,1002) natoms
        call datprt(2)
      end if
      rewind ihist
      if (iotyp .eq. 10) then
c       Amber
        if (nowrite .eq. 0) write (ihist,1000) trtitle(1)
      else if (iotyp .eq. 11) then
c       Charmm - see opencharmm for more comments
        call zeroiti(icntrlw,0,20)
        if (icntrlr(1) .eq. 0) then
          icntrlw(1)=(nmcmax-nmcskip)/nmcrec
          icntrlw(20)=27
        else
          icntrlw(1)=icntrlr(1)
          icntrlw(20)=icntrlr(20)
        end if
        icntrlw(2)=nmcrec
        icntrlw(3)=nmcrec
        nslvfix=max0(0,iop(14)-1)
        if (iop(57)+iop(58) .gt. 0 .and. ifilt .eq. 0) then
c         For now, use nfreat only if it was not used for reading a DCD file
          nfreatw=0
          do ia=1,nstta
            if (isltmv(ia) .gt. 0) then
              nfreatw=nfreatw+1
              ifree(nfreatw)=ia
            end if
          end do
        else
          nfreatw=nstta
        end if
        if (nfreatw .lt. nstta .or. nslvfix .gt. 0) then
c         There are fixed atoms
          if (nfreatw .eq. nstta) then
            do ia=1,nstta
              ifree(ia)=ia
            end do
          end if
          do ia=nstta+nslvfix*nslv+1,natoms
            nfreatw=nfreatw+1
            ifree(nfreatw)=ia
          end do
        else
          nfreatw=natoms
        end if
        icntrlw(8)=3*nfreatw-6
        icntrlw(9)=natoms-nfreatw
        if (nowrite .gt. 0) then
c         Add the existing number of structures
          lrec=3
          if (iopcellw .eq. 2) lrec=4
          nstart=3
          if (icntrlw(9) .gt. 0) nstart=nstart+1
          icntrlw(1)=icntrlw(1)+(nrec-nstart-1)/lrec+1
          if (idebug(95) .gt. 0) then
            write (iout,1003) icntrlw,ichopen
            if (idebug(95) .gt. 1)
     -        write (iout,1005) (ifree(i),i=1,nfreatw)
          end if
          return
        end if
c       Make sure title line is not blank
        do nl=1,ntitle
          ifc=1
          call nextchar(trtitle(nl),ifc,0,inpt,iout)
          if (ifc .ge. 80) trtitle(nl)(3:3)='.'
        end do
        nfreatw = natoms - icntrlw(9)
c       Free atom array
        write (iout,1001) nfreatw
        if (iopcellw .gt. 0) then
          if (ichopen .eq. 0) then
            icntrlw(11)=iopcellw
            do k=1,6
              xtlabc(k)=0.0
            end do
            xtlabc(1)=edgexyz(1)
            xtlabc(3)=edgexyz(2)
            xtlabc(6)=edgexyz(3)
            xtlabc(2)=90.0
            xtlabc(4)=90.0
            xtlabc(5)=90.0
          else
            icntrlw(11)=icntrlr(11)
          end if
        end if
        write (ihist) 'CORD',icntrlw
        write (ihist) ntitle,(trtitle(i),i=1,ntitle)
        write (ihist) natoms
        nrec=nrec+3
        if (icntrlw(9) .gt. 0) then
          write (ihist) (ifree(i),i=1,nfreatw)
          nrec=nrec+1
        end if
        if (iopcellw .gt. 0) then
          write (ihist) xtlabc
          nrec=nrec+1
        end if
        if (idebug(95) .gt. 0) then
          write (iout,1003) ichopen,icntrlw
          if (idebug(95) .gt. 1)
     -      write (iout,1005) (ifree(i),i=1,nfreatw)
          if (iopcellw .gt. 0) write (iout,1004) xtlabc
        end if
      end if
      return
1000  format(a)
1001  format(' Charmm trajectory file initialized for write. Number of',
     -  ' free atoms=',i7)
1002  format(' ERROR: Number of atoms (',i7,') exceeds 99999 - use ',
     -  'binary format (ALLP) instead of asci (ALLA)')
1003  format(' ichopen=',i2,' inctrl:',/,(10i8))
1004  format(' xtlabc=',6f10.5)
1005  format(' ifree =',20i6)
      end
      subroutine opencharmm(ihist,inpt,iout,inperr,nwarn,nwwarn,natoms,
     -  nslt,nslv,nmolec,numsolv,ieof,ntrtitle,trtitle,lmnst,edgexyz,
     -  incc)
c#    MMC routine 440 lstmod: 12/04/12
c*****Open a Charmm trajectory file
      character*80 trtitle(32)
      character*80 filenameh
      dimension edgexyz(3)
      common /hstory/ becpst(250),estac(250),cst(9,250),
     -  lstac,natskip,nmcst(250),istc(250),ialttraj,namlenh,filenameh
      Real*8 xtlabc
      common /charmm/ xtlabc(6),icntrlr(20),icntrlw(20),nfreatr,nfreatw,
     -  ichopen,ifree(#NA)
      common /option/ iop(200),idebug(200)
      character*4 chhd
      Real*8 xtlabct(7)
      dimension edg(3)
c     HDR for coordinate files is "CORD"
c     icntrl(1)=NUMBER OF COORDINATE SETS IN FILE
c     icntrl(2)=first step written
c     icntrl(3)=FREQUENCY FOR SAVING COORDINATES
c     icntrl(4)=NUMBER OF STEPS FOR CREATION RUN
c     icntrl(5)=frequency for saving velocities
c     icntrl(8)=number of degrees of freedom
c     icntrl(9)=number of "fixed" atoms
      ieof=0
      lmnst=lmnst+1
      ierr=1
      read(ihist,err=1100,end=1099) chhd,icntrlr
      ierr=0
1100  if (ierr .eq. 1) then
        write (iout,1011) chhd
        write (iout,1009) icntrlr
        nwwarn=nwwarn+1
      end if
      lmnst=lmnst+1
      if (chhd .ne. 'CORD') then
        write (iout,1003) chhd
        nwarn=nwarn+1
      end if
      ierr=1
      read(ihist,err=1110,end=1099) ntrtitle,(trtitle(i),i=1,ntrtitle)
      ierr=0
1110  if (ierr .eq. 1) then
        write (iout,1012) ntrtitle,(trtitle(i),i=1,ntrtitle)
        nwwarn=nwwarn+1
      end if
c     Eliminate junk characters from VMD-generated title
      do i=1,ntrtitle
        if (trtitle(i)(1:21) .eq. 'Created by DCD plugin') then
          call blankout(trtitle(i),22,80)
        else if (trtitle(i)(1:15) .eq. 'REMARKS Created') then
          call blankout(trtitle(i),38,80)
        end if
      end do
      lmnst=lmnst+1
      nfreatr=natoms-icntrlr(9)-incc
      ierr=1
      read(ihist,err=1120,end=1099) natom
      ierr=0
1120  if (ierr .eq. 1) then
        write (iout,1013) natoms
        nwwarn=nwwarn+1
      end if
      if (iop(24) .gt. 0) then
        if (icntrlr(1) .eq. 0) then
          icntrlr(1)=1000000
          write (iout,1006)
        end if
        write (iout,1001) icntrlr(1),nfreatr
        write (iout,1000) (trtitle(i),i=1,ntrtitle)
      end if
      if (natom-iabs(natskip) .lt. natoms-incc) then
        write (iout,1002) natoms-incc,natom,natskip
        nwwarn=nwwarn+1
      else if (natom-iabs(natskip) .gt. natoms-incc) then
        write (iout,1005) natoms-incc,natom,natskip
        nwarn=nwarn+1
      end if
      if (natom-iabs(natskip) .ne. natoms-incc) then
        natoms=natom-iabs(natskip)+incc
        nfreatr=natom-icntrlr(9)-incc
        numsolv=(natoms-nslt)/nslv
        nmolec=numsolv+1
        write (iout,1010) numsolv
      end if
c     Free atom array
      if (icntrlr(9) .gt. 0) then
        read (ihist) (ifree(i),i=1,nfreatr)
        lmnst=lmnst+1
      end if
c     Crystal information
      if (icntrlr(11) .gt. 0) then
        read(ihist,err=1098,end=1097) xtlabc
        if (iop(24) .gt. 0) write (iout,1007) xtlabc
        edg(1)=xtlabc(1)
        edg(2)=xtlabc(3)
        edg(3)=xtlabc(6)
        call updatecell(edg,edgexyz,0,lmnst,nwwarn,ifailu,inpt,iout)
        lmnst=lmnst+1
c       Test for cell data before 2nd config
        read(ihist,err=1098,end=1099)
        read(ihist,err=1098,end=1099)
        read(ihist,err=1098,end=1099)
        xtlabct(7)=99999.9
        read(ihist,err=2000,end=2000) xtlabct
2000    if (xtlabct(7) .ne. 99999.9) then
c         No second cell info
          icntrlr(11)=1
        else
          icntrlr(11)=2
          if (iop(24) .gt. 0) write (iout,1008)
        end if
c       Reposition trajectory
        rewind ihist
        do i=1,lmnst
         read(ihist)
        end do
      end if
      ichopen=1
      if (idebug(95) .gt. 0) write (iout,1009) lmnst,icntrlr
      return
1097  ieof=1
      write (iout,1004) lmnst,'missing'
      inperr=inperr+1
      return
1098  ieof=1
      write (iout,1004) lmnst,'incomplete'
      inperr=inperr+1
      return
1099  ieof=1
      return
1000  format(' Trajectory title: ',a80)
1001  format(' Charmm trajectory file initialized for read',/,
     -  ' Number of data sets in the trajectory: ',i7,
     -  ' Number of free atoms=',i7)
1002  format(' ===== STRONG WARNING: The number of atoms set (',i8,')',
     -  ' is more than the number of atoms in the Charmm trajectory ',
     -  'file (',i8,')',/,
     -  7x,'minus the number of atoms to be skipped (',i8,')')
1003  format(' ----- WARNING: Charm trajectory file 4-character ',
     -  'header is incorrect: ',a4,' should be CORD')
1004  format(' ***** ERROR: record #',i1,' of Charmm trajectory header',
     -  ' is ',a)
1005  format(' ----- WARNING: The number of atoms inputted (',i8,') is',
     -  ' less than the number of atoms in the Charmm trajectory file ',
     -  '(',i8,')',/,7x,'minus the number of atoms to be skipped (',i8,
     -  ')')
1006  format(' Number of structures is unknown - set to 1000000')
1007  format(' PBC cell shape matrix at start:',6f12.6)
1008  format(' PBC information is read for every frame')
1009  format(' lmnst=',i4,' icntrlr=',/,(10i8))
1010  format(' Number of solvents is established from the trajectory ',
     -  'as ',i8)
1011  format(' ===== STRONG WARNING: Charmm trajectory header is in ',
     -  'error:',/,' Header=',a)
1012  format(' ===== STRONG WARNING: Charmm trajectory title records ',
     -  'are in error:',/,' Ntitlr=',i9,/,(1x,a))
1013  format(' ===== STRONG WARNING: Charmm trajectory atom number ',
     -  'record is in error:',/,' Natoms=',i9)
      end
      function ianum(inmm,nowarn,iout,inperr)
c#    MMC routine 441 lstmod: 09/19/04
c*****Obtain atomic number from name
      character*4 inm,inmm,inm1
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      inm=inmm
c     Shift to the left if first char is blank or a number
      nshft=0
      do while ((isdigit(inm(1:1)) .eq. 1 .or. inm(1:1) .eq. '"' .or.
     -    inm(1:1) .eq. "'" .or. inm(1:1) .eq. ' ') .and. nshft .lt. 3)
        nshft=nshft+1
        do i=1,3
          j=i+1
          inm1(i:i)=inm(j:j)
        end do
        inm=inm1
        inm(4:4)=' '
      end do
c     Set deuteriums to hydrogens
      if (inm(1:1) .eq. 'D') then
        ianum=1
        return
      end if
c     Check for the first two characters at first
      do i=1,40
        if (inm(1:2) .eq. iatnam(i)) then
          ianum=i
          return
        end if
      end do
c     Check first characters only
      do i=1,40
        if (iatnam(i)(2:2) .eq. ' ') then
          if (iatnam(i)(1:1) .eq. inm(1:1)) then
            ianum=i
            return
          end if
        end if
      end do
      if (inm(1:1) .eq. 'W') then
c       Assume water
        ianum=8
        return
      end if
      if (nowarn .eq. 0) then
        write (iout,1000) inmm
        inperr=inperr+1
      end if
      ianum=99
      return
1000  format(' ***** ERROR: could not find atomic number for atom name',
     -  a,/,5x,'atom set to dummy')
      end
      function isdigit(charx)
c#    MMC routine 442 lstmod: 09/12/02
c*****Return one of the argument is a digit character
      character*1 charx
      character*1 tab,ctrlM,idigit,rdigit
      character*4 tab4,ctrlM4
      common /specchar/ tab4,ctrlM4,tab,ctrlM,idigit(10),rdigit(16)
      isdigit=0
      do i=1,10
        if (charx .eq. idigit(i)) then
          isdigit=1
          return
        end if
      end do
      return
      end
      subroutine namornum(any,intg,label,ncol)
c#    MMC routine 443 lstmod: 05/19/98
c*****Decides if ncol-character  string is a label or an integer
      character*(*) any,label
      character*1 any1
      nl=0
      do j=1,ncol
        any1=any(j:j)
        if (isdigit(any1) .eq. 0 .and. any1 .ne. ' ') nl=nl+1
      end do
      if (nl .gt. 0) then
        label=any
        intg=-1
      else
        read (any,*) intg
      end if
      return
      end
      subroutine pxscan(ihist,ichkp,ichkpx,inpt,iout,nconnfail,nwarn,
     -  orient,c,crm,texslt,incc,volav,iskip1,nrecread,uusfac,nstta,
     -  nsvp)
c#    MMC routine 444 lstmod: 03/09/12
c*****Perform the proximity analysis on the history file
      real*8 uusfac
      dimension c(3,#NA),orient(3,3,#MO),crm(3,#MO),
     -  texslt(#MO)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
      common /ecell/ cic(3,27),ncell
      real*8 blkavs
      common /btchav/ blkavs(#MI,11),nblcks
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /option/ iop(200),idebug(200)
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      dimension angincr(1)
      ieof=0
      nmclastr=nmc-nmcpxdsc
      iskipfail=0
      iii=0
      do while (.true.)
        iii=iii+1
        if (iii .gt. 1 .or. iop(10) .gt. 0 .or. iskip1 .eq. 0) then
          call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -      nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,
     -      incrun,ia0,c,incc,nrecread,uusfac,0,nsvp,1)
        else
          nmclastr=-nmcpxdsc
        end if
        if (ieof .gt. 0) go to 999
        nmcnew=nmc-nmcpxdsc
        if (nmcnew .gt. 0) then
          if (nmcransh .gt. 0 .and. iop(30) .eq. 3) then
c           Generate new random torsion shift?
            if (modrange(nmclastr,nmcnew,nmcransh) .eq. 0) then
              call randpx(1,angincr)
              inperr=0
              call postreadcnfh(c,ianslv,rlcslv,rlslt1,nstta,
     -          nsvp,nslv,nmolec,nmc,incc,0,nconnfail,inperr,iout)
              call initaddwidom(c,esf14,vdwf14,cutuus,angincr(1),1,
     -          inperr,iout)
              if (inperr .gt. 0) call datprt(2)
            end if
          end if
          if (modrange(nmclastr,nmcnew,navgpx) .eq. 0) then
            call postreadcnfh(c,ianslv,rlcslv,rlslt1,nstta,
     -        nsvp,nslv,nmolec,nmc,incc,0,nconnfail,inperr,iout)
            call disperpx(orient,c,crm,texslt,ifailpx)
            call genvol(nranpx,nranpxw,1,1,0,0.0,0,c,crm)
            nmcpxo=nmc
          end if
          if (modrange(nmclastr,nmcnew,nsavepx) .eq. 0) then
            call csave(ichkp,1,iskipfail,1)
            call csavepx(ichkpx,1,iskipfail,6)
          end if
          if (modrange(nmclastr,nmcnew,npxcntin) .eq. 0 .and.
     -        iop(142)+iop(146)+iop(148) .gt. 0) then
c           Accumulate block averages
            if (nblcks .eq. #MI) then
c             Double up block averages
              do i=1,9
                do ib=1,#MI/2
                  blkavs(ib,i)=(blkavs(2*ib,i)+blkavs(2*ib-1,i))/2.d0
                end do
              end do
              nblcks=nblcks/2
              npxcntin=2*npxcntin
              if (lumppr .ge.2) lumppr=lumppr/2
            end if
            nblcks=nblcks+1
            call pxtabl(ipxt1,pxt1,ipxt2,pxt2,0,iop(24)-2,
     -        blkavs(nblcks,1),blkavs(nblcks,2),blkavs(nblcks,3),
     -        blkavs(nblcks,4),blkavs(nblcks,5),blkavs(nblcks,6),
     -        blkavs(nblcks,7),blkavs(nblcks,8),blkavs(nblcks,9),
     -        blkavs(nblcks,10),blkavs(nblcks,11),
     -        volav,0,nfgtyp,0,0,1,numrun)
          end if
          if (nmc+navgpx .gt. npxmax) then
c           No more data, exit (will print in driver)
            return
          else if (modrange(nmclastr,nmcnew,npxres) .eq. 0 .and.
     -        nmcnew .gt.  nmclastr .and. (iop(24) .gt. 0 .or.
     -        abs(float(nmc-npxmax))/float(npxmax) .gt. 0.05)) then
c           Don't print distributions if near the end
CSUN          if (modrange(nmclastr,nmcnew,npxres) .eq. 0) then
            call disfinpx(numrun,volav)
          end if
          nmclastr=nmcnew
        end if
      end do
      return
999   write (iout,1000) nmc
      nwarn=nwarn+1
      call csave(ichkp,0,iskipfail,1)
      call csavepx(ichkpx,0,iskipfail,6)
      return
1000  format(' ----- WARNING: problem with history file at Nmc=',i10)
      end
C@DM      subroutine mpi_pxscan(ihist,ichkp,ichkpx,inpt,iout,nwarn,
C@DM     -  nconnfail,orient,c,crm,cgs,molcnt,texslt,
C@DM     -  incc,volav,iskip1,nrecread,uusfac,nstta)
C@DMc#    MMC routine 445 lstmod: 09/04/16
C@DMc*****Perform the proximity analysis on the history file
C@DM      real*8 uusfac
C@DM      dimension c(3,#NA),cgs(3,#NA),orient(3,3,#MO),
C@DM     -  crm(3,#MO),molcnt(#MM),texslt(#MO)
C@DM      common /param/ edgexyz(3),edge2xyz(3),
C@DM     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
C@DM     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
C@DM     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
C@DM     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
C@DM     -  numsolv,nsolvfix,nmolec,nmol3,natoms
C@DM      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
C@DM     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
C@DM     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
C@DM     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
C@DM     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
C@DM     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
C@DM      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
C@DM     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
C@DM     -  islvjrep(#ND),ianslv(#SV)
C@DM      common /relcd/ rlcslt(3,#ST),rlcslv(3,#SV)
C@DM      common /relcd1/ rlslt1(3,#ST),rlslv1(3,#SV)
C@DM      common /ecell/ cic(3,27),ncell
C@DM      real*8 blkavs
C@DM      common /btchav/ blkavs(#MI,11),nblcks
C@DM      real*8 tdavr,ewwnn,ewwis,befssm,besm
C@DM      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
C@DM     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
C@DM     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
C@DM     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
C@DM     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
C@DM     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
C@DM     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
C@DM     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
C@DM     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
C@DM     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
C@DM     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
C@DM      common /option/ iop(200),idebug(200)
C@DM      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
C@DM      include "mpif.h"
C@DM      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
C@DM      dimension nmcsend(3)
C@DM      data nmc_cpu0 /0/,nmc_lastcpu/0/
C@DM      nmcnew=nmclastr
C@DM      ieof=0
C@DM      iskipfail=0
C@DM      inperr0=inperr
C@DMc     call MPI_Bcast(nsvp,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DMc     call MPI_Bcast(incc,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM      nsvp=3
C@DM      if (iop(26) .eq. 4) nsvp=nslv
C@DM      if (iop(24) .gt. 2) write (ioutdb,3008) MYRANK,npxmax,navgpx,
C@DM     -  nmcpxdsc,nsvp,incc,nmc,ncnfpx
C@DM      if (nmcpxdsc .gt. 0 .and. iop(10) .eq. 0) then
C@DM        if (MYRANK .eq. 0) then
C@DMc         Skip configurations to be discarded
C@DM          do while (nmc .gt. nmcpxdsc .and. inperr .eq. inperr0 .and.
C@DM     -              ieof .eq. 0)
C@DM            nmclastr=nmc
C@DM            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
C@DM     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
C@DM     -        nmchinc,ia0,c,incc,nrecread,uusfac,1,nsvp,1)
C@DM          end do
C@DM          iskip1=1
C@DM          nmcnew=nmc-nmcpxdsc
C@DM        end if
C@DM        call MPI_Bcast(ieof,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        call MPI_Bcast(inperr,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        if (iop(24) .gt. 2)
C@DM     -    write (ioutdb,3003) MYRANK,ieof,inperr,inperr0
C@DM        if (ieof .gt. 0 .or. inperr .gt. inperr0) go to 888
C@DM      end if
C@DM      iii=0
C@DM      do while (.true.)
C@DM        nmclastr0=nmcnew
C@DM        ieofn=0
C@DM        if (MYRANK .eq. 0) then
C@DM          do icpu=0,NUMNOD-1
C@DM            do while (modrange(nmclastr,nmcnew,navgpx) .ne. 0 .and.
C@DM     -                nmcnew .lt. npxmax .and. ieofn .eq. 0)
C@DM              nmclastr=nmcnew
C@DM              if (iskip1 .eq. 0) then
C@DM                inperr0=inperr
C@DM                if (icpu .eq. 0) then
C@DM                  call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
C@DM     -              nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
C@DM     -              nmchinc,ia0,c,incc,nrecread,uusfac,1,nsvp,1)
C@DM                  nmc_cpu0=nmc
C@DM                else
C@DM                  call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
C@DM     -              nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
C@DM     -              nmchinc,ia0,cgs,incc,nrecread,uusfac,1,nsvp,1)
C@DM                end if
C@DM                ieofn=ieofn+ieof
C@DM                if (iop(24) .gt. 2) write (ioutdb,3006) nmc,icpu,ieof
C@DM              else
C@DM                iskip1=0
C@DM                ieof=0
C@DM              end if
C@DM              nmcnew=nmc-nmcpxdsc
C@DM            end do
C@DM            iii=iii+1
C@DM            if (icpu .gt. 0) then
C@DMc             Send configuration info (c, nmc, nmclastr)
C@DM              call MPI_send(nmc,1,MPI_INTEGER,icpu,10+icpu,
C@DM     -          MPI_COMM_WORLD,ierr)
C@DM              if (idebug(135) .eq. 0) then
C@DM                call MPI_send(cgs,3*natoms,MPI_REAL,icpu,
C@DM     -            10+NUMNOD+icpu,MPI_COMM_WORLD,ierr)
C@DM              else
C@DMc               Debug: send to all nodes the same structure
C@DM                call MPI_send(c,3*natoms,MPI_REAL,icpu,
C@DM     -            10+NUMNOD+icpu,MPI_COMM_WORLD,ierr)
C@DM              end if
C@DM            end if
C@DM            nmclastr=nmcnew
C@DM          end do
C@DM          nmc_lastcpu=nmc
C@DM        else
C@DMc         Receive configuration info
C@DM          call MPI_Recv(nmc,1,MPI_INTEGER,0,10+MYRANK,MPI_COMM_WORLD,
C@DM     -      MPI_stat,ierr)
C@DM          call MPI_Recv(c,3*natoms,MPI_REAL,0,10+NUMNOD+MYRANK,
C@DM     -      MPI_COMM_WORLD,MPI_stat,ierr)
C@DM        end if
C@DM        if (MYRANK .eq. 0) nmc=nmc_cpu0
C@DM        ieof=ieofn
C@DM        call MPI_Bcast(ieof,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        if (iop(24) .gt. 2 .and. ieof .gt. 0)
C@DM     -    write (ioutdb,3000) MYRANK,nmc,ieof
C@DM        if (ieof .gt. 0) go to 888
C@DM        if (iop(24) .gt. 2) write (ioutdb,3007) MYRANK,nmc,ncnfpx
C@DM        if (idebug(58) .eq. 0) then
C@DM          call postreadcnfh(c,ianslv,rlcslv,rlslt1,nstta,nsvp,nslv,
C@DM     -      nmolec,nmc,incc,MYRANK,nconnfail,inperr,iout)
C@DM          call disperpx(orient,c,crm,texslt,ifailpx)
C@DM        else
C@DMc         Widom output after each structure
C@DM          do icpu=0,NUMNOD-1
C@DM            call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM            if (MYRANK .eq. icpu) then
C@DM              write (iout,*) 'DISPERPX call from MYRANK=',MYRANK
C@DM              call postreadcnfh(c,ianslv,rlcslv,rlslt1,nstta,nsvp,nslv,
C@DM     -          nmolec,nmc,incc,MYRANK,nconnfail,inperr,iout)
C@DM              call disperpx(orient,c,crm,texslt,ifailpx)
C@DM            end if
C@DM          end do
C@DM        end if
C@DM        call MPI_Allreduce(ifailpx,ifailpxsum,1,
C@DM     -    MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,iostat1)
C@DM        call genvol(nranpx,nranpxw,1,1,0,0.0,0,c,crm)
C@DM        if (MYRANK .eq. 0) nmc=nmc_lastcpu
C@DM        call MPI_Bcast(nmc,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        nmcpxo=nmc
C@DM        if (MYRANK .eq. 0) then
C@DM          nmcnew0=nmcnew
C@DM          nrecreadok=nrecread
C@DM          nmcok=nmc
C@DM          nmcsend(1)=nmcnew0
C@DM          nmcsend(2)=nmcnew
C@DM          nmcsend(3)=nmcok
C@DM        end if
C@DM        call MPI_Bcast(nmcsend,3,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
C@DM        if (MYRANK .gt. 0) then
C@DM          nmcnew0=nmcsend(1)
C@DM          nmcnew=nmcsend(2)
C@DM          nmcok=nmcsend(3)
C@DM        end if
C@DM        if (iop(24) .gt. 2) write (ioutdb,3001)
C@DM     -    MYRANK,nmclastr0,nmcnew0,nmcok,nrecreadok,ifailpx
C@DM        if (modrange(nmclastr0,nmcnew0,nsavepx) .eq. 0) then
C@DM          if (iop(24) .gt. 2) write (ioutdb,3004) MYRANK
C@DM          call mpi_pxsave(ichkp,ichkpx)
C@DM        end if
C@DMc!!     Proximity stuff will be implemented later
C@DMC       if (modrange(nmclastr,nmcnew,npxcntin) .eq. 0 .and.
C@DMC     -     iop(142)+iop(146)+iop(148) .gt. 0) then
C@DMCc        Accumulate block averages
C@DMc!!
C@DMC       end if
C@DM        if (iop(24) .gt. 2) write (ioutdb,3002) MYRANK,NUMNOD,
C@DM     -    navgpx,npxmax,nmcok,ifailpxsum
C@DM        if (nmcok+NUMNOD*navgpx .gt. npxmax .or.
C@DM     -        ifailpxsum .gt. 0) then
C@DMc           No more data or error, save .ckp, .pxc & exit (prints in driver)
C@DM        if (iop(24) .gt. 2) write (ioutdb,3005) MYRANK,'ifailpx'
C@DM          go to 888
C@DM        end if
C@DMc       Periodic print
C@DM        if (modrange(nmclastr0,nmcnew0,npxres) .eq. 0 .and.
C@DM     -      nmcnew0 .gt.  nmclastr0 .and. (iop(24) .gt. 0 .or.
C@DM     -      abs(float(nmcok-npxmax))/float(npxmax) .gt. 0.05)) then
C@DMc         Don't print distributions if near the end
C@DM          if (iop(24) .gt. 2) write (ioutdb,3009) MYRANK,'reducepx'
C@DM          call mpi_reducepx
C@DM          if (iop(24) .gt. 2) write (ioutdb,3009) MYRANK,'disfinpx'
C@DM          if (MYRANK .eq. 0) call disfinpx(numrun,volav)
C@DM        end if
C@DM      end do
C@DM888   continue
C@DM      call MPI_BARRIER(MPI_COMM_WORLD,ierr)
C@DM      if (MYRANK .eq. 0) then
C@DM        if (ieof .gt. 0) write (iout,1000) nmcok
C@DM        nmc=nmcok
C@DM        nrecread=nrecreadok
C@DM      end if
C@DM      if (ieof .gt. 0) nwarn=nwarn+1
C@DM      call mpi_pxsave(ichkp,ichkpx)
C@DM      return
C@DM1000  format(' ----- WARNING: unexpected end of history file. Nmc=',i10)
C@DM3000  format(' MPI in mpi_pxscan read failure MYRANK=',i3,' nmc=',i10,
C@DM     -  ' ieof=',i3)
C@DM3001  format(' MPI in mpi_pxscan MYRANK=',i3,' nmclastr0,nmcnew0,',
C@DM     -  'nmcok,nrecreadok=',4i10,' ifailpx=',i3)
C@DM3002  format(' MPI in mpi_pxscan MYRANK,NUMNOD=',2i3,
C@DM     -  ' navgpx,npxmax,nmcok=',3i10,' ifailpxsum=',i3)
C@DM3003  format(' MPI in mpi_pxscan after skip MYRANK=',i3,' ieof',i3)
C@DM3004  format(' MPI in mpi_pxscan MYRANK=',i3,' call reducepx (csave)')
C@DM3005  format(' MPI in mpi_pxscan MYRANK=',i3,' quitting loop(',a,')')
C@DM3006  format(' MPI in mpi_pxscan conf read nmc=',i10,' icpu,ieof=',2i4)
C@DM3007  format(' MPI in mpi_pxscan calling disperpx MYRANK=',i3,' nmc=',
C@DM     -  i10,' ncnfpx=',i9)
C@DM3008  format(' MPI in mpi_pxscan start MYRANK=',i3,' npxmax,navgpx,',
C@DM     -  'nmcpxdsc=',3i10,' nsvp,incc=',i2,i4,' nmc,ncnfpx=',i10,i6)
C@DM3009  format(' MPI in mpi_pxscan MYRANK=',i3,' Call ',a,' (for print)')
C@DM      end
      function modrange(imin,imax,modarg)
c#    MMC routine 446 lstmod: 05/05/03
c*****Find out if there is an integer between imin and imax that is
c     congruent with modarg mod 0
      modrange=1
      if (imax-imin .ge. modarg .or.
     -  mod(imin,modarg)+(imax-imin) .ge. modarg) modrange=0
      return
      end
      subroutine mpi_pxsave(ichkp,ichkpx)
c#    MMC routine 446/a lstmod: 12/06/06
c*****Save state on a parallel environment for analysis
C@DM      include "mpif.h"
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      call mpi_reducepx
      if (MYRANK .eq. 0) then
        call csave(ichkp,1,iskipfail,1)
        call csavepx(ichkpx,0,iskipfail,6)
      else
        call mpi_resetpx
      end if
C@DM      call MPI_Bcast(iskipfail,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
      if (iskipfail .gt. 0) call datprt(2)
      return
      end
      subroutine filterslv(iout,inperr,nwwarn,c,qslt,ianslt,igrslt,
     -  labslt,nslt,ianslv,nslv,numsolv,nmolec,natoms,crm,rslv,ifilt,
     -  nfilt,isltr,nnoffset,minmem,cvlim,ihead,iverb,nmc,xyzmin,
     -  xyzmax,center,rcentmin,rcentmax,cplpmin,cplpmax,cplpar,nmolmin,
     -  nmolmax,nsltsegdel,isltdellim,nslvsegdel,islvdellim,leavemol,
     -  isltfilt,esuvmin,esuvmax,ic00,irecenter,iwriteorg,origfile,
     -  lorigfile,nafltrange,iafltrange,islvkeep,indexfilt,nsltcv,
     -  nsltcvfirst,rcvmax,cvsave)
c#    MMC routine 447 lstmod: 08/07/13
c*****Filter solvents
      character*80 origfile
      character*4 labslt
      dimension c(3,#NA),qslt(#ST),ianslt(#ST),igrslt(#ST),
     -  labslt(2,#ST),ianslv(#SV),crm(3,#MO),islvkeep(#MO),
     -  indexfilt(#MO),iafltrange(2,50),rcvmax(#MO),cvsave(#MO)
      dimension isltdellim(2,250),islvdellim(2,250)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /gather/ itemp(#UV),nnloop(#UV),ifirst(#UV),
     -  ilast(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  iclst(#UV),nneigs(#UV),nnhslt(#UV),ixorig(#UV),
     -  ineigs(12,#UV)
      common /pbcdat/ iused(#UV),
     -  riijjv(#UV),zv(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV)
      character*7 inoutlab
      common /inoutlabel/ inoutlab(2)
      common /option/ iop(200),idebug(200)
      common /worksp/ isltkeep(#NA),iproxi(#UV),nnslt(#UV),
     -  l4(#UV)
      dimension xyzmin(3),xyzmax(3),center(3),d0(3)
c     print *,'FILTERSLV ifilt=',ifilt
      if (inperr .gt. 0) then
        write (iout,1027)
        call datprt(-1)
      end if
      numsolv=0
      ninsd=0
      if (nmolec .eq. 1 .and.
     -  isltfilt .eq. 0 .and. nsltsegdel .eq. 0) then
        if (ihead .eq. 1) write (iout,1019)
        return
      end if
      if (ihead .eq. 1) then
        if (ifilt .le. nfilt) then
          if (ifilt .lt. 4 .or. ifilt .gt. 6) write (iout,1000) rslv
          if (ifilt .lt. 4) then
            if (nnoffset .ne. 0 .and.(ifilt .eq. 2 .or. ifilt  .eq.  3))
     -        write (iout,1007) nnoffset
            if (minmem  .eq. 0) write (iout,1008)
            if (minmem  .gt. 0) write (iout,1009) minmem
            if (ifilt .eq. 1) write (iout,1001)
            if (ifilt .eq. 2) write (iout,1002)
            if (ifilt .eq. 3) write (iout,1003)
          end if
          if (ifilt .ge. 4 .and. ifilt .le. 6) then
c           CV filtering
            if (cvlim .gt. 0) then
              if (ifilt .eq. 4 .or. ifilt .eq. 5)
     -          write (iout,1004) '> ',cvlim,inoutlab(1)
              if (ifilt .eq. 6) write (iout,1022) leavemol,'innermost'
            else
              if (ifilt .eq. 4 .or. ifilt .eq. 5)
     -          write (iout,1004) '< ',-cvlim,inoutlab(2)
              if (ifilt .eq. 6) write (iout,1022) leavemol,'outermost'
            end if
            if (ifilt .eq. 5) write (iout,1020)
            if (nsltcv .lt. nslt .or. nsltcvfirst .gt. 1)
     -        write (iout,1026) nsltcvfirst,nsltcv,nslt
          end if
          if (ifilt .ge. 7 .and. ifilt .le. 9) then
            write (iout,1005) (ifilt-6)
          end if
          if (nafltrange .gt. 0) then
            write (iout,1024)
     -        (' ',(iafltrange(k,i),k=1,2),i=1,nafltrange)
          end if
          if (ifilt .eq. nfilt) write (iout,1022) leavemol,'closest'
          if (ifilt .eq. 6 .or. ifilt .eq. nfilt) then
            if (leavemol .gt. nmolec-1) then
              write (iout,1025) leavemol,nmolec-1
              nwwarn=nwwarn+1
            end if
          end if
          if (isltr .eq. 1) write (iout,6210)
          if (isltr .eq. 2) write (iout,6220)
          if (isltr .eq. 3) write (iout,6230)
        else if (ifilt .eq. nfilt+1) then
          write (iout,1010) (xyzmin(k),xyzmax(k),k=1,3),
     -      (center(k),k=1,3),rcentmin,rcentmax,
     -      cplpmin,cplpmax,nmolmin-1,nmolmax-1
          if (isltfilt .eq. 1) write (iout,1012)
        else if (ifilt .eq. nfilt+2) then
          write (iout,1013)
          if (nsltsegdel .gt. 0) write (iout,1014)
     -      ('[',(isltdellim(k,i),k=1,2),i=1,nsltsegdel)
          if (nslvsegdel .gt. 0) write (iout,1015)
     -      ('[',(islvdellim(k,i),k=1,2),i=1,nslvsegdel)
        else if (ifilt .eq. nfilt+3) then
          write (iout,1016) esuvmin,esuvmax
        end if
        if (irecenter .eq. 1) write (iout,1023)
        if (iwriteorg .gt. 0) write (iout,1029) origfile(1:lorigfile)
      end if
      if (irecenter .eq. 1) then
        call systemcent(crm,c,zv,d0,nslt,nmolec,iop(5),nslv,
     -        ianslt,ianslv,ic00,1)
      end if
      call indexit(indexfilt,1,nmolec-1,0)
      nsolvorig=nmolec-1
c     Calculate solvent com's
      do im=2,nmolec
        call cofms(c(1,nslt+(im-2)*nslv+1),crm(1,im),ianslv,1,nslv,1,wx)
      end do
c     iused will be 1 for solvent considered bulk
      call zeroiti(iused,0,nmolec)
      call zeroiti(islvkeep,0,nmolec)
      nr=(ifilt-6)*2
c     Solute neighbor count may also be needed
      if (ifilt .le. 3)
     -  call sltrad(rsphi,ianslt,nslt,rslv,1,isltr-1,1.0,1.0,2)
      if (ifilt .le. 3) then
        if (ifilt .gt. 1) then
          do im=2,nmolec
            nnslt(im)=0
            nnhslt(im)=0
            do ia=1,nslt
              rr=arrdist(c(1,ia),crm(1,im))
              if (rr .lt. rsphi(ia)) then
                nnslt(im)=nnslt(im)+1
                if (ianslt(ia) .eq. 1) nnhslt(im)=nnhslt(im)+1
              end if
            end do
c           For too many hydrogen neighbors, reduce count
            if (nnhslt(im) .gt. 2 .and. isltr .ne. 2)
     -        nnslt(im)=nnslt(im)-(nnhslt(im)-1)/2
          end do
        end if
c       To determine inside solvents, we need connectivity info
        do im=1,nmolec
          nneigs(im)=0
        end do
        do i=3,nmolec
          do j=2,i-1
            rr=arrdist(crm(1,i),crm(1,j))
            if (rr .lt. (2.0*rslv)**2) then
              if (nneigs(i) .lt. 12 .and. nneigs(j) .lt.  12) then
                nneigs(i)=nneigs(i)+1
                ineigs(nneigs(i),i)=j
                nneigs(j)=nneigs(j)+1
                ineigs(nneigs(j),j)=i
              end if
            end if
          end do
        end do
        call clstrs(ineigs,nneigs,nnloop,1,nmolec,iclst,ifirst,ilast,
     -    0,nofcls,iused,iout,inperr,nww,0,#MO,#MO,12,2,1)
        if (minmem .eq. 0) then
c        Find the largest cluster (considered to be the bulk solvent)
         maxmem=0
         imaxmem=0
         do ic=1,nofcls
           if (ilast(ic)-ifirst(ic) .ge. maxmem) then
             maxmem=ilast(ic)-ifirst(ic)
             imaxmem=ic
           end if
         end do
         do im=ifirst(imaxmem),ilast(imaxmem)
           iused(iclst(im))=1
         end do
        else
c         Consider all cluster to be bulk that have at least minmem members
          do ic=1,nofcls
            if (ilast(ic)-ifirst(ic) .ge. minmem) then
              do im=ifirst(ic),ilast(ic)
                iused(iclst(im))=1
              end do
            end if
          end do
        end if
        if (ifilt .eq. 1 .or. ifilt .eq. 3) then
c         Keep the inside ones for sure
          do im=1,nmolec
            islvkeep(im)=1-iused(im)
          end do
        end if
        if (ifilt .eq. 2 .or. ifilt .eq. 3) then
          if (ifilt .eq. 2) then
            do im=1,nmolec
              islvkeep(im)=0
            end do
          end if
c         Add invaginations for sure
          do im=1,nmolec
            if (iused(im) .eq. 1) then
              if (nneigs(im) .le. nnslt(im)-nnoffset) islvkeep(im)=1
            end if
          end do
        end if
        ninsd=0
        ninvag=0
        do im=2,nmolec
          if (islvkeep(im) .eq. 1) then
            if (iused(im) .eq. 1) ninvag=ninvag+1
            if (iused(im) .eq. 0) ninsd=ninsd+1
          end if
        end do
        if (ifilt .gt. 1) then
          if (iop(24) .ge. 3) then
c           Print neighborhood information
            nwr=0
            do im=2,nmolec
              if (islvkeep(im) .eq. 1) then
                nwr=nwr+1
                write (iout,1717) im,nwr,nneigs(im),nnslt(im),nnhslt(im)
              end if
            end do
          end if
        end if
      end if
      if (ifilt .ge. 4 .and. ifilt .le. 6) then
c       Filter based on circular variance
c       Mark atoms near the slt
        call sltrad(rsphi,ianslt,nslt,rslv,1,isltr-1,1.0,1.0,2)
        nohyd=0
        if (ifilt .eq. 5) nohyd=1
        call circularvar(c,ianslt,crm,nsltcvfirst,nsltcv,2,nmolec,rsphi,
     -    rcvmax,cv1,rslv,nohyd,idebug(135),iout)
        cvsum=0.0
        cvmin=1000.0
        cvmax=0.0
        nkeep=0
        do im=2,nmolec
          cvsum=cvsum+cv1(im)
          cvsave(im)=cv1(im)
          if (cv1(im) .lt. cvmin) cvmin=cv1(im)
          if (cv1(im) .gt. cvmax) cvmax=cv1(im)
          if (cvlim .lt. 0) cv1(im)=1.0-cv1(im)
        end do
        if (cvlim .lt. 0.0) cvlim=-cvlim
        if (iverb .gt. 0) then
          cvavg=cvsum/(nmolec-1)
          write (iout,1018) nmc,' All solvents ',cvavg,cvmin,cvmax
        end if
        cvsum=0.0
        cvmin=1000.0
        cvmax=0.0
        if (ifilt .lt. 6) then
          do im=2,nmolec
            if (cvlim .gt. 0 .and. cv1(im) .gt. cvlim) then
              islvkeep(im)=1
              cvsum=cvsum+cv1(im)
              if (cv1(im) .lt. cvmin) cvmin=cv1(im)
              if (cv1(im) .gt. cvmax) cvmax=cv1(im)
              nkeep=nkeep+1
            end if
          end do
        else
c         Top leavemol inner/outermost kept
          call indexit(iused,1,nmolec,0)
          cv1(1)=0.0
          call mrgsrt(iout,iused,cv1,nmolec,nnloop,l4,itemp,cv2,nmolec)
          do im=max0(2,nmolec-leavemol+1),nmolec
            islvkeep(iused(im))=1
            cvsum=cvsum+cv1(im)
            if (cv1(im) .lt. cvmin) cvmin=cv1(im)
            if (cv1(im) .gt. cvmax) cvmax=cv1(im)
          end do
          nkeep=nkeep+min0(leavemol,nmolec-1)
        end if
        if (nkeep .gt. 0) then
          cvavg=cvsum/nkeep
          write (iout,1018) nmc,' Filtered set ',cvavg,cvmin,cvmax,' ',
     -      nkeep
        end if
      end if
      if (ifilt .le. 6) then
        if (idebug(163) .gt. 1) write (iout,7711) 'A','islvkeep',
     -    nmc,nmolec,(islvkeep(is),is=2,nmolec)
        call discardmol(numsolv,nmolec,natoms,nslt,nslv,c,crm,
     -    1,rcvmax,cvsave,islvkeep,indexfilt,0,#NA,#MO)
c       Set nr to filter out possible 'corner' waters left over
        if (idebug(163) .gt. 0) write (iout,7711) 'A','indexfilt',
     -    nmc,nmolec,(indexfilt(is),is=1,nmolec-1)
c       Set nr to filter out possible 'corner' waters left over
        if (ifilt .lt. 6) nr=3
      end if
      nmoleci=nmolec
      if (ifilt .le. nfilt) then
        call findprox(c,crm,nmolec,edgexa,iproxi,isltkeep,l4,1,1)
        if (ifilt .lt. nfilt .and. ifilt .ne. 6) then
c         Filter based on solvation shells
          call zeroiti(isltkeep,0,nslt)
          call sltrad(rsphi,ianslt,nslt,rslv,nr,isltr-1,1.0,1.0,2)
c         Mark atoms near the slt
          call zeroiti(islvkeep,0,nmolec)
          do im=2,nmolec
            ia=iproxi(im)
            if (arrdist(c(1,ia),crm(1,im)) .lt. rsphi(ia)) then
              islvkeep(im)=1
            end if
          end do
        else if (ifilt .eq. 6) then
          do im=2,nmolec
            islvkeep(im)=1
          end do
        else if (ifilt .eq. nfilt) then
c         Filter based on proximity to end up with leavemol solvents
          rmins(1)=1.e+5
          call indexit(iused,1,nmolec,0)
          call mrgsrt(iout,iused,rmins,nmolec,nnloop,l4,itemp,cv2,
     -      nmolec)
          do i=1,min0(leavemol,nmolec-1)
            islvkeep(iused(i))=1
          end do
        end if
      else if (ifilt .eq. nfilt+1) then
c       Filter based on position in the cell
        if (nmolec .ge. nmolmin .and. nmolec .le. nmolmax .and.
     -      cplpar .ge. cplpmin .and. cplpar .le. cplpmax) then
c         nmolec and cplpar filter is done
          r2max=rcentmax**2
          r2min=rcentmin**2
          nleft=1
          do im=2,nmolec
            call filtgeom(crm(1,im),xyzmin,xyzmax,center,r2min,r2max,
     -        islvkeep(im))
            if (islvkeep(im) .eq. 1) nleft=nleft+1
          end do
          if (isltfilt .eq. 1) then
            do ia=1,nslt
              call filtgeom(c(1,ia),xyzmin,xyzmax,center,r2min,r2max,
     -          isltkeep(ia))
            end do
          end if
        else if (iverb .gt. 0) then
          write (iout,1011) nmc
        end if
      else if (ifilt .eq. nfilt+2) then
c       Delete solute atoms and solvent molecules
        if (nsltsegdel .gt. 0) then
c         Solute segment deletion
          do ia=1,natoms
            isltkeep(ia)=1
          end do
          do is=1,nsltsegdel
            do ia=isltdellim(1,is),isltdellim(2,is)
              isltkeep(ia)=0
            end do
          end do
        end if
        do im=1,nmolec
          islvkeep(im)=1
        end do
        if (nslvsegdel .gt. 0) then
c         Solvent segment deletion
          do is=1,nslvsegdel
            do i=islvdellim(1,is),islvdellim(2,is)
              islvkeep(i+1)=0
            end do
          end do
        end if
      else if (ifilt .eq. nfilt+3) then
c       Delete solvents by solute energy
        islvkeep(1)=1
        do im=2,nmolec
          islvkeep(im)=1
          estsv(im)=engslt(im,riijj,riijj0,rij0,isprox,idistmv,idistid,
     -      c,crm(1,im),crm)
          if (estsv(im) .lt. esuvmin .or. estsv(im) .gt. esuvmax)
     -      islvkeep(im)=0
        end do
      end if
      if (nsltsegdel .gt. 0 .or. isltfilt .eq. 1)
     -  call discardslt(c,natoms,nslt,qslt,ianslt,igrslt,labslt,
     -    isltkeep)
      if (idebug(163) .gt. 1) write (iout,7711) 'B','islvkeep',
     -  nmc,nmolec,(islvkeep(is),is=2,nmolec)
      call discardmol(numsolv,nmolec,natoms,nslt,nslv,c,crm,
     -  1,rcvmax,cvsave,islvkeep,indexfilt,0,#NA,#MO)
      if (idebug(163) .gt. 0) write (iout,7711) 'B','indexfilt',
     -  nmc,nmolec,(indexfilt(is),is=1,nmolec-1)
      ninsd=ninsd-(nmoleci-nmolec)
      if (iwriteorg .gt. 0) then
        write (iwriteorg) nmc,nmolec,nsolvorig
        write (iwriteorg) (indexfilt(im),im=1,nmolec-1)
      end if
      if (iverb .gt. 0) then
        if (ifilt .le. 2) write (iout,1017) ninsd
        if (ifilt .eq. 2 .or. ifilt .eq. 3) write (iout,1006) ninvag
        write (iout,1021) nmc,nmolec,natoms,nslt
        if (nmolec .gt. 1 .and. iverb .gt. 1)
     -    write (iout,1028) (im,indexfilt(im),im=1,nmolec-1)
      end if
      return
1000  format(' Filtering solvents assuming solvent radius=',f6.2,' A')
1001  format(' Keeping only solvents inside the solute')
1002  format(' Keeping only solvents inside or in invaginations ',
     -  'of the solute')
1003  format(' Keeping only solvents in invaginations of the solute')
1004  format(' Keeping only solvents with circular variance ',a2,f6.3,
     -  ' (',a,')')
1005  format(' Keeping ',i1,' solvent layer(s) around the solute')
1006  format(' Number of solvents found in invaginations of the ',
     -   'solute=',i4)
1007  format(' Solute neighbour number is decreased by ',i1,'  for ',
     -   'determining solvents in invaginations')
1008  format(' The largest cluster will be considered the bulk')
1009  format(' Clusters with at least ',i3,' members  will be',
     -  ' considered bulk')
1010  format(' Filtering solvents based on their position in the cell',/
     -  ' Coordinate limits: ',f9.2,' < x < ',f9.2,' , ',
     -  f9.2,' < y < ',f9.2,' , ',f9.2,' < z < ',f9.2,/,
     -  ' Radial limit center=',3f10.3,' Minimum radius=',f9.2,
     -  ' Maximum radius=',f9.2,/,
     -  ' Coupling parameter limits (if applicable)=',2f9.5,/,
     -  ' Number of molecule limits (if applicable)=',2i9)
1011  format(' Configuration at Nmc=',i10,' dropped')
1012  format(' Geometric filtering will also be applied to the solute ',
     -  'atoms')
1013  format(' Filtering solute and solvent atoms by segments')
1014  format(' Deleting solute atoms in the range(s)',
     -  10(1x,a,i5,',',i5,']'))
1015  format(' Deleting solvent molecules in the range(s)',
     -  10(1x,a,i5,',',i5,']'))
1016  format(' Filtering solvents with solute energy in the range ',
     -  '[',f8.3,',',f8.3,'] kcal/mol')
1017  format(' Number of solvents found inside the solute=',i4)
1018  format(' Nmc=',i10,a,'circular variance mean=',f8.5,
     -  ' range: [',f8.5,',',f8.5,']',a,'number of solvents left=',i6)
1019  format(' Configuration contains no solvent - nothing to filter')
1020  format(' Hydrogens will be ignored for circular variance ',
     -  'calculation')
1021  format(' After filtering, the configuration at Nmc=',i10,
     -  ' contains',i6,' molecules,',i8,' atoms, including',i7,
     -  ' solute atoms')
1022  format(' Filtering will leave the ',i6,' solvent molecules that ',
     -  'are ',a,' to the solute')
1023  format(' System will be recentered to the solute COM')
1024  format(' Solvent shell coverage will be restricted to solute ',
     -  'atom ranges ',/,5(a,'[',i7,'-',i7,']'))
1025  format(' ----- WARNING: Number of solvents to leave (',i6,
     -  ') exceeds current number of solvents (',i6,')')
1026  format(' Only solute atoms',i6,' - ',i6,' will be used for ',
     -  'circular variance calculation (instead of all',i6,')')
1027  format(' Aborting - input was not error free')
1028  format(' Solvent',i6,' - original solvent number=',i5)
1029  format(' Original solvent numbers will be written for each frame',
     -  ' to file ',a)
1717  format(' im,i=',2i5,' nneigs=',i3,' nnslt=',i3,' nnhslt=',i3)
6210  format(' Solute atom radii are based on standard Van der ',
     -  'Waals radii')
6220  format(' Solute atom radii are based on Lennard-Jones sigmas')
6230  format(' Solute atom radii are based on Lennard-Jones sigmas',
     -  ' minimum sigma for hydrogens set to one')
7711      format(1x,a,1x,a,' nmc=',i9,' nmolec=',i6,/(20i6))
      end
      subroutine circularvar(cref,ianref,c,nref_first,nref,nfirst,n,
     -  rsphi,rprox,cv,r,nohyd,iprt,iout)
c#    MMC routine 448 lstmod: 08/29/11
c*****Calculate circular variance
      dimension cref(3,nref),ianref(nref),c(3,n),rsphi(nref),rprox(n),
     -  cv(n)
      real*8 rxyzsum,rsum
      dimension rxyzsum(3),xyz(3)
      if (iprt .gt. 0) write (iout,1000) r
      do im=nfirst,n
        rsum=0.d0
        call zeroitd(rxyzsum,3)
        d2min=100000.0
        do ia=nref_first,nref
          if (nohyd .eq. 0 .or. ianref(ia) .ne. 1) then
            call arrdiff(xyz,cref(1,ia),c(1,im),3)
            rr2=xyz(1)**2+xyz(2)**2+xyz(3)**2
            if (d2min .gt. rr2) d2min=rr2
            if (rr2 .lt. rsphi(ia)) then
              rsum=rsum+sqrt(rr2)
              do k=1,3
                rxyzsum(k)=rxyzsum(k)+xyz(k)
              end do
            end if
          end if
        end do
        cv(im)=0.0
        if (rsum .gt. 0.d0) cv(im)=
     -    1.0-dsqrt(rxyzsum(1)**2+rxyzsum(2)**2+rxyzsum(3)**2)/rsum
        rprox(im)=sqrt(d2min)
        if (iprt .gt. 0) write (iout,1001) im,(c(k,im),k=1,3),cv(im)
      end do
      return
1000  format(' Calculating circular variance with radius=',f7.3,' A')
1001  format(i6,' c=',3f10.4,' cv=',f8.5)
      end
      subroutine filtgeom(c,xyzmin,xyzmax,center,r2min,r2max,keepit)
c#    MMC routine 449 lstmod: 12/03/01
c*****Perform geometric filtering of an atom
      dimension c(3),xyzmin(3),xyzmax(3),center(3)
      keepit=1
      r2im=0.0
      do k=1,3
        if (c(k) .lt. xyzmin(k)) keepit=0
        if (c(k) .gt. xyzmax(k)) keepit=0
        r2im=r2im+(c(k)-center(k))**2
      end do
      if (r2im .lt. r2min .or. r2im .gt. r2max) keepit=0
      return
      end
      subroutine filterframes(iout,etotmin,etotmax,nmolmin,nmolmax,c,
     -  keynocalc,nmolec,nmc,nmcwrite,iskipframe,natoms)
c#    MMC routine 449/a lstmod: 05/02/08
      dimension c(3,natoms)
      common /polr/ crm(3,#MO),orientsltm(3,3,#MM),
     -  crm0(3,#MO),ch(3),phi
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      real*8 dnrww,dnrslt,dngwws
      common /rdial/ dnrww(500),dnrslt(500),dngwws,ri,rri,nd,nfslww,
     -  nfsslt,mndslt,mxdslt,mndslv,mxdslv,nssmin,nssmax,mxcslv
      real*8 dkcrslt,dkcrslv,dnesmww,dnesslt,dnslvpe,dnsltpe,dndipc,
     -  dndipmom
      common /quasi/ dkcrslt(30),dkcrslv(20),dnesmww(100),dnesslt(100),
     -  dnslvpe(100),dnsltpe(100),dndipc(180),dndipmom(3,180),dipmomabs,
     -  qslvdip(#SV),empslv,egrslv,empslt,egrslt,emnslt,egpslt,emnslv,
     -  egpslv,exyzabc(3,3),ncor(#MO),lstmvd(#MO),nrejis(#MO),
     -  ksltmn,ncor1ok
      real*8 tesi,frctot,trqtot,tss12,tss6,tss1
      common /eftslvsum/ tesi(#MO),frctot(3,#MO),trqtot(3,#MO),
     -  tss12,tss6,tss1,tsind(3,#MO),frcslt(3,#MO),
     -  trtslt(3,#MO),trvslt(3,#MO),texslt(#MO),
     -  vrcslt(3,#MO)
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
      common /distances/ ipsdist,nslvds(#MO),nslvdsid(#MO),
     -  niso(#MO),nslvdsidn(#MO),ipxn(#MO),ipxo(#MO),
     -  rcomiso(#MO),rcomisn(#MO),rijois(#MO),rijpso(#MO),
     -  rijpsn(#MO),rphs0iso(#MS),rphs0isn(#MS)
      common /option/ iop(200),idebug(200)
      real*8 esmslv
      character*4 skip(2)
      data skip /'keep','skip'/
c     Filter trajectory frames by energy or # of solvents
      if (nmc .le. 1) then
        write (iout,1000) etotmin,etotmax
        if (nmolmin .gt. 1 .or. nmolmax .lt. #MO)
     -    write (iout,1001) nmolmin-1,nmolmax-1
      end if
      if (keynocalc .eq. 2) then
c       Recalculate total energy
        call eism0(1,0,noverl,nfsslt,nfslww,ksltmn,ncor,
     -    tesi,frctot,trqtot,texslt,vrcslt,frcslt,trtslt,trvslt,
     -    tss12,tss6,tss1,tsind,rcomiso,rijpso,rphs0iso,ipxo,nslvds,
     -    nslvdsid,gbuupd,gbuupt,esmslv,c,crm,1)
      end  if
      if (etoto .lt. etotmin .or. etoto .gt. etotmax .or.
     -    nmolec .lt. nmolmin .or. nmolec .gt. nmolmax) then
        iskipframe=1
      else
        iskipframe=0
      end if
      if (idebug(143) .gt. 0)
     -  write (iout,1002) nmc,nmcwrite,etoto,nmolec,skip(iskipframe+1)
      return
1000  format(/,' Filtering trajectory frames',/,
     -  ' Allowed total energy range: [',e12.5,',',e12.5,'] kcal/mol')
1001  format(' Range of allowed number of solvents: [',i8,',',i8,']')
1002  format(' FILTERFRAME nmc,nmcwrite=',2i10,' e=',e12.5,
     -  ' nmolec=',i7,1x,a)
      end
      subroutine allsolv(ihist,ifilt,infopx,nmcskip,nmcfreq,nconf,
     -  file,namlenf,filename1,namlen1,nhstverst,inpt,iout,
     -  nwarn,nwwarn,inperr,nconnfail,c,icftype,iskip1,nrecread,uusfac)
c#    MMC routine 450 lstmod: 04/14/10
c*****Gather all solvents into a single configuration
      character*80 file,filename1
      character*4 iatnam
      character*6 pflab
      dimension c(3,#NA)
      real*8 uusfac
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*80 ident
      common /title/ nlident,ident(2)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
      character*1 charlist
      common /characters/ charlist(52)
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),ccii(3,#UV),zvv(3,#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /warncount/ ichsegwarn,ipdbcherr(11)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
c     This array is always integer*2, independent of the C@ I2 lines
      integer*2 ixpxi2(#MO)
      character*1 chainid
      character*4 name,name1,atnam,segid,segidprev
      data igrslts /0/,iginc /0/
      if (nmolec .lt. 2) then
        nwarn=nwarn+1
        write (iout,2012)
        return
      end if
      if (iop(90) .eq. 0 .and. icftype .eq. 18 .and.
     -    ichsegwarn .eq. 0) then
        ichsegwarn=1
        nwarn=nwarn+1
        write (iout,2010)
      end if
      segid='    '
      segidprev=segid
      call trnsfr(cgs,c,3*natoms)
      call fileopen(file,namlenf,filename1,namlen1,21,0,
     -  numrun,nhstverst,0,0,iop(24),iversout,iout,itemp,0)
      if (nsltpardis .gt. 0) call fileopen(file,namlenf,filename1,
     -  namlen1,22,0,numrun,nhstverst+1,0,0,iop(24),iversout,iout,
     -  itemp1,0)
      write (iout,2000) nmcfreq
      if (icftype .eq. 11) write (iout,2011)
     -   'Insight free format (sxyzqr)'
      if (icftype .eq. 15) write (iout,2011) 'PDB'
      if (icftype .eq. 18) write (iout,2011) 'Charmm CRD'
      if (nmcskip .gt. 0) write (iout,2001) nmcskip
      ieof=0
      nconf=0
      nsltpri=nstta-istf+1
      nslvp=0
      igrsltm=0
      igrsltw=0
      nmolslv=0
      maxat=99999
      maxres=99999
      if (icftype .eq. 15) maxres=9999
      esvmin=+10000.
      esvmax=-10000.
      if (infopx .gt. 0) then
        rewind infopx
        call zeroit(rmins,nmolec)
        call zeroit(estsv,nmolec)
      end if
      ncnfpxread=0
      if (iskip1 .eq. 0) nmc=0
      do iii=1,nmcmax
        if (iii .gt. 1 .or. iskip1 .eq. 0) then
          nmcprev=nmc
          call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -      nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,
     -      incrun,ia0,c,0,nrecread,uusfac,0,nsvp,0)
        else
          nmcprev=0
        end if
        if (ieof .gt. 0) go to 999
        if (iop(163) .gt. 0 .and. infopx .gt. 0) then
          if (iop(163) .eq. 1) then
            read (infopx,1004,end=888) nmolec1,nmcread,ncnfpxread,
     -        (iww,iproxi,labslt(2,iproxi),igrst,
     -        labslt(1,iproxi),rmins(iw),estsv(iw),iw=2,nmolec)
          else
            if (iop(163) .eq. 2) then
              read (infopx,end=888) nmolec1,nmcread,ncnfpxread,
     -          (ixpxi2(iw),rmins(iw),estsv(iw),iw=2,nmolec)
            else
              read (infopx,end=888) nmolec1,nmcread,ncnfpxread,
     -          (ixpxi2(iw),rmins(iw),iw=2,nmolec)
            end if
          end if
          do iw=2,nmolec
            if (esvmin .gt. estsv(iw)) esvmin=estsv(iw)
            if (esvmax .lt. estsv(iw)) esvmax=estsv(iw)
          end do
          if (idebug(39) .gt. 0) write (iout,1010)
     -     iii,(iw,rmins(iw),estsv(iw),iw=2,nmolec)
          if (nmolec1 .ne. nmolec-1) then
            write (iout,2006) nmolec1+1,nmolec,nmc,nmcread
            nwwarn=nwwarn+1
            iop(163)=0
          end if
          go to 880
888       write (iout,2007) ncnfpxread
          inperr=inperr+1
          iop(163)=0
880       if (iop(163) .eq. 0) write (iout,2008)
        end if
        if (nmc .ge. nmcskip+1) then
          if (modrange(nmcprev,nmc,nmcfreq) .eq. 0) then
            nconf=nconf+1
            if (nconf .eq. 1) then
c             Put solute at the beginning
              igrslt0=igrslt(istf)-1
              do ia=istf,nstta
                if (icftype .eq. 11) then
                  write (itemp,1001) iatnam(ianprt(ianslt(ia))),
     -              (c(k,ia),k=1,3),(igrslt(ia)-igrslt0),qslt(ia)
                else
                  write (itemp,1002) (labslt(k,ia),k=1,2),
     -              (c(k,ia),k=1,3),(igrslt(ia)-igrslt0),qslt(ia)
                end if
              end do
              ngrfx=igrslt(nstta)-igrslt0
            end if
            if (nsltpardis .gt. 0) then
c             Add moving solute molecule centers
              igrsltm=igrsltm+1
              do im=movmolf,movmoll
                ia=molcnt(im)
                if (icftype .eq. 11) then
                  write (itemp1,1001) iatnam(ianprt(ianslt(ia))),
     -              (c(k,ia),k=1,3),igrsltm,qslt(ia)
                else
                  write (itemp1,1002) (labslt(k,ia),k=1,2),
     -              (c(k,ia),k=1,3),igrsltm,qslt(ia)
                end if
              end do
            end if
            if (nmolec .gt. 1) then
c             Add representative solvent atom as a He atom
              nslvp=(natoms-nstta)/(nmolec-1)
              igrsltw=igrsltw+1
              do iw=2,nmolec
                write (itemp,1001) iatnam(2),
     -            (c(k,nstta+(iw-2)*nslvp+islvrep),k=1,3),igrsltw,0.0,
     -            estsv(iw)
              end do
              nmolslv=nmolslv+(nmolec-1)
            end if
          end if
        end if
      end do
999   write (iout,2002) nconf,nslvp
      if (iop(163) .gt. 0 .and. infopx .gt. 0)
     -   write (iout,2009) esvmin,esvmax
      rewind itemp
      if (nsltpardis .gt. 0) rewind itemp1
      if (icftype .eq. 11) then
c       Insight free format
        write (ifilt,1000)
     -    (nsltpri+igrsltm*(movmoll-movmolf+1)+igrsltw*(nmolec-1))
        do ia=istf,nstta
          read (itemp,1001) name,x,y,z,ig,q
          write (ifilt,1001) name,x,y,z,ig,q
        end do
        do ia=1,igrsltm*(movmoll-movmolf+1)
          read (itemp1,1001) name,x,y,z,ig,q
          call pdblim('Ins.',ngrfx+ig,igw,maxres,'residue',6,nwwarn,
     -      iout)
          write (ifilt,1001) name,x,y,z,igw,q
        end do
        do im=1,nmolslv
          read (itemp,1001) name,x,y,z,ig,q,estv
          call pdblim('Ins.',ngrfx+igrsltm+ig,igw,maxres,'residue',
     -      6,nwwarn,iout)
          write (ifilt,1001) name,x,y,z,igw,q
        end do
      else if (icftype .eq. 15) then
c       PDB format
        do ic=1,nlident
          write (ifilt,1008) 'REMARK',ident(ic)(1:73)
        end do
        do ia=istf,nstta
          read (itemp,1002) name,name1,x,y,z,ig,q
          if (name(1:1) .eq. ' ') name(1:3)=name(2:4)
          chainid=charlist(min0(iamolslt(ia),22))
          call adjustpdbname(name1,atnam,iop(98))
          write (ifilt,1003) ia,atnam,name(1:3),chainid,ig,x,y,z,q
        end do
        do im=1,igrsltm*(movmoll-movmolf+1)
          read (itemp1,1002) name,name1,x,y,z,ig,q
          if (name(1:1) .eq. ' ') name(1:3)=name(2:4)
          call pdblim('PDB ',nstta+im,imw,maxres,'atom',1,nwwarn,iout)
          call pdblim('PDB ',ngrfx+ig,igw,maxres,'residue',2,nwwarn,
     -      iout)
          call adjustpdbname(name1,atnam,iop(98))
          write (ifilt,1003) imw,atnam,name(1:3),'X',igw,x,y,z,q
        end do
        write (ifilt,1110) 'TER'
        igrslts=ig
        do im=1,nmolslv
          read (itemp,1001) name,x,y,z,ig,q,estv
          call pdblim('PDB ',nstta+igrsltm*(movmoll-movmolf+1)+im,imw,
     -      maxres,'atom',1,nwwarn,iout)
          call pdblim('PDB ',ngrfx+igrsltm+ig,igw,maxres,'residue',
     -      2,nwwarn,iout)
          call adjustpdbname(name,atnam,iop(98))
          write (ifilt,1003) imw,atnam,'SLV','W',igw,x,y,z,q,estv
        end do
        write (ifilt,1110) 'END'
      else
c       Charmm CRD
        do ic=1,nlident
          write (ifilt,1008) '*',ident(ic)(1:73)
        end do
        write (ifilt,1008) '* ='
        write (ifilt,1005)
     -    (nsltpri+igrsltm*(movmoll-movmolf+1)+igrsltw*(nmolec-1))
        do ia=istf,nstta
          read (itemp,1002) name,name1,x,y,z,ig,q
          if (ia .eq. istf) then
            iginc=ig-1
          end if
          if (name(1:1) .eq. ' ') name(1:3)=name(2:4)
          segid(1:1)=charlist(min0(iamolslt(ia),22))
          if (iop(90) .gt. 0) segid=fcglab(ia)(5:8)
          if (segid .ne. segidprev) iginc=ig-1
          call pdblim('CHR ',ig-iginc,igsegw,9999,'residueid',5,nwwarn,
     -      iout)
          write (ifilt,1006) ia,ig,name,name1,x,y,z,segid,igsegw,q
          segidprev=segid
        end do
        igseg=0
        do im=1,igrsltm*(movmoll-movmolf+1)
          if (im .eq. 1) igrslts=ig-1
          read (itemp1,1002) name,name1,x,y,z,ig,q
          call pdblim('CHRM',nstta+im,iw,maxat,'atom',3,nwwarn,iout)
          call pdblim('CHRM',ngrfx+ig,igw,maxres,'residue',4,nwwarn,
     -      iout)
          call pdblim('CHRM',ig-igrslts,igsegw,9999,'residue',5,
     -      nwwarn,iout)
          if (name(1:1) .eq. ' ') name(1:3)=name(2:4)
          write (ifilt,1006) iw,igw,name,name1,x,y,z,'X   ',igsegw,q
        end do
        do im=1,nmolslv
          read (itemp,1001) name,x,y,z,ig,q,estv
          if (im .eq. 1) igrslts=ig-1
          call pdblim('CHRM',nstta+igrsltm*(movmoll-movmolf+1)+im,iw,
     -      maxres,'atom',3,nwwarn,iout)
          call pdblim('CHRM',ngrfx+igrsltm+ig,igw,maxres,'residue',
     -      4,nwwarn,iout)
          call pdblim('CHRM',ig-igrslts,igsegw,maxres,'residueid',
     -      5,nwwarn,iout)
          write (ifilt,1006) iw,igw,'SLV ',name,x,y,z,'W    ',igsegw,q
        end do
      end if
      call fileclose(itemp,1,iop(24),iout)
      if (nsltpardis .gt. 0) call fileclose(itemp1,1,iop(24),iout)
      write (iout,2003) ngrfx
      if (nsltpardis .gt. 0) write (iout,2004) ngrfx+1,ngrfx+igrsltm
      if (nmolec .gt. 1)
     -  write (iout,2005) ngrfx+igrsltm+1,ngrfx+igrsltm+igrsltw
      call trnsfr(c,cgs,3*natoms)
      return
1000  format(i5)
1001  format(a4,1x,3f15.5,i5,2f10.5)
1002  format(2a4,1x,3f15.5,i5,f10.5)
1003  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
1004  format(20x,i6,5x,i9,17x,i6,/,
     -  (9x,i6,21x,i5,2x,a4,13x,i5,2x,a4,7x,f8.4,3x,19x,f12.4,9x))
1005  format('* Aggregate solvent conformations',/,'* ',/,i5)
1006  format(i5,i5,1x,a4,1x,a4,3f10.5,1x,a4,1x,i4,f10.5)
1008  format(a,1x,a,/,a,1x,a,/,a,' Aggregated conformations')
1110  format(a3)
2000  format(' Generating combined solvent positions using ',
     -  'configurations from every',i8,'-th simulation step')
1010  format(' ALLSOLV iii=',i8,/,
     -  (' iw=',i5,' rmins=',f10.5,' esvst=',e12.5))
2001  format(' The first ',i7,' configurations will be skipped')
2002  format(' Number of configurations used=',i6,/,
     -  ' Number of solvent atoms (per molecule)=',i3)
2003  format(' Full solute forms residues 1 - ',i5,1x)
2004  format(' Additional mobile solute atoms form residues ',i5,
     -  ' - ',i5,1x)
2005  format(' Solvent atoms form residues (configs) ',i5,' - ',i6,1x)
2006  format(' ===== STRONG WARNING: number of molecules on proximity ',
     -  'information file (',i6,') disagrees with configuration read:',
     -  i6,/,7x,'MC stepnumers of the .hst and .pxi files:',2i12,/,
     -  7x,'Proximity information file will be ignored')
2007  format(' ***** ERROR: proximity information file is too short,',
     -  ' last snapshot read:',i10,1x)
2008  format(' Proximity information file reading is turned off')
2009  format(' Solvent energy range: [',f8.2,',',f8.2,']')
2010  format(' ----- WARNING: without the CSEG key, only one-character',
     -  ' segment ids will be written')
2011  format(' Output file format: ',a)
2012  format(' ----- WARNING: there are no solvents in this system ',
     -  '- the DENF key will be ignored')
      end
      subroutine trajconv(ihist,iform9w,iop9w,ioptrans,
     -  inpt,iout,nwarn,nconnfail,c,crm,zv,uusfac)
c#    MMC routine 451 lstmod: 10/08/03
c*****Gather all solvents into a single configuration
      character*80 filename1
      dimension c(3,#NA),crm(3,#MO),zv(3,#UV)
      real*8 uusfac
      character*80 ident
      common /title/ nlident,ident(2)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /param/ edgexyz(3),edgexyz2(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*1 lxyz
      common /names/ lxyz(3)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /proxires/ rmins(#MO),ncorslt(#ST),ncor2slt(#ST),
     -  estsv(#MO),rij2v(#ST),rv(#MO)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /option/ iop(200),idebug(200)
      dimension d0(3)
      character*17 formatnames
      common /trajform/ formatnames(11)
      call getint(nmcmax,0,1,100000000)
      call getint(nmcfreq,0,1,1)
      call getint(nmcskip,0,1,0)
      call getint(incvers,0,1,10)
      call getint(nmcmaxseg,0,1,0)
      write (iout,2000) nmcfreq
      write (iout,2011) formatnames(iop9w)
      if (ioptrans .eq. 1) write (iout,2001)
      if (ioptrans .eq. 2) write (iout,2002)
      if (iop(175) .gt. 0) write (iout,1350) (lxyz(ixyz(k)),k=1,3)
      if (nmcskip .gt. 0) write (iout,2001) nmcskip
      write (iout,2004) nmcmax
      nmchinc=0
      call opentraj(filenames(3),namlens(3),nstta,nslv,nsvp,c,0,nmolec,
     -  numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),0,uusfac,
     -  edgexyz,ieof,nconnfail)
      if (ieof .gt. 0) return
      nconf=0
      nrec=0
      if (iskip1 .eq. 0) nmc=0
      iii=0
      nmcdec=0
      if (nmcmaxseg .eq. 0) nmcmaxseg=nmcmax
      nseg=(nmcmax-1)/nmcmaxseg+1
      do iseg=1,nseg
c       Open new configuration file with current version+incvers+iseg-1
        call fileopen(file,namlenf,filename1,namlen1,28,0,numrun,
     -    nhstvers+incvers+iseg-1,0,iform9w,iop(24),iversout,iout,
     -    newhist,0)
        call writeheader(iop9w,newhist,iout,natoms,nstta,2,
     -    ident,nmcfreq,nmcmax,nmcskip,isltmv,nslv,numrec(28),0,
     -    edgexyz,0,0)
        do while (nmc-nmcdec .lt. nmcmaxseg)
          iii=iii+1
          if (iii .gt. 1 .or. iskip1 .eq. 0) then
            nmcprev=nmc
            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -        nmchinc,incrun,ia0,c,0,nrecread,uusfac,0,nsvp,0)
          else
            nmcprev=0
          end if
          if (iop(175) .gt. 0) call permutexyz(c,natoms,ixyz)
          if (nmolec .gt. 1) nslv=(natoms-nstta)/(nmolec-1)
          if (ieof .gt. 0) go to 999
          if (nmc .ge. nmcskip+1) then
            if (modrange(nmcprev,nmc,nmcfreq) .eq. 0) then
              if (ioptrans .eq. 1) then
c               Center system to solute com
                call systemcent(crm,c,zv,d0,nstta,nmolec,iop(5),nslv,
     -            ianslt,ianslv,ic00,1)
              else if (ioptrans .eq. 2) then
c               Shift system by edgexyz/2
                do k=1,3
                  d0(k)=edgexyz2(k)
                end do
                call systemcent(crm,c,zv,d0,nstta,nmolec,iop(5),nslv,
     -            ianslt,ianslv,ic00,0)
              end if
              call savcnfh(newhist,iout,0,1,iop9w,1,c,zv,filename1,
     -          namlen1,nrecprev,nrec,nconf,uusfac,#NA,#UV)
            end if
          end if
        end do
        nmcdec=nmc
        call fileclose(newhist,0,iop(24),iout)
      end do
999   write (iout,2002) nconf,nrec
      if (nmolec .gt. 1) write (iout,2003) nslv
      call fileclose(newhist,0,iop(24),iout)
      nmchinc=0
      return
2000  format(' Transforming trajectory file using configurations from ',
     -  'every',i8,'-th simulation step')
2011  format(' Output file format: ',a17)
2001  format(' The first ',i7,' configurations will be skipped')
2002  format(' Number of configurations used=',i6,/,
     -  ' Number of records written=',i10)
2003  format(' Number of solvent atoms (per molecule)=',i3)
2004  format(' Trajectory will be processed until stepnumber=',i10)
1350  format(' The X, Y, and Z axes will be permuted to ',3(a1,1x))
      end
      subroutine systemcent(crm,c,zv,d0,nstta,nmolec,iop5,nslv,
     -  ianslt,ianslv,ic00,icom)
      dimension crm(3,#MO),c(3,#NA),zv(3,#UV),
     -  ianslt(nstta),ianslv(nslv),d0(3),d1(3)
c#    MMC routine 452 lstmod: 02/26/03
c*****Shift the system to be centered at d0
c     Get crm first
      call cofms(c,crm,ianslt,1,nstta,0,wx)
      do is=2,nmolec
        call cofms(c(1,ic00+1),crm(1,is),ianslv,1,nslv,1,wx)
      end do
c     Calculate the PBC shifts
      if (icom .eq. 1) call trnsfr(d0,crm,3)
      do is=1,nmolec
        call arrdiff(zv(1,is),crm(1,is),d0,3)
      end do
      call pbcvec(iop5,2,nmolec)
      do is=1,nmolec
        call arrdiff(d1,zv(1,is),crm(1,is),3)
        call trnsfr(crm(1,is),zv(1,is),3)
        call trnsfr(zv(1,is),d1,3)
      end do
c     Shift the solute first
      do ia=1,nstta
        call arrsum(c(1,ia),c(1,ia),zv,3)
      end do
      if (nmolec .gt. 1) then
c       Apply the shifts to the solvent
        do j=1,nslv
          do is=2,nmolec
            call arrsum(c(1,ic00+is*nslv+j),
     -        c(1,ic00+is*nslv+j),zv(1,is),3)
          end do
        end do
      end if
      return
      end
      subroutine set_ixorig(ixorig,islvkeep,nmolec)
      dimension ixorig(nmolec),islvkeep(nmolec)
      ndel=0
      do im=2,nmolec
        if (islvkeep(im) .eq. 0) then
          ndel=ndel+1
        else
          ixorig(im-ndel-1)=im-1
        end if
      end do
      return
      end
      subroutine discardmol(numsolv,nmolec,natoms,nslt,nslv,c,crm,
     -  idatacol,datacol1,datacol2,ixkeep,indexfilt,igncrm,maxat,maxmol)
c#    MMC routine 453 lstmod: 08/07/13
c*****Condense solvent list
      dimension c(3,maxat),crm(3,maxmol),ixkeep(maxmol),
     -  indexfilt(maxmol),datacol1(maxmol),datacol2(maxmol)
c     indexfilt(im) is the original solvent number of the filtered solvent set
c     write (6,*) 'DISCARDMOL nmolec=',nmolec
      ndel=0
      do im=2,nmolec
        if (ixkeep(im) .eq. 0) then
          ndel=ndel+1
        else
          ixkeep(im)=0
          if (ndel .gt. 0) then
            indexfilt(im-ndel-1)=indexfilt(im-1)
            do k=1,3
              if (igncrm .eq. 0) crm(k,im-ndel)=crm(k,im)
              do j=1,nslv
                c(k,nslt+(im-ndel-2)*nslv+j)=c(k,nslt+(im-2)*nslv+j)
              end do
            end do
            if (idatacol .gt. 0) then
              datacol1(im-ndel)=datacol1(im)
              datacol2(im-ndel)=datacol2(im)
            end if
          end if
        end if
      end do
      nmolec=nmolec-ndel
      numsolv=nmolec-1
      natoms=natoms-ndel*nslv
c     write (6,*) 'DISCARDMOL numsolv=',numsolv
      return
      end
      subroutine discardslt(c,natoms,nslt,qslt,ianslt,igrslt,labslt,
     -  ikeep)
c#    MMC routine 454 lstmod: 01/18/09
c*****Condense solvent list
      character*4 labslt
      dimension c(3,#NA),qslt(#ST),ianslt(#ST),igrslt(#ST),
     -  labslt(2,#ST),ikeep(#NA)
      ndel=0
      nsltdel=0
      do ia=1,natoms
        if (ikeep(ia) .eq. 0) then
          ndel=ndel+1
          if (ia .le. nslt) nsltdel=nsltdel+1
        else if (ndel .gt. 0) then
          call trnsfr(c(1,ia-ndel),c(1,ia),3)
          if (ia .le. nslt) then
            qslt(ia-nsltdel)=qslt(ia)
            igrslt(ia-nsltdel)=igrslt(ia)
            ianslt(ia-nsltdel)=ianslt(ia)
            labslt(1,ia-nsltdel)=labslt(1,ia)
            labslt(2,ia-nsltdel)=labslt(2,ia)
          end if
        end if
      end do
      nslt=nslt-nsltdel
      natoms=natoms-ndel
      return
      end
      subroutine prtgrid(numrunw,c,maxat,ioutform,nofcls,iopcavintp,
     -  nnexmin,nnexmax,cvlim,rcutcv,volcavmin,volpckmin,
     -  cvlimcav,nlshave,noputbacksfg,
C@PG     -  igrdvers,labslt,iborderprt,maxnnsurf,sltchainid,
     -  iout,inperr,nwarn,nwwarn)
c#    MMC routine 455 lstmod: 02/01/22
c*****Prints all the free grids that are closer than dismax2 A**2 from
c     the nearest solute atom
C@PG      character*4 labslt
C@PG      character*1 sltchainid
      dimension c(3,maxat)
C@PG      dimension labslt(2,#ST)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /option/ iop(200),idebug(200)
      common /param/ edgexa,edgeya,edgea,edgex2,edgey2,edge2,
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@I2      integer*2 ncover
      real*8 ranshift
      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
      common /gather/ indexx(#UV),ixnear(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),frcng(3,#UV),trqng(3,#UV),
     -  trnisg(3,#UV),cv1(#UV),cv2(#UV),cv3(#UV),
     -  qsurf(#UV),aby(#UV),abz(#UV)
      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
     -  cci(3,#UV)
      common /warncount/ ichsegwarn,ipdbcherr(11)
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /worksp/ ireslist(#NA),iatlist(#UV),
     -  l3(#UV),l4(#UV)
C@PG      character*12 fname(3)
C@PG      character*80 filename1
C@PG      dimension r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ)
C@PG      common /grdi/ ingr(6,#CV),nngr(#CV),iclstgr(#CV),
C@PG     -  iusedgr(#CV),icavgrid(#CV),ixrevgrd(#CV),
C@PG     -  ifgr(#GC),ilgr(#GC),indexcav(#GC),cvnumx(#CV),
C@PG     -  cvnumy(#CV),cvnumz(#CV),cvden(#CV)
C@PG      dimension igridfiletyp(4)
C@PG      character*4 cavng(6),resname
C@PG      character*10 chainlab
C@PG      data cavng /'CV1N','CV2N','CV3N','CV4N','CV5N','CV6N'/
C@PG      data igridfiletyp /0,15,18,12/
C@PG      data markfac /1/
C@PG      data fname /'PDB         ','Charmm      ','Insight free'/
C@PG      gridvol=grid(1)*grid(2)*grid(3)
C@PG      mincavcl=volcavmin/gridvol
C@PG      minpckcl=volpckmin/gridvol
C@PG      write (iout,3000)
C@PG      if (amax1(grid(1),grid(2),grid(3)) .gt. 0.5) then
C@PG        write (iout,3010)
C@PG        nwarn=nwarn+1
C@PG      end if
C@PG      if (ioutform .eq. 1) write (iout,3001)
C@PG      if (ioutform .gt. 1) write (iout,3002) fname(ioutform-1)
C@PG      if (ioutform .gt. 0) then
C@PG        if (nnexmin .gt. nnexmax) then
C@PG           write (iout,3004) 'No unfiltered'
C@PG        else if (nnexmin .eq. 1 .and. nnexmax .eq. 6) then
C@PG           write (iout,3004) 'All'
C@PG        else
C@PG           write (iout,3005) nnexmin,nnexmax
C@PG        end if
C@PG      end if
C@PG      if (iop(62) .eq. 0)
C@PG     -   write (iout,2015) 'standard Van der Waals radii'
C@PG      if (iop(62) .eq. 1) write (iout,2015) 'Lennard-Jones sigmas'
C@PG      if (iop(62) .eq. 2) write (iout,2015)
C@PG     -  'Lennard-Jones sigmas; hydrogen sigma <= 1.0'
C@PG      if (rsltfac .ne. 1.0) write (iout,2016) rsltfac
C@PG      write (iout,3009) 'cavity',mincavcl,volcavmin
C@PG      if (cvlimcav .gt. 0.0) write (iout,3011) cvlimcav,rcutcv
C@PG      write (iout,3008) sqrt(rnear2lim)
C@PG      if (iopcavintp .eq. 0) write (iout,3003) 'All'
C@PG      if (iopcavintp .eq. 1) write (iout,3003) 'Boundary'
C@PG      if (iopcavintp .eq. 2)
C@PG     -   write (iout,*) 'Grids will just be clustered'
C@PG      if (cvlim .gt. 0.0) then
C@PG        write (iout,3006) cvlim,rcutcv
C@PG        write (iout,3009) 'pocket',minpckcl,volpckmin
C@PG      end if
C@PG      write (iout,2014)
C@PG      resname='CAVT'
C@PG      if (ioutform .ne. 2) then
C@PG        chainlab=' '
C@PG        lchainlab=1
C@PG        lresname=4
C@PG      else
C@PG        chainlab=' chainid=G'
C@PG        lchainlab=10
C@PG        lresname=3
C@PG      end if
C@PG      nsltres=igrslt(nstta)
C@PG      rslv=diamslv/2.0
C@PG      call zeroit(qsurf,nstta)
C@PG      call clustergrid(1,1,ncavs,nofcls,mincavcl,cvlimcav,rcutcv,
C@PG     -  0.0,c,istf,nstta,ngleft,ncleft,0,0,idebug(157),iout,inperr)
C@PG      if (idebug(126) .gt. 0) call checknnlist(1,ngfree,nngr,ingr,
C@PG     -  iout,inperr,nwwarn,nerr,0,1,0,6,#CV)
C@PG      if (iopcavintp .lt. 2) then
C@PGc       Print cavity information
C@PG        natsp=nstta-istf+1+ilgr(ncavs)
C@PG        if (ncavs .gt. 0) then
C@PG          call zeroiti(ipdbcherr,8,11)
C@PG          markfac=+1
C@PGc         ngleft=0
C@PGc         ncleft=0
C@PGc         do ic=1,ncavs
C@PGc           nmem=ilgr(ic)-ifgr(ic)+1
C@PGc           if (nmem .ge. mincavcl) then
C@PGc             ngleft=ngleft+nmem
C@PGc             ncleft=ncleft+1
C@PGc             indexcav(ncleft)=ic
C@PGc           end if
C@PGc         end do
C@PG          natsp=nstta-istf+1+ngleft
C@PG          if (iopcavintp .eq. 1) then
C@PGc           For each solute atom, mark the uncovered grids in its vicinity
C@PG            markfac=-1
C@PG            do is=istf,nstta
C@PG              cv1(is)=rsphi(is)+(grid(1)+grid(2)+grid(3))/2.0
C@PG              rsphsi=cv1(is)**2
C@PG              call make_printprtgrid(cv1(is),c(1,is),e2gm,rspupe2,
C@PG     -          rspume2,r2x,r2y,r2z,ixf,iyf,izf,igx,igy,igz,ngx,ngy,ngz)
C@PG              do i=ixf,ngx
C@PG                r2xs=r2x(i)
C@PG                do j=iyf,ngy
C@PG                  r2ys=r2xs+r2y(j)
C@PG                  if (r2ys .le. rsphsi) then
C@PG                    do k=izf,ngz
C@PG                      if (r2ys+r2z(k) .le. rsphsi) then
C@PG                        ic=igx(i)
C@PG                        jc=igy(j)
C@PG                        kc=igz(k)
C@PG                        if (ncover(ic,jc,kc) .lt. 0) then
C@PGc                         Grid was free, mark it to be printed (only once)
C@PG                          if (igfree(-ncover(ic,jc,kc)) .gt. 0)
C@PG     -                      igfree(-ncover(ic,jc,kc))=
C@PG     -                        -igfree(-ncover(ic,jc,kc))
C@PG                        end if
C@PG                      end if
C@PG                    end do
C@PG                  end if
C@PG                end do
C@PG              end do
C@PG            end do
C@PG            nbound=0
C@PG            do ic=1,ncleft
C@PG              do ig=ifgr(indexcav(ic)),ilgr(indexcav(ic))
C@PG                if (igfree(iclstgr(ig)) .gt. 0) nbound=nbound+1
C@PG              end do
C@PG            end do
C@PG            natsp=nstta-istf+1+nbound
C@PG          end if
C@PG          do ic=1,ncleft
C@PG            nreslist=0
C@PG            natlist=0
C@PG            do ig=ifgr(indexcav(ic)),ilgr(indexcav(ic))
C@PG              indx=markfac*igfree(iclstgr(ig))
C@PG              if (indx .gt. 0) then
C@PG                call unpackijk(indx,ng1,ix,iy,iz)
C@PG                gx=(e2gm(1)+ix*grid(1))
C@PG                gy=(e2gm(2)+iy*grid(2))
C@PG                gz=(e2gm(3)+iz*grid(3))
C@PG                nn=nngr(iclstgr(ig))
C@PG                call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -            ireslist,nreslist,rnear2,rnear2lim,0)
C@PG                do ia=1,natlist
C@PG                  qsurf(iatlist(ia))=ic
C@PG                end do
C@PG              end if
C@PG            end do
C@PG          end do
C@PG          if (ioutform .gt. 1)
C@PG     -      call writeslthead(file,namlenf,filename1,namlen1,
C@PG     -        igridfiletyp(ioutform),numrunw,igrdvers,ioutform,istf,
C@PG     -        nstta,natsp,c,qsurf,igrslt,labslt,ianslt,ianprt,iatnam,
C@PG     -        'cavity region(s)',16,sltchainid,iop(24),ioutgr,iout)
C@PG          write (iout,2002) 'Cavity',resname(1:lresname),'G'
C@PG          iagrd=nstta-istf+1
C@PG          iggrd=nsltres
C@PG          ngprinttot=0
C@PG          do ic=1,ncleft
C@PG            nreslist=0
C@PG            natlist=0
C@PG            ngprint=0
C@PG            iggrd=nsltres+ic-1
C@PG            iggrd=iggrd+1
C@PG            do ig=ifgr(indexcav(ic)),ilgr(indexcav(ic))
C@PG              igg=iclstgr(ig)
C@PG              indx=markfac*igfree(igg)
C@PG              if (indx .gt. 0) then
C@PG                iagrd=iagrd+1
C@PG                if (ioutform .gt. 1)
C@PG     -            call printgridatom(indx,ng1,iagrd,iagrdp,iggrd,
C@PG     -              iggrdp,nwwarn,iout,ioutgr,'CAVT','G',0.0,
C@PG     -              ioutform,ic,e2gm,grid,gx,gy,gz)
C@PG                ngprint=ngprint+1
C@PG                if (idebug(83) .gt. 0) then
C@PG                  call unpackijk(indx,ng1,ix,iy,iz)
C@PG                  write (iout,2020) ic,iagrdp,iggrd,ix,iy,iz,
C@PG     -              'x',ncover(ix-1,iy,iz),ncover(ix+1,iy,iz),
C@PG     -              'y',ncover(ix,iy-1,iz),ncover(ix,iy+1,iz),
C@PG     -              'z',ncover(ix,iy,iz-1),ncover(ix,iy,iz+1)
C@PG                  do in=1,nngr(igg)
C@PG                    indx=ingr(in,igg)
C@PG                    call unpackijk(indx,ng1,iix,iiy,iiz)
C@PG                    write (iout,1213) ig,ix,iy,iz,iix,iiy,iiz
C@PG                  end do
C@PG                end if
C@PG                nn=nngr(igg)
C@PG                call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -            ireslist,nreslist,rnear2,rnear2lim,0)
C@PG              end if
C@PG            end do
C@PG            iusedgr(ic)=ngprint
C@PG            call fchargesum(labslt,ifgrslt,ireslist,nreslist,fc)
C@PG            call gridclstcent(ifgr(indexcav(ic)),ilgr(indexcav(ic)),
C@PG     -        iclstgr,zv(1,indexcav(ic)),#CV)
C@PG            volscal=(rslv+(gridvol*iusedgr(ic)/pi43)**(1.0/3.0))**3*pi43
C@PG            write (iout,2012) ' Cavity',indexcav(ic),nsltres+ic,
C@PG     -        iusedgr(ic),gridvol*iusedgr(ic),volscal,fc,' ',
C@PG     -        (zv(k,indexcav(ic)),k=1,3)
C@PG            call printreslist(ireslist,ifgrslt,labslt,nreslist,
C@PG     -        iatlist,natlist,iborderprt,indexx,iout,#ST)
C@PG            ngprinttot=ngprinttot+ngprint
C@PG          end do
C@PG          if (ioutform .gt. 1) write (iout,2000)
C@PG     -      ngprinttot,'cavity',filename1(1:namlen1),'cavity',nsltres+1
C@PG          if (nlshave .gt. 0)
C@PG     -      call shavesplit (nlshave,nngr,ingr,1,ncavs,ifgr,ilgr,
C@PG     -        indexcav,iusedgr,iclstgr,e2gm,grid,resname(1:lresname),
C@PG     -        'Cavity',iagrd,ngprinttot,indexx,indexn,ixnear,cgs,
C@PG     -        iborderprt,gridvol,c,labslt,ifgrslt,igfree,
C@PG     -        mincavcl,maxnnsurf,noputbacksfg,rnear2lim,iout,
C@PG     -        ioutform,ioutgr,inperr,nwwarn,ng1)
C@PG          if (ioutform .eq. 2) write (ioutgr,2014) 'END'
C@PG          if (ioutform .gt. 1) call fileclose (ioutgr,0,iop(24),iout)
C@PG          igrdvers=igrdvers+1
C@PG        end if
C@PG        if (cvlim .gt. 0.0) then
C@PG          write (iout,2014)
C@PG          call zeroiti(ipdbcherr,8,11)
C@PGc         Calculate the circular variance of the external grids
C@PG          ngext=ilgr(nofcls)-ifgr(nofcls)+1
C@PG          write (iout,3007) ngext,nofcls
C@PG          resname='PCKT'
C@PG          if (ioutform .eq. 2) then
C@PG            chainlab=' chainid=G'
C@PG            lchainlab=10
C@PG          end if
C@PGc         Establish the reverse indexing
C@PG          do ig=1,ngfree
C@PG            ixrevgrd(iclstgr(ig))=ig
C@PG          end do
C@PG          call cvfilter_grids(ngdel,istf,nstta,c,rcutcv,cvlim,nofcls)
C@PG          if (ngdel .eq. ngext) then
C@PG            write (iout,2004)
C@PG            return
C@PG          end if
C@PGc         Update neighbor list
C@PG          call clustergrid(0,2,ncavs,nofcls,minpckcl,cvlimcav,rcutcv,
C@PG     -      rnear2lim,c,istf,nstta,ngleft,ncleft,0,0,idebug(157),
C@PG     -      iout,inperr)
C@PG          npockets=nofcls-ncavs
C@PG          write (iout,2008) npockets
C@PG          call zeroit(qsurf,nstta)
C@PG          if (npockets .gt. 0) then
C@PG            if (ngleft .gt. 0) then
C@PG              do ic=ncavs+1,ncavs+ncleft
C@PG                nreslist=0
C@PG                natlist=0
C@PG                do ig=ifgr(indexcav(ic)),ilgr(indexcav(ic))
C@PG                  indx=igfree(iclstgr(ig))
C@PG                  nn=nngr(iclstgr(ig))
C@PG                  call unpackijk(indx,ng1,ix,iy,iz)
C@PG                  gx=(e2gm(1)+ix*grid(1))
C@PG                  gy=(e2gm(2)+iy*grid(2))
C@PG                  gz=(e2gm(3)+iz*grid(3))
C@PG                  call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -              ireslist,nreslist,rnear2,rnear2lim,0)
C@PG                  do ia=1,natlist
C@PG                    qsurf(iatlist(ia))=ic
C@PG                  end do
C@PG                end do
C@PG              end do
C@PG              natsp=nstta-istf+1+ngleft
C@PG              if (ioutform .gt. 1)
C@PG     -          call writeslthead(file,namlenf,filename1,namlen1,
C@PG     -            igridfiletyp(ioutform),numrunw,igrdvers,ioutform,
C@PG     -            istf,nstta,natsp,c,qsurf,igrslt,labslt,ianslt,
C@PG     -            ianprt,iatnam,'pocket region(s)',16,sltchainid,
C@PG     -            iop(24),ioutgr,iout)
C@PG              write (iout,2002) 'Pocket',resname(1:lresname),'G'
C@PG              do ic=ncavs+1,ncavs+ncleft
C@PG                ngprint=0
C@PG                nreslist=0
C@PG                natlist=0
C@PG                iggrd=nsltres+ic-ncavs
C@PG                do ig=ifgr(indexcav(ic)),ilgr(indexcav(ic))
C@PG                  indx=igfree(iclstgr(ig))
C@PG                  iagrd=nstta-istf+1+ig
C@PG                  if (ioutform .gt. 1)
C@PG     -              call printgridatom(indx,ng1,iagrd,iagrdp,iggrd,
C@PG     -                iggrdp,nwwarn,iout,ioutgr,'PCKT','G',cvden(ig),
C@PG     -                ioutform,ic,e2gm,grid,gx,gy,gz)
C@PG                  nn=nngr(iclstgr(ig))
C@PG                  call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -              ireslist,nreslist,rnear2,rnear2lim,0)
C@PG                end do
C@PG                nmem=ilgr(indexcav(ic))-ifgr(indexcav(ic))+1
C@PG                call fchargesum(labslt,ifgrslt,ireslist,nreslist,fc)
C@PG                volscal=(rslv+(gridvol*nmem/pi43)**(1.0/3.0))**3*pi43
C@PG                call gridclstcent(ifgr(indexcav(ic)),ilgr(indexcav(ic)),
C@PG     -            iclstgr,zv(1,indexcav(ic)),#CV)
C@PG                write (iout,2012) ' Pocket',indexcav(ic)-ncavs,
C@PG     -            nsltres+ic-ncavs,nmem,gridvol*nmem,volscal,fc,' ',
C@PG     -            (zv(k,indexcav(ic)),k=1,3)
C@PG                call printreslist(ireslist,ifgrslt,labslt,nreslist,
C@PG     -            iatlist,natlist,iborderprt,indexx,iout,#ST)
C@PG              end do
C@PG              if (ioutform .gt. 1) write (iout,2000)
C@PG     -          ngleft,'pocket',filename1(1:namlen1),'pocket',nsltres+1
C@PG              if (nlshave .gt. 0)
C@PG     -          call shavesplit (nlshave,nngr,ingr,ncavs+1,nofcls,
C@PG     -            ifgr,ilgr,indexcav,iusedgr,iclstgr,e2gm,grid,
C@PG     -            resname(1:lresname),'Pocket',iagrd,iggrd,indexx,
C@PG     -            indexn,ixnear,cgs,iborderprt,gridvol,c,labslt,
C@PG     -            ifgrslt,igfree,minpckcl,maxnnsurf,noputbacksfg,
C@PG     -            rnear2lim,iout,ioutform,ioutgr,inperr,nwwarn,ng1)
C@PG              if (ioutform .eq. 2) write (ioutgr,2014) 'END'
C@PG              if (ioutform .gt. 1)call fileclose (ioutgr,0,iop(24),iout)
C@PG              igrdvers=igrdvers+1
C@PG            end if
C@PG          end if
C@PG        end if
C@PG        if (nnexmin .le. nnexmax) then
C@PGc         Print external gridpoint file
C@PG          if (ioutform .gt. 1)
C@PG     -      call writeslthead(file,namlenf,filename1,namlen1,
C@PG     -        igridfiletyp(ioutform),numrunw,igrdvers,ioutform,
C@PG     -        istf,nstta,natsp,c,qslt,igrslt,labslt,ianslt,ianprt,
C@PG     -        iatnam,'outside region',14,sltchainid,iop(24),ioutgr,iout)
C@PG          ngprint=0
C@PG          iagrd=nstta-istf+1
C@PG          iggrd=nsltres+1
C@PG          do ig=ifgr(nofcls),ilgr(nofcls)
C@PG            indx=igfree(iclstgr(ig))
C@PG            nn=nngr(iclstgr(ig))
C@PG            if (nn .ge. nnexmin .and. nn .le. nnexmax) then
C@PG              iagrd=iagrd+1
C@PG              if (ioutform .gt. 1)
C@PG     -          call printgridatom(indx,ng1,iagrd,iagrdp,iggrd,iggrdp,
C@PG     -            nwwarn,iout,ioutgr,cavng(nn),'G',0.0,ioutform,nofcls,
C@PG     -            e2gm,grid,gx,gy,gz)
C@PG              ngprint=ngprint+1
C@PG            end if
C@PG          end do
C@PG          iusedgr(1)=ngprint
C@PG          if (ioutform .eq. 2) write (ioutgr,2014) 'END'
C@PG          if (ioutform .gt. 1) write (iout,2000) ngprint,
C@PG     -      'external',filename1(1:namlen1),'external grid',nsltres
C@PG          if (ioutform .gt. 1) call fileclose (ioutgr,0,iop(24),iout)
C@PG          igrdvers=igrdvers+1
C@PG        end if
C@PG      else
C@PGc       Just cluster gridpoints and return
C@PG        call clstrs(ingr,nngr,indexcav,1,ngfree,iclstgr,ifgr,ilgr,
C@PG     -    0,nofcls,iusedgr,iout,inperr,nww,0,#CV,#GC,6,3,0)
C@PG        if (nofcls .gt. #GC) then
C@PG          write (iout,2001) nofcls,'GC'
C@PG          nofcls=#GC
C@PG        end if
C@PG        do ic=1,nofcls
C@PG          call gridclstcent(ifgr(ic),ilgr(ic),iclstgr,zv(1,ic),
C@PG     -      #CV)
C@PG        end do
C@PG      end if
      return
C@PG2000  format(' A total of',i10,1x,a,' gridpoints were written to file',
C@PG     -  1x,a,/,' Residue number of the first ',a,'=',i5)
C@PG2001  format(' ===== STRONG WARNING: cavity list has been truncated ',
C@PG     -  'from ',i7,' cavities to #UV due to dimension limits (#',
C@PG     -  a,')')
C@PG2002  format(1x,a,' grid points are represented as He atoms, ',
C@PG     -  'residueme=',a,' chainid=',a)
C@PG2004  format(' ///// NOTE: all external gridpoints were filtered out')
C@PG2008  format(' Pocket gridpoints form',i7,' clusters')
C@PG2012  format(a,i5,' res #',i5,' # of grids=',i8,' vol=',f11.2,' A**3 ',
C@PG     -  ' scaled vol=',f11.2,' charge=',f5.1,a,'cent=',3f8.2)
C@PG2014  format(a3)
C@PG2015  format(' Solute atom radii are based on ',a)
C@PG2016  format(' Solute radii will be scaled by a factor of',f6.3)
C@PG2020  format(' PRTG ic,ia,iggrd=',i4,2i6,' ixyz=',3i4,3(1x,a1,
C@PG     -  ' nc+-=',2i9))
C@PG1213  format(' PRTG ig=',i9,' ixyz=',3i4,' neig ixyz=',3i4)
C@PG3000  format(/,10x,'=== Calculation of cavities and pockets ===')
C@PG3001  format(' No cavity grid file is written')
C@PG3002  format(' Writing cavity grid file in ',a,' format')
C@PG3003  format(1x,a,' cavity gridpoints will be written out')
C@PG3004  format(1x,a,' external gridpoints  will be written out')
C@PG3005  format(' Only external gridpoints having at least ',i1,' and',
C@PG     -  ' at most ',i1,' neighboring grid points will be written out')
C@PG3006  format(' External gridpoints will also be filtered by circular ',
C@PG     -  'variance (to detect pockets):',/,10x,'Gridpoints with CV < ',
C@PG     -  f5.3,' will be dropped (cutoff=',f6.2,' A)')
C@PG3007  format(' Circular variance filtering of ',i8,' gridpoints ',
C@PG     -  '(grid cluster # ',i3,')')
C@PG3008  format(' Atoms lining a cavity/pocket have to be closer then ',
C@PG     -  f5.2,' A to a cavity grid')
C@PG3009  format(' Minimum number of gridpoints in a printed ',a,'=',i6,
C@PG     -  ' (minimum volume=',f6.2,' A**3)')
C@PG3010  format(' ----- WARNING: largest grid interval is not less than ',
C@PG     -  ' 0.5 A - this may affect the quality of sampling',/,
C@PG     -  7x,'- increase the number of gridpoints.')
C@PG3011  format(' Cavities whose center has CV < ',f6.3,' (Rcut=',f7.3,
C@PG     -  'A ) will be dropped')
      end
C@PG      subroutine cvfilter_grids(ngdel,istf,nstta,c,rcutcv,cvlim,icout)
C@PGc#    MMC routine 455/a lstmod: 05/11/12
C@PG      dimension c(3,nstta)
C@PGc*****Filter the external gridpoints by CV
C@PG      real*8 ranshift
C@PG      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
C@PG     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
C@PG     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
C@PG     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@PG      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
C@PG     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@PG      common /grdi/ ingr(6,#CV),nngr(#CV),iclstgr(#CV),
C@PG     -  iusedgr(#CV),icavgrid(#CV),ixrevgrd(#CV),
C@PG     -  ifgr(#GC),ilgr(#GC),indexcav(#GC),cvnumx(#CV),
C@PG     -  cvnumy(#CV),cvnumz(#CV),cvden(#CV)
C@PG      dimension r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ)
C@PGc     print *,'CVFILTER_GRIDS icout=',icout,' nstta=',nstta
C@PG      call zeroit(cvden,ngfree)
C@PG      call zeroit(cvnumx,ngfree)
C@PG      call zeroit(cvnumy,ngfree)
C@PG      call zeroit(cvnumz,ngfree)
C@PG      do is=istf,nstta
C@PG        rsphsi=rcutcv**2
C@PG        call make_printprtgrid(rcutcv,c(1,is),e2gm,rspupe2,rspume2,
C@PG     -    r2x,r2y,r2z,ixf,iyf,izf,igx,igy,igz,ngx,ngy,ngz)
C@PG        do i=ixf,ngx
C@PG          r2xs=r2x(i)
C@PG          do j=iyf,ngy
C@PG            r2ys=r2xs+r2y(j)
C@PG            if (r2ys .le. rsphsi) then
C@PG              do k=izf,ngz
C@PG                if (r2ys+r2z(k) .le. rsphsi) then
C@PG                  ic=igx(i)
C@PG                  jc=igy(j)
C@PG                  kc=igz(k)
C@PG                  if (ncover(ic,jc,kc) .lt. 0) then
C@PGc                   Grid was free, accumulate circular variance
C@PG                    ig=ixrevgrd(-ncover(ic,jc,kc))
C@PG                    if (ig .ge. ifgr(icout)) then
C@PG                      rr=sqrt(r2ys+r2z(k))
C@PG                      cvden(ig)=cvden(ig)+1.0
C@PG                      cvnumx(ig)=cvnumx(ig)+
C@PG     -                  (e2gm(1)+ic*grid(1)-c(1,is))/rr
C@PG                      cvnumy(ig)=cvnumy(ig)+
C@PG     -                  (e2gm(2)+jc*grid(2)-c(2,is))/rr
C@PG                      cvnumz(ig)=cvnumz(ig)+
C@PG     -                  (e2gm(3)+kc*grid(3)-c(3,is))/rr
C@PG                    end if
C@PG                  end if
C@PG                end if
C@PG              end do
C@PG            end if
C@PG          end do
C@PG        end do
C@PG      end do
C@PG      ngdel=0
C@PG      do ig=ifgr(icout),ilgr(icout)
C@PG        indx=igfree(iclstgr(ig))
C@PG        if (indx .lt. 0) indx=-indx
C@PG        call unpackijk(indx,ng1,ix,iy,iz)
C@PG        cvig=0.0
C@PG        if (cvden(ig) .gt. 0.0) cvig= 1.0-
C@PG     -    sqrt(cvnumx(ig)**2+cvnumy(ig)**2+cvnumz(ig)**2)/cvden(ig)
C@PG        if (cvig .lt. cvlim) then
C@PGc         Drop grid
C@PG          ngdel=ngdel+1
C@PG          ncover(ix,iy,iz)=0
C@PG        else
C@PG          ignew=ig-ngdel
C@PG          iusedgr(ignew)=indx
C@PG          ncover(ix,iy,iz)=-ignew
C@PG          cvden(ignew)=cvig
C@PG        end if
C@PG      end do
C@PG      ngout=ilgr(icout)-ifgr(icout)+1-ngdel
C@PG      call trnsfi(igfree(ifgr(icout)),iusedgr(ifgr(icout)),ngout)
C@PG      ilgr(icout)=ilgr(icout)-ngdel
C@PG      return
C@PG      end
C@PG      subroutine cavity_occ(crm,nf,nl,ncavs,nofcls,diamol,mincavcl,
C@PG     -  cvlimcav,rcutcv,istf,nstta,c,nocc,nslvfound,nframe,ncleft,
C@PG     -  n_unass,key,iout)
C@PGc*****Count the number of solvents in each cavity
C@PG      dimension crm(3,nl),c(3,nstta),nocc(nofcls)
C@PGc#    MMC routine 455/a lstmod: 05/13/12
C@PG      character*4 key
C@PG      common /cavdat/ diamslv,rsphs,rsltfac,rnear2lim,rsphi(#ST),
C@PG     -  rspupe2(3),rspume2(3),rspvpe2(3),rspvme2(3),nslvxp
C@PGC@I2      integer*2 ncover
C@PG      real*8 ranshift
C@PG      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
C@PG     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
C@PG     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
C@PG     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@PG      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
C@PG     -  cci(3,#UV)
C@PG      dimension r2x(#GX),r2y(#GY),r2z(#GZ),igx(#GX),igy(#GY),igz(#GZ)
C@PG      common /grdi/ ingr(6,#CV),nngr(#CV),iclstgr(#CV),
C@PG     -  iusedgr(#CV),icavgrid(#CV),ixrevgrd(#CV),
C@PG     -  ifgr(#GC),ilgr(#GC),indexcav(#GC),cvnumx(#CV),
C@PG     -  cvnumy(#CV),cvnumz(#CV),cvden(#CV)
C@PG      common /option/ iop(200),idebug(200)
C@PG      character*6 label(2)
C@PG      data label /'Cavity','Pocket'/
C@PGc     print *,'CAVITY_OCC ncavs,nofcls=',ncavs,nofcls
C@PG      nslvfound=0
C@PG      ilab=2
C@PG      if (key .eq. 'CVTY') ilab=1
C@PG      if (nframe .le. 1) then
C@PG        rnear2l=rnear2lim
C@PG        if (key .eq. 'CVTY') then
C@PG          rnearl=0.0
C@PG        end if
C@PG        call filtercavs(ngleft,ncleft,ncavs,nofcls,mincavcl,
C@PG     -    cvlimcav,rcutcv,rnear2l,istf,nstta,c,iout)
C@PG      end if
C@PGc     Establish cavity numbers for the cavities used
C@PG      call zeroiti(iusedgr,0,#CV)
C@PG      do ic=ncavs+1,ncavs+ncleft
C@PG        do ig=ifgr(indexcav(ic)),ilgr(indexcav(ic))
C@PG          iusedgr(iclstgr(ig))=indexcav(ic)
C@PG        end do
C@PG      end do
C@PG      call zeroiti(nocc,0,nofcls)
C@PG      nextdrop=0
C@PG      n_unass=0
C@PG      do is=nf,nl
C@PG        icl=0
C@PG        ndropped=0
C@PG        iext=0
C@PG        call make_printprtgrid(diamol/2.0,crm(1,is),e2gm,rspupe2,
C@PG     -    rspume2,r2x,r2y,r2z,ixf,iyf,izf,igx,igy,igz,ngx,ngy,ngz)
C@PG        rsphsi=0.25
C@PG        if (ixf .lt. 1 .or. ngx .gt. ngrid(1) .or.
C@PG     -      iyf .lt. 1 .or. ngy .gt. ngrid(3) .or.
C@PG     -      izf .lt. 1 .or. ngz .gt. ngrid(3)) then
C@PG           write (iout,2000) is,ixf,iyf,izf,ngx,ngy,ngz
C@PG           stop
C@PG        end if
C@PG        do i=ixf,ngx
C@PG          r2xs=r2x(i)
C@PG          do j=iyf,ngy
C@PG            r2ys=r2xs+r2y(j)
C@PG            if (r2ys .le. rsphsi) then
C@PG              do k=izf,ngz
C@PG                if (r2ys+r2z(k) .le. rsphsi) then
C@PG                  ic=igx(i)
C@PG                  jc=igy(j)
C@PG                  kc=igz(k)
C@PG                  if (ncover(ic,jc,kc) .lt. 0) then
C@PGc                   Grid was free, find the corresponding cavity #
C@PG                    ig=-ncover(ic,jc,kc)
C@PG                    icl=iusedgr(ig)
C@PG                    if (idebug(154) .gt. 0 .and.
C@PG     -                  (idebug(154) .gt. 1 .or. icl .gt. 1)) then
C@PG                      gx=(e2gm(1)+ic*grid(1))
C@PG                      gy=(e2gm(2)+jc*grid(2))
C@PG                      gz=(e2gm(3)+kc*grid(3))
C@PG                      write (iout,2001) is,icl,ig,
C@PG     -                  (crm(m,is),m=1,3),ic,jc,kc,gx,gy,gz,
C@PG     -                  sqrt(r2ys+r2z(k)),diamol
C@PG                    end if
C@PG                    if (icl .gt. 0) then
C@PG                      nslvfound=nslvfound+1
C@PG                      ivopt(nslvfound)=is
C@PG                      nmem=ilgr(icl)-ifgr(icl)+1
C@PG                      go to 100
C@PG                    else
C@PG                      if (ncavs .eq. 0) then
C@PGc                       Cavity cluster - skip message for external cavity
C@PG                        if (ixrevgrd(-ncover(ic,jc,kc)) .gt.
C@PG     -                      ilgr(nofcls)) iext=1
C@PG                      end if
C@PG                      ndropped=ndropped+1
C@PG                    end if
C@PG                  end if
C@PG                end if
C@PG              end do
C@PG            end if
C@PG          end do
C@PG        end do
C@PG100     if (icl .gt. 0) nocc(icl)=nocc(icl)+1
C@PG        if (icl+iext .eq. 0 .and. ndropped .gt. 0 .and. nframe .le. 1)
C@PG     -    write (iout,2002) is,(crm(m,is),m=1,3),label(ilab)
C@PG        nextdrop=nextdrop+iext
C@PG        if (ndropped .gt. 0 .and. iext .eq. 0) n_unass=n_unass+1
C@PG      end do
C@PG      return
C@PG2000  format(' ***** PROGRAM ERROR is=',i5,' ixf,iyf,izf=',3i5,
C@PG     -  ' ngx,ngy,ngz=',3i5)
C@PG2001  format(' Solvent',i5,' icl=',i3,' igr=',i9,' c=',3f7.2,
C@PG     -  ' ic,jc,kc=',3i4,' gxyz=',3f7.2,' r(c-g)=',f5.1,' diam=',f5.1)
C@PG2002  format(' ----- WARNING: Solvent ',i6,' (c=',3f10.5,') was ',
C@PG     -  'assigned to an ignored ',a)
C@PG      end
C@PG      subroutine report_clst_occ(ncleft,ncavs,nofcls,nframe,gvol,
C@PG     -  rslv,nocc,nslvfound,n_unasstot,key,iout)
C@PGc*****Count the number of solvents in each cavity
C@PGc#    MMC routine 455/b lstmod: 05/18/12
C@PG      character*4 key
C@PG      dimension nocc(nofcls)
C@PG      common /grdi/ ingr(6,#CV),nngr(#CV),iclstgr(#CV),
C@PG     -  iusedgr(#CV),icavgrid(#CV),ixrevgrd(#CV),
C@PG     -  ifgr(#GC),ilgr(#GC),indexcav(#GC),cvnumx(#CV),
C@PG     -  cvnumy(#CV),cvnumz(#CV),cvden(#CV)
C@PG      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
C@PG      character*6 label(2)
C@PG      data label /'Cavity','Pocket'/
C@PG      ilab=1
C@PG      ncav=0
C@PG      if (key .eq. 'PCKT') then
C@PG        ilab=2
C@PG        ncav=ncavs
C@PG      end if
C@PG      if (nframe .gt. 1) write (iout,1004) label(ilab),nframe
C@PG      do icl=ncav+1,ncav+ncleft
C@PG        ic=indexcav(icl)
C@PG        nmem=ilgr(ic)-ifgr(ic)+1
C@PG        vol=nmem*gvol
C@PG        volscal=(rslv+(vol/pi43)**(1.0/3.0))**3*pi43
C@PG        if (nframe .le. 1) then
C@PG          write (iout,1000)
C@PG     -      label(ilab),icl-ncav,ic-ncav,nmem,vol,volscal,nocc(ic)
C@PG        else
C@PG          avocc=float(nocc(ic))/float(nframe)
C@PG          write (iout,1001) label(ilab),icl-ncav,ic-ncav,nmem,
C@PG     -      vol,volscal,avocc
C@PG        end if
C@PG      end do
C@PG      if (nframe .eq. 1)
C@PG     -  write (iout,1002) label(ilab),nslvfound,label(ilab),n_unasstot
C@PG      if (nframe .gt. 1) write (iout,1003)
C@PG     -  label(ilab),float(nslvfound)/float(nframe),
C@PG     -  label(ilab),float(n_unasstot)/float(nframe)
C@PG      return
C@PG1000  format(1x,a6,i5,' (original #:',i5,') # of gridpoints=',i8,
C@PG     -  ' Vol=',f8.1,' A^3 Scaled vol=',f8.1,' A^3 # of solvents=',i7)
C@PG1001  format(1x,a6,i5,' (original #:',i5,') # of gridpoints=',i8,
C@PG     -  ' Vol=',f8.1,' A^3 Scaled vol=',f8.1,' A^3 <# of solvents>=',
C@PG     -  e10.4)
C@PG1002  format(' Total number of ',a,' solvents found=',i4,' number of ',
C@PG     -  'solvents assigned to an ignored ',a,'=',i5)
C@PG1003  format(' <Total number of ',a,' solvents found>=',e10.4,
C@PG     -  ' <number of solvents assigned to an ignored ',a,'>=',e10.4)
C@PG1004  format(1x,a6,' occupancy averages over',i6,' frames:')
C@PG      end
C@PG      subroutine clustergrid(ngrd1_in,itypclst,ncavs,nofcls,mincavcl,
C@PG     -  cvlimcav,rcutcv,rnear2lim,c,istf,nstta,ngleft,ncleft,
C@PG     -  irevindex,nofilt,idb,iout,inperr)
C@PGc*****Create the grid point clusters
C@PGc#    MMC routine 455/c lstmod: 06/23/17
C@PGC@I2      integer*2 ncover
C@PG      dimension c(3,nstta)
C@PG      real*8 ranshift
C@PG      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
C@PG     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
C@PG     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
C@PG     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@PG      common /grdi/ ingr(6,#CV),nngr(#CV),iclstgr(#CV),
C@PG     -  iusedgr(#CV),icavgrid(#CV),ixrevgrd(#CV),
C@PG     -  ifgr(#GC),ilgr(#GC),indexcav(#GC),cvnumx(#CV),
C@PG     -  cvnumy(#CV),cvnumz(#CV),cvden(#CV)
C@PG      common /option/ iop(200),idebug(200)
C@PGc     print *,'CLUSTERGRID ngrd1,itypclst,ncavs=',ngrd1_in,itypclst,
C@PGc    -  ncavs
C@PG      if (ngrd1_in .eq. 0) then
C@PGc       External grid cluster
C@PG        call check_clst(ifgr,ilgr,iclstgr,nofcls,igfree,ncover,
C@PG     -    ng1,iusedgr,inperr,1,'after clstrs call',17,idb,iout,
C@PG     -    #CV,#GC)
C@PG        ngrd1=ilgr(nofcls-1)+1
C@PG        ngrd=ilgr(nofcls)
C@PG      else
C@PGc       Initial clustering
C@PG        ngrd1=ngrd1_in
C@PG        ngrd=ngfree
C@PG        ncavs=0
C@PG      end if
C@PG      if (ngrd .eq. 0) then
C@PG        write (iout,1001)
C@PG        return
C@PG      end if
C@PG      call gridnglist(ngrd1,ngrd,nngr,ingr,igfree,ncover,ngrid,
C@PG     -  ng1,iout,inperr)
C@PG       call checknnlist(ngrd1,ngrd,nngr,ingr,iout,inperr,
C@PG     -   nwwarn,nerr,0,1,2,6,#CV)
C@PG      call clstrs(ingr,nngr,icavgrid,ngrd1,ngrd,iclstgr,ifgr,ilgr,
C@PG     -  ncavs,nofcls,iusedgr,iout,inperr,nww,0,#CV,#GC,6,3,
C@PG     -  idebug(173))
C@PG      call check_clst(ifgr,ilgr,iclstgr,nofcls,igfree,ncover,
C@PG     -  ng1,iusedgr,inperr,1,'after clstrs call',17,idb,iout,
C@PG     -  #CV,#GC)
C@PG      if (itypclst .eq. 1) then
C@PG        ncavs=nofcls-1
C@PG        ncavsfilt=0
C@PG        nofclsfilt=ncavs
C@PGc       Move the external grid cluster to be the last one
C@PG        ngout=0
C@PG        icout=1
C@PG        do ic=1,nofcls
C@PG          nmem=ilgr(ic)-ifgr(ic)+1
C@PG          if (nmem .gt. ngout) then
C@PG            ngout=nmem
C@PG            icout=ic
C@PG          end if
C@PG        end do
C@PG        if (icout .lt. nofcls) then
C@PGc         Move the icout-th cluster to the last place
C@PG          call trnsfi(indexcav,iclstgr(ifgr(icout)),ngout)
C@PG          do ig=ifgr(icout+1),ilgr(nofcls)
C@PG            iclstgr(ig-ngout)=iclstgr(ig)
C@PG          end do
C@PG          do ic=icout+1,nofcls
C@PG            ifgr(ic-1)=ifgr(ic)-ngout
C@PG            ilgr(ic-1)=ilgr(ic)-ngout
C@PG          end do
C@PG          ifgr(nofcls)=ilgr(nofcls-1)+1
C@PG          ilgr(nofcls)=ilgr(nofcls-1)+ngout
C@PG          call trnsfi(iclstgr(ifgr(nofcls)),indexcav,ngout)
C@PG        end if
C@PG        call check_clst(ifgr,ilgr,iclstgr,nofcls,igfree,ncover,
C@PG     -    ng1,iusedgr,inperr,1,'after external cluster move',
C@PG     -    27,idb,iout,#CV,#GC)
C@PG      else
C@PG        nofclsfilt=nofcls
C@PG        ncavsfilt=ncavs
C@PG      end if
C@PG      call sortgridng(nngr,ingr,iclstgr,igfree,ncover,
C@PG     -  ngrd1,ngrd,ixrevgrd,iout,inperr,ng1)
C@PG      call check_clst(ifgr,ilgr,iclstgr,nofcls,igfree,ncover,
C@PG     -  ng1,iusedgr,inperr,1,'after sortgridng call',21,idb,iout,
C@PG     -  #CV,#GC)
C@PG      if (nofilt .eq. 0) then
C@PG        call filtercavs(ngleft,ncleft,ncavsfilt,nofclsfilt,mincavcl,
C@PG     -    cvlimcav,rcutcv,rnear2lim,istf,nstta,c,iout)
C@PG      else
C@PG        ngleft=ilgr(nofcls)
C@PG        if (ncavs .gt. 0) ngleft=ngleft-ilgr(ncavs)
C@PG      end if
C@PG      if (irevindex .eq. 1) then
C@PG        do ic=1,nofcls
C@PG          do ig=1,ifgr(ic),ilgr(ic)
C@PG            iusedgr(iclstgr(ig))=ic
C@PG          end do
C@PG        end do
C@PG      end if
C@PG      return
C@PG1001  format(' ///// NOTE: there are no gridpoints to cluster')
C@PG      end
C@PG      subroutine filtercavs(ngleft,ncleft,ncavs,nofcls,mincavcl,
C@PG     -  cvlimcav,rcutcv,rnear2lim,istf,nstta,c,iout)
C@PGc*****Filter the grid point clusters by size and CV
C@PGc#    MMC routine 455/d lstmod: 05/17/12
C@PG      dimension c(3,nstta)
C@PG      real*8 ranshift
C@PG      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
C@PG     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
C@PG     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
C@PG     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@PG      common /pbcdat/ ivopt(#UV),riijjv(#UV),zv(3,#UV),
C@PG     -  cci(3,#UV)
C@PG      common /grdi/ ingr(6,#CV),nngr(#CV),iclstgr(#CV),
C@PG     -  iusedgr(#CV),icavgrid(#CV),ixrevgrd(#CV),
C@PG     -  ifgr(#GC),ilgr(#GC),indexcav(#GC),cvnumx(#CV),
C@PG     -  cvnumy(#CV),cvnumz(#CV),cvden(#CV)
C@PG      common /worksp/ ireslist(#NA),iatlist(#UV),
C@PG     -  l3(#UV),l4(#UV)
C@PG      dimension r(3),rrc(3)
C@PGc     print *,'FILTERCAVS ncavs=',ncavs,' nofcls=',nofcls
C@PG      ngleft=0
C@PG      ncleft=0
C@PG      ineardrop=0
C@PG      nneardrop=0
C@PG      ncvdrop=0
C@PG      nsizedrop=0
C@PG      do ic=ncavs+1,nofcls
C@PG        call gridclstcent(ifgr(ic),ilgr(ic),iclstgr,zv(1,ic),
C@PG     -    #CV)
C@PG        nmem=ilgr(ic)-ifgr(ic)+1
C@PG        if (nmem .ge. mincavcl) then
C@PG          if (cvlimcav .gt. 0.0) then
C@PG            ncv=0
C@PGc           Filter cavities by CV
C@PG            call zeroit(rrc,3)
C@PG            do is=istf,nstta
C@PG              call arrdiff(r,zv(1,ic),c(1,is),3)
C@PG              rr=sqrt(r(1)**2+r(2)**2+r(3)**2)
C@PG              if (rr .le. rcutcv) then
C@PG                ncv=ncv+1
C@PG                do k=1,3
C@PG                  rrc(k)=rrc(k)+r(k)/rr
C@PG                end do
C@PG              end if
C@PG            end do
C@PG            cvcav=0.0
C@PG            if (ncv .gt. 0) cvcav=1.0-
C@PG     -        sqrt(rrc(1)**2+rrc(2)**2+rrc(3)**2)/float(ncv)
C@PG            if (cvcav .lt. cvlimcav)
C@PG     -        write (iout,1001) ic,nmem,cvcav,(zv(k,ic),k=1,3)
C@PG          else
C@PG            cvcav=1.0
C@PG          end if
C@PG          if (rnear2lim .gt. 0.0) then
C@PGc           Filter out pockets without nearby solute
C@PG            ineardrop=0
C@PG            do ig=ifgr(ic),ilgr(ic)
C@PG              indx=igfree(iclstgr(ig))
C@PG              if (indx .gt. 0) then
C@PG                call unpackijk(indx,ng1,ix,iy,iz)
C@PG                gx=(e2gm(1)+ix*grid(1))
C@PG                gy=(e2gm(2)+iy*grid(2))
C@PG                gz=(e2gm(3)+iz*grid(3))
C@PG                nn=nngr(iclstgr(ig))
C@PG                call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -              ireslist,nreslist,rnear2,rnear2lim,1)
C@PG                if (rnear2 .lt. 100.0) go to 100
C@PG              end if
C@PG            end do
C@PGc           Pocket had no lining solute - drop it
C@PG            ineardrop=1
C@PG            nneardrop=nneardrop+1
C@PG            write (iout,1003) ic,nmem,(zv(k,ic),k=1,3),sqrt(rnear2lim)
C@PG100         continue
C@PG          end if
C@PG          if (ineardrop .eq. 0) then
C@PG            if (cvcav .ge. cvlimcav) then
C@PG              ngleft=ngleft+nmem
C@PG              ncleft=ncleft+1
C@PG              indexcav(ncavs+ncleft)=ic
C@PG            else
C@PG              ncvdrop=ncvdrop+1
C@PG            end if
C@PG          end if
C@PG        else
C@PG          nsizedrop=nsizedrop+1
C@PG        end if
C@PG      end do
C@PG      if (ncleft .eq. nofcls-ncavs) then
C@PG        write (iout,1004) nofcls
C@PG      else
C@PG        if (rnear2lim .gt. 0.0)
C@PG     -    write (iout,1005) 'distance from the solute',nneardrop
C@PG        if (mincavcl .gt. 0) write (iout,1005) 'small size',nsizedrop
C@PG        if (cvlimcav .gt. 0.0) write (iout,1006) cvlimcav,ncvdrop
C@PG        if (ncleft .lt. nofcls-ncavs) then
C@PG          write (iout,1000) nofcls-ncavs-ncleft,ncleft
C@PG        else if (ncleft .eq. 0) then
C@PG          write (iout,1002) nofcls
C@PG        end if
C@PG      end if
C@PG1000  format(' Number of grid clusters dropped=',i6,' leaving',i6,
C@PG     -  ' clusters')
C@PG1001  format(' Cavity # ',i5,' (original), # of members=',i8,
C@PG     -  ' CV=',f6.4,' cent:',3f10.5,' is dropped')
C@PG1002  format(' ///// NOTE: All ',i6,' clusters were filtered out')
C@PG1003  format(' Pocket # ',i5,' (original), # of members=',i8,
C@PG     -  ' cent:',3f10.5,' is dropped since no solute is found within',
C@PG     -  f5.1,' A')
C@PG1004  format(' All ',i6,' clusters are kept')
C@PG1005  format(' Number of grid clusters dropped due to their ',a,i8)
C@PG1006  format(' Number of grid clusters dropped as too  close to the ',
C@PG     -  ' surface (CV <',f6.3,')=',i6)
C@PG      return
C@PG      end
C@PG      subroutine gridclstcent(ifg,ilg,iclst,cent,maxg)
C@PGc     Calculate the coordinates of the center of a grid cluster
C@PGc#    MMC routine 455/d lstmod: 01/18/05
C@PG      dimension iclst(maxg),cent(3)
C@PG      real*8 ranshift
C@PG      common /grid/ ranshift(3),gredge(3),fltng3,grid(3),grid2(3),
C@PG     -  e2g(3),e2gm(3),igfree(#CV),igfn(#PP),
C@PG     -  ncover(#GX,#GY,#GZ),ngdrop,maxgfree,ngfree,ngfreeo,
C@PG     -  nsltfr,ngrid(3),limgrl(3),limgru(3),ng1,ng2,ng3
C@PG      ixmax=0
C@PG      iymax=0
C@PG      izmax=0
C@PG      ixmin=ngrid(1)
C@PG      iymin=ngrid(2)
C@PG      izmin=ngrid(3)
C@PG      do ig=ifg,ilg
C@PG        call unpackijk(igfree(iclst(ig)),ng1,ix,iy,iz)
C@PG        if (ix .lt. ixmin) ixmin=ix
C@PG        if (ix .gt. ixmax) ixmax=ix
C@PG        if (iy .lt. iymin) iymin=iy
C@PG        if (iy .gt. iymax) iymax=iy
C@PG        if (iz .lt. izmin) izmin=iz
C@PG        if (iz .gt. izmax) izmax=iz
C@PG      end do
C@PG      ix=(ixmin+ixmax)/2
C@PG      iy=(iymin+iymax)/2
C@PG      iz=(izmin+izmax)/2
C@PG      cent(1)=(e2gm(1)+ix*grid(1))
C@PG      cent(2)=(e2gm(2)+iy*grid(2))
C@PG      cent(3)=(e2gm(3)+iz*grid(3))
C@PGc      write (6,9671) ix,iy,iz,cent
C@PGc9671  format(' GRIDCLSTCENT ix,iy,iz=',3i4,' cent=',3f10.5)
C@PG      return
C@PG      end
C@PG      subroutine fchargesum(labslt,ifgrslt,ireslist,nreslist,fcharge)
c#C@PG    MMC routine 456 lstmod: 01/18/05
C@PG      character*4 labslt,resnam
C@PG      dimension labslt(2,#ST),ifgrslt(#GR),ireslist(nreslist)
C@PG      fcharge=0.0
C@PG      do ir=1,nreslist
C@PG        resnam=labslt(1,ifgrslt(ireslist(ir)))
C@PG        call leftadjust(resnam,resnam,4)
C@PG        if (resnam(1:3) .eq. 'ASP' .or. resnam(1:3) .eq. 'GLU') then
C@PG          fcharge=fcharge-1.0
C@PG        else if (resnam(1:3) .eq. 'LYS' .or. resnam(1:3) .eq. 'ARG')then
C@PG          fcharge=fcharge+1.0
C@PG        end if
C@PG      end do
C@PG      return
C@PG      end
C@PG      subroutine writeslthead(file,namlenf,filename1,namlen1,ifiltype,
C@PG     -  numrunw,igrdvers,ioutform,istf,nstta,natsp,c,qslt,igrslt,
C@PG     -  labslt,ianslt,ianprt,iatnam,grname,lgrname,chainid,iop24,
C@PG     -  ioutgr,iout)
C@PGc*****Prints the solute part of a grid file
C@PGc#    MMC routine 457 lstmod: 03/20/12
C@PG      character*80 file,filename1
C@PG      character*4 labslt,iatnam
C@PG      character*1 chainid
C@PG      character*(*) grname
C@PG      dimension c(3,#ST),qslt(#ST),igrslt(#ST),labslt(2,#ST),
C@PG     -  ianslt(#ST),ianprt(99),iatnam(99)
C@PG      call fileopen(file,namlenf,filename1,namlen1,
C@PG     -  ifiltype,0,numrunw,igrdvers,3,0,iop24,iversout,iout,ioutgr,0)
C@PG      if (ioutform .eq. 2) then
C@PG        write (ioutgr,1021) 'REMARK',grname(1:lgrname)
C@PG        write (ioutgr,1023)
C@PG        write (ioutgr,1012) (ia,labslt(2,ia),labslt(1,ia)(1:3),chainid,
C@PG     -    igrslt(ia),(c(k,ia),k=1,3),qslt(ia),ia=istf,nstta)
C@PG        write (ioutgr,2014) 'TER'
C@PG      else if (ioutform .eq. 3) then
C@PG        write (ioutgr,1021) '*',grname(1:lgrname)
C@PG        write (ioutgr,1020) natsp
C@PG        write (ioutgr,1022) (ia,igrslt(ia),(labslt(ii,ia),ii=1,2),
C@PG     -    (c(k,ia),k=1,3),'SLTE',ia,qslt(ia),ia=istf,nstta)
C@PG      else if (ioutform .eq. 4) then
C@PG        write (ioutgr,1001) natsp
C@PG        write (ioutgr,1002) (iatnam(ianprt(ianslt(i))),
C@PG     -    (c(k,i),k=1,3),igrslt(i),qslt(i),i=istf,nstta)
C@PG      end if
C@PG      return
C@PG1001  format(i5)
C@PG1020  format('* ',/,i5)
C@PG1021  format(a,' Grid file for the ',a)
C@PG1023  format('REMARK Temperature-factor column gives the cavity number')
C@PG1012  format('ATOM ',i6,1x,a4,1x,a3,1x,a1,i4,4x,3f8.3,'  1.00',f5.0)
C@PG1022  format(i5,i5,1x,a4,1x,a4,3f10.5,1x,a4,1x,i4,f10.5)
C@PG1002  format(a4,1x,3f15.5,i5,f10.5)
C@PG2014  format(a3)
C@PG      end
C@PG      subroutine printreslist(ireslist,ifgrslt,labslt,nreslist,iatlist,
C@PG     -  natlist,iborderprt,index,iout,maxat)
c*****PrintsC@PG the pocket -linig residues, sorted by residue number
c#    MMC routine 457/1 lstmod: 05/02/06
C@PG      dimension ireslist(nreslist),ifgrslt(maxat),index(nreslist),
C@PG     -  iatlist(natlist)
C@PG      dimension it1(100),it2(100),it3(100),t1(100),t2(100)
C@PG      character*4 labslt(2,maxat)
C@PG      call indexit(index,1,nreslist,0)
C@PG      if (nreslist .le. 100) then
C@PG        do i=1,nreslist
C@PG          t1(i)=ireslist(i)
C@PG        end do
C@PG        call mrgsrt(iout,index,t1,nreslist,it1,it2,it3,t2,maxat)
C@PG      else
C@PG        write (iout,2000)
C@PG      end if
C@PG      if (mod(iborderprt,2) .eq. 0)
C@PG     -  write (iout,2001) (ireslist(index(irs)),
C@PG     -    labslt(1,ifgrslt(ireslist(index(irs)))),irs=1,nreslist)
C@PG      if (iborderprt .gt. 2) write (iout,2002) (iatlist(ia),
C@PG     -   (labslt(k,iatlist(ia)),k=2,1,-1),ia=1,natlist)
C@PG      return
C@PG2000  format(' NOTE: residue list exceeds 100 - did not sort it')
C@PG2001  format((8x,'Contact residues: ',9(i4,1x,a4,1x)))
C@PG2002  format((8x,'Contact atoms:',11x,6(i6,1x,a4,1x,a4)))
C@PG      end
      subroutine nopbcgr(igx,ixf,ngx,cx,maxgx)
c*****Eliminates periodic images of gridpoints
c#    MMC routine 458 lstmod: 03/05/12
      dimension igx(maxgx)
      if (ngx .eq. 2) then
c       Sign of coordinate will decide which grid is the image grid
        if (igx(1) .gt. igx(2)) then
          if (cx .lt. 0.0) then
            ixf=2
          else
            ixf=1
            ngx=1
          end if
        end if
      else
        ixf=1
        ixc=(ngx+1)/2
        if (igx(ixc-1) .gt. igx(ixc)) then
          ixf=ixc
        else if (igx(ixc+1) .lt. igx(ixc)) then
          ngx=ixc
        else
          ix=1
          do while (ix .lt. ixc-1 .and. igx(ix) .lt. igx(ix+1))
            ix=ix+1
          end do
          if (igx(ix) .gt. igx(ix+1)) ixf=ix+1
          ix=ngx
          do while (ix .gt. ixc+1 .and. igx(ix) .gt. igx(ix-1))
            ix=ix-1
          end do
          if (igx(ix) .lt. igx(ix-1)) ngx=ix-1
        end if
      end if
      return
      end
C@PG      subroutine gridnglist(ngrd1,ngrd,nngr,ingr,igfree,ncover,ngrid,
C@PG     -  ng1,iout,inperr)
C@PGc#    MMC routine 459 lstmod: 03/06/12
C@PGc*****Sets up the grid neigbour list
C@PG      dimension nngr(#CV),ingr(6,#CV),igfree(#CV),
C@PG     -  ncover(#GX,#GY,#GZ),ngrid(3)
C@PGc     print *,'GRIDNGLIST ngrd1,ngrd=',ngrd1,ngrd
C@PG      call zeroiti(nngr,0,#CV)
C@PGc     Set up neighbor list
C@PG      do ig=ngrd1,ngrd
C@PG        indx=igfree(ig)
C@PG        call unpackijk(indx,ng1,ix,iy,iz)
C@PG        if (ncover(ix,iy,iz) .ge. 0) then
C@PG          write (iout,1000) ig,indx,ix,iy,iz,ncover(ix,iy,iz)
C@PG          inperr=inperr+1
C@PG          stop
C@PG        else if (-ncover(ix,iy,iz) .ne. ig) then
C@PG          write (iout,1001) ix,iy,iz,-ncover(ix,iy,iz),ig
C@PG          inperr=inperr+1
C@PG        end if
C@PGc       Scan neighboring cells in ncover
C@PG        do ixx=ix-1,ix+1
C@PG          do iyy=iy-1,iy+1
C@PG            do izz=iz-1,iz+1
C@PG              ndiff=(ix-ixx)**2+(iy-iyy)**2+(iz-izz)**2
C@PG              if (ndiff .eq. 1) then
C@PG                ixxx=ixx
C@PG                if (ixx .lt. 1) ixxx=ngrid(1)
C@PG                if (ixx .gt. ngrid(1)) ixxx=1
C@PG                iyyy=iyy
C@PG                if (iyy .lt. 1) iyyy=ngrid(2)
C@PG                if (iyy .gt. ngrid(2)) iyyy=1
C@PG                izzz=izz
C@PG                if (izz .lt. 1) izzz=ngrid(3)
C@PG                if (izz .gt. ngrid(3)) izzz=1
C@PG                if (ncover(ixxx,iyyy,izzz) .lt. 0) then
C@PG                  igg=-ncover(ixxx,iyyy,izzz)
C@PG                  nngr(ig)=nngr(ig)+1
C@PG                  ingr(nngr(ig),ig)=igg
C@PG                end if
C@PG              end if
C@PG            end do
C@PG          end do
C@PG        end do
C@PG        if (nngr(ig) .lt. 6) then
C@PGc         Search for possible farther neighbours
C@PG          do ixx=ix-1,ix+1
C@PG            do iyy=iy-1,iy+1
C@PG              do izz=iz-1,iz+1
C@PG                ndiff=(ix-ixx)**2+(iy-iyy)**2+(iz-izz)**2
C@PG                if (ndiff .eq. 2) then
C@PG                  ixxx=ixx
C@PG                  if (ixx .lt. 1) ixxx=ngrid(1)
C@PG                  if (ixx .gt. ngrid(1)) ixxx=1
C@PG                  iyyy=iyy
C@PG                  if (iyy .lt. 1) iyyy=ngrid(2)
C@PG                  if (iyy .gt. ngrid(2)) iyyy=1
C@PG                  izzz=izz
C@PG                  if (izz .lt. 1) izzz=ngrid(3)
C@PG                  if (izz .gt. ngrid(3)) izzz=1
C@PG                  if (ncover(ixxx,iyyy,izzz) .lt. 0) then
C@PG                    igg=-ncover(ixxx,iyyy,izzz)
C@PG                    nngr(ig)=nngr(ig)+1
C@PG                    ingr(nngr(ig),ig)=igg
C@PG                    if (nngr(ig) .eq. 6) go to 100
C@PG                  end if
C@PG                end if
C@PG              end do
C@PG            end do
C@PG          end do
C@PG        end if
C@PG        if (nngr(ig) .lt. 6) then
C@PGc         Search for possible farther neighbours
C@PG          do ixx=ix-1,ix+1
C@PG            do iyy=iy-1,iy+1
C@PG              do izz=iz-1,iz+1
C@PG                ndiff=(ix-ixx)**2+(iy-iyy)**2+(iz-izz)**2
C@PG                if (ndiff .eq. 3) then
C@PG                  ixxx=ixx
C@PG                  if (ixx .lt. 1) ixxx=ngrid(1)
C@PG                  if (ixx .gt. ngrid(1)) ixxx=1
C@PG                  iyyy=iyy
C@PG                  if (iyy .lt. 1) iyyy=ngrid(2)
C@PG                  if (iyy .gt. ngrid(2)) iyyy=1
C@PG                  izzz=izz
C@PG                  if (izz .lt. 1) izzz=ngrid(3)
C@PG                  if (izz .gt. ngrid(3)) izzz=1
C@PG                  if (ncover(ixxx,iyyy,izzz) .lt. 0) then
C@PG                    igg=-ncover(ixxx,iyyy,izzz)
C@PG                    nngr(ig)=nngr(ig)+1
C@PG                    ingr(nngr(ig),ig)=igg
C@PG                    if (nngr(ig) .eq. 6) go to 100
C@PG                  end if
C@PG                end if
C@PG              end do
C@PG            end do
C@PG          end do
C@PG        end if
C@PG100     continue
C@PG      end do
C@PG      return
C@PG1000  format(' ***** PROGRAM ERROR: free grid # ',i8,' is not free',
C@PG     -  ' indx=',i9,' ix,iy,iz=',3i6,' ncover=',i9)
C@PG1001  format(' ***** PROGRAM ERROR: grid(',i3,',',i3,',',i3,') ',
C@PG     -  ' points to grid list ',i9,' instead of ',i9)
C@PG      end
      subroutine addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
     -  ireslist,nreslist,rnear2,rnear2lim,itestonly)
c#    MMC routine 460 lstmod: 03/20/12
c*****Possible boundary grid - get proximal residue
      dimension iatlist(#UV),ireslist(#UV),c(3,#NA)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      dimension gr(3)
c     Skip for grids inside the cluster
      if (nn .eq. 6) return
      gr(1)=gx
      gr(2)=gy
      gr(3)=gz
      nsltres=igrslt(nstta)
      rnear2=100.0
      ignear=0
      do isr=1,nsltres
        if (arrdist(c(1,igrcnt(isr)),gr) .lt. 100.0) then
c         Residue center within rnearlim
          do ia=ifgrslt(isr),ilgrslt(isr)
            if (ianslt(ia) .gt. 1) then
              dd2=arrdist(c(1,ia),gr)
              if (dd2 .lt. rnear2) then
                rnear2=dd2
                ignear=isr
                if (itestonly .eq. 1) return
              end if
              if (dd2 .lt. rnear2lim)
     -          call addlist(iatlist,natlist,ia,#UV)
            end if
          end do
        end if
      end do
      if (rnear2 .lt. rnear2lim)
     -  call addlist(ireslist,nreslist,ignear,#UV)
      return
      end
      subroutine addlist(list,nlist,iadd,maxlist)
c#    MMC routine 460/a lstmod: 04/05/05
c*****Add to list - avoid duplicates
      dimension list(maxlist)
      isr=1
      do while (iadd .ne. list(isr) .and. isr .lt. nlist)
        isr=isr+1
      end do
      if (list(isr) .ne. iadd) then
        nlist=nlist+1
        list(nlist)=iadd
      end if
      return
      end
      subroutine printgridatom(indx,ng1,iagrd,iagrdp,iggrd,iggrdp,
     -  nwwarn,iout,ioutgr,glab,clab,cvd,ioutform,icprt,e2gm,grid,
     -  gx,gy,gz)
c#    MMC routine 461 lstmod: 03/13/07
c*****Print an atom record for a grid point
      dimension e2gm(3),grid(3)
      character*(*) glab
      character*1 clab
      call unpackijk(indx,ng1,ix,iy,iz)
      gx=(e2gm(1)+ix*grid(1))
      gy=(e2gm(2)+iy*grid(2))
      gz=(e2gm(3)+iz*grid(3))
      if (ioutform .eq. 2) then
        call pdblim('PRTG',iagrd,iagrdp,999999,'atomnum',7,nwwarn,iout)
        call pdblim('PRTG',iggrd,iggrdp,9999,'atomnum',8,nwwarn,iout)
        write (ioutgr,1012) iagrdp,' He ',glab(1:3),clab,iggrdp,
     -    gx,gy,gz,cvd
      else if (ioutform .eq. 3) then
        call pdblim('PRTG',iagrd,iagrdp,99999,'atomnum',7,nwwarn,iout)
        call pdblim('PRTG',iggrd,iggrdp,99999,'atomnum',8,nwwarn,iout)
        write (ioutgr,1022) iagrdp,iggrdp,'He  ','GRID',gx,gy,gz,glab,
     -    icprt,cvd
      else if (ioutform .eq. 4) then
        call pdblim('PRTG',iggrd,iggrdp,99999,'atomnum',9,nwwarn,iout)
        write (ioutgr,1003) gx,gy,gz,iggrdp
      end if
      return
1003  format('  He ',3f15.5,i5,' 0.0')
1012  format('ATOM ',i6,1x,a4,1x,a3,1x,a1,i4,4x,3f8.3,'  1.00',f5.2)
1022  format(i5,i5,1x,a4,1x,a4,3f10.5,1x,a4,1x,i4,f10.5)
      end
C@PG      subroutine sortgridng(nng,ing,iclst,igfree,ncover,ngrid1,ngrid,
C@PG     -  index,iout,inperr,ng1)
C@PGc#    MMC routine 461/a lstmod: 02/21/06
C@PGc*****Sort the gridpoints to keep grids in the same cluster contiguous
C@PG      dimension nng(ngrid),ing(6,ngrid),iclst(ngrid),igfree(ngrid),
C@PG     -  ncover(#GX,#GY,#GZ),index(ngrid)
C@PG      dimension ing_ggg(14)
C@PGc     Establish the reverse indexing
C@PG      do ig=ngrid1,ngrid
C@PG        index(iclst(ig))=ig
C@PG      end do
C@PG      do ig=ngrid1,ngrid
C@PGc       Swap ig and iclst(ig)
C@PG        igg=iclst(ig)
C@PG        if (index(igg) .ne. ig) then
C@PG          write (iout,1000) 'index',igg,ig,index(igg)
C@PG          inperr=inperr+1
C@PG        end if
C@PGc       Gather neighbors of ig and igg
C@PG        call trnsfi(ing_ggg,ing(1,ig),nng(ig))
C@PG        nng_ggg=nng(ig)
C@PG        do i=1,nng(igg)
C@PG          ingi=ing(i,igg)
C@PG          nfound=0
C@PG          do j=1,nng(ig)
C@PG            if (ing_ggg(j) .eq. ingi) nfound=1
C@PG          end do
C@PG          if (nfound .eq. 0) then
C@PG            nng_ggg=nng_ggg+1
C@PG            ing_ggg(nng_ggg)=ingi
C@PG          end if
C@PG        end do
C@PG        nfound=0
C@PG        do j=1,nng_ggg
C@PG          if (ing_ggg(j) .eq. ig) nfound=1
C@PG        end do
C@PG        if (nfound .eq. 0) then
C@PG          nng_ggg=nng_ggg+1
C@PG          ing_ggg(nng_ggg)=ig
C@PG        end if
C@PG        nfound=0
C@PG        do j=1,nng_ggg
C@PG          if (ing_ggg(j) .eq. igg) nfound=1
C@PG        end do
C@PG        if (nfound .eq. 0) then
C@PG          nng_ggg=nng_ggg+1
C@PG          ing_ggg(nng_ggg)=igg
C@PG        end if
C@PGc       Change index in the neighbor list of neighbors
C@PG        do i=1,nng_ggg
C@PG          ingi=ing_ggg(i)
C@PG          do j=1,nng(ingi)
C@PG            if (ing(j,ingi) .eq. ig) then
C@PG              ing(j,ingi)=igg
C@PG            else if (ing(j,ingi) .eq. igg) then
C@PG              ing(j,ingi)=ig
C@PG            end if
C@PG          end do
C@PG        end do
C@PGc       Swap neighbor lists
C@PG        do i=1,6
C@PG          call swapi(ing(i,ig),ing(i,igg))
C@PG        end do
C@PG        call swapi(nng(ig),nng(igg))
C@PG        call unpackijk(igfree(ig),ng1,ix,iy,iz)
C@PG        ncover(ix,iy,iz)=-igg
C@PG        call unpackijk(igfree(igg),ng1,ix,iy,iz)
C@PG        ncover(ix,iy,iz)=-ig
C@PG        call swapi(igfree(ig),igfree(igg))
C@PG        iggg=index(ig)
C@PG        iclst(iggg)=igg
C@PG        index(igg)=iggg
C@PG        iclst(ig)=ig
C@PG        index(ig)=ig
C@PG      end do
C@PG      do ig=ngrid1,ngrid
C@PG        if (iclst(ig) .ne. ig) then
C@PG          write (iout,1000) 'iclst',ig,ig,iclst(ig)
C@PG          inperr=inperr+1
C@PG        end if
C@PG        if (index(ig) .ne. ig) then
C@PG          write (iout,1000) 'index',ig,ig,index(ig)
C@PG          inperr=inperr+1
C@PG        end if
C@PG      end do
C@PG      return
C@PG1000  format(' ***** PROGRAM ERROR in sortgridng: ',a,'(',i9,
C@PG     -  ') NE ',i9,' but ',i9)
C@PG      end
C@PG      subroutine shavesplit(nlshave,nngr,ingr,ifrstcl,nofcls,ifgr,ilgr,
C@PG     -  indexcav,iusedgr,iclstgr,e2gm,grid,glab,label,natprint,
C@PG     -  nresprint,itemp1,itemp2,itemp3,ctemp,iborderprt,gridvol,
C@PG     -  c,labslt,ifgrslt,igfree,mincl,maxnnsurf,noputbacksfg,rnear2lim,
C@PG     -  iout,ioutform,ioutgr,inperr,nwwarn,ng1)
C@PGc#    MMC routine 461/b lstmod: 04/04/22
C@PG      dimension nngr(#CV),ingr(6,#CV),ifgr(#GC),
C@PG     -  ilgr(#GC),iclstgr(#CV),indexcav(#GC),
C@PG     -   iusedgr(#CV),c(3,#NA),igfree(#CV),
C@PG     -   e2gm(3),grid(3),ifgrslt(#GR),
C@PG     -   itemp1(#UV),itemp2(#UV),itemp3(#UV),ctemp(3,#UV)
C@PG      dimension gxyz(3)
C@PG      character*(*) glab
C@PG      character*4 labslt(2,#ST)
C@PG      character*6 label
C@PG      character*10 chainlab
C@PG      common /option/ iop(200),idebug(200)
C@PG      common /worksp/ ireslist(#NA),iatlist(#UV),
C@PG     -  l3(#UV),l4(#UV)
C@PG      noputback=noputbacksfg
C@PG      chainlab=' '
C@PG      lchainlab=1
C@PG      if (ioutform .eq. 2) then
C@PG        write (ioutgr,2014) 'TER'
C@PG        chainlab='chainid=S'
C@PG        lchainlab=10
C@PG      end if
C@PGc     Shave off nlshave layers of each cluster; print if cluster splits
C@PG      write (iout,3003) nlshave,maxnnsurf
C@PG      if (noputback .eq. 1) write (iout,3008) ' NOT '
C@PG      if (noputback .eq. 0) write (iout,3008) ' '
C@PG      iagrd=natprint
C@PG      iggrd=nresprint
C@PG      igrdf=ifgr(ifrstcl)
C@PG      igrdl=ilgr(nofcls)
C@PG      do ic=ifrstcl,nofcls
C@PG        ntotgrid=ilgr(ic)-ifgr(ic)+1
C@PG        ngsdrop=0
C@PG        ngic1=ilgr(ic)-ifgr(ic)
C@PG        do il=1,nlshave
C@PG          ngsdrop0=ngsdrop
C@PG          do ig=ifgr(ic),ilgr(ic)
C@PG            if (nngr(ig) .ge. 0 .and. nngr(ig) .le. maxnnsurf .and.
C@PG     -          ngsdrop .lt. ngic1) then
C@PGc             Surface grid - add to list of dropped grids, but don't
C@PGc             empty the cluster
C@PG              ngsdrop=ngsdrop+1
C@PG              if (ngsdrop .le. #UV) then
C@PG                itemp1(ngsdrop)=ig
C@PG              end if
C@PG            end if
C@PG          end do
C@PG          do igg=ngsdrop0+1,ngsdrop
C@PGc           Surface grid - eliminate from nn list
C@PG            ig=itemp1(igg)
C@PG            do in=1,nngr(ig)
C@PG              inn=ingr(in,ig)
C@PGc             Move ig to the end of the list of inn
C@PG              nfound=0
C@PG              do jn=1,nngr(inn)-1
C@PG                if (ingr(jn,inn) .eq. ig) then
C@PG                  call swapi(ingr(jn,inn),ingr(nngr(inn),inn))
C@PG                  nfound=1
C@PG                end if
C@PG              end do
C@PG              if (nfound .eq. 0 .and. ingr(nngr(inn),inn) .ne. ig) then
C@PG                write (iout,3000) ig,inn
C@PG                inperr=inperr+1
C@PG              else
C@PG                nngr(inn)=nngr(inn)-1
C@PG              end if
C@PG            end do
C@PG            nngr(ig)=-1
C@PG          end do
C@PG        end do
C@PG        if (ngsdrop .gt. #UV .and. noputback .eq. 0) then
C@PG          write (iout,3006) label,ic,'surface',ngsdrop,'UV'
C@PG          write (iout,3009)
C@PG          noputback=1
C@PG        end if
C@PG        if (idebug(126) .gt. 0) call checknnlist(ifgr(ic),
C@PG     -    ilgr(ic),nngr,ingr,iout,inperr,nwwarn,1,nerr,1,0,6,#CV)
C@PGc       Count remaining gridpoints
C@PG        ngleft=ntotgrid-ngsdrop
C@PG        if (ntotgrid .ge. mincl) then
C@PG          call clstrs(ingr,nngr,indexcav,ifgr(ic),ilgr(ic),iclstgr,
C@PG     -      l3,l4,0,nofclsic,iusedgr,iout,inperr,nww,0,
C@PG     -      #CV,#CV,6,3,0)
C@PG          nwwarn=nwwarn+nww
C@PG          if (nofclsic .gt. #UV) then
C@PG            write (iout,3001) nofclsic,#UV,'UV'
C@PG            call datprt(2)
C@PG          end if
C@PGc         Eliminate the dropped grids
C@PG          ncdel=0
C@PG          ncsmall=0
C@PG          do jc=1,nofclsic
C@PG            ngjc=l4(jc)-l3(jc)+1
C@PG            if (ngjc .le. 1 .and. nngr(iclstgr(l3(jc))) .lt. 0) then
C@PG              ncdel=ncdel+1
C@PG            else
C@PGc             Shift down l3,l4
C@PG              l3(jc-ncdel)=l3(jc)
C@PG              l4(jc-ncdel)=l4(jc)
C@PG            end if
C@PG          end do
C@PG          if (noputback .eq. 0 .and. ncdel .ne. ngsdrop) then
C@PG            write (iout,3013) label,ic,'Number of grids dropped',
C@PG     -        ngsdrop,'number of dropped clusters',ncdel
C@PG            inperr=inperr+1
C@PG          end if
C@PG          write (iout,3004) label,ic,ntotgrid,ngleft,nofclsic,ncdel
C@PG          nofclsic=nofclsic-ncdel
C@PG          nclp=nofclsic
C@PG          if (noputback .eq. 1) nclp=nofclsic-ncsmall
C@PG          if (nclp .gt. 1) then
C@PGc           Cluster did split into more than one piece - print
C@PG            nclgrprt=0
C@PG            if (noputback .eq. 0) then
C@PGc             Establish original subcluster index for each gridpoint
C@PG              call zeroiti(iusedgr,ifgr(ic)-1,ntotgrid)
C@PG              ngcoreleft=0
C@PG              do jc=1,nofclsic
C@PG                do ig=l3(jc),l4(jc)
C@PG                  iusedgr(iclstgr(ig))=jc
C@PG                  if (iclstgr(ig) .lt. ifgr(ic) .or.
C@PG     -                iclstgr(ig) .gt. ilgr(ic)) then
C@PG                    write (iout,3011) ic,jc,ig,iclstgr(ig),
C@PG     -                ifgr(ic),ilgr(ic)
C@PG                    inperr=inperr+1
C@PG                  end if
C@PG                  ngcoreleft=ngcoreleft+1
C@PGc                 Save the coordinates of the core grids
C@PG                  indexcav(ngcoreleft)=iclstgr(ig)
C@PG                  if (ngcoreleft .gt. #UV) then
C@PG                    write (iout,3010) ic,ngcoreleft,'UV'
C@PG                    write (iout,3009)
C@PG                    noputback=1
C@PG                  else
C@PG                    indx=igfree(iclstgr(ig))
C@PG                    call unpackijk(indx,ng1,ix,iy,iz)
C@PG                    ctemp(1,ngcoreleft)=(e2gm(1)+ix*grid(1))
C@PG                    ctemp(2,ngcoreleft)=(e2gm(2)+iy*grid(2))
C@PG                    ctemp(3,ngcoreleft)=(e2gm(3)+iz*grid(3))
C@PG                  end if
C@PG                end do
C@PG              end do
C@PG            end if
C@PG            if (noputback .eq. 0) then
C@PG              do igd=1,ngsdrop
C@PGc               Find out which subcluster itemp1(igd) belongs to
C@PG                indx=igfree(itemp1(igd))
C@PG                call unpackijk(indx,ng1,ix,iy,iz)
C@PG                gxyz(1)=(e2gm(1)+ix*grid(1))
C@PG                gxyz(2)=(e2gm(2)+iy*grid(2))
C@PG                gxyz(3)=(e2gm(3)+iz*grid(3))
C@PG                rmin2=100000.0
C@PG                do ig=1,ngcoreleft
C@PG                  rgg2=arrdist(gxyz,ctemp(1,ig))
C@PG                  if (rgg2 .lt. rmin2) then
C@PG                    rmin2=rgg2
C@PG                    ignear=indexcav(ig)
C@PG                  end if
C@PG                end do
C@PGc               Grid ig is nearest to non-deleted grid ignear
C@PG                itemp2(igd)=iusedgr(ignear)
C@PG                if (iusedgr(ignear) .lt. 1 .or.
C@PG     -              iusedgr(ignear) .gt. nofclsic) then
C@PG                  write (iout,3012) ic,igd,ignear,iusedgr(ignear),
C@PG     -              nofclsic,ifgr(ic),ilgr(ic)
C@PG                  inperr=inperr+1
C@PG                end if
C@PG              end do
C@PG            end if
C@PG            ngdel=ntotgrid-ngleft
C@PG            ngsubtot=l4(nofclsic)-l3(1)+1
C@PG            jcprint=0
C@PG            do jc=1,nofclsic
C@PG              ngjc=l4(jc)-l3(jc)+1
C@PG              jcprint=jcprint+1
C@PG              iggrd=iggrd+1
C@PG              nreslist=0
C@PG              natlist=0
C@PG              do ig=l3(jc),l4(jc)
C@PG                indx=igfree(iclstgr(ig))
C@PG                iagrd=iagrd+1
C@PG                call printgridatom(indx,ng1,iagrd,iagrdp,iggrd,iggrdp,
C@PG     -            nwwarn,iout,ioutgr,glab,'S',0.0,ioutform,jcprint,
C@PG     -            e2gm,grid,gx,gy,gz)
C@PG                nn=nngr(iclstgr(ig))
C@PG                call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -            ireslist,nreslist,rnear2,rnear2lim,0)
C@PG              end do
C@PG              if (noputback .eq. 0) then
C@PGc               Add back the surface grids dropped
C@PG                ngssub=0
C@PG                do igd=1,ngsdrop
C@PG                  if (itemp2(igd) .lt. 1 .or.
C@PG     -                itemp2(igd) .gt. nofclsic) then
C@PG                    write (iout,3007) ic,ig,itemp2(igd),
C@PG     -                nofclsic
C@PG                    inperr=inperr+1
C@PG                    itemp2(ig)=#CV
C@PG                  end if
C@PG                  ig=itemp1(igd)
C@PG                  if (itemp2(igd) .eq. jc) then
C@PG                    ngssub=ngssub+1
C@PG                    indx=igfree(ig)
C@PG                    iagrd=iagrd+1
C@PG                    call printgridatom(indx,ng1,iagrd,iagrdp,iggrd,
C@PG     -                iggrdp,nwwarn,iout,ioutgr,glab,'S',0.0,
C@PG     -                ioutform,jc,e2gm,grid,gx,gy,gz)
C@PG                      nn=nngr(ig)
C@PG                    call addgridpx(nn,gx,gy,gz,c,iatlist,natlist,
C@PG     -                ireslist,nreslist,rnear2,rnear2lim,0)
C@PG                  end if
C@PG                end do
C@PG                ngjctot=ngjc+ngssub
C@PG                nclgrprt=nclgrprt+ngjctot
C@PG              else
C@PGc               Add the proportional part of the shaved grids
C@PG                ngjctot=ngjc+ngdel*float(ngjc)/float(ngsubtot)
C@PG                nclgrprt=nclgrprt+ngjc
C@PG              end if
C@PG              call fchargesum(labslt,ifgrslt,ireslist,nreslist,fc)
C@PG              write (iout,3002) label,ic,jcprint,iggrd,glab,
C@PG     -          chainlab(1:lchainlab),ngjc,ngjctot,ngjctot*gridvol,fc
C@PG              call printreslist(ireslist,ifgrslt,labslt,nreslist,
C@PG     -          iatlist,natlist,iborderprt,itemp3,iout,#ST)
C@PG            end do
C@PG            if (nclgrprt .ne. ntotgrid .and. noputback .eq. 0) then
C@PG              write (iout,3013) ic,ig,'number of grids printed',
C@PG     -         nclgrprt,'number of cluster grids',ntotgrid
C@PG              inperr=inperr+1
C@PG            end if
C@PG          end if
C@PG        end if
C@PG      end do
C@PG      if (ioutform .ne. 2) write (iout,3005) natprint,iagrd
C@PG      return
C@PG2014  format(a3)
C@PG3000  format(' ***** PROGRAM ERROR in shaving: grid ',i9,' is not on ',
C@PG     -  'the nn list of grid',i9)
C@PG3001  format(' ***** ERROR in shaving: number of subclusters(',i9,
C@PG     -  ' exceeds the dimension of the program (',i9,/,
C@PG     -  7x,' increase the size of the #',a,' arrays')
C@PG3002  format(1x,a,i6,' subcluster ',i3,' residue=',i6,' resname=',a,1x,
C@PG     -  a,/,14x,'reduced number of grids=',i8,' corrected number of ',
C@PG     -  'grids=',i8,' volume estimate=',f11.2,' A**3 Formal charge=',
C@PG     -  f5.1)
C@PG3003  format(/,' Attempting to find subclusters by shaving ',i2,
C@PG     -  ' layers off each cluster',/,' Grids with',i2,', or less',
C@PG     -  ' neighbors will be considered surface grids and will be ',
C@PG     -  'shaved off')
C@PG3004  format(1x,a,i6,' original number of gridpoints=',i8,' number ',
C@PG     -  'of gridpoints left after shaving=',i8,/,14x,'Number of ',
C@PG     -  'subclusters=',i5, ' number of subclusters dropped=',i5)
C@PG3005  format(' IMPORTANT: change the number of atoms from',i8,' to',
C@PG     -  i8)
C@PG3006  format(' ----- WARNING: ',a,'#',i8,': number of ',a,' grids (',
C@PG     -  i10,') exceeds the program dimension - increase the dimension',
C@PG     -  ' #',a)
C@PG3007  format(' ***** PROGRAM ERROR in shaving: cluster ',i5,' grid ',i9,
C@PG     - 'itemp2(ig)=',i9,' is outside the [1,',i4,'] range')
C@PG3008  format(' Grids shaved off as surface grids will',a,'be put back',
C@PG     - ' to the subcluster they were shaved off from')
C@PG3009  format(' Surface grids will be left off')
C@PG3010  format(' ----- WARNING: cluster ',i5,'  has too many elements (',
C@PG     -  i9,')  increase the dimension #',a)
C@PG3011  format(' ***** PROGRAM ERROR in shaving: cluster ',i5,
C@PG     -  ' subcluster',i3,' grid ',i9,': iclst(ig)=',i9,
C@PG     -  'is out of [',i9,',',i9,']')
C@PG3012  format(' ***** PROGRAM ERROR in shaving: cluster ',i5,
C@PG     -  ' sf grid',i9,' prox grid ',i9,' subclass=',i4,
C@PG     -  'is out of [1,',i6,'], ifc,ilc=',2i9)
C@PG3013  format(' ***** PROGRAM ERROR in shaving: ',a,' cluster ',i5,': ',
C@PG     -  a,' (',i8,') .ne. ',a,' (',i8,')')
C@PG      end
C@DB      subroutine checklist(ifg,ilg,iclst,label,iout)
C@DBc#    MMC routine 461/c lstmod: 03/02/06
C@DBc*****Check a list of numbers for duplicates (inefficient, needs sorting)
C@DB      character*(*) label
C@DB      dimension iclst(ilg)
C@DB      do i=ifg,ilg-1
C@DB        do j=i+1,ilg
C@DB          if (iclst(i) .eq. iclst(j)) then
C@DB            nerr=nerr+1
C@DB            write (iout,1000) label,i,j,iclst(i)
C@DB          end if
C@DB        end do
C@DB      end do
C@DB      if (nerr .eq. 0) write (iout,1001) label
C@DB      return
C@DB1000  format(' LIST ERROR for ',a,' i=',i9,' j=',i9,
C@DB     -  ' identical list entries:',i8)
C@DB1001  format(' List ',a,' has no duplicates')
C@DB      end
C@DB      subroutine printloopdat(lab,llab,itor,iquata,looplist,
C@DB     -  iprecursor,nrot,irotlist,irotlinc,bond,bond2,angle,cangle,
C@DB     -  bond13,bond12,angle13,cangle13,bondf,bondproj,xfac13,xfac12,
C@DB     -  iout,maxat,maxtor,maxlooptor)
C@DBc#    MMC routine 461/d lstmod: 05/18/15
C@DBc*****print the distance and angle data saved for a loop
C@DB      character*(*) lab
C@DB      dimension iquata(maxtor,6),looplist(6,maxlooptor),
C@DB     -  iprecursor(2,maxat),nrot(maxat),irotlist(maxat),irotlinc(maxat),
C@DB     -  bond(maxat),bond2(maxat),angle(maxat),cangle(maxat),
C@DB     -  bond13(maxat),bond12(maxat),angle13(maxat),cangle13(maxat),
C@DB     -  bondf(maxat),bondproj(maxat),xfac13(maxat),xfac12(maxat)
C@DB      common /looptorsave/ bondo(#LS),bond2o(#LS),bond12o(#LS),
C@DB     -  bond13o(#LS),cangleo(#LS),cangle13o(#LS),bondfo(#LS),
C@DB     -  bondprojo(#LS),xfac12o(#LS),xfac13o(#LS),angleo(#LS),
C@DB     -  angle13o(#LS)
C@DB      do itt=1,6
C@DB        it=looplist(itt,itor)
C@DB        i1=iquata(it,1)
C@DB        i2=iquata(it,2)
C@DB        i3=iquata(it,3)
C@DB        write (iout,7711) lab(1:llab),'N',itor,it,i1,i2,i3,
C@DB     -    bond(i3),bond2(i3),bond12(i3),bond13(i3),cangle(i3),
C@DB     -    cangle13(i3),angle(i3),angle13(i3)
C@DB      end do
C@DB      do itt=1,6
C@DB        it=looplist(itt,itor)
C@DB        i1=iquata(it,1)
C@DB        i2=iquata(it,2)
C@DB        i3=iquata(it,3)
C@DB        write (iout,7711) lab(1:llab),'O',itor,it,i1,i2,i3,
C@DB     -    bondo(i3),bond2o(i3),bond12o(i3),bond13o(i3),cangleo(i3),
C@DB     -    cangle13o(i3),angleo(i3),angle13o(i3)
C@DB      end do
C@DB      return
C@DB7711  format(1x,a,'-',a,': itor,it=',2i5,' i1,2,3=',3i6,' b3=',f6.4,
C@DB     -  ' b2=',f6.4,' b12=',f6.4,' b13=',f6.4,' ca=',f6.4,' ca13=',f6.4,
C@DB     -  ' a=',f8.3,' a13=',f8.3)
C@DB      end
      subroutine clstrs(ineig,nneig,nnloop,n0,n,iclst,ifirst,ilast,
     -  nofcls0,nofcls,iused,iout,inperr,nww,nonnerr,maxat,maxgr,
     -  maxneig,iclstrtyp,neigtest)
c#    MMC routine 462 lstmod: 12/23/16
c*****Find all clusters in a network and sort atoms in a cluster by groups
      dimension ineig(maxneig,maxat),nneig(maxat),iclst(maxat),
     -  ifirst(maxgr),ilast(maxgr),nnloop(maxat),iused(maxat)
      common /option/ iop(200),idebug(200)
c     Input parameters:
c     n0,n: Use atomnumbers (vertices) from n0 to n (inclusive)
c     maxat,maxneig,maxgr: Array sizes - see dimension statement above
c     nneig(i) : number of neighbours (bonded) of molecule i. Negative value
c     is the same as no neighbors
c     ineig(j,i) : j-th neighbour of atom i
c     Workspace arrays:
c     iused(i) : 1 - atom i is not accounted for yet
c                0 - atom i is already accounted for
c     nnloop (i) : copy of nneig in loops 1 and 2 (temporary storage)
c                  the number of loop-closing bonds of atom i thereafter
c     Output parameters:
c     nofcls0: Number of disconnected clusters (groups) found previously
c     nofcls: Number of disconnected clusters (groups) found
c     iclst,ifirst,ilast: The elements of the ig-th group are atoms
c     (iclst(ia),ia=ifrst(ig),ilast(ig))
c     iclstrtyp: 1/2/3/4/5 - molecules/solvent clusters/grid clusters/
c                            generic site clusters/solute groups
c
c     Description of the algorithm:
c     Starting with an atom, the algorithm successively includes its
c     neighbours and then the neighbours of the atoms already on the list.
c     By excluding atoms that 're-occurred' the algorithm essentially generates
c     a spanning tree.
c     Initialization
      if (n0 .gt. n) then
        write (iout,1012) n,n0
        inperr=inperr+1
      end if
      nww=0
      do i=n0,n
        nnloop(i)=nneig(i)
        iused(i)=1
        if (idebug(53) .gt. 0)
     -    write (iout,1010) i,nneig(i),(ineig(j,i),j=1,nneig(i))
      end do
      if (neigtest .eq. 1) call checknnlist(n0,n,nneig,ineig,
     -  iout,inperr,nwwarn,ne,0,nonnerr+1,0,maxneig,maxat)
      nofcls=nofcls0
      if (n .lt. n0) return
      nfound=n0-1
      ifirst(nofcls0+1)=n0
      do i=n0,n
        if (iused(i) .gt. 0) then
c         Start search
c         ncl is the number of elements in the cluster
c         ic is the index of the atom under consideration
c         kroot is the serial no of the lowest element in the cluster
c         that may still have neighbours not examined yet
          ic=i
          ncl=0
          kroot=1
          do while (kroot .lt. ncl .or. ncl .eq. 0)
            if (idebug(53) .gt. 1) write (iout,1009)
     -        i,kroot,ncl,ic,nnloop(ic),iused(ic)
            do while (ncl .eq. 0 .or. nnloop(ic) .gt. 0)
              if (iused(ic) .gt. 0) then
c               Include ic into the list
                iused(ic)=0
                ncl=ncl+1
                iclst(nfound+ncl)=ic
                if (idebug(53) .gt. 1)
     -            write (iout,1008) ic,nnloop(ic),ncl,kroot
              end if
              if (nnloop(ic) .gt. 0) then
c               Now search for the first unused neighbor of ic
                jc=ineig(nnloop(ic),ic)
                do while (iused(jc) .eq. 0 .and. nnloop(ic) .gt. 0)
                  jc=ineig(nnloop(ic),ic)
                  nnloop(ic)=nnloop(ic)-1
                  if (idebug(53) .gt. 1) write (iout,1006)
     -              ic,jc,nnloop(ic),iused(jc),ncl
                end do
                if (iused(jc) .gt. 0) ic=jc
              end if
            end do
c           Neighbour chain ended, back to the kroot-th atom in the list
            ic=iclst(nfound+kroot)
            if (nnloop(ic) .le. 0) kroot=kroot+1
            if (idebug(53) .gt. 1) write (iout,1007)
     -          nfound,kroot,ic,jc,nnloop(ic),ncl
          end do
c         Cluster of ncl elements found
          nofcls=nofcls+1
          if (nofcls .gt. maxgr) then
            if (iclstrtyp .eq. 1) then
              write (iout,1000) 'solute molecules',maxgr,'MM'
            else if (iclstrtyp .eq. 2) then
              write (iout,1000) 'solvent clusters',maxgr,'MO'
            else if (iclstrtyp .eq. 3) then
              write (iout,1000) 'grid clusters',maxgr,
     -          'GX*# GY*(# GZ/32)'
            else if (iclstrtyp .eq. 4) then
              write (iout,1000) 'sites',maxgr,'NH'
            else if (iclstrtyp .eq. 5) then
              write (iout,1000) 'solute groups',maxgr,'GR'
            end if
            call datprt(2)
          end if
          ilast(nofcls)=ifirst(nofcls)+ncl-1
          if (nofcls .lt. maxgr) ifirst(nofcls+1)=ilast(nofcls)+1
          if (iclstrtyp .eq. 1) then
            memmax=0
            memmin=10000000
            do ia=nfound+1,nfound+ncl
              if (memmax .lt. iclst(ia)) memmax=iclst(ia)
              if (memmin .gt. iclst(ia)) memmin=iclst(ia)
            end do
            if (ifirst(nofcls) .ne. memmin .or.
     -          ilast(nofcls) .ne. memmax) then
              write (iout,1002) nofcls,memmin,memmax,
     -        ifirst(nofcls),ilast(nofcls)
              nww=nww+1
            end if
            if (nofcls .gt. 1) then
              if (memmin .lt. ilast(nofcls-1)) then
                write (iout,1003) nofcls
                nww=nww+1
              end if
            end if
          end if
          if (idebug(53)+idebug(157) .gt. 0) write (iout,1005) nofcls,
     -      ifirst(nofcls),ilast(nofcls),ncl
          nfound=nfound+ncl
        end if
      end do
      if (nww .gt. 0 .and. iclstrtyp .eq. 1) write (iout,1004)
c     ilast(nofcls)=n
c     il=ifirst(nofcls)+ncl-1
      if (n .ne. ilast(nofcls)) then
        write (iout,1001) ilast(nofcls),n0,n
        inperr=inperr+1
      end if
      return
1000  format(' ***** ERROR: Maximum number of ',a,' (',i5,') is ',
     -  'exceeded in cluster search',/,' - redimension the program ',
     -  'with increased #',a)
1001  format(' ***** PROGRAM ERROR in cluster search: il=',i6,
     -  ' n0,n=',2i6)
1002  format(' ===== STRONG WARNING: molecule ',i6,' atom range ',
     -  'found:',i7,1x,i7,' expected range:',i7,1x,i7,1x,/,
     -  7x,'- the atoms of a solute molecule are not contiguous or ',
     -  'bonds are missing/misplaced')
1003  format(' ===== STRONG WARNING: one of the first atoms of ',
     -  'molecule ',i6,' is likely to miss a bond')
1004  format(' Use FCGA OERR to find atoms forming unrecognizable ',
     -  'functional groups and BNDL n1 n2 to ',
     -  'find the neighbour list of suspected atoms')
1005  format(' CLSTRS nofcls=',i8,' if,il=',2i10,' ncl=',i9)
1006  format(' CLSTRS ic,jc=',2i5,' nnloop(ic),iused(jc)=',2i3,
     -  ' ncl=',i5)
1007  format(' CLSTRS nfound,kroot=',2i6,' ic,jc,nnloop(ic)=',2i6,i3,
     -  ' ncl=',i5)
1008  format(' CLSTRS Added ic=',i8,' nnloop(ic)=',i2,' ncl,kroot=',2i5)
1009  format(' CLSTRS i,kroot,ncl,ic,nnloop(ic),iused(ic)=',6i8)
1010  format(' CLSTRS ',i7,' nn=',i4,(' in=',10i8))
1012  format(' ***** PROGRAM ERROR: starting increment (n0=',i10,') ',
     -  'exceeds member limit (n=',i10,')')
      end
      subroutine check_clst(ifc,ilc,icl,ncl,igfree,ncover,
     -  ng1,itmp,inperr,istop,lab,llab,idb,iout,maxg,maxc)
c#    MMC routine 462/a lstmod: 05/11/12
c*****Check the integrity of the cluster membership descriptors
      dimension ifc(maxc),ilc(maxc),icl(maxg),igfree(maxg),
     -  ncover(#GX,#GY,#GZ),itmp(maxg)
      character*(*) lab
      if (idb .eq. 0) return
c     print *,'CHECK_CLST ncl=',ncl,' ng1=',ng1
      nerr=0
      do i=2,ncl
        if (ifc(i) .ne. ilc(i-1)+1) then
          write (iout,1000) lab(1:llab),i,ifc(i),ilc(i-1)
          nerr=nerr+1
        end if
      end do
      call zeroiti(itmp,0,ilc(ncl))
      do i=1,ilc(ncl)
        if (itmp(icl(i)) .eq. 1) then
          write (iout,1001) lab(1:llab),icl(i),i
          nerr=nerr+1
        else
          itmp(icl(i))=1
        end if
      end do
      do i=1,ilc(ncl)
        if (itmp(i) .eq. 0) then
          write (iout,1002) lab(1:llab),i
          nerr=nerr+1
        end if
      end do
      do ic=1,ncl
        do ig=ifc(ic),ilc(ic)
          indx=igfree(icl(ig))
          call unpackijk(indx,ng1,ix,iy,iz)
          if (ncover(ix,iy,iz) .ge. 0) then
            write (iout,1004) lab(1:llab),ic,ig,icl(ig),ix,iy,iz
            nerr=nerr+1
          else if (icl(ig) .ne. -ncover(ix,iy,iz)) then
            write (iout,1005) lab(1:llab),ic,ig,icl(ig),ix,iy,iz,
     -        -ncover(ix,iy,iz)
            nerr=nerr+1
          end if
        end do
      end do
      if (nerr .gt. 0 .and. istop .eq. 1) call datprt(nerr+1)
      inperr=inperr+nerr
      if (nerr .eq. 0 .and. idb .gt. 1)
     -  write (iout,1003) lab(1:llab),ncl,ilc(ncl)
      return
1000  format(' ERROR ',a,': cluster',i9,' Starting member=',i9,
     -  ' end of previous cluster=',i9)
1001  format(' ERROR ',a,': cluster member ',i9,
     -  ' ocurred more than once at posioton ',i9)
1002  format(' ERROR ',a,': cluster member ',i9,
     -  ' is missing from the list')
1003  format(1x,a,' check OK ncl=',i5,' ng=',i9)
1004  format(' ERROR ',a,': cluster ',i6,' ig,icl(ig)=',2i10,
     -  ' points to grid (',3i5,') that is not free')
1005  format(' ERROR ',a,': cluster ',i6,' ig,icl(ig)=',2i10,
     -  ' points to grid (',3i5,') that points to',i10)
      end
      subroutine findtcent(ineig,nneig,mask,iparent,list,n0,n,icent,
     -  ncent,molres,iout,inperr,maxat,maxneig)
c#    MMC routine 463 lstmod: 04/27/15
c*****Find the topology center of a molecule
      dimension ineig(maxneig,maxat),nneig(maxat),mask(maxat),
     -  list(maxat),iparent(maxat)
      common /option/ iop(200),idebug(200)
      character*8 mrname
      dimension mrname(2)
      data mrname /'residue ','molecule'/
      data ilist /0/
      if (n .eq. n0) then
        icent=n0
        return
      end if
c     Check to see if center has been given on input
      ncent=0
      do i=n0,n
        if (mask(i) .eq. 1) then
          icent=i
          ncent=ncent+1
        end if
        if (ncent .gt. 0) then
          if (ncent .gt. 1) then
            write (iout,1002) mrname(molres),n0,n,ncent
            inperr=inperr+1
          end if
          if (idebug(4) .eq. 1) write (iout,1003) icent
          return
        end if
      end do
      do ir=1,2
        nsteps=0
        do i=n0,n
          iparent(i)=0
        end do
        if (ir .eq. 1) then
c         First grow neigbour list from n0
          ic=n0
        else
c         Now grow from list(ilist)
          ic=list(ilist)
        end if
        iparent(ic)=ic
        ilistf=1
        ilistl=1
        list(ilistf)=ic
        do while (ilistl .ge. ilistf)
          nsteps=nsteps+1
          ilist=ilistl
          do il=ilistf,ilistl
            ic=list(il)
            do in=1,nneig(ic)
              ia=ineig(in,ic)
              if (ia .ge. n0 .and. ia .le. n) then
c               Consider only atoms within the range
                if (iparent(ia) .eq. 0) then
                  iparent(ia)=ic
                  ilist =ilist+1
                  list(ilist)=ia
                end if
              end if
            end do
          end do
          ilistf=ilistl+1
          ilistl=ilist
        end do
c       Now list(ilist) is one of the farthest from ic
        if (idebug(4) .eq. 1)
     -    write (iout,1000) n0,n,ir,list(ilist),nsteps
      end do
c     nsteps is the number of vertices on the longest path, backtrack
c     nsteps/2 to get the center
      ic=list(ilist)
      do ia=1,nsteps/2
        ic=iparent(ic)
      end do
      icent=ic
      if (idebug(4) .eq. 1) write (iout,1001) icent
      return
1000  format(' FINDCENT: Center search for atoms ',i5,' - ',i5,
     -  ': run',i2,' End point: ',i5,' Steps: ',i4)
1001  format(' Center found:',i5)
1002  format(1x,a,' including atoms ',i5,' - ',i5,' has ',i2,
     -  ' centers  specified on input')
1003  format(' Inputted center found:',i5)
      end
      subroutine initmol(molslt,molslt0,n,nnoclone,nneig,ineig,ifirstm,
     -  ilastm,iamolslt,mask,ifgrmolslt,ilgrmolslt,igrcnt,molcnt,igrslt,
     -  iorig_of_split,ianslt,labslt,noutwarn,nsplitwarn,
     -  noutwmin,noutwmax,nmolwid,ifdummy,nsplitwmin,nsplitwmax,maxat,
     -  maxgr,maxml,maxneig,maxwid)
c#    MMC routine 464 lstmod: 05/03/22
c*****Initialize molecule descriptors (within a solute)
      dimension nneig(maxat),ineig(maxneig,maxat),ifirstm(maxml),
     -  ilastm(maxml),ifgrmolslt(maxml),ilgrmolslt(maxml),
     -  iamolslt(maxat),mask(maxat),igrslt(maxat),igrcnt(maxgr),
     -  ianslt(maxat),molcnt(maxml),iorig_of_split(maxat),
     -  ifdummy(maxwid)
      character*4 labslt(2,maxat)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
c     ifirstm(im),ilastm(im): First and last atom of solute molecule im
c     ifgrmolslt(im),ilgrmolslt(im): First and last group of molecule im
c     molcnt(im): center atom (for rotation and cutoff/pbc distance)
      molsltf=#MM+1
      isswarn=0
      if (iop(85) .eq. 0) then
        if (iop(3) .eq. 11) then
          molslt=1
          ifirstm(1)=1
          ilastm(1)=n
        else if (n .gt. 0) then
          call clstrs(ineig,nneig,l1,1,n,l2,ifirstm,ilastm,molslt0,
     -      molslt,l3,iout,inperr,nww,0,maxat,maxml,maxneig,1,1)
          nwwarn=nwwarn+nww
          call checkdim(ifail,iout,inperr,'MM',molslt,0,0,0)
          if (idebug(53) .gt. 0) then
            do im=1,molslt
              write (iout,1117) im,ifirstm(im),ilastm(im),
     -          (l2(i),i=ifirstm(im),ilastm(im))
            end do
          end if
        end if
      else if (molslt .gt. 0) then
        do im=1,molslt-1
          if (ilastm(im)+1 .ne. ifirstm(im+1)) then
            write (iout,1104) im,ilastm(im),ifirstm(im+1)
            inperr=inperr+1
          end if
        end do
        do im=1,molslt
          do ia=ifirstm(im),ilastm(im)
            l4(ia)=im
          end do
        end do
        if (ilastm(molslt) .ne. n) then
          write (iout,1103) n,ilastm(molslt)
          molsltf=molslt
          call clstrs(ineig,nneig,l1,ilastm(molsltf)+1,n,l2,ifirstm,
     -      ilastm,molsltf,molslt,l3,iout,inperr,nww,1,maxat,maxml,
     -      maxneig,1,1)
          nwwarn=nwwarn+nww
          nwarn=nwarn+1
        end if
      end if
      noutwarn=0
      nsplitwarn=0
      noutwmin=maxat+1
      noutwmax=0
      nsplitwmin=maxat+1
      nsplitwmax=0
      nhcentwarn=0
      do im=molslt0+1,molslt
c       Set molecule indices and check for atoms outside their molecule
c       l2(i): atomindex after clstering; l4(ia): molecule number of atom (ia)
        if (iop(85) .eq. 0 .or. molsltf .lt. im) then
          do ia=ifirstm(im),ilastm(im)
            iat=l2(ia)
            l4(iat)=im
            if (iat .lt. ifirstm(im) .or.
     -          iat .gt.  ilastm(im)) then
              if (noutwarn .le. 25 .or. iop(24) .gt. 0) then
                write (iout,1101)
     -           iat,(labslt(k,iat),k=1,2),im,ifirstm(im),ilastm(im)
                isswarn=1
              end if
              do in=1,nneig(iat)
                ian=ineig(in,iat)
                if (ian .ge. ifirstm(im) .and. ian .le. ilastm(im)) then
                  write (iout,1118) iat,(labslt(k,iat),k=1,2),ian,
     -              (labslt(k,iat),k=1,2)
                  if (iop(61) .gt. 0) write (iout,1119)
     -              iorig_of_split(iat),iorig_of_split(ian)
                end if
              end do
              nwwarn=nwwarn+1
              noutwarn=noutwarn+1
              if (ia .lt. noutwmin) noutwmin=ia
              if (ia .gt. noutwmax) noutwmax=ia
            end if
          end do
        end if
        if (im .gt. 1) then
          if (igrslt(ilastm(im-1)) .eq. igrslt(ifirstm(im))) then
            if (nsplitwarn .le. 25)
     -        write (iout,1102) im,igrslt(ifirstm(im))
            if (nsplitwarn .eq. 26) write (iout,1116)
            nwwarn=nwwarn+1
            nsplitwarn=nsplitwarn+1
            if (ia .lt. nsplitwmin) nsplitwmin=ilastm(im)
            if (ia .gt. nsplitwmax) nsplitwmax=ilastm(im)
          end if
        end if
        ifgrmolslt(im)=igrslt(ifirstm(im))
        ilgrmolslt(im)=igrslt(ilastm(im))
c       Determine molecular center
        nmolc=0
        imolc=0
        do ia=ifirstm(im),ilastm(im)
          nmolc=nmolc+mask(ia)
          if (mask(ia) .eq. 1 .and. nmolc .eq. 1) imolc=ia
          if (nmolc .gt. 1) then
            write (iout,1112) im,ifirstm(im),ilastm(im),ia
            inperr=inperr+1
          end if
        end do
        if (nmolc .eq. 0) then
          call findtcent(ineig,nneig,mask,l2,l3,ifirstm(im),ilastm(im),
     -      molcnt(im),ncentfound,2,iout,inperr,maxat,maxneig)
        else
          molcnt(im)=imolc
        end if
        if (idebug(3) .gt. 0) write (iout,7713) im,ifgrmolslt(im),
     -    ilgrmolslt(im),nmolc,molcnt(im),
     -    (labslt(k,molcnt(im)),k=1,2)
        call trnsfi(iamolslt(ifirstm(im)),l4(ifirstm(im)),
     -    ilastm(im)-ifirstm(im)+1)
        if (ianslt(molcnt(im)) .eq. 1) then
          nhcentwarn=nhcentwarn+1
          if (nhcentwarn .le. 25) write (iout,1115) im,molcnt(im)
          nwwarn=nwwarn+1
          if (nhcentwarn .eq. 26) write (iout,1116)
        end if
      end do
c     For ghost molecules, optionally increment starting index
      if (molslt0 .eq. 0 .and. (iop(30) .eq. 1 .or. iop(30) .eq. 2))then
        do im=1,nmolwid
          if (ianslt(ifirstm(im)) .eq. 99 .and. ifdummy(im) .ne. 1) then
            ifdummy(im)=1
            write (iout,1111) im
            nchng=nchng+1
          end if
          if (ifdummy(im) .eq. 1) then
            if (ncentfound .gt. 0 .and. molcnt(im) .ne. ifirstm(im))then
              write (iout,1110) ifirstm(im)
              nwarn=nwarn+1
            end if
            molcnt(im)=ifirstm(im)
            igrcnt(im)=ifirstm(im)
            ifirstm(im)=ifirstm(im)+1
          end if
        end do
      end if
      do im=molslt0+1,molslt
        if (idebug(3) .gt. 0) then
          write (iout,7711) im,ifirstm(im),ilastm(im),ifgrmolslt(im),
     -      ilgrmolslt(im),molcnt(im)
          if (idebug(3) .gt. 1) write (iout,7712)
     -       (iamolslt(ia),ia=ifirstm(im),ilastm(im))
        end if
c       Check for large solute molecules not broken up into groups
        if (ifgrmolslt(im) .eq. ilgrmolslt(im)) then
          icloned=0
          if (iop(69) .gt. 0 .and. icorig(ilastm(im)) .lt. 0) icloned=1
          if (icloned .eq. 0) then
            natsim=ilastm(im)-ifirstm(im)+1
            if (natsim .gt. 20) then
              write (iout,1113) '----- WARNING',im,natsim
              nwarn=nwarn+1
            else if (ilastm(im)-ifirstm(im) .gt. 50) then
              write (iout,1113) '===== STRONG WARNING',im,natsim
              nwwarn=nwwarn+1
            end if
          end if
        end if
      end do
      do ia=1,n
        if (iamolslt(ia) .lt. 1 .or. iamolslt(ia) .gt. molslt) then
          write (iout,1106) iamolslt(ia),ia
          if (nsplitwarn+noutwarn .gt. 0) write (iout,1109)
          inperr=inperr+1
          iamolslt(ia)=1
        end if
      end do
      if (iop(69) .gt. 0) then
c       Check if whole molecules were cloned
        do ic=1,nclone
          ifst=iaclnf(ic)
          do while (iabs(icorig(ifst)) .lt. iaclnf(ic) .and.ifst .lt. n)
            ifst=ifst+1
          end do
          if (iabs(icorig(ifst)) .ne. iaclnf(ic)) then
            write (iout,1108) 'first',ic
            inperr=inperr+1
          end if
          ilst=ifst+(iaclnl(ic)-iaclnf(ic))
          nx=0
          if (ifst .gt. 1) then
            if (iamolslt(ifst-1) .eq. iamolslt(ifst)) nx=nx+1
          end if
          if (ilst .lt. nnoclone) then
            if (iamolslt(ilst) .eq. iamolslt(ilst+1)) nx=nx+1
          end if
          if (nx .gt. 0) then
            write (iout,1107) iaclnf(ic),iaclnl(ic)
            nwwarn=nwwarn+1
          end if
        end do
      end if
      if (noutwarn+nsplitwarn .gt. 0 .and. iop(85) .eq. 0 .and.
     -    iop(57)+iop(58) .gt. 0) then
        write (iout,1105)
        if (nsplitwarn .gt. 0) write (iout,1114)
        inperr=inperr+1
      end if
      return
7711  format(' INITMOL: Molecule ',i4,' Atom limits: ',i5,' - ',i5,
     -  ' Group limits:',i4,' - ',i4,' Center:',i5)
7712  format(' iamolslt=',30i4)
7713  format(' Molec',i4,' groups',i5,' - ',i5,' nmolc=',i2,
     -  ' molcnt=',i6,1x,2a4)
1101  format(' ===== STRONG WARNING: atom',i6,1x,a,1x,a,
     -  ' of solute molecule',i5,' falls outside its presumed range ',
     -  '(atoms ',i6,' - ',i6,')')
1102  format(' ===== STRONG WARNING: molecule ',i3,' splits group ',i4)
1103  format(' ----- WARNING: inputted molecule definitions do',
     -  ' not cover the whole solute (',i6,' atoms), only the first',
     -  i6,' atoms',/,7x,'connectivity list will be used for the rest',
     -  ' of the solute')
1104  format(' ***** PROGRAM ERROR: inputted molecule definitions do ',
     -  'not define contiguous molecules,',/,5x,' molecule',i5,
     -  ' ends at ',i6,' next molecule starts at ',i6)
1105  format(' ***** ERROR: solute molecule determination from the ',
     -  'connectivity list failed - use the key MOLD to define the ',
     -  'solute molecules')
1106  format(' ***** ERROR: illegal molecule number (',i8,
     -  ') for atom ',i7)
1107  format(' ===== STRONG WARNING: atoms',i5,' - ',i6,' were cloned',
     -  ' but they do not form a separate molecule')
1108  format(' ***** PROGRAM ERROR: Can not find the ',a,' cloned atom',
     -  ' for the ',i2,'-th clone')
1109  format(14x,'It is a likely consequence of the STRONG WARNINGs ',
     -  'above')
1110  format(' ----- WARNING: molecule center specified  by the .slt ',
     -  'file (',i3,') is not the dummy atom  - center set to the 1st',
     -  ' atom')
1111  format(' >>>>> OVERRIDE: first atom of Widom molecule',i2,' is ',
     -  'of type Dummy - it will only be used for molecule placing')
1112  format(' ***** ERROR: solute molecule ',i4,' (',i6,' - ',i6,')',
     -  ' has an additional center specified (atom #',i7,')')
1113  format(1x,a,': solute molecule ',i4,' has ',i4,' atoms and is a ',
     -  'single group.',/,7x,'Partition the solute into groups to ',
     -  'avoid possible simulation artifacts')
1114  format(7x,'or establish bonds within the split residues with the',
     -  ' MAKB key')
1115  format(' ===== STRONG WARNING: center of molecule ',i3,
     -  ' is a hydrogen (atom #',i7,')')
1116  format(' Additional warnigs are suppressed')
1117  format(i4,' range=',2i6,' members:',/,(20i6))
1118  format(23x,'Bond ',i7,1x,a,1x,a,' - ',i6,1x,a,1x,a,' is suspect')
1119  format(23x,'Original atom indices:',i7,' - ',i6)
      end
      subroutine centdef_fix(molslt0,molslt,ifirstm,ilastm,ifgrmolslt,
     -  ilgrmolslt,nneig,ineig,labslt,mask,molcnt,naflxrange,
     -  iaflxrange,iaflxneig,iout,nwarn,ioptord,maxneig,maxml,maxat)
c#    MMC routine 464/a lstmod: 04/11/21
c*****Modify the center definition for peptides when not done by input
      dimension ifirstm(maxml),ilastm(maxml),ifgrmolslt(maxml),
     -  ilgrmolslt(maxml),mask(maxat),molcnt(maxml),
     -  nneig(maxat),ineig(maxneig,maxat),iaflxrange(2,naflxrange),
     -  iaflxneig(2,naflxrange)
      character*4 labslt(2,maxat)
      common /option/ iop(200),idebug(200)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      do im=molslt0+1,molslt
        molcnt_old=molcnt(im)
        ichange=0
        if (ioptord .gt. 2) then
c         Set peptide centers to the first BB N
          do ia=ifirstm(im),ilastm(im)
            if (labslt(2,ia) .eq. 'N   ' .or.labslt(2,ia) .eq. ' N  ')
     -      then
              molcnt(im)=ia
              ichange=1
              write (iout,2004) im,molcnt(im)
              go to 100
            end if
          end do
        end if
100     if (ichange .eq. 0) then
          if (mask(molcnt(im)) .eq. 1) then
            write (iout,2003) im,molcnt(im)
          else
            iflex=0
            do is=1,naflxrange
              if (ifirstm(im) .eq. iaflxrange(1,is) .and.
     -            ilastm(im) .eq. iaflxrange(2,is)) then
                write (iout,2002) im,(iaflxrange(k,is),k=1,2)
                iflex=1
                if (iaflxneig(1,is) .gt. 0) then
                  molcnt(im)=iaflxneig(1,is)
                else if (iaflxneig(2,is) .gt. 0) then
                  molcnt(im)=iaflxneig(2,is)
                else
                  iflex=0
                end if
              end if
            end do
            if (iflex .eq. 0) then
c             Flexible range was not taken care of
              nCA=0
              do ia=ifirstm(im),ilastm(im)
                if ((labslt(2,ia) .eq. 'CA  '.or.
     -               labslt(2,ia) .eq. ' CA ') .and.
     -               labslt(1,ia) .ne. 'SLTE') then
                  nCA=nCA+1
                  l1(nCA)=ia
                end if
              end do
              nmres=ilgrmolslt(im)-ifgrmolslt(im)+1
              if (nCA .gt. 0 .and. nCA .ne. nmres) then
                write (iout,2000) im,nmres,nCA
                nwarn=nwarn+1
              end if
              if (iop(91) .gt. 0) then
                if (nCA .gt. 0) then
c                 Backbone is undergoing loop moves
                  molcnt(im)=l1(1)
                  iCA=l1(1)
                  iNH=0
                  do in=1,nneig(iCA)
                    ja=ineig(in,iCA)
                    if (labslt(2,ja) .eq. 'N   ' .or.
     -                  labslt(2,ja) .eq. ' N  ' .or.
     -                  labslt(2,ja) .eq. 'NH  ' .or.
     -                  labslt(2,ja) .eq. ' NH ') iNH=ja
                  end do
                  if (iNH .gt. 0 .and. nneig(iNH) .gt. 1)molcnt(im)=iNH
                else
                  molcnt(im)=ifirstm(im)
                end if
              else if (nCA .gt. 0) then
c               Set the center to the middle CA
                iCA=nCA/2+1
c               write (iout,*) 'nCA=',nCA,' iCA=',iCA,' L1=',l1(iCA)
                molcnt(im)=l1(iCA)
              end if
            end if
            if (molcnt_old .ne. molcnt(im))
     -        write (iout,2001) im,molcnt_old,molcnt(im)
          end if
        end if
      end do
      return
2000  format(' ----- WARNING: solute molecule ',i4,
     -  ' number of residues=',i4,' number of CA atoms=',i4)
2001  format(' Center for molecule #',i3,' changed from',i7,' to ',i7)
2002  format(' Molecule #',i3,' is flexible range [',i6,',',i6,']')
2003  format(' Molecule',i5,' Center=',i6,' defined in the .slt file')
2004  format(' Peptide center for molecule #',i3,' set to the first N ',
     -  'BB atom (',i7,')')
      end
      subroutine initsolute
c#    MMC routine 465 lstmod: 02/26/13
c*****Set up solute partitioning constants
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  ask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /dploy/ cslvo(3,#SV),dihango(#TR),cslto(3,#ST),
     -  wtlast(#MM),cd(3),crmi(3),dispmax(3),displace,absstep,
     -  cd0bt2,cd1bt2,ra0bt2,ra1bt2,cedslv,rtxslv,cedslt,rtxslt,cdbt2,
     -  rabt2,pvbeta,beta2,beta4,fblamd,cedpslt(3),rtxpslt(3),
     -  cedpsltim(3,#MM),rtxpsltim(3,#MM),rtxcslt,
     -  delcpl,cplprn,cp1prn,paxis,chsq,phiabs,stpfac,rsphm2,dummy,
     -  wcplcha,wsltpdis,wsltptor,wswap,wmv2s,wspec,wslttry(7),
     -  wsltdisp,wsltrot,wslvdisp,wslvrot,r2scut,waxis(4),orj(3,3),
     -  frcmax,trqmax,ntrytyp,kut,kuttyp,nftcut,nftcta,itgfrst,itmfrst,
     -  imspf,imspl,imolpd,imolpt,ifagr,ilagr,ifagrs,ilagrs,iltorgrgr,
     -  incrpmf,icsol1,natm3,kxmn,mvfst,isolv,isolvc,iaxis,idummy0,
     -  nwidta,iaxis2s,icopy,notrans,norot,njacsing,
     -  ngrdmn,ngrdmx,ngrddo,ngrtmn,ngrtmx,nmtmn(#MM),nmtmx(#MM),
     -  nsltfreq,movtyp,iop6ol,molmov,molmovs,itormov,ncoptor,ncoptorf
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /pmfinf/ crm2nd0(3),crm2nd1(3),rlcsec(3,#MA),crmpmf(3),
     -  euler(3),euler2nd(3),ort2nd(3,3),eulercos2,cdpmf(3),rtpmf(3),
     -  crmpmf0(3),norotpmf,notranpmf,igenpmf,impmf,impmf1,impmf2,
     -  icent1,icent2,imolcent2
      real*8 expesum,eintraghost,eintralig,rncavx,egstfx,expsltsum,
     -  expslvsum,expnoslvsum,expintrasum
      common /widom/ expesum(#GX,#MW),eintraghost(#GX,#MW),
     -  eintralig(#GX),egstfx(#GX),rncavx(#GX),expsltsum(#MW),
     -  expslvsum(#MW),expnoslvsum(#MW),expintrasum(#MW),egsltmin(#MW),
     -  egslvmin(#MW),egsltxmin,egslvxmin,ang0i,ang0g,ewmin(#GX,#MW),
     -  ewmax(#GX,#MW),ew0(#MW),facins(#MW),rnearchim,rnearchim2,
     -  pfarchim,nmolwid,nwitry,nwgtry,ifdummy(#MW),ishifttp(3),ngrids,
     -  incrgrid,ngrpanchor,itanchor,ifgrpanchor(10),ilgrpanchor(10),
     -  nghanchor,nghdrop,imanchor,nnoanchor,ighanchor(200),ighdrop(100)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /option/ iop(200),idebug(200)
c     3-copy TI (iop(30) = 7 or 8)
c     <---- FE solute ----><-------- non-FE solute------------><-- solvent ---
c                          <- moving molecs --><-fixed molecs->
c     00000001111111lllllllaaaaabbbbbcccccdddddeeeeefffffggggggsssssssssssssss
c           |      |      |                   |               |
c           nstfa0 nstfa1 nstfa               movmoll         nstta
c           nstfg0 nstfg1 nstfg                               nsttg
c           nstfm0 nstfm1 nstfm                               nsttm
c                   |
c                   istf
c                   molstf
c     iop(30)=7 (PMF):
c                   <-- slt atoms for intra-related eng calc ->
c                   <----- gbuupd range ------>
c                   <----- potential gbuupt range ------------>
c     iop(30)=8 (PM or OR):
c     <------- slt atoms for intra-related eng calc ---------->
c     <-------------- gbuupd range ----------->
c     <---------- potential gbuupt range --------------------->
c     nstfm0=1,2,1,1,1,1 for iop(18)=0,1,2,3,4,5, resp.
c     nstf*1= 2 * nstf*0; nstf* = 3 * nstf*0
c
c     iop(30)=7 (PMF):
c     <-- slt atoms for intra-related eng calc ->
c     <----- gbuupd range ------>
c     <----- potential gbuupt range ------------>
c     nsft*=0
c
c     2-copy TI (iop(30) = 5 or 6)
c     <---- FE solute ----><-------- non-FE solute------------><-- solvent ---
c                          <- moving molecs --><-fixed molecs->
c     000000000011111111111aaaaabbbbbcccccdddddeeeeefffffggggggsssssssssssssss
c     |        |          |                   |               |
c     istf     nstfa0     nstfa               movmoll         nstta
c     molstf   nstfg0     nstfg                               nsttg
c              nstfm0     nstfm                               nsttm
c     <-------- slt atoms for intra-related eng calc --------->
c     <--------------- gbuupd range ---------->
c     <----------- potential gbuupt range -------------------->
c     nsftm0=1, nstfm=2, nstfg0=nstfg/2, but nstfa0<=>nstfm/2 !!!
c     FE solute can not be moved/rotated, only torsions changed.
c
c     Widom  (iop(30) = 1)
c     <---- FE solute ----><-------- non-FE solute------------><-- solvent ---
c                          <- moving molecs --><-fixed molecs->
c     00000000000aaaaabbbbbcccccdddddeeeeefffffggggggsssssssssssssss
c               |                   |               |
c    nstfa0  =  nstfa               movmoll         nstta
c    nstfg0  =  nstfg                               nsttg
c    nstfm0  =  nstfm                               nsttm
c               istf
c               molstf
c               <--- slt atoms for intra-related eng calc ---->
c               <---------- gbuupd range ----->
c               <------ potential gbuupt range --------------->
c     nsftm0=1, nstfm=1, nstfg=nstfg
c     Widom ghost molecule has to be 1 group. Will not be used for regular eng.
c
c     No FE (iop(30) = 0)
c     <------------- non-FE solute--------------><-- solvent ---
c     <---- moving molecs ----><-fixed molecs->
c     aaaaabbbbbcccccdddddeeeeefffffgggggghhhhhhhsssssssssssssss
c     |                       |                 |
c     nstfa                   movmoll           nstta
c     nstfg                                     nsttg
c     nstfm                                     nsttm
c     istf
c     molstf
c
c     #ST, #GR, #MM: maximum of nstta, nsttg, nsttm, resp.
c     #MA: maximum number of atoms per solute molecule
c
      call checkdim(ifail,iout,inperr,'ST',nstta,0,0,0)
      if (nstfa0 .gt. nstfa) then
        if (MYRANK .eq. 0) write (iout,2001) nstfa0,nstfa
        inperr=inperr+1
      end if
      if (nstfa .gt. nstta) then
        if (MYRANK .eq. 0) write (iout,2002) nstfa,nstta
        inperr=inperr+1
      end if
      nstta3=3*nstta
c     impmf1,impfm2: Solute molecules for PMF calculation
      impmf1=0
c     nsltu: the first solute center to be used for proximity determination
c     nsltgru: proximity is determined starting from group nsltgru
c     Members of the i-th group are in igrslt from ifgrslt(i) to ilgrslt(i)
c     The torsion operations are performed on copies from ncoptorf to ncoptor
      nsltu=1
      nsltgru=1
      ncoptor=1
      ncoptorf=1
c     nsttia0,nsttia1: atom limits for TI atoms, lambda 0, lambda1
      nsttia0=0
      nsttia1=0
      movmoll=0
      nstfm1=0
      if (iop(30) .eq. 0) then
        if (nstfa .gt. 0 .or. nstfa0 .gt. 0) then
          if (MYRANK .eq. 0) write (iout,2003)
          nstfa=0
          nstfa0=0
          nwarn=nwarn+1
        end if
        nstcopa=nstta
        nstfm=0
        nstfa=0
      else
        nstfm=iamolslt(nstfa)
        nstcopa=nstfa0
        if (iop(30) .le. 3) nstcopa=nstta-nstfa
      end if
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
        if (nstfg .ne. nmolwid) then
          if (MYRANK .eq. 0) write (iout,2012) nmolwid,nstfg
          inperr=inperr+1
        end if
        nstfm0=nmolwid
        nstfm1=nmolwid
        nsltgru=nmolwid+1
        nsltu=nstfa+1
      else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
        if (nstfa .eq. 0 .or. nstfa0 .eq. 0) then
          if (MYRANK .eq. 0) write (iout,2004)
          inperr=inperr+1
        else if (iop(30) .eq. 6 .and. nstfa .ne. 2*nstfa0) then
          if (MYRANK .eq. 0) write (iout,2006)
          inperr=inperr+1
        end if
        if (nstfa0 .eq. 0) then
          if (MYRANK .eq. 0) write (iout,2011)
          inperr=inperr+1
        else
          nstfm0=iamolslt(nstfa0)
        end if
        nsttia0=nstfa0
        nsttia1=nstfa
        if (nstfm0 .ne. 1 .or. nstfm .ne. 2) then
          if (MYRANK .eq. 0) write (iout,2009) nstfm0,nstfm
          if (MYRANK .eq. 0) write (iout,2013)
          inperr=inperr+1
        end if
      else if (iop(30) .eq. 7 .or. iop(30) .eq. 8) then
        if (nstfa .ne. 3*nstfa0) then
          if (MYRANK .eq. 0) write (iout,2005)
          inperr=inperr+1
        end if
        nstfm0=iamolslt(nstfa0)
        nstfa1=2*nstfa0
        nstfg1=2*nstfg0
        nsltu=nstfa1+1
        nsltgru=nstfg1+1
c       Set default pmf molecules
        if (iop(18) .eq. 1) then
c         Two molecules are moved by PMF calculation
          if (nstfm0 .ne. 2) then
            if (MYRANK .eq. 0) write (iout,2008)
            if (MYRANK .eq. 0) write (iout,2013)
            inperr=inperr+1
          end if
          impmf1=5
          impmf2=6
          nc0=4
        else
c         One molecule is moved only
          if (nstfm0 .ne. 1) then
            if (MYRANK .eq. 0) write (iout,2007) nstfm0
            if (MYRANK .eq. 0) write (iout,2013)
            inperr=inperr+1
          end if
          impmf1=3
          impmf2=3
          nc0=2
        end if
        nstfm1=2*nstfm0
        nstfm=3*nstfm0
      end if
      if (iop(30) .eq. 7 .or. iop(30) .eq. 8) then
        if (iop(18) .ne. 4) then
          icent1=molcnt(impmf1)
          icent2=molcnt(impmf2)
c         2-molec PMF molecules' group center should be 0 to force using crmpmf
          if (iop(65) .gt. 2) then
            iop(65)=iop(65)-2
            write (iout,2014)
            nchng=nchng+1
          end if
          if (iop(18) .gt. 0 .and. iop(18) .lt. 4) then
            do ig=ifgrmolslt(impmf1),ilgrmolslt(impmf1)
              igrcnt(ig)=0
            end do
          end if
          if (impmf1 .ne. impmf2) then
            do ig=ifgrmolslt(impmf2),ilgrmolslt(impmf2)
              igrcnt(ig)=0
            end do
          else if (iop(18) .eq. 2 .or. iop(18) .eq. 3) then
            if (imolcent2 .le. nstfm .or. imolcent2 .gt. nsttm) then
              if (MYRANK .eq. 0)
     -          write (iout,2010) nstfm+1,nsttm,imolcent2
              inperr=inperr+1
            end if
            if (imolcent2 .gt. 0) then
              icent2=molcnt(imolcent2)
            else
              icent2=2
            end if
          end if
c         3-copy FE solute should make sure all copies have the same torsion
          ncoptor=3
c        else if (iop(30) .eq. 7 .and. iop(18) .eq. 4) then
cc         For torsion coupling, only the 3rd copy is used
c          ncoptor=3
c          ncoptorf=3
        end if
      end if
      istf=1
      igstf=1
      molstf=1
      molstfti=1
      if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
        istf=nstfa+1
        igstf=nstfg+1
        molstf=nstfm+1
        molstfti=nstfm+1
      else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
        molstfti=nstfm+1
      else if (iop(30) .eq. 7) then
        istf=nstfa1+1
        igstf=nstfg1+1
        molstf=nstfm1+1
        molstfti=nstfm1+1
      end if
      if (iop(30) .eq. 0) then
        nsltpx1=1
        nsltpx2=nstta
      else if (iop(30) .ge. 1 .and. iop(30) .le. 3) then
        nsltpx1=nstfa+1
        nsltpx2=nstta
      else if (iop(30) .eq. 5 .or. iop(30) .eq. 6) then
        nsltpx1=nstfa0+1
        nsltpx2=nstta
      else
        nsltpx1=nstfa1+1
        nsltpx2=nstta
      end if
c     isltmv(ia)=0: solute atom ia is fixed
c     isltmv(ia)=1: solute atom ia is affected by solute molecule moves
c     isltmv(ia)=2: solute atom ia is affected by torsions or pmf moves
c     ixislt is used for default indexing
      call indexit(ixislt,1,nstta,0)
      call zeroiti(isltmv,0,nstta)
      if (iop(30) .eq. 7 .and. iop(18) .ne. 4) then
        do ia=nstfa1+1,nstfa
          isltmv(ia)=2
        end do
      end if
      if (idebug(1) .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,7700) nstfa0,nstfa1,nstfa,nstta,
     -    nstfg0,nstfg1,nstfg,nsttg,nstfm0,nstfm1,nstfm,nsttm,
     -    nsltu,nsltgru,icent1,icent2,impmf1,impmf2
7700  format(' INITSOLUTE: nstfa0,nstfa1,nstfa,nstta=',4i6,
     -  ' nstfg0,nstfg1,nstfg,nsttg=',4i6,/,
     -  ' nstfm0,nstfm1,nstfm,nsttm=',4i6,' nsltu,nsltgru=',2i6,
     -  ' icent1,icent2,impmf1,impmf2=',4i6)
      return
2001  format(' ***** ERROR: number of FE solute atoms in one copy (',i5,
     -  ') exceeds total number of FE atoms (',i5,')')
2002  format(' ***** ERROR: number of FE solute atoms (',i5,') exceeds',
     -  ' total (',i5,')')
2003  format(' ***** ERROR: non-zero FE solute atoms (nstfa) requires',
     -  ' free energy options (key FREE)')
2004  format(' ***** ERROR: free energy options (FREE) require ',
     -  'non-zero FE solute atoms (nstfa and nstfa0)')
2005  format(' ***** ERROR: Three-copy free energy options (FREE PMF1 ',
     -  'or FREE PMNL) require identical number of atoms per copy')
2006  format(' ***** ERROR: Two-copy perturbation method (FREE PMLI) ',
     -  ' requres identical number of atoms per copy')
2007  format(' ***** ERROR: three-copy FE with linear or torsion ',
     -  'coupling (FREE PM** GENL/TORS) requires one solute molecule ',
     -  'per copy, not',i2)
2008  format(' ***** ERROR: three-copy FE with distance PMF calc (FREE',
     -  ' PM** WR**) requires two solute molecules per copy')
2009  format(' ***** ERROR: two-copy FE requires one solute molecule ',
     -  'per copy, not',i3,' and ',i3)
2010  format(' ***** ERROR: Second PMF molecule center should be ',
     -  'between ',i3,' and',i3,' (instead of ',i3,')')
2011  format(' ***** ERROR: number of atoms in first free energy ',
     -  'molecule is zero')
2012  format(' ***** ERROR: ghost molecules have to be one group each',
     -  ' - there are ',i2,' ghost molecules and ',i5,' groups')
2013  format(' Use the MOLD key, if necessary, to enforce this')
2014  format(' >>>>> OVERRODE: group-based solute-solute PBC ',
     -  'calculation is replaced by molecule-based PBC calculation')
      end
      subroutine collapserdf
c#    MMC routine 466 lstmod: 07/29/02
c*****Collapse RDF,QCDF arrays based on updated FCG info
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /clone/ nclone,iaclnf(10),iaclnl(10),ncopcln(10),
     -  igrinc(10),itorig(#TR),icorig(#ST),icnew(#ST)
      real*8 tdavr,ewwnn,ewwis,befssm,besm
      common /proxan/ tdavr(#DG,#GQ),ewwnn(#SX),ewwis(#SX),
     -  befssm(#SX),besm(#SX),r2fsl2(#SX),rfsl2(#SX),
     -  rfsl(#SX),rfsfac,rfsadd,sigmah,pmvol,rsolmn,rsolmx,rsmnsq,
     -  rsmxsq,rfsww,rfsww2,rceww,rceww2,epmink,epdivk,rpxnear2,
     -  rgpxsltmax2,rgpxwwmax2,rqwmin,rqwmax,rtimlim,dcgrid,rdc1,rdc2,
     -  rpxdiv,rripx2,ngrslt(#RG,#GQ),
     -  ngtslt(#TG,#GQ),nwpx(#SX),nwfspx(#SX),nw2fspx(#SX),
     -  npxwws(#SX),newwnn(#SX),nxtd(#LG,#GQ),nxck(15,#GQ),
     -  nsltep(#GE,#GQ),ngoo(#VG,#GQ,#ND),nsltresets,nslvresets,
     -  nmolsum,nfadel,nladel,mxpxsltgrd,mxpxwwgrd,nmcpxo,ncnfpx,
     -  npxmax,navgpx,nranpx,nsavepx,nmcpxdsc,npxres,npxcntin,lumppr
      common /pxtabdat/ ipxt1,ipxt2,pxt1(15,#SX),pxt2(15,#SX)
      common /volgen/ nrnslt(#RG,#GQ),nrnfs(#ST),nrn2fs(#ST),nrans
      common /option/ iop(200),idebug(200)
c     g(primary)
      if (iop(142) .gt. 1) then
        call collapsei(nsltpx1,nsltpx2,mxpxsltgrd-1,indxrdf,ngrslt,#RG)
        call collapsei(nsltpx1,nsltpx2,mxpxsltgrd-1,indxrdf,nrnslt,#RG)
      end if
c     g(tot)
      if (iop(143) .gt. 0) call collapsei(nsltpx1,nsltpx2,mxpxsltgrd-1,
     -  indxrdf,ngtslt,#TG)
c     Solvent dipole angle distributions
      if (iop(145) .gt. 0) then
        call collapsei(nsltpx1,nsltpx2,#LG,indxrdf,nxtd,#LG)
        call collapsed(nsltpx1,nsltpx2,#DG,indxrdf,tdavr,#DG)
      end if
c     Binding energy QCDF
      if (iop(146) .gt. 0)
     -  call collapsei(nsltpx1,nsltpx2,100,indxrdf,nsltep,100)
c     Solvent-solvent rdf
      if (iop(147) .gt. 0) then
        do iv=1,max0(1,nijgvv)
          call collapsei(nsltpx1,nsltpx2,mxpxwwgrd-1,indxrdf,
     -      ngoo(1,1,iv),#VG)
        end do
      end if
c     Coordination number QCDF
      if (iop(142) .gt. 1)
     -  call collapsei(nsltpx1,nsltpx2,15,indxrdf,nxck,15)
      return
      end
      subroutine collapsei(npx1,npx2,limgr,indxrdf,nrdf,maxgr)
c#    MMC routine 467 lstmod: 02/25/00
c*****Collapse one integer array
      dimension indxrdf(npx2),nrdf(maxgr,#GQ)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      do ig=1,limgr
        call zeroiti(l1,0,#GQ)
        do is=npx1,npx2
          iss=is
          l1(indxrdf(is))=l1(indxrdf(is))+nrdf(ig,iss)
        end do
        do is=1,#GQ
          nrdf(ig,is)=l1(is)
        end do
      end do
      return
      end
      subroutine collapsed(npx1,npx2,limgr,indxrdf,drdf,maxgr)
c#    MMC routine 468 lstmod: 02/25/00
c*****Collapse one double precision array
      real*8 drdf,drdf0
      dimension indxrdf(npx2),drdf(maxgr,#GQ),drdf0(#GQ)
      do ig=1,limgr
        call zeroitd(drdf0,#GQ)
        do is=npx1,npx2
          iss=is
          drdf0(indxrdf(is))=drdf0(indxrdf(is))+drdf(ig,iss)
        end do
        do is=1,#GQ
          drdf(ig,is)=drdf0(is)
        end do
      end do
      return
      end
      subroutine getgrouplabels(nsltpxgr,nsltpx1,nsltpx2,iatnam,ianslt,
     -  labslt,indxrdf,iout,LEVTEST)
c#    MMC routine 469 lstmod: 03/03/08
c*****Extract labels for functional groups
      character*4 iatnam,labslt
      dimension iatnam(99),ianslt(#ST),indxrdf(#ST),
     -  labslt(2,#ST)
      character*4 labpr
      character*2 iaprt
      common /grplst/ ixprt(#ST),ilastg(#ST),labpr(2,#ST),
     -  iaprt(#ST)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
c     Prepare group atomic numbers, labels
      ix=0
      do ig=1,nsltpxgr
        do is=nsltpx1,nsltpx2
          if (indxrdf(is) .eq. ig) then
            ix=ix+1
            ixprt(ix)=is
            iaprt(ix)=iatnam(ianslt(is))(1:2)
            labpr(1,ix)=labslt(1,is)
            labpr(2,ix)=labslt(2,is)
          end if
        end do
        ilastg(ig)=ix
      end do
      if (LEVTEST .gt. 0 .and. MYRANK .eq. 0)
     -  write (iout,1000) nsltpxgr,nsltpx1,nsltpx2
      if (LEVTEST .gt. 1) then
        do ig=1,nsltpxgr
          if (ig .eq. 1) then
            ifst=1
          else
            ifst=ilastg(ig-1)+1
          end if
          ilst=ilastg(ig)
          if (MYRANK .eq. 0) write (iout,1001) (ix,ixprt(ix),iaprt(ix),
     -      (labpr(k,ix),k=1,2),ix=ifst,ilst)
        end do
      end if
      return
1000  format(' GETGROUPLABELS nsltpxgr,nsltpx1,nsltpx2=',3i6)
1001  format(' GETGROUPLABELS ',
     -  2(' ix,ixprt,iaprt,lab=',2i6,1x,a2,1x,2a4))
      end
      subroutine rdfgrp(nsltpx1,nsltpx2,nsltpxgr,indxrdf,indxfg,
     -  ixfg,nfg,icorig,keeppx)
c#    MMC routine 470 lstmod: 03/11/07
c*****Transfer fcg info into indxrdf, set defaults
      dimension indxrdf(#ST),indxfg(#ST),ixfg(#ST),
     -  icorig(#ST),keeppx(#ST)
      common /MPI_DM/ NUMNOD,NUMNOD_o,MYRANK,myrank1,ioutdb,MPI_stat(4)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      if (iop(25) .gt. 1) then
c       Transfer the functional group information into the rdf information
        if (MYRANK .eq. 0) write (iout,2011)
        if (nsltpxgr .gt. 0) write (iout,2012)
        do ig=1,nfg
          l1(ixfg(ig))=ig
        end do
        call zeroiti(indxrdf,0,nsltpx2)
        do is=nsltpx1,nsltpx2
          if (indxfg(is) .ne. 0) indxrdf(is)=l1(indxfg(is))
        end do
      end if
      nsltpxgr=0
      do is=nsltpx1,nsltpx2
        if (indxrdf(is) .gt. nsltpxgr) nsltpxgr=indxrdf(is)
      end do
      if (nsltpxgr .gt. 0 .and. iop(142) .le. 1 .and. iop(143)+iop(145)+
     -    iop(146)+iop(147)+iop(148)+iop(171) .eq. 0) then
        nsltpxgr=0
        if (MYRANK .eq. 0) write (iout,2015)
        nchng=nchng+1
      end if
      if (nsltpxgr .eq. 0) then
c       Set default
        call indexit(indxrdf,nsltpx1,nsltpx2,1-nsltpx1)
c       Turn off condensed table print
        if (iop(158) .ne. 2 .and. iop(158) .ne. 3) then
          iop(158)=3
          if (MYRANK .eq. 0) write (iout,2014)
          nchng=nchng+1
        end if
      end if
      if (iop(168) .gt. 0) then
c       Remove rdf calculation from ignored solute atoms
        do is=nsltpx1,nsltpx2
          if (keeppx(is) .eq. 0) indxrdf(is)=0
        end do
      end if
      if (iop(69) .gt. 0) then
c       Cloned solute molecules contribute to the same rdf's
        npxg=0
        do is=nsltpx1,nsltpx2
          indxrdf(is)=indxrdf(iabs(icorig(is)))
        end do
      end if
c     Remove groups that don't contribute to the proximity list from indxrdf
      call zeroiti(l1,0,nsltpx2)
      do is=nsltpx1,nsltpx2
        if (indxrdf(is) .gt. 0) l1(indxrdf(is))=1
      end do
      nfound=0
      do is=nsltpx1,nsltpx2
        if (l1(is) .eq. 1) then
          nfound=nfound+1
          l2(is)=nfound
        end if
      end do
      nsltpxgr=0
      do is=nsltpx1,nsltpx2
        if (indxrdf(is) .ne. 0) indxrdf(is)= l2(indxrdf(is))
        if (indxrdf(is) .gt. nsltpxgr) nsltpxgr=indxrdf(is)
      end do
      nrdfmax=#GQ-1
      if (nsltpxgr .gt. 0 .or. iop(25) .gt. 1) then
c       Check list for g(r),QCDF for limits
        nwrn=0
        do is=nsltpx1,nsltpx2
          if (iop(142) .gt. 1 .and. indxrdf(is) .gt. nrdfmax) then
            nwrn=nwrn+1
            if (nwrn .le. 25 .and. MYRANK .eq. 0)
     -        write (iout,2020) is,indxrdf(is),nrdfmax
            indxrdf(is)=#GQ
            nwwarn=nwwarn+1
          end if
          if (indxrdf(is) .eq. 0) indxrdf(is)=#GQ
        end do
        if (nwrn .gt. 0) write (iout,2021) nwrn
      end if
      if (nsltpxgr .gt. nrdfmax) then
        if (iop(142) .gt. 1 .or. iop(143)+iop(145)+iop(146)+iop(147)+
     -      iop(148) .gt. 0) then
          if (MYRANK .eq. 0)
     -      write (iout,2013) nsltpxgr,nrdfmax,'GQ',nrdfmax+1
          inperr=inperr+1
        end if
        nsltpxgr=#GQ-1
      end if
      return
2011  format(' +++++ Transferring functional group information to RDF',
     -  ' grouping information as requested by FCGD INTG')
2012  format(' ----- WARNING: inputted indxrdf information will be ',
     -  'irreversibly overridden by the functional group information')
2013  format(' ***** ERROR: the number of distribution functions ',
     -  'requested (',i4,') exceeds program dimensions: ',i4,/,10x,
     -  ' increase #',a2,' to ',i4)
2014  format(' >>>>> OVERRIDE: condensed proximity table will not be ',
     -  'printed since only default rdf indices are used')
2015  format(' >>>>> OVERRIDE: RDF grouping indices will be ignored ',
     -  'since no distribution function calculation was requested')
2020  format(' ===== STRONG WARNING: ',i4,'-th solute atom g(r)/QCDF ',
     - 'index (',i4,') exceeds ',i4,' - no QCDFs will be calculated ',
     -  'for it')
2021  format(' NOTE: ',i5,' atoms will be ignored for QCDF calculation')
      end
C@DM      subroutine setlim(ifirst,n,num_pe,iflpe,ipe,MYRANK,iout,maxnod,
C@DM     -  iverb,label)
C@DMc#    MMC routine 471 lstmod: 03/02/05
C@DM      dimension iflpe(2,maxnod),ipe(n)
C@DM      character*(*) label
C@DMc*****Set buffer limits for arrays for the range nf-nl for MPI routines
C@DMc     Processor ip will work on molecules from iflpe(1,ip) to iflpe(2,ip)
C@DMc     'Molecule' may be replaced by 'solute atom'
C@DM      ntodo=(n-ifirst+1)/num_pe
C@DM      ipf=ntodo*num_pe
C@DM      nextra=n-ifirst+1-ipf
C@DM      iflpe(1,1)=ifirst
C@DM      do ip=1,num_pe
C@DM        iflpe(2,ip)=iflpe(1,ip)+ntodo-1
C@DM        if (ip .le. nextra) iflpe(2,ip)=iflpe(2,ip)+1
C@DM        if (ip .lt. num_pe) iflpe(1,ip+1)=iflpe(2,ip)+1
C@DM        do ii=iflpe(1,ip),iflpe(2,ip)
C@DM          ipe(ii)=ip
C@DM        end do
C@DM      end do
C@DM      if (num_pe .gt. 1 .and. MYRANK .eq. 0) then
C@DM        write (iout,1000) label,n,((iflpe(k,i),k=1,2),i=1,num_pe)
C@DM        if (num_pe .le. 10 .and. iverb .gt. 1)
C@DM     -    write (iout,1001) label,(ipe(i),i=ifirst,n)
C@DM      end if
C@DM      return
C@DM1000  format(' Processor work limits for ',a,' (n=',i6,') :',/,
C@DM     -  8(2i6,2x))
C@DM1001  format(' Processor assigned to each ',a,':',/,(100i1))
C@DM      end
C@DM      subroutine setdispl(num_pe,iflpe,nitem,ndispl,ncount,incr,maxnod)
C@DMc#    MMC routine 472 lstmod: 07/15/10
C@DM      dimension iflpe(2,maxnod),ndispl(maxnod),ncount(maxnod)
C@DMc     Sets the arrays for the variable length communication
C@DM      ndis=incr
C@DM      do ip=1,num_pe
C@DM        ncount(ip)=(iflpe(2,ip)-iflpe(1,ip)+1)*nitem
C@DM        ndispl(ip)=ndis
C@DM        ndis=ndis+ncount(ip)
C@DM      end do
C@DM      return
C@DM      end
C@D4      subroutine checkeijmol(mode,n,ifa,ila,indexx)
C@D4c#    MMC routine 475 lstmod: 12/02/96
C@D4c*****Initialize or check solute atom-atom energy terms
C@D4c!!!  Does not work in selftests after rejected torsions
C@D4      dimension indexx(n)
C@D4      common /eijmol/ eijslto(#ST,#ST),eijsltn(#ST,#ST),
C@D4     -  eijslt(#ST,#ST)
C@D4      if (mode .eq. 0) then
C@D4c       Initialize all
C@D4        do ia=1,n
C@D4          do ja=1,n
C@D4            eijslto(ia,ja)=99999.9
C@D4            eijsltn(ia,ja)=99999.9
C@D4          end do
C@D4        end do
C@D4      else if (mode .eq. 1) then
C@D4c       Save into old from fresh
C@D4        write (6,1003) indexx(ifa),indexx(ila),n
C@D4        do iaa=ifa,ila
C@D4          ia=indexx(iaa)
C@D4          do ja=1,n
C@D4            eijslto(ia,ja)=eijslt(ia,ja)
C@D4            eijslto(ja,ia)=eijslt(ja,ia)
C@D4          end do
C@D4        end do
C@D4      else if (mode .eq. 2) then
C@D4c       Save into new from fresh
C@D4        write (6,1004) indexx(ifa),indexx(ila),n
C@D4        do iaa=ifa,ila
C@D4          ia=indexx(iaa)
C@D4          do ja=1,n
C@D4            eijsltn(ia,ja)=eijslt(ia,ja)
C@D4            eijsltn(ja,ia)=eijslt(ja,ia)
C@D4          end do
C@D4        end do
C@D4      else if (mode .eq. 3) then
C@D4c       Save into old from new
C@D4        write (6,1005) indexx(ifa),indexx(ila),n
C@D4        do iaa=ifa,ila
C@D4          ia=indexx(iaa)
C@D4          do ja=1,n
C@D4            eijslto(ia,ja)=eijsltn(ia,ja)
C@D4            eijslto(ja,ia)=eijsltn(ja,ia)
C@D4          end do
C@D4        end do
C@D4      else if (mode .eq. 4) then
C@D4c       Compare with old
C@D4        write (6,1002) indexx(ifa),indexx(ila),n
C@D4        do iaa=ifa,ila
C@D4          ia=indexx(iaa)
C@D4          do ja=1,n
C@D4            if (eijslto(ia,ja) .ne. 99999.9) then
C@D4              if (abs(eijslt(ia,ja)-eijslto(ia,ja))/
C@D4     -          abs(eijslt(ia,ja)+eijslto(ia,ja)) .gt. 1.e-5) then
C@D4                write (6,1000) ia,ja,eijslt(ia,ja),eijslto(ia,ja)
C@D4              end if
C@D4            end if
C@D4            if (eijslto(ja,ia) .ne. 99999.9) then
C@D4              if (abs(eijslt(ja,ia)-eijslto(ja,ia))/
C@D4     -          abs(eijslt(ja,ia)+eijslto(ja,ia)) .gt. 1.e-5) then
C@D4                write (6,1000) ia,ja,eijslt(ja,ia),eijslto(ja,ia)
C@D4              end if
C@D4            end if
C@D4          end do
C@D4        end do
C@D4      end if
C@D4      return
C@D41000  format(' SLT PAIR ENERGY ERROR: ia,ja=',2i6,' eij,eijo=',2e13.6)
C@D41001  format(' SLT PAIR ENERGY ERROR: ia,ja=',2i6,' eij,eijn=',2e13.6)
C@D41002  format(' Checking eij from ',i6,' to ',i6,' n=',i6)
C@D41003  format(' Saving (C->O) eij from ',i6,' to ',i6,' n=',i6)
C@D41004  format(' Saving (C->N) eij from ',i6,' to ',i6,' n=',i6)
C@D41005  format(' Saving (O->N) eij from ',i6,' to ',i6,' n=',i6)
C@D4      end
      subroutine rij2mat(ns1f,ns1l,ns2f,ns2l,nslt1,nslt2,nslv1,nslv2,
     -  isite1,isite2,c1,c2,iop5,idistopt,nexp,rneig2,maxc1,maxc2)
c#    MMC routine 476 lstmod: 02/24/21
c*****Calculate distance matrix for Hungarian Method matching
      dimension c1(3,maxc1),c2(3,maxc2),z(3)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
c     print *,'rij2mat nslt1,nslt2=',nslt1,nslt2,
c    -  ' nslv1,nslv2=',nslv1,nslv2
      if (idistopt .eq. 1) then
        do is1=ns1f,ns1l
          do is2=ns2f,ns2l
            call arrdiff(z,c1(1,nslt1+(is1-1)*nslv1+isite1),
     -        c2(1,nslt2+(is2-1)*nslv2+isite2),3)
            call pbcnd(z(1),z(2),z(3),iop5,iopt,rsw2(is1,is2))
c           write (6,1000) is1,is2,iopt,rsw2(is1,is2),
c    -        c1(1,nslt1+(is1-1)*nslv1+isite1),
c    -        c2(1,nslt2+(is2-1)*nslv2+isite2)
          end do
        end do
      else
c       Neighbor-based distance list
        rnmatch=0.0
        do is1=ns1f,ns1l
          call zeroiti(l1,0,nslt1)
          nn1=0
          do ia=1,nslt1
            ria2=arrdist(c1(1,nslt1+(is1-1)*nslv1+isite1),c1(1,ia))
            if (ria2 .lt. rneig2) then
              nn1=nn1+1
              l1(ia)=1
              l2(nn1)=ia
            end if
          end do
          do is2=ns2f,ns2l
            nn2=0
            rsw2(is1,is2)=0.0
            do ia=1,nslt2
              ria2=arrdist(c2(1,nslt2+(is2-1)*nslv2+isite2),c2(1,ia))
              if (ria2 .lt. rneig2) then
                if (l1(ia) .eq. 1) rsw2(is1,is2)=rsw2(is1,is2)+1.0
                nn2=nn2+1
                l3(nn2)=ia
              end if
            end do
            if (rnmatch .lt. rsw2(is1,is2)) rnmatch=rsw2(is1,is2)
            rnnav=float(nn1+nn2)/2.0
            if (idistopt .eq. 2) then
              rsw2(is1,is2)=rnnav-rsw2(is1,is2)
            else if (idistopt .eq. 3) then
              rsw2(is1,is2)=(rnnav+1)/(1.0+rsw2(is1,is2))
            else if (idistopt .eq. 4) then
              call arrdiff(z,c1(1,nslt1+(is1-1)*nslv1+isite1),
     -          c2(1,nslt2+(is2-1)*nslv2+isite2),3)
              call pbcnd(z(1),z(2),z(3),iop5,iopt,r12)
              rsw2(is1,is2)=sqrt(r12)*(rnnav+1)/(1.0+rsw2(is1,is2))
            else
              call tanimoto(l2,nn1,l3,nn2,sim)
              if (nexp .gt. 1) then
                dsw=(1.0-sim)**nexp
              else if (nexp .lt. -1) then
                dsw=(1.0-sim)**(1.0/float(-nexp))
              else
                dsw=1.0-sim
              end if
              rsw2(is1,is2)=dsw
            end if
          end do
        end do
        l1(1)=rnmatch
      end if
      return
c1000  format(' DB is1,2=',2i4,' iopt=',i2,' rij2=',e10.3,
c     -  ' c1=',3f10.5,' c2=',3f10.5)
      end
      subroutine rij2matcorr(ns1f,ns1l,ns2f,ns2l,nslt1,nslt2,
     -  nslv1,nslv2,isite1,isite2,c1,c2,iop5,idistopt,nexp,rneig2,iout)
c#    MMC routine 476/a lstmod: 08/02/13
c*****Calculate correlation between distance matrix and neighbor-based measure
      dimension c1(3,#NA),c2(3,#NA),z(3)
      common /worksp/ l1(#NA),l2(#UV),l3(#UV),l4(#UV)
      character*4 optlab(5)
      real*8 rsum,rsum2,dsum,dsum2,rdsum
      data optlab /'    ','ENVN','ENVI','ENVM','TANI'/
      rsum=0.d0
      rsum2=0.d0
      dsum=0.d0
      dsum2=0.d0
      rdsum=0.d0
      do is1=ns1f,ns1l
        call zeroiti(l1,0,nslt1)
        nn1=0
        do ia=1,nslt1
          ria2=arrdist(c1(1,nslt1+(is1-1)*nslv1+isite1),c1(1,ia))
          if (ria2 .lt. rneig2) then
            nn1=nn1+1
            l1(ia)=1
            l2(nn1)=ia
          end if
        end do
        do is2=ns2f,ns2l
          nn2=0
          dsw=0.0
          do ia=1,nslt2
            ria2=arrdist(c2(1,nslt2+(is2-1)*nslv2+isite2),c2(1,ia))
            if (ria2 .lt. rneig2) then
              if (l1(ia) .eq. 1) dsw=dsw+1.0
              nn2=nn2+1
              l3(nn2)=ia
            end if
          end do
          rnnav=float(nn1+nn2)/2.0
          if (idistopt .eq. 2) then
            dsw=rnnav-dsw
          else if (idistopt .eq. 3) then
            dsw=(rnnav+1)/(1.0+dsw)
          else if (idistopt .eq. 4) then
            call arrdiff(z,c1(1,nslt1+(is1-1)*nslv1+isite1),
     -        c2(1,nslt2+(is2-1)*nslv2+isite2),3)
            call pbcnd(z(1),z(2),z(3),iop5,iopt,rsw2)
            dsw=sqrt(rsw2)*(rnnav+1)/(1.0+dsw)
          else
            call tanimoto(l2,nn1,l3,nn2,sim)
            if (nexp .gt. 1) then
              dsw=(1.0-sim)**nexp
            else if (nexp .lt. -1) then
              dsw=(1.0-sim)**(1.0/float(-nexp))
            else
              dsw=1.0-sim
            end if
          end if
          call arrdiff(z,c1(1,nslt1+(is1-1)*nslv1+isite1),
     -      c2(1,nslt2+(is2-1)*nslv2+isite2),3)
          call pbcnd(z(1),z(2),z(3),iop5,iopt,rsw2)
          rsw=sqrt(rsw2)
          rsum=rsum+rsw
          rsum2=rsum2+rsw2
          dsum=dsum+dsw
          dsum2=dsum2+dsw**2
          rdsum=rdsum+rsw*dsw
        end do
      end do
      nsum=(ns1l-ns1f+1)*(ns2l-ns2f+1)
      rsum=rsum/nsum
      rsum2=rsum2/nsum
      dsum=dsum/nsum
      dsum2=dsum2/nsum
      rdsum=rdsum/nsum
c     print *,'nsum,rsum,dsum=',nsum,rsum,dsum
c     print *,'rsum2,dsum2=',rsum2,dsum2,' rdsum=',rdsum
      pcorr=(rdsum-rsum*dsum)/
     -  (dsqrt(rsum2-rsum**2)*dsqrt(dsum2-dsum**2))
      write (iout,1000) optlab(idistopt),sqrt(rneig2)
      write (iout,1004) pcorr
      return
1000  format(' Distance option=',a,/,' Neighborhood cutoff=',f6.2,' A')
1004  format(' Pearson correlation between the distane measure and ',
     -  'the actual distance=',f6.3)
      end
      subroutine tanimoto(list1,n1,list2,n2,sim)
C*****Calculate the Tanimoto coef of neghbour lists
c#    MMC routine 476/b lstmod: 05/06/13
      dimension list1(n1),list2(n2)
      n12=0
      i1=1
      i2=1
      do while (i1 .le. n1 .and. i2 .le. n2)
        if (list1(i1) .eq. list2(i2)) then
          n12=n12+1
          i1=i1+1
        else if (list1(i1) .lt. list2(i2)) then
          i1=i1+1
        else
          i2=i2+1
        end if
      end do
      sim=float(n12)/float(n1+n2-n12)
      return
      end
      subroutine addsite(iwadd,nsnew,nw,ioppbc,iout)
c#    MMC routine 477 lstmod: 12/05/01
c*****Add a solvent as a new site
      common /hunginfo/ csini(3,#MH),cscurr(3,#MH),csw(3,#MO),
     -  frocc(#MH),rdevsw(#MH),rdiffcnv(#MH),rmx,rdiff2,niter,ns,
     -  nused,maxmaxng
      if (nsnew .gt. #MH) then
        write (iout,1024) 'MH'
        call datprt(2)
      end if
      call trnsfr(csini(1,nsnew),csw(1,iwadd),3)
      call trnsfr(cscurr(1,nsnew),csw(1,iwadd),3)
      call rij2mat(nsnew,nsnew,1,nw,0,0,1,1,1,1,csini,csw,ioppbc,1,1,
     -  0.0,#MH,#MH)
      return
1024  format(' ***** ERROR: Can not add a new site: maximum number of ',
     -  'sites (#MH) has been exhausted - recompile with larger #',a2)
      end
      subroutine minmat(nsite,nwat,rcutxst,rmaxmatch,r2sum,r2max,nmat,
     -  nmiter,niter,reps,nmc,maxmaxng,mustsolv)
c#    MMC routine 478 lstmod: 09/11/04
c*****Finds the matching that minimizes the largest matching distance
c     nsite is the number of sites, nwat is the number of waters to be
c     assigned to sites, rsw2(is,iw) is the distance square between site
c     is and water iw
c     r2cutx is initially the starting cutoff inputted and will return the
c     best cutoff that still produces complete matching. r2sum is the
c     corresponding deviation square sum.
c     iwofsx(is) is the water assigned to site is (or zero)
c     isofwx(is) is the site assigned to water iw (or zero)
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      common /hungmatch/ nns(#MH),ineigs(#NH,#MH),nnw(#MO),
     -  ineigw(#NH,#MO),iwofsx(#MH),isofwx(#MO),nnsorg(#MH),
     -  nnworg(#MO)
c     maxhmneig is the maximum number of initial neighbors
      maxhmneig=#NH
      nxincr=0
      nxredu=0
11    rcutx=rcutxst
10    rcut=rcutx
      r2cut=rcut**2
c     rcuty is the largest cutoff tried that does not give complete matching
      rcuty=0
      nmiter=0
c     Set up neigbour list within rcut
      call zeroiti(nns,0,nsite)
      call zeroiti(nnw,0,nwat)
      maxns=0
      maxnw=0
      minns=maxhmneig
      minnw=maxhmneig
      do is=1,nsite
        do iw=1,nwat
          if (rsw2(is,iw) .le. r2cut) then
            nns(is)=nns(is)+1
            if (nns(is) .le. maxhmneig) ineigs(nns(is),is)=iw
            nnw(iw)=nnw(iw)+1
            if (nnw(iw) .le. maxhmneig) ineigw(nnw(iw),iw)=is
          end if
        end do
        if (maxns .lt. nns(is)) maxns=nns(is)
        if (minns .gt. nns(is)) minns=nns(is)
      end do
      do iw=1,nwat
        if (maxnw .lt. nnw(iw)) maxnw=nnw(iw)
        if (minnw .gt. nnw(iw)) minnw=nnw(iw)
      end do
      if (maxmaxng .lt. maxns) maxmaxng=maxns
      if (maxmaxng .lt. maxnw) maxmaxng=maxnw
      if (idebug(62) .gt. 0 .or. maxns .gt. maxhmneig .or.
     -     maxnw .gt. maxhmneig)
     -  write (iout,1002) nmc,nsite,nwat,rcutx,maxns,maxnw,minns,minnw
      if (idebug(62) .gt. 1) then
        write (iout,1005) 'Site',(nns(is),is=1,nsite)
        write (iout,1005) 'Solvent',(nnw(iw),iw=1,nwat)
      end if
      if (minnw .eq. 0) then
        if (rmaxmatch .gt. 0.0 .and. nsite .gt. nwat .and.
     -      rmaxmatch .le. rcut) then
c         Add one water without neighbors to the site list
          iwadd=1
          do while (nnw(iwadd) .gt. 0)
            iwadd=iwadd+1
          end do
          call addsite(iwadd,nsite+1,nwat,iop(5),iout)
          nsite=nsite+1
          nns(nsite)=1
          ineigs(1,nsite)=iwadd
          nnw(iwadd)=1
          ineigw(1,iwadd)=nsite
          write (iout,1021) niter,nmc,iwadd,rcut,nsite
        end if
      end if
      if (maxns .gt. maxhmneig .or. maxnw .gt. maxhmneig) then
c       rcutxst allows too many neigbor sites to start with - reduce by 10%
        if (nxincr .gt. 0) then
          write (iout,1004)  maxhmneig
          call datprt(2)
        end if
        rcutxst=rcutxst*0.9
        nxredu=nxredu+1
        write (iout,1003) maxhmneig,rcutxst
        nwwarn=nwwarn+1
        if (rcut .lt. 1.0) then
          write (iout,1006)
          call datprt(2)
        end if
        go to 11
      end if
      call sortn(nsite,nns,nnsorg,ineigs,+1,maxhmneig,#MH)
      call sortn(nwat,nnw,nnworg,ineigw,-1,maxhmneig,#MO)
c     Now see if complete matching can be achieved
100   nmiter=nmiter+1
      if (nsite .le. nwat) then
        call hungass(nsite,nwat,nns,ineigs,nnw,ineigw,iwofsx,isofwx,
     -    nswap,nmatch,iout,idebug(117),maxhmneig)
        nmiss=nsite-nmatch
      else
        call hungass(nwat,nsite,nnw,ineigw,nns,ineigs,isofwx,iwofsx,
     -    nswap,nmatch,iout,idebug(117),maxhmneig)
        nmiss=nwat-nmatch
      end if
      if (nmiter .eq. 1 .and. mustsolv .eq. 1 .and. nmiss .gt. 0) then
c       Initial cutoff is too small - no full matching. Increase rcutx
        if (nxredu .gt. 0) then
          write (iout,1004)  maxhmneig
          call datprt(2)
        end if
        rcutx=rcutx*1.05
        nxincr=nxincr+1
        if (idebug(62) .gt. 0) write (iout,1012) nmiss,rcut,rcutx,rcuty
        go to 10
      end if
      if (idebug(62) .gt. 0)
     -  write (iout,1000) nmiter,nmiss,nswap,rcut,rcuty,rcutx
      if (nmiss .eq. 0 .or. nmiter .eq. 1) then
c       Save isofwx,iwofsx,rcut
        do is=1,nsite
          iwofs(is)=iwofsx(is)
        end do
        do iw=1,nwat
          isofw(iw)=isofwx(iw)
        end do
        nmat=nmatch
c       Calculate deviation square sums
        r2sum=0.0
        r2max=0.0
        do is=1,nsite
          if (iwofs(is). gt. 0) then
            rswsq=rsw2(is,iwofs(is))
            r2sum=r2sum+rswsq
            if (r2max .lt. rswsq) r2max=rswsq
            if (rswsq .gt. r2cut) then
              write (iout,6233) is,iwofs(is),rswsq
6233          format(' Cutoff error for is,iwofs(is)=',2i4,
     -         ' rswsq=',f8.2)
              r2max=r2cut
            end if
          end if
        end do
        r2sum=r2sum/min0(nsite,nwat)
        if (nmiss .gt. 0) return
        rcut=sqrt(r2max)
        if (rcut-rcuty .le. reps) return
        rcutx=rcut
c       Reduce rcut
        nred=0
        do while (nred .eq. 0)
          rcut=(rcut+rcuty)/2.0
          r2cut=rcut*rcut
          if (idebug(62) .gt. 0)
     -      write (iout,1011) rcut,sqrt(r2max),rcutx,rcuty
c         Reduce nns,nnw
          call scaled(nsite,nns,ineigs,r2cut,nred,+1,maxhmneig,#MH)
          call scaled(nwat,nnw,ineigw,r2cut,nred,-1,maxhmneig,#MO)
        end do
      else
        nred=0
        do while (nred .eq. 0)
          if (rcutx-rcut .lt. reps) return
c         Increase rcut
          rcuty=rcut
          rcut=(rcut+rcutx)/2.0
          r2cut=rcut*rcut
          if (idebug(62) .gt. 0)
     -      write (iout,1012) nmiss,rcut,rcutx,rcuty
c         Increase nns,nnw
          call scaleu(nsite,nns,nnsorg,ineigs,r2cut,nred,+1,maxhmneig,
     -      #MH)
          call scaleu(nwat,nnw,nnworg,ineigw,r2cut,nred,-1,maxhmneig,
     -      #MO)
        end do
      end if
c     Check again for the existence of matching
      go to 100
1000  format(' MINMAT matching iteration',i3,' nmiss,nswap=',2i4,
     -  ' rcut=',f8.3,' rcut min,max=',2f8.3)
1002  format(' MINMAT nmc=',i11,' nsite,nwater=',2i5,' maximum number',
     -  ' of neighbours with rcutx=',f6.3,' A for sites:',i4,
     -  ' for solvents:',i4,/,7x,' minimum number of neighbors: ',2i5)
1003  format(' ===== STRONG WARNING: initial number of neighbors ',
     -  'exceeds limit (',i3,') - initial cutoff rxutx is reduced to ',
     -  f6.3,' A')
1004  format(' ***** ERROR: Current size of neighbor list in minmat (',
     -  i4,') could not result in complete matching.',/,
     -  7x,'Increase maxhmneig (# NH) and recompile')
1005  format(1x,a,' neigbor numbers:',/,(1x,25i4))
1006  format(' ***** ERROR: cutoff was reduced below 1 A without ',
     -  'achieving complete matching')
1011  format(' MINMAT reduce, rcut,max,x,y=',4f8.2)
1012  format(' MINMAT nmiss=',i5,' increase rcut to',f8.2,
     -  ' rcutx,y=',3f8.2)
1021  format(' +++++ Iteration ',i4,' Nmc=',i10,' solvent ',i4,' has ',
     -  'no site within ',f8.3,' A - it has been added as a new site ',
     -  ' number',i5)
      end
      subroutine mergesites(c,nslt,nsite,clstmerge_dmax,froccpairmax,
     -  csite,frocc,rdev,cv,eng,nofcls,ifirst,ilast,iclst,inperr,iout)
c#    MMC routine 479 lstmod: 07/09/13
c*****Cluster sites that are (too) close
      real*8 eng
      dimension c(3,nslt),csite(3,nsite),frocc(nsite),rdev(nsite),
     -  cv(nsite),eng(nsite),ifirst(nsite),ilast(nsite),iclst(nsite)
c     nsite is the number of sites,
      common /option/ iop(200),idebug(200)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      common /gather/ itemp(#UV),nnloop(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),nneigs(#UV),nnhslt(#UV),ineigx(13,#UV)
      common /hungmatch/ nns(#MH),ineigs(#NH,#MH),nnw(#MO),
     -  ineigw(#NH,#MO),iwofsx(#MH),isofwx(#MO),nnsorg(#MH),
     -  nnworg(#MO)
      write (iout,1007) clstmerge_dmax,froccpairmax
      call rij2mat(1,nsite,1,nsite,0,0,1,1,1,1,csite,csite,iop(5),1,1,
     -  0.0,nsite,nsite)
c     Set up neigbour list within clstmerge_dmax
      call zeroiti(nns,0,nsite)
      clstmerge_dmax2=clstmerge_dmax**2
      nclose=0
      do is=1,nsite
        do js=is+1,nsite
          if (rsw2(is,js) .le. clstmerge_dmax2 .and.
     -        frocc(is)+frocc(js) .le. froccpairmax) then
            nns(is)=nns(is)+1
            nns(js)=nns(js)+1
            ineigs(nns(is),is)=js
            ineigs(nns(js),js)=is
            nclose=nclose+1
          end if
        end do
      end do
      write (iout,1004) clstmerge_dmax,froccpairmax,nclose
      call clstrs(ineigs,nns,nnloop,1,nsite,iclst,ifirst,ilast,0,
     -  nofcls,nnw,iout,inperr,nww,0,nsite,nsite,#NH,4,1)
      if (nofcls .lt. nsite) write (iout,1005) nofcls
      if (nofcls .eq. nsite) write (iout,1006)
      call indexit(itemp,1,nsite,0)
      call clustersiteprint(c,nslt,nofcls,crmgs,frocc1,bfac1,frocc2,
     -  bfac2,csite,frocc,rdev,cv,eng,ifirst,ilast,iclst,itemp,
     -  clstmerge_dmax,froccpairmax,1,0,iop(5),iout,nsite)
c     Put back into csite, frocc, rdev, cv, eng the combined values
      do is=1,nofcls
        frocc(is)=frocc1(is)
        rdev(is)=bfac1(is)
        cv(is)=frocc2(is)
        eng(is)=bfac2(is)
        call trnsfr(csite(1,is),crmgs(1,is),3)
c        write (iout,9822) is,(csite(k,is),k=1,3),frocc(is),rdev(is),
c     -    cv(is),eng(is)
c9822    format(i5,' c=',3e10.5,' frocc,rdev,cv,eng=',4f12.5)
      end do
      call trnsfr(cgs(1,nslt+1),crmgs,3*nofcls)
      return
1004  format(' The number of site pairs within ',f6.2,' A ',
     -  'and occupancy sum < ',f5.3,' =',i4)
1005  format(' The number of sites are reduced by clustering to ',i4)
1006  format(' The number of sites was not changed by clustering')
1007  format(' Clustering generic sites',/,
     -  9x,'Maximum distance for pairing=',f6.2,' A',/,
     -  9x,'Maximum occupancy sum for combined sites=',f5.2)
      end
      subroutine cluster_sites(c,nslt,nsite,clstfin_dmax,nclust_clstfin,
     -  istow,cvfilt_stow,froccmin_stow,rmsdlim_stow,maxclstmem_stow,
     -  subreground,csite,frocc,rdev,cv,eng,cvfilt_traj,cvfilt_trajcut,
     -  nofcls,ifirst,ilast,iclst,nmcdisc,filename_gs,namlen_gs,igrslv,
     -  numrun,inperr,iout_inf,iout)
c#    MMC routine 479/a lstmod: 07/11/16
      real*8 eng
      dimension c(3,nslt),csite(3,nsite),frocc(nsite),rdev(nsite),
     -  cv(nsite),eng(nsite),igrslv(nsite),ifirst(nsite),ilast(nsite),
     -  iclst(nsite)
      character*80 filename_gs
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      common /hungmatch/ nns(#MH),ineigs(#NH,#MH),nnw(#MO),
     -  ineigw(#NH,#MO),iwofsx(#MH),isofwx(#MO),nnsorg(#MH),
     -  nnworg(#MO)
      character*80 file,filenames
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /option/ iop(200),idebug(200)
      common /gather/ itemp(#UV),nnloop(#UV),indexn(#UV),
     -  nisoo(#UV),ivtm(#UV),crmgs(3,#UV),cgs(3,#HA),
     -  texng(#UV),nneigs(#UV),nnhslt(#UV),ineigx(13,#UV)
      character*1 yn
      character*80 filename1
      write (iout,1001) clstfin_dmax
      write (iout,1002) 'CV',cvfilt_stow
      write (iout,1002) 'occupancy',froccmin_stow
      if (rmsdlim_stow .gt. 0.0) write (iout,1003) rmsdlim_stow
      call rij2mat(1,nsite,1,nsite,0,0,1,1,1,1,csite,csite,iop(5),1,1,
     -  0.0,nsite,nsite)
      if (clstfin_dmax .gt. 0.0) then
c       Set up neigbour list within clstfin_dmax
        call zeroiti(nns,0,nsite)
        cut2=clstfin_dmax**2
        do is=1,nsite
          do js=is+1,nsite
            if (rsw2(is,js) .le. cut2) then
              nns(is)=nns(is)+1
              nns(js)=nns(js)+1
              ineigs(nns(is),is)=js
              ineigs(nns(js),js)=is
            end if
          end do
        end do
        call indexit(itemp,1,nsite,0)
        call clstrs(ineigs,nns,nnloop,1,nsite,iclst,ifirst,ilast,0,
     -    nofcls,nnw,iout,inperr,nww,0,nsite,nsite,#NH,4,1)
      else
c       Cluster targeting nclust_clstfin clusters
        rsw2min=1000.0
        rsw2max=0.0
        do is=1,nsite
          do js=is+1,nsite
            if (rsw2min .gt. rsw2(is,js)) rsw2min=rsw2(is,js)
            if (rsw2max .lt. rsw2(is,js)) rsw2max=rsw2(is,js)
          end do
        end do
        nofcls=0
        ntry=0
        maxtry=100
        do while (nofcls .ne. nclust_clstfin .and. ntry .lt. maxtry)
          ntry=ntry+1
          cut2=(rsw2max+rsw2min)/2.0
          call zeroiti(nns,0,nsite)
          do is=1,nsite
            do js=is+1,nsite
              if (rsw2(is,js) .le. cut2) then
                nns(is)=nns(is)+1
                nns(js)=nns(js)+1
                ineigs(nns(is),is)=js
                ineigs(nns(js),js)=is
              end if
            end do
          end do
          call indexit(itemp,1,nsite,0)
          call clstrs(ineigs,nns,nnloop,1,nsite,iclst,ifirst,ilast,0,
     -      nofcls,nnw,iout,inperr,nww,0,nsite,nsite,#NH,4,1)
          if (nofcls .lt. nclust_clstfin) rsw2max=cut2
          if (nofcls .gt. nclust_clstfin) rsw2min=cut2
          write (iout,1017) ntry,sqrt(cut2),nofcls,nclust_clstfin
        end do
        if (ntry .eq. maxtry) write (iout,1018)
      end if
      call clustersiteprint(c,nslt,nofcls,crmgs,frocc1,bfac1,frocc2,
     -  bfac2,csite,frocc,rdev,cv,eng,ifirst,ilast,iclst,itemp,
     -  clstmerge_dmax,0.0,0,1,iop(5),iout_inf,nsite)
      if (istow .eq. 1) then
        call fileopen(file,namlenf,filename1,namlen1,
     -    34,1,numrun,0,3,0,iop(24),iversout,iout,iout_stow,0)
        yn='n'
        if (iop(59) .eq. 2) yn='y'
        ieuler=1
        write (iout_stow,1004) subreground,filename_gs(1:namlen_gs),
     -    filenames(32)(1:namlens(32)),yn,filenames(3)(1:namlens(3)),
     -    nmcdisc
        if (cvfilt_traj .gt. 0.0) then
          write (iout_stow,1015) cvfilt_traj,cvfilt_trajcut
        else
          write (iout_stow,1016)
        end if
        write (iout_stow,1014) ieuler
        nskip=0
        ifirstcl=1
        do ic=1,nofcls
          iskip=0
          if (maxclstmem_stow .gt. 0) then
            if (ilast(ic)-ifirst(ic)+1 .gt. maxclstmem_stow) iskip=1
          end if
          occmin=1000.0
          cvmin=1000.0
          rmsdmax=0.0
          do is=ifirst(ic),ilast(ic)
            if (cv(iclst(is)) .lt. cvmin) cvmin=cv(iclst(is))
            if (frocc(iclst(is)) .lt. occmin) occmin=frocc(iclst(is))
            if (rdev(iclst(is)) .gt. rmsdmax) rmsdmax=rdev(iclst(is))
          end do
          if (cvmin .lt. cvfilt_stow) iskip=1
          if (occmin .le. froccmin_stow) iskip=1
          if (rmsdlim_stow .gt. 0.0 .and. rmsdmax .gt. rmsdlim_stow)
     -      iskip=1
          if (iskip .eq. 0) then
            if (ifirstcl .eq. 0) then
              write (iout_stow,1008) 'y'
            else
              ifirstcl=0
            end if
            write (iout_stow,1010) ilast(ic)-ifirst(ic)+1
            do iw=ifirst(ic),ilast(ic)
              write (iout_stow,1005) itemp(iclst(iw))
            end do
            write (iout_stow,1007)
            do iw=ifirst(ic),ilast(ic)
              write (iout_stow,1006)
            end do
            write (iout_stow,1008) 'n'
          end if
          nskip=nskip+iskip
        end do
        write (iout_stow,1008) 'n'
        write (iout,1009) filename1(1:namlen1)
        if (cvfilt_stow .gt. 0.0) write (iout,1011) 'CV',cvfilt_stow
        if (froccmin_stow .gt. 0.0)
     -    write (iout,1011) 'occupancy',froccmin_stow
        if (maxclstmem_stow .gt. 0) write (iout,1012) maxclstmem_stow
        if (nskip .eq. nofcls) write (iout,1013)
        call fileclose(iout_stow,0,iop(24),iout)
      end if
c     Now rearrange the entries
      do ic=1,nofcls
        do ia=ifirst(ic),ilast(ic)
          igrslv(ia)=ic
          frocc1(ia)=frocc(iclst(ia))
          bfac1(ia)=rdev(iclst(ia))
          frocc2(ia)=cv(iclst(ia))
          bfac2(ia)=eng(iclst(ia))
          frocc1(ia)=frocc(iclst(ia))
          call trnsfr(crmgs(1,ia),csite(1,iclst(ia)),3)
        end do
      end do
      call trnsfr(frocc,frocc1,nsite)
      call trnsfr(rdev,bfac1,nsite)
      call trnsfr(cv,frocc2,nsite)
      call trnsfrdr(eng,bfac2,nsite)
      call trnsfr(csite,crmgs,3*nsite)
      return
1001  format(' Clustering the sites with Rcut=',f8.4,' A')
1002  format(' Clusters where the smallest ',a,' value is < ',f6.4,
     -  ' will be dropped')
1003  format(' Clusters where the largest RMSD value is > ',f6.3,
     -  ' will be dropped')
1004  format('n',/,f5.3,/,a,/,a,/,'4',/,a1,/,a,/,i9)
1005  format(i5)
1006  format(/,'y')
1007  format('n',/,'n',/,'n')
1008  format(a1)
1009  format(' Entropy calculation input for the program STOW_GS has ',
     -  'been written to the file ',a)
1010  format(i2)
1011  format(' Clusters with lowest ',a,' < ',f8.4,' were skipped')
1012  format(' Clusters where the number of members is > ',
     -  i2,' were skipped')
1013  format(' ///// NOTE: all clusters were filtered out')
1014  format(i1,/,'n')
1015  format('y',f8.4,/,f8.4)
1016  format('n')
1017  format(' Ntry=',i3,' cutoff used=',f8.2,' A # of clusters found=',
     -  i4,' # of clusters requested=',i4)
1018  format(' ERROR: Could not find the right cutoff in ',i4,
     -  ' iterations')
      end
      subroutine clustersiteprint(c,nslt,nofcls,csite1,frocc1,bfac1,cv1,
     -  eng1,csite,frocc,rdev,cv,eng,ifirst,ilast,iclst,index,
     -  clstmerge_dmax,froccpairmax,idistprint,iproxprint,iop5,iout,ns)
c#    MMC routine 479/b lstmod: 07/09/13
      real*8 eng
      dimension c(3,nslt),csite1(3,ns),frocc1(ns),bfac1(ns),cv1(ns),
     -  eng1(ns),csite(3,ns),frocc(ns),rdev(ns),cv(ns),eng(ns),
     -  ifirst(nofcls),ilast(nofcls),iclst(ns),index(ns)
      character*4 labslt,labslv,namslv
      character*6 pflabslt,pflabslv
      character*8 fcglab
      common /solutelab/ labslt(2,#ST),labslv(#SV),namslv,
     -  pflabslt(#ST),pflabslv(#SV),fcglab(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      dimension z(3)
      if (iproxprint .eq. 1) write (iout,2000)
      do ic=1,nofcls
        frocc1(ic)=0.0
        cv1(ic)=0.0
        bfac1(ic)=0.0
        eng1(ic)=0.0
        call zeroit(z,3)
        if (ifirst(ic) .eq. ilast(ic)) then
c         Real site
          iss=iclst(ifirst(ic))
          if (iproxprint .eq. 0) then
            write (iout,1000) ic,index(iss),(csite(k,iss),k=1,3),
     -        frocc(iss),rdev(iss),cv(iss),eng(iss)
          else
            call findprox0(c,nslt,csite(1,iss),iprox,rij,ianslt,nslt)
            write (iout,2001) ic,index(iss),(csite(k,iss),k=1,3),
     -        frocc(iss),rdev(iss),cv(iss),eng(iss),labslt(2,iprox),
     -        iprox,labslt(1,iprox),igrslt(iprox)
          end if
          call trnsfr(csite1(1,ic),csite(1,iss),3)
          frocc1(ic)=frocc(iss)
          cv1(ic)=cv(iss)
          bfac1(ic)=rdev(iss)
          eng1(ic)=eng(iss)
        else
          nmem=ilast(ic)-ifirst(ic)+1
          do im=ifirst(ic),ilast(ic)
            iss=iclst(im)
            if (iproxprint .eq. 0) then
              write (iout,1001) ic,im-ifirst(ic)+1,index(iss),
     -          (csite(k,iss),k=1,3),frocc(iss),rdev(iss),cv(iss),
     -          eng(iss)
            else
              call findprox0(c,nslt,csite(1,iss),iprox,rij,ianslt,nslt)
              write (iout,2001) ic,index(iss),(csite(k,iss),k=1,3),
     -          frocc(iss),rdev(iss),cv(iss),eng(iss),labslt(2,iprox),
     -         iprox,labslt(1,iprox),igrslt(iprox)
            end if
            frocc1(ic)=frocc1(ic)+frocc(iss)
            bfac1(ic)=bfac1(ic)+frocc(iss)*rdev(iss)**2
            cv1(ic)=cv1(ic)+frocc(iss)*cv(iss)
            eng1(ic)=eng1(ic)+frocc(iss)*eng(iss)
            do k=1,3
              z(k)=z(k)+frocc(iss)*csite(k,iss)
            end do
          end do
c         Combine sites
          if (frocc1(ic) .gt. 0.0) then
            bfac1(ic)=sqrt(bfac1(ic)/frocc1(ic))
            eng1(ic)=eng1(ic)/frocc1(ic)
            cv1(ic)=cv1(ic)/frocc1(ic)
            do k=1,3
              csite1(k,ic)=z(k)/frocc1(ic)
            end do
          end if
          if (iproxprint .eq. 0) then
            write (iout,1002) ic,(csite1(k,ic),k=1,3),
     -        frocc1(ic),bfac1(ic),cv1(ic),eng1(ic)
            if (nmem .gt. 2 .and. frocc1(ic) .gt. froccpairmax)
     -        write (iout,1004) froccpairmax
          else
            write (iout,2002) (csite1(k,ic),k=1,3),
     -        frocc1(ic),bfac1(ic),cv1(ic),eng1(ic)
          end if
          if (idistprint .eq. 1) then
            do im=ifirst(ic),ilast(ic)
              do in=im+1,ilast(ic)
                call arrdiff(z,csite(1,iclst(im)),csite(1,iclst(in)),3)
                call pbcnd(z(1),z(2),z(3),iop5,iopt,rimin2)
                write (iout,1006) iclst(im),iclst(in),sqrt(rimin2)
              end do
            end do
          end if
          if (idistprint .eq. 1 .and. frocc1(ic) .gt. 1.05)
     -      write (iout,1003) ic,nmem,frocc1(ic),clstmerge_dmax
        end if
      end do
      return
1000  format(' Single site ',i4,' (',i4,') c=',3f10.5,' frocc=',f7.4,
     -  ' RMSD=',f6.2,' A CV(wrt solute)=',f7.5,' eng=',f9.2,
     -  ' kcal/mol',1x,a4,i5,1x,a4,i5)
1001  format(' Cluster ',i4,' /',i2,' (',i4,') c=',3f10.5,
     -  ' frocc=',f7.4,' RMSD=',f6.2,' A CV=',f8.5,
     -  ' eng=',f12.3,' kcal/mol',1x,a4,i5,1x,a4,i5)
1002  format(' Cluster site ',i4,5x,'<c>=',3f10.5,' frocc(sum)=',f7.4,
     -  ' <RMSD>=',f6.2,' <CV>=',f8.5,' <eng>=',f12.3)
1003  format(' Cluster site ',i4,' has ',i2,' members with a total ',
     -  'occupancy of ',f6.4,' indicating more than one solvents.',/,
     -  9x,'To separate them reduce either clstmerge_dmax (current ',
     -  'value=',f6.2,' A) or froccpairmax (current value=',f6.2,')')
1004  format(' ///// NOTE: more than two sites merged with occupancy  ',
     -  'sum > ',f5.3)
1006  format(9x,'Distance between sites',i5,' and',i5,' is ',f6.2,' A')
2000  format(/,'  CLS   GS      X         Y          Z      Occ',
     -  '    RMS    CV           E        Atom      Res')
2001  format(2i5,3f10.5,f8.5,f6.2,f8.5,f12.3,1x,a4,i5,1x,a4,i5)
2002  format(' Cls Ctr  ',3f10.5,f8.4,f6.2,f8.5,f12.3)
      end
      subroutine cluster_frames(nsite,iadjac,adjac_12,adjac_22,nsite_2,
     -  iuse2nd,iconn_cum,nofcls,ifirst,ilast,iclst,maxsites,inperr,
     -  iout)
c#    MMC routine 479/c lstmod: 05/20/14
c*****Cluster waters of a frame based on an adjacency matrix
      dimension iadjac(maxsites,maxsites),adjac_22(maxsites,maxsites),
     -  adjac_12(maxsites,maxsites),iconn_cum(maxsites,maxsites),
     -  ifirst(maxsites),ilast(maxsites),iclst(maxsites)
c     nsite is the number of sites,
      common /option/ iop(200),idebug(200)
      common /hungmatch/ nns(#MH),ineigs(#NH,#MH),nnloop(#MO),
     -  ineigw(#NH,#MO),iwofsx(#MH),isofwx(#MO),nnsorg(#MH),
     -  iused(#MO)
c     Set up neigbour list form the adjaceny matrix
c     write (iout,*) 'CLUSTER_FRAMES nsite=',nsite,' nsite_2=',nsite_2
      if (iuse2nd .gt. 0 .and. nsite+nsite_2 .gt. #MH) then
        write (iout,1000)
        inperr=inperr+1
        return
      end if
      call zeroiti(nns,0,nsite)
      nbtot=0
      do is=1,nsite
        do js=is+1,nsite
          if (iadjac(is,js) .gt. 0) then
            nns(is)=nns(is)+1
            nns(js)=nns(js)+1
            ineigs(nns(is),is)=js
            ineigs(nns(js),js)=is
            nbtot=nbtot+1
          end if
        end do
      end do
      if (iuse2nd .eq. 1) then
        nscls=nsite+nsite_2
        call zeroiti(nns,nsite,nscls)
        do i22=1,nsite_2
          i2=nsite+i22
          do is=1,nsite
            if (adjac_12(is,i22) .gt. 0.0) then
              nns(i2)=nns(i2)+1
              nns(is)=nns(is)+1
              ineigs(nns(is),is)=i2
              ineigs(nns(i2),i2)=is
c              write (iout,8561) i22,i2,is,nns(i2),ineigs(nns(i2),i2),
c     -          nns(is),ineigs(nns(is),is)
c8561  format(' BOND i22,i2,is=',3i4,' nn,in(i2)=',i3,i4,' nn,in(is)=',
c     -  i3,i4)
            end if
          end do
        end do
        do i22=1,nsite_2
          i2=nsite+i22
          do iss=1,i22-1
            is=nsite+iss
            if (adjac_22(iss,i22) .gt. 0.0) then
              nns(i2)=nns(i2)+1
              nns(is)=nns(is)+1
              ineigs(nns(is),is)=i2
              ineigs(nns(i2),i2)=is
            end if
          end do
        end do
      else
        nscls=nsite
      end if
      call clstrs(ineigs,nns,nnloop,1,nscls,iclst,ifirst,ilast,0,
     -  nofcls,iused,iout,inperr,nww,0,maxsites,maxsites,#NH,4,1)
      do ic=1,nofcls
        do is=ifirst(ic),ilast(ic)
          do js=ifirst(ic),ilast(ic)
            iconn_cum(iclst(is),iclst(js))=
     -        iconn_cum(iclst(is),iclst(js))+1
          end do
        end do
      end do
      return
1000  format(' ***** ERROR: number of solvent and solute sites exceeds',
     -  ' the limit - increase # MH and recompile')
      end
      subroutine plot_adj(iadj,adj,ireal,ndim,iout,inperr,maxdim)
c#    MMC routine 479/d lstmod: 02/22/2016
c*****Produce a printer plot of an adjacency matrix
      dimension iadj(maxdim,maxdim),adj(maxdim,maxdim)
      character*2000 line
      if (ireal .eq. 0) write (iout,1003)
      if (ireal .eq. 1) write (iout,1004)
      if (ndim .gt. 2000) then
        write (iout,1005)
        inperr=inperr+1
        return
      end if
      write (iout,1001) (10*i,i=1,ndim/10)
      do i=1,ndim
        do j=1,ndim
          if (mod(i,10) .eq. 0) then
            line(j:j)='-'
          else
            line(j:j)='.'
          end if
          if (mod(j,10) .eq. 0) line(j:j)='|'
          if (ireal .eq. 0) then
            if (iadj(i,j) .gt. 0) line(j:j)='*'
          else
            if (adj(i,j) .ge. 1.0) then
               line(j:j)='*'
            else if (adj(i,j) .gt. 0.0) then
              write (line(j:j),1002) int(10.0*adj(i,j))
            end if
          end if
        end do
        write (iout,1000) i,line(1:ndim)
        if (mod(i,10) .eq. 0) then
        end if
      end do
      return
1000  format(i5,'|',a)
1001  format(5x,'|',#MHi10)
1002  format(i1)
1003  format(' * at (i,j): edge')
1004  format(' *: w(i,j) >= 1.0; digit (d): 10*w(i,j)-1 <= d < ',
     -  '10*w(i,j); - or | or .: w(i,j)=0.0')
1005  format(' ***** ERROR: size of the adjacency matrix is > 2000 ',/,
     -  14x,'- increase the length of the character line in subroutine',
     -  ' plot_adj & recompile')
      end
      subroutine sortn(na,nna,nnaorg,ineiga,itrans,maxhmneig,maxsite)
c#    MMC routine 480 lstmod: 01/04/09
c*****Sort the neighbours by distance
      dimension nna(na),nnaorg(na),ineiga(maxhmneig,maxsite),r2(#MH)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      do ia=1,na
        nn=nna(ia)
        if (nn .gt. 1) then
c         Gather distances
          if (itrans .eq. 1) then
            do i=1,nn
              r2(i)=rsw2(ia,ineiga(i,ia))
            end do
          else
            do i=1,nn
              r2(i)=rsw2(ineiga(i,ia),ia)
            end do
          end if
c         Primitive sort (OK not to use mrgsort, since nn is small)
          i2=nn-1
          do i=1,i2
            j1=i+1
            do j=j1,nn
              if (r2(j) .lt. r2(i)) then
                rr=r2(i)
                r2(i)=r2(j)
                r2(j)=rr
                ii=ineiga(i,ia)
                ineiga(i,ia)=ineiga(j,ia)
                ineiga(j,ia)=ii
              end if
            end do
          end do
        end if
      end do
c     Save number of neighbours
      do ia=1,na
        nnaorg(ia)=nna(ia)
      end do
      return
      end
      subroutine scaleu(na,nna,nnaorg,ineiga,r2cut,nred,itrans,
     -  maxhmneig,maxsite)
c#    MMC routine 481 lstmod: 01/04/09
c*****Changes the no of neighbours as the cutoff is increased
      dimension nna(na),nnaorg(na),ineiga(maxhmneig,maxsite),r2(#MH)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      do ia=1,na
        nn=nna(ia)+1
        nnmx=nnaorg(ia)
c       Scan between current and original neighbours
        if (nnmx .ge. nn) then
c         Gather distances
          if (itrans .eq. 1) then
            do i=nn,nnmx
              r2(i)=rsw2(ia,ineiga(i,ia))
            end do
          else
            do i=nn,nnmx
              r2(i)=rsw2(ineiga(i,ia),ia)
            end do
          end if
c          write (6,1234) r2cut,ia,nn,nnmx,(r2(i),i=nn,nnmx)
c1234      format(' scu r2cut=',f8.2,' ia,nn,nnmx=',3i3,' r2=',5f8.2)
          if (r2(nn) .lt. r2cut) then
            do i=nn,nnmx
c              write (6,1211) i,r2(i),r2cut
c1211          format(' i=',i3,' r2i,r2cut=',2f8.2)
              if (r2(i) .ge. r2cut) then
c               Cutoff point  found
                nred=nred+1
                nna(ia)=i-1
                go to 10
              end if
            end do
c           No intermediate cutoff, set back to original
            nna(ia)=nnmx
            nred=nred+1
          end if
        end if
10      continue
      end do
      return
      end
      subroutine scaled(na,nna,ineiga,r2cut,nred,itrans,maxhmneig,
     -  maxsite)
c#    MMC routine 482 lstmod: 01/04/09
c*****Changes the no of neighbours as the cutoff is decreased
      dimension nna(na),ineiga(maxhmneig,maxsite),r2(#MH)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      do ia=1,na
        nn=nna(ia)
        if (nn .gt. 0) then
c         Gather distances
          if (itrans .eq. 1) then
            do i=1,nn
              r2(i)=rsw2(ia,ineiga(i,ia))
            end do
          else
            do i=1,nn
              r2(i)=rsw2(ineiga(i,ia),ia)
            end do
          end if
          if (r2(nn) .ge. r2cut) then
            do i=1,nn
              j=nn-i+1
              if (r2(j) .lt. r2cut) then
c               cutoff point  found
                nred=nred+1
                nna(ia)=j
                go to 10
              end if
            end do
c           All neighbours are outside the cutoff
            nred=nred+1
            nna(ia)=0
          end if
        end if
10      continue
      end do
      return
      end
      subroutine hungass(na,nb,nna,ineiga,nnb,ineigb,ibofa,iaofb,
     -  nswap,nmatch,iout,itrace,maxhmneig)
c#    MMC routine 483 lstmod: 01/26/00
c*****Finds a maximum matching with the Hungarian method
c     Notation follows ch 10 of c. Berger, The Theory of Graphs,
c     John Wiley, 1966.
      dimension nna(na),nnb(nb),ineiga(maxhmneig,na),
     -  ineigb(maxhmneig,nb),ibofa(na),iaofb(nb)
      dimension iwp(#MO),iwpm(#MO),idesc(#MO),iparnt(#MO)
      do ia=1,na
        nn=nna(ia)
        if (itrace .gt. 2) write (iout,1000) ia,nn,(ineiga(j,ia),j=1,nn)
      end do
      do ib=1,nb
        nn=nnb(ib)
        if (itrace .gt. 2) write (iout,1100) nn,(ineigb(j,ib),j=1,nn)
      end do
      do ia=1,na
        ibofa(ia)=0
      end do
      do ib=1,nb
        iaofb(ib)=0
      end do
      nswap=0
      nmatch=0
c     At first, assign sites to each other that are first on each other list
      do ia=1,na
        if (nna(ia) .gt. 0) then
          ib=ineiga(1,ia)
          if (nnb(ib) .gt. 0) then
            if (ineigb(1,ib) .eq. ia) then
              iaofb(ib)=ia
              ibofa(ia)=ib
              nmatch=nmatch+1
            end if
          end if
        end if
      end do
      if (itrace .gt. 1) write (iout,1001) na,nb,nmatch
c     Set up the rest of the mathcing by a greedy algorithm.
      do ia=1,na
        nn=nna(ia)
        if (nn .gt. 0 .and. ibofa(ia) .eq. 0) then
          if (itrace .gt. 2)
     -      write (iout,1003) ia,ineiga(1,ia),iaofb(ineiga(1,ia))
          do i=1,nn
            ib=ineiga(i,ia)
            if (nnb(ib) .gt. 0) then
              if (iaofb(ib) .eq. 0) then
                iaofb(ib)=ia
                ibofa(ia)=ib
                nmatch=nmatch+1
                go to 30
              end if
            end if
          end do
        end if
30      continue
      end do
      if (itrace .gt. 1) write (iout,1002) nmatch,na,nswap
300   if (nmatch .eq. na) return
c     Matching is not complete
c     Set up the w+ and w- sets
c     Site ia is in w+ if the matched partner of ia has connection to an
c     unassigned site
c     Site ia is in w- if it has a connection to an unassigned site
      nwp=0
      nwm=0
c     iwpm(ia) is + if ia is in w+, - if in w-, 0 otherwise
c     If nonzero, its abs value gives the unassigned site it is connected to
      do ia=1,na
        iwpm(ia)=0
      end do
      do ia=1,na
        ib=ibofa(ia)
        if (ib .gt. 0) then
c         See if other vertices starting from ia lead to unassigned site
          nn=nna(ia)
          im=0
          if (nn .gt. 1) then
            do i=1,nn
              ibb=ineiga(i,ia)
              if (iaofb(ibb) .eq. 0) then
c               ia is in w-
                im=ibb
                go to 42
              end if
            end do
          end if
42        nn=nnb(ib)
          ip=0
          if (nn .gt. 1) then
c           see if there are vertices from unassigned site to ib
            do i=1,nn
              iaa=ineigb(i,ib)
              if (ibofa(iaa) .eq. 0) then
c               ia is in w+
                ip=iaa
                go to 44
              end if
            end do
          end if
44        if (ip .gt. 0 .and. im .gt. 0) then
c           ia is in both w+ and w- rearrange immediately
            iaofb(ib)=ip
            ibofa(ip)=ib
            iaofb(im)=ia
            ibofa(ia)=im
            nswap=nswap+1
            nmatch=nmatch+1
            if (itrace .gt. 2) then
              write (iout,1200) ia,ip,ib,im
              write (iout,1021) (iaofb(i),i=1,nb)
              write (iout,1022) (ibofa(i),i=1,na)
            end if
            go to 300
          else if (ip .gt. 0) then
c           save ia into w+
            nwp=nwp+1
            iwp(nwp)=ia
            iwpm(ia)=+ip
          else if (im .gt. 0) then
c           save ia into w-
            nwm=nwm+1
            iwpm(ia)=-im
          end if
        end if
      end do
c     If either w+ or w- is empty, the matching is maximal
      if (itrace .gt. 2) write (iout,1300) nwp,nwm
      if (nwp .eq. 0 .or. nwm .eq. 0) return
c     Search for connecting path
      do ia=1,na
c       iparnt(ia) is the site from which site id was reached
        iparnt(ia)=0
      end do
c     Start the descendant list from w+
      do ip=1,nwp
        ia=iwp(ip)
        idesc(ip)=ia
        iparnt(ia)=-1
      end do
      if (itrace .gt. 2) then
        write (iout,2431) (iwp(i),i=1,nwp)
        write (iout,2432) (iwpm(i),i=1,na)
      end if
      ndesc=nwp
      iscan=1
      ndesc0=ndesc
500   do id=iscan,ndesc0
c       Look at descendants of the previous generation
        nn=nna(idesc(id))
        if (nn .gt. 1) then
          do i=1,nn
            idnext=iaofb(ineiga(i,idesc(id)))
            if (itrace .gt. 2) write (iout,8544)
     -        id,nn,idnext,idesc(id),ineiga(i,idesc(id))
            if (iwpm(idnext) .lt. 0) then
c             w+ -> w- path found, rearrange matching
              ibofao=ibofa(idnext)
              iaofb(-iwpm(idnext))=idnext
              ibofa(idnext)=-iwpm(idnext)
              iact=idesc(id)
              if (itrace .gt. 2)
     -          write (iout,3712) iact,idnext,ibofao,iwpm(idnext)
530           ipar=iparnt(iact)
              if (itrace .gt. 2) write (iout,8523) id,idnext,iact,ipar
              if (ipar .eq. -1) then
c               End of rearrangement - element in w+ reahced
                if (itrace .gt. 2)
     -            write (iout,3711) iact,ibofao,iwpm(iact)
                iaofb(ibofa(iact))=iwpm(iact)
                ibofa(iwpm(iact))=ibofa(iact)
                ibofa(iact)=ibofao
                iaofb(ibofao)=iact
                nmatch=nmatch+1
                nswap=nswap+1
                go to 300
              else
c               Move one generation up in the rearrangement
                ibo=ibofao
                ibofao=ibofa(iact)
                ibofa(iact)=ibo
                iaofb(ibo)=iact
                iact=ipar
              end if
              go to 530
            else if (iparnt(idnext) .eq. 0) then
c             Add idnext to the descendent list
              ndesc=ndesc+1
              idesc(ndesc)=idnext
              iparnt(idnext)=idesc(id)
            end if
            if (idnext .ne. 0 .and. idnext .ne. idesc(id) .and.
     -          iparnt(idnext) .eq. 0) then
c             Add idnext to the descendent list
              ndesc=ndesc+1
              idesc(ndesc)=idnext
              iparnt(idnext)=idesc(id)
            end if
          end do
        end if
      end do
      if (ndesc .gt. ndesc0) then
c       Scan newly added elements
        iscan=ndesc0+1
        ndesc0=ndesc
        go to 500
      end if
c     No path found - matching is maximal
      return
1000  format(' HUNG ',i3,' nna=',i3,' ina=',10i3)
1001  format(' HUNG na,nb=',2i4,' nmatch after mutual assignment=',i3)
1002  format(' HUNG nmatch aft greedy assignment=',i3,' na,nswap=',2i4)
1003  format(' HUNG ia=',i4,' initally unmatched, in(1)=',i4,
     -  ' already assigned to ',i4)
1021  format(' HUNG iaofb=',40i3)
1022  format(' HUNG ibofa=',40i3)
1200  format(' HUNG Quick rearrangement, ia,ip,ib,im=',4i4)
1100  format(' HUNG nnb=',i3,' inb=',10i3)
1300  format(' HUNG start path search (maybe) nwp,nwm=',2i4)
2431  format(' HUNG iwp=',5i4)
2432  format(' HUNG iwpm=',5i4)
3711  format(' HUNG w+ end iact,ibofao,iwpm(iact)=',3i4)
3712  format(' HUNG w- end iact,idnext,ibofao,iwpm(idnext)=',4i4)
8523  format(' HUNG id,idnext,iact,ipar=',4i4)
8544  format(' HUNG id,nn,idnext,idesc(id),ineiga(i,idesc(id))=',5i4)
      end
      subroutine rep2mat(ns1,ns2,nslt1,nslt2,nslv1,nslv2,isite1,isite2,
     -  c1,c2,nmat,niter,fn1,fn2,lnam1,lnam2,rcutxst,rmateps,rcutcrcv,
     -  rmsdgrid,indexn,islvkeep,cv1,cv2,cv3,aby,abz,idisttyp,ih,nexp,
     -  rneigsite,maxsiteng,iout)
c#    MMC routine 484 lstmod: 10/27/14
c*****Print result of comparison betwwen two site sets
      dimension indexn(#UV),islvkeep(#UV),ih(#NA),
     -  cv1(#UV),cv2(#UV),cv3(#UV),aby(#UV),abz(#UV)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      dimension c1(3,#NA),c2(3,#NA),z(3),ndist(20),ndistcum(20)
      character*80 fn1,fn2
      character*132 line
      character*6 lab
      call zeroiti(ndist,0,20)
      write (iout,1006)
      write (iout,1007) 1,' (the reference site) ',
     -  fn1(1:lnam1),ns1,nslt1,nslv1,isite1
      write (iout,1007) 2,' ',fn2(1:lnam2),ns2,nslt2,nslv2,isite2
      write (iout,1009)
      write (iout,1017) rmateps
      if (idisttyp .eq. 1) then
        write (iout,1019) 'site-site distance'
        write (iout,1008) ' ',rcutxst
      else
        write (iout,1019) 'site neighbor list comparison'
        if (idisttyp .eq. 2) then
          write (iout,1021) 'average number of missed matches'
        else if (idisttyp .eq. 3) then
          write (iout,1021) 'average # of matches/(# of matches+1)'
        else if (idisttyp .eq. 4) then
          write (iout,1021)
     -       'distance * average # of matches/(# of matches+1)'
        else
          if (nexp .ge. -1 .and. nexp .le. 1) then
            write (iout,1020)
          else if (nexp .gt. 1 .and. nexp .lt. 10) then
            write (lab,1023) nexp
            write (iout,1020) lab(1:2)
          else if (nexp .lt. -1 .and. nexp .gt. -10) then
            write (lab,1024) -nexp
            write (iout,1020) lab(1:6)
          else
            write (iout,*) '***** ERROR: invalid nexp=',nexp
            call datprt(-1)
          end if
        end if
        write (iout,1008) ' measure ',rcutxst
        write (iout,1018) rneigsite
        write (iout,1016) maxsiteng
        rcutxst=nslt1
      end if
      write (iout,1001) nmat
      if (niter .gt. 0)  write (iout,1003) niter
      nomt=0
      rmstot=0.0
      rdev2max=0.0
      do ia=1,max0(nslt1,nslt2)
        cv2(ia)=rcutcrcv**2
        ih(ia)=0
      end do
      call zeroit(cv3,ns2)
      do is=1,ns1
        if (iwofs(is) .gt. 0) then
          call trnsfr(z,c2(1,nslt2+(iwofs(is)-1)*nslv2+isite2),3)
          rdev2=rsw2(is,iwofs(is))
          if (rdev2max .lt. rdev2) rdev2max=rdev2
          rmstot=rmstot+rdev2
          ic=50
          islvkeep(is-nomt)=iwofs(is)
          write (line(1:50),1000) is-nomt,is,
     -      (c1(k,nslt1+(is-1)*nslv1+isite1),k=1,3),frocc1(is),bfac1(is)
          if (nslt1 .gt. 10) then
            call circularvar(c1,indexn,c1(1,nslt1+(is-1)*nslv1+isite1),
     -        1,nslt1,1,1,cv2,aby,cv1,rcutcrcv,0,0,iout)
            write (line(ic+1:ic+43),1012) cv1(1)
            ic=ic+8
          end if
          write (line(ic+1:ic+55),1013) iwofs(is),z,frocc2(iwofs(is)),
     -      bfac2(iwofs(is))
          ic=ic+55
          if (nslt2 .gt. 10) then
            call circularvar(c2,indexn,z,1,nslt2,1,1,cv2,aby,cv1,
     -        rcutcrcv,0,0,iout)
            write (line(ic+1:ic+8),1012) cv1(1)
            ic=ic+8
            cv3(is-nomt)=-cv1(1)
          end if
          abz(is-nomt)=sqrt(rdev2)
          if (idisttyp .eq. 1) then
            write (line(ic+1:ic+12),1014) sqrt(rdev2)
            ic=ic+12
          else
c           Add real distance to the output
            if (idisttyp .eq. 5) then
              write (line(ic+1:ic+12),1022) rdev2
            else
              write (line(ic+1:ic+12),1014) rdev2
            end if
            ic=ic+12
            rij=sqrt(arrdist(c1(1,nslt1+(is-1)*nslv1+isite1),
     -        c2(1,nslt2+(iwofs(is)-1)*nslv2+isite2)))
            write (line(ic-1:ic+10),1015) rij
            ic=ic+10
          end if
          write (iout,1010) line(1:ic)
        else
          nomt=nomt+1
        end if
      end do
      dgrid=rmsdgrid
      if (rmsdgrid .eq. 0) dgrid=sqrt(rdev2max)/20.0
      do im=1,ns1-nomt
        igrd=min0(20,int(abz(im)/dgrid)+1)
        ndist(igrd)=ndist(igrd)+1
      end do
      if (nomt .gt. 0) write (iout,1005)
      nomt=0
      do is=1,ns1
        if (iwofs(is) .eq. 0) then
          nomt=nomt+1
          write (line(1:77),1002)
     -      nomt,1,is,(c1(k,nslt1+(is-1)*nslv1+isite1),k=1,3),
     -      frocc1(is),bfac1(is),2
          ic=77
          if (nslt1 .gt. 10) then
            call findprox0(c1,nslt1,c1(1,nslt1+(is-1)*nslv1+isite1),
     -        iprox,rij,ih,nslt1+ns1*nslv1)
            call circularvar(c1,indexn,c1(1,nslt1+(is-1)*nslv1+isite1),
     -        1,nslt1,1,1,cv2,aby,cv1,rcutcrcv,0,0,iout)
            write (line(ic+1:ic+44),1011) iprox,rij,cv1(1)
            ic=ic+44
          end if
          write (iout,1010) line(1:ic)
        end if
      end do
      if (nomt .gt. 0) write (iout,1005)
      nomt=0
      do is=1,ns2
        if (isofw(is) .eq. 0) then
          nomt=nomt+1
          islvkeep(nmat+nomt)=is
          write (line(1:77),1002)
     -      nomt,2,is,(c2(k,nslt2+(is-1)*nslv2+isite2),k=1,3),
     -      frocc2(is),bfac2(is),1
          ic=77
          if (nslt2 .gt. 10) then
            call findprox0(c2,nslt2,c2(1,nslt2+(is-1)*nslv2+isite2),
     -        iprox,rij,ih,nslt2+ns2*nslv2)
            call circularvar(c2,indexn,c2(1,nslt2+(is-1)*nslv2+isite2),
     -        1,nslt2,1,1,cv2,aby,cv1,rcutcrcv,0,0,iout)
            write (line(ic+1:ic+44),1011) iprox,rij,cv1(1)
            ic=ic+44
            cv3(nmat+nomt)=-cv1(1)
          end if
          write (iout,1010) line(1:ic)
        end if
      end do
      ndistcum(1)=ndist(1)
      do i=2,20
        ndistcum(i)=ndistcum(i-1)+ndist(i)
      end do
      if (nmat .gt. 0) write (iout,1004) sqrt(rmstot),
     -  sqrt(rmstot/nmat),sqrt(rdev2max),dgrid,ndist,ndistcum
      return
1000  format(i5,' S1 ',i4,3f6.1,' (occ=',f4.2,' B=',f6.2)
1001  format(/,' Matchings found for',i5,' sites')
1002  format(i5,' S',i1,' ',i4,3f6.1,' (occ=',f4.2,' B=',f6.2,')',
     -  ' was not matched to any S',i1)
1003  format(' Number of iterations=',i4)
1004  format(/,' Total RMS of the matchings=',f8.4,' RMS/match=',f6.3,
     -  ' largest RMS=',f8.4,/,' The matching distance (measure) ',
     -  ' distribution with',f5.2,' (A) grid:',/,20i4,/,' The ',
     -  'cumulative matching distance (measure) distribution:',/,20i4)
1005  format(/)
1006  format(/,10x,' Result of matching two sets of sites',/)
1007  format(' Site ',i1,a,'was read from file ',a,/,
     -  5x,'Number of sites=',i5,/,
     -  5x,'Number of solute atoms=',i6,/,5x,'Number of solvent ',
     -  'atoms/molecule=',i2,/,5x,'Representative solute atom=',i2)
1008  format(' Maximum distance',a,'allowed for a match=',f8.2,' A')
1009  format(' The quantities labeled by B are read in the B-factor ',
     -  'column of the respective PDB file (if any)')
1010  format(a)
1011  format('. Nearest solute atom:',i5,' d=',f4.1,' A CV=',f4.2)
1012  format(' CV=',f4.2)
1013  format(') Matched S2:',i4,3f6.1,' (occ=',f4.2,' B=',f6.2)
1014  format(') D=',f6.1,' A')
1015  format(' rij=',f5.1,' A')
1016  format(' Maximum number of site neighbor atoms=',i5)
1017  format(' Convergence threshold for optimizing the Hungarian ',
     -  'method matching=',f10.6)
1018  format(' Sites whose actual distance >',f6.3,' A will not be ',
     -  'matched (independent of the distance measure)')
1019  format(' Generic site comparison based on ',a)
1020  format(' Site-site distance measure is based on the Tanimoto ',
     -  'coefficient (T): D=(1-T)',a)
1021  format(' Site-site distance neasure is the ',a)
1022  format(') D=',f6.4,' A')
1023  format('^',i1)
1024  format('^(1/',i1,')')
      end
      subroutine getsitec(c,ns,iformiop47,itypeiop47,nslt,nslv,isite,
     -  edgexyz,frocc,bfac,keyno,fname,lname,iout,nwarn,inperr)
c#    MMC routine 485 lstmod: 04/26/10
c*****Read a coordinate file containing site data
      dimension c(3,#NA),frocc(#MH),bfac(#MH),
     -  iformiop47(5),itypeiop47(5),edgexyz(3)
      character*80 line
      common /inpline/ line,lineno,icol
      common /option/ iop(200),idebug(200)
      character*80 filename,fname,linesave
      dimension itypealtiop47(5)
      data itypealtiop47 /27,27,27,24,25/
      call getname(filename,namlen,1,80)
      call getint(numrun,1,1,0)
      call getint(irunvers,1,1,0)
      call checkdim(ifail,iout,inperr,'MH',ns,1,0,0)
      call getint(nslt,1,1,0)
      call getint(nslv,1,1,0)
      call getint(isite,1,1,0)
      linesave=line
      icolsave=icol
      if (keyno .gt. 0) iop(47)=keyno-1
      call fileopen(filename,namlen,filename,namlen,
     -  itypealtiop47(iop(47)+1),0,numrun,irunvers,2,
     -  iformiop47(iop(47)+1),iop(24),iversout,iout,ius,0)
      if (ns .eq. 0) call findnats(iop(47),ius,nslt,nslv,natoms,
     -  ns,nwarn,inperr,iout)
      fname=filename
      lname=namlen
      nmolx=ns+1
      if (itypeiop47(iop(47)+1) .eq. 15) then
c       PDB input - read occupancy and B factor first
        call readcrd(c,ius,nmolx,nmolx3,numsolvx,nslt+ns*nslv,nslt,0,
     -    nslv,cplp,edgexyz,icp,1,0,1,filename,namlen,0,iout,
     -    nwwarn,inperr)
        do is=1,ns
          frocc(is)=c(1,nslt+(is-1)*nslv+isite)
          bfac(is)=c(2,nslt+(is-1)*nslv+isite)
        end do
        rewind ius
      else
        do is=1,ns
          frocc(is)=1.0
          bfac(is)=0.0
        end do
      end if
      call readcrd(c,ius,nmolx,nmolx3,numsolvx,nslt+ns*nslv,nslt,0,nslv,
     -  cplp,edgexyz,icp,1,0,0,filename,namlen,0,iout,nwwarn,inperr)
      call fileclose(ius,0,iop(24),iout)
      if (iop(41) .gt. 0) then
        if (nmolx-1 .ne. ns) then
          write (iout,1000) ns,filename(1:namlen),nmolx-1
          nwarn=nwarn+1
        end if
      end if
      line=linesave
      icol=icolsave
      return
1000  format(' ----- WARNING: number of sites requested (',i4,') ',
     -  'differs from the number of solvents in file ',a,' (',i5,')')
      end
      subroutine gensitecalc(c,cgs,frcng,crm,nslt,nslv,islvrepr,rlcslv,
     -  ianslv,ixrep3,nrep3,ianslt,iclslt,igrslt,ifgrslt,ilgrslt,qslt,
     -  labslt,ixislt,iopupdate,iopinicnf,iopresform,iformiop47,
     -  itypeiop47,keynocnf,isorttyp,irestore,sltinptyp,igsanaltyp,
     -  matform,matsort,iaxsort1,iaxsort2,iaxsort3,sortwgt,
     -  icorrcomp,rxhmax2,hbanglemin,hbmatmin,occmin_at,occmin_res,
     -  occmin_tt,iwriteorg,origfile,lorigfile)
c#    MMC routine 486 lstmod: 08/01/21
c*****Perform the iterative site calculation
      character*4 labslt,sltinptyp
      character*80 origfile
      dimension c(3,#NA),cgs(3,#HA),crm(3,#MO),
     -  frcng(3,#UV),iformiop47(5),itypeiop47(5),labslt(2,#ST),
     -  ianslv(nslv),ixrep3(3),rlcslv(3,nslv),ianslt(nslt),iclslt(nslt),
     -  igrslt(nslt),ifgrslt(nslt),ilgrslt(nslt),qslt(nslt),
     -  ixislt(nslt),igsanaltyp(7)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /svint/ numrun,numrunst,nhstvers,nmin,nmax,nmc0,nmc,nmcprv,
     -  nmcmax,nrpt,ncorav,nmcrep,nrecd,nplt,ncntin,nmcadp,nmcrec,
     -  nmcransh,nransh,nidmc,nitry,niaccp,ndaccp,idfreq,idrepf,
     -  nvchfreq,nvchrep,nvchmc,nvchacc,nxstep(3),newrfs,nsavckpf,
     -  nn2min,nn2max,numrunh,nmchinc,nvvchfreq,nvvchrep,nvvchmc,
     -  nmcslftst,modelnum,incrun,mainkeyun(200),mainkeyu(200)
      real*8 uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep,
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01,einnb01,
     -  es1401,eslttor01,epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01,esmol01,ephso,ephsn,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,uinter,uuinter,
     -  tscum,ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot,avststptot,
     -  avststptot2,avststp,avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb,em14,uintranb,um14,uuintranb,uum14,estgrs,eminh,
     -  econstro,econstrn
      common /sreal/ uuscor,uavcor,usmixp,uscpma,usum,vstep,vxstep(3),
     -  uusum,etotn,etoto,etotpn,etotpo,uslt,uuslt,ettnbn,einnbn,es14n,
     -  eslttorn,ettnbo,einnbo,es14o,eslttoro,ettnb01(3,3),einnb01(3,3),
     -  es1401(3,3),eslttor01(3),epmfo,epmfn,usltf,uusltf,uslvf,uuslvf,
     -  vsum,vvsum,hsum,hhsum,exsum,eysum,ezsum,exsum_2,eysum_2,ezsum_2,
     -  efieldo,efieldn,esmolo,esmoln,efield01(3),esmol01(3),
     -  ephso,ephsn,ephssum,eephssum,fphssum,ffphssum,epijsum,epijct,
     -  rphssum,rrphssum,sumnphs,sumnnphs,ephssumlast,sumnphslast,
     -  tscum(3),ucsmmv,ucsmid,ucsmvv,usltms,uusltms,uinnb,uuinnb,
     -  uttnb,uuttnb,usltt,uusltt,uslt14,uuslt14,uslttor,uuslttor,
     -  estsco,estscn,estsca,estsaa,estsua,avstrot(3),avststptot,
     -  avststptot2,avststp(3),avstp,avrot,corrav,unsum,ufsum,fnsum,
     -  rnsum,rnnsum,bsum,bbsum,rnsumprv,rnnsumprv,uavcorprv,einoxs,
     -  eoutxs,eintranb(#MM),em14(#MM),uintranb(#MM),um14(#MM),
     -  uinter(#MM),uuintranb(#MM),uum14(#MM),uuinter(#MM),
     -  estgrs(#GR),eminh,econstro,econstrn,estgr(#GR),eout0,emin,
     -  emax,emaxchange,vmin,vmax,volav,dijmin,accpmn,c12prot
      real*8 gbuupd,gbuupt
      common /parensts/ gbuupd(#MM),gbuupt(#TR)
C@NL      logical ibiton,ibitof
      common /bitmaps/ ibit1(#UV),ibit2(#UV),ibiton(64),
     -  ibitof(64),itwop(64),iallon,nbits,iuuon,ivvon
C@NNC@NL      logical mapbitv
C@NN      common /nneigtv/ mapbitv(#VW,#MO),clstup(3,#MO),
C@NN     -  drmx22,rfacnn,rgcl2,nupdat,nmolmp,nlastwv
      common /sltnnl/ nneig(#ST),ineig(#NL,#ST),nneigh(#ST),
     -   nneiga(#ST),nneig3(#ST),nneig4(#ST)
      common /fcgspec/ nfgmem(#ST),ifgstr(#ST),ifgaix(#ST),
     -  indxfg(#ST),ixfg(#ST),ifgtyp(#ST),itypfg(#ST),nfg
      character*4 namfcg
      character*20 nmlfcg
      common /fcgnam/ igrdup(100),namfcg(100,2),nmlfcg(100,2)
      real*8 ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1
      common /freeen/ ue0,ue1,uus0,uus1,e0o,e1o,uws0,uws1,dele,
     -  delest,del0st,del1st,cplpar,cplpr0,cplpr1,cplpar1,cplimn,cplimx,
     -  uspro0,uspro1,uspar0,uspar1,uspr01,uspr11,dusp12,de01mn,de01mx,
     -  ptiexp(3),tifacone(3),tifactwo(3),epstol,sigtol,qtol,xyztol2,
     -  ptiexpmax,noppti(#GR),kexp,nquad,iquad,nm01mn,nm01mx
      common /dstsv/ ignorehs,r2stsv(#ST)
      common /ecell/ cic(3,27),ncell
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      character*3 terend(2)
      character*36 datainfo(30)
      common /pdbinfo/ ntabcol,npxcol,nothercol,terend,datainfo
      common /stow/ clstfin_dmax,cvfilt_stow,froccmin_stow,rmsdlim_stow,
     -  subreground,nclust_clstfin,maxclstmem_stow
      common /hunginfo/ csini(3,#MH),cscurr(3,#MH),csw(3,#MO),
     -  frocc(#MH),rdevsw(#MH),rdiffcnv(#MH),rmx,rdiff2,niter,ns,
     -  nused,maxmaxng
      character*44 sitesortlab
      common /sitesort/ sitesortlab(6),lsitesortlab(6)
      character*1 lxyz
      common /names/ lxyz(3)
      character*80 file,filenames,filename1,filename2,filenamew
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      common /filestatus/ nfiletyp,ifilstat(50),iuchoice(99),iconfread
      common /option/ iop(200),idebug(200)
      common /io/ inpt,iout,ichkp,icord,ihist,idstr,iindel,ichkpx,
     -  idistrpx,infopx,irtm,ifldgpx,ickpok,itempxxx,
     -  inperr,nwarn,nwwarn,nchng
      common /nmbrs/ ione,pi,pi2,pi43,rdtodg,boltz,avogad,wmmltona3
      common /worksp/ ixkeep(#NA),numcount(#UV),l3(#UV),
     -  l4(#UV)
      real*8 csaccu,ortaccu,rdevmat2,rxyzsum,sengslt,sengslv,seng_sp
      dimension csaccu(3,#MH),rdevmat2(#MH),ortaccu(3,3,#MH),
     -  sengslt(#MH),sengslv(#MH),seng_sp(#MH),rxyzsum(3),
     -  hhdir0(3,#MH),rtemp(#UV),rtemp1(#UV),rtemp2(#UV),
     -  icvcount(#MH),iscontrib(#MH),nmcorig(#MH),isxprox(#MH),
     -  rmssaved(10),ort(3,3),keycol(2),nmisssaved(10),
     -  nmcsaved(10),froccs(#AT),sengs(#AT),rmsdtav(#AT),
     -  cvdipav(#AT),cvhhav(#AT),cv3av(#AT),nstyp(#AT),
     -  cslvrep(3,#SV),cvsite(#MH),nwofs(#MH),iwofs_prev(#MH),
     -  ifr_prev(#MH),ix_solv(#MH),c_save(3,#NA),is_orig(#MH),
     -  ifirst(#MH),ilast(#MH),iclst(#MH),z(3),xyz(3),
     -  crm_min(3),crm_max(3),crm_avg(3),dip1(3),dip2(3),
     -  hh1(3),hh2(3),rnorm1(3),rnorm2(3),csltr(3,#ST),
     -  nhb_ss(#MH,#MH),row(#MH),nframeocc(#MH),ifatocc(#MH),
     -  frocc_tst(#MH),iout_anal(7),lanalname(7),nhbstsv(#MH),
     -  dipavij(3,#MH,#MH),dipcorr_eng(#MH,#MH),iocccorr(#MH,#MH),
     -  dipcorrii(3,#MH,#MH),dipcorrij(3,#MH,#MH),isorig(#MH),
     -  njump(#MH),nwhb(#MH),iwhb(#NS,#MH),nacc_whb(#NS,#MH),
     -  sv_st_hb(#MH,#MH),st_st_hb(#MH,#MH),sv_sv_hb(#MH,#MH),
     -  it_orig(#MH),istemp(#MH),ixtemp(#MH),nmemacc(#MH),
     -  ihb_ww(20),ihb_wp(20)
      real*8 rmsav,rms2av,froccav,frocc2av,rmsfroccav,solvsum,
     -  solvsum2,cvdip,cvhh,uusfac
      real*8 rmsd_tst(#MH)
      real*8 estor,ettnbsum,einnbsum,e14nbsum,estorsum,
     -  ettnbsum2,einnbsum2,e14nbsum2,estorsum2
      character*132 line
      character*#MH site_line
      character*3 mcmd
      character*4 key4(3)
      character*5 centlab
      character*8 mcmd8,molgroup(4),corrcompname(3)
      character*21 analname(7)
      character*1 vt_lab(#MH),digits(10)
      data vt_lab /#MH*'S'/
      data digits /'1','2','3','4','5','6','7','8','9','*'/
      data iout_ws /60/,key4 /'RPDB','RASC','RANN'/,
     -  analname /'dipole covariance','dipole correlation',
     -  'pair energy','hydrogen-bond','occupancy correlation',
     -  'full hydrogen bond','average frames/jump'/,
     -  corrcompname /'bisector','H-H line','normal  '/
      data ettnbsum /0.d0/,einnbsum /0.d0/,e14nbsum /0.d0/,
     -  estorsum /0.d0/,ettnbsum2 /0.d0/,einnbsum2 /0.d0/,
     -  e14nbsum2 /0.d0/,estorsum2 /0.d0/,
     -  molgroup /2*'molecule',2*'group'/,
     -  lanalname /17,18,11,13,21,18,19/
      if (iop(9) .lt. 10) then
        mcmd='Nmc'
        mcmd8='MC  step'
      else
        mcmd='Nfr'
        mcmd8='MD frame'
      end if
      nowater=-1
      call getint(nsiteini,1,1,0)
      call checkdim(ifail,iout,inperr,'MH',nsiteini,1,0,0)
      call getint(nmcmax,1,1,0)
      call getint(nmcfreq,1,1,0)
      call getint(nmcdisc,1,1,0)
      call getreal(rcutxst,0,8.0)
      call getreal(rmateps,0,0.01)
      call getreal(epsgsite,0,0.1)
      if (epsgsite .lt. rmateps) then
        write (iout,1062) epsgsite,rmateps
        epsgsite=rmateps
        nchng=nchng+1
      end if
      call getreal(rmaxmatch,0,1000.0)
      call getreal(rmix,0,0.0)
      if (rmix .gt. 0.999) then
        write (iout,1026) rmix
        rmix=0.0
        nwarn=nwarn+1
      end if
      call getint(maxiter,0,0,100)
      call getint(nsmin,0,0,0)
      maxslv=#MO-1
      call getint(nsmax,0,0,maxslv)
      call getreal(cplpmin,0,-1.0)
      call getreal(cplpmax,0,2.0)
      call getreal(cvfilt_traj,0,0.0)
      call getreal(cvfilt_trajcut,0,10.0)
      call getreal(froccmin,0,0.0)
      call getreal(cvfilt,0,0.0)
      call getreal(distsltmax,0,0.0)
      call getreal(rmsdlim,0,0.0)
      call getreal(froccminrep,0,0.0)
      call getreal(clstmerge_dmax,0,0.0)
      call getreal(froccpairmax,0,2.0)
      call getreal(rmaxrematch,0,0.0)
      irematchtyp=2
      if (rmaxrematch .gt. 0.0) irematchtyp=1
      islvrep=islvrepr
      if (islvrep .eq. 0) islvrep=1
      write (iout,1000)
      write (iout,1037) mcmd8,'read',nmcmax
      write (iout,1037) mcmd8,'skip before starting to read',nmcdisc
      write (iout,1037) mcmd8,'skip between configurations to use',
     -  nmcfreq
      if (nsiteini .gt. 0) write (iout,1003) nsiteini
      if (nsiteini .eq. 0) write (iout,1013)
      call checkdisc(nmcmax,nmcdisc,iout,inperr)
      nmcsave=1
      if (iop(97) .gt. 0) then
        write (iout,1004) nsmin,nsmax
        if (nsmax .gt. #MO) then
          write (iout,1028) 'MO'
          inperr=inperr+1
        end if
        if (nsiteini .gt. 0 .and.
     -      nsiteini .lt. nsmin .or. nsiteini .gt. nsmax) then
          write (iout,1027)
          inperr=inperr+1
        end if
      end if
      if (iop(30) .eq. 7) write (iout,1005) cplpmin,cplpmax
      if (nslt .eq. 0) then
         distsltmax=0.0
         froccmin=0.0
         cvfilt=0.0
         cvfilt_traj=0.0
         rmsdlim=0.0
      end if
      if (cvfilt_traj .eq. 0.0) call indexit(ix_solv,1,#MH,0)
      if (iopupdate .eq. 1) write (iout,1008)
      if (iopupdate .eq. 2) write (iout,1009)
      write (iout,1010) rcutxst,rmateps,epsgsite,rmaxmatch,maxiter
      if (rmix .gt. 0) write (iout,1025) rmix,1.0-rmix
      if (cvfilt_traj .gt. 0.0)
     -  write (iout,1039) cvfilt_traj,cvfilt_trajcut
      if (froccmin .gt. 0.0) write (iout,1035) froccmin
      if (froccmin .eq. 0.0)
     -   write (iout,1137) 'filtering of sites by occupancy'
      if (distsltmax .gt. 0.0) write (iout,1079) distsltmax
      if (distsltmax .eq. 0.0)
     -   write (iout,1137) 'filtering of sites by solute-site distance'
      if (rmsdlim .gt. 0.0) write (iout,1115) rmsdlim
      if (rmsdlim .eq. 0.0)
     -   write (iout,1137) 'filtering of sites by rmsd'
      if (cvfilt .gt. 0.0) write (iout,1038) cvfilt
      if (cvfilt .eq. 0.0) write (iout,1137) 'filtering of sites by CV'
      if (rmaxrematch .gt. 0.0) write (iout,1111) rmaxrematch
      if (froccminrep .gt. 0.0) then
        if (froccminrep .le. froccmin) then
          write (iout,1036) froccmin
          froccminrep=0.0
        else
          write (iout,1056) froccminrep
        end if
      end if
      if (clstmerge_dmax .gt. 0.0) then
        write (iout,1130) ' ',clstmerge_dmax,froccpairmax
      else
        write (iout,1137) 'merging of close partially occupied sites'
      end if
      if (iop(118) .eq. 1) then
        write (iout,1186)
        if (cvfilt_stow .gt. 0.0) then
          write (iout,1043) 'lowest CV','<',cvfilt_stow
        else
          write (iout,1137) 'filtering of clusters by lowest CV'
        end if
        if (froccmin_stow .gt. 0.0) then
          write (iout,1043) 'lowest occupancy','<',froccmin_stow
        else
          write (iout,1137)
     -       'filtering of clusters by smallest occupancy'
        end if
        if (rmsdlim_stow .gt. 0.0) then
          write (iout,1043) 'highest site RMSD','>',rmsdlim_stow
        else
          write (iout,1137) 'filtering of clusters by largest RMSD'
        end if
        if (maxclstmem_stow .gt. 0) write (iout,1044) maxclstmem_stow
        write (iout,1048) subreground
        if (clstfin_dmax .eq. 0.0 .and. nclust_clstfin .eq. 0) then
          clstfin_dmax=3.5
          write (iout,1045) clstfin_dmax
          nchng=nchng+1
        end if
      end if
      if (clstfin_dmax .gt. 0.0) write (iout,1041) clstfin_dmax
      if (nclust_clstfin .gt. 0.0) write (iout,1042) nclust_clstfin
      if (iopresform .gt. 6) then
        iopresfor=iopresform-6
        iwslt=2
        if (iconfread .ne. 1) then
          write (iout,1117) key4(iopresfor)
          call datprt(-1)
        end if
        call trnsfr(csltr,c,3*nslt)
        write (iout,1118) ' ',
     -    ' using the configuration read with the CNFG key'
      else if (iopresform .gt. 3) then
        iopresfor=iopresform-3
        iwslt=1
        write (iout,1118) ' ',
     -    ' using the last configuration read from the history file'
      else
        iopresfor=iopresform
        iwslt=0
        write (iout,1118) ' not '
      end if
      if (irestore .gt. 0) then
        write (iout,1064) filenames(1)(1:namlens(1))
        if (niter .eq. 1) then
          write (iout,1063)
          nwarn=nwarn+1
        else
          write (iout,1074) niter,sqrt(rdiff2)
        end if
        iadd=0
        nusedprev=nused
        if (maxiter .le. niter) then
          write (iout,1090) maxiter
          nwwarn=nwwarn+1
        end if
      else
        niter=1
      end if
      if (iop(152) .eq. 2 .and. iop(3) .lt. 10) then
        if (iconfread .eq. 0) then
          write (iout,1129)
          inperr=inperr+1
        else
          call setup(1,iconfread,iop47read,sltinptyp,0)
        end if
      end if
      niterstart=niter
      if (igsanaltyp(6) .gt. 0 .and. igsanaltyp(4) .eq. 0)
     -  igsanaltyp(4)=1
      ivers_wsl=1
      if (iop(118) .gt. 0) then
c       Open file for the solvent-to-site assignment info
        call fileopen(file,namlenf,filenames(32),
     -    namlens(32),32,0,numrun,1,3,0,iop(24),ivers_wsl,iout,
     -    iout_ws,0)
        write (iout,1011) filenames(32)(1:namlens(32))
      end if
      if (inperr .gt. 0) call datprt(-1)
      iskipfail=0
      nconnfail=0
      iadd=0
      write (iout,1060) ' '
c     Skip to print if maxiter is not above the current number of iterations
      if (maxiter .le. niter) go to 200
c     Skip initial site generation if niter > 1
      if (niter .gt. 1) go to 100
      maxmaxng=0
      ns=nsiteini
      nmc=0
c     Generate initial guess
      if (iopinicnf .eq. 1) then
c       Use the c array (read by CNFG)
        write (iout,1001) 'read by the CNFG key'
        if (mainkeyun(keynocnf) .le. mainkeyu(keynocnf)) then
          write (iout,1007)
          call datprt(2)
        end if
        if (nmolec-1 .lt. nsiteini) then
          write (iout,1006) nmolec-1
          call datprt(2)
        end if
        nsltread=nslt
        nslvread=nslv
        if (nsiteini .eq. 0) ns=nmolec-1
      else if (iopinicnf .eq. 2) then
c       Obtain it from the history file
        write (iout,1001) 'obtained from the history file'
        if (iop(97) .eq. 0 .and. nmolec-1 .lt. nsiteini) then
          write (iout,1006) nmolec-1
          call datprt(2)
        end if
        natoms=nslt+(nmolec-1)*nslv
        nsltread=nslt
        nslvread=nslv
        incc=0
        if (iop(59) .eq. 2) incc=nslt
c!      Problem with iop(59) =1
        if (iop(59) .eq. 1) then
          write (iout,1094)
          call datprt(2)
        end if
        call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,incc,
     -    nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,
     -    uusfac,edgexyz,ieof,nconnfail)
        if (ieof .gt. 0) return
        ifnd=0
        lmnst=0
        nminf=#MO
        nmaxf=0
        cplminf=1.0
        cplmaxf=0.0
        nscan=0
        do while (ieof .eq. 0 .and. (nmc .le. nmcdisc .or. ifnd .eq. 0))
          if (iskip1 .eq. 0) then
            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -        nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
            if (ieof .gt. 0) ifnd=0
          else
            iskip1=0
          end if
          if (ieof .eq. 0) nscan=nscan+1
          if (cvfilt_traj .gt. 0.0)
     -      call filter_traj(nmolec,nslt,nslv,islvrep,natoms,ix_solv,
     -        nmolecsave,c,c_save,cvfilt_traj,cvfilt_trajcut,ndel,
     -        nowater,iout,#MH)
          ifnd=1
          if (iop(97) .gt. 0) then
            if (nmolec-1 .lt. nsmin .or. nmolec-1 .gt. nsmax) ifnd=0
            if (nmolec .lt. nminf) nminf=nmolec
            if (nmolec .gt. nmaxf) nmaxf=nmolec
           end if
          if (iop(30) .eq. 7) then
            if (cplpar .lt. cplpmin .or. cplpar .gt. cplpmax) ifnd=0
            if (cplpar .lt. cplminf) cplminf=cplpar
            if (cplpar .gt. cplmaxf) cplmaxf=cplpar
          end if
          if (ifnd .eq. 1 .and. nmolec-1 .lt. nsiteini) ifnd=0
        end do
        if (iop(24) .gt. 0) write (iout,1084) mcmd,nscan
        if (nscan .eq. 0) then
          write (iout,1002) ' '
          call datprt(2)
        end if
        if (ifnd .eq. 0) then
          write (iout,1002) ' suitable '
          if (iop(97) .gt. 0) write (iout,1082) nminf-1,nmaxf-1
          if (iop(30) .eq. 7) write (iout,1083) cplminf,cplmaxf
          call datprt(2)
        else
          if (nmc .lt. nmcdisc) then
            write (iout,1022) nmc,nmcdisc
            call datprt(2)
          end if
          write (iout,1014) nmc
          if (iop(97) .gt. 0) write (iout,1015) nmolec-1
          if (iop(30) .eq. 7) write (iout,1016) cplpar
          if (nsiteini .eq. 0) ns=nmolec-1
        end if
      else
c       Read it from a new file
        write (iout,1001) 'read from a file specified here'
        call getsitec(c,ns,iformiop47,itypeiop47,nsltread,nslvread,
     -    islvrep,edgexyz,frocc1,bfac1,iopinicnf-2,filename1,lnam1,
     -    iout,nwarn,inperr)
      end if
c     Extract csini from c
      call checkdim(ifail,iout,inperr,'MH',ns,0,0,0)
      if (ifail .gt. 0) return
      do is=1,ns
        call trnsfr(csini(1,is),c(1,nsltread+(is-1)*nslvread+islvrep),3)
      end do
      call trnsfr(cscurr,csini,3*ns)
      sltrmsdmax=0.0
      sltdmax=0.0
100   if (iopinicnf .ne. 2 .or. niter .gt. 1) then
        call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,0,nmolec,
     -    numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,uusfac,
     -    edgexyz,ieof,nconnfail)
        if (ieof .gt. 0) call datprt(2)
      end if
      nscan=0
      nused=0
      call zeroitd(csaccu,3*#MH)
      call zeroitd(rdevmat2,#MH)
      call zeroiti(numcount,0,#MH)
      call zeroit(rdevsw,#MH)
      call zeroit(frocc,#MH)
      if (ns .lt. #MH) call zeroit(csini(1,ns+1),3*(#MH-ns))
      nmclastused=0
      nmclastr=0
      do while (ieof .eq. 0 .and. nmc .lt. nmcmax .or.
     -  iskip1 .gt. 0 .and. nmc .le. nmcmax)
c       Scan history, accumulate site contributions
c       Get the next config from the history file
        if (iskip1 .eq. 0) then
          call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -      nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -      nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
          if (ieof .eq. 0) then
            nmcsave=nmc-nmclastr
          end if
        else
          iskip1=0
        end if
        nscan=nscan+1
        call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -    nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,c_save,
     -    cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,nsmax,cplpar,
     -    cplpmin,cplpmax,nowater)
        if (ifnd .gt. 0) then
c         Use structure
          nused=nused+1
          if (niter .eq. 1) then
c           Get statistics on solute COM movement
            call cofms(c,z,iclslt,1,nslt,0,wx)
            if (nused .eq. 1) then
              call zeroit(crm_avg,3)
              call trnsfr(crm_min,z,3)
              call trnsfr(crm_max,z,3)
            else
              do k=1,3
                crm_avg(k)=crm_avg(k)+z(k)
                if (z(k) .gt. crm_max(k)) crm_max(k)=z(k)
                if (z(k) .lt. crm_min(k)) crm_min(k)=z(k)
              end do
            end if
            if (nused .eq. 1) then
              call trnsfr(frcng,c,3*nslt)
            else if (nslt .gt. 0) then
              rmsd=0.0
              do ia=1,nslt
                dd=arrdist(c(1,ia),frcng(1,ia))
                rmsd=rmsd+dd
                if (dd .gt. sltdmax) then
                  sltdmax=dd
                  nmcdmax=nmc
                  iasltdmax=ia
                end if
              end do
              if (sltrmsdmax .lt. rmsd) then
                sltrmsdmax=rmsd
                nmcrmsdmax=nmc
              end if
            end if
          end if
          nmclastused=nmc
          nw=nmolec-1
          call zeroiti(l3,0,nw)
          if (idebug(64) .gt. 1) write (iout,1017) nused,ns,nw,nmc
          do iw=1,nw
            call trnsfr(csw(1,iw),c(1,nslt+(iw-1)*nslv+islvrep),3)
          end do
          if (niter .eq. 1 .or. iopupdate .eq. 2 .or. iadd .eq. 1) then
            call rij2mat(1,ns,1,nw,0,0,1,1,1,1,cscurr,csw,iop(5),1,1,
     -        0.0,#MH,#MO)
          else
            call rij2mat(1,ns,1,nw,0,0,1,1,1,1,csini,csw,iop(5),1,1,0.0,
     -        #MH,#MO)
          end if
          if (idebug(62) .gt. 2) then
            do is=1,ns
              write (iout,1078) 'CONVERGING',niter,nmc,is,
     -          (rsw2(is,iw),iw=1,nw)
            end do
          end if
300       call minmat(ns,nw,rcutxst,rmaxmatch,r2sum,r2max,nmat,nmiter,
     -      niter,rmateps,nmc,maxmaxng,1)
          nsiteswitch=0
          nsmatched=0
          do is=1,ns
            if (iwofs(is) .ne. iwofs_prev(is)) nsiteswitch=nsiteswitch+1
            iwofs_prev(is)=iwofs(is)
            if (iwofs(is) .ne. 0) nsmatched=nsmatched+1
          end do
          if (nsmatched .eq. ns) then
c           All sites are matched - add extra waters as new sites
            do iw=1,nw
              if (isofw(iw) .eq. 0) then
                ns=ns+1
                l3(iw)=1
                call addsite(iw,ns,nw,iop(5),iout)
                write (iout,1024) niter,nmc,iw,
     -            (csw(k,iw),k=1,3),ns
                iadd=1
                go to 300
              end if
            end do
          end if
          if (idebug(64) .gt. 2) then
            do iw=1,nw
              write (iout,1030) 'solvent',iw,isofw(iw),(csw(k,iw),k=1,3)
            end do
            do is=1,ns
              write (iout,1030) 'site',is,iwofs(is),(cscurr(k,is),k=1,3)
            end do
          end if
          iadd=0
          if (r2max .gt. rmaxmatch**2) then
c           Add the worst matched solvent to the site list
            r2maxx=0.0
            iwmax=0
            do is=1,ns
              iww=iwofs(is)
              if (iww .gt. 0) then
                if (rsw2(is,iww) .gt. r2maxx .and. l3(iww) .eq. 0) then
                  r2maxx=rsw2(is,iww)
                  iwmax=iww
                end if
              end if
            end do
            if (iwmax .eq. 0) then
              write (iout,1095)
              call datprt(2)
            end if
            ns=ns+1
            l3(iwmax)=1
            call addsite(iwmax,ns,nw,iop(5),iout)
            write (iout,1021) niter,nmc,iwmax,sqrt(r2maxx),
     -        (csw(k,iwmax),k=1,3),ns
            iadd=1
            go to 300
          end if
c         Matching info is now in iwofs
          do is=1,ns
            if (iwofs(is) .gt. 0) then
              numcount(is)=numcount(is)+1
              call arrdiff(z,csw(1,iwofs(is)),csini(1,is),3)
              call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
              call arrsum(z,csw(1,iwofs(is)),cic(1,iopt),3)
              do k=1,3
                csaccu(k,is)=csaccu(k,is)+z(k)
              end do
              rdevmat2(is)=rdevmat2(is)+arrdist(z,csini(1,is))
              frocc(is)=frocc(is)+1.0
            end if
          end do
          if (niter .eq. 1 .or. iopupdate .eq. 2) then
c           Update the current site estimate
            do is=1,ns
              if (numcount(is) .gt. 0) then
                do k=1,3
                  cscurr(k,is)=csaccu(k,is)/numcount(is)
                end do
                call pbcnd(cscurr(1,is),cscurr(2,is),cscurr(3,is),
     -            iop(5),iopt,riijj)
              end if
            end do
          end if
        end if
      end do
      nmclast=nmc
      if (iop(24) .gt. 0) write (iout,1084) mcmd,nscan,' ',nused
      if (niter .gt. 1 .and. iopupdate .eq. 1) then
        do is=1,ns
          if (numcount(is) .gt. 0) then
            do k=1,3
              cscurr(k,is)=csaccu(k,is)/numcount(is)
            end do
            call pbcnd(cscurr(1,is),cscurr(2,is),cscurr(3,is),
     -        iop(5),iopt,riijj)
          end if
        end do
      end if
      rdiff2=0.0
      do is=1,ns
        call arrdiff(z,cscurr(1,is),csini(1,is),3)
        call pbcnd(z(1),z(2),z(3),iop(5),iopt,riijj)
        rdiffcnv(is)=sqrt(riijj)
        rdiff2=rdiff2+riijj
        if (rmix .eq. 0.0) then
          call trnsfr(csini(1,is),cscurr(1,is),3)
        else
          do k=1,3
            csini(k,is)=
     -        rmix*csini(k,is)+(1.0-rmix)*(cscurr(k,is)+cic(k,iopt))
          end do
          call pbcnd(csini(1,is),csini(2,is),csini(3,is),
     -      iop(5),iopt,riijj)
        end if
      end do
      rdiff2=rdiff2/ns
      rdevswmin=10000.0
      rdevswmax=0.0
      rdevswavg=0.0
      wsum=0.0
      do is=1,ns
        if (numcount(is) .gt. 0) then
          rdevmat2(is)=sqrt(rdevmat2(is)/numcount(is))
          rdevsw(is)=rdevmat2(is)
          frocc(is)=float(numcount(is))/float(nused)
          if (rdevsw(is) .gt. rdevswmax) rdevswmax=rdevsw(is)
          if (rdevsw(is) .lt. rdevswmin) rdevswmin=rdevsw(is)
          rdevswavg=rdevswavg+frocc(is)*rdevsw(is)
          wsum=wsum+frocc(is)
          frocc1(is)=frocc(is)
          bfac1(is)=rdevsw(is)
        else
          frocc1(is)=0.0
          bfac1(is)=0.0
        end if
      end do
      if (wsum .gt. 0.0) rdevswavg=rdevswavg/wsum
      if (nused .eq. 0) rdevswmin=0.0
      write (iout,1018) niter,nused,sqrt(rdiff2),epsgsite,
     -  ns,rdevswmin,rdevswmax,rdevswavg,nsiteswitch
      call bin10(rdiffcnv,ns,0.0,-1.0,rmx,'site convergence    ',20,
     -  iout)
      if (rdiff2 .gt. epsgsite**2) then
        if (niter .eq. maxiter) then
          write (iout,1020) maxiter,sqrt(rdiff2),epsgsite
          nwwarn=nwwarn+1
          go to 201
        end if
        do is=1,ns
          if (rmix .eq. 0.0) then
            call trnsfr(csini(1,is),cscurr(1,is),3)
          else
            do k=1,3
              csini(k,is)=
     -          rmix*csini(k,is)+(1.0-rmix)*(cscurr(k,is)+cic(k,iopt))
            end do
            call pbcnd(csini(1,is),csini(2,is),csini(3,is),
     -        iop(5),iopt,riijj)
          end if
        end do
        niter=niter+1
        go to 100
      end if
      write (iout,1019) niter
201   if (ifilstat(1) .eq. 0) call fileopen(file,namlenf,filenames(1),
     -  namlens(1),1,0,numrun,1,0,1,iop(24),iversout,iout,ichkp,0)
      if (niter-niterstart .gt. 1) call csave(ichkp,1,iskipfail,1)
c     Iteration stopped, print/save result
200   write (iout,1061) rmx,maxmaxng
      if (rmx .gt. 10.0*epsgsite) then
        write (iout,1066)
        nwarn=nwarn+1
      end if
      call bin10(frocc,ns,0.0,1.0,fmx,'fractional occupancy',20,iout)
      call bin10(rdevsw,ns,0.0,-1.0,dmx,'site RMSD           ',20,iout)
      if (nslt .gt. 0) then
c       Check for large solute moves
        write (iout,*)
        sltrmsdmax=sqrt(sltrmsdmax/nslt)
        if (sltrmsdmax .lt. 0.001) then
          write (iout,1085)
        else
          crmdevmax=0
          do k=1,3
            z(k)=crm_max(k)-crm_min(k)
            if (crmdevmax .lt. z(k)) crmdevmax=z(k)
          end do
          write (iout,1097) sltrmsdmax,mcmd8,nmcrmsdmax,
     -      sqrt(sltdmax),iasltdmax,mcmd8,nmcdmax,(z(k),k=1,3)
          if (sltrmsdmax .gt. 1.5) then
            if (crmdevmax .lt. 0.5) write (iout,1098) ' '
            if (crmdevmax .ge. 0.5) write (iout,1098) ' moves/'
            nwarn=nwarn+1
          else if (sltrmsdmax .gt. 3.0) then
            if (crmdevmax .lt. 0.5) write (iout,1099) ' '
            if (crmdevmax .ge. 0.5) write (iout,1099) ' moves/'
            nwwarn=nwwarn+1
          end if
        end if
        call trnsfr(frcng,c,3*nslt)
        call trnsfr(cgs,c,3*nslt)
        if (iwslt .eq. 1) then
          write (iout,1096) mcmd8,nmclastused
        else if (iwslt .eq. 2) then
c         Check if center of configuration read is near to the trajectory center
          do k=1,3
            crm_avg(k)=crm_avg(k)/float(nused)
          end do
          call cofms(csltr,z,iclslt,1,nslt,0,wx)
          crm_dev=sqrt(arrdist(z,crm_avg))
          if (crm_dev .lt. 1.0) then
            write (iout,1135) ' ',crm_dev
          else if (crm_dev .lt. 2.0) then
            write (iout,1135) ' ----- WARNING: ',crm_dev
            nwarn=nwarn+1
          else if (crm_dev .lt. 4.0) then
            write (iout,1135) ' ===== STRONG WARNING: ',crm_dev
            nwwarn=nwwarn+1
          else
            write (iout,1135) ' ***** ERROR: ',crm_dev
            inperr=inperr+1
          end if
        end if
        write (iout,*)
      end if
c     Establish site-solute nearest approaches
      closed2=10000.0
      do is=1,ns
        call trnsfr(xyz,cscurr(1,is),3)
        rd2=10000.0
        ianear=0
        nsum=0.0
        cvsite(is)=0.0
        call zeroitd(rxyzsum,3)
        do ia=1,nslt
          call arrdiff(z,c(1,ia),xyz,3)
          d2=z(1)**2+z(2)**2+z(3)**2
          if (ianslt(ia) .ne. 1) then
            if (d2 .lt. rd2) then
              rd2=d2
              ianear=ia
            end if
          end if
          if (d2 .lt. 100.0) then
            rr=sqrt(d2)
            nsum=nsum+1
            do k=1,3
              rxyzsum(k)=rxyzsum(k)+z(k)/rr
            end do
          end if
        end do
        if (nsum .gt. 0.0) cvsite(is)=
     -      dsqrt(rxyzsum(1)**2+rxyzsum(2)**2+rxyzsum(3)**2)/
     -        dfloat(nsum)
        isxprox(is)=ianear
        bfac2(is)=rd2
        if (closed2 .gt. rd2) then
          closed2=rd2
          isclose=is
        end if
      end do
      call trnsfr(csw,csini,3*ns)
      nsorig=ns
      if (idebug(150) .gt. 0) then
        do is=1,ns
          call indexit(ixkeep,1,ns,0)
          write (iout,1101) is,ixkeep(is),isxprox(is),rdevsw(is),
     -      rdiffcnv(is),bfac2(is),1.0-cvsite(is),(cscurr(k,is),k=1,3)
        end do
      end if
c     Eliminate sites based on low occupancy, cv,rmsd or solute solvent distance
      ndel=0
      ndelempty=0
      distslt2lim=distsltmax**2
      if (distsltmax .eq. 0.0) distslt2lim=1.e+20
      if (rmsdlim .eq. 0.0) rmsdlim=1.e+20
      call indexit(is_orig,1,ns,0)
      do is=1,ns
        idrop=0
        if (frocc(is) .le. froccmin) then
          write (iout,1080) 'low occupancy'
          idrop=1
        end if
        if (1.0-cvsite(is) .lt. cvfilt) then
          write (iout,1080) 'low circular variance'
          idrop=1
        end if
        if (bfac2(is) .gt. distslt2lim) then
          write (iout,1080) 'large site-solute distance'
          idrop=1
        end if
        if (rdevsw(is) .gt. rmsdlim) then
          write (iout,1080) 'large site RMSD'
          idrop=1
        end if
        if (idrop .eq. 1) then
          if (frocc(is) .eq. 0.0) ndelempty=ndelempty+1
          write (line,1109) is,(cscurr(k,is),k=1,3),frocc(is),
     -      rdevsw(is),1.0-cvsite(is)
          if (isxprox(is) .gt. 0) then
            write (line(79:130),1087) 'to',labslt(2,isxprox(is)),
     -        isxprox(is),labslt(1,isxprox(is)),igrslt(isxprox(is)),
     -        sqrt(bfac2(is))
            llen=130
          else
            llen=78
          endif
          write (iout,1060) line(1:llen)
          ndel=ndel+1
        else
          bfac2(is-ndel)=bfac2(is)
          isxprox(is-ndel)=isxprox(is)
          ixkeep(is-ndel)=ixkeep(is)
          is_orig(is-ndel)=is_orig(is)
          numcount(is-ndel)=numcount(is)
          frocc(is-ndel)=frocc(is)
          cvsite(is-ndel)=cvsite(is)
          rdevsw(is-ndel)=rdevsw(is)
          rdiffcnv(is-ndel)=rdiffcnv(is)
          call trnsfr(cscurr(1,is-ndel),cscurr(1,is),3)
        end if
      end do
      ns=ns-ndel
      if (ndel .gt. 0) write (iout,1081) ns,ns+ndel
      if (ndelempty .gt. 0)  write (iout,1049) ndelempty
      if (ns .eq. 0) return
      if (idebug(150) .gt. 0) then
        write (iout,*) 'After elimination by proximity'
        do is=1,ns
          write (iout,1101) is,ixkeep(is),isxprox(is),rdevsw(is),
     -      rdiffcnv(is),bfac2(is),1.0-cvsite(is),(cscurr(k,is),k=1,3)
        end do
      end if
      call indexit(ixkeep,1,ns,0)
      if (isorttyp .eq. 1) then
c       Put the sites in the order of decreasing occupancy, for
c       fully occupied sites with increasing RMSD
        do is=1,ns
          frocc(is)=-frocc(is)
        end do
        call mrgsrt(iout,ixkeep,frocc,ns,l3,l4,istemp,rtemp,#MH)
        do is=1,ns
          frocc(is)=-frocc(is)
        end do
c       Set limit of RMSD sorting to fully occupied sites
        maxsort=1
        do while (maxsort .lt. ns .and. frocc(maxsort) .gt. 0.99)
          maxsort=maxsort+1
        end do
        if (frocc(ns) .gt. 0.99 .and. maxsort .eq. ns)
     -    maxsort=maxsort+1
        if (maxsort .gt. 1) maxsort=maxsort-1
        if (maxsort .gt. 1) then
          write (iout,1070) maxsort
          call reorder(rdevsw,l3,ixkeep,ns,rtemp,l4,1)
        end if
      else if (isorttyp .eq. 2) then
c       RMSD sorting done later
        maxsort=ns
      else if (isorttyp .eq. 3) then
c       Put the sites in the order of increasing convergence
        call mrgsrt(iout,ixkeep,rdiffcnv,ns,l3,l4,istemp,rtemp,#MH)
        maxsort=1
      else if (isorttyp .eq. 4) then
c       Put the sites in the order of increasing solute proximity
        call mrgsrt(iout,ixkeep,bfac2,ns,l3,l4,istemp,rtemp,#MH)
        maxsort=1
      else if (isorttyp .eq. 5) then
c       Put the sites in the order of decreasing CV wrt the solute
        call mrgsrt(iout,ixkeep,cvsite,ns,l3,l4,istemp,rtemp,#MH)
        maxsort=1
      else if (isorttyp .eq. 6) then
c       Put the sites in the order of increasing proximity solute index
        do is=1,ns
          rtemp1(is)=isxprox(is)
        end do
        call mrgsrt(iout,ixkeep,rtemp1,ns,l3,l4,istemp,rtemp,#MH)
        do is=1,ns
          isxprox(is)=rtemp1(is)
        end do
        maxsort=1
      end if
c     Put the first maxsort sites in the order of increasing RMSD
      call mrgsrt(iout,ixkeep,rdevsw,maxsort,l3,l4,istemp,rtemp,
     -  #MH)
c     Reorder the rest of the arrays
      call reorder(rtemp1,is_orig,ixkeep,ns,rtemp,l4,2)
      if (isorttyp .gt. 2)
     -  call reorder(rdevsw,l3,ixkeep,ns,rtemp,l4,1)
      if (isorttyp .ne. 1) call reorder(frocc,l3,ixkeep,ns,rtemp,l4,1)
      if (isorttyp .ne. 3)
     -  call reorder(rdiffcnv,l3,ixkeep,ns,rtemp,l4,1)
      if (isorttyp .ne. 4) call reorder(bfac2,l3,ixkeep,ns,rtemp,l4,1)
      if (isorttyp .ne. 5) call reorder(cvsite,l3,ixkeep,ns,rtemp,l4,1)
      if (isorttyp .ne. 6)
     -  call reorder(rtemp1,isxprox,ixkeep,ns,rtemp,l4,2)
      call reorder(rtemp1,numcount,ixkeep,ns,rtemp,l4,2)
      do is=1,ns
        call trnsfr(csini(1,is),cscurr(1,ixkeep(is)),3)
      end do
      call trnsfr(cscurr,csini,3*ns)
      if (idebug(150) .gt. 0) then
        write (iout,*) 'After sort'
        do is=1,ns
          write (iout,1101) is,ixkeep(is),isxprox(is),rdevsw(is),
     -      rdiffcnv(is),bfac2(is),1.0-cvsite(is),(cscurr(k,is),k=1,3)
        end do
      end if
c     Check distances between sites
      call rij2mat(1,ns,1,ns,0,0,1,1,1,1,cscurr,cscurr,iop(5),1,1,0.0,
     -  #MH,#MH)
      rmin2=10000.0
      do i=2,ns
        do j=1,i-1
          if (rsw2(i,j) .le. rmin2) then
            rmin2=rsw2(i,j)
            imin=i
            jmin=j
            if (rmin2 .eq. 0.0) then
              write (iout,1110) i,j
              nwwarn=nwwarn+1
            end if
          end if
        end do
      end do
c     Write generic site file
      keycol(1)=npxcol+3
      keycol(2)=npxcol+4
      call savesites(1,iopresfor,cgs,cscurr,csltr,ns,nslt,nslv,natoms,
     -  nmclast,iout,numrun,inperr,nwarn,nwwarn,keycol,
     -  frocc,rdevsw,file,namlenf,filenames(3),namlens(3),iop(24),
     -  sltdmax,iwslt,iatnam,ianslt,qslt,igrslt,l4,ianslv,mcmd,
     -  nmcbest,froccmin,isorttyp,filename2,namlen2,#HA)
c     Obtain a composite configuration, containing a close solvent to each site
c     and the representative conformation, gather data for % within RMSD, CV
      nsfound=0
      ndelsum=0
      nfiltsum=0
      do is=1,ns
        bfac1(is)=10000.0
        ixkeep(is)=1
        nmcorig(is)=0
      end do
      call zeroitd(ortaccu,9*ns)
      call zeroiti(icvcount,0,ns)
      call zeroitd(sengslt,ns)
      call zeroitd(sengslv,ns)
      call initcutoff(iout,nwarn)
      call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,0,nmolec,
     -  numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,uusfac,
     -  edgexyz,ieof,nconnfail)
      ieof=0
      nbestsaved=0
      bestrms10=100000.0
      maxsaved=max0(2,min0(10,nused/10))
      solvsum=0.d0
      solvsum2=0.d0
      call zeroiti(l4,0,ns)
      nscan=0
      nusedrep=0
      call zeroiti(iwofs_prev,0,ns)
      call zeroiti(nwofs,0,ns)
      call zeroitd(rmsd_tst,ns)
      call zeroit(frocc_tst,ns)
      do is=1,ns
        ifr_prev(is)=1
      end do
      nmclastr=0
      do while (ieof .eq. 0 .and. nmc .lt. nmcmax .or.
     -   iskip1 .gt. 0 .and. nmc .le. nmcmax)
        if (iskip1 .eq. 0) then
          call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -      nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,
     -      incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
        else
          iskip1=0
        end if
        if (ieof .eq. 0) nscan=nscan+1
        call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -    nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,c_save,
     -    cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,nsmax,cplpar,
     -    cplpmin,cplpmax,nowater)
        if (ifnd .gt. 0) then
          nusedrep=nusedrep+1
          nw=nmolec-1
          solvsum=solvsum+nw
          solvsum2=solvsum2+nw**2
          nmolecc=nmolec
          if (cvfilt_traj .gt. 0.0) nmolecc=nmolecsave
          call rematch(ns,nw,nslt,nslv,islvrep,csw,cscurr,c,rcutxst,
     -      r2sum,r2max,nmat,nmiter,niter,rmateps,nmc,maxmaxng,
     -      rmaxmatch,rmaxrematch,iop(5),nsorig,is_orig,irematchtyp,0,
     -      istemp,#MH,#NA)
          if (idebug(83) .gt. 0) then
            write (iout,1071) nmc,ns
            if (ns .gt. 0) write (iout,1188) (iwofs(is),is=1,ns)
          end if
          if (idebug(62) .gt. 2) then
            write (iout,1112) (is_orig(is),is=1,ns)
            do is=1,nsorig
              write (iout,1078) 'REMATCH',0,nmc,is,(rsw2(is,iw),iw=1,nw)
            end do
          end if
c         Collect data for orientational spreads (CV)
          do is=1,ns
            iw=iwofs(is)
            if (iw .gt. 0) then
              if (iop(26) .lt. 4) then
c               Water
                call ortslv(c(1,nslt+(iw-1)*nslv+1),ort,ifail)
                if (icvcount(is) .eq. 0) then
                  call trnsfr(hhdir0(1,is),ort(1,3),3)
                else
c                 See if HH has to be reversed
                  scp=sclprd(ort(1,3),hhdir0(1,is))
                  if (scp .lt. 0.0) then
                    do k=1,3
                      ort(k,3)=-ort(k,3)
                    end do
                  end if
                end if
              else
c               General solvent
                call getort(c(1,nslt+(iw-1)*nslv+1),z,ianslv,
     -            rlcslv,nslv,ort,1,ixislt,-1,linear,1,islvrep,ixrep3,
     -            nrep3,ifail,idebug(29),iout,nslv)
              end if
              icvcount(is)=icvcount(is)+1
              do k=1,3
                do l=1,3
                  ortaccu(k,l,is)=ortaccu(k,l,is)+ort(k,l)
                end do
              end do
c             Count the number of 'visitors' to each site
              nwofs(is)=nwofs(is)+1
              rmsd_tst(is)=rmsd_tst(is)+arrdist(cscurr(1,is),
     -          c(1,nslt+(iwofs(is)-1)*nslv+1))
            end if
            iso=is
            if (irematchtyp .eq. 2) iso=is_orig(is)
            if (iso .lt. 1) then
              write (iout,1116) nms,is,iso
              call datprt(2)
            end if
c           Collect data for the % of solvents within RMSD
            if (iwofs(is) .gt. 0) then
              if (rsw2(iso,iwofs(is)) .lt. rdevsw(is)**2)
     -          l4(is)=l4(is)+1
            end if
c           Check if nearest-list can be updated
            do iw=1,nw
              ds2=rsw2(is,iw)
              if (ds2 .lt. bfac1(is)) then
c               Check if this particular solvent has been used already
                isame=0
                do iss=1,is-1
                  if (arrdist(cgs(1,nslt+(iss-1)*nslv+1),
     -                c(1,nslt+(iw-1)*nslv+1)) .lt. 0.1) isame=1
                end do
                if (isame .eq. 0) then
                   call trnsfr(cgs(1,nslt+(is-1)*nslv+1),
     -               c(1,nslt+(iw-1)*nslv+1),3*nslv)
                  bfac1(is)=ds2
                  nmcorig(is)=nmc
                  iscontrib(is)=iw
                  nsfound=nsfound+1
                end if
              end if
            end do
          end do
          if (iop(118) .gt. 0) then
            write (iout_ws,1071) nmc,ns
            if (ns .gt. 0) write (iout_ws,1188) (iwofs(is),is=1,ns)
          end if
          if (idebug(83) .gt. 0) then
            write (iout,1071) nmc,ns
            if (ns .gt. 0) write (iout,1188) (iwofs(is),is=1,ns)
          end if
C@DB          do i=1,2
C@DB            if (iwofs(i) .gt. 0) write (iout,7782) i,iwofs(i),
C@DB     -        (c(k,nslt+(iwofs(i)-1)*nslv+1),k=1,3)
C@DB7782        format(' iwofs(',i1,')=',i5,' c=',3f10.5)
C@DB          end do
          if (iop(152) .eq. 2 .and. iop(3) .lt. 10) then
c           Calculate solute NB energy sum/average
            call eintra0(c,epmfo,ettnbo,einnbo,es14o,estor,ettnb01,
     -        einnb01,es1401,eslttor01,eintranb,em14,gbuupd,gbuupt)
            if (idebug(151) .gt. 1)
     -        write (iout,1126) nmc,einnbo,es14o,estor,ettnbo
            ettnbsum=ettnbsum+ettnbo
            einnbsum=einnbsum+einnbo
            e14nbsum=e14nbsum+es14o
            estorsum=estorsum+estor
            ettnbsum2=ettnbsum2+ettnbo**2
            einnbsum2=einnbsum2+einnbo**2
            e14nbsum2=e14nbsum2+es14o**2
            estorsum2=estorsum2+estor**2
          end if
          if (iop(3) .lt. 8) then
c           Calculate solvent COMs
            do im=2,nmolecc
              ifat=nslt+(im-2)*nslv+1
              if (cvfilt_traj .gt. 0.0) then
c               For solvent-solvent energy, use the waters filtered out too
                call cofms(c_save(1,ifat),crm(1,im),ianslv,1,nslv,1,wx)
              else
                call cofms(c(1,ifat),crm(1,im),ianslv,1,nslv,1,wx)
              end if
            end do
            do is=1,ns
              iw=iwofs(is)
              if (iw .gt. 0) then
c               Accumulate site energy
                if (iop(3) .le. 8) then
                  isx=ix_solv(iw+1)
                  sengslt(is)=sengslt(is)+engslt(iw+1,riijj,riijj0,
     -              rijps0,isprox,idistmv,idistid,c,crm(1,isx),crm)
c                 If filtered during the gens run, isx is the right index
                  ifat=nslt-2*nslv+1+isx*nslv
                  call checkwater(c(1,ifat),isx,nmc,0,iout,'X',nowater)
                  if (iop(119) .eq. 0) then
                    do js=2,nmolecc
                      if (js .ne. isx) then
                        ifat=nslt-2*nslv+1+js*nslv
                        call checkwater(c(1,ifat),js,nmc,0,iout,'J',
     -                    nowater)
                        z1=crm(1,js)-crm(1,isx)
                        z2=crm(2,js)-crm(2,isx)
                        z3=crm(3,js)-crm(3,isx)
                        call pbcnd(z1,z2,z3,iop(5),iopt,riijj)
                        if (riijj .le. ctslvs) then
                          if (cvfilt_traj .eq. 0.0) then
                            eij=eww(isx,js,iopt,cic(1,iopt),cic(2,iopt),
     -                        cic(3,iopt),riijj,c,crm)
                          else
                            eij=eww(isx,js,iopt,cic(1,iopt),cic(2,iopt),
     -                        cic(3,iopt),riijj,c_save,crm)
                          end if
                          if (idebug(83) .gt. 2) write (iout,1133)
     -                      nmc,isx,js,eij,(crm(k,isx),k=1,3),
     -                      (crm(k,js),k=1,3)
                          sengslv(is)=sengslv(is)+eij
                        end if
                      end if
                    end do
                  end if
                end if
              end if
            end do
          end if
c         See if this configuration is a better representative
          if (r2sum .le. bestrms10 .or. nbestsaved .lt. maxsaved) then
c           Save the info about this conformation
            nmiss=0
            do is=1,ns
              if (iwofs(is) .eq. 0) nmiss=nmiss+1
            end do
            if (nbestsaved .eq. 0) then
              rmssaved(1)=r2sum
              nmisssaved(1)=nmiss
              nmcsaved(1)=nmc
            else
c             Find the place of r2sum in the sorted rmssaved
              is=nbestsaved
              do while (is .gt. 1 .and. r2sum .le. rmssaved(is))
                is=is-1
              end do
              if (is .eq. 1 .and. r2sum .le. rmssaved(is)) is=0
c             Move down the data between nbestsaved and is-1
              do iss=min0(maxsaved-1,nbestsaved),is+1,-1
                rmssaved(iss+1)=rmssaved(iss)
                nmisssaved(iss+1)=nmisssaved(iss)
                nmcsaved(iss+1)=nmcsaved(iss)
              end do
              rmssaved(is+1)=r2sum
              nmisssaved(is+1)=nmiss
              nmcsaved(is+1)=nmc
            end if
            if (nbestsaved .lt. maxsaved) nbestsaved=nbestsaved+1
            bestrms1=rmssaved(1)
            bestrms10=rmssaved(nbestsaved)
          end if
        end if
      end do
      if (iop(118) .gt. 0) call fileclose(iout_ws,0,iop(24),iout)
      if (nused .eq. 0) then
        nused=nusedrep
      else
        if (niter .eq. 1 .and. iopinicnf .eq. 2) nused=nused+1
        if (nused .ne. nusedrep) then
          write (iout,1091) nused,nusedrep
          inperr=inperr+1
        end if
      end if
      if (irestore .gt. 0 .and. nused .ne. nusedprev) then
        write (iout,1092) nused,nusedprev
        nwwarn=nwwarn+1
      end if
      if (iop(24) .gt. 0) write (iout,1084) mcmd,nscan
      if (nsfound .lt. ns) then
        write (iout,1040) ns-nsfound
        nwwarn=nwwarn+1
      end if
      if (nusedrep .eq. 0) then
        write (iout,1093)
        call datprt(2)
      end if
      do is=1,ns
        if (nwofs(is) .gt. 0) then
          rmsd_tst(is)=dsqrt(rmsd_tst(is)/dfloat(nwofs(is)))
c         Divide by nusedrep nstead of nscan!
          frocc_tst(is)=float(nwofs(is))/float(nusedrep)
        end if
      end do
c     Save the composite structure to a .tmp file to free up cgs
      call fileopen(file,namlenf,filename1,namlens1,21,0,numrun,1,0,1,
     -  iop(24),iversout,iout,iwtemp,0)
      write (iwtemp) ((cgs(k,ia),k=1,3),ia=1,nslt+ns*nslv)
      if (idebug(64) .gt. 0)
     -   write (iout,1058) rmssaved,nmisssaved,mcmd,nmcsaved
c     For the representative structure select the one with the most molecules
      nmissbest=nmisssaved(1)
      nmcbest=nmcsaved(1)
      bestrms=rmssaved(1)
      nmissworst=0
      do isaved=1,nbestsaved
        if (nmisssaved(isaved) .lt. nmissbest) then
          nmissbest=nmisssaved(isaved)
          nmcbest=nmcsaved(isaved)
          bestrms=rmssaved(isaved)
        end if
        if (nmisssaved(isaved) .gt. nmissworst)
     -    nmissworst=nmisssaved(isaved)
      end do
      nmolecsave=nmolec
      call getbeststruct(filenames(3),namlens(3),nslt,nslv,islvrep,
     -  keycol,nmcstart,nmc,numrunh,nhstvers,cplpar,uusfac,ihist,
     -  inpt,iout,nwarn,nwwarn,inperr,nconnfail,lmnst,nmcbest,ns,nw,
     -  nmiss,nmolecbest,cscurr,cgs,c,cvfilt_traj,cvfilt_trajcut,
     -  iwofs,isofw,iop(5),rmateps,rcutxst,nowater,l3)
      rmsav=0.d0
      rms2av=0.d0
      froccav=0.d0
      frocc2av=0.d0
      rmsfroccav=0.d0
      devmax=0.0
      do is=1,ns
        if (irematchtyp .eq. 1) then
          frocc(is)=frocc_tst(is)
          rdevsw(is)=rmsd_tst(is)
        end if
        bfac1(is)=sqrt(bfac1(is))
        if (devmax .lt. bfac1(is)) devmax=bfac1(is)
        rmsav=rmsav+rdevsw(is)
        froccav=froccav+frocc(is)
        rms2av=rms2av+rdevsw(is)**2
        frocc2av=frocc2av+frocc(is)**2
        rmsfroccav=rmsfroccav+rdevsw(is)*frocc(is)
      end do
      rmsav=rmsav/ns
      froccav=froccav/ns
      rms2av=rms2av/ns
      frocc2av=frocc2av/ns
      rmsfroccav=rmsfroccav/ns
      froccsd=dsqrt(frocc2av-froccav**2)
      rmssd=dsqrt(rms2av-rmsav**2)
      corr=0.0
      if (froccsd*rmssd .gt. 0.0)
     -  corr=(rmsfroccav-rmsav*froccav)/(froccsd*rmssd)
      solvsum=solvsum/nused
      solvsum2=solvsum2/nused-solvsum**2
      solvsum2=dsqrt(solvsum2)
      write (iout,1050) nused
      write (iout,1067) solvsum,solvsum2,ns
      if (nfiltsum .gt. 0)
     -  write (iout,1073) float(ndelsum)/float(nfiltsum)
      write (iout,1055) froccav,froccsd,rmsav,rmssd,corr
      write (iout,1054) isclose,sqrt(closed2)
      write (iout,1029) sqrt(rmin2),imin,frocc(imin),jmin,frocc(jmin)
      write (iout,1065) sitesortlab(isorttyp)(1:lsitesortlab(isorttyp))
      write (iout,1060) ' '
      write (iout,1059) mcmd,nmcbest,nmolecbest-1,bestrms
      if (nmissbest .lt. nmissworst) write (iout,1051) nbestsaved,
     -  rmssaved(1),rmssaved(nbestsaved),nmissbest,nmissworst
      if (nw .gt. ns-nmiss) write (iout,1023) nw-(ns-nmiss)
      if (nmiss .gt. 0) write (iout,1031) nmiss
      write (iout,1034) sqrt(devmax)
      if (iop(152) .eq. 2 .and. iop(3) .lt. 10) then
        call avstdev_n(ettnbsum,ettnbsum2,nused,ettnb,ettnbsd)
        call avstdev_n(einnbsum,einnbsum2,nused,einnb,einnbsd)
        call avstdev_n(e14nbsum,e14nbsum2,nused,e14nb,e14nbsd)
        call avstdev_n(estorsum,estorsum2,nused,estorav,estorsd)
        ettot=ettnb+einnb+e14nb+estor
        ettotsd=sqrt(ettnbsd**2+einnbsd**2+e14nbsd**2+estorsd**2)
        write (iout,1127) ettot,ettotsd,ettnb,ettnbsd,einnb,einnbsd,
     -    e14nb,e14nbsd,estorav,estorsd
        if (iop(65) .eq. 0) write (iout,6500)
        if (iop(65) .eq. 1 .or. iop(65) .eq. 3)
     -    write (iout,6510) molgroup(iop(65))
        if (iop(65) .eq. 2 .or. iop(65) .eq. 4)
     -    write (iout,6511) molgroup(iop(65)),cutuu
      end if
      write (iout,1060) ' '
c     Read back the composite set
      rewind iwtemp
      read (iwtemp) ((cgs(k,ia),k=1,3),ia=1,nslt+ns*nslv)
c     call fileclose(iwtemp,1,iop(24),iout)
      call zeroit(rmsdtav,#AT)
      call zeroit(cvdipav,#AT)
      call zeroit(cvhhav,#AT)
      call zeroit(cv3av,#AT)
      call zeroit(froccs,#AT)
      call zeroit(sengs,#AT)
      call zeroiti(nstyp,0,#AT)
      iapxprev=0
      totenpx=0.0
      numcountdiff=0
      numcountdiffsum=0
      do is=1,ns
        perc=0.0
        if (l4(is) .gt. 0) perc=float(l4(is))/(frocc(is)*float(nused))
        iperc=100*perc
        ityp=iclslt(isxprox(is))
        froccs(ityp)=froccs(ityp)+frocc(is)
        if (icvcount(is) .gt. 0) then
          sengslt(is)=sengslt(is)/float(icvcount(is))
          sengslv(is)=sengslv(is)/float(icvcount(is))
          sengs(ityp)=sengs(ityp)+frocc(is)*(sengslt(is)+sengslv(is))
        end if
        seng_sp(is)=sengslt(is)+sengslv(is)
        nstyp(ityp)=nstyp(ityp)+1
        rmsdtav(ityp)=rmsdtav(ityp)+frocc(is)*rdevsw(is)
        if (iop(26) .lt. 4 .and. icvcount(is) .gt. 0) then
          cvdip=1.d0-dsqrt(ortaccu(1,1,is)**2+ortaccu(2,1,is)**2+
     -      ortaccu(3,1,is)**2)/float(icvcount(is))
          cvhh=1.d0-dsqrt(ortaccu(1,3,is)**2+ortaccu(2,3,is)**2+
     -      ortaccu(3,3,is)**2)/float(icvcount(is))
          cvhhav(ityp)=cvhhav(ityp)+frocc(is)*cvhh
          cvdipav(ityp)=cvdipav(ityp)+frocc(is)*cvdip
        else
          cvdip=0.d0
          cvhh=0.d0
        end if
        cv3=0.0
        if (icvcount(is) .gt. 0) then
          do k=1,3
            do l=1,3
              cv3=cv3+ortaccu(k,l,is)**2
              ort(k,l)=ortaccu(k,l,is)
            end do
          end do
          cv3=1.0-sqrt(cv3/3.0)/float(icvcount(is))
c         Put into ort the average orientation
          call vprd(ort(1,3),ort(1,1),ort(1,2))
          call vprd(ort(1,1),ort(1,2),ort(1,3))
          call mnorm(ort,ifail)
          do k=1,3
            do l=1,3
              ortaccu(k,l,is)=ort(k,l)
            end do
          end do
        end if
        cv3av(ityp)=cv3av(ityp)+frocc(is)*cv3
        if (isorttyp .eq. 6) then
c         Check for end of proxmity region, print sums
          if (iapxprev .ne. isxprox(is)) then
            if (iapxprev .gt. 0) write (iout,1102) iapxprev,
     -        igrslt(iapxprev),(labslt(k,iapxprev),k=1,2),
     -        totoccpx,totenpx
            iapxprev=isxprox(is)
            totoccpx=0.0
            totenpx=0.0
          end if
          totoccpx=totoccpx+frocc(is)
          totenpx=totenpx+frocc(is)*(sengslt(is)+sengslv(is))
        end if
        if (iop(26) .lt. 4) then
          write (iout,1047) is,(cscurr(k,is),k=1,3),frocc(is),
     -      rdevsw(is),iperc,'dipole',cvdip,'H-H',cvhh,cv3
        else if (iop(26) .eq. 4) then
          write (iout,1047) is,(cscurr(k,is),k=1,3),frocc(is),
     -      rdevsw(is),iperc,'X',cvdip,'Z',cvhh,cv3
        end if
        ncol=40
        write (line(1:40),1088) rdiffcnv(is)
        if (iop(3) .le. 8) write (line(29:40),1100) seng_sp(is)
c       cvsite was 1-CV (to help sorting)
        cvsite(is)=1.0-cvsite(is)
        if (nslt .gt. 0 .and. isxprox(is) .gt. 0) then
          write (line(41:100),1087) 'solute atom:',
     -      labslt(2,isxprox(is)),isxprox(is),labslt(1,isxprox(is)),
     -      igrslt(isxprox(is)),sqrt(bfac2(is))
          ncol=100
          write (line(ncol+1:ncol+30),1069) cvsite(is)
          ncol=ncol+30
        else if (nslt .gt. 0) then
          write (line(41:79),1182)
          ncol=79
        end if
        write (iout,1060) line(1:ncol)
        if (iwofs(is) .eq. 0) then
          write (iout,1107) nwofs(is)
        else
          call trnsfr(z,c(1,nslt+(iwofs(is)-1)*nslv+islvrep),3)
          write (iout,1046) z,iwofs(is),sqrt(arrdist(z,cscurr(1,is))),
     -      nwofs(is),sengslt(is)
        end if
        if (nwofs(is) .ne. numcount(is) .and. irematchtyp .eq. 2) then
          if (iop(24) .gt. 1)write (iout,1113) is,numcount(is),nwofs(is)
          numcountdiff=numcountdiff+1
          numcountdiffsum=numcountdiffsum+iabs(numcount(is)-nwofs(is))
        end if
        if (nmcorig(is) .eq. 0) then
          write (iout,1032) sengslv(is)
        else
          write (line,1052) (cgs(k,nslt+(is-1)*nslv+islvrep),k=1,3),
     -      bfac1(is),iscontrib(is),mcmd,nmcorig(is),sengslv(is)
          if (bfac1(is) .ge. 10.0) then
             write (line(97:108),1053) 10.0,'>>>**'
          else if (bfac1(is) .ge. 1.0) then
             write (line(97:108),1053) 1.0,'>>>>>'
          else if (bfac1(is) .ge. 0.5) then
             write (line(97:108),1053) 0.5,'>>>  '
          end if
          write (iout,1060) line
        end if
C@DB        write (iout,7791) is,rmsd_tst(is),frocc_tst(is)
C@DB7791    format(' is=',i4,' rmsd_tst=',f10.2,' frocc_tst=',f10.5)
      end do
      if (numcountdiff .gt. 0) then
        diffav=float(numcountdiffsum)/float(numcountdiff)
        write (iout,1114) numcountdiff,diffav
      end if
      call zeroit(rtemp,nslt)
      call zeroit(rtemp1,nslt)
      do is=1,ns
        ipx=isxprox(is)
        rtemp(ipx)=rtemp(ipx)+frocc(is)
        rtemp1(ipx)=rtemp1(ipx)+frocc(is)*sengslt(is)
        rtemp2(ipx)=rtemp2(ipx)+frocc(is)*sengslv(is)
      end do
      write (iout,1105) 'residues'
      do ig=1,igrslt(nslt)
        froccsum=0.0
        sengsum1=0.0
        sengsum2=0.0
        do ia=ifgrslt(ig),ilgrslt(ig)
          if (rtemp(ia) .gt. 0.0) then
            write (iout,1103) 'Residue',ig,ia,(labslt(k,ia),k=1,2),
     -        rtemp(ia),rtemp1(ia)/rtemp(ia),rtemp2(ia)/rtemp(ia),
     -        (rtemp1(ia)+rtemp2(ia))/rtemp(ia)
            froccsum=froccsum+rtemp(ia)
            sengsum1=sengsum1+rtemp1(ia)
            sengsum2=sengsum2+rtemp2(ia)
          end if
        end do
        if (froccsum .gt. 0.0) write (iout,1104) 'Residue',ig,
     -    labslt(1,ilgrslt(ig)),froccsum,sengsum1/froccsum,
     -    sengsum2/froccsum,(sengsum1+sengsum2)/froccsum
      end do
      if (iop(25) .eq. 0) then
        call findfg(1,nslt,ianslt,indxfg,itypfg,nfg,iout,
     -    nwarn,nneiga,nneigh,ineig,#NL)
        call sortfg(nfg,1,ifgstr,indxfg,ifgaix,nfgmem,ifgtyp,itypfg,
     -    ixfg,nslt,iout,inperr)
      end if
      write (iout,1105) 'functional groups'
      iop25=min0(2,iop(25)+1)
      do igg=1,nfg
        ig=ixfg(ig)
        froccsum=0.0
        sengsum1=0.0
        sengsum2=0.0
        do iaa=ifgstr(ig),ifgstr(ig)+nfgmem(ig)-1
          ia=ifgaix(iaa)
          if (rtemp(ia) .gt. 0.0) then
            write (iout,1103) 'Fcg',ig,ia,
     -        labslt(2,ia),namfcg(ifgtyp(ig),iop25),rtemp(ia),
     -        rtemp1(ia)/rtemp(ia),rtemp2(ia)/rtemp(ia),
     -        (rtemp1(ia)+rtemp2(ia))/rtemp(ia)
            froccsum=froccsum+rtemp(ia)
            sengsum1=sengsum1+rtemp1(ia)
            sengsum2=sengsum2+rtemp2(ia)
          end if
        end do
        if (froccsum .gt. 0.0) write (iout,1104) 'Fcg',ig,
     -    namfcg(ifgtyp(ig),iop25),froccsum,sengsum1/froccsum,
     -    sengsum2/froccsum,(sengsum1+sengsum2)/froccsum
      end do
      write (iout,1086)
      do it=1,#AT
        if (nstyp(it) .gt. 0 .and. froccs(it) .gt. 0.0)
     -    write (iout,1089) it,pflab(it,iop(3)),froccs(it)/nstyp(it),
     -      rmsdtav(it)/froccs(it),(sengslt(it)+sengslv(it))/froccs(it),
     -      cvdipav(it)/froccs(it),cvhhav(it)/froccs(it),
     -      cv3av(it)/froccs(it),nstyp(it)
      end do
      write (iout,1060) ' '
c     Save the composite configuration
      ndel=0
      do is=1,ns
        l3(is+1)=nmcorig(is)
        if (ixkeep(is) .eq. 0) then
          ndel=ndel+1
        else
          frocc1(is-ndel)=frocc(is)
          bfac1(is-ndel)=rdevsw(is)
        end if
      end do
      numsolv=ns
      nmolec=ns+1
      natoms=nslt+ns*nslv
      call discardmol(numsolv,nmolec,natoms,nslt,nslv,cgs,crm,
     -  0,rtemp,rtemp,l3,l4,1,#HA,#MH)
c     l3: ixkeep, l4:indexfilt
      keycol(1)=npxcol+3
      keycol(2)=npxcol+4
      call savesites(6,iopresfor,cgs,cscurr,csltr,ns,nslt,nslv,natoms,
     -  nmclast,iout,numrun,inperr,nwarn,nwwarn,keycol,
     -  frocc1,bfac1,file,namlenf,filenames(3),namlens(3),iop(24),
     -  sltdmax,iwslt,iatnam,ianslt,qslt,igrslt,l4,ianslv,mcmd,nmcbest,
     -  froccmin,isorttyp,filename2,namlen2,#HA)
      if (nslv .gt. 1) then
c       Generate solvents in average orientation
        call trnsfr(z,rlcslv(1,islvrep),nslv)
        do is=1,nslv
          call arrdiff(cslvrep(1,is),rlcslv(1,is),z,nslv)
        end do
        ndel=0
        do is=1,ns
          if (icvcount(is) .gt. 0) then
            frocc1(is-ndel)=frocc(is)
            bfac1(is-ndel)=rdevsw(is)
            do i=1,3
              do j=1,3
                ort(i,j)=ortaccu(i,j,is)
              end do
            end do
            call rot_trans(ort,cslvrep,cscurr(1,is),
     -        cgs(1,nslt+(is-ndel-1)*nslv+islvrep),nslv)
          else
            ndel=ndel+1
            if (iop(24) .gt. 1) write (iout,1068) is,frocc(is),
     -        'average solvent orientation'
          end if
        end do
        nsavrot=ns-ndel
        keycol(2)=npxcol+1
        call savesites(7,iopresfor,cgs,cscurr,csltr,nsavrot,nslt,nslv,
     -    nslt+nsavrot*nslv,nmclast,iout,numrun,inperr,nwarn,nwwarn,
     -    keycol,frocc1,bfac1,file,namlenf,filenames(3),namlens(3),
     -    iop(24),sltdmax,iwslt,iatnam,ianslt,qslt,igrslt,l4,ianslv,
     -    mcmd,nmcbest,froccmin,isorttyp,filenamew,namlenw,#HA)
        if (iop(26) .eq. 4) write (iout,1106)
      end if
c     Save the representative configuration
c     Get the occupancy and the site-solvent distance for the
c     representative solvents
      nmolec=nmolecbest
      numsolv=nmolec-1
      natoms=nslt+numsolv*nslv
      call zeroit(bfac1,nmolec)
      call zeroit(frocc1,nmolec)
      do is=1,ns
        if (iwofs(is) .gt. 0) then
          frocc1(iwofs(is))=frocc(is)
          bfac1(iwofs(is))=sqrt(arrdist(cscurr(1,is),
     -      c(1,nslt+(iwofs(is)-1)*nslv+islvrep)))
        end if
      end do
      iwsltrep=min0(iwslt,1)
      keycol(1)=npxcol+3
      keycol(2)=npxcol+4
      call savesites(4,iopresfor,c,cscurr,csltr,ns,nslt,nslv,natoms,
     -  nmclast,iout,numrun,inperr,nwarn,nwwarn,keycol,
     -  frocc1,bfac1,file,namlenf,filenames(3),namlens(3),iop(24),
     -  sltdmax,iwsltrep,iatnam,ianslt,qslt,igrslt,l4,ianslv,mcmd,
     -  nmcbest,froccmin,isorttyp,filename2,namlen2,#NA)
      nmolec=nmolecsave
      numsolv=nmolec-1
      natoms=nslt+numsolv*nslv
      nused=0
      if (froccminrep .gt. 0.0) then
c       Get the best representative site with all sites with frocc>froccminrep
c       present
        nrepfound=0
        do while (nrepfound .eq. 0 .and. froccminrep .lt. 1.0)
          nsitemiss0=ns
          do is=1,ns
            if (frocc(is) .lt. froccminrep) nsitemiss0=nsitemiss0-1
          end do
          write (iout,1057) froccminrep,ns-nsitemiss0
          call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,0,
     -      nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,
     -      uusfac,edgexyz,ieof,nconnfail)
          call trnsfr(cgs,c,3*nslt)
          ieof=0
          nmc=0
          bestrms=1000000.0
          nscan=0
          nmclastr=0
          do while (ieof .eq. 0 .and. nmc .lt. nmcmax)
            if (iskip1 .eq. 0) then
              call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -          nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -          nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
            else
              iskip1=0
            end if
            if (ieof .eq. 0) nscan=nscan+1
            call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -        nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,
     -        c_save,cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,
     -        nsmax,cplpar,cplpmin,cplpmax,nowater)
            if (ifnd .gt. 0) then
              nused=nused+1
              nw=nmolec-1
              call rematch(ns,nw,nslt,nslv,islvrep,csw,cscurr,c,rcutxst,
     -          r2sum,r2max,nmat,nmiter,niter,rmateps,nmc,maxmaxng,
     -          rmaxmatch,rmaxrematch,iop(5),nsorig,is_orig,irematchtyp,
     -          0,istemp,#MH,#NA)
c             Check if all required sites are represented
              nsitemiss=nsitemiss0
              do is=1,ns
                if (frocc(is) .ge. froccminrep .and. iwofs(is) .ne. 0)
     -            nsitemiss=nsitemiss-1
              end do
              if (nsitemiss .eq. 0) then
                nrepfound=nrepfound+1
c               See if this configuration is a better representative
                if (r2sum .le. bestrms) then
                  nmcbest=nmc
                  bestrms=r2sum
                end if
              end if
            end if
          end do
          if (nrepfound .eq. 0) then
            write (iout,1075) froccminrep
            froccminrep=froccminrep+0.02
          else
            write (iout,1076) froccminrep,nrepfound
          end if
        end do
        if (iop(24) .gt. 0) write (iout,1084) mcmd,nscan,' ',nused
        if (froccminrep .gt. 0.0) then
c         Get and save the nmcbest-th structure
          call getbeststruct(filenames(3),namlens(3),nslt,nslv,islvrep,
     -      keycol,nmcstart,nmc,numrunh,nhstvers,cplpar,uusfac,ihist,
     -      inpt,iout,nwarn,nwwarn,inperr,nconnfail,lmnst,nmcbest,ns,nw,
     -      nmolecbest,nmiss,cscurr,c,cgs,cvfilt_traj,cvfilt_trajcut,
     -      iwofs,isofw,iop(5),rmateps,rcutxst,nowater,l3)
          numsolv=nmolec-1
c         Get the occupancy and the site-solvent distance for the
c         representative solvents
          call zeroit(bfac1,nmolec)
          call zeroit(frocc1,nmolec)
          do is=1,ns
            if (iwofs(is) .gt. 0) then
              frocc1(iwofs(is))=frocc(is)
              bfac1(iwofs(is))=sqrt(arrdist(cscurr(1,is),
     -          cgs(1,nslt+(iwofs(is)-1)*nslv+islvrep)))
            end if
          end do
          call savesites(5,iopresfor,cgs,cscurr,csltr,ns,nslt,nslv,
     -      natoms,nmclast,iout,numrun,inperr,nwarn,nwwarn,
     -      keycol,frocc1,bfac1,file,namlenf,filenames(3),namlens(3),
     -      iop(24),sltdmax,iwsltrep,iatnam,ianslt,qslt,igrslt,l4,
     -      ianslv,mcmd,nmcbest,froccmin,isorttyp,filename2,namlen2,
     -      #HA)
        end if
      end if
      if (clstmerge_dmax .gt. 0.0) then
c       Cluster sites (do it last!)
        call mergesites(c,nslt,ns,clstmerge_dmax,froccpairmax,cscurr,
     -    frocc,rdevsw,cvsite,seng_sp,nofcls,ifirst,ilast,iclst,
     -    inperr,iout)
        nmolecdel=ns-nofcls
        nmolec=nofcls+1
        natoms=nslt+nofcls
        keycol(1)=npxcol+3
        keycol(2)=npxcol+4
        call savesites(2,iopresfor,cgs,cgs(1,nslt+1),csltr,nofcls,nslt,
     -    1,natoms,nmclast,iout,numrun,inperr,nwarn,nwwarn,
     -    keycol,frocc,rdevsw,file,namlenf,filenames(3),namlens(3),
     -    iop(24),sltdmax,iwslt,iatnam,ianslt,qslt,igrslt,l4,ianslv,
     -    mcmd,nmcbest,froccmin,isorttyp,filename2,namlen2,#HA)
c       if (iop(118) .gt. 0 .and. nmolecdel .gt. 0) then
        if (iop(118) .gt. 0) then
c         Repeat the generation of assignment index list
          ivers_wsl=ivers_wsl+1
          call fileopen(file,namlenf,filenames(32),
     -      namlens(32),32,0,numrun,ivers_wsl,3,0,iop(24),iversout,
     -      iout,iout_ws,0)
          write (iout,1124) filenames(32)(1:namlens(32))
          call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,incc,
     -      nmolec,numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,
     -      uusfac,edgexyz,ieof,nconnfail)
          nmclastr=0
          call zeroitd(ortaccu,9*ns)
          call zeroiti(icvcount,0,ns)
          nscan=0
          nused=0
          do while (ieof .eq. 0 .and. nmc .lt. nmcmax)
            if (iskip1 .eq. 0) then
              call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -          nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -          nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
            else
              iskip1=0
            end if
            if (ieof .eq. 0) nscan=nscan+1
            call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -        nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,
     -        c_save,cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,
     -        nsmax,cplpar,cplpmin,cplpmax,nowater)
            if (ifnd .gt. 0) then
              nused=nused+1
              nw=nmolec-1
              call rematch(nofcls,nw,nslt,nslv,islvrep,csw,
     -          cgs(1,nslt+1),c,rcutxst,r2sum,r2max,nmat,nmiter,niter,
     -          rmateps,nmc,maxmaxng,rmaxmatch,rmaxrematch,iop(5),
     -          nsorig,is_orig,irematchtyp,1,istemp,#MH,#NA)
              if (irematchtyp .eq. 2) then
c               Now reorder/merge the iwofs entries
                do ic=1,nofcls
                  do is=ifirst(ic),ilast(ic)
                    iso=is_orig(iclst(is))
                    if (iwofs(iso) .gt. 0) istemp(ic)=iwofs(iso)
                  end do
                end do
                call trnsfi(iwofs,istemp,nofcls)
              end if
              write (iout_ws,1071) nmc,nofcls
              if (nofcls .gt. 0)
     -          write (iout_ws,1188) (iwofs(is),is=1,nofcls)
              if (iop(26) .lt. 4) then
c               Water
                do is=1,nofcls
                  iw=iwofs(is)
                  if (iw .gt. 0) then
                    icvcount(is)=icvcount(is)+1
                    call ortslv(c(1,nslt+(iw-1)*nslv+1),ort,ifail)
                    if (icvcount(is) .eq. 0) then
                      call trnsfr(hhdir0(1,is),ort(1,3),3)
                    else
c                     See if HH has to be reversed
                      scp=sclprd(ort(1,3),hhdir0(1,is))
                      if (scp .lt. 0.0) then
                        do k=1,3
                          ort(k,3)=-ort(k,3)
                        end do
                      end if
                    end if
                    do i=1,3
                      do j=1,3
                        ortaccu(i,j,is)=ortaccu(i,j,is)+ort(i,j)
                      end do
                    end do
                  end if
                end do
              end if
            end if
          end do
          if (iop(26) .lt. 4) then
c           Create conformation with waters in average orientation
            do is=1,nofcls
              call trnsfr(c(1,nslt+(is-1)*nsvp+1),cgs(1,nslt+is),3)
              if (icvcount(is) .eq. 0) then
                call zeroit(c(1,nslt+(is-1)*nsvp+2),6)
                write (iout,1012) is
              else
                do i=1,3
                  do j=1,3
                    ort(i,j)=ortaccu(i,j,is)/dfloat(icvcount(is))
                  end do
                end do
                call vprd(ort(1,3),ort(1,1),ort(1,2))
                call vprd(ort(1,1),ort(1,2),ort(1,3))
                call mnorm(ort,ifail)
                do k=1,3
                  c(k,nslt+(is-1)*nsvp+2)=c(k,nslt+(is-1)*nsvp+1)+
     -              ort(k,1)*0.585882+ort(k,3)*0.756950
                  c(k,nslt+(is-1)*3+3)=c(k,nslt+(is-1)*3+1)+
     -              ort(k,1)*0.585882-ort(k,3)*0.756950
                end do
              end if
            end do
            natoms=nslt+3*nofcls
            keycol(2)=npxcol+1
            call savesites(8,iopresfor,c,cgs(1,nslt+1),csltr,nofcls,
     -        nslt,3,natoms,nmclast,iout,numrun,inperr,nwarn,
     -        nwwarn,keycol,frocc,rdevsw,file,namlenf,filenames(3),
     -        namlens(3),iop(24),sltdmax,iwslt,iatnam,ianslt,qslt,
     -        igrslt,l4,ianslv,mcmd,nmcbest,froccmin,isorttyp,
     -        filenamew,namlenw,#HA)
          end if
          if (iop(118) .gt. 0) call fileclose(iout_ws,0,iop(24),iout)
        end if
        ns=nofcls
      end if
      call trnsfr(csini,cscurr,3*ns)
      if (clstfin_dmax .gt. 0.0 .or. nclust_clstfin .gt. 0) then
c       Cluster the final set of sites, create entropy calculation input
        filename1=file(1:namlenf)//'_gs_fcl'
        namlen1=namlenf+7
        call fileopen(filename1,namlen1,filename1,namlen1,
     -    33,0,numrun,1,3,0,iop(24),iversout,iout,iuinf,0)
        call cluster_sites(c,nslt,ns,clstfin_dmax,nclust_clstfin,
     -    iop(118),cvfilt_stow,froccmin_stow,rmsdlim_stow,
     -    maxclstmem_stow,subreground,cscurr,frocc,rdevsw,cvsite,
     -    seng_sp,cvfilt_traj,cvfilt_trajcut,nofcls,ifirst,ilast,iclst,
     -    nmcdisc/nmcsave,filenamew,namlenw,l4,numrun,inperr,iuinf,iout)
        call fileclose(iuinf,0,iop(24),iout)
        keycol(2)=npxcol+1
        call savesites(3,iopresfor,cgs,cscurr,csltr,ns,nslt,1,
     -    natoms,nmclast,iout,numrun,inperr,nwarn,nwwarn,
     -    keycol,frocc,rdevsw,file,namlenf,filenames(3),namlens(3),
     -    iop(24),sltdmax,iwslt,iatnam,ianslt,qslt,igrslt,l4,ianslv,
     -    mcmd,nmcbest,froccmin,isorttyp,filenamew,namlenw,#HA)
      end if
c     Restore cscurr
      call trnsfr(cscurr,csini,3*ns)
      nhb_slt=0
      inperr0=inperr
      if (iop(118) .gt. 0) then
c       Recalculate  site-solute energies, site-site and
c       intra-cluster w-w energies
        call fileopen(file,namlenf,filenames(32),namlens(32),32,0,
     -    numrun,ivers_wsl,2,0,iop(24),iversout,iout,iout_ws,0)
        call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,0,nmolec,
     -    numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,uusfac,
     -    edgexyz,ieof,nconnfail)
        if (iop(122) .gt. 0) then
          if (iop(26) .gt. 4) then
            write (iout,1139)
            nwarn=nwarn+1
          end if
          call zeroit(dipcorr_eng,#MH**2)
          call zeroit(dipavij,3*#MH**2)
          call zeroit(dipcorrii,3*#MH**2)
          call zeroit(dipcorrij,3*#MH**2)
          call zeroiti(nhb_ss,0,#MH**2)
          call zeroiti(nframeocc,0,#MH)
          call zeroiti(iocccorr,0,#MH**2)
        end if
        nframes=0
        call zeroitd(sengslt,ns)
        call zeroitd(sengslv,ns)
        call zeroitd(seng_sp,ns)
        call zeroiti(iscontrib,0,nofcls)
        call zeroiti(nhbstsv,0,ns)
        rxhtest2=(sqrt(rxhmax2)+2)**2
        rwwiijj=999.0
        nscan=0
        nused=0
        nmclastr=0
        call zeroiti(nwhb,0,#MH)
        call zeroiti(nacc_whb,0,#NS*#MH)
        do while (ieof .eq. 0 .and. nmc .lt. nmcmax)
          if (iskip1 .eq. 0) then
            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -        nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
          else
            iskip1=0
          end if
          if (ieof .eq. 0) then
            nscan=nscan+1
            call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -        nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,
     -        c_save,cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,
     -        nsmax,cplpar,cplpmin,cplpmax,nowater)
            if (ifnd .gt. 0) then
              nused=nused+1
              ns=-1
              read (iout_ws,1072,end=771) nmc_wsl,ns
              if (nmc .ne. nmc_wsl) then
                write (iout,1136) nmc,'wsl',nmc_wsl
                inperr=inperr+1
              end if
              if (iwriteorg .gt. 0) then
                read (iwriteorg,end=771) nmc_orig,nmolecw,nsolvorig
                if (nmc .ne. nmc_orig) then
                  write (iout,1136) nmc,'oro',nmc_orig
                  inperr=inperr+1
                end if
                read (iwriteorg) (isorig(is),is=1,nmolecw-1)
              end if
              call zeroiti(ifatocc,0,ns)
              if (ns .gt. 0) then
                read (iout_ws,1188,end=771) (iwofs(is),is=1,ns)
                nframes=nframes+1
                if (idebug(83) .gt. 1) then
                   write (iout,1134) nmc,nmolec,natoms
                   write (iout,1188) (iwofs(is),is=1,ns)
                   do ia=natoms+1,#NA
                     c(1,ia)=99999.9
                   end do
                end if
                do isa=1,ns
                  ia=iwofs(isa)
                  if (ia .gt. 0) then
                    nframeocc(isa)=nframeocc(isa)+1
                    iaw=ia+1
                    ifat=nslt+(iaw-2)*nslv+1
                    ifatocc(isa)=ifat
                    call cofms(c(1,ifat),crm(1,iaw),ianslv,1,nslv,1,wx)
                    if (idebug(83) .gt. 1) then
                      write (iout,1132) nmc,nframes,
     -                  isa,ia,(crm(k,iaw),k=1,3)
                      if (c(1,ifat) .eq. 99999.9) write (iout,*)
     -                  'ERROR: Undefined coordinate'
                    end if
                  end if
                end do
                do ic=1,nofcls
                  nwfound=0
                  eij=0.0
c                 write (iout,1123) nframes,(iclst(iaa),
c    -              iwofs(iclst(iaa)),iaa=ifirst(ic),ilast(ic))
                  call zeroiti(ix_solv,0,ns)
                  do iaa=ifirst(ic),ilast(ic)
                    ix_solv(iclst(iaa))=1
                  end do
                  do iaa=ifirst(ic),ilast(ic)
                    isa=iclst(iaa)
                    iw=iwofs(isa)
                    if (iw .gt. 0) then
                      nwfound=nwfound+1
c                     iw, jw are water numbers, not molecule numbers
                      iaw=iw+1
                      sengslt(isa)=sengslt(isa)+engslt(iaw,riijj,riijj0,
     -                  rijps0,isprox,idistmv,idistid,c,crm(1,iaw),crm)
                      if (igsanaltyp(4) .gt. 0) then
c                       Accumulate solute-water hydrogen bond count
                        nhb=0
                        do ia=1,nslt
                          ihb=0
                          if (r2stsv(ia) .lt. rxhtest2) then
                            iao=ifatocc(isa)
                            if (ianslt(ia) .eq. 1) then
c                             H on protein
                              if (qslt(ia) .gt. 0.2) then
                                ia_ng=ineig(1,ia)
                                call checkforhbond(c,iao,ia,ia_ng,
     -                            natoms,rxhmax2,hbanglemin,ihb,
     -                            ro2,hang,iout)
                                nhb=nhb+ihb
                                if (idebug(161) .gt. 0 .and. ihb .eq. 1)
     -                            write (iout,1148) nframes,isa,ia
                              end if
                            else if (qslt(ia) .lt. -0.2) then
c                             Protein is the acceptor
                              call checkforhbond(c,ia,iao+1,iao,
     -                          natoms,rxhmax2,hbanglemin,ihb,
     -                          ro2,hang,iout)
                              if (idebug(161) .gt. 0 .and. ihb .eq. 1)
     -                          write (iout,1148) nframes,isa,ia
                              nhb=nhb+ihb
                              call checkforhbond(c,ia,iao+2,iao,
     -                          natoms,rxhmax2,hbanglemin,ihb,
     -                          ro2,hang,iout)
                              if (idebug(161) .gt. 0 .and. ihb .eq. 1)
     -                          write (iout,1148) nframes,isa,ia
                              nhb=nhb+ihb
                            end if
                            if (ihb .gt. 0) then
c                             Gather solute-driven statistics
                              ia_save=0
                              do ja=1,nhb_slt
                                if (ixkeep(ja) .eq. ia) ia_save=ja
                              end do
                              if (ia_save .eq. 0) then
                                if (nhb_slt .lt. #MH) then
                                  nhb_slt=nhb_slt+1
                                  ixkeep(nhb_slt)=ia
                                else
                                  write (iout,1161) na
                                  inperr=inperr+1
                                  go to 400
                                end if
                                ia_save=nhb_slt
                              end if
c                             H bond between atom ixkeep(ia_save) and wat isa
                              isa_save=0
                              do js=1,nwhb(ia_save)
                                if (isa .eq. iwhb(js,ia_save))
     -                            isa_save=js
                              end do
                              if (isa_save .eq. 0) then
                                if (nwhb(ia_save) .lt. #NS) then
                                  nwhb(ia_save)=nwhb(ia_save)+1
                                  isa_save=nwhb(ia_save)
                                  iwhb(isa_save,ia_save)=isa
                                else
                                  write (iout,1162) 'atom',ia,#NS
                                  inperr=inperr+1
                                  go to 400
                                end if
                              end if
                              nacc_whb(isa_save,ia_save)=
     -                          nacc_whb(isa_save,ia_save)+1
                              if (idebug(167) .gt. 0) write (iout,7716)
     -                         nframes,ia,isa,isa_save,ia_save,
     -                         nwhb(ia_save),nacc_whb(isa_save,ia_save),
     -                         (iwhb(ja,ia_save),ja=1,nwhb(ia_save))
                            end if
                          end if
                        end do
                        nhbstsv(isa)=nhbstsv(isa)+nhb
                      end if
                      do jaa=1,ns
                        jsa=iclst(jaa)
                        jw=iwofs(jsa)
                        if (jw .gt. 0 .and. iw .ne. jw)  then
                          jaw=jw+1
                          eww0=eww(iaw,jaw,1,cxx,cyy,czz,rwwiijj,c,crm)
                          sengslv(isa)=sengslv(isa)+eww0
                          if (ix_solv(jsa) .eq. 1)
     -                      seng_sp(isa)=seng_sp(isa)+eww0
                        end if
                      end do
                    end if
                  end do
                  iscontrib(ic)=iscontrib(ic)+nwfound
                end do
              end if
              if (iop(122) .gt. 0) then
c               Accumulate the joint occupancy matrix
                do is1=1,ns
                  if (ifatocc(is1) .gt. 0) then
                    do is2=is1,ns
                      if (ifatocc(is2) .gt. 0) then
                        nhb_ss(is1,is2)=nhb_ss(is1,is2)+1
                      end if
                    end do
                  end if
                end do
              end if
              if (igsanaltyp(1)+igsanaltyp(2) .gt. 0) then
c               Calculate correlation/covariance matrix contributions
                do is1=1,ns
                  if (ifatocc(is1) .gt. 0) then
                    ifat1=ifatocc(is1)
                    dip1sum=0.0
                    hh1sum=0.0
                    do k=1,3
                      dip1(k)=c(k,ifat1+1)+c(k,ifat1+2)-2.0*c(k,ifat1)
                      hh1(k)=c(k,ifat1+1)-c(k,ifat1+2)
                      dip1sum=dip1sum+dip1(k)**2
                      hh1sum=hh1sum+hh1(k)**2
                    end do
                    if (sclprd(hh1,hhdir0(1,is1)) .lt. 0.0) then
                      do k=1,3
                        hh1(k)=-hh1(k)
                      end do
                    end if
                    do k=1,3
                      dip1(k)=dip1(k)/sqrt(dip1sum)
                      hh1(k)=hh1(k)/sqrt(hh1sum)
                    end do
                    do is2=is1,ns
                      if (ifatocc(is2) .gt. 0) then
                        ifat2=ifatocc(is2)
                        dip2sum=0.0
                        hh2sum=0.0
                        do k=1,3
                          dip2(k)=c(k,ifat2+1)+c(k,ifat2+2)-
     -                      2.0*c(k,ifat2)
                          hh2(k)=c(k,ifat2+1)-c(k,ifat2+2)
                          dip2sum=dip2sum+dip2(k)**2
                          hh2sum=hh2sum+hh2(k)**2
                        end do
                        if (sclprd(hh2,hhdir0(1,is2)) .lt. 0.0) then
                          do k=1,3
                            hh2(k)=-hh2(k)
                          end do
                        end if
                        do k=1,3
                          dip2(k)=dip2(k)/sqrt(dip2sum)
                          hh2(k)=hh2(k)/sqrt(hh2sum)
                        end do
                        if (icorrcomp .eq. 2) then
                          call trnsfr(dip1,hh1,3)
                          call trnsfr(dip2,hh2,3)
                        else if (icorrcomp .eq. 3) then
                          dhh1=sclprd(dip1,hh1)
                          dhh2=sclprd(dip2,hh2)
                          call vprd(dip1,hh1,rnorm1)
                          call vprd(dip2,hh2,rnorm2)
                          rr1=sclprd(rnorm1,rnorm1)
                          rr2=sclprd(rnorm2,rnorm2)
                          call trnsfr(dip1,rnorm1,3)
                          call trnsfr(dip2,rnorm2,3)
                        end if
                        scp=0.0
                        do k=1,3
                          scp=scp+dip1(k)*dip2(k)
                          dipavij(k,is1,is2)=dipavij(k,is1,is2)+dip1(k)
                          dipavij(k,is2,is1)=dipavij(k,is2,is1)+dip2(k)
                          dipcorrii(k,is1,is2)=dipcorrii(k,is1,is2)+
     -                      dip1(k)**2
                          dipcorrii(k,is2,is1)=dipcorrii(k,is2,is1)+
     -                      dip2(k)**2
                          dipcorrij(k,is1,is2)=dipcorrij(k,is1,is2)+
     -                      dip1(k)*dip2(k)
                        end do
                        dipcorr_eng(is1,is2)=dipcorr_eng(is1,is2)+scp
                      end if
                    end do
                  end if
                end do
              end if
              if (igsanaltyp(3) .gt. 0) then
c               Calculate interaction energy matrix
                do is1=1,ns
                  if (ifatocc(is1) .gt. 0) then
                    iaw=iwofs(is1)+1
                    do is2=is1+1,ns
                      if (ifatocc(is2) .gt. 0) then
                        jaw=iwofs(is2)+1
                        eww0=eww(iaw,jaw,1,cxx,cyy,czz,rwwiijj,c,crm)
                        dipcorr_eng(is2,is1)=dipcorr_eng(is2,is1)+eww0
                      end if
                    end do
                  end if
                end do
              end if
              if (igsanaltyp(4) .gt. 0) then
c               Calculate H-bond matrix
                do is1=1,ns
                  if (ifatocc(is1) .gt. 0) then
                    iao1=ifatocc(is1)
                    do is2=is1+1,ns
                      if (ifatocc(is2) .gt. 0) then
                        iao2=ifatocc(is2)
                        call checkforhbond(c,iao1,iao2+1,iao2,natoms,
     -                    rxhmax2,hbanglemin,ihb,ro2,hang,iout)
                        if (ihb .eq. 0) call checkforhbond(c,iao2,
     -                    iao2+2,iao2,natoms,rxhmax2,hbanglemin,ihb,
     -                    ro2,hang,iout)
                        if (ihb .eq. 0) call checkforhbond(c,iao2,
     -                    iao1+1,iao1,natoms,rxhmax2,hbanglemin,ihb,
     -                    ro2,hang,iout)
                        if (ihb .eq. 0) call checkforhbond(c,iao2,
     -                    iao1+2,iao1,natoms,rxhmax2,hbanglemin,ihb,
     -                    ro2,hang,iout)
                        nhb_ss(is2,is1)=nhb_ss(is2,is1)+ihb
                        if (idebug(165) .gt. 0) write (77,8501) nframe,
     -                    ihb,is1,is2,iao1,iao2,(c(k,iao1),k=1,3),
     -                   (c(k,iao2),k=1,3)
                      end if
                    end do
                  end if
                end do
              end if
              if (igsanaltyp(5) .gt. 0) then
c               Occupancy correlation
                do is1=1,ns
                  do is2=is1+1,ns
                    if (ifatocc(is1)*ifatocc(is2) .gt. 0) then
                      iocccorr(is1,is2)=iocccorr(is1,is2)+1
c                     Both are present
                    else if (ifatocc(is1)+ifatocc(is2) .gt. 0) then
c                     Only one of them is present
                      iocccorr(is2,is1)=iocccorr(is2,is1)+1
                    end if
                  end do
                end do
              end if
              if (igsanaltyp(7) .gt. 0) then
c               Jump count
                if (iwriteorg .gt. 0) then
                  if (idebug(163) .gt. 0) write (iout,7711)
     -              nmc,nmolecw,nsolvorig,(isorig(is),is=1,nmolecw-1)
                  if (idebug(163) .gt. 1) write (iout,7712) 'A',ns,
     -              (iwofs(is),is=1,ns)
                  do is=1,ns
                    if (iwofs(is) .gt. 0) iwofs(is)=isorig(iwofs(is))
                  end do
                  if (idebug(163) .gt. 1) write (iout,7712) 'B',ns,
     -             (iwofs(is),is=1,ns)
                end if
                call zeroiti(l4,0,nsolvorig)
                do is=1,ns
                  if (iwofs(is) .gt. 0) then
                    l4(iwofs(is))=is
                  end if
                end do
                if (idebug(163) .gt. 1)
     -            write (iout,7713) nw_orig,(l4(iw),iw=1,nsolvorig)
                if (nframes .eq. 1) then
                  call zeroiti(njump,0,#MH)
                else
                  do iw=1,#MO
                    isprev=l3(iw)
                    if (isprev .gt. 0) then
                      if (l3(iw) .ne. l4(iw))
     -                  njump(isprev)=njump(isprev)+1
                    end if
                  end do
                end if
                call trnsfi(l3,l4,#MO)
              end if
            else
              if (iwriteorg .gt. 0) then
                read (iwriteorg,end=771) nmc_orig,nw_orig
                read (iwriteorg) (isorig(is),is=1,nw_orig-1)
              end if
            end if
          end if
          go to 772
771       write (iout,1131) nmc,ns,nscan,nused
772       continue
        end do
400     if (inperr .gt. inperr0) write (iout,1164) nframes
        if (iop(123) .eq. 0) call fileclose(iout_ws,0,iop(24),iout)
        write (iout,1120) nframes
        totsengsltsum=0.0
        totsengslvsum=0.0
        totsengslv_clsum=0.0
        totoccsum=0.0
        centlab=' CENT'
        do ic=1,nofcls
          sengsltsum=0.0
          sengslvsum=0.0
          sengslv_clsum=0.0
          occsum=0.0
          write (iout,1128)
          call zeroit(crm_avg,3)
          do iaa=ifirst(ic),ilast(ic)
            isa=iclst(iaa)
            do k=1,3
              crm_avg(k)=crm_avg(k)+cscurr(k,isa)
            end do
          end do
          do k=1,3
            crm_avg(k)=crm_avg(k)/(ilast(ic)-ifirst(ic)+1)
          end do
          dnear2=1000.0
          iclose=0
          do iaa=ifirst(ic),ilast(ic)
            isa=iclst(iaa)
            d2=arrdist(cscurr(1,isa),crm_avg)
            if (d2 .lt. dnear2) then
              iclose=iaa
              dnear2=d2
            end if
          end do
          do iaa=ifirst(ic),ilast(ic)
            isa=iclst(iaa)
            occ=float(nframeocc(isa))/float(nframes)
            if (nframeocc(isa) .gt. 0) then
              esltav=sengslt(isa)/dfloat(nframeocc(isa))
              eslvav=sengslv(isa)/dfloat(nframeocc(isa))
              eslv_clav=seng_sp(isa)/dfloat(nframeocc(isa))
              sengsltsum=sengsltsum+esltav*occ
              sengslvsum=sengslvsum+eslvav*occ
              sengslv_clsum=sengslv_clsum+eslv_clav*occ
              occsum=occsum+occ
            else
              esltav=0.0
              eslvav=0.0
              eslv_clav=0.0
            end if
c           cscurr has the site coordinates - find the proximal slt atom
            riijj=99999.9
            do ia=1,nslt
              if (ianslt(ia) .gt. 1) then
                d2=arrdist(cscurr(1,isa),c(1,ia))
                if (d2 .lt. riijj) then
                  riijj=d2
                  isprox=ia
                end if
              end if
            end do
            lcentlab=1
            if (iaa .eq. iclose) lcentlab=5
            write (iout,1119) ic,isa,esltav,eslvav,eslv_clav,occ,
     -        occ*esltav,occ*eslvav,occ*eslv_clav,labslt(2,isprox),
     -        isprox,labslt(1,isprox),igrslt(isprox),centlab(1:lcentlab)
            isxprox(isa)=isprox
          end do
          write (iout,1121) ic,crm_avg,occsum,sengsltsum,sengslvsum/2.0,
     -      sengslv_clsum/2.0
          write (iout,*)
          totsengsltsum=totsengsltsum+sengsltsum
          totsengslvsum=totsengslvsum+sengslvsum
          totsengslv_clsum=totsengslv_clsum+sengslv_clsum
          totoccsum=totoccsum+occsum
        end do
        write (iout,1125) totoccsum,totsengsltsum,totsengslvsum/2.0,
     -    totsengslv_clsum/2.0
        call indexit(is_orig,1,ns,0)
        neigv=0
        if (iop(122) .gt. 0) then
c         Open matrix file(s) and check dimensions
          call checkdim(ifail,iout,inperr,'GC',ns,1,0,0)
          nmatanal=0
          ifmat=0
          if (matform .eq. 3) ifmat=1
          do i=1,6
            if (igsanaltyp(i) .gt. 0) then
              nmatanal=nmatanal+1
              iout_anal(i)=iout_ws+i
              ift=35+i
              call fileopen(file,namlenf,filenames(ift),namlens(ift),
     -          ift,0,numrun,ivers_wsl,3,ifmat,iop(24),iversout,iout,
     -          iout_anal(i),0)
              write (iout,1138) analname(i)(1:lanalname(i)),nframes,
     -          filenames(ift)(1:namlens(ift))
              if (i .eq. 4) then
                write (iout,1140) sqrt(rxhmax2),hbanglemin*rdtodg
                if (occmin_at .gt. 0.0)
     -            write (iout,1167) 'atom',occmin_at
                if (occmin_res .gt. 0.0)
     -            write (iout,1167) 'residue',occmin_res
              end if
              if (i .eq. 6) then
                write (iout,1168)
              else
                if (matform .le. 2) write (iout_anal(i),2000) ns
                if (matform .eq. 3) write (iout_anal(i)) ns
              end if
              if (igsanaltyp(i) .gt. 1) neigv=neigv+1
            end if
          end do
          if (igsanaltyp(7) .gt. 0) then
            write (iout,1152) nframes
            if (igsanaltyp(7) .eq. 2) then
              write (iout,1153) origfile(1:lorigfile)
            end if
          end if
          if (igsanaltyp(1)+igsanaltyp(2) .gt. 0)
     -      write (iout,1147) corrcompname(icorrcomp)
          if (igsanaltyp(5) .gt. 1) write (iout,1149)
        end if
        if (matsort .gt. 1) then
c         Sort to scramble is_orig
          if (matsort .eq. 2) write (iout,1141) lxyz(iaxsort1)
          if (matsort .eq. 3) write (iout,1142) lxyz(iaxsort1)
          if (matsort .eq. 4) write (iout,1143) sortwgt,
     -      lxyz(iaxsort1),sortwgt,lxyz(iaxsort2),lxyz(iaxsort3)
          do is=1,ns
            if (matsort .eq. 2) then
              rtemp1(is)=csini(iaxsort1,is)
            else if (matsort .eq. 3) then
              rtemp1(is)=sign(1.0,csini(iaxsort1,is))*
     -          sqrt(csini(1,is)**2+csini(2,is)**2+csini(3,is)**2)
            else
              rtemp1(is)=sortwgt**2*csini(iaxsort1,is)+
     -          sortwgt*csini(iaxsort2,is)+csini(iaxsort3,is)
            end if
          end do
          if (idebug(162) .gt. 0) then
             write (iout,1151)
     -        (is,rtemp1(is),(csini(k,is),k=1,3),is=1,ns)
          end if
          call mrgsrt(iout,is_orig,rtemp1,ns,ifirst,ilast,istemp,
     -      rtemp2,#MH)
        end if
        do is=1,ns
          ix_solv(is_orig(is))=is
        end do
        call zeroit(rtemp1,ns)
        if (igsanaltyp(1)+igsanaltyp(2) .gt. 0) then
          do is1=1,ns
            do is2=is1,ns
              scp=0.0
              do k=1,3
                dip1(k)=dipavij(k,is1,is2)/max0(1,nhb_ss(is1,is2))
                dip2(k)=dipavij(k,is2,is1)/max0(1,nhb_ss(is1,is2))
                scp=scp+dip1(k)*dip2(k)
              end do
              if (is1 .eq. is2) scp=scp/4.0
              dipcorr_eng(is1,is2)=
     -          dipcorr_eng(is1,is2)/max0(1,nhb_ss(is1,is2))-scp
            end do
            rtemp1(is1)=dipcorr_eng(is1,is1)
          end do
        end if
        if (neigv .gt. 0) then
          rewind iwtemp
          write (iwtemp) dipcorr_eng
        end if
        if (igsanaltyp(1) .gt. 0) then
          do ii=1,ns
            i=is_orig(ii)
            do j=1,i-1
              row(ix_solv(j))=dipcorr_eng(j,i)
            end do
            do j=i,ns
              row(ix_solv(j))=dipcorr_eng(i,j)
            end do
c           Covariance matrix
            if (matform .eq. 1) then
c             Formatted output
              write (iout_anal(1),2001) (row(j),j=1,ns)
            else if (matform .eq. 2) then
c             Formatted output, one line per site
              write (iout_anal(1),2002) (row(j),j=1,ns)
            else
c             Unformatted (binary) output
              write (iout_anal(1)) (row(j),j=1,ns)
            end if
          end do
          if (igsanaltyp(1) .gt. 1) then
            do is1=1,ns
              do is2=is1+1,ns
                dipcorr_eng(is2,is1)=dipcorr_eng(is1,is2)
              end do
            end do
            call getmodes(iout,iwtemp,dipcorr_eng,rtemp1,
     -        rtemp2,ix_solv,iclst,ifirst,ilast,istemp,1,numrun,
     -        ivers_wsl,iop(24),ns,#MH)
          end if
        end if
        if (igsanaltyp(2) .gt. 0) then
c         Correlation matrix
c         do i=1,ns
c           do j=i+1,ns
c             sdsd=sqrt(dipcorr_eng(i,i)*dipcorr_eng(j,j))
c             if (sdsd .gt. 0.0)
c    -          dipcorr_eng(i,j)=dipcorr_eng(i,j)/sdsd
c           end do
c         end do
          do is1=1,ns
            do is2=is1+1,ns
              tr11=0.0
              tr22=0.0
              tr12=0.0
              do k=1,3
                dip1k=dipavij(k,is1,is2)/max0(1,nhb_ss(is1,is2))
                dip1kk=dipcorrii(k,is1,is2)/max0(1,nhb_ss(is1,is2))
                tr11=tr11+dip1kk-dip1k**2
                dip2k=dipavij(k,is2,is1)/max0(1,nhb_ss(is1,is2))
                dip2kk=dipcorrii(k,is2,is1)/max0(1,nhb_ss(is1,is2))
                tr22=tr22+dip2kk-dip2k**2
                tr12=tr12+dipcorrij(k,is1,is2)/max0(1,nhb_ss(is1,is2))-
     -            dip1k*dip2k
              end do
              dipcorr_eng(is1,is2)=0.0
              if (tr11*tr22 .gt. 0.0) then
                denom=sqrt(tr11*tr22)
                if (denom .gt. 0.0)dipcorr_eng(is1,is2)=tr12/denom
              end if
            end do
            rtemp1(is1)=dipcorr_eng(is1,is1)
          end do
          do i=1,ns
            dipcorr_eng(i,i)=1.d0
          end do
          do ii=1,ns
            i=is_orig(ii)
            do j=1,i-1
              row(ix_solv(j))=dipcorr_eng(j,i)
            end do
            do j=i,ns
              row(ix_solv(j))=dipcorr_eng(i,j)
            end do
            do j=1,ii-1
              if (row(j) .lt. -1.0) write(iout,1145) ii,j,'< -',row(j)
              if (row(j) .gt. 1.0) write (iout,1145) ii,j,'> ',row(j)
            end do
            if (matform .eq. 1) then
c             Correlation matrix, formatted output
              write (iout_anal(2),2001) (row(j),j=1,ns)
            else if (matform .eq. 2) then
c             Formatted output, one line per site
              write (iout_anal(2),2002) (row(j),j=1,ns)
            else
c             Unformatted (binary) output
              write (iout_anal(2)) (row(j),j=1,ns)
            end if
          end do
          if (igsanaltyp(2) .gt. 1) then
            do is1=1,ns
              do is2=is1+1,ns
                dipcorr_eng(is2,is1)=dipcorr_eng(is1,is2)
              end do
            end do
            call getmodes(iout,iwtemp,dipcorr_eng,rtemp1,
     -        rtemp2,ix_solv,iclst,ifirst,ilast,istemp,2,numrun,
     -        ivers_wsl,iop(24),ns,#MH)
          end if
        end if
        if (igsanaltyp(3) .gt. 0) then
          do i=1,ns
            do j=1,i-1
              dipcorr_eng(i,j)=dipcorr_eng(i,j)/max0(1,nhb_ss(j,i))
            end do
            dipcorr_eng(i,i)=sengslt(i)/nframeocc(i)
          end do
          do ii=1,ns
            i=is_orig(ii)
            do j=1,i-1
              row(ix_solv(j))=dipcorr_eng(i,j)
            end do
            do j=i,ns
              row(ix_solv(j))=dipcorr_eng(j,i)
            end do
            do j=1,ii-1
              if (row(j) .lt. -3.0) write (iout,1146) ii,j,row(j)
            end do
            if (matform .eq. 1) then
              write (iout_anal(3),2001) (row(j),j=1,ns)
            else if (matform .eq. 2) then
              write (iout_anal(3),2002) (row(j),j=1,ns)
            else
              write (iout_anal(3)) (row(j),j=1,ns)
            end if
          end do
          if (igsanaltyp(3) .gt. 1) then
            do is1=1,ns
              do is2=is1+1,ns
                dipcorr_eng(is1,is2)=dipcorr_eng(is2,is1)
              end do
            end do
            call getmodes(iout,iwtemp,dipcorr_eng,rtemp1,
     -        rtemp2,ix_solv,iclst,ifirst,ilast,istemp,3,numrun,
     -        ivers_wsl,iop(24),ns,#MH)
          end if
        end if
        if (igsanaltyp(4) .gt. 0) then
          do i=1,ns
            do j=1,i-1
              dipcorr_eng(i,j)=0.0
              if (nhb_ss(j,i) .gt. 0)
     -          dipcorr_eng(i,j)=float(nhb_ss(i,j))/float(nhb_ss(j,i))
            end do
          end do
          do ii=1,ns
            i=is_orig(ii)
            do j=1,i-1
              row(ix_solv(j))=dipcorr_eng(i,j)
            end do
            do j=i+1,ns
              row(ix_solv(j))=dipcorr_eng(j,i)
            end do
            row(ix_solv(i))=0.0
            if (nframeocc(i) .gt. 0)
     -        row(ix_solv(i))=float(nhbstsv(i))/float(nframeocc(i))
            if (matform .eq. 1) then
              write (iout_anal(4),2001) (row(j),j=1,ns)
            else if (matform .eq. 2) then
              write (iout_anal(4),2002) (row(j),j=1,ns)
            else
              write (iout_anal(4)) (row(j),j=1,ns)
            end if
          end do
          if (igsanaltyp(4) .gt. 1 .or. igsanaltyp(6) .gt. 0) then
            do is1=1,ns
              do is2=is1+1,ns
                dipcorr_eng(is1,is2)=dipcorr_eng(is2,is1)
              end do
              dipcorr_eng(is1,is1)=
     -          float(nhbstsv(is1))/float(nframeocc(is1))
              do is2=1,ns
                sv_sv_hb(is1,is2)=dipcorr_eng(is1,is2)
              end do
              sv_sv_hb(is1,is1)=0
            end do
            if (igsanaltyp(4) .gt. 1) call getmodes(iout,iwtemp,
     -        dipcorr_eng,rtemp1,rtemp2,ix_solv,iclst,ifirst,ilast,
     -        istemp,4,numrun,ivers_wsl,iop(24),ns,#MH)
          end if
          if (igsanaltyp(5) .gt. 0) then
            do is1=1,ns
              row(is1)=float(nframeocc(is1))/float(nframes)
            end do
            do is1=1,ns
              is1o=is_orig(is1)
              do is2=1,ns
                is2o=is_orig(is2)
                if (is1o .eq. is2o) then
                  dipcorr_eng(is1,is1)=row(is1o)
                else if (is1o .lt. is2o) then
                  ocr=iocccorr(is1o,is2o)/float(nframes)
                  if (igsanaltyp(5) .gt. 1)
     -               ocr=ocr/(row(is1o)*row(is2o))
                  if (is1 .lt. is2) dipcorr_eng(is1,is2)=ocr
                  if (is1 .gt. is2) dipcorr_eng(is2,is1)=ocr
                else
                  ocr= -iocccorr(is1o,is2o)/float(nframes)
                  if (igsanaltyp(5) .gt. 1) then
                    rnrm=row(is1o)+row(is2o)-2*row(is1o)*row(is2o)
                    if (rnrm .gt. 0.0) then
                      ocr=ocr/rnrm
                    else
                      ocr=0.0
                    end if
                  end if
                  if (is1 .gt. is2) dipcorr_eng(is1,is2)=ocr
                  if (is1 .lt. is2) dipcorr_eng(is2,is1)=ocr
                end if
              end do
            end do
            do is1=1,ns
              if (matform .eq. 1) then
                write (iout_anal(5),2001) (dipcorr_eng(is1,j),j=1,ns)
              else if (matform .eq. 2) then
                write (iout_anal(5),2002) (dipcorr_eng(is1,j),j=1,ns)
              else
                write (iout_anal(5)) (dipcorr_eng(is1,j),j=1,ns)
              end if
            end do
          end if
        end if
        if (igsanaltyp(7) .gt. 0) then
          do is=1,ns
            cvsite(is)=0.0
            if (njump(is) .gt. 0)
     -        cvsite(is)=float(nframeocc(is))/float(njump(is))
            write (iout,1154) is,float(nframeocc(is))/float(nframes),
     -        njump(is),cvsite(is)
          end do
        end if
      end if
      do i=1,5
        if (igsanaltyp(i) .gt. 0)
     -    call fileclose(iout_anal(i),0,iop(24),iout)
      end do
      if (iop(122) .gt. 0) then
        write (iout,1150)
        do is=1,ns
          occ=float(nframeocc(is_orig(is)))/float(nframes)
          write (iout,1144) is,is_orig(is),
     -      (csini(k,is_orig(is)),k=1,3),occ,
     -      corrcompname(icorrcomp),rtemp1(is_orig(is)),
     -      float(nhbstsv(is_orig(is)))/float(nframeocc(is_orig(is)))
        end do
      end if
      if (igsanaltyp(4) .gt. 0) then
c       ixkeep(ib) is the solute atom that forms the ib-th h bond in the list
        write (iout,1140) sqrt(rxhmax2),hbanglemin*rdtodg
        if (occmin_at .gt. 0.0) write (iout,1169) 'Sites',occmin_at
        maxhb=0
        call zeroiti(l4,0,nslt)
        do iaa=1,nhb_slt
          l4(ixkeep(iaa))=iaa
          if (nwhb(iaa) .gt. maxhb) maxhb=nwhb(iaa)
        end do
        do ia=1,nslt
          iaa=l4(ia)
          if (iaa .gt. 0) then
            isum=0
            do ja=1,nwhb(iaa)
              isum=isum+nacc_whb(ja,iaa)
            end do
            npr=0
            do ja=1,nwhb(iaa)
              occ=float(nacc_whb(ja,iaa))/float(nframes)
              if (occ .ge. occmin_at) then
                npr=npr+1
                row(npr)=occ
                l3(npr)=iwhb(ja,iaa)
              end if
            end do
            if (npr .gt. 0) write (iout,1163) labslt(2,ia),ia,
     -        labslt(1,ia),igrslt(ia),float(isum)/float(nframes),
     -        (l3(ja),row(ja),ja=1,npr)
          end if
        end do
        write (iout,1165) 'an atom',maxhb
        if (occmin_res .gt. 0.0) write (iout,1169) 'Residues',occmin_res
c       Concatenate by residue
        nlimerr=0
        do iaa=1,nhb_slt
c         write (iout,*) 'iaa=',iaa,' ixko=',ixkeep(iaa),
c    -      ' ixkn=',igrslt(ixkeep(iaa))
          ixkeep(iaa)=igrslt(ixkeep(iaa))
          do jaa=1,iaa-1
            if (ixkeep(iaa) .eq. ixkeep(jaa) .and.
     -          ixkeep(iaa) .gt. 0) then
c             Merge iaa and jaa
              do is=1,nwhb(iaa)
                ifound=0
                do js=1,nwhb(jaa)
                  if (iwhb(is,iaa) .eq. iwhb(js,jaa)) then
                    ifound=1
                    nacc_whb(js,jaa)=nacc_whb(js,jaa)+nacc_whb(is,iaa)
                  end if
                end do
                if (ifound .eq. 0) then
                  nwhb(jaa)=nwhb(jaa)+1
                  if (nwhb(jaa) .le. #NS) then
                    iwhb(nwhb(jaa),jaa)=iwhb(is,iaa)
                    nacc_whb(nwhb(jaa),jaa)=nacc_whb(is,iaa)
                  end if
                end if
              end do
              ixkeep(iaa)=0
              nwhb(iaa)=0
            end if
          end do
c         write (iout,*) 'iaa=',iaa,' ixfin=',ixkeep(iaa)
        end do
        maxhb=0
        call zeroiti(l3,0,nslt)
c       ixkeep(ir) is either 0 or the residue # of a h-bonding solute residue
        inperr0=inperr
        do iaa=1,nhb_slt
          if (nwhb(iaa) .gt. maxhb) maxhb=nwhb(iaa)
          if (nwhb(iaa) .gt. #NS) then
            write (iout,1162) 'residue',ixkeep(iaa),#NS
            inperr=inperr+1
            nwhb(iaa)=#NS
          end if
          if (ixkeep(iaa) .gt. 0) l3(ixkeep(iaa))=iaa
        end do
        if (inperr .gt. inperr0) write (iout,1187) maxhb
        nhb_res=0
        do ir=1,nslt
          if (l3(ir) .gt. 0) then
            nhb_res=nhb_res+1
            ixkeep(nhb_res)=ir
            l4(nhb_res)=l3(ir)
          end if
        end do
c       ixkeep now holds the sorted h-bonding residue numbers
c       l4(ir) now points to the original iaa for nwhb, nacc_whb and iwhb
        write (iout,*) 'Number of hydrogen-bonding residues=',nhb_res
        nresdel=0
        do irr=1,nhb_res
          iaa=l4(irr)
          ir=ixkeep(irr)
          isum=0
          do ja=1,nwhb(iaa)
            isum=isum+nacc_whb(ja,iaa)
          end do
          if (ifgrslt(ir) .lt. 1 .or. ifgrslt(ir) .gt. nslt)
     -      write (iout,*) 'INVALID ifgrslt=',ifgrslt(ir),' ir=',ir
          npr=0
          call zeroit(sv_st_hb(1,irr-nresdel),ns)
          do ja=1,nwhb(iaa)
            occ=float(nacc_whb(ja,iaa))/float(nframes)
            if (occ .ge. occmin_res) then
              npr=npr+1
              row(npr)=occ
              l3(npr)=iwhb(ja,iaa)
c             Create matrix column in the order the sv-sv h-bond mat was printed
              sv_st_hb(iwhb(ja,iaa),irr-nresdel)=occ
            end if
          end do
          if (npr .gt. 0) then
            write (iout,1166) labslt(1,max0(1,ifgrslt(ir))),ir,
     -        float(isum)/float(nframes),(l3(ja),row(ja),ja=1,npr)
            ixkeep(irr-nresdel)=ixkeep(irr)
          else
            nresdel=nresdel+1
          end if
        end do
        write (iout,1165) 'a residue',maxhb
        nhb_res=nhb_res-nresdel
        if (nresdel .gt. 0) write (iout,1171) nresdel,nhb_res
      end if
      if (igsanaltyp(6) .gt. 0) then
        call zeroit(st_st_hb,#MH*#MH)
        call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,0,nmolec,
     -    numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,uusfac,
     -    edgexyz,ieof,nconnfail)
        call indexit(njump,1,nhb_res,0)
        nscan=0
        nused=0
        do while (ieof .eq. 0 .and. nmc .lt. nmcmax)
          if (iskip1 .eq. 0) then
            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -        nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
          else
            iskip1=0
          end if
          if (ieof .eq. 0) then
            nscan=nscan+1
            call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -        nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,
     -        c_save,cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,
     -        nsmax,cplpar,cplpmin,cplpmax,nowater)
            if (ifnd .gt. 0) then
              if (matsort .gt. 1 .and. nused .eq. 0) then
                write (iout,1173) lxyz(iaxsort1)
                nnoca=0
                do irr=1,nhb_res
                  ir=ixkeep(irr)
                  ica=0
                  do ia=ifgrslt(ir),ilgrslt(ir)
                    if (labslt(2,ia) .eq. 'CA  ' .or.
     -                  labslt(2,ia) .eq. ' CA ') ica=ia
                  end do
                  if (ica .eq. 0) then
                    nnoca=nnoca+1
                    ica=ifgrslt(ir)
                  end if
                  frocc(irr)=c(iaxsort1,ica)
                end do
                if (nnoca .gt. 0) write (iout,1172) nnoca
                call mrgsrt(iout,njump,frocc,nhb_res,l3,l4,istemp,rtemp,
     -            #MH)
                do ir=1,nhb_res
                  it_orig(ir)=ixkeep(njump(ir))
                end do
                call trnsfi(ixkeep,it_orig,nhb_res)
              end if
              nused=nused+1
              do irr=1,nhb_res
                write (line(1:15),1184) nmc
                lline=15
                ir=ixkeep(irr)
                do ia=ifgrslt(ir),ilgrslt(ir)
                  ia_donacc=0
                  if (ianslt(ia) .eq. 1) then
c                   H on resid ir
                    if (qslt(ia) .gt. 0.2) then
                      ia_donacc=1
                    end if
                  else if (qslt(ia) .lt. -0.2) then
c                   Resid ir is the acceptor
                    ia_donacc=-1
                  end if
                  if (ia_donacc .ne. 0) then
                    do jrr=1,irr
                      jr=ixkeep(jrr)
                      do ja=ifgrslt(jr),ilgrslt(jr)
                        ja_donacc=0
                        if (ianslt(ja) .eq. 1) then
c                         H on resid jr
                          if (qslt(ja) .gt. 0.2) then
                            ja_donacc=1
                          end if
                        else if (qslt(ja) .lt. -0.2) then
c                         Resid jr is the acceptor
                          ja_donacc=-1
                        end if
                        ihb=0
                        if (ia_donacc .eq. -1 .and.
     -                      ja_donacc .eq. 1) then
                          call checkforhbond(c,ia,ja,ineig(1,ja),natoms,
     -                      rxhmax2,hbanglemin,ihb,ro2,hang,iout)
                        else if (ia_donacc .eq. 1 .and.
     -                           ja_donacc .eq. -1) then
                          call checkforhbond(c,ja,ia,ineig(1,ia),natoms,
     -                      rxhmax2,hbanglemin,ihb,ro2,hang,iout)
                        end if
                        if (ihb .gt. 0) then
                          if (idebug(168) .gt. 0 .and. irr .eq. jrr .or.
     -                      idebug(168) .gt. 1) then
                            if (ia_donacc .eq. -1) write (iout,7718)
     -                        nscan,ir,jr,ja,(c(k,ja),k=1,3),
     -                        ia,(c(k,ia),k=1,3),ineig(1,ia),
     -                        (c(k,ineig(1,ia)),k=1,3)
                            if (ia_donacc .eq. +1) write (iout,7718)
     -                        nscan,ir,jr,ia,(c(k,ia),k=1,3),
     -                        ja,(c(k,ja),k=1,3),ineig(1,ja),
     -                        (c(k,ineig(1,ja)),k=1,3)
                          end if
                          st_st_hb(irr,jrr)=st_st_hb(irr,jrr)+ihb
                          st_st_hb(jrr,irr)=st_st_hb(irr,jrr)
                          if (iop(123) .gt. 2) then
                            write (line(lline+1:lline+34),1185)
     -                        ir,ia,jr,ja
                            lline=lline+34
                            if (lline+34 .gt. 132) then
                              write (iout,1060) line(1:lline)
                              lline=15
                            end if
                          end if
                        end if
                      end do
                    end do
                  end if
                end do
                if (lline .gt. 15) write (iout,1060) line(1:lline)
              end do
            end if
          end if
        end do
        if (nconnfail .gt. 0) write (iout,1108) nconnfail
c       Self H bonds were counted twice - correct
        do ir=1,nhb_res
          st_st_hb(ir,ir)=st_st_hb(ir,ir)/2.0
        end do
        write (iout,*) 'Number of frames scanned=',nscan,' used=',nused
        write (iout,1169) 'Residue pairs',occmin_tt
        do irr=1,nhb_res
          do jrr=1,nhb_res
            occ=st_st_hb(irr,jrr)/float(nscan)
            if (occ .gt. occmin_tt) then
              st_st_hb(irr,jrr)=occ
            else
              st_st_hb(irr,jrr)=0.0
            end if
          end do
          npr=0
          do jrr=1,nhb_res
            if (st_st_hb(irr,jrr) .gt. 0.0) then
              npr=npr+1
              l3(npr)=jrr
            end if
          end do
          ir=ixkeep(irr)
          write (iout,1170) irr,labslt(1,max0(1,ifgrslt(ir))),ir,
     -      (labslt(1,max0(1,ifgrslt(ixkeep(l3(ipr))))),ixkeep(l3(ipr)),
     -      st_st_hb(irr,l3(ipr)),ipr=1,npr)
        end do
c       Write out the combined matrix
        if (matform .le. 2) write (iout_anal(6),2000) ns+nhb_res
        if (matform .eq. 3) write (iout_anal(6)) ns+nhb_res
        do ir=1,nhb_res
          it_orig(njump(ir))=ir
        end do
c       Create a combined solute-solvent adjacancy matrix
        do iss=1,ns
          is=is_orig(iss)
          do js=1,ns
            dipcorr_eng(iss,js)= sv_sv_hb(is,is_orig(js))
          end do
          do ir=1,nhb_res
            dipcorr_eng(iss,ns+ir)=sv_st_hb(is,njump(ir))
          end do
        end do
        do ir=1,nhb_res
          do is=1,ns
            dipcorr_eng(ns+ir,is)=sv_st_hb(is_orig(is),njump(ir))
          end do
          do jr=1,nhb_res
            dipcorr_eng(ns+ir,ns+jr)=st_st_hb(ir,jr)
          end do
        end do
        ndim=ns+nhb_res
        do i=1,ndim
          if (matform .eq. 1) then
            write (iout_anal(6),2001) (dipcorr_eng(i,j),j=1,ndim)
          else if (matform .eq. 2) then
            write (iout_anal(6),2002) (dipcorr_eng(i,j),j=1,ndim)
          else
            write (iout_anal(6)) (dipcorr_eng(i,j),j=1,ndim)
          end if
        end do
        call fileclose(iout_anal(6),0,iop(24),iout)
      end if
      if (idebug(166) .gt. 0) then
        write (iout,7715) 'IS_ORIG',(is_orig(is),is=1,ns)
        write (iout,7715) 'IX_SOLV',(ix_solv(is),is=1,ns)
      end if
      if (iop(123) .gt. 0) then
        nmclastr=0
        nmc=0
        nclmin=#MH
        nclmax=0
        nclsum=0
        nbtotsum=0
        nbtotmax=0
        nbtotmin=ns**2
        call zeroiti(iocccorr,0,#MH**2)
        call zeroiti(nmemacc,0,#MH)
        rewind iout_ws
        call opentraj(filenames(3),namlens(3),nslt,nslv,nsvp,c,0,nmolec,
     -    numsolv,natoms,nmcstart,cplpar,iskip1,numrec(3),1,uusfac,
     -    edgexyz,ieof,nconnfail)
        nframes=0
        nscan=0
        nused=0
        if (matsort .gt. 1) write (iout,1174)
        do while (ieof .eq. 0 .and. nmc .lt. nmcmax)
          if (iskip1 .eq. 0) then
            call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -        nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,
     -        nmchinc,incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
          else
            iskip1=0
          end if
          if (ieof .eq. 0) then
            nscan=nscan+1
            call useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -        nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,
     -        c_save,cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,
     -        nsmax,cplpar,cplpmin,cplpmax,nowater)
            if (ifnd .gt. 0) then
              nused=nused+1
              ns=-1
              read (iout_ws,1072,end=773) nmc_wsl,ns
              if (nmc .ne. nmc_wsl) then
                write (iout,1136) nmc,'wsl',nmc_wsl
                inperr=inperr+1
              end if
              if (ns .gt. 0) then
                read (iout_ws,1188,end=773) (iwofs(is),is=1,ns)
                nframes=nframes+1
                if (idebug(83) .gt. 1) then
                  write (iout,1134) nmc,nmolec,natoms
                  write (iout,1188) (iwofs(is),is=1,ns)
                  do ia=natoms+1,#NA
                    c(1,ia)=99999.9
                  end do
                end if
                call zeroiti(ifatocc,0,ns)
                do is=1,ns
                  if (iwofs(is) .gt. 0)
     -              ifatocc(is)=nslt+(iwofs(is)-1)*nslv+1
                  call zeroiti(nhb_ss(1,is),0,ns)
                end do
                nbtot=0
                do is1=1,ns
                  if (iop(123) .gt. 2) then
                    nhb_ww=0
                    nhb_wp=0
                  end if
                  iao1=ifatocc(is1)
                  if (iao1 .gt. 0) then
c                   Look for solvent-solvent H bonds
                    do is2=is1+1,ns
                      iao2=ifatocc(is2)
                      if (iao2 .gt. 0) then
                        call checkforhbond(c,iao1,iao2+1,iao2,natoms,
     -                    rxhmax2,hbanglemin,ihb,ro2,hang,iout)
                        if (ihb .eq. 0) call checkforhbond(c,iao2,
     -                    iao2+2,iao2,natoms,rxhmax2,hbanglemin,ihb,
     -                    ro2,hang,iout)
                        if (ihb .eq. 0) call checkforhbond(c,iao2,
     -                    iao1+1,iao1,natoms,rxhmax2,hbanglemin,ihb,
     -                    ro2,hang,iout)
                        if (ihb .eq. 0) call checkforhbond(c,iao2,
     -                    iao1+2,iao1,natoms,rxhmax2,hbanglemin,ihb,
     -                    ro2,hang,iout)
                        if (ihb .gt. 0) then
                          nhb_ss(is1,is2)=nhb_ss(is1,is2)+ihb
                          nbtot=nbtot+ihb
                          if (iop(123) .gt. 2) then
                            nhb_ww=nhb_ww+1
                            ihb_ww(nhb_ww)=is2
                          end if
                        end if
                        if (idebug(165) .gt. 0) write (78,8501) nframe,
     -                    ihb,is1,is2,iao1,iao2,(c(k,iao1),k=1,3),
     -                   (c(k,iao2),k=1,3)
8501                    format(' nf=',i6,' ihb=',i1,' is1,2=',2i5,
     -                    ' iao1,2=',2i7,' c1=',3f10.5,' c2=',3f10.5)
                      end if
                    end do
                    if (iop(123) .gt. 2) then
c                     Gather site-protein H bonds for frame by frame print
                      do irr=1,nhb_res
                        ir=ixkeep(irr)
                        do ia=ifgrslt(ir),ilgrslt(ir)
                          ihb=0
                          if (ianslt(ia) .eq. 1) then
c                           H on protein
                            if (qslt(ia) .gt. 0.2) then
                              ia_ng=ineig(1,ia)
                              iao=ifatocc(is1)
                              call checkforhbond(c,iao,ia,ia_ng,natoms,
     -                          rxhmax2,hbanglemin,ihb,ro2,hang,iout)
                              if (idebug(161) .gt. 0 .and. ihb .eq. 1)
     -                            write (iout,1148) nframes,is1,ia
                            end if
                          else if (qslt(ia) .lt. -0.2) then
c                           Protein is the acceptor
                            call checkforhbond(c,ia,iao+1,iao,
     -                        natoms,rxhmax2,hbanglemin,ihb,
     -                        ro2,hang,iout)
                            if (idebug(161) .gt. 0 .and. ihb .eq. 1)
     -                        write (iout,1148) nframes,is1,ia
                            if (ihb .eq. 0) call checkforhbond(c,
     -                        ia,iao+2,iao,natoms,rxhmax2,hbanglemin,
     -                        ihb,ro2,hang,iout)
                            if (idebug(161) .gt. 0 .and. ihb .eq. 1)
     -                        write (iout,1148) nframes,is1,ia
                          end if
                          if (ihb .eq. 1) then
                            nhb_wp=nhb_wp+1
                            ihb_wp(nhb_wp)=ir
                          end if
                        end do
                      end do
                    end if
                  end if
                  if (iop(123) .gt. 2) write (iout,1183) nmc,is1,nhb_ww,
     -              nhb_wp,(ihb_ww(i),i=1,nhb_ww),(ihb_wp(i),i=1,nhb_wp)
                end do
                nbtotsum=nbtotsum+nbtot
                if (nbtot .lt. nbtotmin) nbtotmin=nbtot
                if (nbtot .gt. nbtotmax) nbtotmax=nbtot
                call cluster_frames(ns,nhb_ss,sv_st_hb,st_st_hb,nhb_res,
     -            0,iocccorr,nofcls,ifirst,ilast,iclst,#MH,inperr,iout)
                do ic=1,ns
                  site_line(ic:ic)='.'
                end do
                icl=0
                do ic=1,nofcls
                  nmem=ilast(ic)-ifirst(ic)+1
                  if (iop(123) .gt. 1) then
                    if (ilast(ic) .gt. ifirst(ic)) then
                      if (icl .lt. 10) icl=icl+1
                      do i=ifirst(ic),ilast(ic)
                        site_line(ix_solv(iclst(i)):ix_solv(iclst(i)))=
     -                    digits(icl)
                      end do
                      call sort_clst(ixtemp,frocc,ix_solv,1,iclst,
     -                  ifirst(ic),ilast(ic),l3,l4,istemp,rtemp,#MH)
                      write (iout,1158) nframes,nmem,(iclst(i),
     -                  i=ifirst(ic),ilast(ic))
c                     write (iout,1158) nframes,nmem,(ix_solv(iclst(i)),
c    -                  i=ifirst(ic),ilast(ic))
                    end if
                  end if
                  nmemacc(nmem)=nmemacc(nmem)+1
                end do
                if (iop(123) .gt. 1)
     -            write (iout,1160) nframes,site_line(1:ns)
                nclsum=nclsum+nofcls
                if (idebug(164) .gt. 0)
     -            write (iout,7714) nframes,ns,nofcls,nbtot
                if (nofcls .lt. nclmin) nclmin=nofcls
                if (nofcls .gt. nclmax) nclmax=nofcls
              end if
            end if
          end if
          go to 774
773       write (iout,1131) nmc,ns,nscan,nused
774       continue
        end do
        if (nframes .gt. 0) then
          write (iout,1140) sqrt(rxhmax2),hbanglemin*rdtodg
          write (iout,1155) 'hydrogen-bonded pairs',
     -      float(nbtotsum)/float(nframes),nbtotmin,nbtotmax
          write (iout,1155) 'clusters',
     -      float(nclsum)/float(nframes),nclmin,nclmax
          do i=1,ns
            if (nmemacc(i) .gt. 0)
     -        write (iout,1159) i,float(nmemacc(i))/float(nframes)
          end do
          do is1=1,ns
            do is2=is1+1,ns
              iocccorr(is2,is1)=iocccorr(is1,is2)
            end do
          end do
          iout_hbf=iout_ws+1
          call fileopen(file,namlenf,filenames(44),namlens(44),44,0,
     -      numrun,1,3,0,iop(24),iversout,iout,iout_hbf,0)
          write (iout,1138) 'frame-averaged connectivity',nframes,
     -      filenames(44)(1:namlens(44))
          if (matsort .eq. 2) write (iout,1141) lxyz(iaxsort1)
          if (matsort .eq. 3) write (iout,1142) lxyz(iaxsort1)
          if (matsort .eq. 4) write (iout,1143) sortwgt,
     -      lxyz(iaxsort1),sortwgt,lxyz(iaxsort2),lxyz(iaxsort3)
          if (idebug(166) .gt. 0) then
            write (iout,7715) 'IS_ORIG',(is_orig(is),is=1,ns)
            write (iout,7715) 'IX_SOLV',(ix_solv(is),is=1,ns)
          end if
          call zeroiti(nhb_ss,0,#MH**2)
          do ii=1,ns
            i=is_orig(ii)
            do j=1,i-1
              row(ix_solv(j))=float(iocccorr(j,i))/float(nframes)
            end do
            do j=i,ns
              row(ix_solv(j))=float(iocccorr(i,j))/float(nframes)
            end do
c           row(ix_solv(i))=float(nhbstsv(i))/float(nframeocc(i))
            row(ix_solv(i))=0.0
            write (iout_hbf,2002) (row(j),j=1,ns)
            do is=1,ns
              if (row(is) .gt. hbmatmin) nhb_ss(ii,is)=1
            end do
          end do
          call fileclose(iout_hbf,0,iop(24),iout)
          if (igsanaltyp(6) .gt. 0) then
            write (iout,1180) 'Solvent site key:'
            is0=0
            do while (is0 .lt. ns)
              is1=is0+1
              is2=min0(ns,is0+20)
              write (iout,*)
              write (iout,1178) 'Sorted site #:  ',(is,is=is1,is2)
              write (iout,1178) 'Original site #:',
     -          (is_orig(is),is=is1,is2)
              is0=is2
            end do
            write (iout,1180) 'Solute residue key:'
            ir0=0
            do while (ir0 .lt. nhb_res)
              ir1=ir0+1
              ir2=min0(nhb_res,ir0+20)
              write (iout,*)
              write (iout,1178) 'Matrix index:    ',(ns+i,i=ir1,ir2)
              write (iout,1178) 'Sorted residue #:',(i,i=ir1,ir2)
              write (iout,1178) 'Actual residue #:',
     -          (ixkeep(i),i=ir1,ir2)
              write (iout,1179) 'Residue name:     ',
     -          (labslt(1,ifgrslt(ixkeep(i))),i=ir1,ir2)
              ir0=ir2
            end do
            write (iout,1176) 1
            ndim=ns+nhb_res
            call zeroiti(iocccorr,0,#MH*#MH)
            call plot_adj(iocccorr,dipcorr_eng,1,ndim,iout,inperr,#MH)
            do i=1,ndim
              do j=1,ndim
                dipcorrii(1,i,j)=dipcorr_eng(i,j)
                if (dipcorr_eng(i,j) .gt. 0) iocccorr(i,j)=1
              end do
            end do
            do npow=2,4
              do i=1,ndim
                do j=1,ndim
                  sum=0
                  do k=1,ndim
                     sum=sum+dipcorrii(1,i,k)*dipcorr_eng(k,j)
                  end do
                  dipcorrii(2,i,j)=sum
                end do
              end do
              do i=1,ndim
                do j=1,ndim
                  dipcorr_eng(i,j)=dipcorrii(2,i,j)
                end do
              end do
              write (iout,1176) npow
              call plot_adj(iocccorr,dipcorr_eng,1,ndim,iout,inperr,
     -          #MH)
              iout_anal(6)=iout_ws+6
              call fileopen(file,namlenf,filenames(41),namlens(41),
     -          41,0,numrun,ivers_wsl,3,ifmat,iop(24),iversout,iout,
     -          iout_anal(6),0)
              write (iout,1181) npow,filenames(41)(1:namlens(41))
              if (matform .le. 2) write (iout_anal(6),2000) ns+nhb_res
              if (matform .eq. 3) write (iout_anal(6)) ns+nhb_res
              do i=1,ndim
                if (matform .eq. 1) then
                  write (iout_anal(6),2001) (dipcorr_eng(i,j),j=1,ndim)
                else if (matform .eq. 2) then
                  write (iout_anal(6),2002) (dipcorr_eng(i,j),j=1,ndim)
                else
                  write (iout_anal(6)) (dipcorr_eng(i,j),j=1,ndim)
                end if
              end do
              call fileclose(iout_anal(6),0,iop(24),iout)
            end do
          end if
          call cluster_frames(ns,nhb_ss,sv_st_hb,st_st_hb,nhb_res,0,
     -      iocccorr,nofcls,ifirst,ilast,iclst,#MH,inperr,iout)
          write (iout,1156) hbmatmin,nofcls
          do ic=1,nofcls
            write (iout,1157) ' ',ic,ilast(ic)-ifirst(ic)+1
            call sort_clst(ixtemp,frocc,ix_solv,0,iclst,ifirst(ic),
     -        ilast(ic),l3,l4,istemp,rtemp,#MH)
            write (iout,1175)(iclst(i),i=ifirst(ic),ilast(ic))
          end do
          if (igsanaltyp(6) .eq. 0) then
            write (iout,1177)
            call plot_adj(iocccorr,dipcorr_eng,0,ns,iout,inperr,#MH)
          else
            do ir=1,nhb_res
              vt_lab(ns+ir)='T'
            end do
            call zeroiti(iocccorr,0,#MH*#MH)
            call cluster_frames(ns,nhb_ss,sv_st_hb,st_st_hb,nhb_res,1,
     -        iocccorr,nofcls,ifirst,ilast,iclst,#MH,inperr,iout)
            do ic=1,nofcls
              write (iout,1157) '-solute ',ic,ilast(ic)-ifirst(ic)+1
              nc=0
              call sort_clst(ixtemp,frocc,ix_solv,0,iclst,ifirst(ic),
     -          ilast(ic),l3,l4,istemp,rtemp,#MH)
              do ii=ifirst(ic),ilast(ic)
                i=iclst(ii)
                line(nc+1:nc+1)=vt_lab(i)
                if (i .le. ns) then
                  iorg=is_orig(i)
                else
                  i=i-ns
                  iorg=ixkeep(i)
                end if
                write (line(nc+2:nc+13),2003) i,iorg
                nc=nc+13
                if (ii .eq. ilast(ic) .or. nc .gt. 132-13) then
                  write (iout,1060) line(1:nc)
                  nc=0
                end if
              end do
            end do
            write (iout,1177)
            call plot_adj(iocccorr,dipcorr_eng,0,ndim,iout,inperr,#MH)
          end if
        end if
        call fileclose(iout_ws,0,iop(24),iout)
      end if
      nmc=nmclast
      call fileclose(iwtemp,1,iop(24),iout)
      return
2000  format('#',i4)
2001  format(5e13.5)
2002  format(#MHe13.5)
2003  format(i4,' (',i4,') ')
1000  format(/,' Generic solvent site calculation based on matchings ',
     -  'with the Hungarian method')
1001  format(' Initial site will be extracted from a configuration ',a)
1002  format(' ***** ERROR: history file contained no',a,
     -  'configurations to start with')
1003  format(' Number of sites requested in the initial guess=',i4)
1004  format(' Configurations containing fewer than ',i4,' or more ',
     -  'than ',i8,' solvents will be ignored')
1005  format(' Configurations with coupling parmeter smaller than ',
     -  f6.3,' or larger than',f6.3,' will be ignored')
1006  format(' ***** ERROR: the number of solvents  (',i4,') is less ',
     -  ' than the requested number of inital sites')
1007  format(' ***** ERROR: GENS CALC **** GETC has to be preceded by',
     -  ' the CNFG key')
1008  format(' After the first pass, the generic sites are updated',
     -  ' only at the end of each pass')
1009  format(' Generic sites are continually updated as new',
     -  ' configurations are fitted')
1010  format(' Matched pairs will have to be closer than ',f6.2,' A'/,
     -  ' Convergence criterion for matching iterations=',f8.4,' A',/,
     -  ' Site generation will stop when the total RMSD between ',
     -  'successive site estimates is less than ',f8.4,' A',/,
     -  ' If a solvent is farther than ',f8.3,' A from its assigned ',
     -  'site, it will be added as a new site',/,
     -  ' Maximum number of iterations over the simulation history=',i4)
1011  format(' Solvent-to-site information will be written to file ',a)
1012  format(' Clustered site',i5,' had no water assigned to it over ',
     -  'the whole trajectory')
1013  format(' Number of initial sites will be the number of solvents ',
     -  'in the starting configuration')
1014  format(' Initial configuration is taken from step number ',i10)
1015  format(' Number of solvent molecules in the initial ',
     -  'configuration=',i7)
1016  format(' Coupling parameter in the initial configuration=',f8.5)
1017  format(' GENSITECALC nused,ns,nw,nmc=',3i5,i10)
1018  format(' Iteration ',i4,' number of configurations used=',i6,
     -  ' RMSD/site between the last two site estimates=',f10.4,
     -  ' threshold=',f10.4,/,' Number of sites=',i4,
     -  ' Site RMSD min/max: ',f5.1,f5.1,' occupancy-weighted average=',
     -  f8.3,' Number of assignment switches=',i5,/)
1019  format(/,' +++++ Site generation converged in ',i4,' steps')
1020  format(' +++++ Maximum number of iterations (',i5,') has been ',
     -  'reached - generic site calculation has been stopped',/,
     -  5x,' The last RMSD change in the site estimates (',f8.4,') is ',
     -  'over the thereshold specified (',f8.4,')',/,
     -  ' ===== STRONG WARNING: generic site calculation is incomplete')
1021  format(' +++++ Iteration ',i4,' simulation step number ',i10,':',
     -  ' the matched site of solvent ',i4,' was too far (',f8.3,' A)',
     -  /,' - it has been added as a new site at ',3f10.4,
     -  ' New number of sites=',i5)
1022  format(' ***** ERROR: All structures were discarded. Last step ',
     -  'number (',i10,') < steps to discard (',i10,')')
1023  format(7x,'Last',i5,' solvents of the representative ',
     -  'configuration are not matched to any site')
1024  format(' +++++ Iteration ',i4,' simulation step number ',i10,':',
     -  ' all sites are matched ',/,' extra solvent ',i4,
     -  ' has been added as a new site at ',3f10.4,
     -  ' New number of sites=',i5)
1025  format(' New site estimates will be obtained as a mix: ',f7.4,
     -  ' * old + ',f7.4,' * new')
1026  format(' ----- WARNING: invalid ( > 0.999) mixing factor:',f8.4)
1027  format(' ***** ERROR: number of initial sites requested is ',
     -  'outside the range requested to consider')
1028  format(' ***** ERROR: maximum number of solvents allowed by the ',
     -  'key GENS exceeds the maximum number of solvents (#MO)',/,
     -  7x,'- increase #',a,' or reduce the inputted nsmax')
1029  format(' Closest distance (',f8.2,' A) occurs between sites',i5,
     -  ' (occ=',f6.4,') and',i5,' (occ=',f6.4,')')
1030  format(' GENSITECALC: ',a,i5,' iass=',i4,' c=',3f10.5)
1031  format(' >>>>> NOTE: Representative configuration is missing ',
     -  'matches for ',i4,' sites')
1032  format(7x,'>>>>>  Site could not be represented the composite ',
     -  'configuration',39x,' E(sv-sv)=',f11.2)
1034  format(' In the composite structure (cnear in the list below) ',
     -  'the largest distance between the sites and its solvent is ',
     -  f6.2,' A')
1035  format(' Sites with fractional occupancy < ',f7.5,' will be ',
     -  'dropped')
1036  format(' >>>>> Occupancy filter for repeat representative site ',
     -  'creation has to exceed the general occupancy filter (',f5.3,
     -  ')',/,' - second _gs_rep.pdb file will not be created')
1037  format(' Maximum number of ',a,'s to ',a,'=',i10)
1038  format(' Generic sites with CV (w.r.t. the solute) < ',f5.3,
     -  ' will be dropped')
1039  format(' Configurations read from the trajectory will be ',
     -  'filtered by CV:',/,5x,'Solvents with CV (w.r.t. the solute) <',
     -  f5.2,' will be dropped. Cutoff for CV calculation=',f6.2,' A')
1040  format(' ===== STRONG WARNING: composite configuration is ',
     -  'incomplete - ',i4,' sites are not represented')
1041  format(' Generic sites will be clustered using single-link ',
     -  'clustering with a neigbour cutoff of ',f6.2,' A')
1042  format(' Generic sites will be clustered using single-link ',
     -  'clustering aiming for,',i4,' clusters')
1043  format(' Clusters where the ',a,' of the members is ',a,
     -  f6.3,' will be ignored for entropy calculation')
1044  format(' Clusters where the number of members exceeds',i3,
     -  ' will be ignored for entropy calculation')
1045  format(' >>>>> OVERRIDE: generic sites will be clustered with ',
     -  'single-link clustering using a neighbor cutoff of',f5.1,' A',/,
     -  ' (This change is necessary for the STOW input generation)')
1046  format(8x,'crep=',3f9.4,' (solvent #',i5,') R(c,crep)=',f5.2,' A',
     -  ' # of contributing solvents=',i6,' E(st-sv)=',f11.2)
1047  format(' Site',i5,' c=',3f9.4,' frocc=',f6.4,' RMSD=',f6.2,' A',
     -  ' (',i3,'% within RMSD) CV(',a,')=',f6.4,' CV(',a,')=',f6.4,
     -  ' CV3=',f6.4)
1048  format(' Average number of waters will be rounded up to give ',
     -  ' the number of subregions if the fractional part is > ',f5.3)
1049  format(' ///// NOTE:',i5,' sites had zero occupancy')
1050  format(/,20x,' === Generic site generation results based on',i6,
     -  ' configurations ===',/)
1051  format(7x,'Representative configuration was chosen from a list ',
     -  'of',i3,' configurations with RMSD in the range [',f5.2,',',
     -  f5.2,']',/,7x,'The range of the number of sites missing ',
     -  'matches was [',i4,',',i4,']')
1052  format(7x,'cnear=',3f9.4,' R(c,cnear)=',f5.2,
     -  ' A (solvent #',i6,' at ',a,'=',i10,')',14x,' E(sv-sv)=',f11.2)
1053  format(' >',f4.1,1x,a)
1054  format(' The site closest to the solute heavy atoms is',i5,
     -  ' D=',f6.3,' A')
1055  format(' Average site occupancy=',f6.4,' SD=',f6.4,/,
     -  ' Average site RMSD=',f7.3,' SD=',f6.3,/,
     -  ' Correlation between occupancy and RMSD=',f6.4)
1056  format(' The best representative structure where all sites with ',
     -  'occupancy > ',f6.3,' will be also extracted')
1057  format(' Number of sites with occupancy > ',f6.3,'=',i4)
1058  format(' GENSITECALC',/,'   RMSDbest=',10f10.4,/,
     -  ' Nmissbest=',10i10,/,'   ',a,'best=',10i10)
1059  format(' Representative configuration (crep in the list below) ',
     -  'is at ',a,'=',i10,' containing ',i5,' solvents',/,
     -  7x,'Solvents in the representative configuration ',
     -  'are reordered according to the site they match',/,
     -  7x,'RMSD deviation (per site) between the generic sites and ',
     -  ' their representative solvents=',f6.2,' A')
1060  format(a)
1061  format(' Largest site deviation between the final and previous ',
     -  'iteration=',f6.4,' A',/,
     -  ' Maximum number of solvent or site neigbors found in the ',
     -  'matching algorithm=',i4,' (limit=#NH)')
1062  format(' >>>>> OVERRIDE: site convergence threshold is reduced ',
     -  'from',f7.4,' A to',f7.4,' A (the matching convergence ',
     -  'threshold')
1063  format(' ----- WARNING: no GENS calculation to continue')
1064  format(' Generic site calculation is restored from checkpoint ',
     -  'file ',a)
1065  format(' Generic sites are sorted in the order of ',a)
1066  format(' ----- WARNING: largest site change is more than 10 ',
     -  'times the mean site change threshold ',/,
     -  7x,'- you may want to continue the site generation with ',
     -  'tighter tolerances (see key GENS CCAL)')
1067  format(' Average number of solvents/configuration=',f8.2,
     -  ' SD=',f7.2,/,' Number of sites generated=',i5)
1068  format(' +++++ Site ',i5,' occupancy=',f6.3,' is dropped from ',
     -  'the ',a,' configuration')
1069  format(' Site CV wrt the solute=',f6.4)
1070  format(1x,i6,' sites will be also sorted by RMSD',/)
1071  format(' Nmc=',i10,' ns=',i5,' iwofs:')
1072  format(5x,i10,4x,i5)
1073  format(' Average number of solvent molecules filtered out=',f8.1)
1074  format(8x,' Number of completed iterations=',i4,/,
     -  8x,' RMSD/site between the last two site estimates=',f8.5,' A')
1075  format(' No structure was found where all sites with occupancy ',
     -  'greater than ',f6.3,' are present')
1076  format(' Number of structures where all sites with occupancy ',
     -  'greater than ',f6.3,' are present=',i5)
1078  format(' GENSITECALC ',a,' niter=',i4,' nmc=',i9,' is=',i4,
     -  ' rij2:',/,(20f6.1))
1079  format(' Sites whose distance to the nearest solute atom is > ',
     -  f5.2,' A will be dropped')
1080  format(7x,'Site is dropped due to ',a,' :')
1081  format(' Number of sites has been reduced to ',i4,' (from ',i4,
     -  ') after occupancy, CV and solute-site distance filter')
1082  format(' Smallest and largest number of solvents in the ',
     -  'history file=',2i6)
1083  format(' Smallest and largest coupling parameter in the ',
     -  'history file=',2f7.5)
1084  format(' Finished scanning trajectory at ',a,'=',i10,
     -  ' configurations',a,' Number of stuctures used=',i6)
1085  format(' The solute has not been changed')
1086  format(/,' Averages over proximal solute types:')
1087  format(' Proximal ',a,' (',a,i6,',',a,i5,') (D=',f5.2,' A) ')
1088  format(7x,'Convergence=',f6.4,' A',13x)
1089  format(' PF',i4,1x,a,' <frocc>=',f6.4,' <RMSD>=',f5.2,
     -  ' <E(site)>=',f8.3,' <CV(dip)>=',f6.4,' <CV(H-H)>=',f6.4,
     -  ' <CV3>=',f6.4,' Nsite=',i4)
1090  format(' ===== STRONG WARNING: maximum number of iterations ',
     -  'given after restart (',i5,') does not exceed the number of ',
     -  'iterations completed')
1091  format(' ***** PROGRAM ERROR: nused and nusedrep differ:',2i9)
1092  format(' ===== STRONG WARNING: number of structures used after ',
     -  'restart (',i6,') differ from the previously used number (',i6,
     -  ')')
1093  format(' ***** ERROR: no usable structure was found on the ',
     -  'trajectory file')
1094  format(' ***** ERROR: history file with partial solute ',
     -  'TRAJ **** **** MUST) can not be used for inital site ',
     -  'generation')
1095  format(' ***** PROGRAM ERROR: Did not find solvent to add')
1096  format(' Solute coordinates printed are from ',a,i10)
1097  format(' The largest RMSD from the initial solute structure=',
     -  f6.1,' A at ',a,i10,/,' The largest deviation from the initial',
     -  ' solute structure=',f6.1,' (solute atom',i6,' at ',a,i10,')',/,
     -  ' Maximum solute COM change: <',f6.2,',',f6.2,',',f6.2,'>' )
1098  format(' ----- WARNING: the solute',a,'changes noticeably')
1099  format(' ===== STRONG WARNING: the solute',a,
     -  'changes way too much')
1100  format('Eng=',f8.2)
1101  format(i4,' ix,isxprox=',i4,i5,' rdevsw,rdiffcnv,bfac2,cvsite=',
     -  4f8.3,' cscurr=',3f10.5)
1102  format(' Proximity of solute atom',i6,' residue',i5,
     -  ' (',a,',',a,') total occupancy=',f8.4,
     -  ' total solute-solvent energy=',f8.2,' kcal/mol')
1103  format(1x,a,i5,' Atom',i6,' (',a4,1x,a4,') occ=',f8.4,
     -  ' <E(slt-slv)>=',f10.2,' <E(slv-slv)>=',f7.2,
     -  ' <E>=',f7.2,' kc/mol')
1104  format(1x,a,i5,16x,' (',a4,') occ=',f8.4,
     -  ' <E(slt-slv)>=',f10.2,' <E(slv-slv)>=',f7.2,
     -  ' <E>=',f7.2,' kc/mol')
1105  format(/,25x,' === Occupancy and energy sums over proximity ',
     -    'regions and ',a,' ===')
1106  format(' ///// NOTE: average orientations may be incorrect for ',
     -  'symmetric molecules')
1107  format(7x,'>>>>>  Site is missing from the representative ',
     -  'configuration # of contributing solvents=',i6)
1108  format(' A total of ',i6,' structures had suspicious distances')
1109  format(' Site',i5,' c=',3f9.4,' frocc=',f6.4,' RMSD=',f6.2,' A',
     -  ' CV=',f6.4)
1110  format(' ===== STRONG WARNING: sites',i5,' and',i5,
     -  ' are identical')
1111  format(' Solvents will be rematched to the filtered sites only.',
     -  5x,'Solvents farther from their site than ',f5.2,' A will be ',
     -  'dropped')
1112  format(' is_orig:',/,(25i5))
1113  format(' ///// NOTE: count difference for site ',i4,' original ',
     -  'occpancy count=',i6,' occupancy count after rematch=',i6)
1114  format(' ///// NOTE: occupancy count after rematch differed for',
     -  i4,' sites. Average count difference=',f6.1,/,' Such ',
     -  'differences can usually eliminated or reduced with stricter ',
     -  'convergence criteria (rmateps,epsgsite) for the site ',
     -  'generation')
1115  format(' Sites with site RMSD > ',f7.5,' A will be dropped')
1116  format(' ***** PROGRAM ERROR: nmc=',i9,' is_orig(',i5,')=',i9)
1117  format(' ***** ERROR: key ',a4, ' requires a representative ',
     -  'configuration read with the key CNFG READ')
1118  format(' Solute atoms will',a,'be written on the generic site ',
     -  'file',a)
1119  format(i9,i6,f14.3,f13.3,f13.3,f12.4,f12.3,f13.3,f14.3,1x,a,i6,
     -  ',',a,i5,a)
1120  format(/,' Energy calculations repeated over ',i6,' frames:')
1121  format(' Cluster',i3,' centroid:',3f9.4,'  sums:',f12.4,f12.3,
     -  f13.3,f14.3)
c1122  format(' nf=',i6,' ic=',i3,' ia,ij=',2i5,' isa,jsa,ixis=',2i4,i2,
c     -  ' eww=',f10.3,' rij=',f6.1)
c1123  format(' nf=',i6,' mem:',10(i4,i6))
1124  format(' ///// NOTE: Updated solvent-to-site information are ',
     -  'written to file ',a)
1125  format(6x,'Sum of Cluster sums:',29x,f12.4,f12.3,f13.3,f14.3,
     -  ' kcal/mol',//,'   ///// NOTE: E(ww/clst) is the interaction ',
     -  ' with the waters in the same cluster; E(ww) is the ',
     -  'interaction with all the rest',/,
     -  9x,'Interactions with waters not assigned to one of these ',
     -  'sites are ignored',/,
     -  9x,'The values for  E(ww) and E(ww/clst) cluster sums are ',
     -  'divided by two to avoid double countig')
1126  format(' nmc=',i10,' einnbo=',e12.5,' es14o=',e12.5,
     -  ' estor,=',e12.5,' ettnbo,=',e12.5)
1127  format(' Total solute energy=',e12.5,' SD=',e10.2,' kcal/mol',/,
     -  ' Solute intermolcular energy=',e12.5,' SD=',e10.2,/,
     -  ' Solute intramolecular energy=',e12.5,' SD=',e10.2,/,
     -  ' Solute intramolecular 1-4 energy=',e12.5,' SD=',e10.2,/,
     -  ' Solute torsion energy=',e12.5,' SD=',e10.2)
1128  format('   Cluster Site   <E(slt-slv)>       <Eww>    ',
     o  '<E(ww/clst)>    occ    o*<E(slt-slv)>  o*<Eww>   ',
     -  'o*<E(ww/clst)>  Proximal solute atom')
1129  format(' ***** ERROR: flexible solute requires configuration ',
     -  'input with the CNF* key')
1130  format(a,'Sites closer than',f6.2,' A will be merged together',
     -  /,' Maximum occupancy sum for paired sites=',f5.2)
1131  format(' ***** PROGRAM ERROR: EOF on assignment list file - ',
     -  ' nmc=',i10,' ns=',i8,' nscan=',i8)
1132  format(' nmc=',i8,' nframes=',i5,' isa=',i5,' iwofs=',i5,' crm=',
     -  3f10.5)
1133  format(' nmc=',i8,' isx,js=',2i5,' eij=',e12.5,
     -  ' crm(isx)=',3f10.4,' crm(js)=',3f10.5)
1134  format(' nmc,nmolec,natoms=',3i10)
1135  format(a,'The distance between the COM of the input structure ',
     -  'and the COM trajectory average=',f6.1,' A')
1136  format(' ***** ERROR: Stepnumber on trajectory (',i10,
     -  ') is different from the stepnumber on the .',a,
     -  ' file (',i10,')')
1137  format(' No ',a,' will be performed')
1138  format(' Water ',a,' matrix over',i6,' frames will ',
     -  'be written to file ',a)
1139  format(' ----- WARNING: solvent is assumed to be water with ',
     -  'atoms in the order of OHH')
1140  format(/,' O ... H distance threshold for hydrogen bond=',f4.1,
     -  ' A',/,' O...H-O angle minimum for hydrogen bond=',f5.1,' deg')
1141  format(' Each matrix will be sorted by the site ',a,
     -  ' coordinates')
1142  format(' Each matrix will be sorted by the site-origin ',
     -  'distance * sign of the ',a,' coordinate')
1143  format(' Each matrix will be sorted by ',f5.1,'^2*c(',a,')+',
     -  f5.1,'*c(',a,')+c(',a,')')
1144  format(i5,' (Original site #:',i4,') coord:',3f10.5,' Occ=',f5.3,
     -  1x,a,' variance:',e12.5,' <nHB(w-slt)/(occ)>=',f6.2)
1145  format(' ///// NOTE: correlation matrix element (',i5,',',i5,') ',
     -  a,'1.0 :',f10.5)
1146  format(' Interaction energy below -3 kcal/mol (',i5,',',i5,');',
     -  f10.5)
1147  format(' Covariances will be calculated on the water ',a)
1148  format(' H bond frame #=',i8,' site#=',i4,' solute atom #=',i6)
1149  format(' Occupancy correlations will be normalized with the ',
     -  'corresponding random probabilities')
1150  format(/,' The generic sites in the order the matrices are ',
     -  'printed:')
1151  format(i5,' rtemp1=',f10.3,' c=',3f8.3)
1152  format(' Average # of frames between jumps will be calculated ',
     -  'over ',i6,' frames')
1153  format(' Original solvent numbers will be read from file ',a)
1154  format(' Site ',i6,' occupancy=',f6.4,' Njump=',i5,
     -  ' avg # of frames per jump=',f8.1)
1155  format(' Average number of ',a,'/frame=',f6.2,
     -  ' range= [',i4,',',i4,']')
1156  format(' Site clusters based on frame averaged connectivity ',
     -  '(minimum fraction for keeping connection=',f6.3,')',/,
     -  ' Number of clusters=',i4)
1157  format(' Solvent',a,'cluster ',i4,' #of ',i4,' sites; members:')
1158  format(' NF=',i6,' Solvent cluster of ',i4,' sites; members:',
     -  #MHi5)
1159  format(' Average # of ',i4,'-clusters=',f8.5)
1160  format(' NF=',i6,' Cluster membership:',a)
1161  format(' ***** ERROR: number of hydrogen-bonding solute atoms ',
     -  'exceeds #MH - increase # M H and recompile')
1162  format(' **** ERROR: number of sites forming hydrogen bond to ',
     -  'solute ',a,i6,' exceeds ',i3,' - increase the dimension of ',
     -  'arrays iwhb and nacc_whb and recompile')
1163  format(' Solute atom: (',a,i6,',',a,i5,') Total occ=',f6.3,
     -  ' H-bond partners (site, occ):',30(i5,f6.3))
1164  format(' Analysis stopped at frame # ',i6)
1165  format(' Maximum # of sites hydrogen-bonded to ',a,'=',i3)
1166  format(' Solute residue: (',a,i5,') Total occ=',f6.3,
     -  ' H-bond partners (site, occ):',30(i5,f6.3))
1167  format(' Solute ',a,' - solvent hydrogen bonds with occupancy ',
     - '< ',f7.4,' will be filtered out')
1168  format(' Hydrogen-bond matrix including solute-solvent and ',
     -  'solute-solute interactions will also be created')
1169  format(1x,a,' with occupancy < ',f7.4,' will not be listed')
1170  format(' Solute-solute H bond with residue #',i4,' (',a,i6,'):',/,
     - (5(' (',a,i6,') occ:',f6.3)))
1171  format(' Occupancy filtering removed ',i5,' residues ',
     -  '- number of residues left=',i5)
1172  format(' ///// NOTE: ',i4,' residues had no CA atom - first atom',
     -  ' was used for sorting')
1173  format(' Solute residues will be sorted by the ',a,'-coordinate',
     -  ' of the CA or first atom')
1174  format(' ///// NOTE: solvent numbers refer to the solvents after',
     -  ' sorting')
1175  format(25i5)
1176  format(/,' The ',i1,'-edge connected adjacency matrix:')
1177  format(/,' The cluster-connected adjacency matrix:')
1178  format(1x,a,20i5)
1179  format(1x,a,20(1x,a4))
1180  format(/,1x,a)
1181  format(' The ',i1,'-th power of the combined occupancy matrix',
     -  'is written to ',a)
1182  format(' ///// NOTE: no solute heavy atom within 10 A')
1183  format('HBD F',i9,' is=',i6,' nww=',i2,' nwp=',i2,40i6)
1184  format('HBD F',i9,1x)
1185  format('R',i5,' A',i7,' - R',i5,' A',i7,1x)
1186  format(' Input file for entropy calculation with the program ',
     -  'STOW will also be prepared')
1187  format(' ///// NOTE: Concatenation is truncated since the ',
     -  'minimum # N L value is',i3)
1188  format(25i5)
6500  format(' SUUC: Solute-solute interactions are calculated ',
     -  'without PBC')
6510  format(' SUUC: Solute-solute interactions are calculated using ',
     -  'minimum image convention based on ',a,' center distances')
6511  format(' SUUC: Solute-solute interactions are limited to ',a,
     -  ' center distances of ',f6.2,' A')
7711  format(' nmc=',i9,' nmolecw=',i6,' nsolvorig=',i8,/(20i6))
7712  format(1x,a,' iwofs ns=',i6,/(20i6))
7713  format(' l4 nw_orig=',i6,/,(20i6))
7714  format(' GABF nframes=',i6,' nsites=',i5,' nofcls=',i4,
     -  ' nbtot=',i9)
7715  format(1x,a,':',/(25i5))
7716  format(' Frame#:',i6,' ia,isa=',2i6,' isa/ia_save=',2i4,
     -  ' nwhb=',i4,' nacc=',i6,' iwhb=',20i4)
7718  format(' NS=',i6,' ir1=',i5,' ir2=',i5,' Acc:',i6,3f8.2,
     -  ' DonH:',i6,3f8.2,' DonX:',i6,3f8.2)
      end
      subroutine rematch(ns,nw,nslt,nslv,islvrep,csorig,cscurr,c,
     -  rcutxst,r2sum,r2max,nmat,nmiter,niter,rmateps,nmc,maxmaxng,
     -  rmaxmatch,rmaxrematch,iop5,nsorig,isorig,irematchtyp,noreorder,
     -  itemp,maxsite,maxat)
c#    MMC routine 486/a lstmod: 07/24/10
c*****Redo the match on the original sites, transform iwof to filtered sites
      dimension csorig(3,maxsite),cscurr(3,maxsite),c(3,maxat),
     -  isorig(maxsite),itemp(maxsite)
      common /hung/ rsw2(#MH,#MO),iwofs(#MH),isofw(#MO),
     -  frocc1(#MO),frocc2(#MO),bfac1(#MO),bfac2(#MO)
c     print *,'REMATCH irematchtyp=',irematchtyp,' noreorder=',noreorder
      if (irematchtyp .eq. 1) then
c       Just match to the current sites
        call rij2mat(1,ns,1,nw,0,nslt,1,nslv,1,islvrep,cscurr,c,iop5,
     -    1,1,0.0,maxsite,maxat)
        nsmatch=ns
        rmax=rmaxmatch
        if (rmaxrematch .gt. 0.0) rmax=rmaxrematch
        call minmat(nsmatch,nw,rcutxst,rmax,r2sum,r2max,nmat,nmiter,
     -    niter,rmateps,nmc,maxmaxng,1)
      else
        call rij2mat(1,nsorig,1,nw,0,nslt,1,nslv,1,islvrep,csorig,c,
     -    iop5,1,1,0.0,maxsite,maxat)
        nsmatch=nsorig
        call minmat(nsmatch,nw,rcutxst,rmaxmatch,r2sum,r2max,nmat,
     -    nmiter,niter,rmateps,nmc,maxmaxng,1)
        call zeroiti(itemp,0,nsorig)
        if (noreorder .eq. 0) then
c         Now reorder iwofs to reflect the filtered sites
          do is=1,ns
            if (iwofs(isorig(is)) .gt. 0) itemp(is)=iwofs(isorig(is))
          end do
          call trnsfi(iwofs,itemp,ns)
        end if
      end if
      return
      end
      subroutine getbeststruct(filename,namelen,nslt,nslv,islvrep,
     -  keycol,nmcstart,nmc,numrunh,nhstvers,cplpar,uusfac,ihist,
     -  inpt,iout,nwarn,nwwarn,inperr,nconnfail,lmnst,nmcbest,ns,nw,
     -  nmiss,nmolecbest,cscurr,c,crep,cvfilt_traj,cvfilt_trajcut,
     -  iwofs,isofw,iop5,rmateps,rcutxst,nowater,index)
c#    MMC routine 487 lstmod: 06/14/10
c*****Get the nmcbest-th structure
      real*8 uusfac
      character*80 filename,filename1
      dimension c(3,#NA),crep(3,#NA),cscurr(3,#MH),
     -  iwofs(#MH),isofw(#MH),index(#MH),keycol(2)
      common /param/ edgexyz(3),edge2xyz(3),
     -  vol,volin,rinscr,rinscs,rcirc,rdmx,cutslv,ctslvs,cutslt,ctslts,
     -  cutuu,cutuus,cutexp,ctexps,rccomp,rccmp2,fcintra,dielc,dielcau,
     -  esf14,vdwf14,vsltgr,pmvslt,pmvslv,wmslv,wmslt,rnshll,rboxmax,
     -  rpxidlim,rpxidlim2,isltsmpl,isltmove,idsvfst,nmccd,nmccgd,
     -  numsolv,nsolvfix,nmolec,nmol3,natoms
      common /option/ iop(200),idebug(200)
      call opentraj(filename,namelen,nslt,nslv,nsvp,c,0,nmolec,numsolv,
     -  natoms,nmcstart,cplpar,iskip1,lmnst,1,uusfac,edgexyz,ieof,
     -  nconnfail)
      do while (ieof .eq. 0 .and. nmc .lt. nmcbest)
        if (iskip1 .eq. 0) then
          call getcnfh(ihist,inpt,iout,nwarn,nwwarn,inperr,ieof,
     -      nconnfail,nmc,nidmc,niaccp,ndaccp,numrunh,nhstvers,nmchinc,
     -      incrun,i0,c,0,lmnst,uusfac,0,nsvp,0)
        else
          iskip1=0
        end if
      end do
      if (cvfilt_traj .gt. 0.0)
     -  call filter_traj(nmolec,nslt,nslv,islvrep,natoms,index,
     -    nmolecsave,c,crep,cvfilt_traj,cvfilt_trajcut,ndel,nowater,
     -    iout,#MH)
      if (ieof .gt. 0 .or. nmc .ne. nmcbest) then
        write (iout,1001) nmcbest,nmc
        inperr=inperr+1
      end if
      if (idebug(92) .gt. 0)
     -  call savepdb('PDBw',keycol,iuxx,-iout,1,nslt,nslv,c,nmolec-1,
     -    0,0,0,filename1,namlen1,nmc,2,filename,namelen,numrunh,
     -    nhstvers,3,inperr,nwarn,nwwarn,18,0,nlwr,0,1,#NA)
      nmolecbest=nmolec
      nw=nmolec-1
      natoms=nslt+nw*nslv
      call rij2mat(1,ns,1,nw,0,nslt,1,nslv,1,islvrep,cscurr,c,iop5,
     -  1,1,0.0,#MH,#NA)
      call minmat(ns,nw,rcutxst,0.0,r2sum,r2max,nmat,nmiter,niter,
     -  rmateps,nmc,maxmaxng,1)
      call trnsfr(crep,c,3*nslt)
c     Check iwofs,isofw for duplicates
      do is=2,ns
        if (iwofs(is) .ne. 0) then
          do js=1,is-1
            if (iwofs(is) .eq. iwofs(js)) then
              write (iout,1000) 'iwofs',ns,is,js,iwofs(is)
              inperr=inperr+1
            end if
          end do
        end if
      end do
      do iw=2,nw
        if (isofw(iw) .ne. 0) then
          do jw=1,iw-1
            if (isofw(iw) .eq. isofw(jw)) then
              write (iout,1000) 'isofw',nw,iw,jw,isofw(iw)
              inperr=inperr+1
            end if
          end do
        end if
      end do
c     Check if assignment is mutual
      do is=1,ns
        if (iwofs(is) .ne. 0) then
          if (isofw(iwofs(is)) .ne. is) then
            write (iout,1003) is,iwofs(is),isofw(iwofs(is)),is
            inperr=inperr+1
          end if
        end if
      end do
      do iw=1,nw
        if (isofw(iw) .ne. 0) then
          if (iwofs(isofw(iw)) .ne. iw) then
            write (iout,1004) iw,isofw(iw),iwofs(isofw(iw)),iw
            inperr=inperr+1
          end if
        end if
      end do
      nmiss=0
      do is=1,ns
        if (iwofs(is) .ne. 0) then
          call trnsfr(crep(1,nslt+(is-nmiss-1)*nslv+1),
     -      c(1,nslt+(iwofs(is)-1)*nslv+1),3*nslv)
        else
          nmiss=nmiss+1
        end if
      end do
      nfound=ns-nmiss
      nsadd=0
      do iw=1,nw
        if (isofw(iw) .eq. 0) then
          call trnsfr(crep(1,nslt+(nfound+nsadd)*nslv+1),
     -      c(1,nslt+(iw-1)*nslv+1),3*nslv)
          nsadd=nsadd+1
        end if
      end do
      call trnsfi(index,iwofs,ns)
      call zeroiti(isofw,1,nw)
      call zeroiti(iwofs,1,ns)
      nmiss=0
      do is=1,ns
        if (index(is) .ne. 0) then
          iwofs(is)=is-nmiss
          isofw(is-nmiss)=is
        else
          nmiss=nmiss+1
        end if
      end do
      write (iout,1002) nmc,nw,nmiss,nsadd
      return
1000  format(' ***** PROGRAM ERROR: duplicate in ',a,', ns=',i5,
     -  ' is,js=',2i5,' iwofs=',i5)
1001  format(' ***** PROGRAM ERROR: could not find the representative ',
     -  'structure at Nmc=',i10,' - structure at Nmc=',i10,' will be ',
     -  'used')
1002  format(' Representative structure extracted at Nmc=',i10,/,
     -  6x,'It has',i7,' solvents',i5,' sites are not represented and',
     -  i8,' solvents are not assigned to any site.')
1003  format(' ***** PROGRAM ERROR: the solvent assigned to site ',i5,
     -  ' (',i5,') is assigned to site ',i5,' (instead of ',i5,')')
1004  format(' ***** PROGRAM ERROR: the site assigned to solvent ',i5,
     -  ' (',i5,') is assigned to solvent ',i5,' (instead of ',i5,')')
      end
      subroutine sort_clst(ixtemp,r,ix,iuseix,iclst,ifc,ilc,
     -  it1,it2,it3,t,maxmem)
c     Sort the members on an index cluster
c#    MMC routine 487/a lstmod: 05/20/14
      dimension ixtemp(maxmem),r(maxmem),ix(maxmem),iclst(maxmem),
     -  it1(maxmem),it2(maxmem),it3(maxmem),t(maxmem)
      nmem=ilc-ifc+1
      if (iuseix .eq. 1) then
        do i=ifc,ilc
          r(i-ifc+1)=ix(iclst(i))
          ixtemp(i)=1
        end do
      else
        do i=ifc,ilc
          r(i-ifc+1)=iclst(i)
        end do
      end if
      nmem=ilc-ifc+1
      call mrgsrt(iout,ixtemp,r,nmem,it1,it2,it3,t,#MH)
      do i=ifc,ilc
        iclst(i)=r(i-ifc+1)
      end do
      return
      end
      subroutine bin10(f,n,fmin,fmax,fmaxout,title,ntitle,iout)
c*****Calculate distribution of values in f over 10 bins
c#    MMC routine 488 lstmod: 07/12/02
      dimension f(n)
      character*(*) title
      dimension nbin(10)
      call zeroiti(nbin,0,10)
      if (fmin .ge. fmax) then
c       Establish limits
        fmn=f(1)
        fmx=f(1)
        do i=2,n
          if (fmn .gt. f(i)) fmn=f(i)
          if (fmx .lt. f(i)) fmx=f(i)
        end do
      else
        fmn=fmin
        fmx=fmax
      end if
      denom=fmx-fmn
      if (denom .eq. 0.0) denom=1.0
      do i=1,n
        ix=10.0*(f(i)-fmn)/denom+1
        if (ix .lt. 1) ix=1
        if (ix .gt. 10) ix=10
        nbin(ix)=nbin(ix)+1
      end do
      write (iout,1000) title(1:ntitle),fmn,fmx,nbin
      fmaxout=fmx
      return
1000  format(' Distribution of ',a,' in the range of ',f10.5,' - ',
     -  f10.5,' :',10i5)
      end
      subroutine reorder(ra,ia,ix,n,temp,itemp,ir)
c#    MMC routine 489 lstmod: 09/10/04
      dimension ra(n),ia(n),ix(n),temp(n),itemp(n)
c*****Reorder the array ra (ir=1) or ia (ir=2) according  to ix
      if (ir .eq. 1) then
        do i=1,n
          temp(i)=ra(ix(i))
        end do
        call trnsfr(ra,temp,n)
      else
        do i=1,n
          itemp(i)=ia(ix(i))
        end do
        call trnsfi(ia,itemp,n)
      end if
      return
      end
      subroutine savesites(ist,iopresfor,c,cs,csltr,ns,nslt,nslv,natoms,
     -  nmclast,iout,numrun,inperr,nwarn,nwwarn,keycol,frocc,rdevsw,
     -  filename,namlenf,tfilename,namlentf,iop24,sltdmax,iwslt,iatnam,
     -  ianslt,qslt,igrslt,iclustno,ianslv,mcmd,nmcbest,froccmin,
     -  isorttyp,filename1,namlen1,maxat)
c#    MMC routine 490 lstmod: 07/19/12
      character*3 mcmd
      character*4 iatnam(99)
      character*80 filename,tfilename,filename1
      dimension c(3,maxat),csltr(3,nslt),cs(3,ns),frocc(ns),rdevsw(ns),
     -  ianslt(nslt),qslt(nslt),igrslt(nslt),ianslv(nslv),
     -  iclustno(maxat),keycol(2)
c*****Write out a generic site related file
      character*60 configs(26)
      common /confignames/ configs,lconfigs(26)
      character*44 sitesortlab
      common /sitesort/ sitesortlab(6),lsitesortlab(6)
      dimension iformtyp(3),msgno(8)
      character*3 ext(8),gstyp(3),is_are(8)
      data ext /'   ','cls','fcl','rep','rep','cmp','avg','cla'/,
     -  gstyp /'GS ','GSC','FCL'/
      data is_are /'are','are',' is',' is',' is',' is','are',' is'/
      data iformtyp /24,13,11/,msgno /15,16,24,13,17,14,19,23/
c     write (iout,*) 'SAVESITES ns,natoms,nslt,nslv=',ns,natoms,
c    -  nslt,nslv
      numsolv=(natoms-nslt)/nslv
      if (ist .le. 3) then
        numsolv=-1
        natp=ns
        if (iwslt .gt. 0) natp=natp+nslt
      else
        natp=natoms
      end if
      iwsltfac=0
      if (iwslt .gt. 0) iwsltfac=1
      if (iwslt .eq. 2) then
c       Replace the current solute with the solute read with the CNFG key
        call trnsfr(c,csltr,3*nslt)
      end if
c     Open output file
      filename1=filename(1:namlenf)//'_gs'//'_'//ext(ist)//'_all'
      namlen1=namlenf+7
      if (ist .eq. 1) then
        namlen1=namlenf+3
      else if (ist .eq. 5) then
        namlen1=namlenf+11
      else
        namlen1=namlenf+7
      end if
      call fileopen(filename1,namlen1,filename1,namlen1,
     -  iformtyp(iopresfor),0,numrun,1,3,0,iop24,iversout,iout,iures,0)
      write (iout,1068) configs(msgno(ist))(1:lconfigs(msgno(ist))),
     -  is_are(ist),filename1(1:namlen1),natp
      if (nslt .gt. 0 .and. sltdmax .gt. 0.01) then
        if (ist .eq. 4 .or. ist .eq. 5) then
          write (iout,1100) ' ','also from the representative structure'
        else
          write (iout,1100) ' ','the last one read'
        end if
      end if
      if (iopresfor .eq. 1) then
c       Write PDB file (keep increasing the version number to avoid overwrite)
        iofac=1
        if (ist .le. 3) iofac=-1
        if (ist .eq. 4 .or. ist .eq. 5) then
          if (namlentf .gt. 44) then
            write (iures,1042) tfilename(1:namlentf),' ',
     -        mcmd,nmcbest
          else
            write (iures,1049) tfilename(1:namlentf),' ',
     -        mcmd,nmcbest
          end if
          write (iures,1100) 'REMARK ','also from the representative'
        else
          if (namlentf .gt. 44) then
            write (iures,1041) tfilename(1:namlentf)
          else
            write (iures,1048) tfilename(1:namlentf)
          end if
          write (iures,1100) 'REMARK ','the last one read'
        end if
        if ((ist .eq. 6 .or. ist .eq. 7) .and. froccmin .gt. 0.0) then
          write (iures,1037) 'REMARK ',froccmin
          write (iout,1037) ' ',froccmin
        end if
        if (ist .eq. 4) then
          write (iures,1073) 'REMARK '
          write (iout,1073) ' '
        else if (ist .eq. 5) then
           write (iures,1085) 'REMARK '
           write (iout,1085) ' '
        end if
        if (iwslt .gt. 0) then
          write (iures,1069) 'REMARK '
          write (iout,1069) ' '
        end if
        if (iwslt .gt. 0 .or. ist .gt. 3) then
          write (iures,1044) 'REMARK '
          write (iout,1044) ' '
        end if
        if (ist .le. 3) then
          write (iures,1043) 'generic site','site RMSD'
          write (iout,1045) 'generic site','site RMSD'
        else if (ist .le. 5) then
          write (iures,1043) 'solvent','site-solvent distance'
          write (iout,1045) 'solvent','site-solvent distance'
        else
          write (iures,1043) 'solvent','site RMSD'
          write (iout,1045) 'solvent','site RMSD'
        end if
        write (iures,1051)
     -    sitesortlab(isorttyp)(1:lsitesortlab(isorttyp))
        nmc=nmclast
        if (ist .eq. 4 .or. ist. eq. 4) nmc=nmcbest
        if (iwslt .gt. 0 .or. ist .gt. 3)
     -    call savepdb('PDBw',keycol,iures,iofac*iout,1,nslt,nslv,c,
     -      numsolv,0,0,0,filename1,namlen1,nmc,0,filename,namlenf,
     -      numrun,1,0,inperr,nwarn,nwwarn,msgno(ist),1,nlwr,0,1,
     -      maxat)
        if (ist .le. 2) then
          write (iures,1013) (nslt+is,' O  ',gstyp(ist),'S',
     -      is+iwsltfac*igrslt(nslt),(cs(k,is),k=1,3),frocc(is),
     -      rdevsw(is),is=1,ns)
        else if (ist .eq. 3) then
          write (iures,1013) (nslt+is,' O  ',gstyp(ist),'S',
     -      iclustno(is),(cs(k,is),k=1,3),frocc(is),
     -      rdevsw(is),is=1,ns)
        end if
        write (iures,1033)
      else if (iopresfor .eq. 2) then
c       Write ASCII file (.crd format)
        write (iout,1050) 'MMC .crd'
        if (iwslt .gt. 0)
     -    write (iures,1011) ((c(k,ia),k=1,3),ia=1,nslt)
        if (ist .le. 3) then
          write (iures,1011) ((cs(k,is),k=1,3),is=1,ns)
        else
          write (iures,1011) ((c(k,ia),k=1,3),ia=nslt+1,natoms)
        end if
      else if (iopresfor .eq. 3) then
c       Write  annotated ASCII file
        write (iout,1050) 'MMC annotated ASCII'
        if (iwslt .gt. 0)
     -    write (iures,1022) (iatnam(ianslt(ia)),(c(k,ia),k=1,3),
     -      igrslt(ia),qslt(ia),ia=1,nslt)
        if (ist .le. 3) then
          write (iures,1012) ((cs(k,is),k=1,3),is,rdevsw(is),is=1,ns)
        else
          write (iures,1022) ((iatnam(ianslv(ia)),
     -      (c(k,nslt+(is-1)*nslv+ia),k=1,3),
     -      igrslt(nslt)+is,rdevsw(is),ia=1,nslv),is=1,numsolv)
        end if
      end if
      call fileclose(iures,0,iop24,iout)
      return
1011  format(3f15.5)
1012  format(' O  ',1x,3f15.5,i5,f10.5)
1013  format('ATOM  ',i5,1x,a4,1x,a3,1x,a1,i4,1x,3x,3f8.3,2f6.2)
1022  format(a4,1x,3f15.5,i5,f10.5)
1033  format('END')
1037  format(a,'Sites with fractional occupancy not less than ',
     -  f6.3,' only')
1041  format('REMARK Generated from history file:',/,'REMARK ',a)
1042  format('REMARK Extracted from history file:',/,'REMARK ',a,a,/,
     -  'REMARK Configuration is from ',a,'=',i10)
1043  format('REMARK Data after the ',a,' coordinates: ',/,
     -  'REMARK fractional occupancy and ',a)
1044  format(a,'Solute data: atomic radius, partial charge')
1045  format(' Data after the ',a,' coordinates: fractional occupancy',
     -  ' and ',a)
1048  format('REMARK Generated from history file ',a)
1049  format('REMARK Extracted from history file ',a,a,/,
     -  'REMARK Configuration is from ',a,'=',i10)
1050  format(' File format: ',a,a,' Solvent charge: site RMSD')
1051  format('REMARK generic sites are sorted by ',a)
1068  format(/,' +++++ ',a,1x,a,' written on the file ',a,
     -  /,7x,'File contains',i6,' atoms')
1069  format(a,'Full solute is written before the generic sites')
1073  format(a,'Solvents with zero occupancy and B factor are ',
     -  'not assigned to any site')
1085  format(a,'Unassigned solvents are not printed')
1100  format(a,'Solute conformation is ',a)
      end
      subroutine filter_traj(nmolec,nslt,nslv,iasite,natoms,ix_solv,
     -  nmolecsave,c,c_save,cv_filt,cv_cut,ndel,nowater,iout,maxix)
c#    MMC routine 490/a lstmod: 06/14/10
      dimension c_save(3,#NA),c(3,#NA),ix_solv(maxix)
      dimension xyz(3),z(3)
      real*8 rxyzsum(3)
c     print *,'FILTER_TRAJ nmolec,nslt,iasite,cv_cut=',
c    -  nmolec,nslt,iasite,cv_cut
      nmolecsave=nmolec
      call trnsfr(c_save,c,3*natoms)
      ndel=0
      cvmax=0.0
      do is=2,nmolec
        call trnsfr(xyz,c(1,nslt+(is-2)*nslv+iasite),3)
        nsum=0.0
        cv=0.0
        call zeroitd(rxyzsum,3)
        do ia=1,nslt
          call arrdiff(z,c(1,ia),xyz,3)
          d2=z(1)**2+z(2)**2+z(3)**2
          if (d2 .lt. cv_cut**2) then
            rr=sqrt(d2)
            nsum=nsum+1
            do k=1,3
              rxyzsum(k)=rxyzsum(k)+z(k)/rr
            end do
          end if
        end do
        if (nsum .gt. 0.0) cv=1.d0-
     -    dsqrt(rxyzsum(1)**2+rxyzsum(2)**2+rxyzsum(3)**2)/dfloat(nsum)
        if (cv .gt. cvmax) cvmax=cv
        if (cv .gt. cv_filt) then
c         Keep this solvent
          if (is-ndel .gt. #MH) then
            write (iout,1000) 'MH'
            call datprt(2)
          end if
          if (ndel .gt. 0) call trnsfr(c(1,nslt+(is-ndel-2)*nslv+1),
     -      c(1,nslt+(is-2)*nslv+1),3*nslv)
          ix_solv(is-ndel)=is
        else
          ndel=ndel+1
        end if
      end do
      nmolec=nmolec-ndel
      natoms=nslt+nslv*(nmolec-1)
      do is=2,nmolec
        ifat=nslt-2*nslv+1+is*nslv
        call checkwater(c(1,ifat),is,0,0,iout,'F',nowater)
      end do
      if (nmolec .eq. 1) write (iout,1001) cvmax
      return
1000  format(' ***** ERROR: number of solvents after trajectory ',
     -  'filtering exceeds limit (#MH) - increase maxhunmat (#',a,')')
1001  format(' ----- WARNING: All solvents were filtered out ',
     -  '- maximum CV found=',f5.2)
      end
      subroutine useframe(ifnd,nmc,nmcdisc,nmclastr,nmcfreq,cvfilt_traj,
     -  nmolec,nslt,nslv,islvrep,natoms,ix_solv,nmolecsave,c,c_save,
     -  cvfilt_trajcut,ndel,iout,ndelsum,nfiltsum,nsmin,nsmax,cplpar,
     -  cplpmin,cplpmax,nowater)
c*****Decide if a frame is to be used in generic site calculation
c#    MMC routine 490/b lstmod: 05/13/14
      dimension c(3,#NA),c_save(3,#NA),ix_solv(#MH)
      common /option/ iop(200),idebug(200)
      ifnd=0
      if (nmc .gt. nmcdisc) then
        if (modrange(nmclastr,nmc,nmcfreq) .eq. 0) then
c         Pick this structure, but filter first
          if (cvfilt_traj .gt. 0.0) then
            call filter_traj(nmolec,nslt,nslv,islvrep,natoms,ix_solv,
     -        nmolecsave,c,c_save,cvfilt_traj,cvfilt_trajcut,ndel,
     -        nowater,iout,#MH)
            ndelsum=ndelsum+ndel
            nfiltsum=nfiltsum+1
          end if
          ifnd=1
          if (iop(97) .gt. 0 .and.
     -        (nmolec-1 .lt. nsmin .or. nmolec-1 .gt. nsmax)) ifnd=0
          if (iop(30) .eq. 7 .and. (cplpar .lt. cplpmin .or.
     -        cplpar .gt. cplpmax)) ifnd=0
        end if
      end if
      nmclastr=nmc
      return
      end
      subroutine checkwater(c,is,nmc,idebug,iout,lab,nowater)
      dimension c(3,3)
      character*1 lab
c*****Check the geometry of a water for distortion
c#    MMC routine 490/c lstmod: 02/03/12
      if (nowater .le. 0) then
        roh1=0.0
        roh2=0.0
        rhh=0.0
        do k=1,3
          roh1=roh1+(c(k,1)-c(k,2))**2
          roh2=roh2+(c(k,1)-c(k,3))**2
          rhh=rhh+(c(k,2)-c(k,3))**2
        end do
        roh1=sqrt(roh1)
        roh2=sqrt(roh2)
        rhh=sqrt(rhh)
        if (idebug .gt. 0)
     -    write (idebug,8725) nmc,is,roh1,roh2,rhh
        diffoh1=abs(roh1-0.95720)
        diffoh2=abs(roh2-0.95720)
        diffhh=abs(rhh-1.51390)
        diff=amax1(diffoh1,diffoh2,diffhh)
        if (diff .gt. 0.2) then
          if (nowater .eq. -1) then
            write (iout,*) 'Solvent appears to be not water'
            nowater=1
          else
            write (iout,*) 'Distorted water found (',lab,'):'
            write (iout,8725) nmc,is,roh1,roh2,rhh,c
          end if
        else
          nowater=0
        end if
      end if
      return
8725  format(' nmc,is=',i10,i5,' roh1,roh2=',2f8.5,' rhh=',f8.5,/,
     -  ' c=',3(3x,3f10.5))
      end
      subroutine checkforhbond(c,iao,iah,iah_ng,natoms,rxhmax2,anglemin,
     -  ihb,ro2,oang,iout)
c*****Check if c(iao)...c(iah)-c(iah_ng) is a hydrogen bond
c#    MMC routine 490/d lstmod: 07/01/13
      dimension c(3,natoms)
c     write (iout,*) 'CHKHB iao=',iao,' iah=',iah,' iah_ng=',iah_ng
      ihb=0
      ro2=arrdist(c(1,iah),c(1,iao))
      if (ro2 .lt. rxhmax2) then
c       Distance ok, check angle
        oang=angleijk(c,natoms,iao,iah,iah_ng,iout)
        if (oang .gt. anglemin) ihb=1
      end if
      return
      end
      subroutine getmodes(iout,iwtemp,rr,diag,offdiag,ix_solv,index,
     -  ifirst,ilast,istemp,imattyp,numrun,ivers,iverb,n,ndim)
c*****Get the eigenvectors, eigenvalues of the matrix rr
c#    MMC routine 490/e lstmod: 05/19/16
      dimension rr(ndim,ndim),diag(ndim),offdiag(ndim),ix_solv(ndim),
     -  index(ndim),ifirst(ndim),ilast(ndim),istemp(ndim)
      character*80 file,filenames,filenamew
      common /filename/ namlenf,namlens(50),iform(50),numrecprev(50),
     -  numrec(50),numframe,file,filenames(50)
      character*3 namunit
      common /extnames/ namunit(50)
      dimension llabel(5)
      character*21 label(5)
      data label /'Covariance','Correlation','Energy','Hydrogen bond',
     -  'Occupancy correlation'/
     -  llabel /10,11,6,13,21/
      call indexit(index,1,n,0)
      call tred2(rr,n,ndim,diag,offdiag)
      call tqli(diag,offdiag,n,ndim,rr,iout,ifail)
      if (ifail .eq. 0) then
c       Columns of rr are the eigenvectors
        do i=1,n
          diag(i)=-diag(i)
        end do
        call mrgsrt(iout,index,diag,n,ifirst,ilast,istemp,offdiag,
     -    #MH)
        write (iout,1000) label(imattyp)(1:llabel(imattyp))
        do i=1,n
          write (iout,1001) i,-diag(i),(rr(ix_solv(j),index(i)),j=1,n)
        end do
        ift=35+imattyp
        filenamew=filenames(ift)
        filenamew(namlens(ift)-3:namlens(ift)-3)='_'
        call fileopen(filenamew,namlens(ift),filenames(42),namlens(42),
     -    42,0,numrun,ivers,3,0,iverb,iversout,iout,iu,0)
        do i=1,n
          write (iu,1002) -diag(i),(rr(ix_solv(j),index(i)),j=1,n)
        end do
        write (iout,2000) filenames(42)(1:namlens(42))
        call fileclose(iu,0,iverb,iout)
      else
        write (iout,1003) label(imattyp)(1:llabel(imattyp))
      end if
c     Restore rr
      rewind iwtemp
      read (iwtemp) rr
      do i=1,n
        diag(i)=rr(i,i)
      end do
      return
1000  format(1x,a,' matrix')
1001  format(i5,' Eigenvalue=',e12.5,' Eigenvector:'/,(10e12.4))
1002  format(e13.5,#MHe13.5)
1003  format(' ***** ERROR: diagonalization failed for the ',a,
     -  ' matrix')
2000  format(' Eigenvalues and eigenvectors were written to file ',a)
      end
      subroutine phs_setup(iop,MYRANK)
c*****Read/initialize primary hydration shell parameters
c#    MMC routine 491 lstmod: 09/29/12
      dimension iop(200)
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      common /io/ inpt,iout,ifiles(10),ic0,itx,inperr,nwarn,nwwarn,nchng
      call getreal(uphsref,1,0.0)
      call getreal(phsk,1,0.0)
      phsk=phsk/2.0
      call getreal(rphs,1,0.0)
      call getreal(rphsmin,1,0.0)
      call getreal(rphsmax,1,0.0)
c     Use a fixed gridsize - leave room for 20 A shell width
      maxphsgrid=2000
      gphs=0.01
      do ig=1,maxphsgrid
        rphsdst(ig)=rphsmin+ig*gphs-gphs/2.0
      end do
      maxphs=(rphsmax-rphsmin)*gphs
      if (maxphs .gt. maxphsgrid) then
        rphsmax=rphsmin+100.0
        if (MYRANK .eq. 0) write (iout,2077) rphsmax
        nchng=nchng+1
      end if
      call getreal(denphs,0,0.997)
      call getint(nmcphs,0,1,#MO)
      call getreal(ranboxedge,0,1000.0)
      igphswid=maxphsgrid
      if (iop(93) .eq. 2) then
         call getreal(rphswid,0,rphsmax)
         igphswid=rphswid/gphs
      end if
      call readpairlist(naphsrange,iaphsrange,20,0,'iaphsrange',
     -  'PHS solute atoms',' ',iout,inperr,nwarn,1,nchng,0,0,0,0)
      if (iop(43) .eq. 0) then
        if (MYRANK .eq. 0) write (iout,2219)
        iop(43)=1
        nchng=nchng+1
      end if
      if (iop(7) .eq. 2) then
        if (MYRANK .eq. 0) write (iout,2220)
        inperr=inperr+1
      end if
      call initbc(iop(5),ranboxedge,ranboxedge,ranboxedge,iop(24),
     -  inpt,iout)
      usphsout=0.d0
      ussphsout=0.d0
      rnphsout=0.d0
      return
2077  format(' >>>>> OVERRIDE: Current dimensions limit the hydration ',
     -  ' shell to 100 A - rphsmax is set to ',f8.3,' A')
2219  format(' >>>>> OVERRIDE: PHS option requires group-center-based ',
     -  'cutoff (SUVC SPGC or SUVC MIGC)')
2220  format(' ***** ERROR: PHS option is incompatible with iso-',
     -  'electric cutoff (PBCN ISOE)')
      end
      subroutine initphs(nmolf,nmolec,nmc,ephs,rijps,rmax)
c*****Initialize primary hydration shell distributions
c#    MMC routine 491/a lstmod: 03/05/04
      real*8 ephs
      dimension rijps(#MO)
      real*8 usphsout,ussphsout,rnphsout
      common /primhydsh/ usphsout,ussphsout,rnphsout,uphsref,rphs,
     -  rphsmin,rphsmax,phsk,gphs,denphs,rphswid,uphs(#MS),
     -  uphsn(#MS),rphsdst(2000),iphsdst(2000),igphswid,nmcphs,
     -  nmcphslast,igphsmax,nphsout,nphsoutn,maxphsgrid,naphsrange,
     -  iaphsrange(2,20),iaphsslt(#ST),iphsoutn(#MS),iphsout(#MS)
      call zeroiti(iphsdst,0,maxphsgrid)
      nmcphslast=nmc
      ephs=0.d0
      nphsout=0
      rmax=0.0
      do is=nmolf,nmolec
        if (rmax .lt. rijps(is)) rmax=rijps(is)
        if (rijps(is) .gt. rphs) then
          nphsout=nphsout+1
          iphsout(nphsout)=is
          uphs(is)=phsk*(rijps(is)-rphs)**2
          ephs=ephs+uphs(is)
        else
          uphs(is)=0.0
        end if
      end do
      return
      end
      subroutine phspx(is,ipx,rpx,rpx0,rpx1,iaphsslt)
c#    MMC routine 389 lstmod: 02/10/02
c*****Find the proximal heavy atom to a solvent (for PHS model calc)
      dimension iaphsslt(#ST)
      common /solute/ cslt(3,#ST),qslt(#ST),gcut2(#GR),
     -  indxrdf(#ST),nstfa0,nstfa1,nstfa,nstta,nstfg0,nstfg1,nstfg,
     -  nsttg,nsltpardis,nsttia0,nsttia1,nstfm0,nstfm1,nstfm,nsttm,
     -  movmolf,movmoll,nsltpr,nstta3,nsvtmx,ic00,ic01,nsltu,nsltgru,
     -  nstcopa,istf,igstf,molstf,molstfti,nstta_full,indextyp(#UU),
     -  nsltcp(9),indats(#SV),iclslt(#ST),iclsltt(#ST),
     -  ianslt(#ST),iopslt(#ST),isltmv(#ST),ixislt(#ST),
     -  mask(#ST),igrslt(#ST),ifgrslt(#GR),ilgrslt(#GR),
     -  igrcnt(#GR),iamolslt(#ST),molcnt(#MM),moltused(#MM),
     -  ifirstm(#MM),ilastm(#MM),ifgrmolslt(#MM),ilgrmolslt(#MM),
     -  nsttainp,nsltpxgr,nsltpx1,nsltpx2,ixyz(3),ixyzinv(3)
      common /intslt/ npfgr(4),lclen,ipftor(#TL),ipfgr(#GR),
     -  ifpfgr(#GR),ilpfgr(#GR),nstsvgr(#GR),nslvggr(#GR),
     -  igrpf(#ST)
      common /solvnt/ cslv(3,#SV),qslv(#SV),sigpxa,nslv,nslvsv,nslv3,
     -  islvrep,ixrep3(3),nrep3,nijgvv,nijgvvp,islvirep(#ND),
     -  islvjrep(#ND),ianslv(#SV)
      common /ctotal/ c(3,#NA),orient(3,3,#MO)
      common /epssig/ sigslv(#SV),epsslv(#SV),sigslt(#ST),epsslt(#ST),
     -  sig14(#ST),eps14(#ST),ntypused
      character*4 iatnam
      character*6 pflab
      common /atmdat/ aw(99),vdw(99),iatnam(99),ianprt(99),
     -  ianfg(99),iatnos(#AT,11),ifcnos(#AT,11),pflab(#AT,11)
      common /option/ iop(200),idebug(200)
      dimension cis(3)
      call trnsfr(cis,c(1,nstta+(is-2)*nslv+islvrep),3)
      rpx0=100000.0
      do ig=npfgr(3)+1,npfgr(4)
        do ia=ifgrslt(ig),ilgrslt(ig)
          if (iaphsslt(ia) .gt. 1) then
            rpxn=arrdist(cis,c(1,ia))
            if (rpxn .lt. rpx0) then
              rpx0=rpxn
              ipx=ia
            end if
          end if
        end do
      end do
      rpx1=sqrt(rpx0)
      if (iop(92) .eq. 1) then
        rpx=amax1(0.0,rpx1-vdw(ianslt(ipx)))
      else if (iop(92) .eq. 2) then
        rpx=amax1(0.0,rpx1-sigslt(ipx)/2.0)
      end if
      return
      end
